// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var CAst$ReactTemplate = require("../src/cAst.bs.js");
var Pcoq$ReactTemplate = require("../src/pcoq.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var default_constr_levels_000 = /* :: */[
  /* tuple */[
    200,
    /* RightA */1,
    /* false */0
  ],
  /* :: */[
    /* tuple */[
      100,
      /* RightA */1,
      /* false */0
    ],
    /* :: */[
      /* tuple */[
        99,
        /* RightA */1,
        /* true */1
      ],
      /* :: */[
        /* tuple */[
          90,
          /* RightA */1,
          /* true */1
        ],
        /* :: */[
          /* tuple */[
            10,
            /* LeftA */2,
            /* false */0
          ],
          /* :: */[
            /* tuple */[
              9,
              /* RightA */1,
              /* false */0
            ],
            /* :: */[
              /* tuple */[
                8,
                /* RightA */1,
                /* true */1
              ],
              /* :: */[
                /* tuple */[
                  1,
                  /* LeftA */2,
                  /* false */0
                ],
                /* :: */[
                  /* tuple */[
                    0,
                    /* RightA */1,
                    /* false */0
                  ],
                  /* [] */0
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
];

var default_constr_levels_001 = /* :: */[
  /* tuple */[
    200,
    /* RightA */1,
    /* true */1
  ],
  /* :: */[
    /* tuple */[
      100,
      /* RightA */1,
      /* false */0
    ],
    /* :: */[
      /* tuple */[
        99,
        /* RightA */1,
        /* true */1
      ],
      /* :: */[
        /* tuple */[
          90,
          /* RightA */1,
          /* true */1
        ],
        /* :: */[
          /* tuple */[
            10,
            /* LeftA */2,
            /* false */0
          ],
          /* :: */[
            /* tuple */[
              1,
              /* LeftA */2,
              /* false */0
            ],
            /* :: */[
              /* tuple */[
                0,
                /* RightA */1,
                /* false */0
              ],
              /* [] */0
            ]
          ]
        ]
      ]
    ]
  ]
];

var default_constr_levels = /* tuple */[
  default_constr_levels_000,
  default_constr_levels_001
];

function admissible_assoc(param) {
  switch (param[0]) {
    case 0 : 
        return /* true */1;
    case 1 : 
        var match = param[1];
        if (match && match[0] >= 2) {
          return /* false */0;
        } else {
          return /* true */1;
        }
    case 2 : 
        var match$1 = param[1];
        if (match$1 && match$1[0] < 2) {
          return /* false */0;
        } else {
          return /* true */1;
        }
    
  }
}

function create_assoc(param) {
  if (param) {
    return param[0];
  } else {
    return /* RightA */1;
  }
}

function create_pos(param) {
  if (param) {
    return /* After */Block.__(1, [Pervasives.string_of_int(param[0])]);
  } else {
    return /* First */0;
  }
}

function find_position_gen(current, ensure, assoc, lev) {
  if (lev) {
    var n = lev[0];
    var after = [/* None */0];
    var init = [/* None */0];
    var add_level = function (q, l) {
      var exit = 0;
      if (l) {
        var l$1 = l[1];
        var pa = l[0];
        var a = pa[1];
        var p = pa[0];
        if (p > n) {
          return /* :: */[
                  pa,
                  add_level(/* Some */[p], l$1)
                ];
        } else if (p === n) {
          if (pa[2]) {
            var a$prime = create_assoc(assoc);
            init[0] = /* Some */[/* tuple */[
                a$prime,
                create_pos(q)
              ]];
            return /* :: */[
                    /* tuple */[
                      p,
                      a$prime,
                      /* false */0
                    ],
                    l$1
                  ];
          } else if (admissible_assoc(/* tuple */[
                  a,
                  assoc
                ])) {
            throw Pervasives.Exit;
          } else {
            var p$1 = p;
            var current = a;
            var expected = Option$ReactTemplate.get(assoc);
            var pr_assoc = function (param) {
              switch (param) {
                case 0 : 
                    return Pp$ReactTemplate.str("non");
                case 1 : 
                    return Pp$ReactTemplate.str("right");
                case 2 : 
                    return Pp$ReactTemplate.str("left");
                
              }
            };
            return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Level "), Pp$ReactTemplate.$$int(p$1)), Pp$ReactTemplate.str(" is already declared ")), pr_assoc(current)), Pp$ReactTemplate.str(" associative while it is now expected to be ")), pr_assoc(expected)), Pp$ReactTemplate.str(" associative.")));
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        after[0] = q;
        return /* :: */[
                /* tuple */[
                  n,
                  create_assoc(assoc),
                  ensure
                ],
                l
              ];
      }
      
    };
    try {
      var updated = add_level(/* None */0, current);
      var assoc$1 = create_assoc(assoc);
      var match = init[0];
      if (match) {
        return /* tuple */[
                updated,
                /* tuple */[
                  /* Some */[/* Level */Block.__(2, [Pervasives.string_of_int(n)])],
                  /* None */0,
                  /* None */0,
                  init[0]
                ]
              ];
      } else {
        return /* tuple */[
                updated,
                /* tuple */[
                  /* Some */[create_pos(after[0])],
                  /* Some */[assoc$1],
                  /* Some */[Pervasives.string_of_int(n)],
                  /* None */0
                ]
              ];
      }
    }
    catch (exn){
      if (exn === Pervasives.Exit) {
        return /* tuple */[
                current,
                /* tuple */[
                  /* Some */[/* Level */Block.__(2, [Pervasives.string_of_int(n)])],
                  /* None */0,
                  /* None */0,
                  /* None */0
                ]
              ];
      } else {
        throw exn;
      }
    }
  } else {
    return /* tuple */[
            current,
            /* tuple */[
              /* None */0,
              /* None */0,
              /* None */0,
              /* None */0
            ]
          ];
  }
}

function list_mem_assoc_triple(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (param[0][0] === x) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function register_empty_levels(accu, forpat, levels) {
  var filter = function (accu, param) {
    if (param) {
      var n = param[0];
      var match = filter(accu, param[1]);
      var accu$1 = match[1];
      var plev = accu$1[1];
      var clev = accu$1[0];
      var rem = match[0];
      var levels = forpat ? plev : clev;
      if (list_mem_assoc_triple(n, levels)) {
        return /* tuple */[
                rem,
                accu$1
              ];
      } else {
        var match$1 = find_position_gen(levels, /* true */1, /* None */0, /* Some */[n]);
        var nlev = match$1[0];
        var nlev$1 = forpat ? /* tuple */[
            clev,
            nlev
          ] : /* tuple */[
            nlev,
            plev
          ];
        return /* tuple */[
                /* :: */[
                  match$1[1],
                  rem
                ],
                nlev$1
              ];
      }
    } else {
      return /* tuple */[
              /* [] */0,
              accu
            ];
    }
  };
  return filter(accu, levels);
}

function find_position(accu, forpat, assoc, level) {
  var plev = accu[1];
  var clev = accu[0];
  var levels = forpat ? plev : clev;
  var match = find_position_gen(levels, /* false */0, assoc, level);
  var nlev = match[0];
  var nlev$1 = forpat ? /* tuple */[
      clev,
      nlev
    ] : /* tuple */[
      nlev,
      plev
    ];
  return /* tuple */[
          match[1],
          nlev$1
        ];
}

function interp_constr_entry_key(forpat, level) {
  if (forpat !== 0) {
    return /* tuple */[
            Pcoq$ReactTemplate.Constr[/* pattern */10],
            /* Some */[level]
          ];
  } else if (level === 200) {
    return /* tuple */[
            Pcoq$ReactTemplate.Constr[/* binder_constr */3],
            /* None */0
          ];
  } else {
    return /* tuple */[
            Pcoq$ReactTemplate.Constr[/* operconstr */4],
            /* Some */[level]
          ];
  }
}

function interp_entry(forpat, e) {
  if (typeof e === "number") {
    switch (e) {
      case 0 : 
          return /* TTAny */[/* TTName */0];
      case 1 : 
          return /* TTAny */[/* TTReference */1];
      case 2 : 
          return /* TTAny */[/* TTBigint */2];
      
    }
  } else {
    switch (e.tag | 0) {
      case 0 : 
          return /* TTAny */[/* TTConstr */Block.__(0, [
                      e[0],
                      forpat
                    ])];
      case 1 : 
          return /* TTAny */[/* TTPattern */Block.__(2, [e[0]])];
      case 2 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "egramcoq.ml",
                  313,
                  19
                ]
              ];
      case 3 : 
          return /* TTAny */[/* TTConstrList */Block.__(1, [
                      e[0],
                      e[1],
                      forpat
                    ])];
      case 4 : 
          var match = e[0];
          if (match) {
            return /* TTAny */[/* TTClosedBinderList */Block.__(3, [match[0]])];
          } else {
            return /* TTAny */[/* TTOpenBinderList */3];
          }
      
    }
  }
}

function cases_pattern_expr_of_name(param) {
  var loc = param[/* loc */1];
  var na = param[/* v */0];
  return CAst$ReactTemplate.make(loc, na ? /* CPatAtom */Block.__(2, [/* Some */[CAst$ReactTemplate.make(loc, /* Ident */Block.__(1, [na[0]]))]]) : /* CPatAtom */Block.__(2, [/* None */0]));
}

function push_constr(subst, v) {
  return /* record */[
          /* constrs : :: */[
            v,
            subst[/* constrs */0]
          ],
          /* constrlists */subst[/* constrlists */1],
          /* binders */subst[/* binders */2],
          /* binderlists */subst[/* binderlists */3]
        ];
}

function push_item(forpat, e, subst, v) {
  if (typeof e === "number") {
    switch (e) {
      case 0 : 
          if (forpat !== 0) {
            return push_constr(subst, cases_pattern_expr_of_name(v));
          } else {
            return /* record */[
                    /* constrs */subst[/* constrs */0],
                    /* constrlists */subst[/* constrlists */1],
                    /* binders : :: */[
                      cases_pattern_expr_of_name(v),
                      subst[/* binders */2]
                    ],
                    /* binderlists */subst[/* binderlists */3]
                  ];
          }
      case 1 : 
          if (forpat !== 0) {
            var eta = /* CPatAtom */Block.__(2, [/* Some */[v]]);
            return push_constr(subst, CAst$ReactTemplate.make(/* None */0, eta));
          } else {
            var eta$1 = /* CRef */Block.__(0, [
                v,
                /* None */0
              ]);
            return push_constr(subst, CAst$ReactTemplate.make(/* None */0, eta$1));
          }
          break;
      case 2 : 
          if (forpat !== 0) {
            var eta$2 = /* CPatPrim */Block.__(5, [/* Numeral */Block.__(0, [
                    v,
                    /* true */1
                  ])]);
            return push_constr(subst, CAst$ReactTemplate.make(/* None */0, eta$2));
          } else {
            var eta$3 = /* CPrim */Block.__(19, [/* Numeral */Block.__(0, [
                    v,
                    /* true */1
                  ])]);
            return push_constr(subst, CAst$ReactTemplate.make(/* None */0, eta$3));
          }
          break;
      case 3 : 
          return /* record */[
                  /* constrs */subst[/* constrs */0],
                  /* constrlists */subst[/* constrlists */1],
                  /* binders */subst[/* binders */2],
                  /* binderlists : :: */[
                    v,
                    subst[/* binderlists */3]
                  ]
                ];
      
    }
  } else {
    switch (e.tag | 0) {
      case 0 : 
          return push_constr(subst, v);
      case 1 : 
          return /* record */[
                  /* constrs */subst[/* constrs */0],
                  /* constrlists : :: */[
                    v,
                    subst[/* constrlists */1]
                  ],
                  /* binders */subst[/* binders */2],
                  /* binderlists */subst[/* binderlists */3]
                ];
      case 2 : 
          if (forpat !== 0) {
            return push_constr(subst, v);
          } else {
            return /* record */[
                    /* constrs */subst[/* constrs */0],
                    /* constrlists */subst[/* constrlists */1],
                    /* binders : :: */[
                      v,
                      subst[/* binders */2]
                    ],
                    /* binderlists */subst[/* binderlists */3]
                  ];
          }
      case 3 : 
          return /* record */[
                  /* constrs */subst[/* constrs */0],
                  /* constrlists */subst[/* constrlists */1],
                  /* binders */subst[/* binders */2],
                  /* binderlists : :: */[
                    Curry._1(Util$ReactTemplate.List[/* flatten */8], v),
                    subst[/* binderlists */3]
                  ]
                ];
      
    }
  }
}

function ty_eval(param) {
  if (typeof param === "number") {
    return (function (f, env, loc) {
        return Curry._2(f, loc, env);
      });
  } else if (param.tag) {
    var rem = param[3];
    var p = param[2];
    var b = param[1];
    var n = param[0];
    return (function (f, env) {
        var match = Curry._2(Util$ReactTemplate.List[/* chop */99], n, env[/* constrs */0]);
        var constrs = match[1];
        var heads = match[0];
        var match$1;
        if (b) {
          var constrlist = Curry._1(Util$ReactTemplate.List[/* hd */1], env[/* constrlists */1]);
          var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], Curry._1(Util$ReactTemplate.List[/* length */0], constrlist) - p | 0, constrlist);
          match$1 = /* tuple */[
            /* :: */[
              Util$ReactTemplate.$at(heads, match$2[0]),
              Curry._1(Util$ReactTemplate.List[/* tl */2], env[/* constrlists */1])
            ],
            Util$ReactTemplate.$at(match$2[1], constrs)
          ];
        } else {
          var match$3 = Curry._2(Util$ReactTemplate.List[/* chop */99], n - p | 0, heads);
          match$1 = /* tuple */[
            /* :: */[
              match$3[0],
              env[/* constrlists */1]
            ],
            Util$ReactTemplate.$at(match$3[1], constrs)
          ];
        }
        return Curry._2(ty_eval(rem), f, /* record */[
                    /* constrs */match$1[1],
                    /* constrlists */match$1[0],
                    /* binders */env[/* binders */2],
                    /* binderlists */env[/* binderlists */3]
                  ]);
      });
  } else {
    var match = param[1];
    var rem$1 = param[0];
    if (match.tag) {
      var e = match[1];
      var forpat = match[0];
      if (match[3] !== 0) {
        return (function (f, env, v) {
            return Curry._2(ty_eval(rem$1), f, push_item(forpat, e, env, v));
          });
      } else {
        return (function (f, env, _) {
            return Curry._2(ty_eval(rem$1), f, env);
          });
      }
    } else {
      return (function (f, env, _) {
          return Curry._2(ty_eval(rem$1), f, env);
        });
    }
  }
}

function ty_erase(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return /* Stop */0;
    } else if (param.tag) {
      _param = param[3];
      continue ;
      
    } else {
      var match = param[1];
      var rem = param[0];
      if (match.tag) {
        return /* Next */[
                ty_erase(rem),
                match[2]
              ];
      } else {
        return /* Next */[
                ty_erase(rem),
                /* Atoken */Block.__(0, [match[0]])
              ];
      }
    }
  };
}

function make_ty_rule(_, _$1, forpat, prods) {
  var make_ty_rule$1 = function (param) {
    if (param) {
      var match = param[0];
      switch (match.tag | 0) {
        case 0 : 
            var match$1 = make_ty_rule$1(param[1]);
            return /* AnyTyRule */[/* TyNext */Block.__(0, [
                        match$1[0],
                        /* TyTerm */Block.__(0, [match[0]])
                      ])];
        case 1 : 
            var match$2 = make_ty_rule$1(param[1]);
            var match$3 = interp_entry(forpat, match[0]);
            var s = Pervasives.failwith("undefined: symbol_of_entry");
            var bind = match[1] ? /* true */1 : /* false */0;
            return /* AnyTyRule */[/* TyNext */Block.__(0, [
                        match$2[0],
                        /* TyNonTerm */Block.__(1, [
                            forpat,
                            match$3[0],
                            s,
                            bind
                          ])
                      ])];
        case 2 : 
            var match$4 = make_ty_rule$1(param[1]);
            return /* AnyTyRule */[/* TyMark */Block.__(1, [
                        match[0],
                        match[1],
                        match[2],
                        match$4[0]
                      ])];
        
      }
    } else {
      return /* AnyTyRule */[/* TyStop */0];
    }
  };
  return make_ty_rule$1(Curry._1(Util$ReactTemplate.List[/* rev */4], prods));
}

function target_to_bool(param) {
  if (param !== 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function pure_sublevels(level, _r) {
  while(true) {
    var r = _r;
    if (r) {
      var match = r[1];
      var rem = r[0];
      if (typeof match === "number") {
        _r = rem;
        continue ;
        
      } else if (match.tag === 7) {
        var i = match[1];
        var rem$1 = pure_sublevels(level, rem);
        if (level) {
          if (i === level[0]) {
            return rem$1;
          } else {
            return /* :: */[
                    i,
                    rem$1
                  ];
          }
        } else {
          return /* :: */[
                  i,
                  rem$1
                ];
        }
      } else {
        _r = rem;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function make_act(param) {
  if (param !== 0) {
    return (function (notation, loc, env) {
        var env_000 = env[/* constrs */0];
        var env_001 = env[/* constrlists */1];
        var env$1 = /* tuple */[
          env_000,
          env_001
        ];
        return CAst$ReactTemplate.make(/* Some */[loc], /* CPatNotation */Block.__(4, [
                      notation,
                      env$1,
                      /* [] */0
                    ]));
      });
  } else {
    return (function (notation, loc, env) {
        var env_000 = env[/* constrs */0];
        var env_001 = env[/* constrlists */1];
        var env_002 = env[/* binders */2];
        var env_003 = env[/* binderlists */3];
        var env$1 = /* tuple */[
          env_000,
          env_001,
          env_002,
          env_003
        ];
        return CAst$ReactTemplate.make(/* Some */[loc], /* CNotation */Block.__(17, [
                      notation,
                      env$1
                    ]));
      });
  }
}

function extend_constr(state, forpat, ng) {
  var match = ng[/* notgram_level */0];
  var n = match[0];
  var assoc = ng[/* notgram_assoc */1];
  var match$1 = interp_constr_entry_key(forpat, n);
  var level = match$1[1];
  var entry = match$1[0];
  var fold = function (param, pt) {
    var match = make_ty_rule(assoc, n, forpat, pt);
    var r = match[0];
    var symbs = ty_erase(r);
    var pure_sublevels$1 = pure_sublevels(level, symbs);
    var isforpat = target_to_bool(forpat);
    var match$1 = register_empty_levels(param[1], isforpat, pure_sublevels$1);
    var match$2 = find_position(match$1[1], isforpat, assoc, level);
    var match$3 = match$2[0];
    var empty_rules = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            var forpat = isforpat;
            var param$1 = param;
            var reinit = param$1[3];
            var empty_000 = param$1[0];
            var empty_001 = /* :: */[
              /* tuple */[
                param$1[2],
                param$1[1],
                /* [] */0
              ],
              /* [] */0
            ];
            var empty = /* tuple */[
              empty_000,
              empty_001
            ];
            if (forpat) {
              return /* ExtendRule */[
                      Pcoq$ReactTemplate.Constr[/* pattern */10],
                      reinit,
                      empty
                    ];
            } else {
              return /* ExtendRule */[
                      Pcoq$ReactTemplate.Constr[/* operconstr */4],
                      reinit,
                      empty
                    ];
            }
          }), match$1[0]);
    var act = Curry._2(ty_eval(r), Curry._1(make_act(forpat), ng[/* notgram_notation */2]), /* record */[
          /* constrs : [] */0,
          /* constrlists : [] */0,
          /* binders : [] */0,
          /* binderlists : [] */0
        ]);
    var rule_000 = match$3[2];
    var rule_001 = match$3[1];
    var rule_002 = /* :: */[
      /* Rule */[
        symbs,
        act
      ],
      /* [] */0
    ];
    var rule = /* tuple */[
      rule_000,
      rule_001,
      rule_002
    ];
    var r_001 = match$3[3];
    var r_002 = /* tuple */[
      match$3[0],
      /* :: */[
        rule,
        /* [] */0
      ]
    ];
    var r$1 = /* ExtendRule */[
      entry,
      r_001,
      r_002
    ];
    return /* tuple */[
            Util$ReactTemplate.$at(param[0], Util$ReactTemplate.$at(empty_rules, /* :: */[
                      r$1,
                      /* [] */0
                    ])),
            match$2[1]
          ];
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, /* tuple */[
              /* [] */0,
              state
            ], ng[/* notgram_prods */3]);
}

var constr_levels = Curry._1(Pcoq$ReactTemplate.GramState[/* field */5], /* () */0);

function extend_constr_notation(ng, state) {
  var match = Curry._2(Pcoq$ReactTemplate.GramState[/* get */2], state, constr_levels);
  var levels = match ? match[0] : default_constr_levels;
  var match$1 = extend_constr(levels, /* ForConstr */0, ng);
  var match$2 = extend_constr(match$1[1], /* ForPattern */1, ng);
  var state$1 = Curry._3(Pcoq$ReactTemplate.GramState[/* set */1], state, constr_levels, match$2[1]);
  return /* tuple */[
          Util$ReactTemplate.$at(match$1[0], match$2[0]),
          state$1
        ];
}

var constr_grammar = Pcoq$ReactTemplate.create_grammar_command("Notation", extend_constr_notation);

function extend_constr_grammar(ntn) {
  return Pcoq$ReactTemplate.extend_grammar_command(constr_grammar, ntn);
}

exports.extend_constr_grammar = extend_constr_grammar;
/* constr_levels Not a pure module */
