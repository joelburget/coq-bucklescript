// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Universes$ReactTemplate = require("./universes.bs.js");

function make(s) {
  return s;
}

function kind(sigma, s) {
  if (s.tag) {
    return Sorts$ReactTemplate.sort_of_univ(Evd$ReactTemplate.normalize_universe(sigma)(s[0]));
  } else {
    return s;
  }
}

function unsafe_to_sorts(s) {
  return s;
}

function make$1(i) {
  return i;
}

function kind$1(sigma, i) {
  if (Univ$ReactTemplate.Instance[/* is_empty */1](i)) {
    return i;
  } else {
    return Evd$ReactTemplate.normalize_universe_instance(sigma, i);
  }
}

var empty = Univ$ReactTemplate.Instance[/* empty */0];

var is_empty = Univ$ReactTemplate.Instance[/* is_empty */1];

function unsafe_to_instance(t) {
  return t;
}

function safe_evar_value(sigma, ev) {
  try {
    return /* Some */[Evd$ReactTemplate.existential_value(sigma, ev)];
  }
  catch (exn){
    if (exn === Evd$ReactTemplate.NotInstantiatedEvar) {
      return /* None */0;
    } else if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function whd_evar(sigma, _c) {
  while(true) {
    var c = _c;
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 3 : 
          var match$1 = safe_evar_value(sigma, match[0]);
          if (match$1) {
            _c = match$1[0];
            continue ;
            
          } else {
            return c;
          }
          break;
      case 5 : 
          var c0 = match[0];
          if (Constr$ReactTemplate.isEvar(c0)) {
            var ev = Constr$ReactTemplate.destEvar(c0);
            var match$2 = safe_evar_value(sigma, ev);
            if (match$2) {
              _c = Constr$ReactTemplate.mkCast(/* tuple */[
                    match$2[0],
                    match[1],
                    match[2]
                  ]);
              continue ;
              
            } else {
              return c;
            }
          } else {
            return c;
          }
          break;
      case 9 : 
          var f = match[0];
          if (Constr$ReactTemplate.isEvar(f)) {
            var ev$1 = Constr$ReactTemplate.destEvar(f);
            var match$3 = safe_evar_value(sigma, ev$1);
            if (match$3) {
              _c = Constr$ReactTemplate.mkApp(/* tuple */[
                    match$3[0],
                    match[1]
                  ]);
              continue ;
              
            } else {
              return c;
            }
          } else {
            return c;
          }
          break;
      default:
        return c;
    }
  };
}

function kind$2(sigma, c) {
  return Constr$ReactTemplate.kind(whd_evar(sigma, c));
}

function kind_of_type(sigma, c) {
  return Term$ReactTemplate.kind_of_type(whd_evar(sigma, c));
}

function of_constr(c) {
  return c;
}

function unsafe_to_constr(c) {
  return c;
}

function to_constr(sigma, _c) {
  while(true) {
    var c = _c;
    var match = Constr$ReactTemplate.kind(c);
    var exit = 0;
    switch (match.tag | 0) {
      case 3 : 
          var match$1 = safe_evar_value(sigma, match[0]);
          if (match$1) {
            _c = match$1[0];
            continue ;
            
          } else {
            return Constr$ReactTemplate.map((function (c) {
                          return to_constr(sigma, c);
                        }), c);
          }
          break;
      case 4 : 
          var match$2 = match[0];
          if (match$2.tag) {
            var u = match$2[0];
            var u$prime = Evd$ReactTemplate.normalize_universe(sigma)(u);
            if (u$prime === u) {
              return c;
            } else {
              return Constr$ReactTemplate.mkSort(Sorts$ReactTemplate.sort_of_univ(u$prime));
            }
          } else {
            exit = 1;
          }
          break;
      case 10 : 
          var match$3 = match[0];
          var u$1 = match$3[1];
          if (Univ$ReactTemplate.Instance[/* is_empty */1](u$1)) {
            exit = 1;
          } else {
            var u$prime$1 = Evd$ReactTemplate.normalize_universe_instance(sigma, u$1);
            if (u$prime$1 === u$1) {
              return c;
            } else {
              return Constr$ReactTemplate.mkConstU(/* tuple */[
                          match$3[0],
                          u$prime$1
                        ]);
            }
          }
          break;
      case 11 : 
          var match$4 = match[0];
          var u$2 = match$4[1];
          if (Univ$ReactTemplate.Instance[/* is_empty */1](u$2)) {
            exit = 1;
          } else {
            var u$prime$2 = Evd$ReactTemplate.normalize_universe_instance(sigma, u$2);
            if (u$prime$2 === u$2) {
              return c;
            } else {
              return Constr$ReactTemplate.mkIndU(/* tuple */[
                          match$4[0],
                          u$prime$2
                        ]);
            }
          }
          break;
      case 12 : 
          var match$5 = match[0];
          var u$3 = match$5[1];
          if (Univ$ReactTemplate.Instance[/* is_empty */1](u$3)) {
            exit = 1;
          } else {
            var u$prime$3 = Evd$ReactTemplate.normalize_universe_instance(sigma, u$3);
            if (u$prime$3 === u$3) {
              return c;
            } else {
              return Constr$ReactTemplate.mkConstructU(/* tuple */[
                          match$5[0],
                          u$prime$3
                        ]);
            }
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      return Constr$ReactTemplate.map((function (c) {
                    return to_constr(sigma, c);
                  }), c);
    }
    
  };
}

function of_named_decl(d) {
  return d;
}

function unsafe_to_named_decl(d) {
  return d;
}

function of_rel_decl(d) {
  return d;
}

function unsafe_to_rel_decl(d) {
  return d;
}

function to_rel_decl(sigma, d) {
  return Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], (function (param) {
                return to_constr(sigma, param);
              }), d);
}

function in_punivs(a) {
  return /* tuple */[
          a,
          empty
        ];
}

var mkProp = Constr$ReactTemplate.of_kind(/* Sort */Block.__(4, [Sorts$ReactTemplate.prop]));

var mkSet = Constr$ReactTemplate.of_kind(/* Sort */Block.__(4, [Sorts$ReactTemplate.set]));

function mkType(u) {
  return Constr$ReactTemplate.of_kind(/* Sort */Block.__(4, [/* Type */Block.__(1, [u])]));
}

function mkRel(n) {
  return Constr$ReactTemplate.of_kind(/* Rel */Block.__(0, [n]));
}

function mkVar(id) {
  return Constr$ReactTemplate.of_kind(/* Var */Block.__(1, [id]));
}

function mkMeta(n) {
  return Constr$ReactTemplate.of_kind(/* Meta */Block.__(2, [n]));
}

function mkEvar(e) {
  return Constr$ReactTemplate.of_kind(/* Evar */Block.__(3, [e]));
}

function mkSort(s) {
  return Constr$ReactTemplate.of_kind(/* Sort */Block.__(4, [s]));
}

function mkCast(param) {
  return Constr$ReactTemplate.of_kind(/* Cast */Block.__(5, [
                param[0],
                param[1],
                param[2]
              ]));
}

function mkProd(param) {
  return Constr$ReactTemplate.of_kind(/* Prod */Block.__(6, [
                param[0],
                param[1],
                param[2]
              ]));
}

function mkLambda(param) {
  return Constr$ReactTemplate.of_kind(/* Lambda */Block.__(7, [
                param[0],
                param[1],
                param[2]
              ]));
}

function mkLetIn(param) {
  return Constr$ReactTemplate.of_kind(/* LetIn */Block.__(8, [
                param[0],
                param[1],
                param[2],
                param[3]
              ]));
}

function mkApp(param) {
  return Constr$ReactTemplate.of_kind(/* App */Block.__(9, [
                param[0],
                param[1]
              ]));
}

function mkConstU(pc) {
  return Constr$ReactTemplate.of_kind(/* Const */Block.__(10, [pc]));
}

function mkConst(c) {
  return Constr$ReactTemplate.of_kind(/* Const */Block.__(10, [in_punivs(c)]));
}

function mkIndU(pi) {
  return Constr$ReactTemplate.of_kind(/* Ind */Block.__(11, [pi]));
}

function mkInd(i) {
  return Constr$ReactTemplate.of_kind(/* Ind */Block.__(11, [in_punivs(i)]));
}

function mkConstructU(pc) {
  return Constr$ReactTemplate.of_kind(/* Construct */Block.__(12, [pc]));
}

function mkConstruct(c) {
  return Constr$ReactTemplate.of_kind(/* Construct */Block.__(12, [in_punivs(c)]));
}

function mkConstructUi(param) {
  var match = param[0];
  return Constr$ReactTemplate.of_kind(/* Construct */Block.__(12, [/* tuple */[
                  /* tuple */[
                    match[0],
                    param[1]
                  ],
                  match[1]
                ]]));
}

function mkCase(param) {
  return Constr$ReactTemplate.of_kind(/* Case */Block.__(13, [
                param[0],
                param[1],
                param[2],
                param[3]
              ]));
}

function mkFix(f) {
  return Constr$ReactTemplate.of_kind(/* Fix */Block.__(14, [f]));
}

function mkCoFix(f) {
  return Constr$ReactTemplate.of_kind(/* CoFix */Block.__(15, [f]));
}

function mkProj(param) {
  return Constr$ReactTemplate.of_kind(/* Proj */Block.__(16, [
                param[0],
                param[1]
              ]));
}

function mkArrow(t1, t2) {
  return Constr$ReactTemplate.of_kind(/* Prod */Block.__(6, [
                /* Anonymous */0,
                t1,
                t2
              ]));
}

function applist(param) {
  return mkApp(/* tuple */[
              param[0],
              Util$ReactTemplate.$$Array[/* of_list */10](param[1])
            ]);
}

function isRel(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function isVar(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 1) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isInd(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 11) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isEvar(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 3) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isMeta(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 2) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isSort(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 4) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isCast(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 5) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isApp(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 9) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isLambda(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 7) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isLetIn(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 8) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isProd(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 6) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isConst(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 10) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isConstruct(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 12) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isFix(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 14) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isCoFix(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 15) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isCase(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 13) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isProj(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 16) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isVarId(sigma, id, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 1) {
    return Names$ReactTemplate.Id[/* equal */0](id, match[0]);
  } else {
    return /* false */0;
  }
}

function isRelN(sigma, n, c) {
  var match = kind$2(sigma, c);
  if (match.tag) {
    return /* false */0;
  } else {
    return +(n === match[0]);
  }
}

function destRel(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag) {
    throw Constr$ReactTemplate.DestKO;
  } else {
    return match[0];
  }
}

function destVar(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 1) {
    return match[0];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destInd(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 11) {
    return match[0];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destEvar(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 3) {
    return match[0];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destMeta(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 2) {
    return match[0];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destSort(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 4) {
    return match[0];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destCast(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 5) {
    return /* tuple */[
            match[0],
            match[1],
            match[2]
          ];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destApp(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 9) {
    return /* tuple */[
            match[0],
            match[1]
          ];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destLambda(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 7) {
    return /* tuple */[
            match[0],
            match[1],
            match[2]
          ];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destLetIn(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 8) {
    return /* tuple */[
            match[0],
            match[1],
            match[2],
            match[3]
          ];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destProd(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 6) {
    return /* tuple */[
            match[0],
            match[1],
            match[2]
          ];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destConst(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 10) {
    return match[0];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destConstruct(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 12) {
    return match[0];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destFix(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 14) {
    return match[0];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destCoFix(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 15) {
    return match[0];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destCase(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 13) {
    return /* tuple */[
            match[0],
            match[1],
            match[2],
            match[3]
          ];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function destProj(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 16) {
    return /* tuple */[
            match[0],
            match[1]
          ];
  } else {
    throw Constr$ReactTemplate.DestKO;
  }
}

function decompose_app(sigma, c) {
  var match = kind$2(sigma, c);
  if (match.tag === 9) {
    return /* tuple */[
            match[0],
            Util$ReactTemplate.$$Array[/* to_list */9](match[1])
          ];
  } else {
    return /* tuple */[
            c,
            /* [] */0
          ];
  }
}

function decompose_lam(sigma, c) {
  var _l = /* [] */0;
  var _c = c;
  while(true) {
    var c$1 = _c;
    var l = _l;
    var match = kind$2(sigma, c$1);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 7 : 
          _c = match[2];
          _l = /* :: */[
            /* tuple */[
              match[0],
              match[1]
            ],
            l
          ];
          continue ;
          default:
        return /* tuple */[
                l,
                c$1
              ];
    }
  };
}

function decompose_lam_assum(sigma, c) {
  var _l = Context$ReactTemplate.Rel[/* empty */1];
  var _c = c;
  while(true) {
    var c$1 = _c;
    var l = _l;
    var match = kind$2(sigma, c$1);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 7 : 
          _c = match[2];
          _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                  match[0],
                  match[1]
                ]), l);
          continue ;
          case 8 : 
          _c = match[3];
          _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                  match[0],
                  match[1],
                  match[2]
                ]), l);
          continue ;
          default:
        return /* tuple */[
                l,
                c$1
              ];
    }
  };
}

function decompose_lam_n_assum(sigma, n, c) {
  if (n < 0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n_assum: integer parameter must be positive"));
  }
  var _l = Context$ReactTemplate.Rel[/* empty */1];
  var _n = n;
  var _c = c;
  while(true) {
    var c$1 = _c;
    var n$1 = _n;
    var l = _l;
    if (n$1) {
      var c$2 = kind$2(sigma, c$1);
      switch (c$2.tag | 0) {
        case 5 : 
            _c = c$2[0];
            continue ;
            case 7 : 
            _c = c$2[2];
            _n = n$1 - 1 | 0;
            _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                    c$2[0],
                    c$2[1]
                  ]), l);
            continue ;
            case 8 : 
            _c = c$2[3];
            _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                    c$2[0],
                    c$2[1],
                    c$2[2]
                  ]), l);
            continue ;
            default:
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n_assum: not enough abstractions"));
      }
    } else {
      return /* tuple */[
              l,
              c$1
            ];
    }
  };
}

function decompose_lam_n_decls(sigma, n) {
  if (n < 0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n_decls: integer parameter must be positive"));
  }
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _l = partial_arg;
      var _n = n;
      var _c = param;
      while(true) {
        var c = _c;
        var n$1 = _n;
        var l = _l;
        if (n$1) {
          var c$1 = kind$2(sigma, c);
          switch (c$1.tag | 0) {
            case 5 : 
                _c = c$1[0];
                continue ;
                case 7 : 
                _c = c$1[2];
                _n = n$1 - 1 | 0;
                _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                        c$1[0],
                        c$1[1]
                      ]), l);
                continue ;
                case 8 : 
                _c = c$1[3];
                _n = n$1 - 1 | 0;
                _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                        c$1[0],
                        c$1[1],
                        c$1[2]
                      ]), l);
                continue ;
                default:
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n_decls: not enough abstractions"));
          }
        } else {
          return /* tuple */[
                  l,
                  c
                ];
        }
      };
    });
}

function compose_lam(l, b) {
  var n = Curry._1(Util$ReactTemplate.List[/* length */0], l);
  var env = l;
  var b$1 = b;
  var _param = /* tuple */[
    n,
    env,
    b$1
  ];
  while(true) {
    var param = _param;
    var n$1 = param[0];
    if (n$1 !== 0) {
      var match = param[1];
      if (match) {
        var match$1 = match[0];
        _param = /* tuple */[
          n$1 - 1 | 0,
          match[1],
          mkLambda(/* tuple */[
                match$1[0],
                match$1[1],
                param[2]
              ])
        ];
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "eConstr.ml",
                335,
                11
              ]
            ];
      }
    } else {
      return param[2];
    }
  };
}

function to_lambda(sigma, n, _prod) {
  while(true) {
    var prod = _prod;
    if (n) {
      var match = kind$2(sigma, prod);
      switch (match.tag | 0) {
        case 5 : 
            _prod = match[0];
            continue ;
            case 6 : 
            return mkLambda(/* tuple */[
                        match[0],
                        match[1],
                        to_lambda(sigma, n - 1 | 0, match[2])
                      ]);
        default:
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["to_lambda"], Pp$ReactTemplate.mt(/* () */0));
      }
    } else {
      return prod;
    }
  };
}

function decompose_prod(sigma, c) {
  var _l = /* [] */0;
  var _c = c;
  while(true) {
    var c$1 = _c;
    var l = _l;
    var match = kind$2(sigma, c$1);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          _l = /* :: */[
            /* tuple */[
              match[0],
              match[1]
            ],
            l
          ];
          continue ;
          default:
        return /* tuple */[
                l,
                c$1
              ];
    }
  };
}

function decompose_prod_assum(sigma, c) {
  var _l = Context$ReactTemplate.Rel[/* empty */1];
  var _c = c;
  while(true) {
    var c$1 = _c;
    var l = _l;
    var match = kind$2(sigma, c$1);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                  match[0],
                  match[1]
                ]), l);
          continue ;
          case 8 : 
          _c = match[3];
          _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                  match[0],
                  match[1],
                  match[2]
                ]), l);
          continue ;
          default:
        return /* tuple */[
                l,
                c$1
              ];
    }
  };
}

function decompose_prod_n_assum(sigma, n, c) {
  if (n < 0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_prod_n_assum: integer parameter must be positive"));
  }
  var _l = Context$ReactTemplate.Rel[/* empty */1];
  var _n = n;
  var _c = c;
  while(true) {
    var c$1 = _c;
    var n$1 = _n;
    var l = _l;
    if (n$1) {
      var c$2 = kind$2(sigma, c$1);
      switch (c$2.tag | 0) {
        case 5 : 
            _c = c$2[0];
            continue ;
            case 6 : 
            _c = c$2[2];
            _n = n$1 - 1 | 0;
            _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                    c$2[0],
                    c$2[1]
                  ]), l);
            continue ;
            case 8 : 
            _c = c$2[3];
            _n = n$1 - 1 | 0;
            _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                    c$2[0],
                    c$2[1],
                    c$2[2]
                  ]), l);
            continue ;
            default:
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_prod_n_assum: not enough assumptions"));
      }
    } else {
      return /* tuple */[
              l,
              c$1
            ];
    }
  };
}

function existential_type(sigma, param) {
  return Evd$ReactTemplate.existential_type(sigma, /* tuple */[
              param[0],
              Util$ReactTemplate.$$Array[/* map */12](unsafe_to_constr, param[1])
            ]);
}

function map(sigma, f, c) {
  var match = kind$2(sigma, c);
  switch (match.tag | 0) {
    case 3 : 
        var match$1 = match[0];
        var l = match$1[1];
        var l$prime = Util$ReactTemplate.$$Array[/* smartmap */47](f, l);
        if (l$prime === l) {
          return c;
        } else {
          return Constr$ReactTemplate.of_kind(/* Evar */Block.__(3, [/* tuple */[
                          match$1[0],
                          l$prime
                        ]]));
        }
    case 5 : 
        var t = match[2];
        var b = match[0];
        var b$prime = Curry._1(f, b);
        var t$prime = Curry._1(f, t);
        if (b$prime === b && t$prime === t) {
          return c;
        } else {
          return mkCast(/* tuple */[
                      b$prime,
                      match[1],
                      t$prime
                    ]);
        }
    case 6 : 
        var b$1 = match[2];
        var t$1 = match[1];
        var b$prime$1 = Curry._1(f, b$1);
        var t$prime$1 = Curry._1(f, t$1);
        if (b$prime$1 === b$1 && t$prime$1 === t$1) {
          return c;
        } else {
          return mkProd(/* tuple */[
                      match[0],
                      t$prime$1,
                      b$prime$1
                    ]);
        }
    case 7 : 
        var b$2 = match[2];
        var t$2 = match[1];
        var b$prime$2 = Curry._1(f, b$2);
        var t$prime$2 = Curry._1(f, t$2);
        if (b$prime$2 === b$2 && t$prime$2 === t$2) {
          return c;
        } else {
          return mkLambda(/* tuple */[
                      match[0],
                      t$prime$2,
                      b$prime$2
                    ]);
        }
    case 8 : 
        var k = match[3];
        var t$3 = match[2];
        var b$3 = match[1];
        var b$prime$3 = Curry._1(f, b$3);
        var t$prime$3 = Curry._1(f, t$3);
        var k$prime = Curry._1(f, k);
        if (b$prime$3 === b$3 && t$prime$3 === t$3 && k$prime === k) {
          return c;
        } else {
          return mkLetIn(/* tuple */[
                      match[0],
                      b$prime$3,
                      t$prime$3,
                      k$prime
                    ]);
        }
    case 9 : 
        var l$1 = match[1];
        var b$4 = match[0];
        var b$prime$4 = Curry._1(f, b$4);
        var l$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](f, l$1);
        if (b$prime$4 === b$4 && l$prime$1 === l$1) {
          return c;
        } else {
          return mkApp(/* tuple */[
                      b$prime$4,
                      l$prime$1
                    ]);
        }
    case 13 : 
        var bl = match[3];
        var b$5 = match[2];
        var p = match[1];
        var b$prime$5 = Curry._1(f, b$5);
        var p$prime = Curry._1(f, p);
        var bl$prime = Util$ReactTemplate.$$Array[/* smartmap */47](f, bl);
        if (b$prime$5 === b$5 && p$prime === p && bl$prime === bl) {
          return c;
        } else {
          return mkCase(/* tuple */[
                      match[0],
                      p$prime,
                      b$prime$5,
                      bl$prime
                    ]);
        }
    case 14 : 
        var match$2 = match[0];
        var match$3 = match$2[1];
        var bl$1 = match$3[2];
        var tl = match$3[1];
        var tl$prime = Util$ReactTemplate.$$Array[/* smartmap */47](f, tl);
        var bl$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](f, bl$1);
        if (tl$prime === tl && bl$prime$1 === bl$1) {
          return c;
        } else {
          return Constr$ReactTemplate.of_kind(/* Fix */Block.__(14, [/* tuple */[
                          match$2[0],
                          /* tuple */[
                            match$3[0],
                            tl$prime,
                            bl$prime$1
                          ]
                        ]]));
        }
    case 15 : 
        var match$4 = match[0];
        var match$5 = match$4[1];
        var bl$2 = match$5[2];
        var tl$1 = match$5[1];
        var tl$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](f, tl$1);
        var bl$prime$2 = Util$ReactTemplate.$$Array[/* smartmap */47](f, bl$2);
        if (tl$prime$1 === tl$1 && bl$prime$2 === bl$2) {
          return c;
        } else {
          return Constr$ReactTemplate.of_kind(/* CoFix */Block.__(15, [/* tuple */[
                          match$4[0],
                          /* tuple */[
                            match$5[0],
                            tl$prime$1,
                            bl$prime$2
                          ]
                        ]]));
        }
    case 16 : 
        var t$4 = match[1];
        var t$prime$4 = Curry._1(f, t$4);
        if (t$prime$4 === t$4) {
          return c;
        } else {
          return mkProj(/* tuple */[
                      match[0],
                      t$prime$4
                    ]);
        }
    default:
      return c;
  }
}

function map_with_binders(sigma, g, f, l, c0) {
  var match = kind$2(sigma, c0);
  switch (match.tag | 0) {
    case 3 : 
        var match$1 = match[0];
        var al = match$1[1];
        var al$prime = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, al);
        if (al$prime === al) {
          return c0;
        } else {
          return Constr$ReactTemplate.of_kind(/* Evar */Block.__(3, [/* tuple */[
                          match$1[0],
                          al$prime
                        ]]));
        }
    case 5 : 
        var t = match[2];
        var c = match[0];
        var c$prime = Curry._2(f, l, c);
        var t$prime = Curry._2(f, l, t);
        if (c$prime === c && t$prime === t) {
          return c0;
        } else {
          return mkCast(/* tuple */[
                      c$prime,
                      match[1],
                      t$prime
                    ]);
        }
    case 6 : 
        var c$1 = match[2];
        var t$1 = match[1];
        var t$prime$1 = Curry._2(f, l, t$1);
        var c$prime$1 = Curry._2(f, Curry._1(g, l), c$1);
        if (t$prime$1 === t$1 && c$prime$1 === c$1) {
          return c0;
        } else {
          return mkProd(/* tuple */[
                      match[0],
                      t$prime$1,
                      c$prime$1
                    ]);
        }
    case 7 : 
        var c$2 = match[2];
        var t$2 = match[1];
        var t$prime$2 = Curry._2(f, l, t$2);
        var c$prime$2 = Curry._2(f, Curry._1(g, l), c$2);
        if (t$prime$2 === t$2 && c$prime$2 === c$2) {
          return c0;
        } else {
          return mkLambda(/* tuple */[
                      match[0],
                      t$prime$2,
                      c$prime$2
                    ]);
        }
    case 8 : 
        var c$3 = match[3];
        var t$3 = match[2];
        var b = match[1];
        var b$prime = Curry._2(f, l, b);
        var t$prime$3 = Curry._2(f, l, t$3);
        var c$prime$3 = Curry._2(f, Curry._1(g, l), c$3);
        if (b$prime === b && t$prime$3 === t$3 && c$prime$3 === c$3) {
          return c0;
        } else {
          return mkLetIn(/* tuple */[
                      match[0],
                      b$prime,
                      t$prime$3,
                      c$prime$3
                    ]);
        }
    case 9 : 
        var al$1 = match[1];
        var c$4 = match[0];
        var c$prime$4 = Curry._2(f, l, c$4);
        var al$prime$1 = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, al$1);
        if (c$prime$4 === c$4 && al$prime$1 === al$1) {
          return c0;
        } else {
          return mkApp(/* tuple */[
                      c$prime$4,
                      al$prime$1
                    ]);
        }
    case 13 : 
        var bl = match[3];
        var c$5 = match[2];
        var p = match[1];
        var p$prime = Curry._2(f, l, p);
        var c$prime$5 = Curry._2(f, l, c$5);
        var bl$prime = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, bl);
        if (p$prime === p && c$prime$5 === c$5 && bl$prime === bl) {
          return c0;
        } else {
          return mkCase(/* tuple */[
                      match[0],
                      p$prime,
                      c$prime$5,
                      bl$prime
                    ]);
        }
    case 14 : 
        var match$2 = match[0];
        var match$3 = match$2[1];
        var bl$1 = match$3[2];
        var tl = match$3[1];
        var tl$prime = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, tl);
        var l$prime = Util$ReactTemplate.iterate(g, tl.length, l);
        var bl$prime$1 = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l$prime, bl$1);
        if (tl$prime === tl && bl$prime$1 === bl$1) {
          return c0;
        } else {
          return Constr$ReactTemplate.of_kind(/* Fix */Block.__(14, [/* tuple */[
                          match$2[0],
                          /* tuple */[
                            match$3[0],
                            tl$prime,
                            bl$prime$1
                          ]
                        ]]));
        }
    case 15 : 
        var match$4 = match[0];
        var match$5 = match$4[1];
        var tl$1 = match$5[1];
        var tl$prime$1 = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, tl$1);
        var l$prime$1 = Util$ReactTemplate.iterate(g, tl$1.length, l);
        var bl$prime$2 = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l$prime$1, match$5[2]);
        return Constr$ReactTemplate.of_kind(/* CoFix */Block.__(15, [/* tuple */[
                        match$4[0],
                        /* tuple */[
                          match$5[0],
                          tl$prime$1,
                          bl$prime$2
                        ]
                      ]]));
    case 16 : 
        var t$4 = match[1];
        var t$prime$4 = Curry._2(f, l, t$4);
        if (t$prime$4 === t$4) {
          return c0;
        } else {
          return mkProj(/* tuple */[
                      match[0],
                      t$prime$4
                    ]);
        }
    default:
      return c0;
  }
}

function iter(sigma, f, c) {
  var match = kind$2(sigma, c);
  var exit = 0;
  switch (match.tag | 0) {
    case 3 : 
        return Util$ReactTemplate.$$Array[/* iter */11](f, match[0][1]);
    case 5 : 
        Curry._1(f, match[0]);
        return Curry._1(f, match[2]);
    case 6 : 
    case 7 : 
        Curry._1(f, match[1]);
        return Curry._1(f, match[2]);
    case 8 : 
        Curry._1(f, match[1]);
        Curry._1(f, match[2]);
        return Curry._1(f, match[3]);
    case 9 : 
        Curry._1(f, match[0]);
        return Util$ReactTemplate.$$Array[/* iter */11](f, match[1]);
    case 13 : 
        Curry._1(f, match[1]);
        Curry._1(f, match[2]);
        return Util$ReactTemplate.$$Array[/* iter */11](f, match[3]);
    case 14 : 
    case 15 : 
        exit = 1;
        break;
    case 16 : 
        return Curry._1(f, match[1]);
    default:
      return /* () */0;
  }
  if (exit === 1) {
    var match$1 = match[0][1];
    Util$ReactTemplate.$$Array[/* iter */11](f, match$1[1]);
    return Util$ReactTemplate.$$Array[/* iter */11](f, match$1[2]);
  }
  
}

function iter_with_full_binders(sigma, g, f, n, c) {
  var match = kind$2(sigma, c);
  var exit = 0;
  switch (match.tag | 0) {
    case 3 : 
        return CArray$ReactTemplate.Fun1[/* iter */2](f, n, match[0][1]);
    case 5 : 
        Curry._2(f, n, match[0]);
        return Curry._2(f, n, match[2]);
    case 6 : 
    case 7 : 
        exit = 1;
        break;
    case 8 : 
        var t = match[2];
        var b = match[1];
        Curry._2(f, n, b);
        Curry._2(f, n, t);
        return Curry._2(f, Curry._2(g, /* LocalDef */Block.__(1, [
                          match[0],
                          b,
                          t
                        ]), n), match[3]);
    case 9 : 
        Curry._2(f, n, match[0]);
        return CArray$ReactTemplate.Fun1[/* iter */2](f, n, match[1]);
    case 13 : 
        Curry._2(f, n, match[1]);
        Curry._2(f, n, match[2]);
        return CArray$ReactTemplate.Fun1[/* iter */2](f, n, match[3]);
    case 14 : 
        var match$1 = match[0][1];
        var tl = match$1[1];
        Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, n), tl);
        var n$prime = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (n, na, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              na,
                              t
                            ]), n);
              }), n, match$1[0], tl);
        return Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, n$prime), match$1[2]);
    case 15 : 
        var match$2 = match[0][1];
        var tl$1 = match$2[1];
        Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, n), tl$1);
        var n$prime$1 = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (n, na, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              na,
                              t
                            ]), n);
              }), n, match$2[0], tl$1);
        return Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, n$prime$1), match$2[2]);
    case 16 : 
        return Curry._2(f, n, match[1]);
    default:
      return /* () */0;
  }
  if (exit === 1) {
    var t$1 = match[1];
    Curry._2(f, n, t$1);
    return Curry._2(f, Curry._2(g, /* LocalAssum */Block.__(0, [
                      match[0],
                      t$1
                    ]), n), match[2]);
  }
  
}

function iter_with_binders(sigma, g, f, n, c) {
  return iter_with_full_binders(sigma, (function (_, acc) {
                return Curry._1(g, acc);
              }), f, n, c);
}

function fold(sigma, f, acc, c) {
  var match = kind$2(sigma, c);
  var exit = 0;
  switch (match.tag | 0) {
    case 3 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](f, acc, match[0][1]);
    case 5 : 
        return Curry._2(f, Curry._2(f, acc, match[0]), match[2]);
    case 6 : 
    case 7 : 
        exit = 1;
        break;
    case 8 : 
        return Curry._2(f, Curry._2(f, Curry._2(f, acc, match[1]), match[2]), match[3]);
    case 9 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](f, Curry._2(f, acc, match[0]), match[1]);
    case 13 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](f, Curry._2(f, Curry._2(f, acc, match[1]), match[2]), match[3]);
    case 14 : 
        var match$1 = match[0][1];
        return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (acc, t, b) {
                      return Curry._2(f, Curry._2(f, acc, t), b);
                    }), acc, match$1[1], match$1[2]);
    case 15 : 
        var match$2 = match[0][1];
        return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (acc, t, b) {
                      return Curry._2(f, Curry._2(f, acc, t), b);
                    }), acc, match$2[1], match$2[2]);
    case 16 : 
        return Curry._2(f, acc, match[1]);
    default:
      return acc;
  }
  if (exit === 1) {
    return Curry._2(f, Curry._2(f, acc, match[1]), match[2]);
  }
  
}

function compare_gen(k, eq_inst, eq_sort, eq_constr, nargs, c1, c2) {
  if (c1 === c2) {
    return /* true */1;
  } else {
    return Constr$ReactTemplate.compare_head_gen_with(k, k, eq_inst, eq_sort, eq_constr, nargs, c1)(c2);
  }
}

function eq_constr(sigma, c1, c2) {
  var kind$3 = function (c) {
    return kind$2(sigma, c);
  };
  var eq_constr$1 = function (nargs, c1, c2) {
    return compare_gen(kind$3, (function (_, _$1) {
                  return Univ$ReactTemplate.Instance[/* equal */5];
                }), Sorts$ReactTemplate.equal, eq_constr$1, nargs, c1, c2);
  };
  return eq_constr$1(0, c1, c2);
}

function eq_constr_nounivs(sigma, c1, c2) {
  var kind$3 = function (c) {
    return kind$2(sigma, c);
  };
  var eq_constr = function (nargs, c1, c2) {
    return compare_gen(kind$3, (function (_, _$1, _$2, _$3) {
                  return /* true */1;
                }), (function (_, _$1) {
                  return /* true */1;
                }), eq_constr, nargs, c1, c2);
  };
  return eq_constr(0, c1, c2);
}

function compare_constr(sigma, cmp, c1, c2) {
  var kind$3 = function (c) {
    return kind$2(sigma, c);
  };
  var cmp$1 = function (_, c1, c2) {
    return Curry._2(cmp, c1, c2);
  };
  return compare_gen(kind$3, (function (_, _$1) {
                return Univ$ReactTemplate.Instance[/* equal */5];
              }), Sorts$ReactTemplate.equal, cmp$1, 0, c1, c2);
}

function cmp_inductives(cv_pb, spec, nargs, u1, u2, cstrs) {
  var match = spec[0][/* mind_universes */8];
  switch (match.tag | 0) {
    case 0 : 
        if (!(Univ$ReactTemplate.Instance[/* length */6](u1) === 0 && Univ$ReactTemplate.Instance[/* length */6](u2) === 0)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "eConstr.ml",
                  598,
                  4
                ]
              ];
        }
        return cstrs;
    case 1 : 
        return Universes$ReactTemplate.enforce_eq_instances_univs(/* false */0, u1, u2, cstrs);
    case 2 : 
        var num_param_arity = Reduction$ReactTemplate.inductive_cumulativity_arguments(spec);
        var variances = Univ$ReactTemplate.ACumulativityInfo[/* variance */1](match[0]);
        var cv_pb$1 = cv_pb;
        var nargs_ok = +(num_param_arity === nargs);
        var variances$1 = variances;
        var u = u1;
        var u$prime = u2;
        var cstrs$1 = cstrs;
        if (nargs_ok) {
          return CArray$ReactTemplate.fold_left3((function (cstrs, v, u, u$prime) {
                        switch (v) {
                          case 0 : 
                              return Universes$ReactTemplate.Constraints[/* add */3](/* UWeak */Block.__(3, [
                                            u,
                                            u$prime
                                          ]), cstrs);
                          case 1 : 
                              var u$1 = Univ$ReactTemplate.Universe[/* make */3](u);
                              var u$prime$1 = Univ$ReactTemplate.Universe[/* make */3](u$prime);
                              if (cv_pb$1 !== 0) {
                                return Universes$ReactTemplate.Constraints[/* add */3](/* ULe */Block.__(0, [
                                              u$1,
                                              u$prime$1
                                            ]), cstrs);
                              } else {
                                return Universes$ReactTemplate.Constraints[/* add */3](/* UEq */Block.__(1, [
                                              u$1,
                                              u$prime$1
                                            ]), cstrs);
                              }
                          case 2 : 
                              var u$2 = Univ$ReactTemplate.Universe[/* make */3](u);
                              var u$prime$2 = Univ$ReactTemplate.Universe[/* make */3](u$prime);
                              return Universes$ReactTemplate.Constraints[/* add */3](/* UEq */Block.__(1, [
                                            u$2,
                                            u$prime$2
                                          ]), cstrs);
                          
                        }
                      }), cstrs$1, variances$1, Univ$ReactTemplate.Instance[/* to_array */3](u), Univ$ReactTemplate.Instance[/* to_array */3](u$prime));
        } else {
          return Universes$ReactTemplate.enforce_eq_instances_univs(/* false */0, u, u$prime, cstrs$1);
        }
    
  }
}

function cmp_constructors(spec, nargs, u1, u2, cstrs) {
  var match = spec[0][/* mind_universes */8];
  switch (match.tag | 0) {
    case 0 : 
        return cstrs;
    case 1 : 
        return Universes$ReactTemplate.enforce_eq_instances_univs(/* false */0, u1, u2, cstrs);
    case 2 : 
        var num_cnstr_args = Reduction$ReactTemplate.constructor_cumulativity_arguments(spec);
        if (num_cnstr_args !== nargs) {
          return Universes$ReactTemplate.enforce_eq_instances_univs(/* false */0, u1, u2, cstrs);
        } else {
          return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (cstrs, u1, u2) {
                        return Universes$ReactTemplate.Constraints[/* add */3](/* UWeak */Block.__(3, [
                                      u1,
                                      u2
                                    ]), cstrs);
                      }), cstrs, Univ$ReactTemplate.Instance[/* to_array */3](u1), Univ$ReactTemplate.Instance[/* to_array */3](u2));
        }
    
  }
}

function eq_universes(env, sigma, cstrs, cv_pb, ref, nargs, l, l$prime) {
  if (Univ$ReactTemplate.Instance[/* is_empty */1](l)) {
    if (!Univ$ReactTemplate.Instance[/* is_empty */1](l$prime)) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "eConstr.ml",
              623,
              36
            ]
          ];
    }
    return /* true */1;
  } else {
    var l$1 = Evd$ReactTemplate.normalize_universe_instance(sigma, l);
    var l$prime$1 = Evd$ReactTemplate.normalize_universe_instance(sigma, l$prime);
    switch (ref.tag | 0) {
      case 0 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "eConstr.ml",
                  629,
                  18
                ]
              ];
      case 1 : 
          cstrs[0] = Universes$ReactTemplate.enforce_eq_instances_univs(/* true */1, l$1, l$prime$1, cstrs[0]);
          return /* true */1;
      case 2 : 
          var ind = ref[0];
          var mind = Environ$ReactTemplate.lookup_mind(ind[0], env);
          cstrs[0] = cmp_inductives(cv_pb, /* tuple */[
                mind,
                ind[1]
              ], nargs, l$1, l$prime$1, cstrs[0]);
          return /* true */1;
      case 3 : 
          var match = ref[0];
          var match$1 = match[0];
          var mind$1 = Environ$ReactTemplate.lookup_mind(match$1[0], env);
          cstrs[0] = cmp_constructors(/* tuple */[
                mind$1,
                match$1[1],
                match[1]
              ], nargs, l$1, l$prime$1, cstrs[0]);
          return /* true */1;
      
    }
  }
}

function test_constr_universes(env, sigma, leq, m, n) {
  var kind$3 = function (c) {
    return kind$2(sigma, c);
  };
  if (m === n) {
    return /* Some */[Universes$ReactTemplate.Constraints[/* empty */0]];
  } else {
    var cstrs = [Universes$ReactTemplate.Constraints[/* empty */0]];
    var cv_pb = leq ? /* CUMUL */1 : /* CONV */0;
    var eq_universes$1 = function (ref, nargs, l, l$prime) {
      return eq_universes(env, sigma, cstrs, /* CONV */0, ref, nargs, l, l$prime);
    };
    var leq_universes = function (ref, nargs, l, l$prime) {
      return eq_universes(env, sigma, cstrs, cv_pb, ref, nargs, l, l$prime);
    };
    var eq_sorts = function (s1, s2) {
      var s1$1 = kind(sigma, s1);
      var s2$1 = kind(sigma, s2);
      if (Sorts$ReactTemplate.equal(s1$1, s2$1)) {
        return /* true */1;
      } else {
        cstrs[0] = Universes$ReactTemplate.Constraints[/* add */3](/* UEq */Block.__(1, [
                Sorts$ReactTemplate.univ_of_sort(s1$1),
                Sorts$ReactTemplate.univ_of_sort(s2$1)
              ]), cstrs[0]);
        return /* true */1;
      }
    };
    var leq_sorts = function (s1, s2) {
      var s1$1 = kind(sigma, s1);
      var s2$1 = kind(sigma, s2);
      if (Sorts$ReactTemplate.equal(s1$1, s2$1)) {
        return /* true */1;
      } else {
        cstrs[0] = Universes$ReactTemplate.Constraints[/* add */3](/* ULe */Block.__(0, [
                Sorts$ReactTemplate.univ_of_sort(s1$1),
                Sorts$ReactTemplate.univ_of_sort(s2$1)
              ]), cstrs[0]);
        return /* true */1;
      }
    };
    var eq_constr$prime = function (nargs, m, n) {
      return compare_gen(kind$3, eq_universes$1, eq_sorts, eq_constr$prime, nargs, m, n);
    };
    var res;
    if (leq) {
      var compare_leq = function (nargs, m, n) {
        return Constr$ReactTemplate.compare_head_gen_leq_with(kind$3, kind$3, leq_universes, leq_sorts, eq_constr$prime, leq_constr$prime, nargs, m, n);
      };
      var leq_constr$prime = function (nargs, m, n) {
        if (m === n) {
          return /* true */1;
        } else {
          return compare_leq(nargs, m, n);
        }
      };
      res = compare_leq(0, m, n);
    } else {
      res = Constr$ReactTemplate.compare_head_gen_with(kind$3, kind$3, eq_universes$1, eq_sorts, eq_constr$prime, 0, m)(n);
    }
    if (res) {
      return /* Some */[cstrs[0]];
    } else {
      return /* None */0;
    }
  }
}

function eq_constr_universes(env, sigma, m, n) {
  return test_constr_universes(env, sigma, /* false */0, m, n);
}

function leq_constr_universes(env, sigma, m, n) {
  return test_constr_universes(env, sigma, /* true */1, m, n);
}

function eq_constr_universes_proj(env, sigma, m, n) {
  if (m === n) {
    return /* Some */[Universes$ReactTemplate.Constraints[/* empty */0]];
  } else {
    var cstrs = [Universes$ReactTemplate.Constraints[/* empty */0]];
    var eq_universes$1 = function (ref, l, l$prime) {
      return (function (param) {
          return eq_universes(env, sigma, cstrs, /* CONV */0, ref, l, l$prime, param);
        });
    };
    var eq_sorts = function (s1, s2) {
      if (Sorts$ReactTemplate.equal(s1, s2)) {
        return /* true */1;
      } else {
        cstrs[0] = Universes$ReactTemplate.Constraints[/* add */3](/* UEq */Block.__(1, [
                Sorts$ReactTemplate.univ_of_sort(s1),
                Sorts$ReactTemplate.univ_of_sort(s2)
              ]), cstrs[0]);
        return /* true */1;
      }
    };
    var eq_constr$prime = function (nargs, m, n) {
      if (m === n) {
        return /* true */1;
      } else {
        var env$1 = env;
        var sigma$1 = sigma;
        var equ = eq_universes$1;
        var eqs = eq_sorts;
        var eqc$prime = eq_constr$prime;
        var nargs$1 = nargs;
        var m$1 = m;
        var n$1 = n;
        var kind$3 = function (c) {
          return kind$2(sigma$1, c);
        };
        var match = kind$2(sigma$1, m$1);
        var match$1 = kind$2(sigma$1, n$1);
        var exit = 0;
        var p;
        var c;
        var f;
        var args;
        switch (match.tag | 0) {
          case 9 : 
              if (match$1.tag === 16) {
                p = match$1[0];
                c = match$1[1];
                f = match[0];
                args = match[1];
                exit = 2;
              } else {
                exit = 1;
              }
              break;
          case 16 : 
              if (match$1.tag === 9) {
                p = match[0];
                c = match[1];
                f = match$1[0];
                args = match$1[1];
                exit = 2;
              } else {
                exit = 1;
              }
              break;
          default:
            exit = 1;
        }
        switch (exit) {
          case 1 : 
              return Constr$ReactTemplate.compare_head_gen_with(kind$3, kind$3, equ, eqs, eqc$prime, nargs$1, m$1)(n$1);
          case 2 : 
              var match$2 = kind$2(sigma$1, f);
              if (match$2.tag === 10) {
                if (Names$ReactTemplate.Constant[/* equal */12](Names$ReactTemplate.Projection[/* constant */2](p), match$2[0][0])) {
                  var pb = Environ$ReactTemplate.lookup_projection(p, env$1);
                  var npars = pb[/* proj_npars */1];
                  if (args.length === (npars + 1 | 0)) {
                    return Curry._3(eqc$prime, 0, c, Caml_array.caml_array_get(args, npars));
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
              break;
          
        }
      }
    };
    var res = eq_constr$prime(0, m, n);
    if (res) {
      return /* Some */[cstrs[0]];
    } else {
      return /* None */0;
    }
  }
}

function universes_of_constr(env, sigma, c) {
  var aux = function (s, c) {
    var match = kind$2(sigma, c);
    var exit = 0;
    var mind;
    var u;
    switch (match.tag | 0) {
      case 3 : 
          var concl = Evd$ReactTemplate.evar_concl(Evd$ReactTemplate.find(sigma, match[0][0]));
          return fold(sigma, aux, aux(s, concl), c);
      case 4 : 
          var sort = kind(sigma, match[0]);
          if (Sorts$ReactTemplate.is_small(sort)) {
            return s;
          } else {
            var u$1 = Sorts$ReactTemplate.univ_of_sort(sort);
            return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], Univ$ReactTemplate.LSet[/* add */3], Univ$ReactTemplate.Universe[/* levels */9](u$1), s);
          }
          break;
      case 10 : 
          var match$1 = match[0];
          var match$2 = Environ$ReactTemplate.lookup_constant(match$1[0], env)[/* const_universes */4];
          if (match$2.tag) {
            return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], Univ$ReactTemplate.LSet[/* add */3], Univ$ReactTemplate.Instance[/* levels */12](kind$1(sigma, match$1[1])), s);
          } else {
            return Curry._2(Univ$ReactTemplate.LSet[/* union */6], s, match$2[0][0]);
          }
          break;
      case 11 : 
          var match$3 = match[0];
          mind = match$3[0][0];
          u = match$3[1];
          exit = 1;
          break;
      case 12 : 
          var match$4 = match[0];
          mind = match$4[0][0][0];
          u = match$4[1];
          exit = 1;
          break;
      default:
        return fold(sigma, aux, s, c);
    }
    if (exit === 1) {
      var match$5 = Environ$ReactTemplate.lookup_mind(mind, env)[/* mind_universes */8];
      var exit$1 = 0;
      switch (match$5.tag | 0) {
        case 0 : 
            return Curry._2(Univ$ReactTemplate.LSet[/* union */6], s, match$5[0][0]);
        case 1 : 
        case 2 : 
            exit$1 = 2;
            break;
        
      }
      if (exit$1 === 2) {
        return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], Univ$ReactTemplate.LSet[/* add */3], Univ$ReactTemplate.Instance[/* levels */12](kind$1(sigma, u)), s);
      }
      
    }
    
  };
  return aux(Univ$ReactTemplate.LSet[/* empty */0], c);
}

var LocalOccur = Caml_exceptions.create("EConstr-ReactTemplate.Vars.LocalOccur");

function lift(n, c) {
  return Vars$ReactTemplate.lift(n)(c);
}

var liftn = Vars$ReactTemplate.liftn;

var substnl = Vars$ReactTemplate.substnl;

var substl = Vars$ReactTemplate.substl;

var subst1 = Vars$ReactTemplate.subst1;

var substnl_decl = Vars$ReactTemplate.substnl_decl;

var substl_decl = Vars$ReactTemplate.substl_decl;

var subst1_decl = Vars$ReactTemplate.subst1_decl;

var replace_vars = Vars$ReactTemplate.replace_vars;

var substn_vars = Vars$ReactTemplate.substn_vars;

var subst_vars = Vars$ReactTemplate.subst_vars;

var subst_var = Vars$ReactTemplate.subst_var;

var subst_univs_level_constr = Vars$ReactTemplate.subst_univs_level_constr;

function noccurn(sigma, n, term) {
  var occur_rec = function (n, c) {
    var match = kind$2(sigma, c);
    if (match.tag) {
      return iter_with_binders(sigma, (function (prim) {
                    return prim + 1 | 0;
                  }), occur_rec, n, c);
    } else if (match[0] === n) {
      throw LocalOccur;
    } else {
      return 0;
    }
  };
  try {
    occur_rec(n, term);
    return /* true */1;
  }
  catch (exn){
    if (exn === LocalOccur) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function noccur_between(sigma, n, m, term) {
  var occur_rec = function (n, c) {
    var match = kind$2(sigma, c);
    if (match.tag) {
      return iter_with_binders(sigma, (function (prim) {
                    return prim + 1 | 0;
                  }), occur_rec, n, c);
    } else {
      var p = match[0];
      if (n <= p && p < (n + m | 0)) {
        throw LocalOccur;
      } else {
        return 0;
      }
    }
  };
  try {
    occur_rec(n, term);
    return /* true */1;
  }
  catch (exn){
    if (exn === LocalOccur) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function closedn(sigma, n, c) {
  var closed_rec = function (n, c) {
    var match = kind$2(sigma, c);
    if (match.tag) {
      return iter_with_binders(sigma, (function (prim) {
                    return prim + 1 | 0;
                  }), closed_rec, n, c);
    } else if (match[0] > n) {
      throw LocalOccur;
    } else {
      return 0;
    }
  };
  try {
    closed_rec(n, c);
    return /* true */1;
  }
  catch (exn){
    if (exn === LocalOccur) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function closed0(sigma, c) {
  return closedn(sigma, 0, c);
}

function subst_of_rel_context_instance(ctx, subst) {
  var x = Vars$ReactTemplate.subst_of_rel_context_instance(ctx, subst);
  Util$ReactTemplate.sym(/* Refl */0);
  return x;
}

function isArity(sigma, _c) {
  while(true) {
    var c = _c;
    var match = kind$2(sigma, c);
    switch (match.tag | 0) {
      case 4 : 
          return /* true */1;
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          continue ;
          case 8 : 
          _c = subst1(match[1], match[3]);
          continue ;
          default:
        return /* false */0;
    }
  };
}

function destArity(sigma) {
  return (function (param) {
      var _l = /* [] */0;
      var _c = param;
      while(true) {
        var c = _c;
        var l = _l;
        var match = kind$2(sigma, c);
        switch (match.tag | 0) {
          case 4 : 
              return /* tuple */[
                      l,
                      match[0]
                    ];
          case 5 : 
              _c = match[0];
              continue ;
              case 6 : 
              _c = match[2];
              _l = /* :: */[
                /* LocalAssum */Block.__(0, [
                    match[0],
                    match[1]
                  ]),
                l
              ];
              continue ;
              case 8 : 
              _c = match[3];
              _l = /* :: */[
                /* LocalDef */Block.__(1, [
                    match[0],
                    match[1],
                    match[2]
                  ]),
                l
              ];
              continue ;
              default:
            return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["destArity"], Pp$ReactTemplate.str("not an arity."));
        }
      };
    });
}

function mkProd_or_LetIn(decl, c) {
  if (decl.tag) {
    return mkLetIn(/* tuple */[
                decl[0],
                decl[1],
                decl[2],
                c
              ]);
  } else {
    return mkProd(/* tuple */[
                decl[0],
                decl[1],
                c
              ]);
  }
}

function mkLambda_or_LetIn(decl, c) {
  if (decl.tag) {
    return mkLetIn(/* tuple */[
                decl[0],
                decl[1],
                decl[2],
                c
              ]);
  } else {
    return mkLambda(/* tuple */[
                decl[0],
                decl[1],
                c
              ]);
  }
}

function mkNamedProd(id, typ, c) {
  return mkProd(/* tuple */[
              /* Name */[id],
              typ,
              subst_var(id, c)
            ]);
}

function mkNamedLambda(id, typ, c) {
  return mkLambda(/* tuple */[
              /* Name */[id],
              typ,
              subst_var(id, c)
            ]);
}

function mkNamedLetIn(id, c1, t, c2) {
  return mkLetIn(/* tuple */[
              /* Name */[id],
              c1,
              t,
              subst_var(id, c2)
            ]);
}

function mkNamedProd_or_LetIn(decl, c) {
  if (decl.tag) {
    return mkNamedLetIn(decl[0], decl[1], decl[2], c);
  } else {
    return mkNamedProd(decl[0], decl[1], c);
  }
}

function mkNamedLambda_or_LetIn(decl, c) {
  if (decl.tag) {
    return mkNamedLetIn(decl[0], decl[1], decl[2], c);
  } else {
    return mkNamedLambda(decl[0], decl[1], c);
  }
}

function it_mkProd_or_LetIn(t, ctx) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (c, d) {
                return mkProd_or_LetIn(d, c);
              }), t, ctx);
}

function it_mkLambda_or_LetIn(t, ctx) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (c, d) {
                return mkLambda_or_LetIn(d, c);
              }), t, ctx);
}

var push_rel = Environ$ReactTemplate.push_rel;

var push_rel_context = Environ$ReactTemplate.push_rel_context;

var push_rec_types = Environ$ReactTemplate.push_rec_types;

var push_named = Environ$ReactTemplate.push_named;

function push_named_context(d, e) {
  return Curry._2(Environ$ReactTemplate.push_named_context, d, e);
}

var push_named_context_val = Environ$ReactTemplate.push_named_context_val;

function rel_context(e) {
  var x = Environ$ReactTemplate.rel_context(e);
  Util$ReactTemplate.sym(/* Refl */0);
  return x;
}

function named_context(e) {
  var x = Environ$ReactTemplate.named_context(e);
  Util$ReactTemplate.sym(/* Refl */0);
  return x;
}

var val_of_named_context = Environ$ReactTemplate.val_of_named_context;

function named_context_of_val(e) {
  var x = Environ$ReactTemplate.named_context_of_val(e);
  Util$ReactTemplate.sym(/* Refl */0);
  return x;
}

function lookup_rel(i, e) {
  var x = Environ$ReactTemplate.lookup_rel(i, e);
  Util$ReactTemplate.sym(/* Refl */0);
  return x;
}

function lookup_named(n, e) {
  var x = Environ$ReactTemplate.lookup_named(n, e);
  Util$ReactTemplate.sym(/* Refl */0);
  return x;
}

function lookup_named_val(n, e) {
  var x = Environ$ReactTemplate.lookup_named_val(n, e);
  Util$ReactTemplate.sym(/* Refl */0);
  return x;
}

function map_rel_context_in_env(f, env, sign) {
  var _env = env;
  var _acc = /* [] */0;
  var _param = Curry._1(Util$ReactTemplate.List[/* rev */4], sign);
  while(true) {
    var param = _param;
    var acc = _acc;
    var env$1 = _env;
    if (param) {
      var d = param[0];
      _param = param[1];
      _acc = /* :: */[
        Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], Curry._1(f, env$1), d),
        acc
      ];
      _env = push_rel(d, env$1);
      continue ;
      
    } else {
      return acc;
    }
  };
}

function fresh_global(loc, rigid, names, env, sigma, reference) {
  var match = Evd$ReactTemplate.fresh_global(loc, rigid, names, env, sigma, reference);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function is_global(sigma, gr, c) {
  return Globnames$ReactTemplate.is_global(gr, to_constr(sigma, c));
}

var ESorts = [
  make,
  kind
];

var EInstance = [
  make$1,
  kind$1,
  empty,
  is_empty
];

var kind_upto = kind$2;

var of_kind = Constr$ReactTemplate.of_kind;

var Vars = [
  lift,
  liftn,
  substnl,
  substl,
  subst1,
  substnl_decl,
  substl_decl,
  subst1_decl,
  replace_vars,
  substn_vars,
  subst_vars,
  subst_var,
  noccurn,
  noccur_between,
  closedn,
  closed0,
  subst_univs_level_constr,
  subst_of_rel_context_instance
];

var Unsafe = [
  unsafe_to_constr,
  unsafe_to_rel_decl,
  unsafe_to_named_decl,
  unsafe_to_sorts,
  unsafe_to_instance,
  /* Refl */0
];

exports.ESorts = ESorts;
exports.EInstance = EInstance;
exports.kind = kind$2;
exports.kind_upto = kind_upto;
exports.to_constr = to_constr;
exports.kind_of_type = kind_of_type;
exports.of_kind = of_kind;
exports.of_constr = of_constr;
exports.mkRel = mkRel;
exports.mkVar = mkVar;
exports.mkMeta = mkMeta;
exports.mkEvar = mkEvar;
exports.mkSort = mkSort;
exports.mkProp = mkProp;
exports.mkSet = mkSet;
exports.mkType = mkType;
exports.mkCast = mkCast;
exports.mkProd = mkProd;
exports.mkLambda = mkLambda;
exports.mkLetIn = mkLetIn;
exports.mkApp = mkApp;
exports.mkConst = mkConst;
exports.mkConstU = mkConstU;
exports.mkProj = mkProj;
exports.mkInd = mkInd;
exports.mkIndU = mkIndU;
exports.mkConstruct = mkConstruct;
exports.mkConstructU = mkConstructU;
exports.mkConstructUi = mkConstructUi;
exports.mkCase = mkCase;
exports.mkFix = mkFix;
exports.mkCoFix = mkCoFix;
exports.mkArrow = mkArrow;
exports.applist = applist;
exports.mkProd_or_LetIn = mkProd_or_LetIn;
exports.mkLambda_or_LetIn = mkLambda_or_LetIn;
exports.it_mkProd_or_LetIn = it_mkProd_or_LetIn;
exports.it_mkLambda_or_LetIn = it_mkLambda_or_LetIn;
exports.mkNamedLambda = mkNamedLambda;
exports.mkNamedLetIn = mkNamedLetIn;
exports.mkNamedProd = mkNamedProd;
exports.mkNamedLambda_or_LetIn = mkNamedLambda_or_LetIn;
exports.mkNamedProd_or_LetIn = mkNamedProd_or_LetIn;
exports.isRel = isRel;
exports.isVar = isVar;
exports.isInd = isInd;
exports.isEvar = isEvar;
exports.isMeta = isMeta;
exports.isSort = isSort;
exports.isCast = isCast;
exports.isApp = isApp;
exports.isLambda = isLambda;
exports.isLetIn = isLetIn;
exports.isProd = isProd;
exports.isConst = isConst;
exports.isConstruct = isConstruct;
exports.isFix = isFix;
exports.isCoFix = isCoFix;
exports.isCase = isCase;
exports.isProj = isProj;
exports.destArity = destArity;
exports.isArity = isArity;
exports.isVarId = isVarId;
exports.isRelN = isRelN;
exports.destRel = destRel;
exports.destMeta = destMeta;
exports.destVar = destVar;
exports.destSort = destSort;
exports.destCast = destCast;
exports.destProd = destProd;
exports.destLambda = destLambda;
exports.destLetIn = destLetIn;
exports.destApp = destApp;
exports.destConst = destConst;
exports.destEvar = destEvar;
exports.destInd = destInd;
exports.destConstruct = destConstruct;
exports.destCase = destCase;
exports.destProj = destProj;
exports.destFix = destFix;
exports.destCoFix = destCoFix;
exports.decompose_app = decompose_app;
exports.decompose_lam = decompose_lam;
exports.decompose_lam_assum = decompose_lam_assum;
exports.decompose_lam_n_assum = decompose_lam_n_assum;
exports.decompose_lam_n_decls = decompose_lam_n_decls;
exports.compose_lam = compose_lam;
exports.to_lambda = to_lambda;
exports.decompose_prod = decompose_prod;
exports.decompose_prod_assum = decompose_prod_assum;
exports.decompose_prod_n_assum = decompose_prod_n_assum;
exports.existential_type = existential_type;
exports.whd_evar = whd_evar;
exports.eq_constr = eq_constr;
exports.eq_constr_nounivs = eq_constr_nounivs;
exports.eq_constr_universes = eq_constr_universes;
exports.leq_constr_universes = leq_constr_universes;
exports.eq_constr_universes_proj = eq_constr_universes_proj;
exports.compare_constr = compare_constr;
exports.map = map;
exports.map_with_binders = map_with_binders;
exports.iter = iter;
exports.iter_with_binders = iter_with_binders;
exports.iter_with_full_binders = iter_with_full_binders;
exports.fold = fold;
exports.universes_of_constr = universes_of_constr;
exports.Vars = Vars;
exports.push_rel = push_rel;
exports.push_rel_context = push_rel_context;
exports.push_rec_types = push_rec_types;
exports.push_named = push_named;
exports.push_named_context = push_named_context;
exports.push_named_context_val = push_named_context_val;
exports.rel_context = rel_context;
exports.named_context = named_context;
exports.val_of_named_context = val_of_named_context;
exports.named_context_of_val = named_context_of_val;
exports.lookup_rel = lookup_rel;
exports.lookup_named = lookup_named;
exports.lookup_named_val = lookup_named_val;
exports.map_rel_context_in_env = map_rel_context_in_env;
exports.fresh_global = fresh_global;
exports.is_global = is_global;
exports.of_named_decl = of_named_decl;
exports.of_rel_decl = of_rel_decl;
exports.to_rel_decl = to_rel_decl;
exports.Unsafe = Unsafe;
/* mkProp Not a pure module */
