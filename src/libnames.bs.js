// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function pr_dirpath(sl) {
  return Names$ReactTemplate.DirPath[/* print */10](sl);
}

function split_dirpath(d) {
  var match = Names$ReactTemplate.DirPath[/* repr */4](d);
  if (match) {
    return /* tuple */[
            Names$ReactTemplate.DirPath[/* make */3](match[1]),
            match[0]
          ];
  } else {
    return Pervasives.failwith("split_dirpath");
  }
}

function pop_dirpath(p) {
  var match = Names$ReactTemplate.DirPath[/* repr */4](p);
  if (match) {
    return Names$ReactTemplate.DirPath[/* make */3](match[1]);
  } else {
    return Pervasives.failwith("pop_dirpath");
  }
}

function pop_dirpath_n(n, dir) {
  return Names$ReactTemplate.DirPath[/* make */3](Curry._2(Util$ReactTemplate.List[/* skipn */107], n, Names$ReactTemplate.DirPath[/* repr */4](dir)));
}

function is_dirpath_prefix_of(d1, d2) {
  return Curry._3(Util$ReactTemplate.List[/* prefix_of */110], Names$ReactTemplate.Id[/* equal */0], Curry._1(Util$ReactTemplate.List[/* rev */4], Names$ReactTemplate.DirPath[/* repr */4](d1)), Curry._1(Util$ReactTemplate.List[/* rev */4], Names$ReactTemplate.DirPath[/* repr */4](d2)));
}

function is_dirpath_suffix_of(dir1, dir2) {
  var dir1$1 = Names$ReactTemplate.DirPath[/* repr */4](dir1);
  var dir2$1 = Names$ReactTemplate.DirPath[/* repr */4](dir2);
  return Curry._3(Util$ReactTemplate.List[/* prefix_of */110], Names$ReactTemplate.Id[/* equal */0], dir1$1, dir2$1);
}

function chop_dirpath(n, d) {
  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], n, Curry._1(Util$ReactTemplate.List[/* rev */4], Names$ReactTemplate.DirPath[/* repr */4](d)));
  return /* tuple */[
          Names$ReactTemplate.DirPath[/* make */3](Curry._1(Util$ReactTemplate.List[/* rev */4], match[0])),
          Names$ReactTemplate.DirPath[/* make */3](Curry._1(Util$ReactTemplate.List[/* rev */4], match[1]))
        ];
}

function drop_dirpath_prefix(d1, d2) {
  var d = Curry._3(Util$ReactTemplate.List[/* drop_prefix */111], Names$ReactTemplate.Id[/* equal */0], Curry._1(Util$ReactTemplate.List[/* rev */4], Names$ReactTemplate.DirPath[/* repr */4](d1)), Curry._1(Util$ReactTemplate.List[/* rev */4], Names$ReactTemplate.DirPath[/* repr */4](d2)));
  return Names$ReactTemplate.DirPath[/* make */3](Curry._1(Util$ReactTemplate.List[/* rev */4], d));
}

function append_dirpath(d1, d2) {
  return Names$ReactTemplate.DirPath[/* make */3](Util$ReactTemplate.$at(Names$ReactTemplate.DirPath[/* repr */4](d2), Names$ReactTemplate.DirPath[/* repr */4](d1)));
}

function add_dirpath_prefix(id, d) {
  return Names$ReactTemplate.DirPath[/* make */3](Util$ReactTemplate.$at(Names$ReactTemplate.DirPath[/* repr */4](d), /* :: */[
                  id,
                  /* [] */0
                ]));
}

function add_dirpath_suffix(p, id) {
  return Names$ReactTemplate.DirPath[/* make */3](/* :: */[
              id,
              Names$ReactTemplate.DirPath[/* repr */4](p)
            ]);
}

function parse_dir(s) {
  var len = s.length;
  var _dirs = /* [] */0;
  var _n = 0;
  while(true) {
    var n = _n;
    var dirs = _dirs;
    if (n === len && n > 0) {
      CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(s + " is an invalid path."));
    }
    if (n >= len) {
      return dirs;
    } else {
      var pos;
      try {
        pos = Curry._3(Util$ReactTemplate.$$String[/* index_from */15], s, n, /* "." */46);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          pos = len;
        } else {
          throw exn;
        }
      }
      if (pos === n) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(s + " is an invalid path."));
      }
      var dir = Curry._3(Util$ReactTemplate.$$String[/* sub */3], s, n, pos - n | 0);
      _n = pos + 1 | 0;
      _dirs = /* :: */[
        Names$ReactTemplate.Id[/* of_string */5](dir),
        dirs
      ];
      continue ;
      
    }
  };
}

function dirpath_of_string(s) {
  var tmp = s === "" ? /* [] */0 : parse_dir(s);
  return Names$ReactTemplate.DirPath[/* make */3](tmp);
}

var string_of_dirpath = Names$ReactTemplate.DirPath[/* to_string */7];

var Dirset = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], [Names$ReactTemplate.DirPath[1]]);

var Dirmap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], [Names$ReactTemplate.DirPath[1]]);

function dirpath(sp) {
  return sp[/* dirpath */0];
}

function basename(sp) {
  return sp[/* basename */1];
}

function make_path(pa, id) {
  return /* record */[
          /* dirpath */pa,
          /* basename */id
        ];
}

function repr_path(param) {
  return /* tuple */[
          param[/* dirpath */0],
          param[/* basename */1]
        ];
}

function eq_full_path(p1, p2) {
  if (Names$ReactTemplate.Id[/* equal */0](p1[/* basename */1], p2[/* basename */1])) {
    return Curry._2(Names$ReactTemplate.DirPath[/* equal */0], p1[/* dirpath */0], p2[/* dirpath */0]);
  } else {
    return /* false */0;
  }
}

function string_of_path(sp) {
  var match = repr_path(sp);
  var id = match[1];
  var sl = match[0];
  var match$1 = Names$ReactTemplate.DirPath[/* repr */4](sl);
  if (match$1) {
    return Names$ReactTemplate.DirPath[/* to_string */7](sl) + ("." + Names$ReactTemplate.Id[/* to_string */7](id));
  } else {
    return Names$ReactTemplate.Id[/* to_string */7](id);
  }
}

function sp_ord(sp1, sp2) {
  var match = repr_path(sp1);
  var match$1 = repr_path(sp2);
  var p_bit = Curry._2(Names$ReactTemplate.DirPath[/* compare */1], match[0], match$1[0]);
  if (p_bit) {
    return p_bit;
  } else {
    return Curry._2(Names$ReactTemplate.Id[/* compare */1], match[1], match$1[1]);
  }
}

var SpOrdered = /* module */[/* compare */sp_ord];

var Spmap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], SpOrdered);

function path_of_string(s) {
  try {
    var match = split_dirpath(dirpath_of_string(s));
    return /* record */[
            /* dirpath */match[0],
            /* basename */match[1]
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return CErrors$ReactTemplate.invalid_arg(/* None */0, "path_of_string");
    } else {
      throw exn;
    }
  }
}

function pr_path(sp) {
  return Pp$ReactTemplate.str(string_of_path(sp));
}

function restrict_path(n, sp) {
  var match = repr_path(sp);
  var dir$prime = Curry._2(Util$ReactTemplate.List[/* firstn */104], n, Names$ReactTemplate.DirPath[/* repr */4](match[0]));
  return /* record */[
          /* dirpath */Names$ReactTemplate.DirPath[/* make */3](dir$prime),
          /* basename */match[1]
        ];
}

function qualid_of_path(sp) {
  return sp;
}

function qualid_of_ident(id) {
  return /* record */[
          /* dirpath */Names$ReactTemplate.DirPath[/* empty */5],
          /* basename */id
        ];
}

function qualid_of_dirpath(dir) {
  var match = split_dirpath(dir);
  return /* record */[
          /* dirpath */match[0],
          /* basename */match[1]
        ];
}

function make_oname(param, id) {
  return /* tuple */[
          /* record */[
            /* dirpath */param[/* obj_dir */0],
            /* basename */id
          ],
          Names$ReactTemplate.KerName[/* make */0](param[/* obj_mp */1], param[/* obj_sec */2], Names$ReactTemplate.Label[/* of_id */5](id))
        ];
}

function eq_op(op1, op2) {
  if (Curry._2(Names$ReactTemplate.DirPath[/* equal */0], op1[/* obj_dir */0], op2[/* obj_dir */0]) && Curry._2(Names$ReactTemplate.DirPath[/* equal */0], op1[/* obj_sec */2], op2[/* obj_sec */2])) {
    return Names$ReactTemplate.ModPath[/* equal */1](op1[/* obj_mp */1], op2[/* obj_mp */1]);
  } else {
    return /* false */0;
  }
}

function eq_global_dir_reference(r1, r2) {
  switch (r1.tag | 0) {
    case 0 : 
        if (r2.tag) {
          return /* false */0;
        } else {
          return eq_op(r1[0], r2[0]);
        }
        break;
    case 1 : 
        if (r2.tag === 1) {
          return eq_op(r1[0], r2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 2 : 
        if (r2.tag === 2) {
          return eq_op(r1[0], r2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 3 : 
        if (r2.tag === 3) {
          return eq_op(r1[0], r2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 4 : 
        if (r2.tag === 4) {
          return Curry._2(Names$ReactTemplate.DirPath[/* equal */0], r1[0], r2[0]);
        } else {
          return /* false */0;
        }
        break;
    
  }
}

function qualid_of_reference(param) {
  return CAst$ReactTemplate.map((function (param) {
                if (param.tag) {
                  return /* record */[
                          /* dirpath */Names$ReactTemplate.DirPath[/* empty */5],
                          /* basename */param[0]
                        ];
                } else {
                  return param[0];
                }
              }), param);
}

function string_of_reference(param) {
  return CAst$ReactTemplate.with_val((function (param) {
                if (param.tag) {
                  return Names$ReactTemplate.Id[/* to_string */7](param[0]);
                } else {
                  return string_of_path(param[0]);
                }
              }), param);
}

function pr_reference(param) {
  return CAst$ReactTemplate.with_val((function (param) {
                if (param.tag) {
                  return Names$ReactTemplate.Id[/* print */8](param[0]);
                } else {
                  return Pp$ReactTemplate.str(string_of_path(param[0]));
                }
              }), param);
}

function eq_reference(param, param$1) {
  var r2 = param$1[/* v */0];
  var r1 = param[/* v */0];
  if (r1.tag) {
    if (r2.tag) {
      return Names$ReactTemplate.Id[/* equal */0](r1[0], r2[0]);
    } else {
      return /* false */0;
    }
  } else if (r2.tag) {
    return /* false */0;
  } else {
    return eq_full_path(r1[0], r2[0]);
  }
}

function join_reference(param, param$1) {
  var r = param$1[/* v */0];
  var ns = param[/* v */0];
  var tmp;
  if (ns.tag) {
    var id1 = ns[0];
    if (r.tag) {
      tmp = /* Qualid */Block.__(0, [/* record */[
            /* dirpath */dirpath_of_string(Names$ReactTemplate.Id[/* to_string */7](id1)),
            /* basename */r[0]
          ]]);
    } else {
      var match = repr_path(r[0]);
      tmp = /* Qualid */Block.__(0, [/* record */[
            /* dirpath */append_dirpath(dirpath_of_string(Names$ReactTemplate.Id[/* to_string */7](id1)), match[0]),
            /* basename */match[1]
          ]]);
    }
  } else {
    var q1 = ns[0];
    if (r.tag) {
      var match$1 = repr_path(q1);
      tmp = /* Qualid */Block.__(0, [/* record */[
            /* dirpath */append_dirpath(match$1[0], dirpath_of_string(Names$ReactTemplate.Id[/* to_string */7](match$1[1]))),
            /* basename */r[0]
          ]]);
    } else {
      var match$2 = repr_path(q1);
      var match$3 = repr_path(r[0]);
      tmp = /* Qualid */Block.__(0, [/* record */[
            /* dirpath */append_dirpath(append_dirpath(match$2[0], dirpath_of_string(Names$ReactTemplate.Id[/* to_string */7](match$2[1]))), match$3[0]),
            /* basename */match$3[1]
          ]]);
    }
  }
  return CAst$ReactTemplate.make(Loc$ReactTemplate.merge_opt(param[/* loc */1], param$1[/* loc */1]), tmp);
}

var default_library = Names$ReactTemplate.DirPath[/* initial */8];

var coq_string = "Coq";

var coq_root = Names$ReactTemplate.Id[/* of_string */5](coq_string);

var default_root_prefix = Names$ReactTemplate.DirPath[/* empty */5];

var Spmap_000 = Spmap[0];

var Spmap_001 = Spmap[1];

var Spmap_002 = Spmap[2];

var Spmap_003 = Spmap[3];

var Spmap_004 = Spmap[4];

var Spmap_005 = Spmap[5];

var Spmap_006 = Spmap[6];

var Spmap_007 = Spmap[7];

var Spmap_008 = Spmap[8];

var Spmap_009 = Spmap[9];

var Spmap_010 = Spmap[10];

var Spmap_011 = Spmap[11];

var Spmap_012 = Spmap[12];

var Spmap_013 = Spmap[13];

var Spmap_014 = Spmap[14];

var Spmap_015 = Spmap[15];

var Spmap_016 = Spmap[16];

var Spmap_017 = Spmap[17];

var Spmap_018 = Spmap[18];

var Spmap_019 = Spmap[19];

var Spmap_020 = Spmap[20];

var Spmap_021 = Spmap[21];

var Spmap_022 = Spmap[22];

var Spmap_023 = Spmap[23];

var Spmap$1 = [
  Spmap_000,
  Spmap_001,
  Spmap_002,
  Spmap_003,
  Spmap_004,
  Spmap_005,
  Spmap_006,
  Spmap_007,
  Spmap_008,
  Spmap_009,
  Spmap_010,
  Spmap_011,
  Spmap_012,
  Spmap_013,
  Spmap_014,
  Spmap_015,
  Spmap_016,
  Spmap_017,
  Spmap_018,
  Spmap_019,
  Spmap_020,
  Spmap_021,
  Spmap_022,
  Spmap_023
];

var make_qualid = make_path;

var repr_qualid = repr_path;

var qualid_eq = eq_full_path;

var pr_qualid = pr_path;

var string_of_qualid = string_of_path;

var qualid_of_string = path_of_string;

var make_short_qualid = qualid_of_ident;

var qualid_of_sp = qualid_of_path;

exports.dirpath_of_string = dirpath_of_string;
exports.pr_dirpath = pr_dirpath;
exports.string_of_dirpath = string_of_dirpath;
exports.pop_dirpath = pop_dirpath;
exports.pop_dirpath_n = pop_dirpath_n;
exports.split_dirpath = split_dirpath;
exports.add_dirpath_suffix = add_dirpath_suffix;
exports.add_dirpath_prefix = add_dirpath_prefix;
exports.chop_dirpath = chop_dirpath;
exports.append_dirpath = append_dirpath;
exports.drop_dirpath_prefix = drop_dirpath_prefix;
exports.is_dirpath_prefix_of = is_dirpath_prefix_of;
exports.is_dirpath_suffix_of = is_dirpath_suffix_of;
exports.Dirset = Dirset;
exports.Dirmap = Dirmap;
exports.eq_full_path = eq_full_path;
exports.make_path = make_path;
exports.repr_path = repr_path;
exports.dirpath = dirpath;
exports.basename = basename;
exports.path_of_string = path_of_string;
exports.string_of_path = string_of_path;
exports.pr_path = pr_path;
exports.Spmap = Spmap$1;
exports.restrict_path = restrict_path;
exports.make_qualid = make_qualid;
exports.repr_qualid = repr_qualid;
exports.qualid_eq = qualid_eq;
exports.pr_qualid = pr_qualid;
exports.string_of_qualid = string_of_qualid;
exports.qualid_of_string = qualid_of_string;
exports.qualid_of_path = qualid_of_path;
exports.qualid_of_dirpath = qualid_of_dirpath;
exports.qualid_of_ident = qualid_of_ident;
exports.eq_op = eq_op;
exports.make_oname = make_oname;
exports.eq_global_dir_reference = eq_global_dir_reference;
exports.eq_reference = eq_reference;
exports.qualid_of_reference = qualid_of_reference;
exports.string_of_reference = string_of_reference;
exports.pr_reference = pr_reference;
exports.join_reference = join_reference;
exports.default_library = default_library;
exports.coq_root = coq_root;
exports.coq_string = coq_string;
exports.default_root_prefix = default_root_prefix;
exports.make_short_qualid = make_short_qualid;
exports.qualid_of_sp = qualid_of_sp;
/* Dirset Not a pure module */
