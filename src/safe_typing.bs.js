// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var Modops$ReactTemplate = require("./modops.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Typeops$ReactTemplate = require("./typeops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Subtyping$ReactTemplate = require("./subtyping.bs.js");
var CEphemeron$ReactTemplate = require("./cEphemeron.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");
var Mod_typing$ReactTemplate = require("./mod_typing.bs.js");
var Conv_oracle$ReactTemplate = require("./conv_oracle.bs.js");
var Opaqueproof$ReactTemplate = require("./opaqueproof.bs.js");
var Term_typing$ReactTemplate = require("./term_typing.bs.js");

function digest_match(actual, required) {
  if (actual.tag) {
    var d1 = actual[0];
    if (required.tag) {
      if (d1 === required[0]) {
        return +(actual[1] === required[1]);
      } else {
        return /* false */0;
      }
    } else {
      return +(d1 === required[0]);
    }
  } else if (required.tag) {
    return /* false */0;
  } else {
    return +(actual[0] === required[0]);
  }
}

var DPMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], [Names$ReactTemplate.DirPath[1]]);

function library_dp_of_senv(_senv) {
  while(true) {
    var senv = _senv;
    var match = senv[/* modvariant */2];
    if (typeof match === "number") {
      return Names$ReactTemplate.ModPath[/* dp */7](senv[/* modpath */1]);
    } else {
      _senv = match[1];
      continue ;
      
    }
  };
}

var empty_environment_001 = /* modpath */Names$ReactTemplate.ModPath[/* initial */6];

var empty_environment_006 = /* modlabels */Names$ReactTemplate.Label[/* Set */8][/* empty */0];

var empty_environment_007 = /* objlabels */Names$ReactTemplate.Label[/* Set */8][/* empty */0];

var empty_environment_008 = /* univ */Univ$ReactTemplate.ContextSet[/* empty */0];

var empty_environment_011 = /* required */DPMap[/* empty */0];

var empty_environment = /* record */[
  /* env */Environ$ReactTemplate.empty_env,
  empty_environment_001,
  /* modvariant : NONE */0,
  /* modresolver */Mod_subst$ReactTemplate.empty_delta_resolver,
  /* paramresolver */Mod_subst$ReactTemplate.empty_delta_resolver,
  /* revstruct : [] */0,
  empty_environment_006,
  empty_environment_007,
  empty_environment_008,
  /* future_cst : [] */0,
  /* engagement : None */0,
  empty_environment_011,
  /* loads : [] */0,
  /* local_retroknowledge : [] */0
];

function is_initial(senv) {
  var match = senv[/* revstruct */5];
  var match$1 = senv[/* modvariant */2];
  if (match || !(typeof match$1 === "number" && match$1 === 0)) {
    return /* false */0;
  } else {
    return Names$ReactTemplate.ModPath[/* equal */1](senv[/* modpath */1], Names$ReactTemplate.ModPath[/* initial */6]);
  }
}

function delta_of_senv(senv) {
  return /* tuple */[
          senv[/* modresolver */3],
          senv[/* paramresolver */4]
        ];
}

function set_engagement_opt(env, param) {
  if (param) {
    return Environ$ReactTemplate.set_engagement(param[0], env);
  } else {
    return env;
  }
}

function set_engagement(c, senv) {
  var newrecord = senv.slice();
  newrecord[/* env */0] = Environ$ReactTemplate.set_engagement(c, senv[/* env */0]);
  newrecord[/* engagement */10] = /* Some */[c];
  return newrecord;
}

function set_typing_flags(c, senv) {
  var newrecord = senv.slice();
  newrecord[/* env */0] = Environ$ReactTemplate.set_typing_flags(c, senv[/* env */0]);
  return newrecord;
}

function get_opaque_body(env, cbo) {
  var match = cbo[/* const_body */1];
  switch (match.tag | 0) {
    case 0 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "safe_typing.ml",
                205,
                15
              ]
            ];
    case 1 : 
        return /* Nothing */481346541;
    case 2 : 
        var opaque = match[0];
        return /* `Opaque */[
                -746172159,
                /* tuple */[
                  Opaqueproof$ReactTemplate.force_proof(Environ$ReactTemplate.opaque_tables(env), opaque),
                  Opaqueproof$ReactTemplate.force_constraints(Environ$ReactTemplate.opaque_tables(env), opaque)
                ]
              ];
    
  }
}

function private_con_of_con(env, c) {
  var cbo = Environ$ReactTemplate.lookup_constant(c, env[/* env */0]);
  return /* record */[
          /* from_env */CEphemeron$ReactTemplate.create(env[/* revstruct */5]),
          /* eff : SEsubproof */Block.__(0, [
              c,
              cbo,
              get_opaque_body(env[/* env */0], cbo)
            ])
        ];
}

function private_con_of_scheme(kind, env, cl) {
  return /* record */[
          /* from_env */CEphemeron$ReactTemplate.create(env[/* revstruct */5]),
          /* eff : SEscheme */Block.__(1, [
              Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                      var c = param[1];
                      var cbo = Environ$ReactTemplate.lookup_constant(c, env[/* env */0]);
                      return /* tuple */[
                              param[0],
                              c,
                              cbo,
                              get_opaque_body(env[/* env */0], cbo)
                            ];
                    }), cl),
              kind
            ])
        ];
}

function universes_of_private(eff) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
                var eff = param[/* eff */1];
                if (eff.tag) {
                  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
                                var c = param[3];
                                var acc$1 = typeof c === "number" ? acc : /* :: */[
                                    c[1][1],
                                    acc
                                  ];
                                var match = param[2][/* const_universes */4];
                                if (match.tag) {
                                  return acc$1;
                                } else {
                                  return /* :: */[
                                          match[0],
                                          acc$1
                                        ];
                                }
                              }), acc, eff[0]);
                } else {
                  var match = eff[1][/* const_universes */4];
                  if (match.tag) {
                    return acc;
                  } else {
                    return /* :: */[
                            match[0],
                            acc
                          ];
                  }
                }
              }), /* [] */0, Term_typing$ReactTemplate.uniq_seff(eff));
}

function env_of_safe_env(senv) {
  return senv[/* env */0];
}

function add_constraints(cst, senv) {
  if (cst.tag) {
    var newrecord = senv.slice();
    newrecord[/* future_cst */9] = /* :: */[
      cst[0],
      senv[/* future_cst */9]
    ];
    return newrecord;
  } else {
    var cst$1 = cst[1];
    var newrecord$1 = senv.slice();
    newrecord$1[/* env */0] = Environ$ReactTemplate.push_context_set(/* Some */[1 - cst[0]], cst$1, senv[/* env */0]);
    newrecord$1[/* univ */8] = Univ$ReactTemplate.ContextSet[/* union */6](cst$1, senv[/* univ */8]);
    return newrecord$1;
  }
}

function add_constraints_list(cst, senv) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, c) {
                return add_constraints(c, acc);
              }), senv, cst);
}

function push_context_set(poly, ctx) {
  var partial_arg = /* Now */Block.__(0, [
      poly,
      ctx
    ]);
  return (function (param) {
      return add_constraints(partial_arg, param);
    });
}

function push_context(poly, ctx) {
  var partial_arg_001 = Univ$ReactTemplate.ContextSet[/* of_context */14](ctx);
  var partial_arg = /* Now */Block.__(0, [
      poly,
      partial_arg_001
    ]);
  return (function (param) {
      return add_constraints(partial_arg, param);
    });
}

function is_curmod_library(senv) {
  var match = senv[/* modvariant */2];
  if (typeof match === "number" && match !== 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function join_safe_environment($staropt$star, e) {
  var except = $staropt$star ? $staropt$star[0] : Future$ReactTemplate.UUIDSet[/* empty */0];
  Modops$ReactTemplate.join_structure(except, Environ$ReactTemplate.opaque_tables(e[/* env */0]), e[/* revstruct */5]);
  var newrecord = e.slice();
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (e, fc) {
                if (Curry._2(Future$ReactTemplate.UUIDSet[/* mem */2], Future$ReactTemplate.uuid(fc), except)) {
                  return e;
                } else {
                  return add_constraints(/* Now */Block.__(0, [
                                /* false */0,
                                Future$ReactTemplate.join(fc)
                              ]), e);
                }
              }), (newrecord[/* future_cst */9] = /* [] */0, newrecord), e[/* future_cst */9]);
}

function is_joined_environment(e) {
  return Curry._1(Util$ReactTemplate.List[/* is_empty */45], e[/* future_cst */9]);
}

function exists_modlabel(l, senv) {
  return Curry._2(Names$ReactTemplate.Label[/* Set */8][/* mem */2], l, senv[/* modlabels */6]);
}

function exists_objlabel(l, senv) {
  return Curry._2(Names$ReactTemplate.Label[/* Set */8][/* mem */2], l, senv[/* objlabels */7]);
}

function check_modlabel(l, senv) {
  if (exists_modlabel(l, senv)) {
    return Modops$ReactTemplate.error_existing_label(l);
  } else {
    return 0;
  }
}

function check_objlabel(l, senv) {
  if (exists_objlabel(l, senv)) {
    return Modops$ReactTemplate.error_existing_label(l);
  } else {
    return 0;
  }
}

function check_objlabels(ls, senv) {
  return Curry._2(Names$ReactTemplate.Label[/* Set */8][/* iter */12], (function (l) {
                return check_objlabel(l, senv);
              }), ls);
}

function check_current_label(lab, param) {
  switch (param.tag | 0) {
    case 0 : 
    case 1 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "safe_typing.ml",
                321,
                9
              ]
            ];
    case 2 : 
        if (Names$ReactTemplate.Label[/* equal */0](lab, param[1])) {
          return 0;
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "safe_typing.ml",
                  320,
                  19
                ]
              ];
        }
        break;
    
  }
}

function check_struct(param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "safe_typing.ml",
            325,
            30
          ]
        ];
  } else if (param.tag === 1) {
    return /* tuple */[
            param[0],
            param[1]
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "safe_typing.ml",
            325,
            30
          ]
        ];
  }
}

function check_sig(param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "safe_typing.ml",
            329,
            33
          ]
        ];
  } else if (param.tag) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "safe_typing.ml",
            329,
            33
          ]
        ];
  } else {
    return /* tuple */[
            param[0],
            param[1]
          ];
  }
}

function check_empty_context(senv) {
  if (Environ$ReactTemplate.empty_context(senv[/* env */0])) {
    return 0;
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "safe_typing.ml",
            338,
            2
          ]
        ];
  }
}

function check_empty_struct(senv) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], senv[/* revstruct */5]) && Curry._1(Util$ReactTemplate.List[/* is_empty */45], senv[/* loads */12])) {
    return 0;
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "safe_typing.ml",
            344,
            2
          ]
        ];
  }
}

function safe_push_named(d, env) {
  var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
  try {
    Environ$ReactTemplate.lookup_named(id, env);
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.pr_sequence(Pp$ReactTemplate.str, /* :: */[
              "Identifier",
              /* :: */[
                Names$ReactTemplate.Id[/* to_string */7](id),
                /* :: */[
                  "already defined.",
                  /* [] */0
                ]
              ]
            ]));
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    
  }
  return Environ$ReactTemplate.push_named(d, env);
}

function push_named_def(param, senv) {
  var id = param[0];
  var match = Term_typing$ReactTemplate.translate_local_def(senv[/* env */0], id, param[1]);
  var env$prime$prime = safe_push_named(/* LocalDef */Block.__(1, [
          id,
          match[0],
          match[1]
        ]), senv[/* env */0]);
  var newrecord = senv.slice();
  newrecord[/* env */0] = env$prime$prime;
  return newrecord;
}

function push_named_assum(param, senv) {
  var match = param[0];
  var senv$prime = push_context_set(match[2], param[1])(senv);
  var t = Term_typing$ReactTemplate.translate_local_assum(senv$prime[/* env */0], match[1]);
  var env$prime$prime = safe_push_named(/* LocalAssum */Block.__(0, [
          match[0],
          t
        ]), senv$prime[/* env */0]);
  var newrecord = senv$prime.slice();
  newrecord[/* env */0] = env$prime$prime;
  return newrecord;
}

function labels_of_mib(mib) {
  var labels = [Names$ReactTemplate.Label[/* Set */8][/* empty */0]];
  var match_000 = function (id) {
    labels[0] = Curry._2(Names$ReactTemplate.Label[/* Set */8][/* add */3], Names$ReactTemplate.Label[/* of_id */5](id), labels[0]);
    return /* () */0;
  };
  var match_001 = function () {
    return labels[0];
  };
  var add = match_000;
  var visit_mip = function (mip) {
    Curry._1(add, mip[/* mind_typename */0]);
    return Util$ReactTemplate.$$Array[/* iter */11](add, mip[/* mind_consnames */3]);
  };
  Util$ReactTemplate.$$Array[/* iter */11](visit_mip, mib[/* mind_packets */0]);
  return Curry._1(match_001, /* () */0);
}

function constraints_of_sfb(env, sfb) {
  var exit = 0;
  switch (sfb.tag | 0) {
    case 0 : 
        var env$1 = env;
        var cb = sfb[0];
        var match = cb[/* const_universes */4];
        if (match.tag) {
          return /* :: */[
                  /* Now */Block.__(0, [
                      /* true */1,
                      Univ$ReactTemplate.ContextSet[/* empty */0]
                    ]),
                  /* [] */0
                ];
        } else {
          var match$1 = cb[/* const_body */1];
          var tmp;
          switch (match$1.tag | 0) {
            case 0 : 
            case 1 : 
                tmp = /* [] */0;
                break;
            case 2 : 
                var match$2 = Opaqueproof$ReactTemplate.get_constraints(Environ$ReactTemplate.opaque_tables(env$1), match$1[0]);
                if (match$2) {
                  var fc = match$2[0];
                  var match$3 = Future$ReactTemplate.peek_val(fc);
                  tmp = match$3 ? /* :: */[
                      /* Now */Block.__(0, [
                          /* false */0,
                          match$3[0]
                        ]),
                      /* [] */0
                    ] : /* :: */[
                      /* Later */Block.__(1, [fc]),
                      /* [] */0
                    ];
                } else {
                  tmp = /* [] */0;
                }
                break;
            
          }
          return /* :: */[
                  /* Now */Block.__(0, [
                      /* false */0,
                      match[0]
                    ]),
                  tmp
                ];
        }
    case 1 : 
        var mb = sfb[0];
        var match$4 = mb[/* mind_universes */8];
        switch (match$4.tag | 0) {
          case 0 : 
              return /* :: */[
                      /* Now */Block.__(0, [
                          /* false */0,
                          match$4[0]
                        ]),
                      /* [] */0
                    ];
          case 1 : 
          case 2 : 
              return /* :: */[
                      /* Now */Block.__(0, [
                          /* true */1,
                          Univ$ReactTemplate.ContextSet[/* empty */0]
                        ]),
                      /* [] */0
                    ];
          
        }
    case 2 : 
    case 3 : 
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    return /* :: */[
            /* Now */Block.__(0, [
                /* false */0,
                sfb[0][/* mod_constraints */4]
              ]),
            /* [] */0
          ];
  }
  
}

function add_field(field, gn, senv) {
  var sfb = field[1];
  var l = field[0];
  var match;
  var exit = 0;
  switch (sfb.tag | 0) {
    case 0 : 
        check_objlabel(l, senv);
        match = /* tuple */[
          Names$ReactTemplate.Label[/* Set */8][/* empty */0],
          Curry._1(Names$ReactTemplate.Label[/* Set */8][/* singleton */4], l)
        ];
        break;
    case 1 : 
        var l$1 = labels_of_mib(sfb[0]);
        check_objlabels(l$1, senv);
        match = /* tuple */[
          Names$ReactTemplate.Label[/* Set */8][/* empty */0],
          l$1
        ];
        break;
    case 2 : 
    case 3 : 
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    check_modlabel(l, senv);
    match = /* tuple */[
      Curry._1(Names$ReactTemplate.Label[/* Set */8][/* singleton */4], l),
      Names$ReactTemplate.Label[/* Set */8][/* empty */0]
    ];
  }
  var cst = constraints_of_sfb(senv[/* env */0], sfb);
  var senv$1 = add_constraints_list(cst, senv);
  var env$prime;
  var exit$1 = 0;
  switch (sfb.tag | 0) {
    case 0 : 
        if (typeof gn === "number" || gn.tag) {
          exit$1 = 1;
        } else {
          env$prime = Environ$ReactTemplate.add_constant(gn[0], sfb[0], senv$1[/* env */0]);
        }
        break;
    case 1 : 
        if (typeof gn === "number" || gn.tag !== 1) {
          exit$1 = 1;
        } else {
          env$prime = Environ$ReactTemplate.add_mind(gn[0], sfb[0], senv$1[/* env */0]);
        }
        break;
    case 2 : 
        if (typeof gn === "number" && gn === 0) {
          env$prime = Modops$ReactTemplate.add_module(sfb[0], senv$1[/* env */0]);
        } else {
          exit$1 = 1;
        }
        break;
    case 3 : 
        if (typeof gn === "number" && gn !== 0) {
          env$prime = Environ$ReactTemplate.add_modtype(sfb[0], senv$1[/* env */0]);
        } else {
          exit$1 = 1;
        }
        break;
    
  }
  if (exit$1 === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "safe_typing.ml",
            469,
            11
          ]
        ];
  }
  var newrecord = senv$1.slice();
  newrecord[/* env */0] = env$prime;
  newrecord[/* revstruct */5] = /* :: */[
    field,
    senv$1[/* revstruct */5]
  ];
  newrecord[/* modlabels */6] = Curry._2(Names$ReactTemplate.Label[/* Set */8][/* union */6], match[0], senv$1[/* modlabels */6]);
  newrecord[/* objlabels */7] = Curry._2(Names$ReactTemplate.Label[/* Set */8][/* union */6], match[1], senv$1[/* objlabels */7]);
  return newrecord;
}

function update_resolver(f, senv) {
  var newrecord = senv.slice();
  newrecord[/* modresolver */3] = Curry._1(f, senv[/* modresolver */3]);
  return newrecord;
}

function add_constant_aux(no_section, senv, param) {
  var cb = param[1];
  var kn = param[0];
  var l = Util$ReactTemplate.pi3(Names$ReactTemplate.Constant[/* repr3 */6](kn));
  var match = cb[/* const_body */1];
  var match$1;
  var exit = 0;
  switch (match.tag | 0) {
    case 0 : 
    case 1 : 
        exit = 1;
        break;
    case 2 : 
        if (no_section) {
          var match$2 = Opaqueproof$ReactTemplate.turn_indirect(library_dp_of_senv(senv), match[0], Environ$ReactTemplate.opaque_tables(senv[/* env */0]));
          var newrecord = cb.slice();
          match$1 = /* tuple */[
            (newrecord[/* const_body */1] = /* OpaqueDef */Block.__(2, [match$2[0]]), newrecord),
            match$2[1]
          ];
        } else {
          exit = 1;
        }
        break;
    
  }
  if (exit === 1) {
    match$1 = /* tuple */[
      cb,
      Environ$ReactTemplate.opaque_tables(senv[/* env */0])
    ];
  }
  var cb$1 = match$1[0];
  var newrecord$1 = senv.slice();
  newrecord$1[/* env */0] = Environ$ReactTemplate.set_opaque_tables(senv[/* env */0], match$1[1]);
  var senv$prime = add_field(/* tuple */[
        l,
        /* SFBconst */Block.__(0, [cb$1])
      ], /* C */Block.__(0, [kn]), newrecord$1);
  var match$3 = cb$1[/* const_body */1];
  switch (match$3.tag | 0) {
    case 0 : 
        var match$4 = match$3[0];
        if (match$4) {
          return update_resolver(Mod_subst$ReactTemplate.add_inline_delta_resolver(Names$ReactTemplate.Constant[/* user */4](kn), /* tuple */[
                          match$4[0],
                          /* None */0
                        ]), senv$prime);
        } else {
          return senv$prime;
        }
    case 1 : 
    case 2 : 
        return senv$prime;
    
  }
}

function export_private_constants(in_section, ce, senv) {
  var match = Term_typing$ReactTemplate.export_side_effects(senv[/* revstruct */5], senv[/* env */0], ce);
  var exported = match[0];
  var bodies = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[0],
                  param[1]
                ];
        }), exported);
  var exported$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[0],
                  param[2]
                ];
        }), exported);
  var no_section = 1 - in_section;
  var senv$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
          return add_constant_aux(no_section, param, param$1);
        }), senv, bodies);
  return /* tuple */[
          /* tuple */[
            match[1],
            exported$1
          ],
          senv$1
        ];
}

function add_constant(dir, l, decl, senv) {
  var kn = Names$ReactTemplate.Constant[/* make3 */3](senv[/* modpath */1], dir, l);
  var no_section = Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], dir);
  var cb;
  if (decl.tag) {
    var cb$1 = Term_typing$ReactTemplate.translate_recipe(senv[/* env */0], kn, decl[0]);
    cb = no_section ? Declareops$ReactTemplate.hcons_const_body(cb$1) : cb$1;
  } else {
    cb = decl[0] !== 0 ? Term_typing$ReactTemplate.translate_constant(/* Pure */0, senv[/* env */0], kn, decl[1]) : Term_typing$ReactTemplate.translate_constant(/* SideEffects */[senv[/* revstruct */5]], senv[/* env */0], kn, decl[1]);
  }
  var senv$1 = add_constant_aux(no_section, senv, /* tuple */[
        kn,
        cb
      ]);
  return /* tuple */[
          kn,
          senv$1
        ];
}

function check_mind(mie, lab) {
  var match = mie[/* mind_entry_inds */3];
  if (match) {
    if (Names$ReactTemplate.Id[/* equal */0](Names$ReactTemplate.Label[/* to_id */6](lab), match[0][/* mind_entry_typename */0])) {
      return 0;
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "safe_typing.ml",
              547,
              4
            ]
          ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "safe_typing.ml",
            544,
            10
          ]
        ];
  }
}

function add_mind(dir, l, mie, senv) {
  check_mind(mie, l);
  var kn = Names$ReactTemplate.MutInd[/* make3 */3](senv[/* modpath */1], dir, l);
  var mib = Term_typing$ReactTemplate.translate_mind(senv[/* env */0], kn, mie);
  var match = mib[/* mind_hyps */4];
  var mib$1 = match ? mib : Declareops$ReactTemplate.hcons_mind(mib);
  return /* tuple */[
          kn,
          add_field(/* tuple */[
                l,
                /* SFBmind */Block.__(1, [mib$1])
              ], /* I */Block.__(1, [kn]), senv)
        ];
}

function add_modtype(l, params_mte, inl, senv) {
  var mp_000 = senv[/* modpath */1];
  var mp = /* MPdot */Block.__(2, [
      mp_000,
      l
    ]);
  var mtb = Mod_typing$ReactTemplate.translate_modtype(senv[/* env */0], mp, inl, params_mte);
  var mtb$1 = Declareops$ReactTemplate.hcons_module_type(mtb);
  var senv$prime = add_field(/* tuple */[
        l,
        /* SFBmodtype */Block.__(3, [mtb$1])
      ], /* MT */1, senv);
  return /* tuple */[
          mp,
          senv$prime
        ];
}

function full_add_module_type(mp, mt, senv) {
  var senv$1 = add_constraints(/* Now */Block.__(0, [
          /* false */0,
          mt[/* mod_constraints */4]
        ]), senv);
  var newrecord = senv$1.slice();
  newrecord[/* env */0] = Modops$ReactTemplate.add_module_type(mp, mt, senv$1[/* env */0]);
  return newrecord;
}

function add_module(l, me, inl, senv) {
  var mp_000 = senv[/* modpath */1];
  var mp = /* MPdot */Block.__(2, [
      mp_000,
      l
    ]);
  var mb = Mod_typing$ReactTemplate.translate_module(senv[/* env */0], mp, inl, me);
  var mb$1 = Declareops$ReactTemplate.hcons_module_body(mb);
  var senv$prime = add_field(/* tuple */[
        l,
        /* SFBmodule */Block.__(2, [mb$1])
      ], /* M */0, senv);
  var senv$prime$prime;
  if (Modops$ReactTemplate.is_functor(mb$1[/* mod_type */2])) {
    senv$prime$prime = senv$prime;
  } else {
    var partial_arg = mb$1[/* mod_delta */5];
    senv$prime$prime = update_resolver((function (param) {
            return Mod_subst$ReactTemplate.add_delta_resolver(partial_arg, param);
          }), senv$prime);
  }
  return /* tuple */[
          /* tuple */[
            mp,
            mb$1[/* mod_delta */5]
          ],
          senv$prime$prime
        ];
}

function start_module(l, senv) {
  check_modlabel(l, senv);
  check_empty_context(senv);
  var mp_000 = senv[/* modpath */1];
  var mp = /* MPdot */Block.__(2, [
      mp_000,
      l
    ]);
  var newrecord = empty_environment.slice();
  return /* tuple */[
          mp,
          (newrecord[/* env */0] = senv[/* env */0], newrecord[/* modpath */1] = mp, newrecord[/* modvariant */2] = /* STRUCT */Block.__(1, [
                /* [] */0,
                senv
              ]), newrecord[/* required */11] = senv[/* required */11], newrecord)
        ];
}

function start_modtype(l, senv) {
  check_modlabel(l, senv);
  check_empty_context(senv);
  var mp_000 = senv[/* modpath */1];
  var mp = /* MPdot */Block.__(2, [
      mp_000,
      l
    ]);
  var newrecord = empty_environment.slice();
  return /* tuple */[
          mp,
          (newrecord[/* env */0] = senv[/* env */0], newrecord[/* modpath */1] = mp, newrecord[/* modvariant */2] = /* SIG */Block.__(0, [
                /* [] */0,
                senv
              ]), newrecord[/* required */11] = senv[/* required */11], newrecord)
        ];
}

function add_module_parameter(mbid, mte, inl, senv) {
  check_empty_struct(senv);
  var mp = /* MPbound */Block.__(1, [mbid]);
  var mtb = Mod_typing$ReactTemplate.translate_modtype(senv[/* env */0], mp, inl, /* tuple */[
        /* [] */0,
        mte
      ]);
  var senv$1 = full_add_module_type(mp, mtb, senv);
  var match = senv$1[/* modvariant */2];
  var new_variant;
  if (typeof match === "number") {
    if (match) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "safe_typing.ml",
              631,
              11
            ]
          ];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "safe_typing.ml",
              631,
              11
            ]
          ];
    }
  } else {
    new_variant = match.tag ? /* STRUCT */Block.__(1, [
          /* :: */[
            /* tuple */[
              mbid,
              mtb
            ],
            match[0]
          ],
          match[1]
        ]) : /* SIG */Block.__(0, [
          /* :: */[
            /* tuple */[
              mbid,
              mtb
            ],
            match[0]
          ],
          match[1]
        ]);
  }
  var new_paramresolver = Modops$ReactTemplate.is_functor(mtb[/* mod_type */2]) ? senv$1[/* paramresolver */4] : Mod_subst$ReactTemplate.add_delta_resolver(mtb[/* mod_delta */5], senv$1[/* paramresolver */4]);
  var newrecord = senv$1.slice();
  return /* tuple */[
          mtb[/* mod_delta */5],
          (newrecord[/* modvariant */2] = new_variant, newrecord[/* paramresolver */4] = new_paramresolver, newrecord)
        ];
}

function functorize(params, init) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (e, param) {
                return /* MoreFunctor */Block.__(1, [
                          param[0],
                          param[1],
                          e
                        ]);
              }), init, params);
}

function propagate_loads(senv) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (env, param) {
                var mb = param[1];
                var senv = env;
                return add_constraints(/* Now */Block.__(0, [
                              /* false */0,
                              mb[/* mod_constraints */4]
                            ]), senv);
              }), senv, Curry._1(Util$ReactTemplate.List[/* rev */4], senv[/* loads */12]));
}

function functorize_module(params, mb) {
  var f = function (x) {
    return functorize(params, x);
  };
  return /* record */[
          /* mod_mp */mb[/* mod_mp */0],
          /* mod_expr */Modops$ReactTemplate.implem_smartmap(f, f, mb[/* mod_expr */1]),
          /* mod_type */functorize(params, mb[/* mod_type */2]),
          /* mod_type_alg */Option$ReactTemplate.map(f, mb[/* mod_type_alg */3]),
          /* mod_constraints */mb[/* mod_constraints */4],
          /* mod_delta */mb[/* mod_delta */5],
          /* mod_retroknowledge */mb[/* mod_retroknowledge */6]
        ];
}

function build_module_body(params, restype, senv) {
  var struc = /* NoFunctor */Block.__(0, [Curry._1(Util$ReactTemplate.List[/* rev */4], senv[/* revstruct */5])]);
  var restype$prime = Option$ReactTemplate.map((function (param) {
          return /* tuple */[
                  /* tuple */[
                    /* [] */0,
                    param[0]
                  ],
                  param[1]
                ];
        }), restype);
  var mb = Mod_typing$ReactTemplate.finalize_module(senv[/* env */0], senv[/* modpath */1], /* tuple */[
        struc,
        /* None */0,
        senv[/* modresolver */3],
        senv[/* univ */8]
      ], restype$prime);
  var mb$prime = functorize_module(params, mb);
  var newrecord = mb$prime.slice();
  newrecord[/* mod_retroknowledge */6] = /* ModBodyRK */[senv[/* local_retroknowledge */13]];
  return newrecord;
}

var allow_delayed_constants = [/* false */0];

function propagate_senv(newdef, newenv, newresolver, senv, oldsenv) {
  var match = Curry._2(Util$ReactTemplate.List[/* partition */29], Future$ReactTemplate.is_val, senv[/* future_cst */9]);
  var later_cst = match[1];
  if (!allow_delayed_constants[0] && later_cst !== /* [] */0) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["safe_typing"], Pp$ReactTemplate.str("True Future.t were created for opaque constants even if -async-proofs is off"));
  }
  return /* record */[
          /* env */newenv,
          /* modpath */oldsenv[/* modpath */1],
          /* modvariant */oldsenv[/* modvariant */2],
          /* modresolver */newresolver,
          /* paramresolver */oldsenv[/* paramresolver */4],
          /* revstruct : :: */[
            newdef,
            oldsenv[/* revstruct */5]
          ],
          /* modlabels */Curry._2(Names$ReactTemplate.Label[/* Set */8][/* add */3], newdef[0], oldsenv[/* modlabels */6]),
          /* objlabels */oldsenv[/* objlabels */7],
          /* univ */Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, cst) {
                  return Univ$ReactTemplate.ContextSet[/* union */6](acc, Future$ReactTemplate.force(cst));
                }), Univ$ReactTemplate.ContextSet[/* union */6](senv[/* univ */8], oldsenv[/* univ */8]), match[0]),
          /* future_cst */Util$ReactTemplate.$at(later_cst, oldsenv[/* future_cst */9]),
          /* engagement */senv[/* engagement */10],
          /* required */senv[/* required */11],
          /* loads */Util$ReactTemplate.$at(senv[/* loads */12], oldsenv[/* loads */12]),
          /* local_retroknowledge */Util$ReactTemplate.$at(senv[/* local_retroknowledge */13], oldsenv[/* local_retroknowledge */13])
        ];
}

function end_module(l, restype, senv) {
  var mp = senv[/* modpath */1];
  var match = check_struct(senv[/* modvariant */2]);
  var oldsenv = match[1];
  var params = match[0];
  check_current_label(l, mp);
  check_empty_context(senv);
  var mbids = Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (prim) {
          return prim[0];
        }), params);
  var mb = build_module_body(params, restype, senv);
  var newenv = Environ$ReactTemplate.set_opaque_tables(oldsenv[/* env */0], Environ$ReactTemplate.opaque_tables(senv[/* env */0]));
  var newenv$1 = set_engagement_opt(newenv, senv[/* engagement */10]);
  var newrecord = senv.slice();
  var senv$prime = propagate_loads((newrecord[/* env */0] = newenv$1, newrecord[/* univ */8] = Univ$ReactTemplate.ContextSet[/* union */6](senv[/* univ */8], mb[/* mod_constraints */4]), newrecord));
  var newenv$2 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], mb[/* mod_constraints */4], senv$prime[/* env */0]);
  var newenv$3 = Modops$ReactTemplate.add_module(mb, newenv$2);
  var newresolver = Modops$ReactTemplate.is_functor(mb[/* mod_type */2]) ? oldsenv[/* modresolver */3] : Mod_subst$ReactTemplate.add_delta_resolver(mb[/* mod_delta */5], oldsenv[/* modresolver */3]);
  return /* tuple */[
          /* tuple */[
            mp,
            mbids,
            mb[/* mod_delta */5]
          ],
          propagate_senv(/* tuple */[
                l,
                /* SFBmodule */Block.__(2, [mb])
              ], newenv$3, newresolver, senv$prime, oldsenv)
        ];
}

function build_mtb(mp, sign, cst, delta) {
  return /* record */[
          /* mod_mp */mp,
          /* mod_expr : () */0,
          /* mod_type */sign,
          /* mod_type_alg : None */0,
          /* mod_constraints */cst,
          /* mod_delta */delta,
          /* mod_retroknowledge : ModTypeRK */0
        ];
}

function end_modtype(l, senv) {
  var mp = senv[/* modpath */1];
  var match = check_sig(senv[/* modvariant */2]);
  var oldsenv = match[1];
  var params = match[0];
  check_current_label(l, mp);
  check_empty_context(senv);
  var mbids = Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (prim) {
          return prim[0];
        }), params);
  var newenv = Environ$ReactTemplate.set_opaque_tables(oldsenv[/* env */0], Environ$ReactTemplate.opaque_tables(senv[/* env */0]));
  var newenv$1 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], senv[/* univ */8], newenv);
  var newenv$2 = set_engagement_opt(newenv$1, senv[/* engagement */10]);
  var newrecord = senv.slice();
  var senv$prime = propagate_loads((newrecord[/* env */0] = newenv$2, newrecord));
  var auto_tb = functorize(params, /* NoFunctor */Block.__(0, [Curry._1(Util$ReactTemplate.List[/* rev */4], senv[/* revstruct */5])]));
  var mtb = build_mtb(mp, auto_tb, senv$prime[/* univ */8], senv[/* modresolver */3]);
  var newenv$3 = Environ$ReactTemplate.add_modtype(mtb, senv$prime[/* env */0]);
  var newresolver = oldsenv[/* modresolver */3];
  return /* tuple */[
          /* tuple */[
            mp,
            mbids
          ],
          propagate_senv(/* tuple */[
                l,
                /* SFBmodtype */Block.__(3, [mtb])
              ], newenv$3, newresolver, senv$prime, oldsenv)
        ];
}

function add_include(me, is_module, inl, senv) {
  var mp_sup = senv[/* modpath */1];
  var match = Mod_typing$ReactTemplate.translate_mse_incl(is_module, senv[/* env */0], mp_sup, inl, me);
  var senv$1 = add_constraints(/* Now */Block.__(0, [
          /* false */0,
          match[3]
        ]), senv);
  var compute_sign = function (_sign, mb, _resolver, _senv) {
    while(true) {
      var senv = _senv;
      var resolver = _resolver;
      var sign = _sign;
      if (sign.tag) {
        var mtb = sign[1];
        var mbid = sign[0];
        var cst_sub = Subtyping$ReactTemplate.check_subtypes(senv[/* env */0], mb, mtb);
        var senv$1 = add_constraints(/* Now */Block.__(0, [
                /* false */0,
                Univ$ReactTemplate.ContextSet[/* add_constraints */10](cst_sub, Univ$ReactTemplate.ContextSet[/* empty */0])
              ]), senv);
        var mpsup_delta = Modops$ReactTemplate.inline_delta_resolver(senv$1[/* env */0], inl, mp_sup, mbid, mtb, mb[/* mod_delta */5]);
        var subst = Mod_subst$ReactTemplate.map_mbid(mbid, mp_sup, mpsup_delta);
        var resolver$1 = Mod_subst$ReactTemplate.subst_codom_delta_resolver(subst, resolver);
        _senv = senv$1;
        _resolver = resolver$1;
        _sign = Modops$ReactTemplate.subst_signature(subst)(sign[2]);
        continue ;
        
      } else {
        return /* tuple */[
                resolver,
                sign[0],
                senv
              ];
      }
    };
  };
  var struc = /* NoFunctor */Block.__(0, [Curry._1(Util$ReactTemplate.List[/* rev */4], senv$1[/* revstruct */5])]);
  var mtb = build_mtb(mp_sup, struc, Univ$ReactTemplate.ContextSet[/* empty */0], senv$1[/* modresolver */3]);
  var match$1 = compute_sign(match[0], mtb, match[2], senv$1);
  var resolver = match$1[0];
  var senv$2 = update_resolver((function (param) {
          return Mod_subst$ReactTemplate.add_delta_resolver(resolver, param);
        }), match$1[2]);
  var add = function (senv, field) {
    var l = field[0];
    var new_name;
    switch (field[1].tag | 0) {
      case 0 : 
          new_name = /* C */Block.__(0, [Mod_subst$ReactTemplate.constant_of_delta_kn(resolver, Names$ReactTemplate.KerName[/* make2 */1](mp_sup, l))]);
          break;
      case 1 : 
          new_name = /* I */Block.__(1, [Mod_subst$ReactTemplate.mind_of_delta_kn(resolver, Names$ReactTemplate.KerName[/* make2 */1](mp_sup, l))]);
          break;
      case 2 : 
          new_name = /* M */0;
          break;
      case 3 : 
          new_name = /* MT */1;
          break;
      
    }
    return add_field(field, new_name, senv);
  };
  return /* tuple */[
          resolver,
          Curry._3(Util$ReactTemplate.List[/* fold_left */13], add, senv$2, match$1[1])
        ];
}

function j_val(j) {
  return j[/* uj_val */0];
}

function j_type(j) {
  return j[/* uj_type */1];
}

function typing(senv) {
  return Curry._1(Typeops$ReactTemplate.infer, senv[/* env */0]);
}

function retroknowledge(f, senv) {
  return Environ$ReactTemplate.retroknowledge(f, senv[/* env */0]);
}

function register(field, value, _, senv) {
  var newrecord = senv.slice();
  newrecord[/* env */0] = Environ$ReactTemplate.register(senv[/* env */0], field, value);
  newrecord[/* local_retroknowledge */13] = /* :: */[
    /* RKRegister */[
      field,
      value
    ],
    senv[/* local_retroknowledge */13]
  ];
  return newrecord;
}

function register_inline(kn, senv) {
  if (!Environ$ReactTemplate.evaluable_constant(kn, senv[/* env */0])) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Register inline: an evaluable constant is expected"));
  }
  var env = Environ$ReactTemplate.pre_env(senv[/* env */0]);
  var match = Curry._2(Names$ReactTemplate.Cmap_env[/* find */21], kn, env[/* env_globals */0][/* env_constants */0]);
  var newrecord = match[0].slice();
  newrecord[/* const_inline_code */6] = /* true */1;
  var new_constants = Curry._3(Names$ReactTemplate.Cmap_env[/* add */3], kn, /* tuple */[
        newrecord,
        match[1]
      ], env[/* env_globals */0][/* env_constants */0]);
  var init = env[/* env_globals */0];
  var new_globals_001 = /* env_inductives */init[/* env_inductives */1];
  var new_globals_002 = /* env_modules */init[/* env_modules */2];
  var new_globals_003 = /* env_modtypes */init[/* env_modtypes */3];
  var new_globals = /* record */[
    /* env_constants */new_constants,
    new_globals_001,
    new_globals_002,
    new_globals_003
  ];
  var newrecord$1 = env.slice();
  newrecord$1[/* env_globals */0] = new_globals;
  var newrecord$2 = senv.slice();
  newrecord$2[/* env */0] = Environ$ReactTemplate.env_of_pre_env(newrecord$1);
  return newrecord$2;
}

function add_constraints$1(c) {
  var partial_arg_001 = Univ$ReactTemplate.ContextSet[/* add_constraints */10](c, Univ$ReactTemplate.ContextSet[/* empty */0]);
  var partial_arg = /* Now */Block.__(0, [
      /* false */0,
      partial_arg_001
    ]);
  return (function (param) {
      return add_constraints(partial_arg, param);
    });
}

function set_strategy(e, k, l) {
  var newrecord = e.slice();
  newrecord[/* env */0] = Environ$ReactTemplate.set_oracle(e[/* env */0], Conv_oracle$ReactTemplate.set_strategy(Environ$ReactTemplate.oracle(e[/* env */0]), k, l));
  return newrecord;
}

var side_effects_of_private_constants = Term_typing$ReactTemplate.uniq_seff;

var empty_private_constants = Term_typing$ReactTemplate.empty_seff;

var add_private = Term_typing$ReactTemplate.add_seff;

var concat_private = Term_typing$ReactTemplate.concat_seff;

var mk_pure_proof = Term_typing$ReactTemplate.mk_pure_proof;

var inline_private_constants_in_constr = Term_typing$ReactTemplate.inline_side_effects;

var inline_private_constants_in_definition_entry = Term_typing$ReactTemplate.inline_entry_side_effects;

exports.digest_match = digest_match;
exports.empty_environment = empty_environment;
exports.is_initial = is_initial;
exports.env_of_safe_env = env_of_safe_env;
exports.side_effects_of_private_constants = side_effects_of_private_constants;
exports.empty_private_constants = empty_private_constants;
exports.add_private = add_private;
exports.concat_private = concat_private;
exports.private_con_of_con = private_con_of_con;
exports.private_con_of_scheme = private_con_of_scheme;
exports.mk_pure_proof = mk_pure_proof;
exports.inline_private_constants_in_constr = inline_private_constants_in_constr;
exports.inline_private_constants_in_definition_entry = inline_private_constants_in_definition_entry;
exports.universes_of_private = universes_of_private;
exports.is_curmod_library = is_curmod_library;
exports.join_safe_environment = join_safe_environment;
exports.is_joined_environment = is_joined_environment;
exports.push_named_assum = push_named_assum;
exports.push_named_def = push_named_def;
exports.export_private_constants = export_private_constants;
exports.add_constant = add_constant;
exports.add_mind = add_mind;
exports.add_module = add_module;
exports.add_modtype = add_modtype;
exports.push_context_set = push_context_set;
exports.push_context = push_context;
exports.add_constraints = add_constraints$1;
exports.set_engagement = set_engagement;
exports.set_typing_flags = set_typing_flags;
exports.start_module = start_module;
exports.start_modtype = start_modtype;
exports.add_module_parameter = add_module_parameter;
exports.allow_delayed_constants = allow_delayed_constants;
exports.end_module = end_module;
exports.end_modtype = end_modtype;
exports.add_include = add_include;
exports.j_val = j_val;
exports.j_type = j_type;
exports.typing = typing;
exports.exists_objlabel = exists_objlabel;
exports.delta_of_senv = delta_of_senv;
exports.retroknowledge = retroknowledge;
exports.register = register;
exports.register_inline = register_inline;
exports.set_strategy = set_strategy;
/* DPMap Not a pure module */
