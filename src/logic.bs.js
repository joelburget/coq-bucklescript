// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Goal$ReactTemplate = require("./goal.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Indrec$ReactTemplate = require("./indrec.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Tacred$ReactTemplate = require("./tacred.bs.js");
var Typing$ReactTemplate = require("./typing.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Miscprint$ReactTemplate = require("./miscprint.bs.js");
var Type_errors$ReactTemplate = require("./type_errors.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("./pretype_errors.bs.js");

var RefinerError = Caml_exceptions.create("Logic-ReactTemplate.RefinerError");

function is_unification_error(param) {
  switch (param.tag | 0) {
    case 0 : 
    case 12 : 
    case 13 : 
    case 14 : 
    case 15 : 
    case 16 : 
    case 17 : 
        return /* false */0;
    default:
      return /* true */1;
  }
}

function catchable_exception(param) {
  if (param[0] === CErrors$ReactTemplate.UserError) {
    return /* true */1;
  } else if (param[0] === Type_errors$ReactTemplate.TypeError) {
    return /* true */1;
  } else if (param[0] === RefinerError) {
    return /* true */1;
  } else if (param[0] === Indrec$ReactTemplate.RecursionSchemeError) {
    return /* true */1;
  } else if (param[0] === Nametab$ReactTemplate.GlobalizationError) {
    return /* true */1;
  } else if (param[0] === Tacred$ReactTemplate.ReductionTacticError) {
    return /* true */1;
  } else if (param[0] === Pretype_errors$ReactTemplate.PretypeError) {
    var e = param[3];
    if (is_unification_error(e)) {
      return /* true */1;
    } else {
      var param$1 = e;
      switch (param$1.tag | 0) {
        case 13 : 
        case 14 : 
        case 15 : 
        case 16 : 
            return /* true */1;
        default:
          return /* false */0;
      }
    }
  } else {
    return /* false */0;
  }
}

function error_no_such_hypothesis(env, sigma, id) {
  throw [
        RefinerError,
        env,
        sigma,
        /* NoSuchHyp */Block.__(7, [id])
      ];
}

var check = [/* false */0];

function with_check(param, param$1) {
  return Flags$ReactTemplate.with_option(check, param, param$1);
}

function apply_to_hyp(env, sigma, check, sign, id, f) {
  try {
    return Environ$ReactTemplate.apply_to_hyp(sign, id, f);
  }
  catch (exn){
    if (exn === Environ$ReactTemplate.Hyp_not_found) {
      if (check) {
        return error_no_such_hypothesis(env, sigma, id);
      } else {
        return sign;
      }
    } else {
      throw exn;
    }
  }
}

function check_typability(env, sigma, c) {
  if (check[0]) {
    Typing$ReactTemplate.unsafe_type_of(env, sigma, EConstr$ReactTemplate.of_constr(c));
    return /* () */0;
  } else {
    return 0;
  }
}

var mt_q_000 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];

var mt_q = /* tuple */[
  mt_q_000,
  /* [] */0
];

function push_val(y, q) {
  var match = q[1];
  if (match) {
    var match$1 = match[0];
    return /* tuple */[
            q[0],
            /* :: */[
              /* tuple */[
                match$1[0],
                Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], y, match$1[1])
              ],
              match[1]
            ]
          ];
  } else {
    return q;
  }
}

function push_item(x, v, param) {
  return /* tuple */[
          Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], x, v, param[0]),
          /* :: */[
            /* tuple */[
              x,
              Names$ReactTemplate.Id[/* Set */9][/* empty */0]
            ],
            param[1]
          ]
        ];
}

function mem_q(x, param) {
  return Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], x, param[0]);
}

function find_q(x, param) {
  var m = param[0];
  var v = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x, m);
  var m$prime = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* remove */5], x, m);
  var _accs = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var _acc = /* [] */0;
  var _param = param[1];
  while(true) {
    var param$1 = _param;
    var acc = _acc;
    var accs = _accs;
    if (param$1) {
      var itl = param$1[1];
      var i = param$1[0];
      var l = i[1];
      var x$prime = i[0];
      if (itl) {
        var match = itl[0];
        if (Names$ReactTemplate.Id[/* equal */0](x, x$prime)) {
          return /* tuple */[
                  /* tuple */[
                    v,
                    Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], accs, l)
                  ],
                  /* tuple */[
                    m$prime,
                    Util$ReactTemplate.$at(Curry._1(Util$ReactTemplate.List[/* rev */4], acc), /* :: */[
                          /* tuple */[
                            match[0],
                            Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], x, Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], l, match[1]))
                          ],
                          itl[1]
                        ])
                  ]
                ];
        } else {
          _param = itl;
          _acc = /* :: */[
            i,
            acc
          ];
          _accs = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], l, accs);
          continue ;
          
        }
      } else if (Names$ReactTemplate.Id[/* equal */0](x, x$prime)) {
        return /* tuple */[
                /* tuple */[
                  v,
                  Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], accs, l)
                ],
                /* tuple */[
                  m$prime,
                  Curry._1(Util$ReactTemplate.List[/* rev */4], acc)
                ]
              ];
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function occur_vars_in_decl(env, sigma, hyps, d) {
  if (Curry._1(Names$ReactTemplate.Id[/* Set */9][/* is_empty */1], hyps)) {
    return /* false */0;
  } else {
    var ohyps = Termops$ReactTemplate.global_vars_set_of_decl(env, sigma, d);
    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* exists */15], (function (h) {
                  return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], h, ohyps);
                }), hyps);
  }
}

function reorder_context(env, sigma, sign, ord) {
  var ords = Curry._3(Util$ReactTemplate.List[/* fold_right */14], Names$ReactTemplate.Id[/* Set */9][/* add */3], ord, Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
  if (Curry._1(Util$ReactTemplate.List[/* length */0], ord) !== Curry._1(Names$ReactTemplate.Id[/* Set */9][/* cardinal */18], ords)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Order list has duplicates"));
  }
  var _ord = ord;
  var _expected = ords;
  var _ctxt_head = sign;
  var _moved_hyps = mt_q;
  var _ctxt_tail = /* [] */0;
  while(true) {
    var ctxt_tail = _ctxt_tail;
    var moved_hyps = _moved_hyps;
    var ctxt_head = _ctxt_head;
    var expected = _expected;
    var ord$1 = _ord;
    if (ord$1) {
      var top = ord$1[0];
      if (mem_q(top, moved_hyps)) {
        var match = find_q(top, moved_hyps);
        var match$1 = match[0];
        var h = match$1[1];
        var d = match$1[0];
        if (occur_vars_in_decl(env, sigma, h, d)) {
          CErrors$ReactTemplate.user_err(/* None */0, /* Some */["reorder_context"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot move declaration "), Names$ReactTemplate.Id[/* print */8](top)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("before ")), Pp$ReactTemplate.pr_sequence(Names$ReactTemplate.Id[/* print */8], Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], Curry._2(Names$ReactTemplate.Id[/* Set */9][/* inter */7], h, Termops$ReactTemplate.global_vars_set_of_decl(env, sigma, d))))));
        }
        _ctxt_tail = /* :: */[
          d,
          ctxt_tail
        ];
        _moved_hyps = match[1];
        _ord = ord$1[1];
        continue ;
        
      } else if (ctxt_head) {
        var ctxt = ctxt_head[1];
        var d$1 = ctxt_head[0];
        var x = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d$1);
        if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], x, expected)) {
          _moved_hyps = push_item(x, d$1, moved_hyps);
          _ctxt_head = ctxt;
          _expected = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* remove */5], x, expected);
          continue ;
          
        } else {
          _ctxt_tail = /* :: */[
            d$1,
            ctxt_tail
          ];
          _moved_hyps = push_val(x, moved_hyps);
          _ctxt_head = ctxt;
          continue ;
          
        }
      } else {
        return error_no_such_hypothesis(env, sigma, Curry._1(Util$ReactTemplate.List[/* hd */1], ord$1));
      }
    } else {
      return Util$ReactTemplate.$at(Curry._1(Util$ReactTemplate.List[/* rev */4], ctxt_tail), ctxt_head);
    }
  };
}

function check_decl_position(env, sigma, sign, d) {
  var x = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
  var needed = Termops$ReactTemplate.global_vars_set_of_decl(env, sigma, d);
  var deps = Termops$ReactTemplate.dependency_closure(env, sigma, EConstr$ReactTemplate.named_context_of_val(sign), needed);
  if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], x, deps)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Logic.check_decl_position"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot create self-referring hypothesis "), Names$ReactTemplate.Id[/* print */8](x)));
  }
  return /* :: */[
          x,
          deps
        ];
}

function move_location_eq(m1, m2) {
  if (typeof m1 === "number") {
    if (m1) {
      if (typeof m2 === "number" && m2 !== 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else if (typeof m2 === "number" && m2 === 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (m1.tag) {
    if (typeof m2 === "number" || m2.tag !== 1) {
      return /* false */0;
    } else {
      return Names$ReactTemplate.Id[/* equal */0](m1[0], m2[0]);
    }
  } else if (typeof m2 === "number" || m2.tag) {
    return /* false */0;
  } else {
    return Names$ReactTemplate.Id[/* equal */0](m1[0], m2[0]);
  }
}

function split_sign(env, sigma, hfrom, hto, l) {
  var _left = /* [] */0;
  var _toleft = /* false */0;
  var _param = l;
  while(true) {
    var param = _param;
    var toleft = _toleft;
    var left = _left;
    if (param) {
      var right = param[1];
      var d = param[0];
      var hyp = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
      if (Names$ReactTemplate.Id[/* equal */0](hyp, hfrom)) {
        return /* tuple */[
                left,
                right,
                d,
                toleft || move_location_eq(hto, /* MoveLast */1)
              ];
      } else {
        var is_toleft = typeof hto === "number" ? /* false */0 : Names$ReactTemplate.Id[/* equal */0](hyp, hto[0]);
        _param = right;
        _toleft = toleft || is_toleft;
        _left = /* :: */[
          d,
          left
        ];
        continue ;
        
      }
    } else {
      return error_no_such_hypothesis(env, sigma, hfrom);
    }
  };
}

function hyp_of_move_location(param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "logic.ml",
            215,
            9
          ]
        ];
  } else {
    return param[0];
  }
}

function move_hyp(sigma, toleft, param, hto) {
  var right = param[2];
  var declfrom = param[1];
  var left = param[0];
  var env = Global$ReactTemplate.env(/* () */0);
  var moverec = function (_first, _middle, _right) {
    while(true) {
      var right = _right;
      var middle = _middle;
      var first = _first;
      if (right) {
        var right$1 = right[1];
        var d = right[0];
        if (move_location_eq(hto, /* MoveBefore */Block.__(1, [Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d)]))) {
          return Util$ReactTemplate.$at(Curry._1(Util$ReactTemplate.List[/* rev */4], first), Util$ReactTemplate.$at(Curry._1(Util$ReactTemplate.List[/* rev */4], middle), right));
        } else {
          var hyp = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
          var match = Curry._2(Util$ReactTemplate.List[/* exists */21], (function(d){
              return function (param) {
                var d$1 = d;
                var d2 = param;
                if (toleft) {
                  return Termops$ReactTemplate.occur_var_in_decl(env, sigma, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d2), d$1);
                } else {
                  return Termops$ReactTemplate.occur_var_in_decl(env, sigma, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d$1), d2);
                }
              }
              }(d)), middle) ? (
              move_location_eq(hto, /* MoveAfter */Block.__(0, [hyp])) ? CErrors$ReactTemplate.user_err(/* None */0, /* Some */["move_hyp"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot move "), Names$ReactTemplate.Id[/* print */8](Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], declfrom))), Miscprint$ReactTemplate.pr_move_location(Names$ReactTemplate.Id[/* print */8], hto)), Pp$ReactTemplate.str(toleft ? ": it occurs in the type of " : ": it depends on ")), Names$ReactTemplate.Id[/* print */8](hyp)), Pp$ReactTemplate.str("."))) : /* tuple */[
                  first,
                  /* :: */[
                    d,
                    middle
                  ]
                ]
            ) : /* tuple */[
              /* :: */[
                d,
                first
              ],
              middle
            ];
          var middle$prime = match[1];
          var first$prime = match[0];
          if (move_location_eq(hto, /* MoveAfter */Block.__(0, [hyp]))) {
            return Util$ReactTemplate.$at(Curry._1(Util$ReactTemplate.List[/* rev */4], first$prime), Util$ReactTemplate.$at(Curry._1(Util$ReactTemplate.List[/* rev */4], middle$prime), right$1));
          } else {
            _right = right$1;
            _middle = middle$prime;
            _first = first$prime;
            continue ;
            
          }
        }
      } else {
        if (typeof hto === "number" ? /* false */0 : /* true */1) {
          error_no_such_hypothesis(env, sigma, hyp_of_move_location(hto));
        }
        return Util$ReactTemplate.$at(Curry._1(Util$ReactTemplate.List[/* rev */4], first), Curry._1(Util$ReactTemplate.List[/* rev */4], middle));
      }
    };
  };
  if (toleft) {
    var right$1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], EConstr$ReactTemplate.push_named_context_val, right, Environ$ReactTemplate.empty_named_context_val);
    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (sign, d) {
                  return EConstr$ReactTemplate.push_named_context_val(d, sign);
                }), right$1, moverec(/* [] */0, /* :: */[
                    declfrom,
                    /* [] */0
                  ], left));
  } else {
    var right$2 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], EConstr$ReactTemplate.push_named_context_val, moverec(/* [] */0, /* :: */[
              declfrom,
              /* [] */0
            ], right), Environ$ReactTemplate.empty_named_context_val);
    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (sign, d) {
                  return EConstr$ReactTemplate.push_named_context_val(d, sign);
                }), right$2, left);
  }
}

function move_hyp_in_named_context(env, sigma, hfrom, hto, sign) {
  var match = split_sign(env, sigma, hfrom, hto, EConstr$ReactTemplate.named_context_of_val(sign));
  return move_hyp(sigma, match[3], /* tuple */[
              match[0],
              match[2],
              match[1]
            ], hto);
}

function insert_decl_in_named_context(sigma, decl, hto, sign) {
  return move_hyp(sigma, /* false */0, /* tuple */[
              /* [] */0,
              decl,
              EConstr$ReactTemplate.named_context_of_val(sign)
            ], hto);
}

function collect_meta_variables(c) {
  var collrec = function (deep, acc, _c) {
    while(true) {
      var c = _c;
      var match = Constr$ReactTemplate.kind(c);
      switch (match.tag | 0) {
        case 2 : 
            if (deep) {
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Application of lemmas whose beta-iota normal "), Pp$ReactTemplate.strbrk("form contains metavariables deep inside the term is not ")), Pp$ReactTemplate.strbrk("supported; try \"refine\" instead.")));
            } else {
              return /* :: */[
                      match[0],
                      acc
                    ];
            }
        case 5 : 
            _c = match[0];
            continue ;
            case 9 : 
            return Constr$ReactTemplate.fold((function (param, param$1) {
                          return collrec(deep, param, param$1);
                        }), acc, c);
        case 13 : 
            return Constr$ReactTemplate.fold((function (param, param$1) {
                          return collrec(deep, param, param$1);
                        }), acc, c);
        case 16 : 
            _c = match[1];
            continue ;
            default:
          return Constr$ReactTemplate.fold((function (param, param$1) {
                        return collrec(/* true */1, param, param$1);
                      }), acc, c);
      }
    };
  };
  return Curry._1(Util$ReactTemplate.List[/* rev */4], collrec(/* false */0, /* [] */0, c));
}

function check_meta_variables(env, sigma, c) {
  if (Curry._2(Util$ReactTemplate.List[/* distinct_f */59], Caml_primitive.caml_int_compare, collect_meta_variables(c))) {
    return 0;
  } else {
    throw [
          RefinerError,
          env,
          sigma,
          /* NonLinearProof */Block.__(4, [c])
        ];
  }
}

function check_conv_leq_goal(env, sigma, arg, ty, conclty) {
  if (check[0]) {
    var match = Reductionops$ReactTemplate.infer_conv(/* None */0, /* None */0, /* None */0, env, sigma, EConstr$ReactTemplate.of_constr(ty), EConstr$ReactTemplate.of_constr(conclty));
    if (match[1]) {
      return match[0];
    } else {
      throw [
            RefinerError,
            env,
            sigma,
            /* BadType */Block.__(0, [
                arg,
                ty,
                conclty
              ])
          ];
    }
  } else {
    return sigma;
  }
}

var Stop = Caml_exceptions.create("Logic-ReactTemplate.Stop");

function meta_free_prefix(sigma, a) {
  try {
    var a$1 = Util$ReactTemplate.$$Array[/* map */12](EConstr$ReactTemplate.of_constr, a);
    Util$ReactTemplate.$$Array[/* fold_left */15]((function (acc, a) {
            if (Termops$ReactTemplate.occur_meta(sigma, a)) {
              throw [
                    Stop,
                    acc
                  ];
            } else {
              return /* :: */[
                      a,
                      acc
                    ];
            }
          }), /* [] */0, a$1);
    return a$1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Stop) {
      return Util$ReactTemplate.$$Array[/* rev_of_list */62](exn[1]);
    } else {
      throw exn;
    }
  }
}

function goal_type_of(env, sigma, c) {
  if (check[0]) {
    var match = Typing$ReactTemplate.type_of(/* None */0, env, sigma, EConstr$ReactTemplate.of_constr(c));
    return /* tuple */[
            match[0],
            EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[1])
          ];
  } else {
    return /* tuple */[
            sigma,
            EConstr$ReactTemplate.Unsafe[/* to_constr */0](Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, EConstr$ReactTemplate.of_constr(c)))
          ];
  }
}

function mk_refgoals(sigma, goal, goalacc, conclty, trm) {
  var env = Goal$ReactTemplate.V82[/* env */0](sigma, goal);
  var hyps = Goal$ReactTemplate.V82[/* hyps */1](sigma, goal);
  var mk_goal = function (hyps, concl) {
    return Goal$ReactTemplate.V82[/* mk_goal */5](sigma, hyps, concl, Goal$ReactTemplate.V82[/* extra */4](sigma, goal));
  };
  if (!check[0] && !Termops$ReactTemplate.occur_meta(sigma, EConstr$ReactTemplate.of_constr(trm))) {
    var t$primety = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, EConstr$ReactTemplate.of_constr(trm));
    var t$primety$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](t$primety);
    var sigma$1 = check_conv_leq_goal(env, sigma, trm, t$primety$1, conclty);
    return /* tuple */[
            goalacc,
            t$primety$1,
            sigma$1,
            trm
          ];
  } else {
    var match = Constr$ReactTemplate.kind(trm);
    switch (match.tag | 0) {
      case 2 : 
          var conclty$1 = Reductionops$ReactTemplate.nf_betaiota(env, sigma, EConstr$ReactTemplate.of_constr(conclty));
          if (check[0] && Termops$ReactTemplate.occur_meta(sigma, conclty$1)) {
            throw [
                  RefinerError,
                  env,
                  sigma,
                  /* MetaInType */Block.__(5, [conclty$1])
                ];
          }
          var match$1 = mk_goal(hyps, conclty$1);
          var ev = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match$1[1]);
          var conclty$2 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](conclty$1);
          return /* tuple */[
                  /* :: */[
                    match$1[0],
                    goalacc
                  ],
                  conclty$2,
                  match$1[2],
                  ev
                ];
      case 5 : 
          var ty = match[2];
          var k = match[1];
          var t = match[0];
          check_typability(env, sigma, ty);
          var sigma$2 = check_conv_leq_goal(env, sigma, trm, ty, conclty);
          var res = mk_refgoals(sigma$2, goal, goalacc, ty, t);
          if (Constr$ReactTemplate.isMeta(t)) {
            if (!(k !== /* VMcast */0 && k !== /* NATIVEcast */1)) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "logic.ml",
                      354,
                      3
                    ]
                  ];
            }
            return res;
          } else {
            var ans = res[3];
            var ans$1 = ans === t ? trm : Constr$ReactTemplate.mkCast(/* tuple */[
                    ans,
                    k,
                    ty
                  ]);
            return /* tuple */[
                    res[0],
                    res[1],
                    res[2],
                    ans$1
                  ];
          }
          break;
      case 9 : 
          var l = match[1];
          var f = match[0];
          var match$2;
          if (Termops$ReactTemplate.is_template_polymorphic(env, sigma, EConstr$ReactTemplate.of_constr(f))) {
            var firstmeta = Util$ReactTemplate.$$Array[/* findi */31]((function (_, x) {
                    return Termops$ReactTemplate.occur_meta(sigma, EConstr$ReactTemplate.of_constr(x));
                  }), l);
            var match$3 = Option$ReactTemplate.cata((function (i) {
                    return CArray$ReactTemplate.chop(i, l);
                  }), /* tuple */[
                  l,
                  /* array */[]
                ], firstmeta);
            var ty$1 = Retyping$ReactTemplate.type_of_global_reference_knowing_parameters(env, sigma, EConstr$ReactTemplate.of_constr(f), Util$ReactTemplate.$$Array[/* map */12](EConstr$ReactTemplate.of_constr, match$3[0]));
            var ty$2 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](ty$1);
            match$2 = /* tuple */[
              goalacc,
              ty$2,
              sigma,
              f
            ];
          } else {
            match$2 = mk_hdgoals(sigma, goal, goalacc, f);
          }
          var applicand = match$2[3];
          var match$4 = mk_arggoals(match$2[2], goal, match$2[0], match$2[1], l);
          var args = match$4[1];
          var match$5 = match$4[0];
          var conclty$prime = match$5[1];
          var sigma$3 = check_conv_leq_goal(env, match$5[2], trm, conclty$prime, conclty);
          var ans$2 = applicand === f && args === l ? trm : Constr$ReactTemplate.mkApp(/* tuple */[
                  applicand,
                  args
                ]);
          return /* tuple */[
                  match$5[0],
                  conclty$prime,
                  sigma$3,
                  ans$2
                ];
      case 13 : 
          var lf = match[3];
          var c = match[2];
          var p = match[1];
          var match$6 = mk_casegoals(sigma, goal, goalacc, p, c);
          var c$prime = match$6[5];
          var p$prime = match$6[4];
          var conclty$prime$1 = match$6[2];
          var sigma$4 = check_conv_leq_goal(env, match$6[3], trm, conclty$prime$1, conclty);
          var match$7 = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (param, ty, fi) {
                  var match = mk_refgoals(param[1], goal, param[0], ty, fi);
                  return /* tuple */[
                          match[0],
                          match[2],
                          /* :: */[
                            match[3],
                            param[2]
                          ]
                        ];
                }), /* tuple */[
                match$6[0],
                sigma$4,
                /* [] */0
              ], match$6[1], lf);
          var lf$prime = Util$ReactTemplate.$$Array[/* rev_of_list */62](match$7[2]);
          var ans$3 = p$prime === p && c$prime === c && Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), lf$prime, lf) ? trm : Constr$ReactTemplate.mkCase(/* tuple */[
                  match[0],
                  p$prime,
                  c$prime,
                  lf$prime
                ]);
          return /* tuple */[
                  match$7[0],
                  conclty$prime$1,
                  match$7[1],
                  ans$3
                ];
      case 16 : 
          var match$8 = mk_hdgoals(sigma, goal, goalacc, match[1]);
          var sigma$5 = match$8[2];
          var c$1 = Constr$ReactTemplate.mkProj(/* tuple */[
                match[0],
                match$8[3]
              ]);
          var ty$3 = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma$5, EConstr$ReactTemplate.of_constr(c$1));
          var ty$4 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](ty$3);
          return /* tuple */[
                  match$8[0],
                  ty$4,
                  sigma$5,
                  c$1
                ];
      default:
        if (Termops$ReactTemplate.occur_meta(sigma, EConstr$ReactTemplate.of_constr(trm))) {
          CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("refiner called with a meta in non app/case subterm."));
        }
        var match$9 = goal_type_of(env, sigma, trm);
        var t$primety$2 = match$9[1];
        var sigma$6 = check_conv_leq_goal(env, match$9[0], trm, t$primety$2, conclty);
        return /* tuple */[
                goalacc,
                t$primety$2,
                sigma$6,
                trm
              ];
    }
  }
}

function mk_hdgoals(sigma, goal, goalacc, trm) {
  var env = Goal$ReactTemplate.V82[/* env */0](sigma, goal);
  var hyps = Goal$ReactTemplate.V82[/* hyps */1](sigma, goal);
  var mk_goal = function (hyps, concl) {
    return Goal$ReactTemplate.V82[/* mk_goal */5](sigma, hyps, concl, Goal$ReactTemplate.V82[/* extra */4](sigma, goal));
  };
  var match = Constr$ReactTemplate.kind(trm);
  switch (match.tag | 0) {
    case 5 : 
        var ty = match[2];
        var c = match[0];
        if (Constr$ReactTemplate.isMeta(c)) {
          check_typability(env, sigma, ty);
          var match$1 = mk_goal(hyps, Reductionops$ReactTemplate.nf_betaiota(env, sigma, EConstr$ReactTemplate.of_constr(ty)));
          var ev = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match$1[1]);
          return /* tuple */[
                  /* :: */[
                    match$1[0],
                    goalacc
                  ],
                  ty,
                  match$1[2],
                  ev
                ];
        } else {
          check_typability(env, sigma, ty);
          return mk_refgoals(sigma, goal, goalacc, ty, c);
        }
        break;
    case 9 : 
        var l = match[1];
        var f = match[0];
        var match$2;
        if (Termops$ReactTemplate.is_template_polymorphic(env, sigma, EConstr$ReactTemplate.of_constr(f))) {
          var l$prime = meta_free_prefix(sigma, l);
          match$2 = /* tuple */[
            goalacc,
            EConstr$ReactTemplate.Unsafe[/* to_constr */0](Retyping$ReactTemplate.type_of_global_reference_knowing_parameters(env, sigma, EConstr$ReactTemplate.of_constr(f), l$prime)),
            sigma,
            f
          ];
        } else {
          match$2 = mk_hdgoals(sigma, goal, goalacc, f);
        }
        var applicand = match$2[3];
        var match$3 = mk_arggoals(match$2[2], goal, match$2[0], match$2[1], l);
        var args = match$3[1];
        var match$4 = match$3[0];
        var ans = applicand === f && args === l ? trm : Constr$ReactTemplate.mkApp(/* tuple */[
                applicand,
                args
              ]);
        return /* tuple */[
                match$4[0],
                match$4[1],
                match$4[2],
                ans
              ];
    case 13 : 
        var lf = match[3];
        var c$1 = match[2];
        var p = match[1];
        var match$5 = mk_casegoals(sigma, goal, goalacc, p, c$1);
        var c$prime = match$5[5];
        var p$prime = match$5[4];
        var match$6 = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (param, ty, fi) {
                var match = mk_refgoals(param[1], goal, param[0], ty, fi);
                return /* tuple */[
                        match[0],
                        match[2],
                        /* :: */[
                          match[3],
                          param[2]
                        ]
                      ];
              }), /* tuple */[
              match$5[0],
              match$5[3],
              /* [] */0
            ], match$5[1], lf);
        var lf$prime = Util$ReactTemplate.$$Array[/* rev_of_list */62](match$6[2]);
        var ans$1 = p$prime === p && c$prime === c$1 && Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
                return +(prim === prim$1);
              }), lf$prime, lf) ? trm : Constr$ReactTemplate.mkCase(/* tuple */[
                match[0],
                p$prime,
                c$prime,
                lf$prime
              ]);
        return /* tuple */[
                match$6[0],
                match$5[2],
                match$6[1],
                ans$1
              ];
    case 16 : 
        var match$7 = mk_hdgoals(sigma, goal, goalacc, match[1]);
        var sigma$1 = match$7[2];
        var c$2 = Constr$ReactTemplate.mkProj(/* tuple */[
              match[0],
              match$7[3]
            ]);
        var ty$1 = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma$1, EConstr$ReactTemplate.of_constr(c$2));
        var ty$2 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](ty$1);
        return /* tuple */[
                match$7[0],
                ty$2,
                sigma$1,
                c$2
              ];
    default:
      if (check[0] && Termops$ReactTemplate.occur_meta(sigma, EConstr$ReactTemplate.of_constr(trm))) {
        CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("refine called with a dependent meta."));
      }
      var match$8 = goal_type_of(env, sigma, trm);
      return /* tuple */[
              goalacc,
              match$8[1],
              match$8[0],
              trm
            ];
  }
}

function mk_arggoals(sigma, goal, goalacc, funty, allargs) {
  var foldmap = function (param, harg) {
    var sigma = param[2];
    var t = Reductionops$ReactTemplate.whd_all(Goal$ReactTemplate.V82[/* env */0](sigma, goal))(sigma, EConstr$ReactTemplate.of_constr(param[1]));
    var t$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](t);
    var collapse = function (_t) {
      while(true) {
        var t = _t;
        var match = Constr$ReactTemplate.kind(t);
        if (match.tag === 8) {
          _t = Vars$ReactTemplate.subst1(match[1], match[3]);
          continue ;
          
        } else {
          return t;
        }
      };
    };
    var t$2 = collapse(t$1);
    var match = Constr$ReactTemplate.kind(t$2);
    if (match.tag === 6) {
      var match$1 = mk_refgoals(sigma, goal, param[0], match[1], harg);
      return /* tuple */[
              /* tuple */[
                match$1[0],
                Vars$ReactTemplate.subst1(harg, match[2]),
                match$1[2]
              ],
              match$1[3]
            ];
    } else {
      var env = Goal$ReactTemplate.V82[/* env */0](sigma, goal);
      throw [
            RefinerError,
            env,
            sigma,
            /* CannotApply */Block.__(2, [
                t$2,
                harg
              ])
          ];
    }
  };
  return Util$ReactTemplate.$$Array[/* smartfoldmap */48](foldmap, /* tuple */[
              goalacc,
              funty,
              sigma
            ], allargs);
}

function mk_casegoals(sigma, goal, goalacc, p, c) {
  var env = Goal$ReactTemplate.V82[/* env */0](sigma, goal);
  var match = mk_hdgoals(sigma, goal, goalacc, c);
  var ct = EConstr$ReactTemplate.of_constr(match[1]);
  var match$1 = mk_hdgoals(match[2], goal, match[0], p);
  var sigma$1 = match$1[2];
  var match$2;
  try {
    match$2 = Tacred$ReactTemplate.find_hnf_rectype(env, sigma$1, ct);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      match$2 = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("mk_casegoals."));
    } else {
      throw exn;
    }
  }
  var match$3 = match$2[0];
  var indspec_000 = /* tuple */[
    match$3[0],
    EConstr$ReactTemplate.EInstance[/* kind */1](sigma$1, match$3[1])
  ];
  var indspec_001 = match$2[1];
  var indspec = /* tuple */[
    indspec_000,
    indspec_001
  ];
  var match$4 = Inductiveops$ReactTemplate.type_case_branches_with_names(env, sigma$1, indspec, p, c);
  return /* tuple */[
          match$1[0],
          match$4[0],
          match$4[1],
          sigma$1,
          match$1[3],
          match[3]
        ];
}

function convert_hyp(check, sign, sigma, d) {
  var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
  var b = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], d);
  var env = Global$ReactTemplate.env(/* () */0);
  var reorder = [/* [] */0];
  var sign$prime = apply_to_hyp(env, sigma, check, sign, id, (function (_, d$prime, _$1) {
          var c = Option$ReactTemplate.map(EConstr$ReactTemplate.of_constr, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], d$prime));
          var env = Global$ReactTemplate.env_of_context(sign);
          if (check && !Reductionops$ReactTemplate.is_conv(/* None */0, env, sigma)(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], d), EConstr$ReactTemplate.of_constr(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], d$prime)))) {
            CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Logic.convert_hyp"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incorrect change of the type of "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(".")));
          }
          if (check && !Option$ReactTemplate.equal(Reductionops$ReactTemplate.is_conv(/* None */0, env, sigma), b, c)) {
            CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Logic.convert_hyp"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incorrect change of the body of "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(".")));
          }
          if (check) {
            reorder[0] = check_decl_position(env, sigma, sign, d);
          }
          return Termops$ReactTemplate.map_named_decl(EConstr$ReactTemplate.Unsafe[/* to_constr */0], d);
        }));
  var env$1 = env;
  var sigma$1 = sigma;
  var sign$1 = sign$prime;
  var ord = reorder[0];
  return EConstr$ReactTemplate.val_of_named_context(reorder_context(env$1, sigma$1, EConstr$ReactTemplate.named_context_of_val(sign$1), ord));
}

function prim_refiner(r, sigma, goal) {
  var env = Goal$ReactTemplate.V82[/* env */0](sigma, goal);
  var cl = Goal$ReactTemplate.V82[/* concl */3](sigma, goal);
  var c = r[0];
  var cl$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](cl);
  check_meta_variables(env, sigma, c);
  var match = mk_refgoals(sigma, goal, /* [] */0, cl$1, c);
  var sgl = Curry._1(Util$ReactTemplate.List[/* rev */4], match[0]);
  var sigma$1 = Goal$ReactTemplate.V82[/* partial_solution */6](match[2], goal, EConstr$ReactTemplate.of_constr(match[3]));
  return /* tuple */[
          sgl,
          sigma$1
        ];
}

exports.with_check = with_check;
exports.prim_refiner = prim_refiner;
exports.RefinerError = RefinerError;
exports.error_no_such_hypothesis = error_no_such_hypothesis;
exports.catchable_exception = catchable_exception;
exports.convert_hyp = convert_hyp;
exports.move_hyp_in_named_context = move_hyp_in_named_context;
exports.insert_decl_in_named_context = insert_decl_in_named_context;
/* Pp-ReactTemplate Not a pure module */
