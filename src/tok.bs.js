// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function equal(t1, t2) {
  if (typeof t1 === "number") {
    if (t1) {
      if (typeof t2 === "number" && t2 !== 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else if (typeof t2 === "number" && t2 === 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else {
    switch (t1.tag | 0) {
      case 0 : 
          if (typeof t2 === "number" || t2.tag) {
            return /* false */0;
          } else {
            return +(t1[0] === t2[0]);
          }
          break;
      case 1 : 
          if (typeof t2 === "number" || t2.tag !== 1) {
            return /* false */0;
          } else {
            return +(t1[0] === t2[0]);
          }
          break;
      case 2 : 
          if (typeof t2 === "number") {
            return /* false */0;
          } else {
            switch (t2.tag | 0) {
              case 0 : 
              case 2 : 
                  return +(t1[0] === t2[0]);
              default:
                return /* false */0;
            }
          }
          break;
      case 3 : 
          if (typeof t2 === "number" || t2.tag !== 3) {
            return /* false */0;
          } else {
            return +(t1[0] === t2[0]);
          }
          break;
      case 4 : 
          if (typeof t2 === "number" || t2.tag !== 4) {
            return /* false */0;
          } else {
            return +(t1[0] === t2[0]);
          }
          break;
      case 5 : 
          if (typeof t2 === "number" || t2.tag !== 5) {
            return /* false */0;
          } else {
            return +(t1[0] === t2[0]);
          }
          break;
      case 6 : 
          if (typeof t2 === "number" || t2.tag !== 6) {
            return /* false */0;
          } else {
            return +(t1[0] === t2[0]);
          }
          break;
      
    }
  }
}

function extract_string(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return "";
    } else {
      return "?";
    }
  } else {
    return param[0];
  }
}

function to_string(param) {
  if (typeof param === "number") {
    if (param) {
      return "EOI";
    } else {
      return "LEFTQMARK";
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Curry._1(Format.sprintf(/* Format */[
                          /* Caml_string */Block.__(3, [
                              /* No_padding */0,
                              /* End_of_format */0
                            ]),
                          "%S"
                        ]), param[0]);
      case 1 : 
          return Curry._1(Format.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "PATTERNIDENT ",
                              /* Caml_string */Block.__(3, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "PATTERNIDENT %S"
                        ]), param[0]);
      case 2 : 
          return Curry._1(Format.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "IDENT ",
                              /* Caml_string */Block.__(3, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "IDENT %S"
                        ]), param[0]);
      case 3 : 
          return Curry._1(Format.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "FIELD ",
                              /* Caml_string */Block.__(3, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "FIELD %S"
                        ]), param[0]);
      case 4 : 
          return Curry._1(Format.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "INT ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "INT %s"
                        ]), param[0]);
      case 5 : 
          return Curry._1(Format.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "STRING ",
                              /* Caml_string */Block.__(3, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "STRING %S"
                        ]), param[0]);
      case 6 : 
          return Curry._1(Format.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "BULLET ",
                              /* Caml_string */Block.__(3, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "BULLET %S"
                        ]), param[0]);
      
    }
  }
}

function match_keyword(kwd, param) {
  if (typeof param === "number" || !(!param.tag && kwd === param[0])) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function print(ppf, tok) {
  return Format.pp_print_string(ppf, to_string(tok));
}

function of_pattern(param) {
  switch (param[0]) {
    case "" : 
        return /* KEYWORD */Block.__(0, [param[1]]);
    case "BULLET" : 
        return /* BULLET */Block.__(6, [param[1]]);
    case "EOI" : 
        return /* EOI */1;
    case "FIELD" : 
        return /* FIELD */Block.__(3, [param[1]]);
    case "IDENT" : 
        return /* IDENT */Block.__(2, [param[1]]);
    case "INT" : 
        return /* INT */Block.__(4, [param[1]]);
    case "LEFTQMARK" : 
        return /* LEFTQMARK */0;
    case "PATTERNIDENT" : 
        return /* PATTERNIDENT */Block.__(1, [param[1]]);
    case "STRING" : 
        return /* STRING */Block.__(5, [param[1]]);
    default:
      return Pervasives.failwith("Tok.of_pattern: not a constructor");
  }
}

function to_pattern(param) {
  if (typeof param === "number") {
    if (param) {
      return /* tuple */[
              "EOI",
              ""
            ];
    } else {
      return /* tuple */[
              "LEFTQMARK",
              ""
            ];
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return /* tuple */[
                  "",
                  param[0]
                ];
      case 1 : 
          return /* tuple */[
                  "PATTERNIDENT",
                  param[0]
                ];
      case 2 : 
          return /* tuple */[
                  "IDENT",
                  param[0]
                ];
      case 3 : 
          return /* tuple */[
                  "FIELD",
                  param[0]
                ];
      case 4 : 
          return /* tuple */[
                  "INT",
                  param[0]
                ];
      case 5 : 
          return /* tuple */[
                  "STRING",
                  param[0]
                ];
      case 6 : 
          return /* tuple */[
                  "BULLET",
                  param[0]
                ];
      
    }
  }
}

function match_pattern(pat) {
  var exit = 0;
  switch (pat[0]) {
    case "" : 
        if (pat[1] === "") {
          return (function (param) {
              if (typeof param === "number") {
                throw Stream.Failure;
              } else if (param.tag) {
                throw Stream.Failure;
              } else {
                return param[0];
              }
            });
        } else {
          exit = 1;
        }
        break;
    case "BULLET" : 
        if (pat[1] === "") {
          return (function (param) {
              if (typeof param === "number") {
                throw Stream.Failure;
              } else if (param.tag === 6) {
                return param[0];
              } else {
                throw Stream.Failure;
              }
            });
        } else {
          exit = 1;
        }
        break;
    case "EOI" : 
        if (pat[1] === "") {
          return (function (param) {
              if (typeof param === "number") {
                if (param !== 0) {
                  return "";
                } else {
                  throw Stream.Failure;
                }
              } else {
                throw Stream.Failure;
              }
            });
        } else {
          exit = 1;
        }
        break;
    case "FIELD" : 
        if (pat[1] === "") {
          return (function (param) {
              if (typeof param === "number") {
                throw Stream.Failure;
              } else if (param.tag === 3) {
                return param[0];
              } else {
                throw Stream.Failure;
              }
            });
        } else {
          exit = 1;
        }
        break;
    case "IDENT" : 
        if (pat[1] === "") {
          return (function (param) {
              if (typeof param === "number") {
                throw Stream.Failure;
              } else if (param.tag === 2) {
                return param[0];
              } else {
                throw Stream.Failure;
              }
            });
        } else {
          exit = 1;
        }
        break;
    case "INT" : 
        if (pat[1] === "") {
          return (function (param) {
              if (typeof param === "number") {
                throw Stream.Failure;
              } else if (param.tag === 4) {
                return param[0];
              } else {
                throw Stream.Failure;
              }
            });
        } else {
          exit = 1;
        }
        break;
    case "LEFTQMARK" : 
        if (pat[1] === "") {
          return (function (param) {
              if (typeof param === "number") {
                if (param !== 0) {
                  throw Stream.Failure;
                } else {
                  return "";
                }
              } else {
                throw Stream.Failure;
              }
            });
        } else {
          exit = 1;
        }
        break;
    case "PATTERNIDENT" : 
        if (pat[1] === "") {
          return (function (param) {
              if (typeof param === "number") {
                throw Stream.Failure;
              } else if (param.tag === 1) {
                return param[0];
              } else {
                throw Stream.Failure;
              }
            });
        } else {
          exit = 1;
        }
        break;
    case "STRING" : 
        if (pat[1] === "") {
          return (function (param) {
              if (typeof param === "number") {
                throw Stream.Failure;
              } else if (param.tag === 5) {
                return param[0];
              } else {
                throw Stream.Failure;
              }
            });
        } else {
          exit = 1;
        }
        break;
    default:
      exit = 1;
  }
  if (exit === 1) {
    var tok = of_pattern(pat);
    return (function (tok$prime) {
        if (equal(tok, tok$prime)) {
          return pat[1];
        } else {
          throw Stream.Failure;
        }
      });
  }
  
}

exports.equal = equal;
exports.extract_string = extract_string;
exports.to_string = to_string;
exports.print = print;
exports.match_keyword = match_keyword;
exports.of_pattern = of_pattern;
exports.to_pattern = to_pattern;
exports.match_pattern = match_pattern;
/* Format Not a pure module */
