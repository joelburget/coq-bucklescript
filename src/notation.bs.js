// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Bigint$ReactTemplate = require("./bigint.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Unicode$ReactTemplate = require("./unicode.bs.js");
var Classops$ReactTemplate = require("./classops.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Notation_ops$ReactTemplate = require("./notation_ops.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");

var notation_level_map = [Util$ReactTemplate.$$String[/* Map */39][/* empty */0]];

var scope_map = [Util$ReactTemplate.$$String[/* Map */39][/* empty */0]];

var delimiters_map = [Util$ReactTemplate.$$String[/* Map */39][/* empty */0]];

var empty_scope_000 = /* notations */Util$ReactTemplate.$$String[/* Map */39][/* empty */0];

var empty_scope = /* record */[
  empty_scope_000,
  /* delimiters : None */0
];

var default_scope = "";

function init_scope_map() {
  scope_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], default_scope, empty_scope, scope_map[0]);
  return /* () */0;
}

function level_eq(param, param$1) {
  var param$2 = param;
  var param$3 = param$1;
  var tolerability_eq = function (param, param$1) {
    if (param[0] === param$1[0]) {
      var t1 = param[1];
      var t2 = param$1[1];
      if (typeof t1 === "number") {
        switch (t1) {
          case 0 : 
              if (typeof t2 === "number" && t2 === 0) {
                return /* true */1;
              } else {
                return /* false */0;
              }
          case 1 : 
              if (typeof t2 === "number" && t2 === 1) {
                return /* true */1;
              } else {
                return /* false */0;
              }
          case 2 : 
              if (typeof t2 === "number" && t2 >= 2) {
                return /* true */1;
              } else {
                return /* false */0;
              }
          
        }
      } else if (typeof t2 === "number") {
        return /* false */0;
      } else {
        return +(t1[0] === t2[0]);
      }
    } else {
      return /* false */0;
    }
  };
  var prod_eq = function (_, _$1) {
    return /* true */1;
  };
  if (param$2[0] === param$3[0] && Curry._3(Util$ReactTemplate.List[/* equal */44], tolerability_eq, param$2[1], param$3[1])) {
    return Curry._3(Util$ReactTemplate.List[/* equal */44], (function (param, param$1) {
                  var eq = prod_eq;
                  var v1 = param;
                  var v2 = param$1;
                  if (typeof v1 === "number") {
                    switch (v1) {
                      case 0 : 
                          if (typeof v2 === "number" && v2 === 0) {
                            return /* true */1;
                          } else {
                            return /* false */0;
                          }
                      case 1 : 
                          if (typeof v2 === "number" && v2 === 1) {
                            return /* true */1;
                          } else {
                            return /* false */0;
                          }
                      case 2 : 
                          if (typeof v2 === "number" && v2 >= 2) {
                            return /* true */1;
                          } else {
                            return /* false */0;
                          }
                      
                    }
                  } else {
                    switch (v1.tag | 0) {
                      case 0 : 
                          if (typeof v2 === "number" || v2.tag) {
                            return /* false */0;
                          } else {
                            return +(v1[0] === v2[0]);
                          }
                          break;
                      case 1 : 
                          if (typeof v2 === "number" || v2.tag !== 1) {
                            return /* false */0;
                          } else {
                            return Curry._2(eq, v1[0], v2[0]);
                          }
                          break;
                      case 2 : 
                          if (typeof v2 === "number" || !(v2.tag === 2 && Curry._2(eq, v1[1], v2[1]))) {
                            return /* false */0;
                          } else {
                            return +(v1[0] === v2[0]);
                          }
                          break;
                      case 3 : 
                          if (typeof v2 === "number" || !(v2.tag === 3 && v1[0] === v2[0])) {
                            return /* false */0;
                          } else {
                            return Option$ReactTemplate.equal((function (prim, prim$1) {
                                          return +(prim === prim$1);
                                        }), v1[1], v2[1]);
                          }
                          break;
                      case 4 : 
                          if (typeof v2 === "number" || !(v2.tag === 4 && v1[0] === v2[0])) {
                            return /* false */0;
                          } else {
                            return +(v1[1] === v2[1]);
                          }
                          break;
                      
                    }
                  }
                }), param$2[2], param$3[2]);
  } else {
    return /* false */0;
  }
}

function declare_scope(scope) {
  try {
    Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], scope, scope_map[0]);
    return /* () */0;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      scope_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], scope, empty_scope, scope_map[0]);
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function error_unknown_scope(sc) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Notation"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Scope "), Pp$ReactTemplate.str(sc)), Pp$ReactTemplate.str(" is not declared.")));
}

function find_scope(scope) {
  try {
    return Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], scope, scope_map[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return error_unknown_scope(scope);
    } else {
      throw exn;
    }
  }
}

function check_scope(sc) {
  find_scope(sc);
  return /* () */0;
}

function normalize_scope(sc) {
  try {
    Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], sc, scope_map[0]);
    return sc;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      try {
        var sc$1 = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], sc, delimiters_map[0]);
        Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], sc$1, scope_map[0]);
        return sc$1;
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          return error_unknown_scope(sc);
        } else {
          throw exn$1;
        }
      }
    } else {
      throw exn;
    }
  }
}

function scope_eq(s1, s2) {
  if (s1.tag) {
    if (s2.tag) {
      return +(s1[0] === s2[0]);
    } else {
      return /* false */0;
    }
  } else if (s2.tag) {
    return /* false */0;
  } else {
    return +(s1[0] === s2[0]);
  }
}

var scope_stack = [/* [] */0];

function current_scopes() {
  return scope_stack[0];
}

function scope_is_open_in_scopes(sc, l) {
  return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                if (param.tag) {
                  return /* false */0;
                } else {
                  return +(sc === param[0]);
                }
              }), l);
}

function scope_is_open(sc) {
  return scope_is_open_in_scopes(sc, scope_stack[0]);
}

function open_scope(i, param) {
  if (i === 1) {
    var match = param[1];
    var sc = match[2];
    scope_stack[0] = match[1] ? /* :: */[
        sc,
        scope_stack[0]
      ] : Curry._3(Util$ReactTemplate.List[/* except */87], scope_eq, sc, scope_stack[0]);
    return /* () */0;
  } else {
    return 0;
  }
}

function cache_scope(o) {
  return open_scope(1, o);
}

function subst_scope(param) {
  return param[1];
}

function discharge_scope(param) {
  var o = param[1];
  if (o[0]) {
    return /* None */0;
  } else {
    return /* Some */[o];
  }
}

function classify_scope(o) {
  if (o[0]) {
    return /* Dispose */0;
  } else {
    return /* Substitute */Block.__(0, [o]);
  }
}

var init = Libobject$ReactTemplate.default_object("SCOPE");

var inScope = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_scope,
      /* load_function */init[/* load_function */2],
      /* open_function */open_scope,
      /* classify_function */classify_scope,
      /* subst_function */subst_scope,
      /* discharge_function */discharge_scope,
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

function open_close_scope(param) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inScope, /* tuple */[
                  param[0],
                  param[1],
                  /* Scope */Block.__(0, [normalize_scope(param[2])])
                ]));
}

function push_scope(sc, scopes) {
  return /* :: */[
          /* Scope */Block.__(0, [sc]),
          scopes
        ];
}

var push_scopes = Curry._1(Util$ReactTemplate.List[/* fold_right */14], push_scope);

function make_current_scopes(param) {
  return Option$ReactTemplate.fold_right(push_scope, param[0], Curry._2(push_scopes, param[1], scope_stack[0]));
}

function declare_delimiters(scope, key) {
  var sc = find_scope(scope);
  var newsc_000 = /* notations */sc[/* notations */0];
  var newsc_001 = /* delimiters : Some */[key];
  var newsc = /* record */[
    newsc_000,
    newsc_001
  ];
  var match = sc[/* delimiters */1];
  if (match) {
    var oldkey = match[0];
    if (oldkey !== key) {
      Flags$ReactTemplate.if_verbose((function (eta) {
              return Feedback$ReactTemplate.msg_info(/* None */0, eta);
            }), Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Overwriting previous delimiting key "), Pp$ReactTemplate.str(oldkey)), Pp$ReactTemplate.str(" in scope ")), Pp$ReactTemplate.str(scope)));
      scope_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], scope, newsc, scope_map[0]);
    }
    
  } else {
    scope_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], scope, newsc, scope_map[0]);
  }
  try {
    var oldscope = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], key, delimiters_map[0]);
    if (oldscope === scope) {
      return /* () */0;
    } else {
      Flags$ReactTemplate.if_verbose((function (eta) {
              return Feedback$ReactTemplate.msg_info(/* None */0, eta);
            }), Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Hiding binding of key "), Pp$ReactTemplate.str(key)), Pp$ReactTemplate.str(" to ")), Pp$ReactTemplate.str(oldscope)));
      delimiters_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], key, scope, delimiters_map[0]);
      return /* () */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      delimiters_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], key, scope, delimiters_map[0]);
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function remove_delimiters(scope) {
  var sc = find_scope(scope);
  var newsc_000 = /* notations */sc[/* notations */0];
  var newsc = /* record */[
    newsc_000,
    /* delimiters : None */0
  ];
  var match = sc[/* delimiters */1];
  if (match) {
    var key = match[0];
    scope_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], scope, newsc, scope_map[0]);
    try {
      Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], key, delimiters_map[0]);
      delimiters_map[0] = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* remove */5], key, delimiters_map[0]);
      return /* () */0;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "notation.ml",
                244,
                9
              ]
            ];
      } else {
        throw exn;
      }
    }
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No bound key for scope "), Pp$ReactTemplate.str(scope)), Pp$ReactTemplate.str(".")));
  }
}

function find_delimiters_scope(loc, key) {
  try {
    return Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], key, delimiters_map[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(loc, /* Some */["find_delimiters"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unknown scope delimiting key "), Pp$ReactTemplate.str(key)), Pp$ReactTemplate.str(".")));
    } else {
      throw exn;
    }
  }
}

function key_compare(k1, k2) {
  if (k1) {
    if (k2) {
      return Globnames$ReactTemplate.RefOrdered[/* compare */0](k1[0], k2[0]);
    } else {
      return -1;
    }
  } else if (k2) {
    return 1;
  } else {
    return 0;
  }
}

var KeyOrd = /* module */[/* compare */key_compare];

var KeyMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], KeyOrd);

function keymap_add(key, interp, map) {
  var old;
  try {
    old = Curry._2(KeyMap[/* find */21], key, map);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      old = /* [] */0;
    } else {
      throw exn;
    }
  }
  return Curry._3(KeyMap[/* add */3], key, /* :: */[
              interp,
              old
            ], map);
}

function keymap_find(key, map) {
  try {
    return Curry._2(KeyMap[/* find */21], key, map);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

var notations_key_table = [KeyMap[/* empty */0]];

var prim_token_key_table = [KeyMap[/* empty */0]];

function glob_prim_constr_key(c) {
  var match = DAst$ReactTemplate.get(c);
  switch (match.tag | 0) {
    case 0 : 
        return /* RefKey */[Globnames$ReactTemplate.canonical_gr(match[0])];
    case 4 : 
        var match$1 = DAst$ReactTemplate.get(match[0]);
        if (match$1.tag) {
          return /* Oth */0;
        } else {
          return /* RefKey */[Globnames$ReactTemplate.canonical_gr(match$1[0])];
        }
        break;
    default:
      return /* Oth */0;
  }
}

function glob_constr_keys(c) {
  var match = DAst$ReactTemplate.get(c);
  switch (match.tag | 0) {
    case 0 : 
        return /* :: */[
                /* RefKey */[Globnames$ReactTemplate.canonical_gr(match[0])],
                /* [] */0
              ];
    case 4 : 
        var match$1 = DAst$ReactTemplate.get(match[0]);
        if (match$1.tag) {
          return /* :: */[
                  /* Oth */0,
                  /* [] */0
                ];
        } else {
          return /* :: */[
                  /* RefKey */[Globnames$ReactTemplate.canonical_gr(match$1[0])],
                  /* :: */[
                    /* Oth */0,
                    /* [] */0
                  ]
                ];
        }
        break;
    default:
      return /* :: */[
              /* Oth */0,
              /* [] */0
            ];
  }
}

function cases_pattern_key(c) {
  var match = DAst$ReactTemplate.get(c);
  if (match.tag) {
    return /* RefKey */[Globnames$ReactTemplate.canonical_gr(/* ConstructRef */Block.__(3, [match[0]]))];
  } else {
    return /* Oth */0;
  }
}

function notation_constr_key(param) {
  var exit = 0;
  var ref;
  var args;
  switch (param.tag | 0) {
    case 0 : 
        return /* tuple */[
                /* RefKey */[Globnames$ReactTemplate.canonical_gr(param[0])],
                /* None */0
              ];
    case 2 : 
        var match = param[0];
        if (match.tag) {
          return /* tuple */[
                  /* Oth */0,
                  /* Some */[Curry._1(Util$ReactTemplate.List[/* length */0], param[1])]
                ];
        } else {
          return /* tuple */[
                  /* RefKey */[Globnames$ReactTemplate.canonical_gr(match[0])],
                  /* Some */[Curry._1(Util$ReactTemplate.List[/* length */0], param[1])]
                ];
        }
        break;
    case 4 : 
        var match$1 = param[2];
        if (match$1.tag === 2) {
          var match$2 = match$1[0];
          if (match$2.tag) {
            return /* tuple */[
                    /* Oth */0,
                    /* None */0
                  ];
          } else {
            ref = match$2[0];
            args = match$1[1];
            exit = 1;
          }
        } else {
          return /* tuple */[
                  /* Oth */0,
                  /* None */0
                ];
        }
        break;
    case 7 : 
        var match$3 = param[2];
        if (match$3.tag === 2) {
          var match$4 = match$3[0];
          if (match$4.tag) {
            return /* tuple */[
                    /* Oth */0,
                    /* None */0
                  ];
          } else {
            ref = match$4[0];
            args = match$3[1];
            exit = 1;
          }
        } else {
          return /* tuple */[
                  /* Oth */0,
                  /* None */0
                ];
        }
        break;
    default:
      return /* tuple */[
              /* Oth */0,
              /* None */0
            ];
  }
  if (exit === 1) {
    return /* tuple */[
            /* RefKey */[Globnames$ReactTemplate.canonical_gr(ref)],
            /* Some */[Curry._1(Util$ReactTemplate.List[/* length */0], args)]
          ];
  }
  
}

var prim_token_interpreter_tab = Hashtbl.create(/* None */0, 7);

function add_prim_token_interpreter(sc, interp) {
  try {
    var cont = Hashtbl.find(prim_token_interpreter_tab, sc);
    return Hashtbl.replace(prim_token_interpreter_tab, sc, Curry._1(interp, cont));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var cont$1 = function (_, _$1) {
        throw Caml_builtin_exceptions.not_found;
      };
      return Hashtbl.add(prim_token_interpreter_tab, sc, Curry._1(interp, cont$1));
    } else {
      throw exn;
    }
  }
}

function declare_prim_token_interpreter(sc, interp, param) {
  var b = param[2];
  var uninterp = param[1];
  declare_scope(sc);
  add_prim_token_interpreter(sc, interp);
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (pat) {
                prim_token_key_table[0] = Curry._3(KeyMap[/* add */3], glob_prim_constr_key(pat), /* tuple */[
                      sc,
                      uninterp,
                      b
                    ], prim_token_key_table[0]);
                return /* () */0;
              }), param[0]);
}

function mkNumeral(n) {
  if (Bigint$ReactTemplate.is_pos_or_zero(n)) {
    return /* Numeral */Block.__(0, [
              Bigint$ReactTemplate.to_string(n),
              /* true */1
            ]);
  } else {
    return /* Numeral */Block.__(0, [
              Bigint$ReactTemplate.to_string(Bigint$ReactTemplate.neg(n)),
              /* false */0
            ]);
  }
}

function ofNumeral(n, s) {
  if (s) {
    return Bigint$ReactTemplate.of_string(n);
  } else {
    return Bigint$ReactTemplate.neg(Bigint$ReactTemplate.of_string(n));
  }
}

function delay(dir, $$int, loc, x) {
  return /* tuple */[
          dir,
          (function () {
              return Curry._2($$int, loc, x);
            })
        ];
}

function declare_rawnumeral_interpreter(sc, dir, interp, param) {
  var uninterp = param[1];
  return declare_prim_token_interpreter(sc, (function (cont, loc, p) {
                if (p.tag) {
                  return Curry._2(cont, loc, p);
                } else {
                  return delay(dir, interp, loc, /* tuple */[
                              p[0],
                              p[1]
                            ]);
                }
              }), /* tuple */[
              param[0],
              (function (r) {
                  var match = Curry._1(uninterp, r);
                  if (match) {
                    var match$1 = match[0];
                    return /* Some */[/* Numeral */Block.__(0, [
                                match$1[0],
                                match$1[1]
                              ])];
                  } else {
                    return /* None */0;
                  }
                }),
              param[2]
            ]);
}

function declare_numeral_interpreter(sc, dir, interp, param) {
  var uninterp = param[1];
  var interp$prime = function (loc, param) {
    return Curry._2(interp, loc, ofNumeral(param[0], param[1]));
  };
  return declare_prim_token_interpreter(sc, (function (cont, loc, p) {
                if (p.tag) {
                  return Curry._2(cont, loc, p);
                } else {
                  return delay(dir, interp$prime, loc, /* tuple */[
                              p[0],
                              p[1]
                            ]);
                }
              }), /* tuple */[
              param[0],
              (function (r) {
                  return Option$ReactTemplate.map(mkNumeral, Curry._1(uninterp, r));
                }),
              param[2]
            ]);
}

function declare_string_interpreter(sc, dir, interp, param) {
  var uninterp = param[1];
  return declare_prim_token_interpreter(sc, (function (cont, loc, p) {
                if (p.tag) {
                  return delay(dir, interp, loc, p[0]);
                } else {
                  return Curry._2(cont, loc, p);
                }
              }), /* tuple */[
              param[0],
              (function (r) {
                  var param = Curry._1(uninterp, r);
                  if (param) {
                    var s = param[0];
                    if (Unicode$ReactTemplate.is_utf8(s)) {
                      return /* Some */[/* String */Block.__(1, [s])];
                    } else {
                      return /* None */0;
                    }
                  } else {
                    return /* None */0;
                  }
                }),
              param[2]
            ]);
}

function check_required_module(loc, sc, param) {
  try {
    Nametab$ReactTemplate.global_of_path(param[0]);
    return /* () */0;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(loc, /* Some */["prim_token_interpreter"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot interpret in "), Pp$ReactTemplate.str(sc)), Pp$ReactTemplate.str(" without requiring first module ")), Pp$ReactTemplate.str(Curry._1(Util$ReactTemplate.List[/* last */105], param[1]))), Pp$ReactTemplate.str(".")));
    } else {
      throw exn;
    }
  }
}

function find_with_delimiters(param) {
  if (param) {
    var scope = param[0];
    var match = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], scope, scope_map[0])[/* delimiters */1];
    if (match) {
      return /* Some */[/* tuple */[
                /* Some */[scope],
                /* Some */[match[0]]
              ]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function find_without_delimiters(find, _param, _param$1) {
  while(true) {
    var param = _param$1;
    var param$1 = _param;
    var ntn = param$1[1];
    var ntn_scope = param$1[0];
    if (param) {
      var match = param[0];
      if (match.tag) {
        var exit = 0;
        if (ntn_scope) {
          exit = 1;
        } else if (ntn) {
          if (ntn[0] === match[0]) {
            return /* Some */[/* tuple */[
                      /* None */0,
                      /* None */0
                    ]];
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          _param$1 = param[1];
          _param = /* tuple */[
            ntn_scope,
            ntn
          ];
          continue ;
          
        }
        
      } else {
        var scope = match[0];
        var exit$1 = 0;
        if (ntn_scope) {
          if (scope === ntn_scope[0]) {
            return /* Some */[/* tuple */[
                      /* None */0,
                      /* None */0
                    ]];
          } else {
            exit$1 = 1;
          }
        } else {
          exit$1 = 1;
        }
        if (exit$1 === 1) {
          if (Curry._1(find, scope)) {
            return find_with_delimiters(ntn_scope);
          } else {
            _param$1 = param[1];
            _param = /* tuple */[
              ntn_scope,
              ntn
            ];
            continue ;
            
          }
        }
        
      }
    } else {
      return find_with_delimiters(ntn_scope);
    }
  };
}

function declare_notation_level(ntn, level) {
  if (Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* mem */2], ntn, notation_level_map[0])) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation "), Pp$ReactTemplate.str(ntn)), Pp$ReactTemplate.str(" is already assigned a level.")));
  }
  notation_level_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], ntn, level, notation_level_map[0]);
  return /* () */0;
}

function level_of_notation(ntn) {
  return Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], ntn, notation_level_map[0]);
}

var warn_notation_overridden = CWarnings$ReactTemplate.create("notation-overridden", "parsing", /* None */0, (function (param) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(param[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.strbrk("was already used")), param[1]), Pp$ReactTemplate.str("."));
      }));

function declare_notation_interpretation(ntn, scopt, pat, df, onlyprint) {
  var scope = scopt ? scopt[0] : default_scope;
  var sc = find_scope(scope);
  if (Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* mem */2], ntn, sc[/* notations */0])) {
    var which_scope = scopt ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.strbrk("in scope")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(scope)) : Pp$ReactTemplate.mt(/* () */0);
    Curry._2(warn_notation_overridden, /* None */0, /* tuple */[
          ntn,
          which_scope
        ]);
  }
  var notdata = /* record */[
    /* not_interp */pat,
    /* not_location */df,
    /* not_onlyprinting */onlyprint
  ];
  var sc_000 = /* notations */Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], ntn, notdata, sc[/* notations */0]);
  var sc_001 = /* delimiters */sc[/* delimiters */1];
  var sc$1 = /* record */[
    sc_000,
    sc_001
  ];
  scope_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], scope, sc$1, scope_map[0]);
  if (scopt) {
    return /* () */0;
  } else {
    scope_stack[0] = /* :: */[
      /* SingleNotation */Block.__(1, [ntn]),
      scope_stack[0]
    ];
    return /* () */0;
  }
}

function declare_uninterpretation(rule, pat) {
  var match = notation_constr_key(pat[1]);
  notations_key_table[0] = keymap_add(match[0], /* tuple */[
        rule,
        pat,
        match[1]
      ], notations_key_table[0]);
  return /* () */0;
}

function find_interpretation(ntn, find, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (match.tag) {
        var scopes = param[1];
        if (match[0] === ntn) {
          try {
            var match$1 = Curry._1(find, default_scope);
            return /* tuple */[
                    match$1[0],
                    /* tuple */[
                      match$1[1],
                      /* None */0
                    ]
                  ];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              _param = scopes;
              continue ;
              
            } else {
              throw exn;
            }
          }
        } else {
          _param = scopes;
          continue ;
          
        }
      } else {
        var scope = match[0];
        try {
          var match$2 = Curry._1(find, scope);
          return /* tuple */[
                  match$2[0],
                  /* tuple */[
                    match$2[1],
                    /* Some */[scope]
                  ]
                ];
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            _param = param[1];
            continue ;
            
          } else {
            throw exn$1;
          }
        }
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_notation(ntn, sc) {
  var n = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], ntn, find_scope(sc)[/* notations */0]);
  if (n[/* not_onlyprinting */2]) {
    throw Caml_builtin_exceptions.not_found;
  }
  return /* tuple */[
          n[/* not_interp */0],
          n[/* not_location */1]
        ];
}

function notation_of_prim_token(param) {
  if (param.tag) {
    throw Caml_builtin_exceptions.not_found;
  } else {
    var n = param[0];
    if (param[1] !== 0) {
      return n;
    } else {
      return "- " + n;
    }
  }
}

function interp_prim_token_gen(loc, g, p, local_scopes) {
  var scopes = make_current_scopes(local_scopes);
  var p_as_ntn;
  try {
    p_as_ntn = notation_of_prim_token(p);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      p_as_ntn = "";
    } else {
      throw exn;
    }
  }
  try {
    return find_interpretation(p_as_ntn, (function (param) {
                  var check_allowed = g;
                  var loc$1 = loc;
                  var p$1 = p;
                  var sc = param;
                  try {
                    var match = find_notation(notation_of_prim_token(p$1), sc);
                    var pat = Notation_ops$ReactTemplate.glob_constr_of_notation_constr(loc$1, match[0][1]);
                    Curry._1(check_allowed, pat);
                    return /* tuple */[
                            pat,
                            match[1]
                          ];
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      var match$1 = Curry._2(Hashtbl.find(prim_token_interpreter_tab, sc), loc$1, p$1);
                      var spdir = match$1[0];
                      check_required_module(loc$1, sc, spdir);
                      var pat$1 = Curry._1(match$1[1], /* () */0);
                      Curry._1(check_allowed, pat$1);
                      return /* tuple */[
                              pat$1,
                              /* tuple */[
                                /* tuple */[
                                  Libnames$ReactTemplate.dirpath(spdir[0]),
                                  Names$ReactTemplate.DirPath[/* empty */5]
                                ],
                                ""
                              ]
                            ];
                    } else {
                      throw exn;
                    }
                  }
                }), scopes);
  }
  catch (exn$1){
    if (exn$1 === Caml_builtin_exceptions.not_found) {
      var tmp;
      tmp = p.tag ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No interpretation for string "), Pp$ReactTemplate.qs(p[0])) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No interpretation for numeral "), Pp$ReactTemplate.str(notation_of_prim_token(p)));
      return CErrors$ReactTemplate.user_err(loc, /* Some */["interp_prim_token"], Pp$ReactTemplate.$plus$plus(tmp, Pp$ReactTemplate.str(".")));
    } else {
      throw exn$1;
    }
  }
}

function interp_prim_token(loc) {
  return (function (param, param$1) {
      return interp_prim_token_gen(loc, (function () {
                    return /* () */0;
                  }), param, param$1);
    });
}

function check_allowed_ref_in_pat(looked_for) {
  return (function (param) {
      return DAst$ReactTemplate.with_val((function (param) {
                    switch (param.tag | 0) {
                      case 0 : 
                          return Curry._1(looked_for, param[0]);
                      case 4 : 
                          var match = DAst$ReactTemplate.get(param[0]);
                          if (match.tag) {
                            throw Caml_builtin_exceptions.not_found;
                          } else {
                            Curry._1(looked_for, match[0]);
                            return Curry._2(Util$ReactTemplate.List[/* iter */9], check_allowed_ref_in_pat(looked_for), param[1]);
                          }
                          break;
                      case 1 : 
                      case 13 : 
                          return /* () */0;
                      default:
                        throw Caml_builtin_exceptions.not_found;
                    }
                  }), param);
    });
}

function interp_prim_token_cases_pattern_expr(loc, looked_for, p) {
  var partial_arg = check_allowed_ref_in_pat(looked_for);
  return (function (param) {
      return interp_prim_token_gen(loc, partial_arg, p, param);
    });
}

function interp_notation(loc, ntn, local_scopes) {
  var scopes = make_current_scopes(local_scopes);
  try {
    return find_interpretation(ntn, (function (param) {
                  return find_notation(ntn, param);
                }), scopes);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unknown interpretation for notation \""), Pp$ReactTemplate.str(ntn)), Pp$ReactTemplate.str("\".")));
    } else {
      throw exn;
    }
  }
}

function uninterp_notations(c) {
  return Curry._2(Util$ReactTemplate.List[/* map_append */113], (function (key) {
                return keymap_find(key, notations_key_table[0]);
              }), glob_constr_keys(c));
}

function uninterp_cases_pattern_notations(c) {
  return keymap_find(cases_pattern_key(c), notations_key_table[0]);
}

function uninterp_ind_pattern_notations(ind) {
  return keymap_find(/* RefKey */[Globnames$ReactTemplate.canonical_gr(/* IndRef */Block.__(2, [ind]))], notations_key_table[0]);
}

function availability_of_notation(param, scopes) {
  var ntn = param[1];
  var f = function (scope) {
    return Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* mem */2], ntn, Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], scope, scope_map[0])[/* notations */0]);
  };
  return find_without_delimiters(f, /* tuple */[
              param[0],
              /* Some */[ntn]
            ], make_current_scopes(scopes));
}

function uninterp_prim_token(c) {
  try {
    var match = Curry._2(KeyMap[/* find */21], glob_prim_constr_key(c), prim_token_key_table[0]);
    var match$1 = Curry._1(match[1], /* AnyGlobConstr */[c]);
    if (match$1) {
      return /* tuple */[
              match[0],
              match$1[0]
            ];
    } else {
      throw Notation_ops$ReactTemplate.No_match;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw Notation_ops$ReactTemplate.No_match;
    } else {
      throw exn;
    }
  }
}

function uninterp_prim_token_ind_pattern(ind, args) {
  var ref = /* IndRef */Block.__(2, [ind]);
  try {
    var k = /* RefKey */[Globnames$ReactTemplate.canonical_gr(ref)];
    var match = Curry._2(KeyMap[/* find */21], k, prim_token_key_table[0]);
    if (!match[2]) {
      throw Notation_ops$ReactTemplate.No_match;
    }
    var args$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
            return Glob_ops$ReactTemplate.glob_constr_of_closed_cases_pattern(x)[1];
          }), args);
    var eta = /* GRef */Block.__(0, [
        ref,
        /* None */0
      ]);
    var ref$1 = DAst$ReactTemplate.make(/* None */0, eta);
    var eta$1 = /* GApp */Block.__(4, [
        ref$1,
        args$prime
      ]);
    var match$1 = Curry._1(match[1], /* AnyGlobConstr */[DAst$ReactTemplate.make(/* None */0, eta$1)]);
    if (match$1) {
      return /* tuple */[
              match[0],
              match$1[0]
            ];
    } else {
      throw Notation_ops$ReactTemplate.No_match;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw Notation_ops$ReactTemplate.No_match;
    } else {
      throw exn;
    }
  }
}

function uninterp_prim_token_cases_pattern(c) {
  try {
    var k = cases_pattern_key(c);
    var match = Curry._2(KeyMap[/* find */21], k, prim_token_key_table[0]);
    if (!match[2]) {
      throw Notation_ops$ReactTemplate.No_match;
    }
    var match$1 = Glob_ops$ReactTemplate.glob_constr_of_closed_cases_pattern(c);
    var match$2 = Curry._1(match[1], /* AnyGlobConstr */[match$1[1]]);
    if (match$2) {
      return /* tuple */[
              match$1[0],
              match[0],
              match$2[0]
            ];
    } else {
      throw Notation_ops$ReactTemplate.No_match;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw Notation_ops$ReactTemplate.No_match;
    } else {
      throw exn;
    }
  }
}

function availability_of_prim_token(n, printer_scope, local_scopes) {
  var f = function (scope) {
    try {
      Curry._2(Hashtbl.find(prim_token_interpreter_tab, scope), /* None */0, n);
      return /* true */1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  };
  var scopes = make_current_scopes(local_scopes);
  return Option$ReactTemplate.map((function (prim) {
                return prim[1];
              }), find_without_delimiters(f, /* tuple */[
                  /* Some */[printer_scope],
                  /* None */0
                ], scopes));
}

function pair_eq(f, g, param, param$1) {
  if (Curry._2(f, param[0], param$1[0])) {
    return Curry._2(g, param[1], param$1[1]);
  } else {
    return /* false */0;
  }
}

function var_attributes_eq(param, param$1) {
  var match = param$1[1];
  var match$1 = param[1];
  if (pair_eq((function (param, param$1) {
            return Option$ReactTemplate.equal((function (prim, prim$1) {
                          return +(prim === prim$1);
                        }), param, param$1);
          }), Curry._1(Util$ReactTemplate.List[/* equal */44], (function (prim, prim$1) {
                return +(prim === prim$1);
              })), match$1[0], match[0])) {
    var t1 = match$1[1];
    var t2 = match[1];
    if (typeof t1 === "number") {
      switch (t1) {
        case 0 : 
            if (typeof t2 === "number" && t2 === 0) {
              return /* true */1;
            } else {
              return /* false */0;
            }
        case 1 : 
            if (typeof t2 === "number" && t2 === 1) {
              return /* true */1;
            } else {
              return /* false */0;
            }
        case 2 : 
            if (typeof t2 === "number" && t2 >= 2) {
              return /* true */1;
            } else {
              return /* false */0;
            }
        
      }
    } else if (typeof t2 === "number") {
      return /* false */0;
    } else {
      var s1 = t1[0];
      var s2 = t2[0];
      if (typeof s1 === "number") {
        if (typeof s2 === "number") {
          return /* true */1;
        } else {
          return /* false */0;
        }
      } else if (s1.tag) {
        if (typeof s2 === "number" || !s2.tag) {
          return /* false */0;
        } else {
          return +(s1[0] === s2[0]);
        }
      } else if (typeof s2 === "number" || s2.tag) {
        return /* false */0;
      } else {
        return +(s1[0] === s2[0]);
      }
    }
  } else {
    return /* false */0;
  }
}

function exists_notation_in_scope(scopt, ntn, onlyprint, r) {
  var scope = scopt ? scopt[0] : default_scope;
  try {
    var sc = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], scope, scope_map[0]);
    var n = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], ntn, sc[/* notations */0]);
    if (onlyprint === n[/* not_onlyprinting */2]) {
      var param = n[/* not_interp */0];
      var param$1 = r;
      var vars2 = param$1[0];
      var vars1 = param[0];
      if (Curry._3(Util$ReactTemplate.List[/* equal */44], var_attributes_eq, vars1, vars2)) {
        return Notation_ops$ReactTemplate.eq_notation_constr(/* tuple */[
                    Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                            return prim[0];
                          }), vars1),
                    Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                            return prim[0];
                          }), vars2)
                  ], param[1], param$1[1]);
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function isNVar_or_NHole(param) {
  switch (param.tag | 0) {
    case 1 : 
    case 3 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function compute_scope_class(sigma, t) {
  return Classops$ReactTemplate.find_class_type(sigma, t)[0];
}

var ScopeClassOrd = /* module */[/* compare */Classops$ReactTemplate.cl_typ_ord];

var ScopeClassMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], ScopeClassOrd);

var initial_scope_class_map = ScopeClassMap[/* empty */0];

var scope_class_map = [initial_scope_class_map];

function declare_scope_class(sc, cl) {
  scope_class_map[0] = Curry._3(ScopeClassMap[/* add */3], cl, sc, scope_class_map[0]);
  return /* () */0;
}

function find_scope_class(cl) {
  return Curry._2(ScopeClassMap[/* find */21], cl, scope_class_map[0]);
}

function find_scope_class_opt(param) {
  if (param) {
    try {
      return /* Some */[find_scope_class(param[0])];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
  } else {
    return /* None */0;
  }
}

function compute_arguments_classes(sigma, t) {
  var match = EConstr$ReactTemplate.kind(sigma, Reductionops$ReactTemplate.whd_betaiotazeta(sigma, t));
  if (match.tag === 6) {
    var cl;
    try {
      cl = /* Some */[compute_scope_class(sigma, match[1])];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        cl = /* None */0;
      } else {
        throw exn;
      }
    }
    return /* :: */[
            cl,
            compute_arguments_classes(sigma, match[2])
          ];
  } else {
    return /* [] */0;
  }
}

function compute_arguments_scope_full(sigma, t) {
  var cls = compute_arguments_classes(sigma, t);
  var scs = Curry._2(Util$ReactTemplate.List[/* map */10], find_scope_class_opt, cls);
  return /* tuple */[
          scs,
          cls
        ];
}

function compute_arguments_scope(sigma, t) {
  return compute_arguments_scope_full(sigma, t)[0];
}

function compute_type_scope(sigma, t) {
  var tmp;
  try {
    tmp = /* Some */[compute_scope_class(sigma, t)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      tmp = /* None */0;
    } else {
      throw exn;
    }
  }
  return find_scope_class_opt(tmp);
}

function current_type_scope_name() {
  return find_scope_class_opt(/* Some */[/* CL_SORT */0]);
}

function scope_class_of_class(x) {
  return x;
}

function update_scope(cl, sco) {
  var sco$prime = find_scope_class_opt(cl);
  if (sco$prime) {
    return sco$prime;
  } else {
    return sco;
  }
}

function update_scopes(cls, scl) {
  if (cls) {
    if (scl) {
      return /* :: */[
              update_scope(cls[0], scl[0]),
              update_scopes(cls[1], scl[1])
            ];
    } else {
      return Curry._2(Util$ReactTemplate.List[/* map */10], find_scope_class_opt, cls);
    }
  } else {
    return scl;
  }
}

var arguments_scope = [Globnames$ReactTemplate.Refmap[/* empty */0]];

function load_arguments_scope(_, param) {
  var match = param[1];
  var scl = match[3];
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
          return Option$ReactTemplate.iter(check_scope, param);
        }), scl);
  var initial_stamp = ScopeClassMap[/* empty */0];
  arguments_scope[0] = Curry._3(Globnames$ReactTemplate.Refmap[/* add */3], match[1], /* tuple */[
        scl,
        match[4],
        initial_stamp
      ], arguments_scope[0]);
  return /* () */0;
}

function cache_arguments_scope(o) {
  return load_arguments_scope(1, o);
}

function subst_scope_class(subst, cs) {
  try {
    return /* Some */[Classops$ReactTemplate.subst_cl_typ(subst, cs)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function subst_arguments_scope(param) {
  var match = param[1];
  var subst = param[0];
  var r$prime = Globnames$ReactTemplate.subst_global(subst, match[1])[0];
  var subst_cl = function (ocl) {
    if (ocl) {
      var cl = ocl[0];
      var ocl$prime = subst_scope_class(subst, cl);
      if (ocl$prime && ocl$prime[0] !== cl) {
        return ocl$prime;
      } else {
        return ocl;
      }
    } else {
      return ocl;
    }
  };
  var cls$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], subst_cl, match[4]);
  return /* tuple */[
          /* ArgsScopeNoDischarge */2,
          r$prime,
          match[2],
          match[3],
          cls$prime
        ];
}

function discharge_arguments_scope(param) {
  var match = param[1];
  var r = match[1];
  var req = match[0];
  if (req === /* ArgsScopeNoDischarge */2 || Globnames$ReactTemplate.isVarRef(r) && Lib$ReactTemplate.is_in_section(r)) {
    return /* None */0;
  } else {
    var n;
    try {
      var vars = Lib$ReactTemplate.variable_section_segment_of_reference(r);
      n = Curry._1(Util$ReactTemplate.List[/* length */0], Curry._2(Util$ReactTemplate.List[/* filter */27], Context$ReactTemplate.Named[/* Declaration */0][/* is_local_assum */5], Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                      return prim[0];
                    }), vars)));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        n = 0;
      } else {
        throw exn;
      }
    }
    return /* Some */[/* tuple */[
              req,
              Lib$ReactTemplate.discharge_global(r),
              n,
              match[3],
              /* [] */0
            ]];
  }
}

function classify_arguments_scope(obj) {
  if (obj[0] === /* ArgsScopeNoDischarge */2) {
    return /* Dispose */0;
  } else {
    return /* Substitute */Block.__(0, [obj]);
  }
}

var init$1 = Libobject$ReactTemplate.default_object("ARGUMENTS-SCOPE");

var inArgumentsScope = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$1[/* object_name */0],
      /* cache_function */cache_arguments_scope,
      /* load_function */load_arguments_scope,
      /* open_function */init$1[/* open_function */3],
      /* classify_function */classify_arguments_scope,
      /* subst_function */subst_arguments_scope,
      /* discharge_function */discharge_arguments_scope,
      /* rebuild_function */(function (param) {
          var sigma = Evd$ReactTemplate.empty;
          var param$1 = param;
          var n = param$1[2];
          var r = param$1[1];
          var req = param$1[0];
          switch (req) {
            case 0 : 
                var env = Global$ReactTemplate.env(/* () */0);
                var typ = EConstr$ReactTemplate.of_constr(Global$ReactTemplate.type_of_global_in_context(env, r)[0]);
                var match = compute_arguments_scope_full(sigma, typ);
                var scs = match[0];
                return /* tuple */[
                        req,
                        r,
                        Curry._1(Util$ReactTemplate.List[/* length */0], scs),
                        scs,
                        match[1]
                      ];
            case 1 : 
                var env$1 = Global$ReactTemplate.env(/* () */0);
                var typ$1 = EConstr$ReactTemplate.of_constr(Global$ReactTemplate.type_of_global_in_context(env$1, r)[0]);
                var match$1 = compute_arguments_scope_full(sigma, typ$1);
                var l1 = Curry._2(Util$ReactTemplate.List[/* firstn */104], n, match$1[0]);
                var cls1 = Curry._2(Util$ReactTemplate.List[/* firstn */104], n, match$1[1]);
                return /* tuple */[
                        req,
                        r,
                        0,
                        Util$ReactTemplate.$at(l1, param$1[3]),
                        cls1
                      ];
            case 2 : 
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "notation.ml",
                        763,
                        30
                      ]
                    ];
            
          }
        })
    ]);

function is_local(local, ref) {
  if (local) {
    return /* true */1;
  } else if (Globnames$ReactTemplate.isVarRef(ref)) {
    return Lib$ReactTemplate.is_in_section(ref);
  } else {
    return /* false */0;
  }
}

function declare_arguments_scope_gen(req, r, n, param) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inArgumentsScope, /* tuple */[
                  req,
                  r,
                  n,
                  param[0],
                  param[1]
                ]));
}

function declare_arguments_scope(local, r, scl) {
  var req = is_local(local, r) ? /* ArgsScopeNoDischarge */2 : /* ArgsScopeManual */1;
  return declare_arguments_scope_gen(req, r, 0, /* tuple */[
              scl,
              /* [] */0
            ]);
}

function find_arguments_scope(r) {
  try {
    var match = Curry._2(Globnames$ReactTemplate.Refmap[/* find */21], r, arguments_scope[0]);
    var cls = match[1];
    var scl = match[0];
    var cur_stamp = scope_class_map[0];
    if (match[2] === cur_stamp) {
      return scl;
    } else {
      var scl$prime = update_scopes(cls, scl);
      arguments_scope[0] = Curry._3(Globnames$ReactTemplate.Refmap[/* add */3], r, /* tuple */[
            scl$prime,
            cls,
            cur_stamp
          ], arguments_scope[0]);
      return scl$prime;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

function declare_ref_arguments_scope(sigma, ref) {
  var env = Global$ReactTemplate.env(/* () */0);
  var typ = EConstr$ReactTemplate.of_constr(Global$ReactTemplate.type_of_global_in_context(env, ref)[0]);
  var o = compute_arguments_scope_full(sigma, typ);
  return declare_arguments_scope_gen(/* ArgsScopeAuto */0, ref, Curry._1(Util$ReactTemplate.List[/* length */0], o[0]), o);
}

function symbol_eq(s1, s2) {
  switch (s1.tag | 0) {
    case 0 : 
        if (s2.tag) {
          return /* false */0;
        } else {
          return +(s1[0] === s2[0]);
        }
        break;
    case 1 : 
        if (s2.tag === 1) {
          return Names$ReactTemplate.Id[/* equal */0](s1[0], s2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 2 : 
        if (s2.tag === 2 && Names$ReactTemplate.Id[/* equal */0](s1[0], s2[0])) {
          return Curry._3(Util$ReactTemplate.List[/* equal */44], symbol_eq, s1[1], s2[1]);
        } else {
          return /* false */0;
        }
        break;
    case 3 : 
        if (s2.tag === 3) {
          return +(s1[0] === s2[0]);
        } else {
          return /* false */0;
        }
        break;
    
  }
}

function string_of_symbol(param) {
  switch (param.tag | 0) {
    case 0 : 
        var s = param[0];
        if (s === "_") {
          return /* :: */[
                  "'_'",
                  /* [] */0
                ];
        } else {
          return /* :: */[
                  s,
                  /* [] */0
                ];
        }
        break;
    case 1 : 
        return /* :: */[
                "_",
                /* [] */0
              ];
    case 2 : 
        var l = Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], string_of_symbol, param[1]));
        return Util$ReactTemplate.$at(/* :: */[
                    "_",
                    l
                  ], Util$ReactTemplate.$at(/* :: */[
                        "..",
                        l
                      ], /* :: */[
                        "_",
                        /* [] */0
                      ]));
    case 3 : 
        return /* [] */0;
    
  }
}

function make_notation_key(symbols) {
  return Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], string_of_symbol, symbols)));
}

function decompose_notation_key(s) {
  var len = s.length;
  var _dirs = /* [] */0;
  var _n = 0;
  while(true) {
    var n = _n;
    var dirs = _dirs;
    if (n >= len) {
      return Curry._1(Util$ReactTemplate.List[/* rev */4], dirs);
    } else {
      var pos;
      try {
        pos = Curry._3(Util$ReactTemplate.$$String[/* index_from */15], s, n, /* " " */32);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          pos = len;
        } else {
          throw exn;
        }
      }
      var s$1 = Curry._3(Util$ReactTemplate.$$String[/* sub */3], s, n, pos - n | 0);
      var tok = s$1 === "_" ? /* NonTerminal */Block.__(1, [Names$ReactTemplate.Id[/* of_string */5]("_")]) : /* Terminal */Block.__(0, [Curry._1(Util$ReactTemplate.$$String[/* drop_simple_quotes */30], s$1)]);
      _n = pos + 1 | 0;
      _dirs = /* :: */[
        tok,
        dirs
      ];
      continue ;
      
    }
  };
}

function pr_delimiters_info(param) {
  if (param) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Delimiting key is "), Pp$ReactTemplate.str(param[0]));
  } else {
    return Pp$ReactTemplate.str("No delimiting key");
  }
}

function classes_of_scope(sc) {
  return Curry._3(ScopeClassMap[/* fold */10], (function (cl, sc$prime, l) {
                if (sc === sc$prime) {
                  return /* :: */[
                          cl,
                          l
                        ];
                } else {
                  return l;
                }
              }), scope_class_map[0], /* [] */0);
}

function pr_scope_classes(sc) {
  var l = classes_of_scope(sc);
  if (l) {
    var opt_s = l[1] ? Pp$ReactTemplate.str("es") : Pp$ReactTemplate.mt(/* () */0);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Bound to class"), opt_s), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Classops$ReactTemplate.pr_class, l))), Pp$ReactTemplate.fnl(/* () */0));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_notation_info(prglob, ntn, c) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("\""), Pp$ReactTemplate.str(ntn)), Pp$ReactTemplate.str("\" := ")), Curry._1(prglob, Notation_ops$ReactTemplate.glob_constr_of_notation_constr(/* None */0, c)));
}

function pr_named_scope(prglob, scope, sc) {
  var tmp;
  if (scope === default_scope) {
    var n = Curry._1(Util$ReactTemplate.$$String[/* Map */39][/* cardinal */15], sc[/* notations */0]);
    tmp = n !== 0 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Lonely notation"), n === 1 ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.str("s")) : Pp$ReactTemplate.str("No lonely notation");
  } else {
    tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Scope "), Pp$ReactTemplate.str(scope)), Pp$ReactTemplate.fnl(/* () */0)), pr_delimiters_info(sc[/* delimiters */1]));
  }
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(tmp, Pp$ReactTemplate.fnl(/* () */0)), pr_scope_classes(scope)), Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* fold */10], (function (_, param, strm) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_notation_info(prglob, param[/* not_location */1][1], param[/* not_interp */0][1]), Pp$ReactTemplate.fnl(/* () */0)), strm);
                  }), sc[/* notations */0], Pp$ReactTemplate.mt(/* () */0)));
}

function pr_scope(prglob, scope) {
  return pr_named_scope(prglob, scope, find_scope(scope));
}

function pr_scopes(prglob) {
  return Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* fold */10], (function (scope, sc, strm) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_named_scope(prglob, scope, sc), Pp$ReactTemplate.fnl(/* () */0)), strm);
              }), scope_map[0], Pp$ReactTemplate.mt(/* () */0));
}

function find_default(ntn, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (match.tag) {
        if (ntn === match[0]) {
          return /* Some */[default_scope];
        } else {
          _param = param[1];
          continue ;
          
        }
      } else {
        var scope = match[0];
        if (Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* mem */2], ntn, find_scope(scope)[/* notations */0])) {
          return /* Some */[scope];
        } else {
          _param = param[1];
          continue ;
          
        }
      }
    } else {
      return /* None */0;
    }
  };
}

function factorize_entries(param) {
  if (param) {
    var match = param[0];
    var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
            var c = param$1[1];
            var a = param$1[0];
            var rest = param[2];
            var l = param[1];
            var a$prime = param[0];
            if (a === a$prime) {
              return /* tuple */[
                      a$prime,
                      /* :: */[
                        c,
                        l
                      ],
                      rest
                    ];
            } else {
              return /* tuple */[
                      a,
                      /* :: */[
                        c,
                        /* [] */0
                      ],
                      /* :: */[
                        /* tuple */[
                          a$prime,
                          l
                        ],
                        rest
                      ]
                    ];
            }
          }), /* tuple */[
          match[0],
          /* :: */[
            match[1],
            /* [] */0
          ],
          /* [] */0
        ], param[1]);
    return /* :: */[
            /* tuple */[
              match$1[0],
              match$1[1]
            ],
            match$1[2]
          ];
  } else {
    return /* [] */0;
  }
}

function split_notation_string(str) {
  var push_token = function (beg, i, l) {
    if (beg === i) {
      return l;
    } else {
      var s = Curry._3(Util$ReactTemplate.$$String[/* sub */3], str, beg, i - beg | 0);
      return /* :: */[
              /* String */Block.__(1, [s]),
              l
            ];
    }
  };
  var push_whitespace = function (beg, i, l) {
    if (beg === i) {
      return l;
    } else {
      return /* :: */[
              /* WhiteSpace */Block.__(0, [i - beg | 0]),
              l
            ];
    }
  };
  var loop = function (beg, _i) {
    while(true) {
      var i = _i;
      if (i < str.length) {
        if (Caml_string.get(str, i) === /* " " */32) {
          return push_token(beg, i, loop_on_whitespace(i + 1 | 0, i + 1 | 0));
        } else {
          _i = i + 1 | 0;
          continue ;
          
        }
      } else {
        return push_token(beg, i, /* [] */0);
      }
    };
  };
  var loop_on_whitespace = function (beg, _i) {
    while(true) {
      var i = _i;
      if (i < str.length) {
        if (Caml_string.get(str, i) !== /* " " */32) {
          return push_whitespace(beg, i, loop(i, i + 1 | 0));
        } else {
          _i = i + 1 | 0;
          continue ;
          
        }
      } else {
        return push_whitespace(beg, i, /* [] */0);
      }
    };
  };
  return loop(0, 0);
}

function raw_analyze_notation_tokens(param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      var x = match[0];
      switch (x) {
        case ".." : 
            return /* :: */[
                    /* NonTerminal */Block.__(1, [Notation_ops$ReactTemplate.ldots_var]),
                    raw_analyze_notation_tokens(param[1])
                  ];
        case "_" : 
            return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("_ must be quoted."));
        default:
          var sl = param[1];
          if (Names$ReactTemplate.Id[/* is_valid */3](x)) {
            return /* :: */[
                    /* NonTerminal */Block.__(1, [Names$ReactTemplate.Id[/* of_string */5](x)]),
                    raw_analyze_notation_tokens(sl)
                  ];
          } else {
            return /* :: */[
                    /* Terminal */Block.__(0, [Curry._1(Util$ReactTemplate.$$String[/* drop_simple_quotes */30], x)]),
                    raw_analyze_notation_tokens(sl)
                  ];
          }
      }
    } else {
      return /* :: */[
              /* Break */Block.__(3, [match[0]]),
              raw_analyze_notation_tokens(param[1])
            ];
    }
  } else {
    return /* [] */0;
  }
}

function decompose_raw_notation(ntn) {
  return raw_analyze_notation_tokens(split_notation_string(ntn));
}

function possible_notations(ntn) {
  var toks = split_notation_string(ntn);
  if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
            if (!param.tag || param[0] !== "_") {
              return /* false */0;
            } else {
              return /* true */1;
            }
          }), toks)) {
    return /* :: */[
            ntn,
            /* [] */0
          ];
  } else {
    var ntn$prime = make_notation_key(raw_analyze_notation_tokens(toks));
    if (ntn === ntn$prime) {
      return /* :: */[
              ntn,
              /* [] */0
            ];
    } else {
      return /* :: */[
              ntn,
              /* :: */[
                ntn$prime,
                /* [] */0
              ]
            ];
    }
  }
}

function browse_notation(strict, ntn, map) {
  var ntns = possible_notations(ntn);
  var l = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* fold */10], (function (scope_name, sc) {
          return Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* fold */10], (function (ntn, param, l) {
                        if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                                  var ntn$prime = ntn;
                                  var ntn$1 = param;
                                  if (Curry._2(Util$ReactTemplate.$$String[/* contains */17], ntn$1, /* " " */32)) {
                                    return +(ntn$1 === ntn$prime);
                                  } else {
                                    var toks = decompose_notation_key(ntn$prime);
                                    var get_terminals = function (param) {
                                      if (param.tag) {
                                        return /* None */0;
                                      } else {
                                        return /* Some */[param[0]];
                                      }
                                    };
                                    var trms = Curry._2(Util$ReactTemplate.List[/* map_filter */62], get_terminals, toks);
                                    if (strict) {
                                      return Curry._2(Util$ReactTemplate.$$String[/* List */40][/* equal */0], /* :: */[
                                                  ntn$1,
                                                  /* [] */0
                                                ], trms);
                                    } else {
                                      return Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem */1], ntn$1, trms);
                                    }
                                  }
                                }), ntns)) {
                          return /* :: */[
                                  /* tuple */[
                                    ntn,
                                    /* tuple */[
                                      scope_name,
                                      param[/* not_interp */0][1],
                                      param[/* not_location */1]
                                    ]
                                  ],
                                  l
                                ];
                        } else {
                          return l;
                        }
                      }), sc[/* notations */0]);
        }), map, /* [] */0);
  return Curry._2(Util$ReactTemplate.List[/* sort */38], (function (x, y) {
                return Curry._2(Util$ReactTemplate.$$String[/* compare */24], x[0], y[0]);
              }), l);
}

function error_notation_not_reference(loc, ntn) {
  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unable to interpret "), Pp$ReactTemplate.quote(Pp$ReactTemplate.str(ntn))), Pp$ReactTemplate.str(" as a reference.")));
}

function interp_notation_as_global_reference(loc, test, ntn, sc) {
  var scopes;
  if (sc) {
    var sc$1 = sc[0];
    var scope = find_scope(find_delimiters_scope(/* None */0, sc$1));
    scopes = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], sc$1, scope, Util$ReactTemplate.$$String[/* Map */39][/* empty */0]);
  } else {
    scopes = scope_map[0];
  }
  var ntns = browse_notation(/* true */1, ntn, scopes);
  var refs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var test$1 = test;
          var param$1 = param;
          var match = param$1[1];
          var c = match[1];
          var sc = match[0];
          var ntn = param$1[0];
          switch (c.tag | 0) {
            case 0 : 
                var ref = c[0];
                if (Curry._1(test$1, ref)) {
                  return /* Some */[/* tuple */[
                            ntn,
                            sc,
                            ref
                          ]];
                } else {
                  return /* None */0;
                }
            case 2 : 
                var match$1 = c[0];
                if (match$1.tag) {
                  return /* None */0;
                } else {
                  var ref$1 = match$1[0];
                  if (Curry._2(Util$ReactTemplate.List[/* for_all */20], isNVar_or_NHole, c[1]) && Curry._1(test$1, ref$1)) {
                    return /* Some */[/* tuple */[
                              ntn,
                              sc,
                              ref$1
                            ]];
                  } else {
                    return /* None */0;
                  }
                }
                break;
            default:
              return /* None */0;
          }
        }), ntns);
  var refs$1 = Option$ReactTemplate.List[/* flatten */1](refs);
  if (refs$1) {
    if (refs$1[1]) {
      var f = function (param) {
        var def = find_default(param[0], scope_stack[0]);
        if (def) {
          return +(param[1] === def[0]);
        } else {
          return /* false */0;
        }
      };
      var match = Curry._2(Util$ReactTemplate.List[/* filter */27], f, refs$1);
      if (match) {
        if (match[1]) {
          var loc$1 = loc;
          return CErrors$ReactTemplate.user_err(loc$1, /* None */0, Pp$ReactTemplate.str("Ambiguous notation."));
        } else {
          return match[0][2];
        }
      } else {
        return error_notation_not_reference(loc, ntn);
      }
    } else {
      return refs$1[0][2];
    }
  } else {
    return error_notation_not_reference(loc, ntn);
  }
}

function locate_notation(prglob, ntn, scope) {
  var ntns = factorize_entries(browse_notation(/* false */0, ntn, scope_map[0]));
  var scopes = Option$ReactTemplate.fold_right(push_scope, scope, scope_stack[0]);
  if (ntns) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation"), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.prlist((function (param) {
                      var scope = find_default(param[0], scopes);
                      return Pp$ReactTemplate.prlist((function (param) {
                                    var sc = param[0];
                                    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_notation_info(prglob, param[2][1], param[1]), sc === default_scope ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str(": ")), Pp$ReactTemplate.str(sc))), Option$ReactTemplate.equal((function (prim, prim$1) {
                                                              return +(prim === prim$1);
                                                            }), /* Some */[sc], scope) ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("(default interpretation)")) : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.fnl(/* () */0)));
                                  }), param[1]);
                    }), ntns));
  } else {
    return Pp$ReactTemplate.str("Unknown notation");
  }
}

function collect_notation_in_scope(scope, sc, known) {
  if (scope === default_scope) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "notation.ml",
            1068,
            2
          ]
        ];
  }
  return Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* fold */10], (function (ntn, param, acc) {
                var known = acc[1];
                if (Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem */1], ntn, known)) {
                  return acc;
                } else {
                  return /* tuple */[
                          /* :: */[
                            /* tuple */[
                              param[/* not_location */1][1],
                              param[/* not_interp */0][1]
                            ],
                            acc[0]
                          ],
                          /* :: */[
                            ntn,
                            known
                          ]
                        ];
                }
              }), sc[/* notations */0], /* tuple */[
              /* [] */0,
              known
            ]);
}

function collect_notations(stack) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
                  var knownntn = acc[1];
                  var all = acc[0];
                  if (param.tag) {
                    var ntn = param[0];
                    if (Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem */1], ntn, knownntn)) {
                      return /* tuple */[
                              all,
                              knownntn
                            ];
                    } else {
                      var match = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], ntn, find_scope(default_scope)[/* notations */0]);
                      var df = match[/* not_location */1][1];
                      var r = match[/* not_interp */0][1];
                      var all$prime;
                      var exit = 0;
                      if (all) {
                        var match$1 = all[0];
                        var s = match$1[0];
                        if (s === default_scope) {
                          all$prime = /* :: */[
                            /* tuple */[
                              s,
                              /* :: */[
                                /* tuple */[
                                  df,
                                  r
                                ],
                                match$1[1]
                              ]
                            ],
                            all[1]
                          ];
                        } else {
                          exit = 1;
                        }
                      } else {
                        exit = 1;
                      }
                      if (exit === 1) {
                        all$prime = /* :: */[
                          /* tuple */[
                            default_scope,
                            /* :: */[
                              /* tuple */[
                                df,
                                r
                              ],
                              /* [] */0
                            ]
                          ],
                          all
                        ];
                      }
                      return /* tuple */[
                              all$prime,
                              /* :: */[
                                ntn,
                                knownntn
                              ]
                            ];
                    }
                  } else {
                    var scope = param[0];
                    if (Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem_assoc */3], scope, all)) {
                      return acc;
                    } else {
                      var match$2 = collect_notation_in_scope(scope, find_scope(scope), knownntn);
                      return /* tuple */[
                              /* :: */[
                                /* tuple */[
                                  scope,
                                  match$2[0]
                                ],
                                all
                              ],
                              match$2[1]
                            ];
                    }
                  }
                }), /* tuple */[
                /* [] */0,
                /* [] */0
              ], stack)[0];
}

function pr_visible_in_scope(prglob, param) {
  var ntns = param[1];
  var scope = param[0];
  var strm = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, strm) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_notation_info(prglob, param[0], param[1]), Pp$ReactTemplate.fnl(/* () */0)), strm);
        }), ntns, Pp$ReactTemplate.mt(/* () */0));
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(scope === default_scope ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Lonely notation"), ntns && !ntns[1] ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.str("s")) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Visible in scope "), Pp$ReactTemplate.str(scope)), Pp$ReactTemplate.fnl(/* () */0)), strm);
}

function pr_scope_stack(prglob, stack) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (strm, scntns) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(strm, pr_visible_in_scope(prglob, scntns)), Pp$ReactTemplate.fnl(/* () */0));
              }), Pp$ReactTemplate.mt(/* () */0), collect_notations(stack));
}

function pr_visibility(prglob, param) {
  if (param) {
    return pr_scope_stack(prglob, /* :: */[
                /* Scope */Block.__(0, [param[0]]),
                scope_stack[0]
              ]);
  } else {
    return pr_scope_stack(prglob, scope_stack[0]);
  }
}

var notation_rules = [Util$ReactTemplate.$$String[/* Map */39][/* empty */0]];

function declare_notation_rule(ntn, extra, unpl, gram) {
  notation_rules[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], ntn, /* tuple */[
        unpl,
        extra,
        gram
      ], notation_rules[0]);
  return /* () */0;
}

function find_notation_printing_rule(ntn) {
  try {
    return Util$ReactTemplate.pi1(Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], ntn, notation_rules[0]));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No printing rule found for "), Pp$ReactTemplate.str(ntn)), Pp$ReactTemplate.str(".")));
    } else {
      throw exn;
    }
  }
}

function find_notation_extra_printing_rules(ntn) {
  try {
    return Util$ReactTemplate.pi2(Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], ntn, notation_rules[0]));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

function find_notation_parsing_rules(ntn) {
  try {
    return Util$ReactTemplate.pi3(Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], ntn, notation_rules[0]));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No parsing rule found for "), Pp$ReactTemplate.str(ntn)), Pp$ReactTemplate.str(".")));
    } else {
      throw exn;
    }
  }
}

function get_defined_notations() {
  return Curry._1(Util$ReactTemplate.$$String[/* Set */38][/* elements */19], Curry._1(Util$ReactTemplate.$$String[/* Map */39][/* domain */27], notation_rules[0]));
}

function add_notation_extra_printing_rule(ntn, k, v) {
  try {
    var match = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], ntn, notation_rules[0]);
    notation_rules[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], ntn, /* tuple */[
          match[0],
          /* :: */[
            /* tuple */[
              k,
              v
            ],
            match[1]
          ],
          match[2]
        ], notation_rules[0]);
    return /* () */0;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["add_notation_extra_printing_rule"], Pp$ReactTemplate.str("No such Notation."));
    } else {
      throw exn;
    }
  }
}

function freeze() {
  return /* tuple */[
          scope_map[0],
          notation_level_map[0],
          scope_stack[0],
          arguments_scope[0],
          delimiters_map[0],
          notations_key_table[0],
          notation_rules[0],
          scope_class_map[0]
        ];
}

function unfreeze(param) {
  scope_map[0] = param[0];
  notation_level_map[0] = param[1];
  scope_stack[0] = param[2];
  delimiters_map[0] = param[4];
  arguments_scope[0] = param[3];
  notations_key_table[0] = param[5];
  notation_rules[0] = param[6];
  scope_class_map[0] = param[7];
  return /* () */0;
}

function init$2() {
  init_scope_map(/* () */0);
  notation_level_map[0] = Util$ReactTemplate.$$String[/* Map */39][/* empty */0];
  delimiters_map[0] = Util$ReactTemplate.$$String[/* Map */39][/* empty */0];
  notations_key_table[0] = KeyMap[/* empty */0];
  notation_rules[0] = Util$ReactTemplate.$$String[/* Map */39][/* empty */0];
  scope_class_map[0] = initial_scope_class_map;
  return /* () */0;
}

Summary$ReactTemplate.declare_summary("symbols", /* record */[
      /* freeze_function */freeze,
      /* unfreeze_function */unfreeze,
      /* init_function */init$2
    ]);

function with_notation_protection(f, x) {
  var fs = freeze(/* false */0);
  try {
    var a = Curry._1(f, x);
    unfreeze(fs);
    return a;
  }
  catch (raw_reraise){
    var reraise = Js_exn.internalToOCamlException(raw_reraise);
    var reraise$1 = CErrors$ReactTemplate.push(reraise);
    unfreeze(fs);
    return Util$ReactTemplate.iraise(reraise$1);
  }
}

var empty_scope_stack = /* [] */0;

var scope_class_compare = Classops$ReactTemplate.cl_typ_ord;

var pr_scope_class = Classops$ReactTemplate.pr_class;

exports.declare_scope = declare_scope;
exports.current_scopes = current_scopes;
exports.level_eq = level_eq;
exports.scope_is_open_in_scopes = scope_is_open_in_scopes;
exports.scope_is_open = scope_is_open;
exports.open_close_scope = open_close_scope;
exports.empty_scope_stack = empty_scope_stack;
exports.push_scope = push_scope;
exports.find_scope = find_scope;
exports.declare_delimiters = declare_delimiters;
exports.remove_delimiters = remove_delimiters;
exports.find_delimiters_scope = find_delimiters_scope;
exports.declare_rawnumeral_interpreter = declare_rawnumeral_interpreter;
exports.declare_numeral_interpreter = declare_numeral_interpreter;
exports.declare_string_interpreter = declare_string_interpreter;
exports.interp_prim_token = interp_prim_token;
exports.interp_prim_token_cases_pattern_expr = interp_prim_token_cases_pattern_expr;
exports.uninterp_prim_token = uninterp_prim_token;
exports.uninterp_prim_token_cases_pattern = uninterp_prim_token_cases_pattern;
exports.uninterp_prim_token_ind_pattern = uninterp_prim_token_ind_pattern;
exports.availability_of_prim_token = availability_of_prim_token;
exports.declare_notation_interpretation = declare_notation_interpretation;
exports.declare_uninterpretation = declare_uninterpretation;
exports.interp_notation = interp_notation;
exports.uninterp_notations = uninterp_notations;
exports.uninterp_cases_pattern_notations = uninterp_cases_pattern_notations;
exports.uninterp_ind_pattern_notations = uninterp_ind_pattern_notations;
exports.availability_of_notation = availability_of_notation;
exports.declare_notation_level = declare_notation_level;
exports.level_of_notation = level_of_notation;
exports.interp_notation_as_global_reference = interp_notation_as_global_reference;
exports.exists_notation_in_scope = exists_notation_in_scope;
exports.declare_arguments_scope = declare_arguments_scope;
exports.find_arguments_scope = find_arguments_scope;
exports.scope_class_compare = scope_class_compare;
exports.subst_scope_class = subst_scope_class;
exports.declare_scope_class = declare_scope_class;
exports.declare_ref_arguments_scope = declare_ref_arguments_scope;
exports.compute_arguments_scope = compute_arguments_scope;
exports.compute_type_scope = compute_type_scope;
exports.current_type_scope_name = current_type_scope_name;
exports.scope_class_of_class = scope_class_of_class;
exports.symbol_eq = symbol_eq;
exports.make_notation_key = make_notation_key;
exports.decompose_notation_key = decompose_notation_key;
exports.decompose_raw_notation = decompose_raw_notation;
exports.pr_scope_class = pr_scope_class;
exports.pr_scope = pr_scope;
exports.pr_scopes = pr_scopes;
exports.locate_notation = locate_notation;
exports.pr_visibility = pr_visibility;
exports.declare_notation_rule = declare_notation_rule;
exports.find_notation_printing_rule = find_notation_printing_rule;
exports.find_notation_extra_printing_rules = find_notation_extra_printing_rules;
exports.find_notation_parsing_rules = find_notation_parsing_rules;
exports.add_notation_extra_printing_rule = add_notation_extra_printing_rule;
exports.get_defined_notations = get_defined_notations;
exports.with_notation_protection = with_notation_protection;
/* inScope Not a pure module */
