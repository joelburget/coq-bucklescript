// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Hook$ReactTemplate = require("./hook.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Miscops$ReactTemplate = require("./miscops.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Constr_matching$ReactTemplate = require("./constr_matching.bs.js");

var print_evar_arguments = [/* false */0];

function add_name(na, b, t, param) {
  return /* tuple */[
          Termops$ReactTemplate.add_name(na, param[0]),
          EConstr$ReactTemplate.push_rel(b ? /* LocalDef */Block.__(1, [
                    na,
                    b[0],
                    t
                  ]) : /* LocalAssum */Block.__(0, [
                    na,
                    t
                  ]), param[1])
        ];
}

function add_name_opt(na, b, t, param) {
  var env = param[1];
  var nenv = param[0];
  if (t) {
    return add_name(na, b, t[0], /* tuple */[
                nenv,
                env
              ]);
  } else {
    return /* tuple */[
            Termops$ReactTemplate.add_name(na, nenv),
            env
          ];
  }
}

function encode_inductive(r) {
  var indsp = Nametab$ReactTemplate.global_inductive(r);
  var constr_lengths = Inductiveops$ReactTemplate.constructors_nrealargs(indsp);
  return /* tuple */[
          indsp,
          constr_lengths
        ];
}

function encode_bool(r) {
  var match = encode_inductive(r);
  if (match[1].length !== 2) {
    CErrors$ReactTemplate.user_err(r[/* loc */1], /* Some */["encode_if"], Pp$ReactTemplate.str("This type has not exactly two constructors."));
  }
  return match[0];
}

function encode_tuple(r) {
  var match = encode_inductive(r);
  if (match[1].length !== 1) {
    CErrors$ReactTemplate.user_err(r[/* loc */1], /* Some */["encode_tuple"], Pp$ReactTemplate.str("This type cannot be seen as a tuple type."));
  }
  return match[0];
}

function PrintingInductiveMake(Test) {
  var encode = Test[/* encode */0];
  var subst = Mod_subst$ReactTemplate.subst_ind;
  var printer = function (ind) {
    return Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* IndRef */Block.__(2, [ind]));
  };
  var key_001 = /* :: */[
    Test[/* field */2],
    /* [] */0
  ];
  var key = /* :: */[
    "Printing",
    key_001
  ];
  var title = Test[/* title */3];
  var member_message = function (x) {
    return Curry._1(Test[/* member_message */1], printer(x));
  };
  return /* module */[
          /* compare */Names$ReactTemplate.ind_ord,
          /* encode */encode,
          /* subst */subst,
          /* printer */printer,
          /* key */key,
          /* title */title,
          /* member_message */member_message,
          /* synchronous : true */1
        ];
}

var subst = Mod_subst$ReactTemplate.subst_ind;

function printer(ind) {
  return Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* IndRef */Block.__(2, [ind]));
}

var key_001 = /* :: */[
  "If",
  /* [] */0
];

var key = /* :: */[
  "Printing",
  key_001
];

function member_message(x) {
  var partial_arg = printer(x);
  return (function (param) {
      var s = partial_arg;
      var b = param;
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cases on elements of "), s), Pp$ReactTemplate.str(b ? " are printed using a `if' form" : " are not printed using a `if' form"));
    });
}

var subst$1 = Mod_subst$ReactTemplate.subst_ind;

function printer$1(ind) {
  return Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* IndRef */Block.__(2, [ind]));
}

var key_001$1 = /* :: */[
  "Let",
  /* [] */0
];

var key$1 = /* :: */[
  "Printing",
  key_001$1
];

function member_message$1(x) {
  var partial_arg = printer$1(x);
  return (function (param) {
      var s = partial_arg;
      var b = param;
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cases on elements of "), s), Pp$ReactTemplate.str(b ? " are printed using a `let' form" : " are not printed using a `let' form"));
    });
}

var PrintingIf = Goptions$ReactTemplate.MakeRefTable([
      Names$ReactTemplate.ind_ord,
      encode_bool,
      subst,
      printer,
      key,
      "Types leading to pretty-printing of Cases using a `if' form:",
      member_message
    ]);

var PrintingLet = Goptions$ReactTemplate.MakeRefTable([
      Names$ReactTemplate.ind_ord,
      encode_tuple,
      subst$1,
      printer$1,
      key$1,
      "Types leading to a pretty-printing of Cases using a `let' form:",
      member_message$1
    ]);

var wildcard_value = [/* true */1];

function force_wildcard() {
  return wildcard_value[0];
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"forced wildcard",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Wildcard",
          /* [] */0
        ]
      ],
      /* optread */force_wildcard,
      /* optwrite */(function (param) {
          wildcard_value[0] = param;
          return /* () */0;
        })
    ]);

var synth_type_value = [/* true */1];

function synthetize_type() {
  return synth_type_value[0];
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"pattern matching return type synthesizability",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Synth",
          /* [] */0
        ]
      ],
      /* optread */synthetize_type,
      /* optwrite */(function (param) {
          synth_type_value[0] = param;
          return /* () */0;
        })
    ]);

var reverse_matching_value = [/* true */1];

function reverse_matching() {
  return reverse_matching_value[0];
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"pattern-matching reversibility",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Matching",
          /* [] */0
        ]
      ],
      /* optread */reverse_matching,
      /* optwrite */(function (param) {
          reverse_matching_value[0] = param;
          return /* () */0;
        })
    ]);

var print_primproj_params_value = [/* false */0];

function print_primproj_params() {
  return print_primproj_params_value[0];
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"printing of primitive projection parameters",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Primitive",
          /* :: */[
            "Projection",
            /* :: */[
              "Parameters",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */print_primproj_params,
      /* optwrite */(function (param) {
          print_primproj_params_value[0] = param;
          return /* () */0;
        })
    ]);

var print_primproj_compatibility_value = [/* false */0];

function print_primproj_compatibility() {
  return print_primproj_compatibility_value[0];
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"backwards-compatible printing of primitive projections",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Primitive",
          /* :: */[
            "Projection",
            /* :: */[
              "Compatibility",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */print_primproj_compatibility,
      /* optwrite */(function (param) {
          print_primproj_compatibility_value[0] = param;
          return /* () */0;
        })
    ]);

function computable(sigma, p, k) {
  var match = EConstr$ReactTemplate.decompose_lam_assum(sigma, p);
  if (Curry._1(Context$ReactTemplate.Rel[/* length */3], match[0]) === (k + 1 | 0)) {
    return EConstr$ReactTemplate.Vars[/* noccur_between */13](sigma, 1, k + 1 | 0, match[1]);
  } else {
    return /* false */0;
  }
}

function lookup_name_as_displayed(env, sigma, t, s) {
  var _avoid = Environ$ReactTemplate.ids_of_named_context_val(Environ$ReactTemplate.named_context_val(env));
  var _n = 1;
  var _c = t;
  while(true) {
    var c = _c;
    var n = _n;
    var avoid = _avoid;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          var c$prime = match[2];
          var match$1 = Namegen$ReactTemplate.compute_displayed_name_in(sigma, /* RenamingForGoal */0, avoid, match[0], c$prime);
          var match$2 = match$1[0];
          if (match$2) {
            if (Names$ReactTemplate.Id[/* equal */0](match$2[0], s)) {
              return /* Some */[n];
            } else {
              _c = c$prime;
              _n = n + 1 | 0;
              _avoid = match$1[1];
              continue ;
              
            }
          } else {
            _c = Termops$ReactTemplate.pop(c$prime);
            _n = n + 1 | 0;
            _avoid = match$1[1];
            continue ;
            
          }
          break;
      case 8 : 
          var c$prime$1 = match[3];
          var match$3 = Namegen$ReactTemplate.compute_displayed_name_in(sigma, /* RenamingForGoal */0, avoid, match[0], c$prime$1);
          var match$4 = match$3[0];
          if (match$4) {
            if (Names$ReactTemplate.Id[/* equal */0](match$4[0], s)) {
              return /* Some */[n];
            } else {
              _c = c$prime$1;
              _n = n + 1 | 0;
              _avoid = match$3[1];
              continue ;
              
            }
          } else {
            _c = Termops$ReactTemplate.pop(c$prime$1);
            _n = n + 1 | 0;
            _avoid = match$3[1];
            continue ;
            
          }
          break;
      default:
        return /* None */0;
    }
  };
}

function lookup_index_as_renamed(_, sigma, t, n) {
  var _n = n;
  var _d = 1;
  var _c = t;
  while(true) {
    var c = _c;
    var d = _d;
    var n$1 = _n;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          var c$prime = match[2];
          var match$1 = Namegen$ReactTemplate.compute_displayed_name_in(sigma, /* RenamingForGoal */0, Names$ReactTemplate.Id[/* Set */9][/* empty */0], match[0], c$prime);
          if (match$1[0]) {
            _c = c$prime;
            _d = d + 1 | 0;
            continue ;
            
          } else if (n$1) {
            if (n$1 === 1) {
              return /* Some */[d];
            } else {
              _c = c$prime;
              _d = d + 1 | 0;
              _n = n$1 - 1 | 0;
              continue ;
              
            }
          } else {
            return /* Some */[d - 1 | 0];
          }
          break;
      case 8 : 
          var c$prime$1 = match[3];
          var match$2 = Namegen$ReactTemplate.compute_displayed_name_in(sigma, /* RenamingForGoal */0, Names$ReactTemplate.Id[/* Set */9][/* empty */0], match[0], c$prime$1);
          if (match$2[0]) {
            _c = c$prime$1;
            _d = d + 1 | 0;
            continue ;
            
          } else if (n$1) {
            if (n$1 === 1) {
              return /* Some */[d];
            } else {
              _c = c$prime$1;
              _d = d + 1 | 0;
              _n = n$1 - 1 | 0;
              continue ;
              
            }
          } else {
            return /* Some */[d - 1 | 0];
          }
          break;
      default:
        if (n$1) {
          return /* None */0;
        } else {
          return /* Some */[d - 1 | 0];
        }
    }
  };
}

var print_factorize_match_patterns = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"factorization of \"match\" patterns in printing",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Factorizable",
          /* :: */[
            "Match",
            /* :: */[
              "Patterns",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */(function () {
          return print_factorize_match_patterns[0];
        }),
      /* optwrite */(function (b) {
          print_factorize_match_patterns[0] = b;
          return /* () */0;
        })
    ]);

var print_allow_match_default_clause = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"possible use of \"match\" default pattern in printing",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Allow",
          /* :: */[
            "Match",
            /* :: */[
              "Default",
              /* :: */[
                "Clause",
                /* [] */0
              ]
            ]
          ]
        ]
      ],
      /* optread */(function () {
          return print_allow_match_default_clause[0];
        }),
      /* optwrite */(function (b) {
          print_allow_match_default_clause[0] = b;
          return /* () */0;
        })
    ]);

function join_eqns(x, _patll, _param) {
  while(true) {
    var param = _param;
    var patll = _patll;
    if (param) {
      var rest = param[1];
      var eqn$prime = param[0];
      var match = eqn$prime[/* v */0];
      if (!Flags$ReactTemplate.raw_print[0] && print_factorize_match_patterns[0] && Curry._3(Util$ReactTemplate.List[/* eq_set */49], Names$ReactTemplate.Id[/* equal */0], x[0], match[0]) && Glob_ops$ReactTemplate.glob_constr_eq(x[1])(match[2])) {
        _param = rest;
        _patll = /* :: */[
          match[1],
          patll
        ];
        continue ;
        
      } else {
        var match$1 = join_eqns(x, patll, rest);
        return /* tuple */[
                match$1[0],
                /* :: */[
                  eqn$prime,
                  match$1[1]
                ]
              ];
      }
    } else {
      return /* tuple */[
              patll,
              /* [] */0
            ];
    }
  };
}

function number_of_patterns(param) {
  return Curry._1(Util$ReactTemplate.List[/* length */0], param[/* v */0][1]);
}

function is_default_candidate(param) {
  return +(param[/* v */0][0] === /* [] */0);
}

function move_more_factorized_default_candidate_to_end(eqn, n, param) {
  if (param) {
    var eqns = param[1];
    var eqn$prime = param[0];
    var match = Util$ReactTemplate.set_temporary_memory(/* () */0);
    if (is_default_candidate(eqn$prime) && Curry._1(match[0], number_of_patterns(eqn$prime)) >= n) {
      var match$1 = move_more_factorized_default_candidate_to_end(eqn$prime, Curry._1(match[1], /* () */0), eqns);
      var eqns$1 = match$1[2];
      var dft = match$1[1];
      if (match$1[0]) {
        return /* tuple */[
                /* false */0,
                dft,
                eqns$1
              ];
      } else {
        return /* tuple */[
                /* false */0,
                dft,
                /* :: */[
                  eqn$prime,
                  eqns$1
                ]
              ];
      }
    } else {
      var match$2 = move_more_factorized_default_candidate_to_end(eqn, n, eqns);
      return /* tuple */[
              match$2[0],
              match$2[1],
              /* :: */[
                eqn$prime,
                match$2[2]
              ]
            ];
    }
  } else {
    return /* tuple */[
            /* true */1,
            /* Some */[eqn],
            /* [] */0
          ];
  }
}

function select_default_clause(param) {
  if (param) {
    var eqns = param[1];
    var eqn = param[0];
    var match = Util$ReactTemplate.set_temporary_memory(/* () */0);
    if (is_default_candidate(eqn) && Curry._1(match[0], number_of_patterns(eqn)) > 1) {
      var match$1 = move_more_factorized_default_candidate_to_end(eqn, Curry._1(match[1], /* () */0), eqns);
      var eqns$1 = match$1[2];
      var dft = match$1[1];
      if (match$1[0]) {
        return /* tuple */[
                dft,
                eqns$1
              ];
      } else {
        return /* tuple */[
                dft,
                /* :: */[
                  eqn,
                  eqns$1
                ]
              ];
      }
    } else {
      var match$2 = select_default_clause(eqns);
      return /* tuple */[
              match$2[0],
              /* :: */[
                eqn,
                match$2[1]
              ]
            ];
    }
  } else {
    return /* tuple */[
            /* None */0,
            /* [] */0
          ];
  }
}

function factorize_eqns(eqns) {
  var aux = function (_found, _param) {
    while(true) {
      var param = _param;
      var found = _found;
      if (param) {
        var match = param[0];
        var match$1 = match[/* v */0];
        var rhs = match$1[2];
        var ids = match$1[0];
        var match$2 = join_eqns(/* tuple */[
              ids,
              rhs
            ], /* :: */[
              match$1[1],
              /* [] */0
            ], param[1]);
        _param = match$2[1];
        _found = /* :: */[
          CAst$ReactTemplate.make(match[/* loc */1], /* tuple */[
                ids,
                match$2[0],
                rhs
              ]),
          found
        ];
        continue ;
        
      } else {
        return found;
      }
    };
  };
  var eqns$1 = aux(/* [] */0, Curry._1(Util$ReactTemplate.List[/* rev */4], eqns));
  var mk_anon = function (patl) {
    return Curry._2(Util$ReactTemplate.List[/* map */10], (function () {
                  return DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0]));
                }), patl);
  };
  if (!Flags$ReactTemplate.raw_print[0] && print_allow_match_default_clause[0] && eqns$1 !== /* [] */0) {
    var match = select_default_clause(eqns$1);
    var match$1 = match[0];
    if (match$1) {
      var match$2 = match$1[0];
      var match$3 = match$2[/* v */0];
      if (match$3[0]) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "detyping.ml",
                338,
                49
              ]
            ];
      } else {
        var match$4 = match$3[1];
        if (match$4) {
          var match$5 = match$4[1];
          if (match$5) {
            var eqns$2 = match[1];
            var gloc = match$2[/* loc */1];
            var rhs = match$3[2];
            var patl = match$4[0];
            if (eqns$2) {
              return Util$ReactTemplate.$at(eqns$2, /* :: */[
                          CAst$ReactTemplate.make(gloc, /* tuple */[
                                /* [] */0,
                                /* :: */[
                                  mk_anon(patl),
                                  /* [] */0
                                ],
                                rhs
                              ]),
                          /* [] */0
                        ]);
            } else {
              return /* :: */[
                      CAst$ReactTemplate.make(gloc, /* tuple */[
                            /* [] */0,
                            /* :: */[
                              patl,
                              /* :: */[
                                mk_anon(match$5[0]),
                                /* [] */0
                              ]
                            ],
                            rhs
                          ]),
                      /* [] */0
                    ];
            }
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "detyping.ml",
                    338,
                    49
                  ]
                ];
          }
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "detyping.ml",
                  338,
                  49
                ]
              ];
        }
      }
    } else {
      return match[1];
    }
  } else {
    return eqns$1;
  }
}

function update_name(sigma, na, param) {
  if (na && force_wildcard(/* () */0) && EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, Curry._3(Util$ReactTemplate.List[/* index */77], Names$ReactTemplate.Name[/* equal */4], na, param[0][1][0]), param[1])) {
    return /* Anonymous */0;
  } else {
    return na;
  }
}

function decomp_branch(_tags, _nal, _b, _e, sigma, _c) {
  while(true) {
    var c = _c;
    var e = _e;
    var b = _b;
    var nal = _nal;
    var tags = _tags;
    var env = e[1];
    var flag = b ? /* RenamingForGoal */0 : /* RenamingForCasesPattern */Block.__(0, [/* tuple */[
            env[0],
            c
          ]]);
    if (tags) {
      var b$1 = tags[0];
      var match = EConstr$ReactTemplate.kind(sigma, Termops$ReactTemplate.strip_outer_cast(sigma, c));
      var match$1;
      var exit = 0;
      switch (match.tag | 0) {
        case 7 : 
            if (b$1 !== 0) {
              exit = 1;
            } else {
              match$1 = /* tuple */[
                match[0],
                match[2],
                Namegen$ReactTemplate.compute_displayed_let_name_in,
                /* None */0,
                /* Some */[match[1]]
              ];
            }
            break;
        case 8 : 
            if (b$1 !== 0) {
              match$1 = /* tuple */[
                match[0],
                match[3],
                Namegen$ReactTemplate.compute_displayed_name_in,
                /* Some */[match[1]],
                /* Some */[match[2]]
              ];
            } else {
              exit = 1;
            }
            break;
        default:
          exit = 1;
      }
      if (exit === 1) {
        match$1 = b$1 !== 0 ? /* tuple */[
            /* Anonymous */0,
            EConstr$ReactTemplate.Vars[/* lift */0](1, c),
            Namegen$ReactTemplate.compute_displayed_name_in,
            /* None */0,
            /* None */0
          ] : /* tuple */[
            /* Name */[Namegen$ReactTemplate.default_dependent_ident],
            EConstr$ReactTemplate.applist(/* tuple */[
                  EConstr$ReactTemplate.Vars[/* lift */0](1, c),
                  /* :: */[
                    EConstr$ReactTemplate.mkRel(1),
                    /* [] */0
                  ]
                ]),
            Namegen$ReactTemplate.compute_displayed_name_in,
            /* None */0,
            /* None */0
          ];
      }
      var c$1 = match$1[1];
      var match$2 = Curry._5(match$1[2], sigma, flag, e[0], match$1[0], c$1);
      var na$prime = match$2[0];
      _c = c$1;
      _e = /* tuple */[
        match$2[1],
        add_name_opt(na$prime, match$1[3], match$1[4], env)
      ];
      _b = b$1;
      _nal = /* :: */[
        na$prime,
        nal
      ];
      _tags = tags[1];
      continue ;
      
    } else {
      return /* tuple */[
              Curry._1(Util$ReactTemplate.List[/* rev */4], nal),
              /* tuple */[
                e,
                c
              ]
            ];
    }
  };
}

function build_tree(na, isgoal, e, sigma, ci, cl) {
  var mkpat = function (n, rhs, pl) {
    var eta_000 = /* tuple */[
      ci[/* ci_ind */0],
      n + 1 | 0
    ];
    var eta_002 = update_name(sigma, na, rhs);
    var eta = /* PatCstr */Block.__(1, [
        eta_000,
        pl,
        eta_002
      ]);
    return DAst$ReactTemplate.make(/* None */0, eta);
  };
  var cnl = ci[/* ci_pp_info */4][/* cstr_tags */1];
  return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* init */46], cl.length, (function (i) {
                    var isgoal$1 = isgoal;
                    var e$1 = e;
                    var sigma$1 = sigma;
                    var param = /* tuple */[
                      Caml_array.caml_array_get(cnl, i),
                      (function (param, param$1) {
                          return mkpat(i, param, param$1);
                        }),
                      Caml_array.caml_array_get(cl, i)
                    ];
                    var mkpat$1 = param[1];
                    var match = decomp_branch(param[0], /* [] */0, isgoal$1, e$1, sigma$1, param[2]);
                    var mat = align_tree(match[0], isgoal$1, match[1], sigma$1);
                    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                  var rhs = param[2];
                                  return /* tuple */[
                                          param[0],
                                          Curry._2(mkpat$1, rhs, param[1]),
                                          rhs
                                        ];
                                }), mat);
                  })));
}

function align_tree(nal, isgoal, rhs, sigma) {
  if (nal) {
    var nal$1 = nal[1];
    var na = nal[0];
    var e = rhs[0];
    var match = EConstr$ReactTemplate.kind(sigma, rhs[1]);
    var exit = 0;
    if (match.tag === 13) {
      var cl = match[3];
      var ci = match[0];
      if (Termops$ReactTemplate.eq_constr(sigma, match[2], EConstr$ReactTemplate.mkRel(Curry._3(Util$ReactTemplate.List[/* index */77], Names$ReactTemplate.Name[/* equal */4], na, e[1][0]))) && cl.length !== 0 && computable(sigma, match[1], Curry._1(Util$ReactTemplate.List[/* length */0], ci[/* ci_pp_info */4][/* ind_tags */0]))) {
        var clauses = build_tree(na, isgoal, e, sigma, ci, cl);
        return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                          var pat = param[1];
                          var ids = param[0];
                          var lines = align_tree(nal$1, isgoal, param[2], sigma);
                          return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                        return /* tuple */[
                                                Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], Names$ReactTemplate.Id[/* Set */9][/* add */3], ids, param[0]),
                                                /* :: */[
                                                  pat,
                                                  param[1]
                                                ],
                                                param[2]
                                              ];
                                      }), lines);
                        }), clauses));
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var na$1 = update_name(sigma, na, rhs);
      var eta = /* PatVar */Block.__(0, [na$1]);
      var pat = DAst$ReactTemplate.make(/* None */0, eta);
      var mat = align_tree(nal$1, isgoal, rhs, sigma);
      return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return /* tuple */[
                            Nameops$ReactTemplate.Name[/* fold_right */10](Names$ReactTemplate.Id[/* Set */9][/* add */3], na$1, param[0]),
                            /* :: */[
                              pat,
                              param[1]
                            ],
                            param[2]
                          ];
                  }), mat);
    }
    
  } else {
    return /* :: */[
            /* tuple */[
              Names$ReactTemplate.Id[/* Set */9][/* empty */0],
              /* [] */0,
              rhs
            ],
            /* [] */0
          ];
  }
}

function is_nondep_branch(sigma, c, l) {
  try {
    var match = EConstr$ReactTemplate.decompose_lam_n_decls(sigma, Curry._1(Util$ReactTemplate.List[/* length */0], l))(c);
    return EConstr$ReactTemplate.Vars[/* noccur_between */13](sigma, 1, Curry._1(Context$ReactTemplate.Rel[/* length */3], match[0]), match[1]);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      return /* false */0;
    } else {
      throw e;
    }
  }
}

function it_destRLambda_or_LetIn_names(l, c) {
  var _l = l;
  var _nal = /* [] */0;
  var _c = c;
  while(true) {
    var c$1 = _c;
    var nal = _nal;
    var l$1 = _l;
    var match = DAst$ReactTemplate.get(c$1);
    var exit = 0;
    if (l$1) {
      switch (match.tag | 0) {
        case 5 : 
            if (l$1[0] !== 0) {
              exit = 1;
            } else {
              _c = match[3];
              _nal = /* :: */[
                match[0],
                nal
              ];
              _l = l$1[1];
              continue ;
              
            }
            break;
        case 7 : 
            if (l$1[0] !== 0) {
              _c = match[3];
              _nal = /* :: */[
                match[0],
                nal
              ];
              _l = l$1[1];
              continue ;
              
            } else {
              exit = 1;
            }
            break;
        default:
          exit = 1;
      }
    } else {
      return /* tuple */[
              Curry._1(Util$ReactTemplate.List[/* rev */4], nal),
              c$1
            ];
    }
    if (exit === 1) {
      if (l$1[0] !== 0) {
        _nal = /* :: */[
          /* Anonymous */0,
          nal
        ];
        _l = l$1[1];
        continue ;
        
      } else {
        var l$2 = Glob_ops$ReactTemplate.free_glob_vars(c$1);
        var x = Namegen$ReactTemplate.next_ident_away(Namegen$ReactTemplate.default_dependent_ident, l$2);
        var eta = /* GVar */Block.__(1, [x]);
        var a = DAst$ReactTemplate.make(/* None */0, eta);
        var match$1 = DAst$ReactTemplate.get(c$1);
        var tmp;
        if (match$1.tag === 4) {
          tmp = DAst$ReactTemplate.make(c$1[/* loc */1], /* GApp */Block.__(4, [
                  match$1[0],
                  Util$ReactTemplate.$at(match$1[1], /* :: */[
                        a,
                        /* [] */0
                      ])
                ]));
        } else {
          var eta_001 = /* :: */[
            a,
            /* [] */0
          ];
          var eta$1 = /* GApp */Block.__(4, [
              c$1,
              eta_001
            ]);
          tmp = DAst$ReactTemplate.make(/* None */0, eta$1);
        }
        _c = tmp;
        _nal = /* :: */[
          /* Name */[x],
          nal
        ];
        _l = l$1[1];
        continue ;
        
      }
    }
    
  };
}

function detype_universe(sigma, u) {
  var fn = function (param) {
    return /* Some */[/* tuple */[
              Termops$ReactTemplate.reference_of_level(sigma, param[0]),
              param[1]
            ]];
  };
  return Curry._2(Univ$ReactTemplate.Universe[/* map */17], fn, u);
}

function detype_sort(sigma, param) {
  if (param.tag) {
    return /* GType */[Flags$ReactTemplate.univ_print[0] ? detype_universe(sigma, param[0]) : /* [] */0];
  } else if (param[0] !== 0) {
    return /* GProp */0;
  } else {
    return /* GSet */1;
  }
}

var detype_anonymous = [(function (_, _$1) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["detype"], Pp$ReactTemplate.str("index to an anonymous variable."));
    })];

function set_detype_anonymous(f) {
  detype_anonymous[0] = f;
  return /* () */0;
}

function detype_instance(sigma, l) {
  var l$1 = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, l);
  if (Univ$ReactTemplate.Instance[/* is_empty */1](l$1)) {
    return /* None */0;
  } else {
    return /* Some */[Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    var sigma$1 = sigma;
                    var l = param;
                    var l$1 = Termops$ReactTemplate.reference_of_level(sigma$1, l);
                    return /* GType */[/* UNamed */[l$1]];
                  }), Util$ReactTemplate.$$Array[/* to_list */9](Univ$ReactTemplate.Instance[/* to_array */3](l$1)))];
  }
}

function detype(d, flags, avoid, env, sigma, t) {
  var d$1 = d;
  var f = detype_r;
  var flags$1 = flags;
  var env$1 = avoid;
  var avoid$1 = env;
  var sigma$1 = sigma;
  var t$1 = t;
  if (d$1 !== 0) {
    return DAst$ReactTemplate.delay(/* None */0, (function () {
                  return Curry._6(f, d$1, flags$1, env$1, avoid$1, sigma$1, t$1);
                }));
  } else {
    return DAst$ReactTemplate.make(/* None */0, Curry._6(f, d$1, flags$1, env$1, avoid$1, sigma$1, t$1));
  }
}

function detype_r(d, flags, avoid, env, sigma, t) {
  var match = EConstr$ReactTemplate.kind(sigma, Termops$ReactTemplate.collapse_appl(sigma, t));
  switch (match.tag | 0) {
    case 0 : 
        var n = match[0];
        try {
          var match$1 = Termops$ReactTemplate.lookup_name_of_rel(n, env[0]);
          if (match$1) {
            return /* GVar */Block.__(1, [match$1[0]]);
          } else {
            return /* GVar */Block.__(1, [Curry._2(detype_anonymous[0], /* None */0, n)]);
          }
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            var s = "_UNBOUND_REL_" + Pervasives.string_of_int(n);
            return /* GVar */Block.__(1, [Names$ReactTemplate.Id[/* of_string */5](s)]);
          } else {
            throw exn;
          }
        }
        break;
    case 1 : 
        var id = match[0];
        try {
          Global$ReactTemplate.lookup_named(id);
          return /* GRef */Block.__(0, [
                    /* VarRef */Block.__(0, [id]),
                    /* None */0
                  ]);
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            return /* GVar */Block.__(1, [id]);
          } else {
            throw exn$1;
          }
        }
        break;
    case 2 : 
        var n$1 = match[0];
        if (n$1 === Constr_matching$ReactTemplate.special_meta) {
          return /* GEvar */Block.__(2, [
                    Names$ReactTemplate.Id[/* of_string_soft */6]("CONTEXT-HOLE"),
                    /* [] */0
                  ]);
        } else {
          return /* GEvar */Block.__(2, [
                    Names$ReactTemplate.Id[/* of_string_soft */6]("M" + Pervasives.string_of_int(n$1)),
                    /* [] */0
                  ]);
        }
    case 3 : 
        var match$2 = match[0];
        var cl = match$2[1];
        var evk = match$2[0];
        var bound_to_itself_or_letin = function (decl, c) {
          if (decl.tag) {
            return /* true */1;
          } else {
            var id = decl[0];
            try {
              var n = Curry._3(Util$ReactTemplate.List[/* index */77], Names$ReactTemplate.Name[/* equal */4], /* Name */[id], env[0]);
              return EConstr$ReactTemplate.isRelN(sigma, n, c);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return EConstr$ReactTemplate.isVarId(sigma, id, c);
              } else {
                throw exn;
              }
            }
          }
        };
        var match$3;
        try {
          var match$4 = Evd$ReactTemplate.evar_ident(evk, sigma);
          var id$1 = match$4 ? match$4[0] : Termops$ReactTemplate.pr_evar_suggested_name(evk, sigma);
          var l = Evd$ReactTemplate.evar_instance_array(bound_to_itself_or_letin, Evd$ReactTemplate.find(sigma, evk), cl);
          var match$5 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                  var rels = param[1];
                  var fvs = param[0];
                  var match = EConstr$ReactTemplate.kind(sigma, param$1[1]);
                  switch (match.tag | 0) {
                    case 0 : 
                        return /* tuple */[
                                fvs,
                                Curry._2(Int$ReactTemplate.$$Set[/* add */3], match[0], rels)
                              ];
                    case 1 : 
                        return /* tuple */[
                                Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], match[0], fvs),
                                rels
                              ];
                    default:
                      return /* tuple */[
                              fvs,
                              rels
                            ];
                  }
                }), /* tuple */[
                Names$ReactTemplate.Id[/* Set */9][/* empty */0],
                Int$ReactTemplate.$$Set[/* empty */0]
              ], l);
          var rels = match$5[1];
          var fvs = match$5[0];
          var l$1 = Evd$ReactTemplate.evar_instance_array((function (d, c) {
                  if (!print_evar_arguments[0] && bound_to_itself_or_letin(d, c)) {
                    return 1 - (EConstr$ReactTemplate.isRel(sigma, c) && Curry._2(Int$ReactTemplate.$$Set[/* mem */2], EConstr$ReactTemplate.destRel(sigma, c), rels) || EConstr$ReactTemplate.isVar(sigma, c) && Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], EConstr$ReactTemplate.destVar(sigma, c), fvs));
                  } else {
                    return /* false */0;
                  }
                }), Evd$ReactTemplate.find(sigma, evk), cl);
          match$3 = /* tuple */[
            id$1,
            l$1
          ];
        }
        catch (exn$2){
          if (exn$2 === Caml_builtin_exceptions.not_found) {
            match$3 = /* tuple */[
              Names$ReactTemplate.Id[/* of_string */5]("X" + Pervasives.string_of_int(Evar$ReactTemplate.repr(evk))),
              Util$ReactTemplate.$$Array[/* map_to_list */44]((function (c) {
                      return /* tuple */[
                              Names$ReactTemplate.Id[/* of_string */5]("__"),
                              c
                            ];
                    }), cl)
            ];
          } else {
            throw exn$2;
          }
        }
        return /* GEvar */Block.__(2, [
                  match$3[0],
                  Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                          return Util$ReactTemplate.on_snd((function (param) {
                                        return detype(d, flags, avoid, env, sigma, param);
                                      }), param);
                        }), match$3[1])
                ]);
    case 4 : 
        return /* GSort */Block.__(12, [detype_sort(sigma, EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]))]);
    case 5 : 
        var k = match[1];
        var c1 = match[0];
        var exit = 0;
        if (k >= 3) {
          if (Flags$ReactTemplate.raw_print[0]) {
            exit = 1;
          } else {
            return DAst$ReactTemplate.get(detype(d, flags, avoid, env, sigma, c1));
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          var d1 = detype(d, flags, avoid, env, sigma, c1);
          var d2 = detype(d, flags, avoid, env, sigma, match[2]);
          var cast = k !== 0 ? /* CastConv */Block.__(0, [d2]) : /* CastVM */Block.__(1, [d2]);
          return /* GCast */Block.__(14, [
                    d1,
                    cast
                  ]);
        }
        break;
    case 6 : 
        return detype_binder(d, flags, /* BProd */0, avoid, env, sigma, match[0], /* None */0, match[1], match[2]);
    case 7 : 
        return detype_binder(d, flags, /* BLambda */1, avoid, env, sigma, match[0], /* None */0, match[1], match[2]);
    case 8 : 
        return detype_binder(d, flags, /* BLetIn */2, avoid, env, sigma, match[0], /* Some */[match[1]], match[2], match[3]);
    case 9 : 
        var f$prime = detype(d, flags, avoid, env, sigma, match[0]);
        var args$prime = Util$ReactTemplate.$$Array[/* map_to_list */44]((function (param) {
                return detype(d, flags, avoid, env, sigma, param);
              }), match[1]);
        var match$6 = DAst$ReactTemplate.get(f$prime);
        if (match$6.tag === 4) {
          return /* GApp */Block.__(4, [
                    match$6[0],
                    Util$ReactTemplate.$at(match$6[1], args$prime)
                  ]);
        } else {
          return /* GApp */Block.__(4, [
                    f$prime,
                    args$prime
                  ]);
        }
    case 10 : 
        var match$7 = match[0];
        return /* GRef */Block.__(0, [
                  /* ConstRef */Block.__(1, [match$7[0]]),
                  detype_instance(sigma, match$7[1])
                ]);
    case 11 : 
        var match$8 = match[0];
        return /* GRef */Block.__(0, [
                  /* IndRef */Block.__(2, [match$8[0]]),
                  detype_instance(sigma, match$8[1])
                ]);
    case 12 : 
        var match$9 = match[0];
        return /* GRef */Block.__(0, [
                  /* ConstructRef */Block.__(3, [match$9[0]]),
                  detype_instance(sigma, match$9[1])
                ]);
    case 13 : 
        var p = match[1];
        var ci = match[0];
        var comp = computable(sigma, p, Curry._1(Util$ReactTemplate.List[/* length */0], ci[/* ci_pp_info */4][/* ind_tags */0]));
        var computable$1 = comp;
        var detype$1 = function (param) {
          return detype(d, flags, avoid, env, sigma, param);
        };
        var detype_eqns$1 = function (param, param$1, param$2) {
          return detype_eqns(d, flags, avoid, env, sigma, ci, comp, param, param$1, param$2);
        };
        var testdep = function (param, param$1) {
          return is_nondep_branch(sigma, param, param$1);
        };
        var data = /* tuple */[
          ci[/* ci_ind */0],
          ci[/* ci_pp_info */4][/* style */2],
          ci[/* ci_pp_info */4][/* cstr_tags */1],
          ci[/* ci_pp_info */4][/* ind_tags */0]
        ];
        var p$1 = p;
        var c = match[2];
        var bl = match[3];
        var constagsl = data[2];
        var st = data[1];
        var indsp = data[0];
        var synth_type = synthetize_type(/* () */0);
        var tomatch = Curry._1(detype$1, c);
        var match$10;
        if (!Flags$ReactTemplate.raw_print[0] && synth_type && computable$1 && bl.length !== 0) {
          match$10 = /* tuple */[
            /* Anonymous */0,
            /* None */0,
            /* None */0
          ];
        } else {
          var p$2 = Curry._1(detype$1, p$1);
          var match$11 = it_destRLambda_or_LetIn_names(data[3], p$2);
          var typ = match$11[1];
          var nl = match$11[0];
          var match$12 = DAst$ReactTemplate.get(typ);
          var match$13;
          match$13 = match$12.tag === 5 ? /* tuple */[
              match$12[0],
              match$12[3]
            ] : /* tuple */[
              /* Anonymous */0,
              typ
            ];
          var partial_arg = Names$ReactTemplate.Name[/* equal */4];
          var aliastyp = Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
                  return partial_arg(/* Anonymous */0, param);
                }), nl) ? /* None */0 : /* Some */[CAst$ReactTemplate.make(/* None */0, /* tuple */[
                    indsp,
                    nl
                  ])];
          match$10 = /* tuple */[
            match$13[0],
            aliastyp,
            /* Some */[match$13[1]]
          ];
        }
        var pred = match$10[2];
        var aliastyp$1 = match$10[1];
        var alias = match$10[0];
        var constructs = Util$ReactTemplate.$$Array[/* init */0](bl.length, (function (i) {
                return /* tuple */[
                        indsp,
                        i + 1 | 0
                      ];
              }));
        var tag;
        try {
          tag = Flags$ReactTemplate.raw_print[0] ? /* RegularStyle */4 : (
              st === /* LetPatternStyle */2 ? st : (
                  Curry._1(PrintingLet[/* active */0], indsp) ? /* LetStyle */0 : (
                      Curry._1(PrintingIf[/* active */0], indsp) ? /* IfStyle */1 : st
                    )
                )
            );
        }
        catch (exn$3){
          if (exn$3 === Caml_builtin_exceptions.not_found) {
            tag = st;
          } else {
            throw exn$3;
          }
        }
        var exit$1 = 0;
        if (tag !== 1) {
          if (tag !== 0) {
            exit$1 = 1;
          } else if (aliastyp$1) {
            exit$1 = 1;
          } else {
            var bl$prime = Util$ReactTemplate.$$Array[/* map */12](detype$1, bl);
            var match$14 = it_destRLambda_or_LetIn_names(Caml_array.caml_array_get(constagsl, 0), Caml_array.caml_array_get(bl$prime, 0));
            return /* GLetTuple */Block.__(9, [
                      match$14[0],
                      /* tuple */[
                        alias,
                        pred
                      ],
                      tomatch,
                      match$14[1]
                    ]);
          }
        } else if (aliastyp$1) {
          exit$1 = 1;
        } else {
          var bl$prime$1 = Util$ReactTemplate.$$Array[/* map */12](detype$1, bl);
          var nondepbrs = Util$ReactTemplate.$$Array[/* map3 */51]((function (param, param$1, param$2) {
                  var test = testdep;
                  var c = param;
                  var b = param$1;
                  var l = param$2;
                  var strip = function (_l, _r) {
                    while(true) {
                      var r = _r;
                      var l = _l;
                      var match = DAst$ReactTemplate.get(r);
                      var exit = 0;
                      if (l) {
                        switch (match.tag | 0) {
                          case 5 : 
                              if (l[0] !== 0) {
                                exit = 1;
                              } else {
                                _r = match[3];
                                _l = l[1];
                                continue ;
                                
                              }
                              break;
                          case 7 : 
                              if (l[0] !== 0) {
                                _r = match[3];
                                _l = l[1];
                                continue ;
                                
                              } else {
                                exit = 1;
                              }
                              break;
                          default:
                            exit = 1;
                        }
                      } else {
                        return r;
                      }
                      if (exit === 1) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "detyping.ml",
                                425,
                                15
                              ]
                            ];
                      }
                      
                    };
                  };
                  if (Curry._2(test, c, l)) {
                    return /* Some */[strip(l, b)];
                  } else {
                    return /* None */0;
                  }
                }), bl, bl$prime$1, constagsl);
          if (Util$ReactTemplate.$$Array[/* for_all */26]((function (param) {
                    return +(/* None */0 !== param);
                  }), nondepbrs)) {
            return /* GIf */Block.__(10, [
                      tomatch,
                      /* tuple */[
                        alias,
                        pred
                      ],
                      Option$ReactTemplate.get(Caml_array.caml_array_get(nondepbrs, 0)),
                      Option$ReactTemplate.get(Caml_array.caml_array_get(nondepbrs, 1))
                    ]);
          } else {
            var eqnl = Curry._3(detype_eqns$1, constructs, constagsl, bl);
            return /* GCases */Block.__(8, [
                      tag,
                      pred,
                      /* :: */[
                        /* tuple */[
                          tomatch,
                          /* tuple */[
                            alias,
                            aliastyp$1
                          ]
                        ],
                        /* [] */0
                      ],
                      eqnl
                    ]);
          }
        }
        if (exit$1 === 1) {
          var eqnl$1 = Curry._3(detype_eqns$1, constructs, constagsl, bl);
          return /* GCases */Block.__(8, [
                    tag,
                    pred,
                    /* :: */[
                      /* tuple */[
                        tomatch,
                        /* tuple */[
                          alias,
                          aliastyp$1
                        ]
                      ],
                      /* [] */0
                    ],
                    eqnl$1
                  ]);
        }
        case 14 : 
        var match$15 = match[0];
        var d$1 = d;
        var flags$1 = flags;
        var avoid$1 = avoid;
        var env$1 = env;
        var sigma$1 = sigma;
        var nvn = match$15[0];
        var param = match$15[1];
        var tys = param[1];
        var match$16 = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (param, na, ty) {
                var avoid = param[0];
                var id = Namegen$ReactTemplate.next_name_away(na, avoid);
                return /* tuple */[
                        Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid),
                        add_name(/* Name */[id], /* None */0, ty, param[1]),
                        /* :: */[
                          id,
                          param[2]
                        ]
                      ];
              }), /* tuple */[
              avoid$1,
              env$1,
              /* [] */0
            ], param[0], tys);
        var def_env = match$16[1];
        var def_avoid = match$16[0];
        var n$2 = tys.length;
        var v = Util$ReactTemplate.$$Array[/* map3 */51]((function (c, t, i) {
                return share_names(d$1, flags$1, i + 1 | 0, /* [] */0, def_avoid, def_env, sigma$1, c, EConstr$ReactTemplate.Vars[/* lift */0](n$2, t));
              }), param[2], tys, nvn[0]);
        return /* GRec */Block.__(11, [
                  /* GFix */Block.__(0, [/* tuple */[
                        Util$ReactTemplate.$$Array[/* map */12]((function (i) {
                                return /* tuple */[
                                        /* Some */[i],
                                        /* GStructRec */0
                                      ];
                              }), nvn[0]),
                        nvn[1]
                      ]]),
                  Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(Util$ReactTemplate.List[/* rev */4], match$16[2])),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return param[0];
                        }), v),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return param[2];
                        }), v),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return param[1];
                        }), v)
                ]);
    case 15 : 
        var match$17 = match[0];
        var d$2 = d;
        var flags$2 = flags;
        var avoid$2 = avoid;
        var env$2 = env;
        var sigma$2 = sigma;
        var n$3 = match$17[0];
        var param$1 = match$17[1];
        var tys$1 = param$1[1];
        var match$18 = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (param, na, ty) {
                var avoid = param[0];
                var id = Namegen$ReactTemplate.next_name_away(na, avoid);
                return /* tuple */[
                        Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid),
                        add_name(/* Name */[id], /* None */0, ty, param[1]),
                        /* :: */[
                          id,
                          param[2]
                        ]
                      ];
              }), /* tuple */[
              avoid$2,
              env$2,
              /* [] */0
            ], param$1[0], tys$1);
        var def_env$1 = match$18[1];
        var def_avoid$1 = match$18[0];
        var ntys = tys$1.length;
        var v$1 = Util$ReactTemplate.$$Array[/* map2 */49]((function (c, t) {
                return share_names(d$2, flags$2, 0, /* [] */0, def_avoid$1, def_env$1, sigma$2, c, EConstr$ReactTemplate.Vars[/* lift */0](ntys, t));
              }), param$1[2], tys$1);
        return /* GRec */Block.__(11, [
                  /* GCoFix */Block.__(1, [n$3]),
                  Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(Util$ReactTemplate.List[/* rev */4], match$18[2])),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return param[0];
                        }), v$1),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return param[2];
                        }), v$1),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return param[1];
                        }), v$1)
                ]);
    case 16 : 
        var c$1 = match[1];
        var p$3 = match[0];
        var noparams = function () {
          return /* GProj */Block.__(15, [
                    p$3,
                    detype(d, flags, avoid, env, sigma, c$1)
                  ]);
        };
        if (flags[0] || Flags$ReactTemplate.in_debugger[0] || Flags$ReactTemplate.in_toplevel[0]) {
          try {
            return noparams(/* () */0);
          }
          catch (exn$4){
            var eta_000 = /* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](p$3)]);
            var eta = /* GRef */Block.__(0, [
                eta_000,
                /* None */0
              ]);
            return /* GApp */Block.__(4, [
                      DAst$ReactTemplate.make(/* None */0, eta),
                      /* :: */[
                        detype(d, flags, avoid, env, sigma, c$1),
                        /* [] */0
                      ]
                    ]);
          }
        } else if (print_primproj_compatibility_value[0] && Names$ReactTemplate.Projection[/* unfolded */3](p$3)) {
          var c$prime;
          try {
            var pb = Environ$ReactTemplate.lookup_projection(p$3, env[1]);
            var body = pb[/* proj_body */5];
            var ty = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env[1], sigma, c$1);
            var match$19 = Inductiveops$ReactTemplate.find_mrectype(env[1], sigma, ty);
            var body$prime = Term$ReactTemplate.strip_lam_assum(body);
            var u = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$19[0][1]);
            var body$prime$1 = Vars$ReactTemplate.subst_instance_constr(u, body$prime);
            var body$prime$2 = EConstr$ReactTemplate.of_constr(body$prime$1);
            c$prime = EConstr$ReactTemplate.Vars[/* substl */3](/* :: */[
                  c$1,
                  Curry._1(Util$ReactTemplate.List[/* rev */4], match$19[1])
                ], body$prime$2);
          }
          catch (raw_exn){
            var exn$5 = Js_exn.internalToOCamlException(raw_exn);
            if (exn$5[0] === Retyping$ReactTemplate.RetypeError) {
              c$prime = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot detype an unfolded primitive projection."));
            } else if (exn$5 === Caml_builtin_exceptions.not_found) {
              c$prime = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot detype an unfolded primitive projection."));
            } else {
              throw exn$5;
            }
          }
          return DAst$ReactTemplate.get(detype(d, flags, avoid, env, sigma, c$prime));
        } else if (print_primproj_params_value[0]) {
          try {
            var c$2 = Retyping$ReactTemplate.expand_projection(env[1], sigma, p$3, c$1, /* [] */0);
            return DAst$ReactTemplate.get(detype(d, flags, avoid, env, sigma, c$2));
          }
          catch (raw_exn$1){
            var exn$6 = Js_exn.internalToOCamlException(raw_exn$1);
            if (exn$6[0] === Retyping$ReactTemplate.RetypeError) {
              return noparams(/* () */0);
            } else {
              throw exn$6;
            }
          }
        } else {
          return noparams(/* () */0);
        }
        break;
    
  }
}

function share_names(d, flags, _n, _l, _avoid, _env, sigma, _c, _t) {
  while(true) {
    var t = _t;
    var c = _c;
    var env = _env;
    var avoid = _avoid;
    var l = _l;
    var n = _n;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    var match$1 = EConstr$ReactTemplate.kind(sigma, t);
    var exit = 0;
    var exit$1 = 0;
    switch (match.tag | 0) {
      case 7 : 
          var t$1 = match[1];
          var na = match[0];
          switch (match$1.tag | 0) {
            case 6 : 
                var na$prime = match$1[0];
                var na$1 = na || !na$prime ? na : na$prime;
                var t$prime = detype(d, flags, avoid, env, sigma, t$1);
                var id = Namegen$ReactTemplate.next_name_away(na$1, avoid);
                var avoid$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid);
                var env$1 = add_name(/* Name */[id], /* None */0, t$1, env);
                _t = match$1[2];
                _c = match[2];
                _env = env$1;
                _avoid = avoid$1;
                _l = /* :: */[
                  /* tuple */[
                    /* Name */[id],
                    /* Explicit */0,
                    /* None */0,
                    t$prime
                  ],
                  l
                ];
                _n = n - 1 | 0;
                continue ;
                case 8 : 
                exit$1 = 2;
                break;
            default:
              exit = 1;
          }
          break;
      case 8 : 
          if (n > 0) {
            var t$prime$1 = match[2];
            var b = match[1];
            var t$prime$prime = detype(d, flags, avoid, env, sigma, t$prime$1);
            var b$prime = detype(d, flags, avoid, env, sigma, b);
            var id$1 = Namegen$ReactTemplate.next_name_away(match[0], avoid);
            var avoid$2 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id$1, avoid);
            var env$2 = add_name(/* Name */[id$1], /* Some */[b], t$prime$1, env);
            _t = EConstr$ReactTemplate.Vars[/* lift */0](1, t);
            _c = match[3];
            _env = env$2;
            _avoid = avoid$2;
            _l = /* :: */[
              /* tuple */[
                /* Name */[id$1],
                /* Explicit */0,
                /* Some */[b$prime],
                t$prime$prime
              ],
              l
            ];
            continue ;
            
          } else {
            exit$1 = 2;
          }
          break;
      default:
        exit$1 = 2;
    }
    if (exit$1 === 2) {
      switch (match$1.tag | 0) {
        case 6 : 
            if (n > 0) {
              var t$prime$2 = match$1[1];
              var t$prime$prime$1 = detype(d, flags, avoid, env, sigma, t$prime$2);
              var id$2 = Namegen$ReactTemplate.next_name_away(match$1[0], avoid);
              var avoid$3 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id$2, avoid);
              var env$3 = add_name(/* Name */[id$2], /* None */0, t$prime$2, env);
              var appc = EConstr$ReactTemplate.mkApp(/* tuple */[
                    EConstr$ReactTemplate.Vars[/* lift */0](1, c),
                    /* array */[EConstr$ReactTemplate.mkRel(1)]
                  ]);
              _t = match$1[2];
              _c = appc;
              _env = env$3;
              _avoid = avoid$3;
              _l = /* :: */[
                /* tuple */[
                  /* Name */[id$2],
                  /* Explicit */0,
                  /* None */0,
                  t$prime$prime$1
                ],
                l
              ];
              _n = n - 1 | 0;
              continue ;
              
            } else {
              exit = 1;
            }
            break;
        case 8 : 
            if (n > 0) {
              _t = EConstr$ReactTemplate.Vars[/* subst1 */4](match$1[1], match$1[3]);
              continue ;
              
            } else {
              exit = 1;
            }
            break;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      if (n > 0) {
        Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.strbrk("Detyping.detype: cannot factorize fix enough"));
      }
      var c$1 = detype(d, flags, avoid, env, sigma, c);
      var t$2 = detype(d, flags, avoid, env, sigma, t);
      return /* tuple */[
              Curry._1(Util$ReactTemplate.List[/* rev */4], l),
              c$1,
              t$2
            ];
    }
    
  };
}

function detype_eqns(d, flags, avoid, env, sigma, ci, _, constructs, consnargsl, bl) {
  try {
    if (Flags$ReactTemplate.raw_print[0] || !reverse_matching_value[0]) {
      throw Pervasives.Exit;
    }
    var mat = build_tree(/* Anonymous */0, flags[1], /* tuple */[
          avoid,
          env
        ], sigma, ci, bl);
    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  var match = param[2];
                  var match$1 = match[0];
                  return CAst$ReactTemplate.make(/* None */0, /* tuple */[
                              Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], param[0]),
                              /* :: */[
                                param[1],
                                /* [] */0
                              ],
                              detype(d, flags, match$1[0], match$1[1], sigma, match[1])
                            ]);
                }), mat);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      return Util$ReactTemplate.$$Array[/* to_list */9](Util$ReactTemplate.$$Array[/* map3 */51]((function (param, param$1, param$2) {
                        var d$1 = d;
                        var flags$1 = flags;
                        var avoid$1 = avoid;
                        var env$1 = env;
                        var sigma$1 = sigma;
                        var constr = param;
                        var construct_nargs = param$1;
                        var branch = param$2;
                        var isgoal = flags$1[1];
                        var make_pat = function (x, avoid, env, b, body, ty, ids) {
                          if (force_wildcard(/* () */0) && EConstr$ReactTemplate.Vars[/* noccurn */12](sigma$1, 1, b)) {
                            return /* tuple */[
                                    DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0])),
                                    avoid,
                                    add_name(/* Anonymous */0, body, ty, env),
                                    ids
                                  ];
                          } else {
                            var flag = isgoal ? /* RenamingForGoal */0 : /* RenamingForCasesPattern */Block.__(0, [/* tuple */[
                                    env[0],
                                    b
                                  ]]);
                            var match = Namegen$ReactTemplate.compute_displayed_name_in(sigma$1, flag, avoid, x, b);
                            var na = match[0];
                            return /* tuple */[
                                    DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [na])),
                                    match[1],
                                    add_name(na, body, ty, env),
                                    Termops$ReactTemplate.add_vname(ids, na)
                                  ];
                          }
                        };
                        var _ids = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
                        var _patlist = /* [] */0;
                        var _avoid = avoid$1;
                        var _env = env$1;
                        var _l = construct_nargs;
                        var _b = branch;
                        while(true) {
                          var b = _b;
                          var l = _l;
                          var env$2 = _env;
                          var avoid$2 = _avoid;
                          var patlist = _patlist;
                          var ids = _ids;
                          var match = EConstr$ReactTemplate.kind(sigma$1, b);
                          var exit = 0;
                          if (l) {
                            switch (match.tag | 0) {
                              case 5 : 
                                  _b = match[0];
                                  continue ;
                                  case 7 : 
                                  if (l[0] !== 0) {
                                    exit = 1;
                                  } else {
                                    var b$1 = match[2];
                                    var match$1 = make_pat(match[0], avoid$2, env$2, b$1, /* None */0, match[1], ids);
                                    _b = b$1;
                                    _l = l[1];
                                    _env = match$1[2];
                                    _avoid = match$1[1];
                                    _patlist = /* :: */[
                                      match$1[0],
                                      patlist
                                    ];
                                    _ids = match$1[3];
                                    continue ;
                                    
                                  }
                                  break;
                              case 8 : 
                                  if (l[0] !== 0) {
                                    var b$prime = match[3];
                                    var match$2 = make_pat(match[0], avoid$2, env$2, b$prime, /* Some */[match[1]], match[2], ids);
                                    _b = b$prime;
                                    _l = l[1];
                                    _env = match$2[2];
                                    _avoid = match$2[1];
                                    _patlist = /* :: */[
                                      match$2[0],
                                      patlist
                                    ];
                                    _ids = match$2[3];
                                    continue ;
                                    
                                  } else {
                                    exit = 1;
                                  }
                                  break;
                              default:
                                exit = 1;
                            }
                          } else {
                            var eta_001 = Curry._1(Util$ReactTemplate.List[/* rev */4], patlist);
                            var eta = /* PatCstr */Block.__(1, [
                                constr,
                                eta_001,
                                /* Anonymous */0
                              ]);
                            var eta_000 = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], ids);
                            var eta_001$1 = /* :: */[
                              DAst$ReactTemplate.make(/* None */0, eta),
                              /* [] */0
                            ];
                            var eta_002 = detype(d$1, flags$1, avoid$2, env$2, sigma$1, b);
                            var eta$1 = /* tuple */[
                              eta_000,
                              eta_001$1,
                              eta_002
                            ];
                            return CAst$ReactTemplate.make(/* None */0, eta$1);
                          }
                          if (exit === 1) {
                            if (l[0] !== 0) {
                              var pat = DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0]));
                              _l = l[1];
                              _patlist = /* :: */[
                                pat,
                                patlist
                              ];
                              continue ;
                              
                            } else {
                              var new_b = EConstr$ReactTemplate.applist(/* tuple */[
                                    EConstr$ReactTemplate.Vars[/* lift */0](1, b),
                                    /* :: */[
                                      EConstr$ReactTemplate.mkRel(1),
                                      /* [] */0
                                    ]
                                  ]);
                              var match$3 = make_pat(/* Anonymous */0, avoid$2, env$2, new_b, /* None */0, EConstr$ReactTemplate.mkProp, ids);
                              _b = new_b;
                              _l = l[1];
                              _env = match$3[2];
                              _avoid = match$3[1];
                              _patlist = /* :: */[
                                match$3[0],
                                patlist
                              ];
                              _ids = match$3[3];
                              continue ;
                              
                            }
                          }
                          
                        };
                      }), constructs, consnargsl, bl));
    } else {
      throw e;
    }
  }
}

function detype_binder(d, flags, bk, avoid, env, sigma, na, body, ty, c) {
  var lax = flags[0];
  var flag = flags[1] ? /* RenamingForGoal */0 : /* RenamingElsewhereFor */Block.__(1, [/* tuple */[
          env[0],
          c
        ]]);
  var match = bk >= 2 ? Namegen$ReactTemplate.compute_displayed_let_name_in(sigma, flag, avoid, na, c) : Namegen$ReactTemplate.compute_displayed_name_in(sigma, flag, avoid, na, c);
  var na$prime = match[0];
  var r = detype(d, flags, match[1], add_name(na$prime, body, ty, env), sigma, c);
  switch (bk) {
    case 0 : 
        return /* GProd */Block.__(6, [
                  na$prime,
                  /* Explicit */0,
                  detype(d, /* tuple */[
                        lax,
                        /* false */0
                      ], avoid, env, sigma, ty),
                  r
                ]);
    case 1 : 
        return /* GLambda */Block.__(5, [
                  na$prime,
                  /* Explicit */0,
                  detype(d, /* tuple */[
                        lax,
                        /* false */0
                      ], avoid, env, sigma, ty),
                  r
                ]);
    case 2 : 
        var c$1 = detype(d, /* tuple */[
              lax,
              /* false */0
            ], avoid, env, sigma, Option$ReactTemplate.get(body));
        var s;
        try {
          s = Retyping$ReactTemplate.get_sort_family_of(/* None */0, /* None */0, env[1], sigma, ty);
        }
        catch (exn){
          if (Flags$ReactTemplate.in_debugger[0] || Flags$ReactTemplate.in_toplevel[0]) {
            s = /* InType */2;
          } else {
            throw exn;
          }
        }
        var t = s !== /* InProp */0 && !Flags$ReactTemplate.raw_print[0] ? /* None */0 : /* Some */[detype(d, /* tuple */[
                  lax,
                  /* false */0
                ], avoid, env, sigma, ty)];
        return /* GLetIn */Block.__(7, [
                  na$prime,
                  c$1,
                  t,
                  r
                ]);
    
  }
}

function detype_names(isgoal, avoid, nenv, env, sigma, t) {
  return detype(/* Now */0, /* tuple */[
              /* false */0,
              isgoal
            ], avoid, /* tuple */[
              nenv,
              env
            ], sigma, t);
}

function detype$1(d, $staropt$star, isgoal, avoid, env, sigma, t) {
  var lax = $staropt$star ? $staropt$star[0] : /* false */0;
  return detype(d, /* tuple */[
              lax,
              isgoal
            ], avoid, /* tuple */[
              Termops$ReactTemplate.names_of_rel_context(env),
              env
            ], sigma, t);
}

function detype_rel_context(d, lax, where, avoid, env, sigma, sign) {
  var d$1 = d;
  var $staropt$star = lax;
  var where$1 = where;
  var avoid$1 = avoid;
  var env$1 = env;
  var sigma$1 = sigma;
  var sign$1 = sign;
  var lax$1 = $staropt$star ? $staropt$star[0] : /* false */0;
  var where$2 = Option$ReactTemplate.map((function (c) {
          return EConstr$ReactTemplate.it_mkLambda_or_LetIn(c, sign$1);
        }), where$1);
  var aux = function (avoid, env, param) {
    if (param) {
      var decl = param[0];
      var na = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
      var t = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl);
      var match;
      if (where$2) {
        var c = where$2[0];
        match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_def */6], decl) ? Namegen$ReactTemplate.compute_displayed_let_name_in(sigma$1, /* RenamingElsewhereFor */Block.__(1, [/* tuple */[
                    env[0],
                    c
                  ]]), avoid, na, c) : Namegen$ReactTemplate.compute_displayed_name_in(sigma$1, /* RenamingElsewhereFor */Block.__(1, [/* tuple */[
                    env[0],
                    c
                  ]]), avoid, na, c);
      } else {
        match = /* tuple */[
          na,
          avoid
        ];
      }
      var na$prime = match[0];
      var b;
      b = decl.tag ? /* Some */[decl[1]] : /* None */0;
      var partial_arg = /* tuple */[
        lax$1,
        /* false */0
      ];
      var b$prime = Option$ReactTemplate.map((function (param) {
              return detype(d$1, partial_arg, avoid, env, sigma$1, param);
            }), b);
      var t$prime = detype(d$1, /* tuple */[
            lax$1,
            /* false */0
          ], avoid, env, sigma$1, t);
      return /* :: */[
              /* tuple */[
                na$prime,
                /* Explicit */0,
                b$prime,
                t$prime
              ],
              aux(match[1], add_name(na$prime, b, t, env), param[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  return aux(avoid$1, env$1, Curry._1(Util$ReactTemplate.List[/* rev */4], sign$1));
}

function detype_closed_glob(lax, isgoal, avoid, env, sigma, t) {
  var convert_id = function (cl, id) {
    try {
      return Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, cl[/* idents */0]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return id;
      } else {
        throw exn;
      }
    }
  };
  var convert_name = function (cl, param) {
    if (param) {
      return /* Name */[convert_id(cl, param[0])];
    } else {
      return /* Anonymous */0;
    }
  };
  var detype_closed_glob$1 = function (cl, cg) {
    return DAst$ReactTemplate.map((function (c) {
                  switch (c.tag | 0) {
                    case 1 : 
                        var id = c[0];
                        try {
                          return /* GVar */Block.__(1, [Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, cl[/* idents */0])]);
                        }
                        catch (exn){
                          if (exn === Caml_builtin_exceptions.not_found) {
                            try {
                              var match = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, cl[/* typed */1]);
                              var assums = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
                                      return /* LocalAssum */Block.__(0, [
                                                /* Name */[id],
                                                EConstr$ReactTemplate.mkProp
                                              ]);
                                    }), match[0]);
                              var env$1 = EConstr$ReactTemplate.push_rel_context(assums, env);
                              return DAst$ReactTemplate.get(detype$1(/* Now */0, lax, isgoal, avoid, env$1, sigma, match[1]));
                            }
                            catch (exn$1){
                              if (exn$1 === Caml_builtin_exceptions.not_found) {
                                try {
                                  var match$1 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, cl[/* untyped */2]);
                                  return DAst$ReactTemplate.get(detype_closed_glob$1(match$1[/* closure */0], match$1[/* term */1]));
                                }
                                catch (exn$2){
                                  if (exn$2 === Caml_builtin_exceptions.not_found) {
                                    return /* GVar */Block.__(1, [id]);
                                  } else {
                                    throw exn$2;
                                  }
                                }
                              } else {
                                throw exn$1;
                              }
                            }
                          } else {
                            throw exn;
                          }
                        }
                        break;
                    case 5 : 
                        var id$1 = convert_name(cl, c[0]);
                        return /* GLambda */Block.__(5, [
                                  id$1,
                                  c[1],
                                  detype_closed_glob$1(cl, c[2]),
                                  detype_closed_glob$1(cl, c[3])
                                ]);
                    case 6 : 
                        var id$2 = convert_name(cl, c[0]);
                        return /* GProd */Block.__(6, [
                                  id$2,
                                  c[1],
                                  detype_closed_glob$1(cl, c[2]),
                                  detype_closed_glob$1(cl, c[3])
                                ]);
                    case 7 : 
                        var id$3 = convert_name(cl, c[0]);
                        return /* GLetIn */Block.__(7, [
                                  id$3,
                                  detype_closed_glob$1(cl, c[1]),
                                  Option$ReactTemplate.map((function (param) {
                                          return detype_closed_glob$1(cl, param);
                                        }), c[2]),
                                  detype_closed_glob$1(cl, c[3])
                                ]);
                    case 8 : 
                        var match$2 = Glob_ops$ReactTemplate.map_pattern_binders((function (na) {
                                return convert_name(cl, na);
                              }), c[2], c[3]);
                        var match$3 = Glob_ops$ReactTemplate.map_pattern((function (c) {
                                return detype_closed_glob$1(cl, c);
                              }), match$2[0], match$2[1]);
                        return /* GCases */Block.__(8, [
                                  c[0],
                                  c[1],
                                  match$3[0],
                                  match$3[1]
                                ]);
                    case 9 : 
                        var match$4 = c[1];
                        var ids = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                return convert_name(cl, param);
                              }), c[0]);
                        var n = convert_name(cl, match$4[0]);
                        return /* GLetTuple */Block.__(9, [
                                  ids,
                                  /* tuple */[
                                    n,
                                    match$4[1]
                                  ],
                                  detype_closed_glob$1(cl, c[2]),
                                  detype_closed_glob$1(cl, c[3])
                                ]);
                    default:
                      return DAst$ReactTemplate.get(Glob_ops$ReactTemplate.map_glob_constr((function (param) {
                                          return detype_closed_glob$1(cl, param);
                                        }))(cg));
                  }
                }), cg);
  };
  return detype_closed_glob$1(t[/* closure */0], t[/* term */1]);
}

function subst_cases_pattern(subst) {
  return (function (param) {
      return DAst$ReactTemplate.map((function (pat) {
                    if (pat.tag) {
                      var cpl = pat[1];
                      var match = pat[0];
                      var match$1 = match[0];
                      var kn = match$1[0];
                      var kn$prime = Mod_subst$ReactTemplate.subst_mind(subst, kn);
                      var cpl$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], subst_cases_pattern(subst), cpl);
                      if (kn$prime === kn && cpl$prime === cpl) {
                        return pat;
                      } else {
                        return /* PatCstr */Block.__(1, [
                                  /* tuple */[
                                    /* tuple */[
                                      kn$prime,
                                      match$1[1]
                                    ],
                                    match[1]
                                  ],
                                  cpl$prime,
                                  pat[2]
                                ]);
                      }
                    } else {
                      return pat;
                    }
                  }), param);
    });
}

var match = Hook$ReactTemplate.make(/* None */0, /* () */0);

var f_subst_genarg = match[0];

function subst_glob_constr(subst) {
  return (function (param) {
      return DAst$ReactTemplate.map((function (raw) {
                    switch (raw.tag | 0) {
                      case 0 : 
                          var ref = raw[0];
                          var match = Globnames$ReactTemplate.subst_global(subst, ref);
                          if (match[0] === ref) {
                            return raw;
                          } else {
                            return DAst$ReactTemplate.get(detype$1(/* Now */0, /* None */0, /* false */0, Names$ReactTemplate.Id[/* Set */9][/* empty */0], Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(match[1])));
                          }
                      case 4 : 
                          var rl = raw[1];
                          var r = raw[0];
                          var r$prime = subst_glob_constr(subst)(r);
                          var rl$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], subst_glob_constr(subst), rl);
                          if (r$prime === r && rl$prime === rl) {
                            return raw;
                          } else {
                            return /* GApp */Block.__(4, [
                                      r$prime,
                                      rl$prime
                                    ]);
                          }
                      case 5 : 
                          var r2 = raw[3];
                          var r1 = raw[2];
                          var r1$prime = subst_glob_constr(subst)(r1);
                          var r2$prime = subst_glob_constr(subst)(r2);
                          if (r1$prime === r1 && r2$prime === r2) {
                            return raw;
                          } else {
                            return /* GLambda */Block.__(5, [
                                      raw[0],
                                      raw[1],
                                      r1$prime,
                                      r2$prime
                                    ]);
                          }
                      case 6 : 
                          var r2$1 = raw[3];
                          var r1$1 = raw[2];
                          var r1$prime$1 = subst_glob_constr(subst)(r1$1);
                          var r2$prime$1 = subst_glob_constr(subst)(r2$1);
                          if (r1$prime$1 === r1$1 && r2$prime$1 === r2$1) {
                            return raw;
                          } else {
                            return /* GProd */Block.__(6, [
                                      raw[0],
                                      raw[1],
                                      r1$prime$1,
                                      r2$prime$1
                                    ]);
                          }
                      case 7 : 
                          var r2$2 = raw[3];
                          var t = raw[2];
                          var r1$2 = raw[1];
                          var r1$prime$2 = subst_glob_constr(subst)(r1$2);
                          var r2$prime$2 = subst_glob_constr(subst)(r2$2);
                          var t$prime = Option$ReactTemplate.smartmap(subst_glob_constr(subst), t);
                          if (r1$prime$2 === r1$2 && t === t$prime && r2$prime$2 === r2$2) {
                            return raw;
                          } else {
                            return /* GLetIn */Block.__(7, [
                                      raw[0],
                                      r1$prime$2,
                                      t$prime,
                                      r2$prime$2
                                    ]);
                          }
                      case 8 : 
                          var branches = raw[3];
                          var rl$1 = raw[2];
                          var rtno = raw[1];
                          var rtno$prime = Option$ReactTemplate.smartmap(subst_glob_constr(subst), rtno);
                          var rl$prime$1 = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (y) {
                                  var x = y[1];
                                  var a = y[0];
                                  var a$prime = subst_glob_constr(subst)(a);
                                  var topt = x[1];
                                  var topt$prime = Option$ReactTemplate.smartmap((function (t) {
                                          var match = t[/* v */0];
                                          var match$1 = match[0];
                                          var sp = match$1[0];
                                          var sp$prime = Mod_subst$ReactTemplate.subst_mind(subst, sp);
                                          if (sp === sp$prime) {
                                            return t;
                                          } else {
                                            return CAst$ReactTemplate.make(t[/* loc */1], /* tuple */[
                                                        /* tuple */[
                                                          sp$prime,
                                                          match$1[1]
                                                        ],
                                                        match[1]
                                                      ]);
                                          }
                                        }), topt);
                                  if (a === a$prime && topt === topt$prime) {
                                    return y;
                                  } else {
                                    return /* tuple */[
                                            a$prime,
                                            /* tuple */[
                                              x[0],
                                              topt$prime
                                            ]
                                          ];
                                  }
                                }), rl$1);
                          var branches$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (branch) {
                                  var match = branch[/* v */0];
                                  var r = match[2];
                                  var cpl = match[1];
                                  var cpl$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], subst_cases_pattern(subst), cpl);
                                  var r$prime = subst_glob_constr(subst)(r);
                                  if (cpl$prime === cpl && r$prime === r) {
                                    return branch;
                                  } else {
                                    return CAst$ReactTemplate.make(branch[/* loc */1], /* tuple */[
                                                match[0],
                                                cpl$prime,
                                                r$prime
                                              ]);
                                  }
                                }), branches);
                          if (rtno$prime === rtno && rl$prime$1 === rl$1 && branches$prime === branches) {
                            return raw;
                          } else {
                            return /* GCases */Block.__(8, [
                                      raw[0],
                                      rtno$prime,
                                      rl$prime$1,
                                      branches$prime
                                    ]);
                          }
                      case 9 : 
                          var c = raw[3];
                          var b = raw[2];
                          var match$1 = raw[1];
                          var po = match$1[1];
                          var po$prime = Option$ReactTemplate.smartmap(subst_glob_constr(subst), po);
                          var b$prime = subst_glob_constr(subst)(b);
                          var c$prime = subst_glob_constr(subst)(c);
                          if (po$prime === po && b$prime === b && c$prime === c) {
                            return raw;
                          } else {
                            return /* GLetTuple */Block.__(9, [
                                      raw[0],
                                      /* tuple */[
                                        match$1[0],
                                        po$prime
                                      ],
                                      b$prime,
                                      c$prime
                                    ]);
                          }
                      case 10 : 
                          var b2 = raw[3];
                          var b1 = raw[2];
                          var match$2 = raw[1];
                          var po$1 = match$2[1];
                          var c$1 = raw[0];
                          var po$prime$1 = Option$ReactTemplate.smartmap(subst_glob_constr(subst), po$1);
                          var b1$prime = subst_glob_constr(subst)(b1);
                          var b2$prime = subst_glob_constr(subst)(b2);
                          var c$prime$1 = subst_glob_constr(subst)(c$1);
                          if (c$prime$1 === c$1 && po$prime$1 === po$1 && b1$prime === b1 && b2$prime === b2) {
                            return raw;
                          } else {
                            return /* GIf */Block.__(10, [
                                      c$prime$1,
                                      /* tuple */[
                                        match$2[0],
                                        po$prime$1
                                      ],
                                      b1$prime,
                                      b2$prime
                                    ]);
                          }
                      case 11 : 
                          var ra2 = raw[4];
                          var ra1 = raw[3];
                          var bl = raw[2];
                          var ra1$prime = Util$ReactTemplate.$$Array[/* smartmap */47](subst_glob_constr(subst), ra1);
                          var ra2$prime = Util$ReactTemplate.$$Array[/* smartmap */47](subst_glob_constr(subst), ra2);
                          var bl$prime = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(Util$ReactTemplate.List[/* smartmap */65], (function (dcl) {
                                      var ty = dcl[3];
                                      var obd = dcl[2];
                                      var ty$prime = subst_glob_constr(subst)(ty);
                                      var obd$prime = Option$ReactTemplate.smartmap(subst_glob_constr(subst), obd);
                                      if (ty$prime === ty && obd$prime === obd) {
                                        return dcl;
                                      } else {
                                        return /* tuple */[
                                                dcl[0],
                                                dcl[1],
                                                obd$prime,
                                                ty$prime
                                              ];
                                      }
                                    })), bl);
                          if (ra1$prime === ra1 && ra2$prime === ra2 && bl$prime === bl) {
                            return raw;
                          } else {
                            return /* GRec */Block.__(11, [
                                      raw[0],
                                      raw[1],
                                      bl$prime,
                                      ra1$prime,
                                      ra2$prime
                                    ]);
                          }
                      case 13 : 
                          var solve = raw[2];
                          var knd = raw[0];
                          var nknd;
                          if (typeof knd === "number") {
                            nknd = knd;
                          } else if (knd.tag) {
                            nknd = knd;
                          } else {
                            var ref$1 = knd[0];
                            var match$3 = Globnames$ReactTemplate.subst_global(subst, ref$1);
                            var nref = match$3[0];
                            nknd = nref === ref$1 ? knd : /* ImplicitArg */Block.__(0, [
                                  nref,
                                  knd[1],
                                  knd[2]
                                ]);
                          }
                          var nsolve = Option$ReactTemplate.smartmap(Curry._1(Hook$ReactTemplate.get(f_subst_genarg), subst), solve);
                          if (nsolve === solve && nknd === knd) {
                            return raw;
                          } else {
                            return /* GHole */Block.__(13, [
                                      nknd,
                                      raw[1],
                                      nsolve
                                    ]);
                          }
                      case 14 : 
                          var k = raw[1];
                          var r1$3 = raw[0];
                          var r1$prime$3 = subst_glob_constr(subst)(r1$3);
                          var k$prime = Miscops$ReactTemplate.smartmap_cast_type(subst_glob_constr(subst), k);
                          if (r1$prime$3 === r1$3 && k$prime === k) {
                            return raw;
                          } else {
                            return /* GCast */Block.__(14, [
                                      r1$prime$3,
                                      k$prime
                                    ]);
                          }
                      case 15 : 
                          var c$2 = raw[1];
                          var p = raw[0];
                          var kn = Names$ReactTemplate.Projection[/* constant */2](p);
                          var b$1 = Names$ReactTemplate.Projection[/* unfolded */3](p);
                          var kn$prime = Mod_subst$ReactTemplate.subst_constant(subst, kn);
                          var c$prime$2 = subst_glob_constr(subst)(c$2);
                          if (kn$prime === kn && c$prime$2 === c$2) {
                            return raw;
                          } else {
                            return /* GProj */Block.__(15, [
                                      Names$ReactTemplate.Projection[/* make */0](kn$prime, b$1),
                                      c$prime$2
                                    ]);
                          }
                      default:
                        return raw;
                    }
                  }), param);
    });
}

function simple_cases_matrix_of_branches(ind, brs) {
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                var match = it_destRLambda_or_LetIn_names(param[1], param[2]);
                var nal = match[0];
                var mkPatVar = function (na) {
                  var eta = /* PatVar */Block.__(0, [na]);
                  return DAst$ReactTemplate.make(/* None */0, eta);
                };
                var eta_000 = /* tuple */[
                  ind,
                  param[0] + 1 | 0
                ];
                var eta_001 = Curry._2(Util$ReactTemplate.List[/* map */10], mkPatVar, nal);
                var eta = /* PatCstr */Block.__(1, [
                    eta_000,
                    eta_001,
                    /* Anonymous */0
                  ]);
                var p = DAst$ReactTemplate.make(/* None */0, eta);
                var ids = Curry._2(Util$ReactTemplate.List[/* map_filter */62], Nameops$ReactTemplate.Name[/* to_option */18], nal);
                var eta_001$1 = /* :: */[
                  p,
                  /* [] */0
                ];
                var eta_002 = match[1];
                var eta$1 = /* tuple */[
                  ids,
                  eta_001$1,
                  eta_002
                ];
                return CAst$ReactTemplate.make(/* None */0, eta$1);
              }), brs);
}

function return_type_of_predicate(ind, nrealargs_tags, pred) {
  var match = it_destRLambda_or_LetIn_names(Util$ReactTemplate.$at(nrealargs_tags, /* :: */[
            /* false */0,
            /* [] */0
          ]), pred);
  var nal = match[0];
  return /* tuple */[
          /* tuple */[
            Curry._1(Util$ReactTemplate.List[/* hd */1], nal),
            /* Some */[CAst$ReactTemplate.make(/* None */0, /* tuple */[
                    ind,
                    Curry._1(Util$ReactTemplate.List[/* tl */2], nal)
                  ])]
          ],
          /* Some */[match[1]]
        ];
}

var print_universes = Flags$ReactTemplate.univ_print;

var subst_genarg_hook = match[1];

exports.print_universes = print_universes;
exports.print_evar_arguments = print_evar_arguments;
exports.print_factorize_match_patterns = print_factorize_match_patterns;
exports.print_allow_match_default_clause = print_allow_match_default_clause;
exports.subst_cases_pattern = subst_cases_pattern;
exports.subst_glob_constr = subst_glob_constr;
exports.factorize_eqns = factorize_eqns;
exports.detype_names = detype_names;
exports.detype = detype$1;
exports.detype_sort = detype_sort;
exports.detype_rel_context = detype_rel_context;
exports.detype_closed_glob = detype_closed_glob;
exports.lookup_name_as_displayed = lookup_name_as_displayed;
exports.lookup_index_as_renamed = lookup_index_as_renamed;
exports.set_detype_anonymous = set_detype_anonymous;
exports.force_wildcard = force_wildcard;
exports.synthetize_type = synthetize_type;
exports.it_destRLambda_or_LetIn_names = it_destRLambda_or_LetIn_names;
exports.simple_cases_matrix_of_branches = simple_cases_matrix_of_branches;
exports.return_type_of_predicate = return_type_of_predicate;
exports.subst_genarg_hook = subst_genarg_hook;
exports.PrintingInductiveMake = PrintingInductiveMake;
/* PrintingIf Not a pure module */
