// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Int$ReactTemplate = require("../src/int.bs.js");
var Loc$ReactTemplate = require("../src/loc.bs.js");
var Evar$ReactTemplate = require("../src/evar.bs.js");
var Keys$ReactTemplate = require("../library/keys.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var Tacred$ReactTemplate = require("../src/tacred.bs.js");
var Typing$ReactTemplate = require("../src/typing.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var CClosure$ReactTemplate = require("../src/cClosure.bs.js");
var CProfile$ReactTemplate = require("../shims/cProfile.bs.js");
var Coercion$ReactTemplate = require("../src/coercion.bs.js");
var Evarconv$ReactTemplate = require("../src/evarconv.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Locusops$ReactTemplate = require("../src/locusops.bs.js");
var Retyping$ReactTemplate = require("../src/retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Evarsolve$ReactTemplate = require("../src/evarsolve.bs.js");
var Pretyping$ReactTemplate = require("../src/pretyping.bs.js");
var Recordops$ReactTemplate = require("../src/recordops.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Evardefine$ReactTemplate = require("../src/evardefine.bs.js");
var Conv_oracle$ReactTemplate = require("../src/conv_oracle.bs.js");
var Type_errors$ReactTemplate = require("../src/type_errors.bs.js");
var Typeclasses$ReactTemplate = require("../src/typeclasses.bs.js");
var Find_subterm$ReactTemplate = require("../src/find_subterm.bs.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("../src/pretype_errors.bs.js");

var keyed_unification = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"Unification is keyed",
      /* optkey : :: */[
        "Keyed",
        /* :: */[
          "Unification",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return keyed_unification[0];
        }),
      /* optwrite */(function (a) {
          keyed_unification[0] = a;
          return /* () */0;
        })
    ]);

function is_keyed_unification() {
  return keyed_unification[0];
}

var debug_unification = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"Print states sent to tactic unification",
      /* optkey : :: */[
        "Debug",
        /* :: */[
          "Tactic",
          /* :: */[
            "Unification",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return debug_unification[0];
        }),
      /* optwrite */(function (a) {
          debug_unification[0] = a;
          return /* () */0;
        })
    ]);

function unsafe_occur_meta_or_existential(c) {
  var c$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](c);
  var occrec = function (c) {
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 2 : 
      case 3 : 
          throw Termops$ReactTemplate.Occur;
      default:
        return Constr$ReactTemplate.iter(occrec, c);
    }
  };
  try {
    occrec(c$1);
    return /* false */0;
  }
  catch (exn){
    if (exn === Termops$ReactTemplate.Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function occur_meta_or_undefined_evar(evd, c) {
  var c$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](c);
  var occrec = function (c) {
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 2 : 
          throw Termops$ReactTemplate.Occur;
      case 3 : 
          var match$1 = match[0];
          var match$2 = Evd$ReactTemplate.evar_body(Evd$ReactTemplate.find(evd, match$1[0]));
          if (match$2) {
            occrec(match$2[0]);
            return Util$ReactTemplate.$$Array[/* iter */11](occrec, match$1[1]);
          } else {
            throw Termops$ReactTemplate.Occur;
          }
          break;
      default:
        return Constr$ReactTemplate.iter(occrec, c);
    }
  };
  try {
    occrec(c$1);
    return /* false */0;
  }
  catch (exn){
    if (exn === Termops$ReactTemplate.Occur) {
      return /* true */1;
    } else if (exn === Caml_builtin_exceptions.not_found) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function occur_meta_evd(sigma, mv, c) {
  var occrec = function (c) {
    var c$1 = Reductionops$ReactTemplate.whd_meta(sigma, c);
    var match = EConstr$ReactTemplate.kind(sigma, c$1);
    if (match.tag === 2) {
      if (mv === match[0]) {
        throw Termops$ReactTemplate.Occur;
      } else {
        return EConstr$ReactTemplate.iter(sigma, occrec, c$1);
      }
    } else {
      return EConstr$ReactTemplate.iter(sigma, occrec, c$1);
    }
  };
  try {
    occrec(c);
    return /* false */0;
  }
  catch (exn){
    if (exn === Termops$ReactTemplate.Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function abstract_scheme(env, evd, c, l, lname_typ) {
  var mkLambda_name = function (env, param) {
    var a = param[1];
    return EConstr$ReactTemplate.mkLambda(/* tuple */[
                Namegen$ReactTemplate.named_hd(env, evd, a, param[0]),
                a,
                param[2]
              ]);
  };
  return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, param$1, decl) {
                var a = param$1[1];
                var evd = param[1];
                var t = param[0];
                var na = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
                var ta = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl);
                var match = EConstr$ReactTemplate.kind(evd, a);
                var na$1;
                na$1 = match.tag === 1 ? /* Name */[match[0]] : na;
                if (Termops$ReactTemplate.occur_meta(evd, a)) {
                  return /* tuple */[
                          mkLambda_name(env, /* tuple */[
                                na$1,
                                ta,
                                t
                              ]),
                          evd
                        ];
                } else {
                  var match$1 = Find_subterm$ReactTemplate.subst_closed_term_occ(env, evd, param$1[0], a, t);
                  return /* tuple */[
                          mkLambda_name(env, /* tuple */[
                                na$1,
                                ta,
                                match$1[0]
                              ]),
                          match$1[1]
                        ];
                }
              }), /* tuple */[
              c,
              evd
            ], Curry._1(Util$ReactTemplate.List[/* rev */4], l), lname_typ);
}

function abstract_list_all(env, evd, typ, c, l) {
  var match = Reductionops$ReactTemplate.splay_prod_n(env, evd, Curry._1(Util$ReactTemplate.List[/* length */0], l))(typ);
  var l_with_all_occs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (a) {
          return /* tuple */[
                  /* LikeFirst */0,
                  a
                ];
        }), l);
  var match$1 = abstract_scheme(env, evd, c, l_with_all_occs, match[0]);
  var evd$1 = match$1[1];
  var p = match$1[0];
  var match$2;
  try {
    match$2 = Typing$ReactTemplate.type_of(/* None */0, env, evd$1, p);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === CErrors$ReactTemplate.UserError) {
      match$2 = Pretype_errors$ReactTemplate.error_cannot_find_well_typed_abstraction(env, evd$1, p, l, /* None */0);
    } else if (exn[0] === Type_errors$ReactTemplate.TypeError) {
      match$2 = Pretype_errors$ReactTemplate.error_cannot_find_well_typed_abstraction(env, evd$1, p, l, /* None */0);
    } else if (exn[0] === Pretype_errors$ReactTemplate.PretypeError) {
      var match$3 = exn[3];
      if (match$3.tag === 16) {
        match$2 = Pretype_errors$ReactTemplate.error_cannot_find_well_typed_abstraction(env, exn[2], p, l, /* Some */[/* tuple */[
                exn[1],
                match$3[0]
              ]]);
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
  return /* tuple */[
          match$2[0],
          /* tuple */[
            p,
            match$2[1]
          ]
        ];
}

function set_occurrences_of_last_arg(args) {
  return /* :: */[
          /* Some */[/* AllOccurrences */0],
          Curry._1(Util$ReactTemplate.List[/* tl */2], Util$ReactTemplate.$$Array[/* map_to_list */44]((function () {
                      return /* None */0;
                    }), args))
        ];
}

function abstract_list_all_with_dependencies(env, evd, typ, c, l) {
  var match = Evarutil$ReactTemplate.new_evar(env, evd, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, typ);
  var ev = match[1];
  var evd$1 = match[0];
  var match$1 = Evardefine$ReactTemplate.evar_absorb_arguments(env, evd$1, EConstr$ReactTemplate.destEvar(evd$1, ev), l);
  var ev$prime = match$1[1];
  var n = Curry._1(Util$ReactTemplate.List[/* length */0], l);
  var argoccs = set_occurrences_of_last_arg(Util$ReactTemplate.$$Array[/* sub */5](ev$prime[1], 0, n));
  var match$2 = Evarconv$ReactTemplate.second_order_matching(Names$ReactTemplate.empty_transparent_state, env, match$1[0], ev$prime, argoccs, c);
  var evd$2 = match$2[0];
  if (match$2[1]) {
    var p = Evarutil$ReactTemplate.nf_evar(evd$2, ev);
    return /* tuple */[
            evd$2,
            p
          ];
  } else {
    return Pretype_errors$ReactTemplate.error_cannot_find_well_typed_abstraction(env, evd$2, c, l, /* None */0);
  }
}

function opp_status(param) {
  switch (param) {
    case 0 : 
        return /* IsSubType */1;
    case 1 : 
        return /* IsSuperType */0;
    case 2 : 
        return /* Conv */2;
    
  }
}

function add_type_status(param) {
  return /* tuple */[
          /* tuple */[
            param[0],
            /* TypeNotProcessed */1
          ],
          /* tuple */[
            param[1],
            /* TypeNotProcessed */1
          ]
        ];
}

function extract_instance_status(param) {
  if (param !== 0) {
    return add_type_status(/* tuple */[
                /* IsSubType */1,
                /* IsSuperType */0
              ]);
  } else {
    return add_type_status(/* tuple */[
                /* Conv */2,
                /* Conv */2
              ]);
  }
}

function subst_meta_instances(sigma, bl, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 2) {
    var i = match[0];
    var select = function (param) {
      return +(i === param[0]);
    };
    try {
      return Util$ReactTemplate.pi2(Curry._2(Util$ReactTemplate.List[/* find */26], select, bl));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return c;
      } else {
        throw exn;
      }
    }
  } else {
    return EConstr$ReactTemplate.map(sigma, (function (param) {
                  return subst_meta_instances(sigma, bl, param);
                }), c);
  }
}

function pose_all_metas_as_evars(env, evd, t) {
  var evdref = [evd];
  var aux = function (t) {
    var match = EConstr$ReactTemplate.kind(evdref[0], t);
    if (match.tag === 2) {
      var mv = match[0];
      var match$1 = Evd$ReactTemplate.meta_opt_fvalue(evdref[0], mv);
      if (match$1) {
        return EConstr$ReactTemplate.of_constr(match$1[0][0][/* rebus */0]);
      } else {
        var match$2 = Evd$ReactTemplate.meta_ftype(evd, mv);
        var ty = EConstr$ReactTemplate.of_constr(match$2[/* rebus */0]);
        var ty$1 = Curry._1(Evd$ReactTemplate.Metaset[/* is_empty */1], match$2[/* freemetas */1]) ? ty : aux(ty);
        var ty$2 = Flags$ReactTemplate.version_strictly_greater(/* V8_6 */0) ? Reductionops$ReactTemplate.nf_betaiota(env, evd, ty$1) : ty$1;
        var src = Evd$ReactTemplate.evar_source_of_meta(mv, evdref[0]);
        var ev = Evarutil$ReactTemplate.e_new_evar(env, evdref, /* Some */[src], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, ty$2);
        evdref[0] = Evd$ReactTemplate.meta_assign(mv, /* tuple */[
              EConstr$ReactTemplate.Unsafe[/* to_constr */0](ev),
              /* tuple */[
                /* Conv */2,
                /* TypeNotProcessed */1
              ]
            ], evdref[0]);
        return ev;
      }
    } else {
      return EConstr$ReactTemplate.map(evdref[0], aux, t);
    }
  };
  var c = aux(t);
  return /* tuple */[
          evdref[0],
          c
        ];
}

function push(d, param) {
  return /* tuple */[
          Termops$ReactTemplate.push_rel_assum(d, param[0]),
          param[1] + 1 | 0
        ];
}

function default_core_unify_flags() {
  return /* record */[
          /* modulo_conv_on_closed_terms : Some */[Names$ReactTemplate.full_transparent_state],
          /* use_metas_eagerly_in_conv_on_closed_terms : true */1,
          /* use_evars_eagerly_in_conv_on_closed_terms : false */0,
          /* modulo_delta */Names$ReactTemplate.full_transparent_state,
          /* modulo_delta_types */Names$ReactTemplate.full_transparent_state,
          /* check_applied_meta_types : true */1,
          /* use_pattern_unification : true */1,
          /* use_meta_bound_pattern_unification : true */1,
          /* frozen_evars */Evar$ReactTemplate.$$Set[/* empty */0],
          /* restrict_conv_on_strict_subterms : false */0,
          /* modulo_betaiota : true */1,
          /* modulo_eta : true */1
        ];
}

function default_unify_flags() {
  var flags = default_core_unify_flags(/* () */0);
  var newrecord = flags.slice();
  return /* record */[
          /* core_unify_flags */flags,
          /* merge_unify_flags */flags,
          /* subterm_unify_flags */(newrecord[/* modulo_delta */3] = Names$ReactTemplate.var_full_transparent_state, newrecord),
          /* allow_K_in_toplevel_higher_order_unification : false */0,
          /* resolve_evars : false */0
        ];
}

function set_no_delta_core_flags(flags) {
  return /* record */[
          /* modulo_conv_on_closed_terms : None */0,
          /* use_metas_eagerly_in_conv_on_closed_terms */flags[/* use_metas_eagerly_in_conv_on_closed_terms */1],
          /* use_evars_eagerly_in_conv_on_closed_terms */flags[/* use_evars_eagerly_in_conv_on_closed_terms */2],
          /* modulo_delta */Names$ReactTemplate.empty_transparent_state,
          /* modulo_delta_types */flags[/* modulo_delta_types */4],
          /* check_applied_meta_types : false */0,
          /* use_pattern_unification : false */0,
          /* use_meta_bound_pattern_unification : true */1,
          /* frozen_evars */flags[/* frozen_evars */8],
          /* restrict_conv_on_strict_subterms */flags[/* restrict_conv_on_strict_subterms */9],
          /* modulo_betaiota : false */0,
          /* modulo_eta */flags[/* modulo_eta */11]
        ];
}

function set_no_delta_flags(flags) {
  return /* record */[
          /* core_unify_flags */set_no_delta_core_flags(flags[/* core_unify_flags */0]),
          /* merge_unify_flags */set_no_delta_core_flags(flags[/* merge_unify_flags */1]),
          /* subterm_unify_flags */set_no_delta_core_flags(flags[/* subterm_unify_flags */2]),
          /* allow_K_in_toplevel_higher_order_unification */flags[/* allow_K_in_toplevel_higher_order_unification */3],
          /* resolve_evars */flags[/* resolve_evars */4]
        ];
}

function set_no_delta_open_core_flags(flags) {
  var newrecord = flags.slice();
  newrecord[/* modulo_delta */3] = Names$ReactTemplate.empty_transparent_state;
  newrecord[/* modulo_betaiota */10] = /* false */0;
  return newrecord;
}

function set_no_delta_open_flags(flags) {
  return /* record */[
          /* core_unify_flags */set_no_delta_open_core_flags(flags[/* core_unify_flags */0]),
          /* merge_unify_flags */set_no_delta_open_core_flags(flags[/* merge_unify_flags */1]),
          /* subterm_unify_flags */set_no_delta_open_core_flags(flags[/* subterm_unify_flags */2]),
          /* allow_K_in_toplevel_higher_order_unification */flags[/* allow_K_in_toplevel_higher_order_unification */3],
          /* resolve_evars */flags[/* resolve_evars */4]
        ];
}

function default_no_delta_core_unify_flags() {
  var init = default_core_unify_flags(/* () */0);
  return /* record */[
          /* modulo_conv_on_closed_terms */init[/* modulo_conv_on_closed_terms */0],
          /* use_metas_eagerly_in_conv_on_closed_terms */init[/* use_metas_eagerly_in_conv_on_closed_terms */1],
          /* use_evars_eagerly_in_conv_on_closed_terms */init[/* use_evars_eagerly_in_conv_on_closed_terms */2],
          /* modulo_delta */Names$ReactTemplate.empty_transparent_state,
          /* modulo_delta_types */init[/* modulo_delta_types */4],
          /* check_applied_meta_types : false */0,
          /* use_pattern_unification : false */0,
          /* use_meta_bound_pattern_unification : true */1,
          /* frozen_evars */init[/* frozen_evars */8],
          /* restrict_conv_on_strict_subterms */init[/* restrict_conv_on_strict_subterms */9],
          /* modulo_betaiota : false */0,
          /* modulo_eta */init[/* modulo_eta */11]
        ];
}

function default_no_delta_unify_flags() {
  var flags = default_no_delta_core_unify_flags(/* () */0);
  return /* record */[
          /* core_unify_flags */flags,
          /* merge_unify_flags */flags,
          /* subterm_unify_flags */flags,
          /* allow_K_in_toplevel_higher_order_unification : false */0,
          /* resolve_evars : false */0
        ];
}

function elim_core_flags(sigma) {
  var newrecord = default_core_unify_flags(/* () */0).slice();
  newrecord[/* frozen_evars */8] = Evd$ReactTemplate.fold_undefined((function (evk, _, evars) {
          return Curry._2(Evar$ReactTemplate.$$Set[/* add */3], evk, evars);
        }), sigma, Evar$ReactTemplate.$$Set[/* empty */0]);
  newrecord[/* modulo_betaiota */10] = /* false */0;
  return newrecord;
}

function elim_flags() {
  var sigma = Evd$ReactTemplate.empty;
  var flags = elim_core_flags(sigma);
  var newrecord = flags.slice();
  return /* record */[
          /* core_unify_flags */flags,
          /* merge_unify_flags */flags,
          /* subterm_unify_flags */(newrecord[/* modulo_delta */3] = Names$ReactTemplate.empty_transparent_state, newrecord),
          /* allow_K_in_toplevel_higher_order_unification : true */1,
          /* resolve_evars : false */0
        ];
}

function elim_no_delta_core_flags() {
  var newrecord = elim_core_flags(Evd$ReactTemplate.empty).slice();
  newrecord[/* modulo_delta */3] = Names$ReactTemplate.empty_transparent_state;
  newrecord[/* check_applied_meta_types */5] = /* false */0;
  newrecord[/* use_pattern_unification */6] = /* false */0;
  newrecord[/* modulo_betaiota */10] = /* false */0;
  return newrecord;
}

function elim_no_delta_flags() {
  var flags = elim_no_delta_core_flags(/* () */0);
  return /* record */[
          /* core_unify_flags */flags,
          /* merge_unify_flags */flags,
          /* subterm_unify_flags */flags,
          /* allow_K_in_toplevel_higher_order_unification : true */1,
          /* resolve_evars : false */0
        ];
}

function set_flags_for_type(flags) {
  return /* record */[
          /* modulo_conv_on_closed_terms : Some */[flags[/* modulo_delta_types */4]],
          /* use_metas_eagerly_in_conv_on_closed_terms */flags[/* use_metas_eagerly_in_conv_on_closed_terms */1],
          /* use_evars_eagerly_in_conv_on_closed_terms */flags[/* use_evars_eagerly_in_conv_on_closed_terms */2],
          /* modulo_delta */flags[/* modulo_delta_types */4],
          /* modulo_delta_types */flags[/* modulo_delta_types */4],
          /* check_applied_meta_types */flags[/* check_applied_meta_types */5],
          /* use_pattern_unification : true */1,
          /* use_meta_bound_pattern_unification */flags[/* use_meta_bound_pattern_unification */7],
          /* frozen_evars */flags[/* frozen_evars */8],
          /* restrict_conv_on_strict_subterms */flags[/* restrict_conv_on_strict_subterms */9],
          /* modulo_betaiota : true */1,
          /* modulo_eta : true */1
        ];
}

function use_metas_pattern_unification(sigma, flags, nb, l) {
  if (flags[/* use_pattern_unification */6]) {
    return /* true */1;
  } else if (flags[/* use_meta_bound_pattern_unification */7]) {
    return Util$ReactTemplate.$$Array[/* for_all */26]((function (c) {
                  if (EConstr$ReactTemplate.isRel(sigma, c)) {
                    return +(EConstr$ReactTemplate.destRel(sigma, c) <= nb);
                  } else {
                    return /* false */0;
                  }
                }), l);
  } else {
    return /* false */0;
  }
}

function expand_table_key(env, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Environ$ReactTemplate.constant_opt_value_in(env, param[0]);
    case 1 : 
        try {
          return Environ$ReactTemplate.named_body(param[0], env);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return /* None */0;
          } else {
            throw exn;
          }
        }
        break;
    case 2 : 
        return /* None */0;
    
  }
}

function unfold_projection(env, p, stk) {
  var match;
  try {
    match = /* Some */[Environ$ReactTemplate.lookup_projection(p, env)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      match = /* None */0;
    } else {
      throw exn;
    }
  }
  if (match) {
    var pb = match[0];
    var s_000 = pb[/* proj_npars */1];
    var s_001 = pb[/* proj_arg */2];
    var s_003 = Reductionops$ReactTemplate.Cst_stack[/* empty */0];
    var s = /* Proj */Block.__(2, [
        s_000,
        s_001,
        p,
        s_003
      ]);
    return /* :: */[
            s,
            stk
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "unification.ml",
            482,
            12
          ]
        ];
  }
}

function expand_key(ts, env, sigma, param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      var c = match[1];
      var p = match[0];
      var red = Reductionops$ReactTemplate.Stack[/* zip */21](/* None */0, sigma, Reductionops$ReactTemplate.whd_betaiota_deltazeta_for_iota_state(ts, env, sigma, Reductionops$ReactTemplate.Cst_stack[/* empty */0], /* tuple */[
                  c,
                  unfold_projection(env, p, /* [] */0)
                ])[0]);
      if (EConstr$ReactTemplate.eq_constr(sigma, EConstr$ReactTemplate.mkProj(/* tuple */[
                  p,
                  c
                ]), red)) {
        return /* None */0;
      } else {
        return /* Some */[red];
      }
    } else {
      return Option$ReactTemplate.map(EConstr$ReactTemplate.of_constr, expand_table_key(env, match[0]));
    }
  } else {
    return /* None */0;
  }
}

function isApp_or_Proj(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 9 : 
    case 16 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function subterm_restriction(opt, flags) {
  if (opt[/* at_top */0]) {
    return /* false */0;
  } else {
    return flags[/* restrict_conv_on_strict_subterms */9];
  }
}

function key_of(env, sigma, b, flags, f) {
  if (subterm_restriction(b, flags)) {
    return /* None */0;
  } else {
    var match = EConstr$ReactTemplate.kind(sigma, f);
    switch (match.tag | 0) {
      case 1 : 
          var id = match[0];
          if (Reductionops$ReactTemplate.is_transparent(env, /* VarKey */Block.__(1, [id])) && Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], id, flags[/* modulo_delta */3][0])) {
            return /* Some */[/* IsKey */Block.__(0, [/* VarKey */Block.__(1, [id])])];
          } else {
            return /* None */0;
          }
      case 10 : 
          var match$1 = match[0];
          var cst = match$1[0];
          if (Reductionops$ReactTemplate.is_transparent(env, /* ConstKey */Block.__(0, [cst])) && (Curry._2(Names$ReactTemplate.Cpred[/* mem */4], cst, flags[/* modulo_delta */3][1]) || Environ$ReactTemplate.is_projection(cst, env))) {
            var u = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$1[1]);
            return /* Some */[/* IsKey */Block.__(0, [/* ConstKey */Block.__(0, [/* tuple */[
                              cst,
                              u
                            ]])])];
          } else {
            return /* None */0;
          }
          break;
      case 16 : 
          var p = match[0];
          if (Names$ReactTemplate.Projection[/* unfolded */3](p) || Reductionops$ReactTemplate.is_transparent(env, /* ConstKey */Block.__(0, [Names$ReactTemplate.Projection[/* constant */2](p)])) && Curry._2(Names$ReactTemplate.Cpred[/* mem */4], Names$ReactTemplate.Projection[/* constant */2](p), flags[/* modulo_delta */3][1])) {
            return /* Some */[/* IsProj */Block.__(1, [
                        p,
                        match[1]
                      ])];
          } else {
            return /* None */0;
          }
      default:
        return /* None */0;
    }
  }
}

function translate_key(param) {
  if (param.tag) {
    return /* ConstKey */Block.__(0, [Names$ReactTemplate.Projection[/* constant */2](param[0])]);
  } else {
    var param$1 = param[0];
    switch (param$1.tag | 0) {
      case 0 : 
          return /* ConstKey */Block.__(0, [param$1[0][0]]);
      case 1 : 
          return /* VarKey */Block.__(1, [param$1[0]]);
      case 2 : 
          return /* RelKey */Block.__(2, [param$1[0]]);
      
    }
  }
}

function oracle_order(env, cf1, cf2) {
  if (cf1) {
    if (cf2) {
      var k2 = cf2[0];
      var k1 = cf1[0];
      var exit = 0;
      if (k1.tag) {
        var p = k1[0];
        if (k2.tag) {
          exit = 1;
        } else {
          var match = k2[0];
          switch (match.tag | 0) {
            case 0 : 
                if (Names$ReactTemplate.Constant[/* equal */12](Names$ReactTemplate.Projection[/* constant */2](p), match[0][0])) {
                  return /* Some */[1 - Names$ReactTemplate.Projection[/* unfolded */3](p)];
                } else {
                  exit = 1;
                }
                break;
            case 1 : 
            case 2 : 
                exit = 1;
                break;
            
          }
        }
      } else {
        var match$1 = k1[0];
        switch (match$1.tag | 0) {
          case 0 : 
              if (k2.tag) {
                var p$prime = k2[0];
                if (Names$ReactTemplate.Constant[/* equal */12](match$1[0][0], Names$ReactTemplate.Projection[/* constant */2](p$prime))) {
                  return /* Some */[Names$ReactTemplate.Projection[/* unfolded */3](p$prime)];
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
              break;
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          
        }
      }
      if (exit === 1) {
        return /* Some */[Conv_oracle$ReactTemplate.oracle_order((function (x) {
                        return x;
                      }), Environ$ReactTemplate.oracle(env), /* false */0, translate_key(k1), translate_key(k2))];
      }
      
    } else {
      return /* Some */[/* true */1];
    }
  } else if (cf2) {
    return /* Some */[/* false */0];
  } else {
    return /* None */0;
  }
}

function is_rigid_head(sigma, flags, t) {
  var match = EConstr$ReactTemplate.kind(sigma, t);
  switch (match.tag | 0) {
    case 10 : 
        return 1 - Curry._2(Names$ReactTemplate.Cpred[/* mem */4], match[0][0], flags[/* modulo_delta */3][1]);
    case 11 : 
    case 12 : 
    case 14 : 
    case 15 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function force_eqs(c) {
  return Curry._3(Universes$ReactTemplate.Constraints[/* fold */13], (function (c, acc) {
                var c$prime;
                var exit = 0;
                switch (c.tag | 0) {
                  case 0 : 
                  case 1 : 
                      c$prime = c;
                      break;
                  case 2 : 
                  case 3 : 
                      exit = 1;
                      break;
                  
                }
                if (exit === 1) {
                  c$prime = /* UEq */Block.__(1, [
                      Univ$ReactTemplate.Universe[/* make */3](c[0]),
                      Univ$ReactTemplate.Universe[/* make */3](c[1])
                    ]);
                }
                return Universes$ReactTemplate.Constraints[/* add */3](c$prime, acc);
              }), c, Universes$ReactTemplate.Constraints[/* empty */0]);
}

function constr_cmp(pb, env, sigma, flags, t, u) {
  var cstrs = pb ? EConstr$ReactTemplate.leq_constr_universes(env, sigma, t, u) : EConstr$ReactTemplate.eq_constr_universes(env, sigma, t, u);
  if (cstrs) {
    var cstrs$1 = cstrs[0];
    try {
      return /* tuple */[
              Evd$ReactTemplate.add_universe_constraints(sigma, cstrs$1),
              /* true */1
            ];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Univ$ReactTemplate.UniverseInconsistency) {
        return /* tuple */[
                sigma,
                /* false */0
              ];
      } else if (exn === Evd$ReactTemplate.UniversesDiffer) {
        if (is_rigid_head(sigma, flags, t)) {
          try {
            return /* tuple */[
                    Evd$ReactTemplate.add_universe_constraints(sigma, force_eqs(cstrs$1)),
                    /* true */1
                  ];
          }
          catch (raw_exn$1){
            var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
            if (exn$1[0] === Univ$ReactTemplate.UniverseInconsistency) {
              return /* tuple */[
                      sigma,
                      /* false */0
                    ];
            } else {
              throw exn$1;
            }
          }
        } else {
          return /* tuple */[
                  sigma,
                  /* false */0
                ];
        }
      } else {
        throw exn;
      }
    }
  } else {
    return /* tuple */[
            sigma,
            /* false */0
          ];
  }
}

function do_reduce(ts, param, sigma, c) {
  return Reductionops$ReactTemplate.Stack[/* zip */21](/* None */0, sigma, Reductionops$ReactTemplate.whd_betaiota_deltazeta_for_iota_state(ts, param[0], sigma, Reductionops$ReactTemplate.Cst_stack[/* empty */0], /* tuple */[
                    c,
                    Reductionops$ReactTemplate.Stack[/* empty */2]
                  ])[0]);
}

function isAllowedEvar(sigma, flags, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 3) {
    return 1 - Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], match[0][0], flags[/* frozen_evars */8]);
  } else {
    return /* false */0;
  }
}

function subst_defined_metas_evars(_, param, c) {
  var el = param[1];
  var bl = param[0];
  var c$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](c);
  var substrec = function (_c) {
    while(true) {
      var c = _c;
      var match = Constr$ReactTemplate.kind(c);
      switch (match.tag | 0) {
        case 2 : 
            var i = match[0];
            var select = (function(i){
            return function select(param) {
              return +(i === param[0]);
            }
            }(i));
            _c = EConstr$ReactTemplate.Unsafe[/* to_constr */0](Util$ReactTemplate.pi2(Curry._2(Util$ReactTemplate.List[/* find */26], select, bl)));
            continue ;
            case 3 : 
            var match$1 = match[0];
            var args = match$1[1];
            var evk = match$1[0];
            var eq = function (c1, c2) {
              return Constr$ReactTemplate.equal(c1, EConstr$ReactTemplate.Unsafe[/* to_constr */0](c2));
            };
            var select$1 = (function(evk,args){
            return function select$1(param) {
              var match = param[1];
              if (Evar$ReactTemplate.equal(evk, match[0])) {
                return Util$ReactTemplate.$$Array[/* for_all2 */27](eq, args, match[1]);
              } else {
                return /* false */0;
              }
            }
            }(evk,args));
            try {
              return substrec(EConstr$ReactTemplate.Unsafe[/* to_constr */0](Util$ReactTemplate.pi3(Curry._2(Util$ReactTemplate.List[/* find */26], select$1, el))));
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return Constr$ReactTemplate.map(substrec, c);
              } else {
                throw exn;
              }
            }
            break;
        default:
          return Constr$ReactTemplate.map(substrec, c);
      }
    };
  };
  try {
    return /* Some */[EConstr$ReactTemplate.of_constr(substrec(c$1))];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function check_compatibility(env, pbty, flags, param, tyM, tyN) {
  var metasubst = param[1];
  var sigma = param[0];
  var match = subst_defined_metas_evars(sigma, /* tuple */[
        metasubst,
        /* [] */0
      ], tyM);
  if (match) {
    var m = match[0];
    var match$1 = subst_defined_metas_evars(sigma, /* tuple */[
          metasubst,
          /* [] */0
        ], tyN);
    if (match$1) {
      var n = match$1[0];
      if (Evarutil$ReactTemplate.is_ground_term(sigma, m) && Evarutil$ReactTemplate.is_ground_term(sigma, n)) {
        var match$2 = Reductionops$ReactTemplate.infer_conv(/* None */0, /* Some */[pbty], /* Some */[flags[/* modulo_delta_types */4]], env, sigma, m, n);
        var sigma$1 = match$2[0];
        if (match$2[1]) {
          return sigma$1;
        } else {
          return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, env, sigma$1, /* None */0, /* tuple */[
                      m,
                      n
                    ]);
        }
      } else {
        return sigma;
      }
    } else {
      return sigma;
    }
  } else {
    return sigma;
  }
}

function is_eta_constructor_app(env, sigma, ts, f, l1, term) {
  var match = EConstr$ReactTemplate.kind(sigma, f);
  if (match.tag === 12) {
    var match$1 = match[0][0];
    var ind = match$1[0];
    if (ind[1] === 0 && match$1[1] === 1) {
      var mib = Environ$ReactTemplate.lookup_mind(ind[0], env);
      var match$2 = mib[/* mind_record */1];
      if (match$2) {
        var match$3 = match$2[0];
        if (match$3 && mib[/* mind_finite */2] === /* BiFinite */2 && match$3[0][2].length === (l1.length - mib[/* mind_nparams */5] | 0)) {
          var env$1 = env;
          var sigma$1 = sigma;
          var ts$1 = ts;
          var _t = term;
          while(true) {
            var t = _t;
            var match$4 = Termops$ReactTemplate.decompose_app_vect(sigma$1, t);
            var match$5 = EConstr$ReactTemplate.kind(sigma$1, match$4[0]);
            switch (match$5.tag | 0) {
              case 1 : 
                  var id = match$5[0];
                  if (!Environ$ReactTemplate.evaluable_named(id, env$1) || !Reductionops$ReactTemplate.is_transparent(env$1, /* VarKey */Block.__(1, [id]))) {
                    return /* true */1;
                  } else {
                    return 1 - Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], id, ts$1[0]);
                  }
              case 0 : 
              case 2 : 
              case 3 : 
                  return /* true */1;
              case 9 : 
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "unification.ml",
                          651,
                          15
                        ]
                      ];
              case 10 : 
                  var c = match$5[0][0];
                  if (!Environ$ReactTemplate.evaluable_constant(c, env$1) || !Reductionops$ReactTemplate.is_transparent(env$1, /* ConstKey */Block.__(0, [c]))) {
                    return /* true */1;
                  } else {
                    return 1 - Curry._2(Names$ReactTemplate.Cpred[/* mem */4], c, ts$1[1]);
                  }
              case 13 : 
                  _t = match$5[2];
                  continue ;
                  case 7 : 
              case 8 : 
              case 12 : 
              case 14 : 
              case 15 : 
                  return /* false */0;
              case 16 : 
                  _t = match$5[1];
                  continue ;
                  default:
                return /* false */0;
            }
          };
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function eta_constructor_app(env, sigma, f, l1, term) {
  var match = EConstr$ReactTemplate.kind(sigma, f);
  if (match.tag === 12) {
    var match$1 = match[0];
    var u = match$1[1];
    var mib = Environ$ReactTemplate.lookup_mind(match$1[0][0][0], env);
    var match$2 = mib[/* mind_record */1];
    if (match$2) {
      var match$3 = match$2[0];
      if (match$3) {
        var npars = mib[/* mind_nparams */5];
        var match$4 = Util$ReactTemplate.$$Array[/* chop */46](npars, l1);
        var arg = Util$ReactTemplate.$$Array[/* append */3](match$4[0], /* array */[term]);
        var l2 = Util$ReactTemplate.$$Array[/* map */12]((function (p) {
                return EConstr$ReactTemplate.mkApp(/* tuple */[
                            EConstr$ReactTemplate.mkConstU(/* tuple */[
                                  p,
                                  u
                                ]),
                            arg
                          ]);
              }), match$3[0][1]);
        return /* tuple */[
                match$4[1],
                l2
              ];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "unification.ml",
                676,
                13
              ]
            ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "unification.ml",
              676,
              13
            ]
          ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "unification.ml",
            677,
            9
          ]
        ];
  }
}

function unify_0_with_initial_metas(subst, conv_at_top, env, cv_pb, flags, m, n) {
  var es = subst[2];
  var ms = subst[1];
  var sigma = subst[0];
  var unirec_rec = function (_curenvnb, _pb, _opt, _substn, _curm, _curn) {
    while(true) {
      var curn = _curn;
      var curm = _curm;
      var substn = _substn;
      var opt = _opt;
      var pb = _pb;
      var curenvnb = _curenvnb;
      var evarsubst = substn[2];
      var metasubst = substn[1];
      var sigma$1 = substn[0];
      var nb = curenvnb[1];
      var curenv = curenvnb[0];
      var cM = Evarutil$ReactTemplate.whd_head_evar(sigma$1, curm);
      var cN = Evarutil$ReactTemplate.whd_head_evar(sigma$1, curn);
      if (debug_unification[0]) {
        Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Termops$ReactTemplate.print_constr_env(curenv, sigma$1, cM), Pp$ReactTemplate.str(" ~= ")), Termops$ReactTemplate.print_constr_env(curenv, sigma$1, cN)));
      }
      var match = EConstr$ReactTemplate.kind(sigma$1, cM);
      var match$1 = EConstr$ReactTemplate.kind(sigma$1, cN);
      var exit = 0;
      var exit$1 = 0;
      var exit$2 = 0;
      var exit$3 = 0;
      var exit$4 = 0;
      var exit$5 = 0;
      var exit$6 = 0;
      var exit$7 = 0;
      var exit$8 = 0;
      var exit$9 = 0;
      var exit$10 = 0;
      var exit$11 = 0;
      switch (match.tag | 0) {
        case 2 : 
            var k1 = match[0];
            if (match$1.tag === 2) {
              var k2 = match$1[0];
              if (k1 === k2) {
                return substn;
              } else {
                var match$2 = extract_instance_status(pb);
                var sigma$2;
                if (opt[/* with_types */1] && flags[/* check_applied_meta_types */5]) {
                  var tyM = Typing$ReactTemplate.meta_type(sigma$1, k1);
                  var tyN = Typing$ReactTemplate.meta_type(sigma$1, k2);
                  var match$3 = k2 < k1 ? /* tuple */[
                      tyN,
                      tyM
                    ] : /* tuple */[
                      tyM,
                      tyN
                    ];
                  sigma$2 = check_compatibility(curenv, /* CUMUL */1, flags, substn, match$3[0], match$3[1]);
                } else {
                  sigma$2 = sigma$1;
                }
                if (k2 < k1) {
                  return /* tuple */[
                          sigma$2,
                          /* :: */[
                            /* tuple */[
                              k1,
                              cN,
                              match$2[1]
                            ],
                            metasubst
                          ],
                          evarsubst
                        ];
                } else {
                  return /* tuple */[
                          sigma$2,
                          /* :: */[
                            /* tuple */[
                              k2,
                              cM,
                              match$2[0]
                            ],
                            metasubst
                          ],
                          evarsubst
                        ];
                }
              }
            } else if (Termops$ReactTemplate.dependent(sigma$1, cM, cN)) {
              exit$11 = 12;
            } else {
              var sigma$3;
              if (opt[/* with_types */1] && flags[/* check_applied_meta_types */5]) {
                try {
                  var tyM$1 = Typing$ReactTemplate.meta_type(sigma$1, k1);
                  var tyN$1 = Retyping$ReactTemplate.get_type_of(/* None */0, /* Some */[/* true */1], curenv, sigma$1, cN);
                  sigma$3 = check_compatibility(curenv, /* CUMUL */1, flags, substn, tyN$1, tyM$1);
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === Retyping$ReactTemplate.RetypeError) {
                    sigma$3 = sigma$1;
                  } else {
                    throw exn;
                  }
                }
              } else {
                sigma$3 = sigma$1;
              }
              if (nb) {
                if (EConstr$ReactTemplate.Vars[/* noccur_between */13](sigma$3, 1, nb, cN)) {
                  return /* tuple */[
                          sigma$3,
                          /* :: */[
                            /* tuple */[
                              k1,
                              EConstr$ReactTemplate.Vars[/* lift */0](-nb | 0, cN),
                              extract_instance_status(pb)[1]
                            ],
                            metasubst
                          ],
                          evarsubst
                        ];
                } else {
                  return Pretype_errors$ReactTemplate.error_cannot_unify_local(curenv, sigma$3, /* tuple */[
                              m,
                              n,
                              cN
                            ]);
                }
              } else {
                return /* tuple */[
                        sigma$3,
                        /* :: */[
                          /* tuple */[
                            k1,
                            cN,
                            extract_instance_status(pb)[1]
                          ],
                          metasubst
                        ],
                        evarsubst
                      ];
              }
            }
            break;
        case 3 : 
            var ev = match[0];
            var evk = ev[0];
            switch (match$1.tag | 0) {
              case 2 : 
                  exit$11 = 12;
                  break;
              case 3 : 
                  if (!Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], evk, flags[/* frozen_evars */8]) && Evar$ReactTemplate.equal(evk, match$1[0][0])) {
                    var match$4 = constr_cmp(cv_pb, env, sigma$1, flags, cM, cN);
                    if (match$4[1]) {
                      return /* tuple */[
                              match$4[0],
                              metasubst,
                              evarsubst
                            ];
                    } else {
                      return /* tuple */[
                              sigma$1,
                              metasubst,
                              /* :: */[
                                /* tuple */[
                                  curenv,
                                  ev,
                                  cN
                                ],
                                evarsubst
                              ]
                            ];
                    }
                  } else {
                    exit$10 = 11;
                  }
                  break;
              default:
                exit$10 = 11;
            }
            break;
        case 4 : 
            switch (match$1.tag | 0) {
              case 2 : 
                  exit$11 = 12;
                  break;
              case 3 : 
                  exit$9 = 10;
                  break;
              case 4 : 
                  try {
                    var s1 = EConstr$ReactTemplate.ESorts[/* kind */1](sigma$1, match[0]);
                    var s2 = EConstr$ReactTemplate.ESorts[/* kind */1](sigma$1, match$1[0]);
                    var sigma$prime = pb === /* CUMUL */1 ? Evd$ReactTemplate.set_leq_sort(curenv, sigma$1, s1, s2) : Evd$ReactTemplate.set_eq_sort(curenv, sigma$1, s1, s2);
                    return /* tuple */[
                            sigma$prime,
                            metasubst,
                            evarsubst
                          ];
                  }
                  catch (raw_e){
                    var e = Js_exn.internalToOCamlException(raw_e);
                    if (CErrors$ReactTemplate.noncritical(e)) {
                      return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenv, sigma$1, /* None */0, /* tuple */[
                                  m,
                                  n
                                ]);
                    } else {
                      throw e;
                    }
                  }
                  break;
              case 7 : 
                  exit$5 = 6;
                  break;
              case 8 : 
                  exit$7 = 8;
                  break;
              case 9 : 
                  exit$3 = 4;
                  break;
              default:
                exit = 1;
            }
            break;
        case 6 : 
            var t1 = match[1];
            switch (match$1.tag | 0) {
              case 2 : 
                  exit$11 = 12;
                  break;
              case 3 : 
                  exit$9 = 10;
                  break;
              case 6 : 
                  _curn = match$1[2];
                  _curm = match[2];
                  _substn = unirec_rec(curenvnb, /* CONV */0, /* record */[
                        /* at_top : true */1,
                        /* with_types : false */0,
                        /* with_cs */opt[/* with_cs */2]
                      ], substn, t1, match$1[1]);
                  _opt = /* record */[
                    /* at_top : true */1,
                    /* with_types */opt[/* with_types */1],
                    /* with_cs */opt[/* with_cs */2]
                  ];
                  _curenvnb = push(/* tuple */[
                        match[0],
                        t1
                      ], curenvnb);
                  continue ;
                  case 7 : 
                  exit$5 = 6;
                  break;
              case 8 : 
                  exit$7 = 8;
                  break;
              case 9 : 
                  exit$3 = 4;
                  break;
              default:
                exit = 1;
            }
            break;
        case 7 : 
            var t1$1 = match[1];
            switch (match$1.tag | 0) {
              case 2 : 
                  exit$11 = 12;
                  break;
              case 3 : 
                  exit$9 = 10;
                  break;
              case 7 : 
                  _curn = match$1[2];
                  _curm = match[2];
                  _substn = unirec_rec(curenvnb, /* CONV */0, /* record */[
                        /* at_top : true */1,
                        /* with_types : false */0,
                        /* with_cs */opt[/* with_cs */2]
                      ], substn, t1$1, match$1[1]);
                  _opt = /* record */[
                    /* at_top : true */1,
                    /* with_types */opt[/* with_types */1],
                    /* with_cs */opt[/* with_cs */2]
                  ];
                  _pb = /* CONV */0;
                  _curenvnb = push(/* tuple */[
                        match[0],
                        t1$1
                      ], curenvnb);
                  continue ;
                  case 8 : 
                  exit$7 = 8;
                  break;
              default:
                exit$6 = 7;
            }
            break;
        case 13 : 
            switch (match$1.tag | 0) {
              case 2 : 
                  exit$11 = 12;
                  break;
              case 3 : 
                  exit$9 = 10;
                  break;
              case 7 : 
                  exit$5 = 6;
                  break;
              case 8 : 
                  exit$7 = 8;
                  break;
              case 9 : 
                  exit$3 = 4;
                  break;
              case 13 : 
                  try {
                    var opt$prime_002 = /* with_cs */opt[/* with_cs */2];
                    var opt$prime = /* record */[
                      /* at_top : true */1,
                      /* with_types : false */0,
                      opt$prime_002
                    ];
                    var partial_arg_001 = /* with_types */opt[/* with_types */1];
                    var partial_arg_002 = /* with_cs */opt[/* with_cs */2];
                    var partial_arg = /* record */[
                      /* at_top : true */1,
                      partial_arg_001,
                      partial_arg_002
                    ];
                    return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function(curenvnb,partial_arg){
                              return function (param, param$1, param$2) {
                                return unirec_rec(curenvnb, /* CONV */0, partial_arg, param, param$1, param$2);
                              }
                              }(curenvnb,partial_arg)), unirec_rec(curenvnb, /* CONV */0, opt$prime, unirec_rec(curenvnb, /* CONV */0, opt$prime, substn, match[1], match$1[1]), match[2], match$1[2]), match[3], match$1[3]);
                  }
                  catch (raw_ex){
                    var ex = Js_exn.internalToOCamlException(raw_ex);
                    if (Pretype_errors$ReactTemplate.precatchable_exception(ex)) {
                      return reduce(curenvnb, pb, opt, substn, cM, cN);
                    } else {
                      throw ex;
                    }
                  }
                  break;
              default:
                exit = 1;
            }
            break;
        case 16 : 
            switch (match$1.tag | 0) {
              case 2 : 
                  exit$11 = 12;
                  break;
              case 3 : 
                  exit$9 = 10;
                  break;
              case 7 : 
                  exit$5 = 6;
                  break;
              case 8 : 
                  exit$7 = 8;
                  break;
              case 9 : 
                  exit$3 = 4;
                  break;
              case 16 : 
                  if (Names$ReactTemplate.Constant[/* equal */12](Names$ReactTemplate.Projection[/* constant */2](match[0]), Names$ReactTemplate.Projection[/* constant */2](match$1[0]))) {
                    try {
                      var curenvnb$1 = curenvnb;
                      var cv_pb$1 = cv_pb;
                      var opt$1 = /* record */[
                        /* at_top : true */1,
                        /* with_types */opt[/* with_types */1],
                        /* with_cs */opt[/* with_cs */2]
                      ];
                      var substn$1 = substn;
                      var c1 = match[1];
                      var c2 = match$1[1];
                      var curenv$1 = curenvnb$1[0];
                      var substn$2 = unirec_rec(curenvnb$1, /* CONV */0, opt$1, substn$1, c1, c2);
                      try {
                        var ty1 = Retyping$ReactTemplate.get_type_of(/* None */0, /* Some */[/* true */1], curenv$1, sigma, c1);
                        var ty2 = Retyping$ReactTemplate.get_type_of(/* None */0, /* Some */[/* true */1], curenv$1, sigma, c2);
                        var newrecord = flags.slice();
                        return unify_0_with_initial_metas(substn$2, /* true */1, curenv$1, cv_pb$1, (newrecord[/* modulo_conv_on_closed_terms */0] = /* Some */[Names$ReactTemplate.full_transparent_state], newrecord[/* modulo_delta */3] = Names$ReactTemplate.full_transparent_state, newrecord[/* modulo_betaiota */10] = /* true */1, newrecord[/* modulo_eta */11] = /* true */1, newrecord), ty1, ty2);
                      }
                      catch (raw_exn$1){
                        var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
                        if (exn$1[0] === Retyping$ReactTemplate.RetypeError) {
                          return substn$2;
                        } else {
                          throw exn$1;
                        }
                      }
                    }
                    catch (raw_ex$1){
                      var ex$1 = Js_exn.internalToOCamlException(raw_ex$1);
                      if (Pretype_errors$ReactTemplate.precatchable_exception(ex$1)) {
                        return unify_not_same_head(curenvnb, pb, opt, substn, cM, cN);
                      } else {
                        throw ex$1;
                      }
                    }
                  } else {
                    exit = 1;
                  }
                  break;
              default:
                exit = 1;
            }
            break;
        default:
          exit$11 = 12;
      }
      if (exit$11 === 12) {
        if (match$1.tag === 2) {
          var k = match$1[0];
          if (Termops$ReactTemplate.dependent(sigma$1, cN, cM)) {
            exit$10 = 11;
          } else {
            var sigma$4;
            if (opt[/* with_types */1] && flags[/* check_applied_meta_types */5]) {
              try {
                var tyM$2 = Retyping$ReactTemplate.get_type_of(/* None */0, /* Some */[/* true */1], curenv, sigma$1, cM);
                var tyN$2 = Typing$ReactTemplate.meta_type(sigma$1, k);
                sigma$4 = check_compatibility(curenv, /* CUMUL */1, flags, substn, tyM$2, tyN$2);
              }
              catch (raw_exn$2){
                var exn$2 = Js_exn.internalToOCamlException(raw_exn$2);
                if (exn$2[0] === Retyping$ReactTemplate.RetypeError) {
                  sigma$4 = sigma$1;
                } else {
                  throw exn$2;
                }
              }
            } else {
              sigma$4 = sigma$1;
            }
            if (nb) {
              if (EConstr$ReactTemplate.Vars[/* noccur_between */13](sigma$4, 1, nb, cM)) {
                return /* tuple */[
                        sigma$4,
                        /* :: */[
                          /* tuple */[
                            k,
                            EConstr$ReactTemplate.Vars[/* lift */0](-nb | 0, cM),
                            extract_instance_status(pb)[0]
                          ],
                          metasubst
                        ],
                        evarsubst
                      ];
              } else {
                return Pretype_errors$ReactTemplate.error_cannot_unify_local(curenv, sigma$4, /* tuple */[
                            m,
                            n,
                            cM
                          ]);
              }
            } else {
              return /* tuple */[
                      sigma$4,
                      /* :: */[
                        /* tuple */[
                          k,
                          cM,
                          extract_instance_status(pb)[0]
                        ],
                        metasubst
                      ],
                      evarsubst
                    ];
            }
          }
        } else {
          exit$10 = 11;
        }
      }
      if (exit$10 === 11) {
        switch (match.tag | 0) {
          case 3 : 
              var ev$1 = match[0];
              var evk$1 = ev$1[0];
              if (!Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], evk$1, flags[/* frozen_evars */8]) && !Termops$ReactTemplate.occur_evar(sigma$1, evk$1, cN)) {
                var cmvars = Termops$ReactTemplate.free_rels(sigma$1, cM);
                var cnvars = Termops$ReactTemplate.free_rels(sigma$1, cN);
                if (Curry._2(Int$ReactTemplate.$$Set[/* subset */11], cnvars, cmvars)) {
                  return /* tuple */[
                          sigma$1,
                          metasubst,
                          /* :: */[
                            /* tuple */[
                              curenv,
                              ev$1,
                              cN
                            ],
                            evarsubst
                          ]
                        ];
                } else {
                  return Pretype_errors$ReactTemplate.error_cannot_unify_local(curenv, sigma$1, /* tuple */[
                              m,
                              n,
                              cN
                            ]);
                }
              } else {
                exit$9 = 10;
              }
              break;
          case 7 : 
              exit$6 = 7;
              break;
          case 4 : 
          case 6 : 
          case 13 : 
          case 16 : 
              exit = 1;
              break;
          default:
            exit$9 = 10;
        }
      }
      if (exit$9 === 10) {
        if (match$1.tag === 3) {
          var ev$2 = match$1[0];
          var evk$2 = ev$2[0];
          if (!Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], evk$2, flags[/* frozen_evars */8]) && !Termops$ReactTemplate.occur_evar(sigma$1, evk$2, cM)) {
            var cmvars$1 = Termops$ReactTemplate.free_rels(sigma$1, cM);
            var cnvars$1 = Termops$ReactTemplate.free_rels(sigma$1, cN);
            if (Curry._2(Int$ReactTemplate.$$Set[/* subset */11], cmvars$1, cnvars$1)) {
              return /* tuple */[
                      sigma$1,
                      metasubst,
                      /* :: */[
                        /* tuple */[
                          curenv,
                          ev$2,
                          cM
                        ],
                        evarsubst
                      ]
                    ];
            } else {
              return Pretype_errors$ReactTemplate.error_cannot_unify_local(curenv, sigma$1, /* tuple */[
                          m,
                          n,
                          cN
                        ]);
            }
          } else {
            exit$8 = 9;
          }
        } else {
          exit$8 = 9;
        }
      }
      if (exit$8 === 9) {
        switch (match.tag | 0) {
          case 7 : 
              exit$6 = 7;
              break;
          case 8 : 
              _curn = cN;
              _curm = EConstr$ReactTemplate.Vars[/* subst1 */4](match[1], match[3]);
              continue ;
              case 4 : 
          case 6 : 
          case 13 : 
          case 16 : 
              exit = 1;
              break;
          default:
            exit$7 = 8;
        }
      }
      if (exit$7 === 8) {
        if (match$1.tag === 8) {
          _curn = EConstr$ReactTemplate.Vars[/* subst1 */4](match$1[1], match$1[3]);
          _curm = cM;
          continue ;
          
        } else {
          exit$6 = 7;
        }
      }
      if (exit$6 === 7) {
        if (match.tag === 7) {
          if (flags[/* modulo_eta */11]) {
            _curn = EConstr$ReactTemplate.mkApp(/* tuple */[
                  EConstr$ReactTemplate.Vars[/* lift */0](1, cN),
                  /* array */[EConstr$ReactTemplate.mkRel(1)]
                ]);
            _curm = match[2];
            _opt = /* record */[
              /* at_top : true */1,
              /* with_types */opt[/* with_types */1],
              /* with_cs */opt[/* with_cs */2]
            ];
            _pb = /* CONV */0;
            _curenvnb = push(/* tuple */[
                  match[0],
                  match[1]
                ], curenvnb);
            continue ;
            
          } else {
            exit$5 = 6;
          }
        } else {
          exit$5 = 6;
        }
      }
      if (exit$5 === 6) {
        if (match$1.tag === 7) {
          if (flags[/* modulo_eta */11]) {
            _curn = match$1[2];
            _curm = EConstr$ReactTemplate.mkApp(/* tuple */[
                  EConstr$ReactTemplate.Vars[/* lift */0](1, cM),
                  /* array */[EConstr$ReactTemplate.mkRel(1)]
                ]);
            _opt = /* record */[
              /* at_top : true */1,
              /* with_types */opt[/* with_types */1],
              /* with_cs */opt[/* with_cs */2]
            ];
            _pb = /* CONV */0;
            _curenvnb = push(/* tuple */[
                  match$1[0],
                  match$1[1]
                ], curenvnb);
            continue ;
            
          } else {
            exit$4 = 5;
          }
        } else {
          exit$4 = 5;
        }
      }
      if (exit$4 === 5) {
        switch (match.tag | 0) {
          case 9 : 
              var l1 = match[1];
              var f1 = match[0];
              if (flags[/* modulo_eta */11] && is_eta_constructor_app(curenv, sigma$1, flags[/* modulo_delta */3], f1, l1, cN)) {
                try {
                  var match$5 = eta_constructor_app(curenv, sigma$1, f1, l1, cN);
                  var opt$prime_001 = /* with_types */opt[/* with_types */1];
                  var opt$prime$1 = /* record */[
                    /* at_top : true */1,
                    opt$prime_001,
                    /* with_cs : false */0
                  ];
                  return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function(curenvnb,opt$prime$1){
                            return function (param, param$1, param$2) {
                              return unirec_rec(curenvnb, /* CONV */0, opt$prime$1, param, param$1, param$2);
                            }
                            }(curenvnb,opt$prime$1)), substn, match$5[0], match$5[1]);
                }
                catch (raw_ex$2){
                  var ex$2 = Js_exn.internalToOCamlException(raw_ex$2);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(ex$2)) {
                    var match$6 = EConstr$ReactTemplate.kind(sigma$1, cN);
                    if (match$6.tag === 9) {
                      var l2 = match$6[1];
                      var f2 = match$6[0];
                      if (EConstr$ReactTemplate.isMeta(sigma$1, f2) && use_metas_pattern_unification(sigma$1, flags, nb, l2) || flags[/* use_pattern_unification */6] && isAllowedEvar(sigma$1, flags, f2)) {
                        return unify_app_pattern(/* false */0, curenvnb, pb, opt, substn, cM, f1, l1, cN, f2, l2);
                      } else {
                        throw ex$2;
                      }
                    } else {
                      throw ex$2;
                    }
                  } else {
                    throw ex$2;
                  }
                }
              } else {
                exit$3 = 4;
              }
              break;
          case 4 : 
          case 6 : 
          case 13 : 
          case 16 : 
              exit = 1;
              break;
          default:
            exit$3 = 4;
        }
      }
      if (exit$3 === 4) {
        if (match$1.tag === 9) {
          var l2$1 = match$1[1];
          var f2$1 = match$1[0];
          if (flags[/* modulo_eta */11] && is_eta_constructor_app(curenv, sigma$1, flags[/* modulo_delta */3], f2$1, l2$1, cM)) {
            try {
              var match$7 = eta_constructor_app(curenv, sigma$1, f2$1, l2$1, cM);
              var opt$prime_001$1 = /* with_types */opt[/* with_types */1];
              var opt$prime$2 = /* record */[
                /* at_top : true */1,
                opt$prime_001$1,
                /* with_cs : false */0
              ];
              return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function(curenvnb,opt$prime$2){
                        return function (param, param$1, param$2) {
                          return unirec_rec(curenvnb, /* CONV */0, opt$prime$2, param, param$1, param$2);
                        }
                        }(curenvnb,opt$prime$2)), substn, match$7[1], match$7[0]);
            }
            catch (raw_ex$3){
              var ex$3 = Js_exn.internalToOCamlException(raw_ex$3);
              if (Pretype_errors$ReactTemplate.precatchable_exception(ex$3)) {
                var match$8 = EConstr$ReactTemplate.kind(sigma$1, cM);
                if (match$8.tag === 9) {
                  var l1$1 = match$8[1];
                  var f1$1 = match$8[0];
                  if (EConstr$ReactTemplate.isMeta(sigma$1, f1$1) && use_metas_pattern_unification(sigma$1, flags, nb, l1$1) || flags[/* use_pattern_unification */6] && isAllowedEvar(sigma$1, flags, f1$1)) {
                    return unify_app_pattern(/* true */1, curenvnb, pb, opt, substn, cM, f1$1, l1$1, cN, f2$1, l2$1);
                  } else {
                    throw ex$3;
                  }
                } else {
                  throw ex$3;
                }
              } else {
                throw ex$3;
              }
            }
          } else {
            exit$2 = 3;
          }
        } else {
          exit$2 = 3;
        }
      }
      if (exit$2 === 3) {
        if (match.tag === 9) {
          var l1$2 = match[1];
          var f1$2 = match[0];
          if (EConstr$ReactTemplate.isMeta(sigma$1, f1$2) && use_metas_pattern_unification(sigma$1, flags, nb, l1$2) || flags[/* use_pattern_unification */6] && isAllowedEvar(sigma$1, flags, f1$2)) {
            return unify_app_pattern(/* true */1, curenvnb, pb, opt, substn, cM, f1$2, l1$2, cN, cN, /* array */[]);
          } else {
            switch (match$1.tag | 0) {
              case 9 : 
                  exit$1 = 2;
                  break;
              case 16 : 
                  return unify_app(curenvnb, pb, opt, substn, cM, f1$2, l1$2, cN, cN, /* array */[]);
              default:
                exit = 1;
            }
          }
        } else {
          exit$1 = 2;
        }
      }
      if (exit$1 === 2) {
        if (match$1.tag === 9) {
          var l2$2 = match$1[1];
          var f2$2 = match$1[0];
          if (EConstr$ReactTemplate.isMeta(sigma$1, f2$2) && use_metas_pattern_unification(sigma$1, flags, nb, l2$2) || flags[/* use_pattern_unification */6] && isAllowedEvar(sigma$1, flags, f2$2)) {
            return unify_app_pattern(/* false */0, curenvnb, pb, opt, substn, cM, cM, /* array */[], cN, f2$2, l2$2);
          } else {
            switch (match.tag | 0) {
              case 9 : 
                  return unify_app(curenvnb, pb, opt, substn, cM, match[0], match[1], cN, match$1[0], match$1[1]);
              case 16 : 
                  return unify_app(curenvnb, pb, opt, substn, cM, cM, /* array */[], cN, match$1[0], match$1[1]);
              default:
                exit = 1;
            }
          }
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        return unify_not_same_head(curenvnb, pb, opt, substn, cM, cN);
      }
      
    };
  };
  var unify_app_pattern = function (dir, curenvnb, pb, opt, substn, cM, f1, l1, cN, f2, l2) {
    var sigma = substn[0];
    var match = dir ? /* tuple */[
        f1,
        l1,
        cN
      ] : /* tuple */[
        f2,
        l2,
        cM
      ];
    var t = match[2];
    var f = match[0];
    var match$1 = Evarsolve$ReactTemplate.is_unification_pattern(curenvnb, sigma, f, Util$ReactTemplate.$$Array[/* to_list */9](match[1]), t);
    if (match$1) {
      var param = curenvnb;
      var f$1 = f;
      var l = match$1[0];
      var c = t;
      var param$1 = substn;
      var evarsubst = param$1[2];
      var metasubst = param$1[1];
      var sigma$1 = param$1[0];
      var nb = param[1];
      var env = param[0];
      var match$2 = EConstr$ReactTemplate.kind(sigma$1, f$1);
      switch (match$2.tag | 0) {
        case 2 : 
            var env$prime = Environ$ReactTemplate.pop_rel_context(nb, env);
            var match$3 = pose_all_metas_as_evars(env$prime, sigma$1, c);
            var sigma$2 = match$3[0];
            var c$1 = Evarsolve$ReactTemplate.solve_pattern_eqn(env, sigma$2, l, match$3[1]);
            if (EConstr$ReactTemplate.Vars[/* noccur_between */13](sigma$2, 1, nb, c$1)) {
              return /* tuple */[
                      sigma$2,
                      /* :: */[
                        /* tuple */[
                          match$2[0],
                          EConstr$ReactTemplate.Vars[/* lift */0](-nb | 0, c$1),
                          /* tuple */[
                            /* Conv */2,
                            /* TypeNotProcessed */1
                          ]
                        ],
                        metasubst
                      ],
                      evarsubst
                    ];
            } else {
              var l$1 = Curry._2(Util$ReactTemplate.List[/* map */10], Evarsolve$ReactTemplate.of_alias, l);
              return Pretype_errors$ReactTemplate.error_cannot_unify_local(env, sigma$2, /* tuple */[
                          EConstr$ReactTemplate.applist(/* tuple */[
                                f$1,
                                l$1
                              ]),
                          c$1,
                          c$1
                        ]);
            }
            break;
        case 3 : 
            var env$prime$1 = Environ$ReactTemplate.pop_rel_context(nb, env);
            var match$4 = pose_all_metas_as_evars(env$prime$1, sigma$1, c);
            var sigma$3 = match$4[0];
            return /* tuple */[
                    sigma$3,
                    metasubst,
                    /* :: */[
                      /* tuple */[
                        env,
                        match$2[0],
                        Evarsolve$ReactTemplate.solve_pattern_eqn(env, sigma$3, l, match$4[1])
                      ],
                      evarsubst
                    ]
                  ];
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "unification.ml",
                  229,
                  11
                ]
              ];
      }
    } else {
      var match$5 = EConstr$ReactTemplate.kind(sigma, t);
      switch (match$5.tag | 0) {
        case 9 : 
            var l$prime = match$5[1];
            var f$prime = match$5[0];
            if (dir) {
              return unify_app(curenvnb, pb, opt, substn, cM, f1, l1, t, f$prime, l$prime);
            } else {
              return unify_app(curenvnb, pb, opt, substn, t, f$prime, l$prime, cN, f2, l2);
            }
        case 16 : 
            return unify_app(curenvnb, pb, opt, substn, cM, f1, l1, cN, f2, l2);
        default:
          return unify_not_same_head(curenvnb, pb, opt, substn, cM, cN);
      }
    }
  };
  var unify_app = function (curenvnb, pb, opt, substn, cM, f1, l1, cN, f2, l2) {
    var sigma = substn[0];
    var curenv = curenvnb[0];
    try {
      var needs_expansion = function (p, c$prime) {
        var match = EConstr$ReactTemplate.kind(sigma, c$prime);
        switch (match.tag | 0) {
          case 2 : 
          case 3 : 
              return /* true */1;
          case 10 : 
              return Names$ReactTemplate.Constant[/* equal */12](match[0][0], Names$ReactTemplate.Projection[/* constant */2](p));
          default:
            return /* false */0;
        }
      };
      var expand_proj = function (c, c$prime, l) {
        var match = EConstr$ReactTemplate.kind(sigma, c);
        if (match.tag === 16) {
          var p = match[0];
          if (!Names$ReactTemplate.Projection[/* unfolded */3](p) && needs_expansion(p, c$prime)) {
            try {
              return EConstr$ReactTemplate.destApp(sigma, Retyping$ReactTemplate.expand_projection(curenv, sigma, p, match[1], Util$ReactTemplate.$$Array[/* to_list */9](l)));
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Retyping$ReactTemplate.RetypeError) {
                return /* tuple */[
                        c,
                        l
                      ];
              } else {
                throw exn;
              }
            }
          } else {
            return /* tuple */[
                    c,
                    l
                  ];
          }
        } else {
          return /* tuple */[
                  c,
                  l
                ];
        }
      };
      var match = expand_proj(f1, f2, l1);
      var f1$1 = match[0];
      var match$1 = expand_proj(f2, f1$1, l2);
      var opta_002 = /* with_cs */opt[/* with_cs */2];
      var opta = /* record */[
        /* at_top : true */1,
        /* with_types : false */0,
        opta_002
      ];
      var optf_002 = /* with_cs */opt[/* with_cs */2];
      var optf = /* record */[
        /* at_top : true */1,
        /* with_types : true */1,
        optf_002
      ];
      var match$2 = Termops$ReactTemplate.adjust_app_array_size(f1$1, match[1], match$1[0], match$1[1]);
      var l1$1 = match$2[1];
      if (l1$1.length) {
        return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (param, param$1, param$2) {
                      return unirec_rec(curenvnb, /* CONV */0, opta, param, param$1, param$2);
                    }), unirec_rec(curenvnb, /* CONV */0, optf, substn, match$2[0], match$2[2]), l1$1, match$2[3]);
      } else {
        return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
                    cM,
                    cN
                  ]);
      }
    }
    catch (raw_ex){
      var ex = Js_exn.internalToOCamlException(raw_ex);
      if (Pretype_errors$ReactTemplate.precatchable_exception(ex)) {
        try {
          return reduce(curenvnb, pb, /* record */[
                      /* at_top */opt[/* at_top */0],
                      /* with_types : false */0,
                      /* with_cs */opt[/* with_cs */2]
                    ], substn, cM, cN);
        }
        catch (raw_ex$1){
          var ex$1 = Js_exn.internalToOCamlException(raw_ex$1);
          if (Pretype_errors$ReactTemplate.precatchable_exception(ex$1)) {
            try {
              return canonical_projections(curenvnb, pb, opt, cM, cN, substn);
            }
            catch (raw_ex$2){
              var ex$2 = Js_exn.internalToOCamlException(raw_ex$2);
              if (Pretype_errors$ReactTemplate.precatchable_exception(ex$2)) {
                return expand(curenvnb, pb, /* record */[
                            /* at_top */opt[/* at_top */0],
                            /* with_types : false */0,
                            /* with_cs */opt[/* with_cs */2]
                          ], substn, cM, f1, l1, cN, f2, l2);
              } else {
                throw ex$2;
              }
            }
          } else {
            throw ex$1;
          }
        }
      } else {
        throw ex;
      }
    }
  };
  var unify_not_same_head = function (curenvnb, pb, opt, substn, cM, cN) {
    var sigma = substn[0];
    try {
      return canonical_projections(curenvnb, pb, opt, cM, cN, substn);
    }
    catch (raw_ex){
      var ex = Js_exn.internalToOCamlException(raw_ex);
      if (Pretype_errors$ReactTemplate.precatchable_exception(ex)) {
        var match = constr_cmp(cv_pb, env, sigma, flags, cM, cN);
        if (match[1]) {
          return /* tuple */[
                  match[0],
                  substn[1],
                  substn[2]
                ];
        } else {
          try {
            return reduce(curenvnb, pb, opt, substn, cM, cN);
          }
          catch (raw_ex$1){
            var ex$1 = Js_exn.internalToOCamlException(raw_ex$1);
            if (Pretype_errors$ReactTemplate.precatchable_exception(ex$1)) {
              var match$1 = EConstr$ReactTemplate.kind(sigma, cM);
              var match$2;
              match$2 = match$1.tag === 9 ? /* tuple */[
                  match$1[0],
                  match$1[1]
                ] : /* tuple */[
                  cM,
                  /* array */[]
                ];
              var match$3 = EConstr$ReactTemplate.kind(sigma, cN);
              var match$4;
              match$4 = match$3.tag === 9 ? /* tuple */[
                  match$3[0],
                  match$3[1]
                ] : /* tuple */[
                  cN,
                  /* array */[]
                ];
              return expand(curenvnb, pb, opt, substn, cM, match$2[0], match$2[1], cN, match$4[0], match$4[1]);
            } else {
              throw ex$1;
            }
          }
        }
      } else {
        throw ex;
      }
    }
  };
  var reduce = function (curenvnb, pb, opt, substn, cM, cN) {
    var sigma = substn[0];
    if (flags[/* modulo_betaiota */10] && !subterm_restriction(opt, flags)) {
      var cM$prime = do_reduce(flags[/* modulo_delta */3], curenvnb, sigma, cM);
      if (EConstr$ReactTemplate.eq_constr(sigma, cM, cM$prime)) {
        var cN$prime = do_reduce(flags[/* modulo_delta */3], curenvnb, sigma, cN);
        if (EConstr$ReactTemplate.eq_constr(sigma, cN, cN$prime)) {
          return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
                      cM,
                      cN
                    ]);
        } else {
          return unirec_rec(curenvnb, pb, opt, substn, cM, cN$prime);
        }
      } else {
        return unirec_rec(curenvnb, pb, opt, substn, cM$prime, cN);
      }
    } else {
      return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
                  cM,
                  cN
                ]);
    }
  };
  var expand = function (curenvnb, pb, opt, substn, cM, f1, l1, cN, f2, l2) {
    var evarsubst = substn[2];
    var metasubst = substn[1];
    var sigma = substn[0];
    var curenv = curenvnb[0];
    var res;
    if (subterm_restriction(opt, flags)) {
      res = /* None */0;
    } else {
      var match = flags[/* modulo_conv_on_closed_terms */0];
      if (match) {
        var subst_000 = flags[/* use_metas_eagerly_in_conv_on_closed_terms */1] ? metasubst : ms;
        var subst_001 = flags[/* use_evars_eagerly_in_conv_on_closed_terms */2] ? evarsubst : es;
        var subst = /* tuple */[
          subst_000,
          subst_001
        ];
        var match$1 = subst_defined_metas_evars(sigma, subst, cM);
        if (match$1) {
          var m1 = match$1[0];
          var match$2 = subst_defined_metas_evars(sigma, subst, cN);
          if (match$2) {
            var n1 = match$2[0];
            var sigma$1;
            if (opt[/* with_types */1]) {
              try {
                var tyM = Retyping$ReactTemplate.get_type_of(/* None */0, /* Some */[/* true */1], curenv, sigma, m1);
                var tyN = Retyping$ReactTemplate.get_type_of(/* None */0, /* Some */[/* true */1], curenv, sigma, n1);
                sigma$1 = check_compatibility(curenv, /* CUMUL */1, flags, substn, tyM, tyN);
              }
              catch (raw_exn){
                var exn = Js_exn.internalToOCamlException(raw_exn);
                if (exn[0] === Retyping$ReactTemplate.RetypeError) {
                  sigma$1 = sigma;
                } else {
                  throw exn;
                }
              }
            } else {
              sigma$1 = sigma;
            }
            var match$3 = Reductionops$ReactTemplate.infer_conv(/* None */0, /* Some */[pb], /* Some */[match[0]], curenv, sigma$1, m1, n1);
            var sigma$2 = match$3[0];
            res = match$3[1] ? /* Some */[/* tuple */[
                  sigma$2,
                  metasubst,
                  evarsubst
                ]] : (
                Evarutil$ReactTemplate.is_ground_term(sigma$2, m1) && Evarutil$ReactTemplate.is_ground_term(sigma$2, n1) ? Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenv, sigma$2, /* None */0, /* tuple */[
                        cM,
                        cN
                      ]) : /* None */0
              );
          } else {
            res = /* None */0;
          }
        } else {
          res = /* None */0;
        }
      } else {
        res = /* None */0;
      }
    }
    if (res) {
      return res[0];
    } else {
      var cf1 = key_of(curenv, sigma, opt, flags, f1);
      var cf2 = key_of(curenv, sigma, opt, flags, f2);
      var match$4 = oracle_order(curenv, cf1, cf2);
      if (match$4) {
        if (match$4[0] !== 0) {
          var match$5 = expand_key(flags[/* modulo_delta */3], curenv, sigma, cf1);
          if (match$5) {
            return unirec_rec(curenvnb, pb, opt, substn, Reductionops$ReactTemplate.whd_betaiotazeta(sigma, EConstr$ReactTemplate.mkApp(/* tuple */[
                                match$5[0],
                                l1
                              ])), cN);
          } else {
            var match$6 = expand_key(flags[/* modulo_delta */3], curenv, sigma, cf2);
            if (match$6) {
              return unirec_rec(curenvnb, pb, opt, substn, cM, Reductionops$ReactTemplate.whd_betaiotazeta(sigma, EConstr$ReactTemplate.mkApp(/* tuple */[
                                  match$6[0],
                                  l2
                                ])));
            } else {
              return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenv, sigma, /* None */0, /* tuple */[
                          cM,
                          cN
                        ]);
            }
          }
        } else {
          var match$7 = expand_key(flags[/* modulo_delta */3], curenv, sigma, cf2);
          if (match$7) {
            return unirec_rec(curenvnb, pb, opt, substn, cM, Reductionops$ReactTemplate.whd_betaiotazeta(sigma, EConstr$ReactTemplate.mkApp(/* tuple */[
                                match$7[0],
                                l2
                              ])));
          } else {
            var match$8 = expand_key(flags[/* modulo_delta */3], curenv, sigma, cf1);
            if (match$8) {
              return unirec_rec(curenvnb, pb, opt, substn, Reductionops$ReactTemplate.whd_betaiotazeta(sigma, EConstr$ReactTemplate.mkApp(/* tuple */[
                                  match$8[0],
                                  l1
                                ])), cN);
            } else {
              return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenv, sigma, /* None */0, /* tuple */[
                          cM,
                          cN
                        ]);
            }
          }
        }
      } else {
        return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenv, sigma, /* None */0, /* tuple */[
                    cM,
                    cN
                  ]);
      }
    }
  };
  var canonical_projections = function (curenvnb, pb, opt, cM, cN, substn) {
    var sigma = substn[0];
    var curenv = curenvnb[0];
    var match = flags[/* modulo_conv_on_closed_terms */0];
    if (!opt[/* with_cs */2] || (
        match ? subterm_restriction(opt, flags) : /* true */1
      )) {
      return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
                  cM,
                  cN
                ]);
    } else {
      try {
        if (isApp_or_Proj(sigma, cM)) {
          var f1l1 = Reductionops$ReactTemplate.whd_nored_state(sigma)(/* tuple */[
                cM,
                Reductionops$ReactTemplate.Stack[/* empty */2]
              ]);
          if (Recordops$ReactTemplate.is_open_canonical_projection(curenv, sigma, f1l1)) {
            var f2l2 = Reductionops$ReactTemplate.whd_nored_state(sigma)(/* tuple */[
                  cN,
                  Reductionops$ReactTemplate.Stack[/* empty */2]
                ]);
            return solve_canonical_projection(curenvnb, pb, opt, cM, f1l1, cN, f2l2, substn);
          } else {
            return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
                        cM,
                        cN
                      ]);
          }
        } else {
          return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
                      cM,
                      cN
                    ]);
        }
      }
      catch (raw_e){
        var e = Js_exn.internalToOCamlException(raw_e);
        if (Pretype_errors$ReactTemplate.precatchable_exception(e)) {
          if (isApp_or_Proj(sigma, cN)) {
            var f2l2$1 = Reductionops$ReactTemplate.whd_nored_state(sigma)(/* tuple */[
                  cN,
                  Reductionops$ReactTemplate.Stack[/* empty */2]
                ]);
            if (Recordops$ReactTemplate.is_open_canonical_projection(curenv, sigma, f2l2$1)) {
              var f1l1$1 = Reductionops$ReactTemplate.whd_nored_state(sigma)(/* tuple */[
                    cM,
                    Reductionops$ReactTemplate.Stack[/* empty */2]
                  ]);
              return solve_canonical_projection(curenvnb, pb, opt, cN, f2l2$1, cM, f1l1$1, substn);
            } else {
              return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
                          cM,
                          cN
                        ]);
            }
          } else {
            return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
                        cM,
                        cN
                      ]);
          }
        } else {
          throw e;
        }
      }
    }
  };
  var solve_canonical_projection = function (curenvnb, pb, opt, cM, f1l1, cN, f2l2, param) {
    var sigma = param[0];
    var match;
    try {
      match = Evarconv$ReactTemplate.check_conv_record(curenvnb[0], sigma, f1l1, f2l2);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        match = Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
              cM,
              cN
            ]);
      } else {
        throw exn;
      }
    }
    var match$1 = match[8];
    var t2 = match$1[1];
    var n = match$1[0];
    var match$2 = match[6];
    var ts1 = match$2[1];
    var ts = match$2[0];
    var match$3 = match[5];
    var match$4 = match[4];
    var bs = match[3];
    if (Reductionops$ReactTemplate.Stack[/* compare_shape */7](ts, ts1)) {
      var sigma$1 = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible, sigma, match[0]);
      var match$5 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, b) {
              var m = param[2];
              var ks = param[1];
              var evd = param[0];
              if (n ? +(m === n[0]) : /* false */0) {
                return /* tuple */[
                        evd,
                        /* :: */[
                          t2,
                          ks
                        ],
                        m - 1 | 0
                      ];
              } else {
                var mv = Evarutil$ReactTemplate.new_meta(/* () */0);
                var evd$prime = Evd$ReactTemplate.meta_declare(mv, EConstr$ReactTemplate.Unsafe[/* to_constr */0](EConstr$ReactTemplate.Vars[/* substl */3](ks, b)), /* None */0, evd);
                return /* tuple */[
                        evd$prime,
                        /* :: */[
                          EConstr$ReactTemplate.mkMeta(mv),
                          ks
                        ],
                        m - 1 | 0
                      ];
              }
            }), /* tuple */[
            sigma$1,
            /* [] */0,
            Curry._1(Util$ReactTemplate.List[/* length */0], bs)
          ], bs);
      var ks = match$5[1];
      try {
        var opt$prime_000 = /* at_top */opt[/* at_top */0];
        var opt$prime_002 = /* with_cs */opt[/* with_cs */2];
        var opt$prime = /* record */[
          opt$prime_000,
          /* with_types : false */0,
          opt$prime_002
        ];
        var substn = Reductionops$ReactTemplate.Stack[/* fold2 */9]((function (s, u1, u) {
                return unirec_rec(curenvnb, pb, opt$prime, s, u1, EConstr$ReactTemplate.Vars[/* substl */3](ks, u));
              }), /* tuple */[
              match$5[0],
              param[1],
              param[2]
            ], match$3[1], match$3[0]);
        var substn$1 = Reductionops$ReactTemplate.Stack[/* fold2 */9]((function (s, u1, u) {
                return unirec_rec(curenvnb, pb, opt$prime, s, u1, EConstr$ReactTemplate.Vars[/* substl */3](ks, u));
              }), substn, match$4[1], match$4[0]);
        var substn$2 = Reductionops$ReactTemplate.Stack[/* fold2 */9]((function (s, u1, u2) {
                return unirec_rec(curenvnb, pb, opt$prime, s, u1, u2);
              }), substn$1, ts, ts1);
        var app = EConstr$ReactTemplate.mkApp(/* tuple */[
              match[2],
              Util$ReactTemplate.$$Array[/* rev_of_list */62](ks)
            ]);
        return unirec_rec(curenvnb, pb, opt$prime, substn$2, match[7], app);
      }
      catch (exn$1){
        if (exn$1 === Reductionops$ReactTemplate.Stack[/* IncompatibleFold2 */8]) {
          return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma$1, /* None */0, /* tuple */[
                      cM,
                      cN
                    ]);
        } else {
          throw exn$1;
        }
      }
    } else {
      return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenvnb[0], sigma, /* None */0, /* tuple */[
                  cM,
                  cN
                ]);
    }
  };
  if (debug_unification[0]) {
    Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.str("Starting unification"));
  }
  var opt = /* record */[
    /* at_top */conv_at_top,
    /* with_types : false */0,
    /* with_cs : true */1
  ];
  try {
    var res;
    if (subterm_restriction(opt, flags) || occur_meta_or_undefined_evar(sigma, m) || occur_meta_or_undefined_evar(sigma, n)) {
      res = /* None */0;
    } else {
      var match = flags[/* modulo_conv_on_closed_terms */0];
      var match$1 = match ? Reductionops$ReactTemplate.infer_conv(/* None */0, /* Some */[cv_pb], /* Some */[match[0]], env, sigma, m, n) : constr_cmp(cv_pb, env, sigma, flags, m, n);
      var sigma$1 = match$1[0];
      if (match$1[1]) {
        res = /* Some */[sigma$1];
      } else {
        var match$2 = flags[/* modulo_conv_on_closed_terms */0];
        var match$3 = flags[/* modulo_delta */3];
        var tmp;
        if (match$2) {
          var match$4 = match$2[0];
          tmp = Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* subset */13], match$3[0], match$4[0]) && Curry._2(Names$ReactTemplate.Cpred[/* subset */13], match$3[1], match$4[1]);
        } else {
          tmp = Curry._1(Names$ReactTemplate.Id[/* Pred */11][/* is_empty */2], match$3[0]) && Curry._1(Names$ReactTemplate.Cpred[/* is_empty */2], match$3[1]);
        }
        res = tmp ? Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, env, sigma$1, /* None */0, /* tuple */[
                m,
                n
              ]) : /* None */0;
      }
    }
    var a = res ? /* tuple */[
        res[0],
        ms,
        es
      ] : unirec_rec(/* tuple */[
            env,
            0
          ], cv_pb, opt, subst, m, n);
    if (debug_unification[0]) {
      Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.str("Leaving unification with success"));
    }
    return a;
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    var e$1 = CErrors$ReactTemplate.push(e);
    if (debug_unification[0]) {
      Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.str("Leaving unification with failure"));
    }
    return Util$ReactTemplate.iraise(e$1);
  }
}

function unify_0(env, sigma) {
  var partial_arg = /* tuple */[
    sigma,
    /* [] */0,
    /* [] */0
  ];
  return (function (param, param$1, param$2, param$3) {
      return unify_0_with_initial_metas(partial_arg, /* true */1, env, param, param$1, param$2, param$3);
    });
}

function unify_with_eta(_keptside, flags, _env, sigma, _c1, _c2) {
  while(true) {
    var c2 = _c2;
    var c1 = _c1;
    var env = _env;
    var keptside = _keptside;
    var match = EConstr$ReactTemplate.kind(sigma, c1);
    var match$1 = EConstr$ReactTemplate.kind(sigma, c2);
    if (match.tag === 7) {
      var c1$prime = match[2];
      var t1 = match[1];
      var na = match[0];
      if (match$1.tag === 7) {
        var env$prime = Termops$ReactTemplate.push_rel_assum(/* tuple */[
              na,
              t1
            ], env);
        var match$2 = unify_0(env, sigma)(/* CONV */0, flags, t1, match$1[1]);
        var match$3 = unify_with_eta(keptside, flags, env$prime, match$2[0], c1$prime, match$1[2]);
        var match$4 = match$3[1];
        return /* tuple */[
                match$3[0],
                /* tuple */[
                  match$4[0],
                  Util$ReactTemplate.$at(match$2[1], match$4[1]),
                  Util$ReactTemplate.$at(match$2[2], match$4[2])
                ]
              ];
      } else {
        var env$prime$1 = Termops$ReactTemplate.push_rel_assum(/* tuple */[
              na,
              t1
            ], env);
        _c2 = EConstr$ReactTemplate.mkApp(/* tuple */[
              EConstr$ReactTemplate.Vars[/* lift */0](1, c2),
              /* array */[EConstr$ReactTemplate.mkRel(1)]
            ]);
        _c1 = c1$prime;
        _env = env$prime$1;
        _keptside = /* true */1;
        continue ;
        
      }
    } else if (match$1.tag === 7) {
      var env$prime$2 = Termops$ReactTemplate.push_rel_assum(/* tuple */[
            match$1[0],
            match$1[1]
          ], env);
      _c2 = match$1[2];
      _c1 = EConstr$ReactTemplate.mkApp(/* tuple */[
            EConstr$ReactTemplate.Vars[/* lift */0](1, c1),
            /* array */[EConstr$ReactTemplate.mkRel(1)]
          ]);
      _env = env$prime$2;
      _keptside = /* false */0;
      continue ;
      
    } else {
      return /* tuple */[
              keptside,
              unify_0(env, sigma)(/* CONV */0, flags, c1, c2)
            ];
    }
  };
}

function merge_instances(env, sigma, flags, st1, st2, c1, c2) {
  var match = opp_status(st1);
  var exit = 0;
  var exit$1 = 0;
  switch (match) {
    case 0 : 
        if (st2 !== 1) {
          exit = 1;
        } else {
          try {
            return /* tuple */[
                    /* true */1,
                    /* IsSubType */1,
                    unify_0(env, sigma)(/* CUMUL */1, flags, c2, c1)
                  ];
          }
          catch (raw_e){
            var e = Js_exn.internalToOCamlException(raw_e);
            if (CErrors$ReactTemplate.noncritical(e)) {
              return /* tuple */[
                      /* false */0,
                      /* IsSubType */1,
                      unify_0(env, sigma)(/* CUMUL */1, flags, c1, c2)
                    ];
            } else {
              throw e;
            }
          }
        }
        break;
    case 1 : 
        if (st2 !== 0) {
          exit$1 = 2;
        } else {
          try {
            return /* tuple */[
                    /* true */1,
                    /* IsSuperType */0,
                    unify_0(env, sigma)(/* CUMUL */1, flags, c1, c2)
                  ];
          }
          catch (raw_e$1){
            var e$1 = Js_exn.internalToOCamlException(raw_e$1);
            if (CErrors$ReactTemplate.noncritical(e$1)) {
              return /* tuple */[
                      /* false */0,
                      /* IsSuperType */0,
                      unify_0(env, sigma)(/* CUMUL */1, flags, c2, c1)
                    ];
            } else {
              throw e$1;
            }
          }
        }
        break;
    case 2 : 
        if (st2 >= 2) {
          var match$1 = unify_with_eta(/* true */1, flags, env, sigma, c1, c2);
          return /* tuple */[
                  match$1[0],
                  /* Conv */2,
                  match$1[1]
                ];
        } else {
          exit$1 = 2;
        }
        break;
    
  }
  if (exit$1 === 2) {
    if (st2 !== 0) {
      var res = unify_0(env, sigma)(/* CUMUL */1, flags, c2, c1);
      if (Evd$ReactTemplate.eq_instance_constraint(match, st2)) {
        return /* tuple */[
                /* true */1,
                st1,
                res
              ];
      } else if (Evd$ReactTemplate.eq_instance_constraint(st2, /* IsSubType */1)) {
        return /* tuple */[
                /* true */1,
                st1,
                res
              ];
      } else {
        return /* tuple */[
                /* false */0,
                st2,
                res
              ];
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    var res$1 = unify_0(env, sigma)(/* CUMUL */1, flags, c1, c2);
    if (Evd$ReactTemplate.eq_instance_constraint(match, st2)) {
      return /* tuple */[
              /* true */1,
              st1,
              res$1
            ];
    } else if (Evd$ReactTemplate.eq_instance_constraint(st2, /* IsSuperType */0)) {
      return /* tuple */[
              /* true */1,
              st1,
              res$1
            ];
    } else {
      return /* tuple */[
              /* false */0,
              st2,
              res$1
            ];
    }
  }
  
}

function applyHead(env, evd, n, c) {
  var _n = n;
  var _c = c;
  var _cty = Typing$ReactTemplate.unsafe_type_of(env, evd, c);
  var _evd = evd;
  while(true) {
    var evd$1 = _evd;
    var cty = _cty;
    var c$1 = _c;
    var n$1 = _n;
    if (n$1) {
      var match = EConstr$ReactTemplate.kind(evd$1, Reductionops$ReactTemplate.whd_all(env)(evd$1, cty));
      if (match.tag === 6) {
        var match$1 = Evarutil$ReactTemplate.new_evar(env, evd$1, /* Some */[Loc$ReactTemplate.tag(/* None */0, /* GoalEvar */1)], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, match[1]);
        var evar = match$1[1];
        _evd = match$1[0];
        _cty = EConstr$ReactTemplate.Vars[/* subst1 */4](evar, match[2]);
        _c = EConstr$ReactTemplate.mkApp(/* tuple */[
              c$1,
              /* array */[evar]
            ]);
        _n = n$1 - 1 | 0;
        continue ;
        
      } else {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Apply_Head_Then"));
      }
    } else {
      return /* tuple */[
              evd$1,
              c$1
            ];
    }
  };
}

function is_mimick_head(sigma, ts, f) {
  var match = EConstr$ReactTemplate.kind(sigma, f);
  switch (match.tag | 0) {
    case 1 : 
        return 1 - CClosure$ReactTemplate.is_transparent_variable(ts, match[0]);
    case 10 : 
        return 1 - CClosure$ReactTemplate.is_transparent_constant(ts, match[0][0]);
    case 0 : 
    case 11 : 
    case 12 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function try_to_coerce(env, evd, c, cty, tycon) {
  var j = Environ$ReactTemplate.make_judge(c, cty);
  var match = Coercion$ReactTemplate.inh_conv_coerce_rigid_to(/* None */0, /* true */1)(env, evd, j, tycon);
  var evd$prime = Evarconv$ReactTemplate.solve_unif_constraints_with_heuristics(env, /* None */0, match[0]);
  var evd$prime$1 = Evd$ReactTemplate.map_metas_fvalue((function (c) {
          return EConstr$ReactTemplate.Unsafe[/* to_constr */0](Evarutil$ReactTemplate.nf_evar(evd$prime, EConstr$ReactTemplate.of_constr(c)));
        }), evd$prime);
  return /* tuple */[
          evd$prime$1,
          match[1][/* uj_val */0]
        ];
}

function w_coerce_to_type(env, evd, c, cty, mvty) {
  var match = pose_all_metas_as_evars(env, evd, mvty);
  var tycon = match[1];
  var evd$1 = match[0];
  try {
    return try_to_coerce(env, evd$1, c, cty, tycon);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (Pretype_errors$ReactTemplate.precatchable_exception(e)) {
      var cty$1 = Tacred$ReactTemplate.hnf_constr(env, evd$1, cty);
      return try_to_coerce(env, evd$1, c, cty$1, tycon);
    } else {
      throw e;
    }
  }
}

function w_coerce(env, evd, mv, c) {
  var cty = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, evd, c);
  var mvty = Typing$ReactTemplate.meta_type(evd, mv);
  return w_coerce_to_type(env, evd, c, cty, mvty);
}

function unify_type(env, sigma, flags, mv, status, c) {
  var mvty = Typing$ReactTemplate.meta_type(sigma, mv);
  var mvty$1 = Reductionops$ReactTemplate.nf_meta(sigma, mvty);
  var env$1 = env;
  var sigma$1 = sigma;
  var flags$1 = set_flags_for_type(flags);
  var c$1 = c;
  var u = mvty$1;
  var match = Evarsolve$ReactTemplate.refresh_universes(/* None */0, /* None */0, /* None */0, /* Some */[/* false */0], env$1, sigma$1, c$1);
  var sigma$2 = match[0];
  var t = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env$1, sigma$2, Reductionops$ReactTemplate.nf_meta(sigma$2, match[1]));
  var t$1 = Reductionops$ReactTemplate.nf_betaiota(env$1, sigma$2, Reductionops$ReactTemplate.nf_meta(sigma$2, t));
  return unify_0(env$1, sigma$2)(/* CUMUL */1, flags$1, t$1, u);
}

function order_metas(metas) {
  var order = function (_latemetas, _param) {
    while(true) {
      var param = _param;
      var latemetas = _latemetas;
      if (param) {
        var meta = param[0];
        if (meta[2][1] !== 0) {
          return /* :: */[
                  meta,
                  order(latemetas, param[1])
                ];
        } else {
          _param = param[1];
          _latemetas = /* :: */[
            meta,
            latemetas
          ];
          continue ;
          
        }
      } else {
        return Curry._1(Util$ReactTemplate.List[/* rev */4], latemetas);
      }
    };
  };
  return order(/* [] */0, metas);
}

function solve_simple_evar_eqn(ts, env, evd, ev, rhs) {
  var match = Evarsolve$ReactTemplate.solve_simple_eqn(Evarconv$ReactTemplate.evar_conv_x(ts), /* None */0, env, evd, /* tuple */[
        /* None */0,
        ev,
        rhs
      ]);
  if (match.tag) {
    return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, env, match[0], /* Some */[match[1]], /* tuple */[
                EConstr$ReactTemplate.mkEvar(ev),
                rhs
              ]);
  } else {
    return match[0];
  }
}

function w_merge(env, with_types, flags, param) {
  var w_merge_rec = function (_evd, _metas, _evars, _eqns) {
    while(true) {
      var eqns = _eqns;
      var evars = _evars;
      var metas = _metas;
      var evd = _evd;
      if (evars) {
        var evars$prime = evars[1];
        var match = evars[0];
        var rhs = match[2];
        var ev = match[1];
        var evk = ev[0];
        var curenv = match[0];
        if (Evd$ReactTemplate.is_defined(evd, evk)) {
          var v = EConstr$ReactTemplate.mkEvar(ev);
          var match$1 = unify_0(curenv, evd)(/* CONV */0, flags, rhs, v);
          _evars = Util$ReactTemplate.$at(match$1[2], evars$prime);
          _metas = Util$ReactTemplate.$at(match$1[1], metas);
          _evd = match$1[0];
          continue ;
          
        } else {
          var rhs$prime = subst_meta_instances(evd, metas, rhs);
          var match$2 = EConstr$ReactTemplate.kind(evd, rhs);
          var exit = 0;
          if (match$2.tag === 9) {
            var f = match$2[0];
            if (Termops$ReactTemplate.occur_meta(evd, rhs$prime)) {
              if (Termops$ReactTemplate.occur_evar(evd, evk, rhs$prime)) {
                Pretype_errors$ReactTemplate.error_occur_check(curenv, evd, evk, rhs$prime);
              }
              if (is_mimick_head(evd, flags[/* modulo_delta */3], f)) {
                var evd$prime = mimick_undefined_evar(evd, flags, f, match$2[1].length, evk);
                _evd = evd$prime;
                continue ;
                
              } else {
                var match$3 = pose_all_metas_as_evars(curenv, evd, rhs$prime);
                var rhs$prime$prime = match$3[1];
                var evd$prime$1 = match$3[0];
                var evd$prime$2;
                try {
                  evd$prime$2 = solve_simple_evar_eqn(flags[/* modulo_delta_types */4], curenv, evd$prime$1, ev, rhs$prime$prime);
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === Retyping$ReactTemplate.RetypeError) {
                    evd$prime$2 = Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenv, evd$prime$1, /* None */0, /* tuple */[
                          EConstr$ReactTemplate.mkEvar(ev),
                          rhs$prime$prime
                        ]);
                  } else {
                    throw exn;
                  }
                }
                _evars = evars$prime;
                _evd = evd$prime$2;
                continue ;
                
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var match$4 = pose_all_metas_as_evars(curenv, evd, rhs$prime);
            var rhs$prime$prime$1 = match$4[1];
            var evd$prime$3 = match$4[0];
            var evd$prime$4;
            try {
              evd$prime$4 = solve_simple_evar_eqn(flags[/* modulo_delta_types */4], curenv, evd$prime$3, ev, rhs$prime$prime$1);
            }
            catch (raw_exn$1){
              var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
              if (exn$1[0] === Retyping$ReactTemplate.RetypeError) {
                evd$prime$4 = Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, curenv, evd$prime$3, /* None */0, /* tuple */[
                      EConstr$ReactTemplate.mkEvar(ev),
                      rhs$prime$prime$1
                    ]);
              } else {
                throw exn$1;
              }
            }
            _evars = evars$prime;
            _evd = evd$prime$4;
            continue ;
            
          }
          
        }
      } else if (metas) {
        var metas$1 = metas[1];
        var match$5 = metas[0];
        var match$6 = match$5[2];
        var to_type = match$6[1];
        var status = match$6[0];
        var c = match$5[1];
        var mv = match$5[0];
        var match$7 = with_types && to_type !== /* TypeProcessed */2 ? (
            to_type !== 0 ? /* tuple */[
                /* tuple */[
                  /* tuple */[
                    evd,
                    c
                  ],
                  /* tuple */[
                    /* [] */0,
                    /* [] */0
                  ]
                ],
                /* :: */[
                  /* tuple */[
                    mv,
                    status,
                    c
                  ],
                  eqns
                ]
              ] : /* tuple */[
                /* tuple */[
                  w_coerce(env, evd, mv, c),
                  /* tuple */[
                    /* [] */0,
                    /* [] */0
                  ]
                ],
                eqns
              ]
          ) : /* tuple */[
            /* tuple */[
              /* tuple */[
                evd,
                c
              ],
              /* tuple */[
                /* [] */0,
                /* [] */0
              ]
            ],
            eqns
          ];
        var eqns$1 = match$7[1];
        var match$8 = match$7[0];
        var match$9 = match$8[1];
        var evars$prime$prime = match$9[1];
        var metas$prime$prime = match$9[0];
        var match$10 = match$8[0];
        var c$1 = match$10[1];
        var evd$1 = match$10[0];
        if (Evd$ReactTemplate.meta_defined(evd$1, mv)) {
          var match$11 = Evd$ReactTemplate.meta_fvalue(evd$1, mv);
          var match$12 = merge_instances(env, evd$1, flags, match$11[1][0], status, EConstr$ReactTemplate.of_constr(match$11[0][/* rebus */0]), c$1);
          var match$13 = match$12[2];
          var evd$2 = match$13[0];
          var evd$prime$5 = match$12[0] ? evd$2 : Evd$ReactTemplate.meta_reassign(mv, /* tuple */[
                  EConstr$ReactTemplate.Unsafe[/* to_constr */0](c$1),
                  /* tuple */[
                    match$12[1],
                    /* TypeProcessed */2
                  ]
                ], evd$2);
          _eqns = eqns$1;
          _evars = Util$ReactTemplate.$at(match$13[2], evars$prime$prime);
          _metas = Util$ReactTemplate.$at(match$13[1], Util$ReactTemplate.$at(metas$1, metas$prime$prime));
          _evd = evd$prime$5;
          continue ;
          
        } else {
          var evd$prime$6 = occur_meta_evd(evd$1, mv, c$1) ? (
              Termops$ReactTemplate.isMetaOf(evd$1, mv, Reductionops$ReactTemplate.whd_all(env)(evd$1, c$1)) ? evd$1 : Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, env, evd$1, /* None */0, /* tuple */[
                      EConstr$ReactTemplate.mkMeta(mv),
                      c$1
                    ])
            ) : Evd$ReactTemplate.meta_assign(mv, /* tuple */[
                  EConstr$ReactTemplate.Unsafe[/* to_constr */0](c$1),
                  /* tuple */[
                    status,
                    /* TypeProcessed */2
                  ]
                ], evd$1);
          _eqns = eqns$1;
          _evars = evars$prime$prime;
          _metas = Util$ReactTemplate.$at(metas$prime$prime, metas$1);
          _evd = evd$prime$6;
          continue ;
          
        }
      } else {
        var _failures = /* [] */0;
        var _param = eqns;
        while(true) {
          var param = _param;
          var failures = _failures;
          if (param) {
            var eqns$2 = param[1];
            var match$14 = param[0];
            var c$2 = match$14[2];
            var status$1 = match$14[1];
            var mv$1 = match$14[0];
            var match$15;
            try {
              match$15 = /* Inl */Block.__(0, [unify_type(env, evd, flags, mv$1, status$1, c$2)]);
            }
            catch (raw_e){
              var e = Js_exn.internalToOCamlException(raw_e);
              if (CErrors$ReactTemplate.noncritical(e)) {
                match$15 = /* Inr */Block.__(1, [e]);
              } else {
                throw e;
              }
            }
            if (match$15.tag) {
              _param = eqns$2;
              _failures = /* :: */[
                /* tuple */[
                  /* tuple */[
                    mv$1,
                    status$1,
                    c$2
                  ],
                  match$15[0]
                ],
                failures
              ];
              continue ;
              
            } else {
              var match$16 = match$15[0];
              return w_merge_rec(match$16[0], match$16[1], match$16[2], Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                    return prim[0];
                                  }), failures), eqns$2));
            }
          } else if (failures) {
            throw failures[0][1];
          } else {
            return evd;
          }
        };
      }
    };
  };
  var mimick_undefined_evar = function (evd, flags, hdc, nargs, sp) {
    var ev = Evd$ReactTemplate.find_undefined(evd, sp);
    var sp_env = Global$ReactTemplate.env_of_context(ev[/* evar_hyps */1]);
    var match = applyHead(sp_env, evd, nargs, hdc);
    var c = match[1];
    var evd$prime = match[0];
    var match$1 = unify_0(sp_env, evd$prime)(/* CUMUL */1, flags, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, sp_env, evd$prime, c), EConstr$ReactTemplate.of_constr(ev[/* evar_concl */0]));
    var evd$prime$prime$prime = w_merge_rec(match$1[0], match$1[1], match$1[2], /* [] */0);
    if (evd$prime === evd$prime$prime$prime) {
      return Evd$ReactTemplate.define(sp, EConstr$ReactTemplate.Unsafe[/* to_constr */0](c), evd$prime$prime$prime);
    } else {
      return Evd$ReactTemplate.define(sp, EConstr$ReactTemplate.Unsafe[/* to_constr */0](Evarutil$ReactTemplate.nf_evar(evd$prime$prime$prime, c)), evd$prime$prime$prime);
    }
  };
  var res = w_merge_rec(param[0], order_metas(param[1]), Curry._1(Util$ReactTemplate.List[/* rev */4], param[2]), /* [] */0);
  if (with_types) {
    var evd = res;
    var metas = Evd$ReactTemplate.meta_list(evd);
    var eqns = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
            var b = param[1];
            if (b.tag) {
              var match = b[1];
              var match$1 = match[1];
              if (match$1[1] !== 1) {
                return acc;
              } else {
                return /* :: */[
                        /* tuple */[
                          param[0],
                          match$1[0],
                          EConstr$ReactTemplate.of_constr(match[0][/* rebus */0])
                        ],
                        acc
                      ];
              }
            } else {
              return acc;
            }
          }), /* [] */0, metas);
    return w_merge_rec(evd, /* [] */0, /* [] */0, eqns);
  } else {
    return res;
  }
}

function retract_coercible_metas(evd) {
  var match = Evd$ReactTemplate.retract_coercible_metas(evd);
  var map = function (param) {
    return /* tuple */[
            param[0],
            EConstr$ReactTemplate.of_constr(param[1]),
            param[2]
          ];
  };
  return /* tuple */[
          Curry._2(Util$ReactTemplate.List[/* map */10], map, match[0]),
          match[1]
        ];
}

function w_unify_meta_types(env, $staropt$star, evd) {
  var flags = $staropt$star ? $staropt$star[0] : default_unify_flags(/* () */0);
  var match = retract_coercible_metas(evd);
  return w_merge(env, /* true */1, flags[/* merge_unify_flags */1], /* tuple */[
              match[1],
              match[0],
              /* [] */0
            ]);
}

function head_app(sigma, m) {
  return Reductionops$ReactTemplate.whd_nored_state(sigma)(/* tuple */[
                m,
                Reductionops$ReactTemplate.Stack[/* empty */2]
              ])[0];
}

function isEvar_or_Meta(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 2 : 
    case 3 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function check_types(env, flags, subst, m, n) {
  var sigma = subst[0];
  if (isEvar_or_Meta(sigma, head_app(sigma, m))) {
    return unify_0_with_initial_metas(subst, /* true */1, env, /* CUMUL */1, flags, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, n), Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, m));
  } else if (isEvar_or_Meta(sigma, head_app(sigma, n))) {
    return unify_0_with_initial_metas(subst, /* true */1, env, /* CUMUL */1, flags, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, m), Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, n));
  } else {
    return subst;
  }
}

function try_resolve_typeclasses(env, evd, flag, _, _$1) {
  if (flag) {
    return Typeclasses$ReactTemplate.resolve_typeclasses(/* None */0, /* Some */[Typeclasses$ReactTemplate.no_goals], /* None */0, /* Some */[/* false */0], /* Some */[/* true */1], env, evd);
  } else {
    return evd;
  }
}

function w_unify_core_0(env, evd, with_types, cv_pb, flags, m, n) {
  var match = retract_coercible_metas(evd);
  var match$1 = check_types(env, set_flags_for_type(flags[/* core_unify_flags */0]), /* tuple */[
        match[1],
        match[0],
        /* [] */0
      ], m, n);
  var subst2 = unify_0_with_initial_metas(/* tuple */[
        match$1[0],
        match$1[1],
        match$1[2]
      ], /* false */0, env, cv_pb, flags[/* core_unify_flags */0], m, n);
  var evd$1 = w_merge(env, with_types, flags[/* merge_unify_flags */1], subst2);
  return try_resolve_typeclasses(env, evd$1, flags[/* resolve_evars */4], m, n);
}

function w_typed_unify_array(env, evd, flags, f1, l1, f2, l2) {
  var match = Termops$ReactTemplate.adjust_app_array_size(f1, l1, f2, l2);
  var l2$1 = match[3];
  var f2$1 = match[2];
  var l1$1 = match[1];
  var f1$1 = match[0];
  var match$1 = retract_coercible_metas(evd);
  var fold_subst = function (subst, m, n) {
    return unify_0_with_initial_metas(subst, /* true */1, env, /* CONV */0, flags[/* core_unify_flags */0], m, n);
  };
  var subst = fold_subst(/* tuple */[
        match$1[1],
        /* [] */0,
        /* [] */0
      ], f1$1, f2$1);
  var subst$1 = Util$ReactTemplate.$$Array[/* fold_left2 */40](fold_subst, subst, l1$1, l2$1);
  var evd$1 = w_merge(env, /* true */1, flags[/* merge_unify_flags */1], subst$1);
  return try_resolve_typeclasses(env, evd$1, flags[/* resolve_evars */4], EConstr$ReactTemplate.mkApp(/* tuple */[
                  f1$1,
                  l1$1
                ]), EConstr$ReactTemplate.mkApp(/* tuple */[
                  f2$1,
                  l2$1
                ]));
}

function iter_fail(f, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("iter_fail"));
    } else {
      try {
        return Curry._1(f, Caml_array.caml_array_get(a, i));
      }
      catch (raw_ex){
        var ex = Js_exn.internalToOCamlException(raw_ex);
        if (Pretype_errors$ReactTemplate.precatchable_exception(ex)) {
          _i = i + 1 | 0;
          continue ;
          
        } else {
          throw ex;
        }
      }
    }
  };
}

function indirectly_dependent(sigma, c, d, decls) {
  if (EConstr$ReactTemplate.isVar(sigma, c)) {
    return /* false */0;
  } else {
    return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (d$prime) {
                  return Termops$ReactTemplate.dependent_in_decl(sigma, EConstr$ReactTemplate.mkVar(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d$prime)), d);
                }), decls);
  }
}

function finish_evar_resolution($staropt$star, env, current_sigma, param) {
  var flags = $staropt$star ? $staropt$star[0] : Pretyping$ReactTemplate.all_and_fail_flags;
  var sigma = Pretyping$ReactTemplate.solve_remaining_evars(flags, env, current_sigma, param[0]);
  var match = Evd$ReactTemplate.nf_univ_variables(sigma);
  var sigma$1 = match[0];
  return /* tuple */[
          sigma$1,
          EConstr$ReactTemplate.of_constr(Curry._2(Universes$ReactTemplate.subst_univs_constr, match[1], EConstr$ReactTemplate.Unsafe[/* to_constr */0](Evarutil$ReactTemplate.nf_evar(sigma$1, param[1]))))
        ];
}

function default_matching_core_flags(sigma) {
  return /* record */[
          /* modulo_conv_on_closed_terms : Some */[Names$ReactTemplate.empty_transparent_state],
          /* use_metas_eagerly_in_conv_on_closed_terms : false */0,
          /* use_evars_eagerly_in_conv_on_closed_terms : false */0,
          /* modulo_delta */Names$ReactTemplate.empty_transparent_state,
          /* modulo_delta_types */Names$ReactTemplate.full_transparent_state,
          /* check_applied_meta_types : true */1,
          /* use_pattern_unification : false */0,
          /* use_meta_bound_pattern_unification : false */0,
          /* frozen_evars */Curry._1(Evar$ReactTemplate.$$Map[/* domain */27], Evd$ReactTemplate.undefined_map(sigma)),
          /* restrict_conv_on_strict_subterms : false */0,
          /* modulo_betaiota : false */0,
          /* modulo_eta : false */0
        ];
}

function default_matching_merge_flags(sigma) {
  var flags = default_matching_core_flags(sigma);
  return /* record */[
          /* modulo_conv_on_closed_terms : Some */[Names$ReactTemplate.full_transparent_state],
          /* use_metas_eagerly_in_conv_on_closed_terms */flags[/* use_metas_eagerly_in_conv_on_closed_terms */1],
          /* use_evars_eagerly_in_conv_on_closed_terms */flags[/* use_evars_eagerly_in_conv_on_closed_terms */2],
          /* modulo_delta */Names$ReactTemplate.full_transparent_state,
          /* modulo_delta_types */flags[/* modulo_delta_types */4],
          /* check_applied_meta_types */flags[/* check_applied_meta_types */5],
          /* use_pattern_unification : true */1,
          /* use_meta_bound_pattern_unification */flags[/* use_meta_bound_pattern_unification */7],
          /* frozen_evars */flags[/* frozen_evars */8],
          /* restrict_conv_on_strict_subterms */flags[/* restrict_conv_on_strict_subterms */9],
          /* modulo_betaiota : true */1,
          /* modulo_eta : true */1
        ];
}

function default_matching_flags(sigma) {
  var flags = default_matching_core_flags(sigma);
  return /* record */[
          /* core_unify_flags */flags,
          /* merge_unify_flags */default_matching_merge_flags(sigma),
          /* subterm_unify_flags */flags,
          /* allow_K_in_toplevel_higher_order_unification : false */0,
          /* resolve_evars : false */0
        ];
}

var PatternNotFound = Caml_exceptions.create("Unification-ReactTemplate.PatternNotFound");

function make_pattern_test(from_prefix_of_ind, is_correct_type, env, sigma, param) {
  var c = param[1];
  var pending = param[0];
  var flags;
  if (from_prefix_of_ind) {
    var flags$1 = default_matching_flags(pending);
    var newrecord = flags$1[/* core_unify_flags */0].slice();
    flags = /* record */[
      /* core_unify_flags */(newrecord[/* modulo_conv_on_closed_terms */0] = /* Some */[Names$ReactTemplate.full_transparent_state], newrecord[/* restrict_conv_on_strict_subterms */9] = /* true */1, newrecord),
      /* merge_unify_flags */flags$1[/* merge_unify_flags */1],
      /* subterm_unify_flags */flags$1[/* subterm_unify_flags */2],
      /* allow_K_in_toplevel_higher_order_unification */flags$1[/* allow_K_in_toplevel_higher_order_unification */3],
      /* resolve_evars */flags$1[/* resolve_evars */4]
    ];
  } else {
    flags = default_matching_flags(pending);
  }
  var n = Termops$ReactTemplate.decompose_app_vect(sigma, c)[1].length;
  var matching_fun = function (_, t) {
    try {
      var match;
      if (from_prefix_of_ind) {
        var match$1 = EConstr$ReactTemplate.decompose_app(sigma, t);
        var match$2;
        try {
          match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], n, match$1[1]);
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn[0] === Caml_builtin_exceptions.failure) {
            throw [
                  Find_subterm$ReactTemplate.NotUnifiable,
                  /* None */0
                ];
          } else {
            throw exn;
          }
        }
        var l2 = match$2[1];
        if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (c) {
                  return EConstr$ReactTemplate.Vars[/* closed0 */15](sigma, c);
                }), l2)) {
          match = /* tuple */[
            EConstr$ReactTemplate.applist(/* tuple */[
                  match$1[0],
                  match$2[0]
                ]),
            l2
          ];
        } else {
          throw [
                Find_subterm$ReactTemplate.NotUnifiable,
                /* None */0
              ];
        }
      } else {
        match = /* tuple */[
          t,
          /* [] */0
        ];
      }
      var sigma$1 = w_unify_core_0(env, sigma, /* true */1, /* CONV */0, flags, c, match[0]);
      var ty = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma$1, t);
      if (!Curry._1(is_correct_type, ty)) {
        throw [
              Find_subterm$ReactTemplate.NotUnifiable,
              /* None */0
            ];
      }
      return /* Some */[/* tuple */[
                sigma$1,
                t,
                match[1]
              ]];
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      var exit = 0;
      if (e[0] === Pretype_errors$ReactTemplate.PretypeError) {
        var match$3 = e[3];
        if (match$3.tag === 4) {
          var match$4 = match$3[2];
          if (match$4) {
            throw [
                  Find_subterm$ReactTemplate.NotUnifiable,
                  /* Some */[/* tuple */[
                      match$3[0],
                      match$3[1],
                      match$4[0]
                    ]]
                ];
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (CErrors$ReactTemplate.noncritical(e)) {
          throw [
                Find_subterm$ReactTemplate.NotUnifiable,
                /* None */0
              ];
        } else {
          throw e;
        }
      }
      
    }
  };
  var merge_fun = function (c1, c2) {
    if (c1) {
      if (c2) {
        var match = c1[0];
        var c1$1 = match[1];
        var match$1 = Reductionops$ReactTemplate.infer_conv(/* None */0, /* Some */[/* CONV */0], /* None */0, env, match[0], c1$1, c2[0][1]);
        if (match$1[1]) {
          return /* Some */[/* tuple */[
                    match$1[0],
                    c1$1,
                    match[2]
                  ]];
        } else {
          throw [
                Find_subterm$ReactTemplate.NotUnifiable,
                /* None */0
              ];
        }
      } else {
        return c1;
      }
    } else if (c2) {
      return c2;
    } else {
      return /* None */0;
    }
  };
  return /* tuple */[
          /* record */[
            /* match_fun */matching_fun,
            /* merge_fun */merge_fun,
            /* testing_state : None */0,
            /* last_found : None */0
          ],
          (function (test) {
              var match = test[/* testing_state */2];
              if (match) {
                var match$1 = match[0];
                var sigma = match$1[0];
                var c$1 = EConstr$ReactTemplate.applist(/* tuple */[
                      Evarutil$ReactTemplate.nf_evar(sigma, Reductionops$ReactTemplate.local_strong(Reductionops$ReactTemplate.whd_meta, sigma)(c)),
                      match$1[2]
                    ]);
                var match$2 = Evd$ReactTemplate.nf_univ_variables(sigma);
                return /* Some */[/* tuple */[
                          sigma,
                          EConstr$ReactTemplate.of_constr(Curry._2(Universes$ReactTemplate.subst_univs_constr, match$2[1], EConstr$ReactTemplate.Unsafe[/* to_constr */0](c$1)))
                        ]];
              } else {
                return /* None */0;
              }
            })
        ];
}

function make_eq_test(env, evd, c) {
  var out = function (cstr) {
    var match = cstr[/* last_found */3];
    if (match) {
      return /* Some */[/* tuple */[
                cstr[/* testing_state */2],
                c
              ]];
    } else {
      return /* None */0;
    }
  };
  return /* tuple */[
          Find_subterm$ReactTemplate.make_eq_univs_test(env, evd, c),
          out
        ];
}

function make_abstraction_core(name, param, env, sigma, c, ty, occs, check_occs, concl) {
  var test = param[0];
  var t = ty ? ty[0] : Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c);
  var x = Namegen$ReactTemplate.id_of_name_using_hdchar(Global$ReactTemplate.env(/* () */0), sigma, t, name);
  var ids = Environ$ReactTemplate.ids_of_named_context_val(Environ$ReactTemplate.named_context_val(env));
  var id = name ? (
      Termops$ReactTemplate.mem_named_context_val(x, Environ$ReactTemplate.named_context_val(env)) ? CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Unification.make_abstraction_core"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The variable "), Names$ReactTemplate.Id[/* print */8](x)), Pp$ReactTemplate.str(" is already declared."))) : x
    ) : Namegen$ReactTemplate.next_ident_away_in_goal(x, ids);
  var likefirst = Locusops$ReactTemplate.clause_with_generic_occurrences(occs);
  var mkvarid = function () {
    return EConstr$ReactTemplate.mkVar(id);
  };
  var compute_dependency = function (_, d, param) {
    var depdecls = param[1];
    var sign = param[0];
    var d$1 = Termops$ReactTemplate.map_named_decl(EConstr$ReactTemplate.of_constr, d);
    var hyp = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d$1);
    var occ = Locusops$ReactTemplate.occurrences_of_hyp(hyp, occs);
    var match = occ[0];
    var exit = 0;
    if (typeof match === "number") {
      if (match !== 0) {
        if (occ[1] !== 0) {
          exit = 1;
        } else {
          return /* tuple */[
                  EConstr$ReactTemplate.push_named_context_val(d$1, sign),
                  depdecls
                ];
        }
      } else if (occ[1] !== 0) {
        exit = 1;
      } else {
        var occ$1 = likefirst ? /* LikeFirst */0 : /* AtOccs */[occ];
        var newdecl = Find_subterm$ReactTemplate.replace_term_occ_decl_modulo(sigma, occ$1, test, mkvarid, d$1);
        if (Curry._3(Context$ReactTemplate.Named[/* Declaration */0][/* equal */9], (function (param, param$1) {
                  return EConstr$ReactTemplate.eq_constr(sigma, param, param$1);
                }), d$1, newdecl) && !indirectly_dependent(sigma, c, d$1, depdecls)) {
          if (check_occs && !Locusops$ReactTemplate.in_every_hyp(occs)) {
            throw [
                  Pretype_errors$ReactTemplate.PretypeError,
                  env,
                  sigma,
                  /* NoOccurrenceFound */Block.__(8, [
                      c,
                      /* Some */[hyp]
                    ])
                ];
          } else {
            return /* tuple */[
                    EConstr$ReactTemplate.push_named_context_val(d$1, sign),
                    depdecls
                  ];
          }
        } else {
          return /* tuple */[
                  EConstr$ReactTemplate.push_named_context_val(newdecl, sign),
                  /* :: */[
                    newdecl,
                    depdecls
                  ]
                ];
        }
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var newdecl$1 = Find_subterm$ReactTemplate.replace_term_occ_decl_modulo(sigma, /* AtOccs */[occ], test, mkvarid, d$1);
      return /* tuple */[
              EConstr$ReactTemplate.push_named_context_val(newdecl$1, sign),
              /* :: */[
                newdecl$1,
                depdecls
              ]
            ];
    }
    
  };
  try {
    var match = Environ$ReactTemplate.fold_named_context(compute_dependency, env, /* tuple */[
          Environ$ReactTemplate.empty_named_context_val,
          /* [] */0
        ]);
    var depdecls = match[1];
    var occ = Locusops$ReactTemplate.occurrences_of_goal(occs);
    var ccl;
    var exit = 0;
    if (typeof occ === "number" && occ !== 0) {
      ccl = concl;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var occ$1 = likefirst ? /* LikeFirst */0 : /* AtOccs */[occ];
      ccl = Find_subterm$ReactTemplate.replace_term_occ_modulo(sigma, occ$1, test, mkvarid, concl);
    }
    var lastlhyp = Curry._1(Util$ReactTemplate.List[/* is_empty */45], depdecls) ? /* None */0 : /* Some */[Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], Curry._1(Util$ReactTemplate.List[/* last */105], depdecls))];
    var match$1 = Curry._1(param[1], test);
    var res;
    if (match$1) {
      var match$2 = match$1[0];
      res = /* Some */[/* tuple */[
          match$2[0],
          match$2[1]
        ]];
    } else {
      res = /* None */0;
    }
    return /* tuple */[
            id,
            match[0],
            depdecls,
            lastlhyp,
            ccl,
            res
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Find_subterm$ReactTemplate.SubtermUnificationError) {
      throw [
            Pretype_errors$ReactTemplate.PretypeError,
            env,
            sigma,
            /* CannotUnifyOccurrences */Block.__(17, [exn[1]])
          ];
    } else {
      throw exn;
    }
  }
}

function make_abstraction(env, evd, ccl, abs) {
  if (abs.tag) {
    var c = abs[1];
    return make_abstraction_core(abs[0], make_eq_test(env, evd, c), env, evd, c, abs[2], abs[3], abs[4], ccl);
  } else {
    var c$1 = abs[3];
    return make_abstraction_core(abs[2], make_pattern_test(abs[0], abs[1], env, evd, c$1), env, evd, c$1[1], /* None */0, abs[4], abs[5], ccl);
  }
}

function keyed_unify(_, evd, kop) {
  if (keyed_unification[0]) {
    if (kop) {
      var kop$1 = kop[0];
      return (function (cl) {
          var kc = Keys$ReactTemplate.constr_key((function (c) {
                  return EConstr$ReactTemplate.kind(evd, c);
                }), cl);
          if (kc) {
            return Keys$ReactTemplate.equiv_keys(kop$1, kc[0]);
          } else {
            return /* false */0;
          }
        });
    } else {
      return (function () {
          return /* true */1;
        });
    }
  } else {
    return (function () {
        return /* true */1;
      });
  }
}

function w_unify_to_subterm(env, evd, $staropt$star, param) {
  var op = param[0];
  var flags = $staropt$star ? $staropt$star[0] : default_unify_flags(/* () */0);
  var bestexn = [/* None */0];
  var kop = Keys$ReactTemplate.constr_key((function (c) {
          return EConstr$ReactTemplate.kind(evd, c);
        }), op);
  var matchrec = function (_cl) {
    while(true) {
      var cl = _cl;
      var cl$1 = Termops$ReactTemplate.strip_outer_cast(evd, cl);
      try {
        if (EConstr$ReactTemplate.Vars[/* closed0 */15](evd, cl$1) && !EConstr$ReactTemplate.isEvar(evd, cl$1) && Curry._1(keyed_unify(env, evd, kop), cl$1)) {
          try {
            if (keyed_unification[0]) {
              var match = Termops$ReactTemplate.decompose_app_vect(evd, op);
              var match$1 = Termops$ReactTemplate.decompose_app_vect(evd, cl$1);
              return /* tuple */[
                      w_typed_unify_array(env, evd, flags, match[0], match[1], match$1[0], match$1[1]),
                      cl$1
                    ];
            } else {
              return /* tuple */[
                      w_unify_core_0(env, evd, /* true */1, /* CONV */0, flags, op, cl$1),
                      cl$1
                    ];
            }
          }
          catch (raw_ex){
            var ex = Js_exn.internalToOCamlException(raw_ex);
            if (Pretype_errors$ReactTemplate.unsatisfiable_exception(ex)) {
              bestexn[0] = /* Some */[ex];
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Unsat"));
            } else {
              throw ex;
            }
          }
        } else {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Bound 1"));
        }
      }
      catch (raw_ex$1){
        var ex$1 = Js_exn.internalToOCamlException(raw_ex$1);
        if (Pretype_errors$ReactTemplate.precatchable_exception(ex$1)) {
          var match$2 = EConstr$ReactTemplate.kind(evd, cl$1);
          switch (match$2.tag | 0) {
            case 6 : 
                try {
                  return matchrec(match$2[1]);
                }
                catch (raw_ex$2){
                  var ex$2 = Js_exn.internalToOCamlException(raw_ex$2);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(ex$2)) {
                    _cl = match$2[2];
                    continue ;
                    
                  } else {
                    throw ex$2;
                  }
                }
                break;
            case 7 : 
                try {
                  return matchrec(match$2[1]);
                }
                catch (raw_ex$3){
                  var ex$3 = Js_exn.internalToOCamlException(raw_ex$3);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(ex$3)) {
                    _cl = match$2[2];
                    continue ;
                    
                  } else {
                    throw ex$3;
                  }
                }
                break;
            case 8 : 
                try {
                  return matchrec(match$2[1]);
                }
                catch (raw_ex$4){
                  var ex$4 = Js_exn.internalToOCamlException(raw_ex$4);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(ex$4)) {
                    _cl = match$2[3];
                    continue ;
                    
                  } else {
                    throw ex$4;
                  }
                }
                break;
            case 9 : 
                var args = match$2[1];
                var n = args.length;
                if (n <= 0) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "unification.ml",
                          1736,
                          7
                        ]
                      ];
                }
                var c1 = EConstr$ReactTemplate.mkApp(/* tuple */[
                      match$2[0],
                      Util$ReactTemplate.$$Array[/* sub */5](args, 0, n - 1 | 0)
                    ]);
                var c2 = Caml_array.caml_array_get(args, n - 1 | 0);
                try {
                  return matchrec(c1);
                }
                catch (raw_ex$5){
                  var ex$5 = Js_exn.internalToOCamlException(raw_ex$5);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(ex$5)) {
                    _cl = c2;
                    continue ;
                    
                  } else {
                    throw ex$5;
                  }
                }
                break;
            case 13 : 
                try {
                  return matchrec(match$2[2]);
                }
                catch (raw_ex$6){
                  var ex$6 = Js_exn.internalToOCamlException(raw_ex$6);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(ex$6)) {
                    return iter_fail(matchrec, match$2[3]);
                  } else {
                    throw ex$6;
                  }
                }
                break;
            case 14 : 
                var match$3 = match$2[0][1];
                try {
                  return iter_fail(matchrec, match$3[1]);
                }
                catch (raw_ex$7){
                  var ex$7 = Js_exn.internalToOCamlException(raw_ex$7);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(ex$7)) {
                    return iter_fail(matchrec, match$3[2]);
                  } else {
                    throw ex$7;
                  }
                }
                break;
            case 15 : 
                var match$4 = match$2[0][1];
                try {
                  return iter_fail(matchrec, match$4[1]);
                }
                catch (raw_ex$8){
                  var ex$8 = Js_exn.internalToOCamlException(raw_ex$8);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(ex$8)) {
                    return iter_fail(matchrec, match$4[2]);
                  } else {
                    throw ex$8;
                  }
                }
                break;
            case 16 : 
                _cl = match$2[1];
                continue ;
                default:
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Match_subterm"));
          }
        } else {
          throw ex$1;
        }
      }
    };
  };
  try {
    return matchrec(param[1]);
  }
  catch (raw_ex){
    var ex = Js_exn.internalToOCamlException(raw_ex);
    if (Pretype_errors$ReactTemplate.precatchable_exception(ex)) {
      var match = bestexn[0];
      if (match) {
        throw match[0];
      } else {
        throw [
              Pretype_errors$ReactTemplate.PretypeError,
              env,
              evd,
              /* NoOccurrenceFound */Block.__(8, [
                  op,
                  /* None */0
                ])
            ];
      }
    } else {
      throw ex;
    }
  }
}

function w_unify_to_subterm_all(env, evd, $staropt$star, param) {
  var op = param[0];
  var flags = $staropt$star ? $staropt$star[0] : default_unify_flags(/* () */0);
  var fail = function (str, _) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(str));
  };
  var bind = function (f, g, a) {
    var a1;
    try {
      a1 = Curry._1(f, a);
    }
    catch (raw_ex){
      var ex = Js_exn.internalToOCamlException(raw_ex);
      if (Pretype_errors$ReactTemplate.precatchable_exception(ex)) {
        a1 = a;
      } else {
        throw ex;
      }
    }
    try {
      return Curry._1(g, a1);
    }
    catch (raw_ex$1){
      var ex$1 = Js_exn.internalToOCamlException(raw_ex$1);
      if (Pretype_errors$ReactTemplate.precatchable_exception(ex$1)) {
        return a1;
      } else {
        throw ex$1;
      }
    }
  };
  var bind_iter = function (f, a) {
    var n = a.length;
    var ffail = function (i) {
      if (i === n) {
        return (function (a) {
            return a;
          });
      } else {
        var partial_arg = ffail(i + 1 | 0);
        var partial_arg$1 = Curry._1(f, Caml_array.caml_array_get(a, i));
        return (function (param) {
            return bind(partial_arg$1, partial_arg, param);
          });
      }
    };
    return ffail(0);
  };
  var matchrec = function (cl) {
    var cl$1 = Termops$ReactTemplate.strip_outer_cast(evd, cl);
    var match = EConstr$ReactTemplate.kind(evd, cl$1);
    var partial_arg;
    var exit = 0;
    switch (match.tag | 0) {
      case 5 : 
          partial_arg = (function (param) {
              return fail("Match_subterm", param);
            });
          break;
      case 6 : 
      case 7 : 
          exit = 1;
          break;
      case 8 : 
          var partial_arg$1 = matchrec(match[3]);
          var partial_arg$2 = matchrec(match[1]);
          partial_arg = (function (param) {
              return bind(partial_arg$2, partial_arg$1, param);
            });
          break;
      case 9 : 
          var args = match[1];
          var n = args.length;
          if (n <= 0) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "unification.ml",
                    1823,
                    2
                  ]
                ];
          }
          var c1 = EConstr$ReactTemplate.mkApp(/* tuple */[
                match[0],
                Util$ReactTemplate.$$Array[/* sub */5](args, 0, n - 1 | 0)
              ]);
          var c2 = Caml_array.caml_array_get(args, n - 1 | 0);
          var partial_arg$3 = matchrec(c2);
          var partial_arg$4 = matchrec(c1);
          partial_arg = (function (param) {
              return bind(partial_arg$4, partial_arg$3, param);
            });
          break;
      case 13 : 
          var partial_arg$5 = bind_iter(matchrec, match[3]);
          var partial_arg$6 = matchrec(match[2]);
          partial_arg = (function (param) {
              return bind(partial_arg$6, partial_arg$5, param);
            });
          break;
      case 14 : 
      case 15 : 
          exit = 2;
          break;
      case 16 : 
          partial_arg = matchrec(match[1]);
          break;
      default:
        partial_arg = (function (param) {
            return fail("Match_subterm", param);
          });
    }
    switch (exit) {
      case 1 : 
          var partial_arg$7 = matchrec(match[2]);
          var partial_arg$8 = matchrec(match[1]);
          partial_arg = (function (param) {
              return bind(partial_arg$8, partial_arg$7, param);
            });
          break;
      case 2 : 
          var match$1 = match[0][1];
          var partial_arg$9 = bind_iter(matchrec, match$1[2]);
          var partial_arg$10 = bind_iter(matchrec, match$1[1]);
          partial_arg = (function (param) {
              return bind(partial_arg$10, partial_arg$9, param);
            });
          break;
      
    }
    var partial_arg$11 = EConstr$ReactTemplate.Vars[/* closed0 */15](evd, cl$1) ? (function (param) {
          var a = function () {
            return /* tuple */[
                    w_unify_core_0(env, evd, /* true */1, /* CONV */0, flags, op, cl$1),
                    cl$1
                  ];
          };
          var b = param;
          var a$1 = Curry._1(a, /* () */0);
          var c = a$1[1];
          if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                    return EConstr$ReactTemplate.eq_constr(param[0], c, param[1]);
                  }), b)) {
            return b;
          } else {
            return /* :: */[
                    a$1,
                    b
                  ];
          }
        }) : (function (param) {
          return fail("Bound 1", param);
        });
    return (function (param) {
        return bind(partial_arg$11, partial_arg, param);
      });
  };
  var res = matchrec(param[1])(/* [] */0);
  if (res) {
    return res;
  } else {
    throw [
          Pretype_errors$ReactTemplate.PretypeError,
          env,
          evd,
          /* NoOccurrenceFound */Block.__(8, [
              op,
              /* None */0
            ])
        ];
  }
}

function w_unify_to_subterm_list(env, evd, flags, hdmeta, oplist, t) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (op, param) {
                var l = param[1];
                var evd = param[0];
                var op$1 = Reductionops$ReactTemplate.whd_meta(evd, op);
                if (EConstr$ReactTemplate.isMeta(evd, op$1)) {
                  if (flags[/* allow_K_in_toplevel_higher_order_unification */3]) {
                    return /* tuple */[
                            evd,
                            /* :: */[
                              op$1,
                              l
                            ]
                          ];
                  } else {
                    return Pretype_errors$ReactTemplate.error_abstraction_over_meta(env, evd, hdmeta, EConstr$ReactTemplate.destMeta(evd, op$1));
                  }
                } else {
                  var allow_K = flags[/* allow_K_in_toplevel_higher_order_unification */3];
                  var flags$1 = unsafe_occur_meta_or_existential(op$1) || keyed_unification[0] ? flags : set_no_delta_flags(flags);
                  var t$prime_000 = Termops$ReactTemplate.strip_outer_cast(evd, op$1);
                  var t$prime = /* tuple */[
                    t$prime_000,
                    t
                  ];
                  var match;
                  try {
                    if (is_keyed_unification(/* () */0)) {
                      try {
                        var flags$2 = set_no_delta_open_flags(flags$1);
                        match = w_unify_to_subterm(env, evd, /* Some */[flags$2], t$prime);
                      }
                      catch (e){
                        match = w_unify_to_subterm(env, evd, /* Some */[flags$1], t$prime);
                      }
                    } else {
                      match = w_unify_to_subterm(env, evd, /* Some */[flags$1], t$prime);
                    }
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Pretype_errors$ReactTemplate.PretypeError) {
                      if (exn[3].tag === 8) {
                        if (allow_K || Termops$ReactTemplate.dependent(evd, op$1, t)) {
                          match = /* tuple */[
                            evd,
                            op$1
                          ];
                        } else {
                          throw exn;
                        }
                      } else {
                        throw exn;
                      }
                    } else {
                      throw exn;
                    }
                  }
                  var cl = match[1];
                  var evd$prime = match[0];
                  if (!allow_K && Curry._2(Util$ReactTemplate.List[/* exists */21], (function (op) {
                            return EConstr$ReactTemplate.eq_constr(evd$prime, op, cl);
                          }), l)) {
                    return Pretype_errors$ReactTemplate.error_non_linear_unification(env, evd, hdmeta, cl);
                  } else {
                    return /* tuple */[
                            evd$prime,
                            /* :: */[
                              cl,
                              l
                            ]
                          ];
                  }
                }
              }), oplist, /* tuple */[
              evd,
              /* [] */0
            ]);
}

function secondOrderAbstraction(env, evd, flags, typ, param) {
  var p = param[0];
  var flags_000 = /* core_unify_flags */flags[/* subterm_unify_flags */2];
  var flags_001 = /* merge_unify_flags */flags[/* merge_unify_flags */1];
  var flags_002 = /* subterm_unify_flags */flags[/* subterm_unify_flags */2];
  var flags_003 = /* allow_K_in_toplevel_higher_order_unification */flags[/* allow_K_in_toplevel_higher_order_unification */3];
  var flags_004 = /* resolve_evars */flags[/* resolve_evars */4];
  var flags$1 = /* record */[
    flags_000,
    flags_001,
    flags_002,
    flags_003,
    flags_004
  ];
  var match = w_unify_to_subterm_list(env, evd, flags$1, p, param[1], typ);
  var evd$prime = match[0];
  var typp = Typing$ReactTemplate.meta_type(evd$prime, p);
  var match$1 = abstract_list_all(env, evd$prime, typp, typ, match[1]);
  var match$2 = match$1[1];
  var predtyp = match$2[1];
  var pred = match$2[0];
  var match$3 = Reductionops$ReactTemplate.infer_conv(/* None */0, /* Some */[/* CUMUL */1], /* None */0, env, match$1[0], predtyp, typp);
  var evd$prime$1 = match$3[0];
  if (!match$3[1]) {
    Pretype_errors$ReactTemplate.error_wrong_abstraction_type(env, evd$prime$1, Evd$ReactTemplate.meta_name(evd, p), pred, typp, predtyp);
  }
  return w_merge(env, /* false */0, flags_001, /* tuple */[
              evd$prime$1,
              /* :: */[
                /* tuple */[
                  p,
                  pred,
                  /* tuple */[
                    /* Conv */2,
                    /* TypeProcessed */2
                  ]
                ],
                /* [] */0
              ],
              /* [] */0
            ]);
}

function secondOrderDependentAbstraction(env, evd, flags, typ, param) {
  var p = param[0];
  var typp = Typing$ReactTemplate.meta_type(evd, p);
  var match = abstract_list_all_with_dependencies(env, evd, typp, typ, param[1]);
  return w_merge(env, /* false */0, flags[/* merge_unify_flags */1], /* tuple */[
              match[0],
              /* :: */[
                /* tuple */[
                  p,
                  match[1],
                  /* tuple */[
                    /* Conv */2,
                    /* TypeProcessed */2
                  ]
                ],
                /* [] */0
              ],
              /* [] */0
            ]);
}

function w_unify2(env, evd, flags, dep, _, ty1, ty2) {
  var match = Reductionops$ReactTemplate.whd_nored_stack(evd, ty1);
  var match$1 = Reductionops$ReactTemplate.whd_nored_stack(evd, ty2);
  var match$2 = EConstr$ReactTemplate.kind(evd, match[0]);
  var match$3 = EConstr$ReactTemplate.kind(evd, match$1[0]);
  if (match$2.tag === 2) {
    return Curry._5(dep ? secondOrderDependentAbstraction : secondOrderAbstraction, env, evd, flags, ty2, /* tuple */[
                match$2[0],
                match[1]
              ]);
  } else if (match$3.tag === 2) {
    return Curry._5(dep ? secondOrderDependentAbstraction : secondOrderAbstraction, env, evd, flags, ty1, /* tuple */[
                match$3[0],
                match$1[1]
              ]);
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("w_unify2"));
  }
}

function w_unify(env, evd, cv_pb, flags, ty1, ty2) {
  var env$1 = env;
  var evd$1 = evd;
  var cv_pb$1 = cv_pb;
  var $staropt$star = /* Some */[flags];
  var ty1$1 = ty1;
  var ty2$1 = ty2;
  var flags$1 = $staropt$star ? $staropt$star[0] : default_unify_flags(/* () */0);
  var match = Termops$ReactTemplate.decompose_app_vect(evd$1, Reductionops$ReactTemplate.whd_nored(evd$1, ty1$1));
  var l1 = match[1];
  var hd1 = match[0];
  var match$1 = Termops$ReactTemplate.decompose_app_vect(evd$1, Reductionops$ReactTemplate.whd_nored(evd$1, ty2$1));
  var l2 = match$1[1];
  var hd2 = match$1[0];
  var is_empty1 = Util$ReactTemplate.$$Array[/* is_empty */23](l1);
  var is_empty2 = Util$ReactTemplate.$$Array[/* is_empty */23](l2);
  var match$2 = EConstr$ReactTemplate.kind(evd$1, hd1);
  var match$3 = 1 - is_empty1;
  var match$4 = EConstr$ReactTemplate.kind(evd$1, hd2);
  var match$5 = 1 - is_empty2;
  var exit = 0;
  var exit$1 = 0;
  switch (match$2.tag | 0) {
    case 2 : 
        if (match$3 !== 0 && match$4.tag === 7) {
          exit$1 = 2;
        } else {
          exit = 1;
        }
        break;
    case 7 : 
        if (match$4.tag === 2 && match$5 !== 0) {
          exit$1 = 2;
        } else {
          exit = 1;
        }
        break;
    default:
      exit = 1;
  }
  if (exit$1 === 2) {
    if (l1.length === l2.length) {
      try {
        return w_typed_unify_array(env$1, evd$1, flags$1, hd1, l1, hd2, l2);
      }
      catch (raw_ex){
        var ex = Js_exn.internalToOCamlException(raw_ex);
        if (Pretype_errors$ReactTemplate.precatchable_exception(ex)) {
          try {
            return w_unify2(env$1, evd$1, flags$1, /* false */0, cv_pb$1, ty1$1, ty2$1);
          }
          catch (raw_e){
            var e = Js_exn.internalToOCamlException(raw_e);
            if (e[0] === Pretype_errors$ReactTemplate.PretypeError) {
              if (e[3].tag === 8) {
                throw e;
              } else {
                throw e;
              }
            } else {
              throw e;
            }
          }
        } else {
          throw ex;
        }
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    var exit$2 = 0;
    var exit$3 = 0;
    if (match$2.tag === 2 && match$3 !== 0) {
      exit$2 = 3;
    } else {
      exit$3 = 4;
    }
    if (exit$3 === 4) {
      exit$2 = match$4.tag === 2 && match$5 !== 0 ? 3 : 2;
    }
    switch (exit$2) {
      case 2 : 
          return w_unify_core_0(env$1, evd$1, /* true */1, cv_pb$1, flags$1, ty1$1, ty2$1);
      case 3 : 
          try {
            return w_unify2(env$1, evd$1, flags$1, /* false */0, cv_pb$1, ty1$1, ty2$1);
          }
          catch (raw_e$1){
            var e$1 = Js_exn.internalToOCamlException(raw_e$1);
            var exit$4 = 0;
            if (e$1[0] === Pretype_errors$ReactTemplate.PretypeError) {
              if (e$1[3].tag === 8) {
                throw e$1;
              } else {
                exit$4 = 4;
              }
            } else {
              exit$4 = 4;
            }
            if (exit$4 === 4) {
              if (Pretype_errors$ReactTemplate.precatchable_exception(e$1)) {
                try {
                  return w_typed_unify_array(env$1, evd$1, flags$1, hd1, l1, hd2, l2);
                }
                catch (raw_ex$prime){
                  var ex$prime = Js_exn.internalToOCamlException(raw_ex$prime);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(ex$prime)) {
                    try {
                      return w_unify2(env$1, evd$1, flags$1, /* true */1, cv_pb$1, ty1$1, ty2$1);
                    }
                    catch (raw_ex$prime$1){
                      var ex$prime$1 = Js_exn.internalToOCamlException(raw_ex$prime$1);
                      if (Pretype_errors$ReactTemplate.precatchable_exception(ex$prime$1)) {
                        throw e$1;
                      } else {
                        throw ex$prime$1;
                      }
                    }
                  } else {
                    throw ex$prime;
                  }
                }
              } else {
                throw e$1;
              }
            }
            
          }
          break;
      
    }
  }
  
}

var w_unify$1;

if (Flags$ReactTemplate.profile) {
  var wunifkey = CProfile$ReactTemplate.declare_profile("w_unify");
  w_unify$1 = CProfile$ReactTemplate.profile6(wunifkey, w_unify);
} else {
  w_unify$1 = w_unify;
}

function w_unify$2(env, evd, cv_pb, $staropt$star, ty1, ty2) {
  var flags = $staropt$star ? $staropt$star[0] : default_unify_flags(/* () */0);
  return Curry._6(w_unify$1, env, evd, cv_pb, flags, ty1, ty2);
}

exports.default_core_unify_flags = default_core_unify_flags;
exports.default_no_delta_core_unify_flags = default_no_delta_core_unify_flags;
exports.default_unify_flags = default_unify_flags;
exports.default_no_delta_unify_flags = default_no_delta_unify_flags;
exports.elim_flags = elim_flags;
exports.elim_no_delta_flags = elim_no_delta_flags;
exports.is_keyed_unification = is_keyed_unification;
exports.w_unify = w_unify$2;
exports.w_unify_to_subterm = w_unify_to_subterm;
exports.w_unify_to_subterm_all = w_unify_to_subterm_all;
exports.w_unify_meta_types = w_unify_meta_types;
exports.w_coerce_to_type = w_coerce_to_type;
exports.PatternNotFound = PatternNotFound;
exports.finish_evar_resolution = finish_evar_resolution;
exports.make_abstraction = make_abstraction;
exports.pose_all_metas_as_evars = pose_all_metas_as_evars;
exports.abstract_list_all = abstract_list_all;
exports.w_merge = w_merge;
exports.unify_0 = unify_0;
exports.unify_0_with_initial_metas = unify_0_with_initial_metas;
/*  Not a pure module */
