// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Arguments_renaming$ReactTemplate = require("./arguments_renaming.bs.js");

var implicit_args = [/* record */[
    /* auto : false */0,
    /* strict : true */1,
    /* strongly_strict : false */0,
    /* reversible_pattern : false */0,
    /* contextual : false */0,
    /* maximal : false */0
  ]];

function make_implicit_args(flag) {
  var newrecord = implicit_args[0].slice();
  newrecord[/* auto */0] = flag;
  implicit_args[0] = newrecord;
  return /* () */0;
}

function make_strict_implicit_args(flag) {
  var newrecord = implicit_args[0].slice();
  newrecord[/* strict */1] = flag;
  implicit_args[0] = newrecord;
  return /* () */0;
}

function make_strongly_strict_implicit_args(flag) {
  var newrecord = implicit_args[0].slice();
  newrecord[/* strongly_strict */2] = flag;
  implicit_args[0] = newrecord;
  return /* () */0;
}

function make_reversible_pattern_implicit_args(flag) {
  var newrecord = implicit_args[0].slice();
  newrecord[/* reversible_pattern */3] = flag;
  implicit_args[0] = newrecord;
  return /* () */0;
}

function make_contextual_implicit_args(flag) {
  var newrecord = implicit_args[0].slice();
  newrecord[/* contextual */4] = flag;
  implicit_args[0] = newrecord;
  return /* () */0;
}

function make_maximal_implicit_args(flag) {
  var newrecord = implicit_args[0].slice();
  newrecord[/* maximal */5] = flag;
  implicit_args[0] = newrecord;
  return /* () */0;
}

function is_implicit_args() {
  return implicit_args[0][/* auto */0];
}

function is_strict_implicit_args() {
  return implicit_args[0][/* strict */1];
}

function is_strongly_strict_implicit_args() {
  return implicit_args[0][/* strongly_strict */2];
}

function is_reversible_pattern_implicit_args() {
  return implicit_args[0][/* reversible_pattern */3];
}

function is_contextual_implicit_args() {
  return implicit_args[0][/* contextual */4];
}

function is_maximal_implicit_args() {
  return implicit_args[0][/* maximal */5];
}

function with_implicit_protection(f, x) {
  var oflags = implicit_args[0];
  try {
    var rslt = Curry._1(f, x);
    implicit_args[0] = oflags;
    return rslt;
  }
  catch (raw_reraise){
    var reraise = Js_exn.internalToOCamlException(raw_reraise);
    var reraise$1 = CErrors$ReactTemplate.push(reraise);
    implicit_args[0] = oflags;
    return Util$ReactTemplate.iraise(reraise$1);
  }
}

function set_maximality(imps, b) {
  var is_set = function (x) {
    if (x) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  };
  if (b) {
    return /* true */1;
  } else {
    return Curry._2(Util$ReactTemplate.List[/* for_all */20], is_set, imps);
  }
}

function argument_position_eq(p1, p2) {
  if (p1) {
    if (p2) {
      return +(p1[0] === p2[0]);
    } else {
      return /* false */0;
    }
  } else if (p2) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function explicitation_eq(ex1, ex2) {
  if (ex1.tag) {
    if (ex2.tag) {
      return Names$ReactTemplate.Id[/* equal */0](ex1[0], ex2[0]);
    } else {
      return /* false */0;
    }
  } else if (!ex2.tag && ex1[0] === ex2[0]) {
    return Option$ReactTemplate.equal(Names$ReactTemplate.Id[/* equal */0], ex1[1], ex2[1]);
  } else {
    return /* false */0;
  }
}

function argument_less(param) {
  var match = param[0];
  if (match) {
    var match$1 = param[1];
    if (match$1) {
      return +(match[0] < match$1[0]);
    } else {
      return /* true */1;
    }
  } else {
    return /* false */0;
  }
}

function update(pos, rig, param) {
  var st = param[1];
  var e;
  if (rig) {
    if (st) {
      var x = st[0];
      if (typeof x === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "impargs.ml",
                155,
                23
              ]
            ];
      } else {
        switch (x.tag | 0) {
          case 0 : 
              e = argument_less(/* tuple */[
                    pos,
                    x[0]
                  ]) ? /* DepRigid */Block.__(0, [pos]) : x;
              break;
          case 1 : 
              var fpos = x[0];
              e = argument_less(/* tuple */[
                    pos,
                    fpos
                  ]) || argument_position_eq(pos, fpos) ? /* DepRigid */Block.__(0, [pos]) : /* DepFlexAndRigid */Block.__(2, [
                    fpos,
                    pos
                  ]);
              break;
          case 2 : 
              var fpos$1 = x[0];
              e = argument_less(/* tuple */[
                    pos,
                    fpos$1
                  ]) || argument_position_eq(pos, fpos$1) ? /* DepRigid */Block.__(0, [pos]) : (
                  argument_less(/* tuple */[
                        pos,
                        x[1]
                      ]) ? /* DepFlexAndRigid */Block.__(2, [
                        fpos$1,
                        pos
                      ]) : x
                );
              break;
          
        }
      }
    } else {
      e = /* DepRigid */Block.__(0, [pos]);
    }
  } else if (st) {
    var x$1 = st[0];
    if (typeof x$1 === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "impargs.ml",
              165,
              23
            ]
          ];
    } else {
      switch (x$1.tag | 0) {
        case 0 : 
            var rpos = x$1[0];
            e = argument_less(/* tuple */[
                  pos,
                  rpos
                ]) ? /* DepFlexAndRigid */Block.__(2, [
                  pos,
                  rpos
                ]) : x$1;
            break;
        case 1 : 
            e = argument_less(/* tuple */[
                  pos,
                  x$1[0]
                ]) ? /* DepFlex */Block.__(1, [pos]) : x$1;
            break;
        case 2 : 
            e = argument_less(/* tuple */[
                  pos,
                  x$1[0]
                ]) ? /* DepFlexAndRigid */Block.__(2, [
                  pos,
                  x$1[1]
                ]) : x$1;
            break;
        
      }
    }
  } else {
    e = /* DepFlex */Block.__(1, [pos]);
  }
  return /* tuple */[
          param[0],
          /* Some */[e]
        ];
}

function is_flexible_reference(env, sigma, bound, depth, f) {
  var match = EConstr$ReactTemplate.kind(sigma, f);
  switch (match.tag | 0) {
    case 0 : 
        var n = match[0];
        if (n >= (bound + depth | 0) || n < depth) {
          return /* false */0;
        } else {
          return /* true */1;
        }
    case 1 : 
        return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* is_local_def */6], Environ$ReactTemplate.lookup_named(match[0], env));
    case 10 : 
        var cb = Environ$ReactTemplate.lookup_constant(match[0][0], env);
        var match$1 = cb[/* const_body */1];
        switch (match$1.tag | 0) {
          case 1 : 
              return /* true */1;
          case 0 : 
          case 2 : 
              return /* false */0;
          
        }
        break;
    case 11 : 
    case 12 : 
        return /* false */0;
    default:
      return /* true */1;
  }
}

function push_lift(d, param) {
  return /* tuple */[
          EConstr$ReactTemplate.push_rel(d, param[0]),
          param[1] + 1 | 0
        ];
}

function is_reversible_pattern(sigma, bound, depth, f, l) {
  if (EConstr$ReactTemplate.isRel(sigma, f)) {
    var n = EConstr$ReactTemplate.destRel(sigma, f);
    if (n < (bound + depth | 0) && n >= depth && Util$ReactTemplate.$$Array[/* for_all */26]((function (c) {
              return EConstr$ReactTemplate.isRel(sigma, c) ? +(EConstr$ReactTemplate.destRel(sigma, c) < depth) : /* false */0;
            }), l)) {
      return Util$ReactTemplate.$$Array[/* distinct */61](l);
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function add_free_rels_until(strict, strongly_strict, revpat, bound, env, sigma, m, pos, acc) {
  var frec = function (rig, ed, c) {
    var depth = ed[1];
    var env = ed[0];
    var hd = strict ? Reductionops$ReactTemplate.whd_all(env)(sigma, c) : c;
    var c$1 = strongly_strict ? hd : c;
    var match = EConstr$ReactTemplate.kind(sigma, hd);
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          var n = match[0];
          if (n < (bound + depth | 0) && n >= depth) {
            var i = ((bound + depth | 0) - n | 0) - 1 | 0;
            return Caml_array.caml_array_set(acc, i, update(pos, rig, Caml_array.caml_array_get(acc, i)));
          } else {
            exit = 1;
          }
          break;
      case 3 : 
          return /* () */0;
      case 9 : 
          var f = match[0];
          if (revpat && is_reversible_pattern(sigma, bound, depth, f, match[1])) {
            var i$1 = ((bound + depth | 0) - EConstr$ReactTemplate.destRel(sigma, f) | 0) - 1 | 0;
            return Caml_array.caml_array_set(acc, i$1, update(pos, rig, Caml_array.caml_array_get(acc, i$1)));
          } else if (rig && is_flexible_reference(env, sigma, bound, depth, f)) {
            if (strict) {
              return /* () */0;
            } else {
              return Termops$ReactTemplate.iter_constr_with_full_binders(sigma, push_lift, (function (param, param$1) {
                            return frec(/* false */0, param, param$1);
                          }), ed, c$1);
            }
          } else {
            exit = 1;
          }
          break;
      case 13 : 
          if (rig) {
            if (strict) {
              return /* () */0;
            } else {
              return Termops$ReactTemplate.iter_constr_with_full_binders(sigma, push_lift, (function (param, param$1) {
                            return frec(/* false */0, param, param$1);
                          }), ed, c$1);
            }
          } else {
            exit = 1;
          }
          break;
      case 16 : 
          if (rig) {
            if (strict) {
              return /* () */0;
            } else {
              return Termops$ReactTemplate.iter_constr_with_full_binders(sigma, push_lift, (function (param, param$1) {
                            return frec(/* false */0, param, param$1);
                          }), ed, match[1]);
            }
          } else {
            exit = 1;
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      return Termops$ReactTemplate.iter_constr_with_full_binders(sigma, push_lift, (function (param, param$1) {
                    return frec(rig, param, param$1);
                  }), ed, c$1);
    }
    
  };
  if (!EConstr$ReactTemplate.Vars[/* noccur_between */13](sigma, 1, bound, m)) {
    frec(/* true */1, /* tuple */[
          env,
          1
        ], m);
  }
  return acc;
}

function is_rigid_head(sigma, _t) {
  while(true) {
    var t = _t;
    var match = EConstr$ReactTemplate.kind(sigma, t);
    switch (match.tag | 0) {
      case 0 : 
      case 3 : 
          return /* false */0;
      case 9 : 
          var f = match[0];
          var match$1 = EConstr$ReactTemplate.kind(sigma, f);
          if (match$1.tag === 14) {
            var match$2 = match$1[0][0];
            _t = Caml_array.caml_array_get(match[1], Caml_array.caml_array_get(match$2[0], match$2[1]));
            continue ;
            
          } else {
            _t = f;
            continue ;
            
          }
          break;
      case 13 : 
          _t = match[2];
          continue ;
          case 1 : 
      case 4 : 
      case 10 : 
      case 11 : 
      case 16 : 
          return /* true */1;
      default:
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "impargs.ml",
                227,
                32
              ]
            ];
    }
  };
}

function find_displayed_name_in(all, avoid, na, param) {
  var b = param[1];
  var envnames_b_000 = param[0];
  var envnames_b = /* tuple */[
    envnames_b_000,
    b
  ];
  var flag = /* RenamingElsewhereFor */Block.__(1, [envnames_b]);
  if (all) {
    return Namegen$ReactTemplate.compute_and_force_displayed_name_in(Evd$ReactTemplate.empty, flag, avoid, na, b);
  } else {
    return Namegen$ReactTemplate.compute_displayed_name_in(Evd$ReactTemplate.empty, flag, avoid, na, b);
  }
}

function compute_implicits_gen(strict, strongly_strict, revpat, contextual, all, env, sigma, t) {
  var rigid = [/* true */1];
  var aux = function (env, avoid, n, names, t) {
    var t$1 = Reductionops$ReactTemplate.whd_all(env)(sigma, t);
    var match = EConstr$ReactTemplate.kind(sigma, t$1);
    if (match.tag === 6) {
      var b = match[2];
      var a = match[1];
      var match$1 = find_displayed_name_in(all, avoid, match[0], /* tuple */[
            names,
            b
          ]);
      var na$prime = match$1[0];
      return add_free_rels_until(strict, strongly_strict, revpat, n, env, sigma, a, /* Hyp */[n + 1 | 0], aux(EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                            na$prime,
                            a
                          ]), env), match$1[1], n + 1 | 0, /* :: */[
                      na$prime,
                      names
                    ], b));
    } else {
      rigid[0] = is_rigid_head(sigma, t$1);
      var names$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], names);
      var v = Util$ReactTemplate.$$Array[/* map */12]((function (na) {
              return /* tuple */[
                      na,
                      /* None */0
                    ];
            }), Util$ReactTemplate.$$Array[/* of_list */10](names$1));
      if (contextual) {
        return add_free_rels_until(strict, strongly_strict, revpat, n, env, sigma, t$1, /* Conclusion */0, v);
      } else {
        return v;
      }
    }
  };
  var match = EConstr$ReactTemplate.kind(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, t));
  if (match.tag === 6) {
    var b = match[2];
    var match$1 = find_displayed_name_in(all, Names$ReactTemplate.Id[/* Set */9][/* empty */0], match[0], /* tuple */[
          /* [] */0,
          b
        ]);
    var na$prime = match$1[0];
    var v = aux(EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                na$prime,
                match[1]
              ]), env), match$1[1], 1, /* :: */[
          na$prime,
          /* [] */0
        ], b);
    return /* tuple */[
            rigid[0],
            Util$ReactTemplate.$$Array[/* to_list */9](v)
          ];
  } else {
    return /* tuple */[
            /* true */1,
            /* [] */0
          ];
  }
}

function compute_implicits_flags(env, sigma, f, all, t) {
  return compute_implicits_gen(f[/* strict */1] || f[/* strongly_strict */2], f[/* strongly_strict */2], f[/* reversible_pattern */3], f[/* contextual */4], all, env, sigma, t);
}

function compute_auto_implicits(env, sigma, flags, enriching, t) {
  if (enriching) {
    return compute_implicits_flags(env, sigma, flags, /* true */1, t);
  } else {
    return compute_implicits_gen(/* false */0, /* false */0, /* false */0, /* true */1, /* true */1, env, sigma, t);
  }
}

function compute_implicits_names(env, sigma, t) {
  var match = compute_implicits_gen(/* false */0, /* false */0, /* false */0, /* false */0, /* true */1, env, sigma, t);
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                return prim[0];
              }), match[1]);
}

function is_status_implicit(param) {
  if (param) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function name_of_implicit(param) {
  if (param) {
    return param[0][0];
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not an implicit argument."));
  }
}

function maximal_insertion_of(param) {
  if (param) {
    return param[0][2][0];
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not an implicit argument."));
  }
}

function force_inference_of(param) {
  if (param) {
    return param[0][2][1];
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not an implicit argument."));
  }
}

function is_inferable_implicit(in_ctx, n, param) {
  if (param) {
    var match = param[0][1];
    if (typeof match === "number") {
      return /* true */1;
    } else {
      switch (match.tag | 0) {
        case 0 : 
            var match$1 = match[0];
            if (match$1) {
              if (in_ctx) {
                return /* true */1;
              } else {
                return +(n >= match$1[0]);
              }
            } else {
              return in_ctx;
            }
        case 1 : 
            return /* false */0;
        case 2 : 
            var match$2 = match[1];
            if (match$2) {
              if (in_ctx) {
                return /* true */1;
              } else {
                return +(n >= match$2[0]);
              }
            } else {
              return in_ctx;
            }
        
      }
    }
  } else {
    return /* false */0;
  }
}

function positions_of_implicits(param) {
  var aux = function (_n, _param) {
    while(true) {
      var param = _param;
      var n = _n;
      if (param) {
        if (param[0]) {
          return /* :: */[
                  n,
                  aux(n + 1 | 0, param[1])
                ];
        } else {
          _param = param[1];
          _n = n + 1 | 0;
          continue ;
          
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return aux(1, param[1]);
}

function prepare_implicits(f, param) {
  if (param) {
    var match = param[0];
    var match$1 = match[0];
    if (match$1) {
      var match$2 = match[1];
      if (match$2) {
        var imps$prime = prepare_implicits(f, param[1]);
        return /* :: */[
                /* Some */[/* tuple */[
                    match$1[0],
                    match$2[0],
                    /* tuple */[
                      set_maximality(imps$prime, f[/* maximal */5]),
                      /* true */1
                    ]
                  ]],
                imps$prime
              ];
      } else {
        return /* :: */[
                /* None */0,
                prepare_implicits(f, param[1])
              ];
      }
    } else if (match[1]) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unnamed implicit."));
    } else {
      return /* :: */[
              /* None */0,
              prepare_implicits(f, param[1])
            ];
    }
  } else {
    return /* [] */0;
  }
}

function assoc_by_pos(k, param) {
  if (param) {
    var hd = param[0];
    var match = hd[0];
    var exit = 0;
    if (match.tag) {
      exit = 1;
    } else if (k === match[0]) {
      return /* tuple */[
              /* tuple */[
                match[1],
                hd[1]
              ],
              param[1]
            ];
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$1 = assoc_by_pos(k, param[1]);
      return /* tuple */[
              match$1[0],
              /* :: */[
                hd,
                match$1[1]
              ]
            ];
    }
    
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function check_correct_manual_implicits(autoimps, l) {
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                var match = param[0];
                if (match.tag) {
                  if (param[1][2]) {
                    return 0;
                  } else {
                    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Wrong or non-dependent implicit argument name: "), Names$ReactTemplate.Id[/* print */8](match[0])), Pp$ReactTemplate.str(".")));
                  }
                } else {
                  var i = match[0];
                  if (i < 1 || i > Curry._1(Util$ReactTemplate.List[/* length */0], autoimps)) {
                    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Bad implicit argument number: "), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(".")));
                  } else {
                    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot set implicit argument number "), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(": it has no name.")));
                  }
                }
              }), l);
}

function set_manual_implicits(_, flags, enriching, autoimps, l) {
  var try_forced = function (k, l) {
    try {
      var match = assoc_by_pos(k, l);
      var match$1 = match[0];
      var match$2 = match$1[1];
      if (match$2[2]) {
        var id = match$1[0];
        var id$1 = id ? id[0] : Names$ReactTemplate.Id[/* of_string */5]("arg_" + Pervasives.string_of_int(k));
        return /* tuple */[
                match[1],
                /* Some */[/* tuple */[
                    id$1,
                    /* Manual */0,
                    /* tuple */[
                      match$2[0],
                      match$2[1]
                    ]
                  ]]
              ];
      } else {
        return /* tuple */[
                l,
                /* None */0
              ];
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* tuple */[
                l,
                /* None */0
              ];
      } else {
        throw exn;
      }
    }
  };
  if (!Curry._1(Util$ReactTemplate.List[/* distinct */58], l)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Some parameters are referred more than once."));
  }
  var merge = function (k, l, param) {
    if (param) {
      var match = param[0];
      var match$1 = match[0];
      if (match$1) {
        var imp = match[1];
        var id = match$1[0];
        var match$2;
        try {
          var match$3 = Curry._3(Util$ReactTemplate.List[/* assoc_f */125], explicitation_eq, /* ExplByName */Block.__(1, [id]), l);
          match$2 = /* tuple */[
            Curry._3(Util$ReactTemplate.List[/* remove_assoc_f */126], explicitation_eq, /* ExplByName */Block.__(1, [id]), l),
            /* Some */[/* Manual */0],
            /* Some */[/* tuple */[
                match$3[0],
                match$3[1]
              ]]
          ];
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            try {
              var match$4 = assoc_by_pos(k, l);
              var match$5 = match$4[0][1];
              match$2 = /* tuple */[
                match$4[1],
                /* Some */[/* Manual */0],
                /* Some */[/* tuple */[
                    match$5[0],
                    match$5[1]
                  ]]
              ];
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                var m = enriching !== 0 && imp ? /* Some */[/* tuple */[
                      flags[/* maximal */5],
                      /* true */1
                    ]] : /* None */0;
                match$2 = /* tuple */[
                  l,
                  imp,
                  m
                ];
              } else {
                throw exn$1;
              }
            }
          } else {
            throw exn;
          }
        }
        var imp$1 = match$2[1];
        var imps$prime = merge(k + 1 | 0, match$2[0], param[1]);
        var m$1 = Option$ReactTemplate.map((function (param) {
                return /* tuple */[
                        set_maximality(imps$prime, param[0]),
                        param[1]
                      ];
              }), match$2[2]);
        return /* :: */[
                Option$ReactTemplate.map((function (param) {
                        var id$1 = id;
                        var imp$2 = imp$1;
                        var insmax = param;
                        return /* tuple */[
                                id$1,
                                imp$2 ? imp$2[0] : /* Manual */0,
                                insmax
                              ];
                      }), m$1),
                imps$prime
              ];
      } else {
        var match$6 = try_forced(k, l);
        return /* :: */[
                match$6[1],
                merge(k + 1 | 0, match$6[0], param[1])
              ];
      }
    } else if (l ? /* false */0 : /* true */1) {
      return /* [] */0;
    } else {
      check_correct_manual_implicits(autoimps, l);
      return /* [] */0;
    }
  };
  return merge(1, l, autoimps);
}

function compute_semi_auto_implicits(env, sigma, f, manual, t) {
  if (manual) {
    var match = compute_auto_implicits(env, sigma, f, f[/* auto */0], t);
    return /* :: */[
            /* tuple */[
              /* DefaultImpArgs */0,
              set_manual_implicits(env, f, f[/* auto */0], match[1], manual)
            ],
            /* [] */0
          ];
  } else if (f[/* auto */0]) {
    var match$1 = compute_implicits_flags(env, sigma, f, /* false */0, t);
    return /* :: */[
            /* tuple */[
              /* DefaultImpArgs */0,
              prepare_implicits(f, match$1[1])
            ],
            /* [] */0
          ];
  } else {
    return /* :: */[
            /* tuple */[
              /* DefaultImpArgs */0,
              /* [] */0
            ],
            /* [] */0
          ];
  }
}

function compute_constant_implicits(flags, manual, cst) {
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_env(env);
  var cb = Environ$ReactTemplate.lookup_constant(cst, env);
  var ty = EConstr$ReactTemplate.of_constr(cb[/* const_type */2]);
  return compute_semi_auto_implicits(env, sigma, flags, manual, ty);
}

function compute_mib_implicits(flags, manual, kn) {
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_env(env);
  var mib = Environ$ReactTemplate.lookup_mind(kn, env);
  var ar = Util$ReactTemplate.$$Array[/* to_list */9](Util$ReactTemplate.$$Array[/* mapi */14]((function (i, mip) {
              var match = Global$ReactTemplate.type_of_global_in_context(env, /* IndRef */Block.__(2, [/* tuple */[
                        kn,
                        i
                      ]]));
              return /* LocalAssum */Block.__(0, [
                        /* Name */[mip[/* mind_typename */0]],
                        match[0]
                      ]);
            }), mib[/* mind_packets */0]));
  var env_ar = Environ$ReactTemplate.push_rel_context(ar, env);
  var imps_one_inductive = function (i, mip) {
    var ind = /* tuple */[
      kn,
      i
    ];
    var match = Global$ReactTemplate.type_of_global_in_context(env, /* IndRef */Block.__(2, [ind]));
    return /* tuple */[
            /* tuple */[
              /* IndRef */Block.__(2, [ind]),
              compute_semi_auto_implicits(env, sigma, flags, manual, EConstr$ReactTemplate.of_constr(match[0]))
            ],
            Util$ReactTemplate.$$Array[/* mapi */14]((function (j, c) {
                    return /* tuple */[
                            /* ConstructRef */Block.__(3, [/* tuple */[
                                  ind,
                                  j + 1 | 0
                                ]]),
                            compute_semi_auto_implicits(env_ar, sigma, flags, manual, c)
                          ];
                  }), Util$ReactTemplate.$$Array[/* map */12](EConstr$ReactTemplate.of_constr, mip[/* mind_nf_lc */8]))
          ];
  };
  return Util$ReactTemplate.$$Array[/* mapi */14](imps_one_inductive, mib[/* mind_packets */0]);
}

function compute_all_mib_implicits(flags, manual, kn) {
  var imps = compute_mib_implicits(flags, manual, kn);
  return Curry._1(Util$ReactTemplate.List[/* flatten */8], Util$ReactTemplate.$$Array[/* map_to_list */44]((function (param) {
                    return /* :: */[
                            param[0],
                            Util$ReactTemplate.$$Array[/* to_list */9](param[1])
                          ];
                  }), imps));
}

function compute_global_implicits(flags, manual, param) {
  switch (param.tag | 0) {
    case 0 : 
        var flags$1 = flags;
        var manual$1 = manual;
        var id = param[0];
        var env = Global$ReactTemplate.env(/* () */0);
        var sigma = Evd$ReactTemplate.from_env(env);
        return compute_semi_auto_implicits(env, sigma, flags$1, manual$1, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], EConstr$ReactTemplate.lookup_named(id, env)));
    case 1 : 
        return compute_constant_implicits(flags, manual, param[0]);
    case 2 : 
        var match = param[0];
        var match$1 = Caml_array.caml_array_get(compute_mib_implicits(flags, manual, match[0]), match[1]);
        return match$1[0][1];
    case 3 : 
        var match$2 = param[0];
        var match$3 = match$2[0];
        var match$4 = Caml_array.caml_array_get(compute_mib_implicits(flags, manual, match$3[0]), match$3[1]);
        return Caml_array.caml_array_get(match$4[1], match$2[1] - 1 | 0)[1];
    
  }
}

function merge_impls(param, param$1) {
  var newimpls = param$1[1];
  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], Curry._1(Util$ReactTemplate.List[/* length */0], newimpls), param[1]);
  return /* tuple */[
          param[0],
          Util$ReactTemplate.$at(Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (orig, ni) {
                      if (orig && typeof orig[0][1] === "number") {
                        return orig;
                      } else {
                        return ni;
                      }
                    }), match[0], newimpls), match[1])
        ];
}

var implicits_table = Summary$ReactTemplate.ref(/* None */0, "implicits", Globnames$ReactTemplate.Refmap[/* empty */0]);

function implicits_of_global(ref) {
  try {
    var l = Curry._2(Globnames$ReactTemplate.Refmap[/* find */21], ref, implicits_table[0]);
    try {
      var rename_l = Arguments_renaming$ReactTemplate.arguments_names(ref);
      var rename = function (implicits, names) {
        if (implicits) {
          var imp = implicits[0];
          var exit = 0;
          if (imp) {
            if (names) {
              var match = names[0];
              if (match) {
                var match$1 = imp[0];
                return /* :: */[
                        /* Some */[/* tuple */[
                            match[0],
                            match$1[1],
                            match$1[2]
                          ]],
                        rename(implicits[1], names[1])
                      ];
              } else {
                exit = 1;
              }
            } else {
              return implicits;
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            if (names) {
              return /* :: */[
                      imp,
                      rename(implicits[1], names[1])
                    ];
            } else {
              return implicits;
            }
          }
          
        } else {
          return /* [] */0;
        }
      };
      return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return /* tuple */[
                            param[0],
                            rename(param[1], rename_l)
                          ];
                  }), l);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return l;
      } else {
        throw exn;
      }
    }
  }
  catch (exn$1){
    if (exn$1 === Caml_builtin_exceptions.not_found) {
      return /* :: */[
              /* tuple */[
                /* DefaultImpArgs */0,
                /* [] */0
              ],
              /* [] */0
            ];
    } else {
      throw exn$1;
    }
  }
}

function cache_implicits_decl(param) {
  implicits_table[0] = Curry._3(Globnames$ReactTemplate.Refmap[/* add */3], param[0], param[1], implicits_table[0]);
  return /* () */0;
}

function load_implicits(_, param) {
  return Curry._2(Util$ReactTemplate.List[/* iter */9], cache_implicits_decl, param[1][1]);
}

function cache_implicits(o) {
  return load_implicits(1, o);
}

function subst_implicits(param) {
  var subst = param[0];
  return /* tuple */[
          /* ImplLocal */0,
          Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
                  var subst$1 = subst;
                  var o = param;
                  var r = o[0];
                  var r$prime = Globnames$ReactTemplate.subst_global(subst$1, r)[0];
                  if (r === r$prime) {
                    return o;
                  } else {
                    return /* tuple */[
                            r$prime,
                            o[1]
                          ];
                  }
                }), param[1][1])
        ];
}

function impls_of_context(ctx) {
  var map = function (param) {
    if (param[1] !== 0) {
      return /* Some */[/* tuple */[
                Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], param[0]),
                /* Manual */0,
                /* tuple */[
                  /* true */1,
                  /* true */1
                ]
              ]];
    } else {
      return /* None */0;
    }
  };
  var partial_arg = Context$ReactTemplate.Named[/* Declaration */0][/* is_local_assum */5];
  return Curry._2(Util$ReactTemplate.List[/* rev_map */12], map, Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                    return Util$ReactTemplate.$percent$great((function (prim) {
                                  return prim[0];
                                }), partial_arg, param);
                  }), ctx));
}

function adjust_side_condition(p, param) {
  if (param) {
    return /* LessArgsThan */[param[0] + p | 0];
  } else {
    return /* DefaultImpArgs */0;
  }
}

function add_section_impls(vars, extra_impls, param) {
  var p = Curry._1(Util$ReactTemplate.List[/* length */0], vars) - Curry._1(Util$ReactTemplate.List[/* length */0], extra_impls) | 0;
  return /* tuple */[
          adjust_side_condition(p, param[0]),
          Util$ReactTemplate.$at(extra_impls, param[1])
        ];
}

function discharge_implicits(param) {
  var match = param[1];
  var l = match[1];
  var req = match[0];
  if (typeof req === "number") {
    return /* None */0;
  } else {
    switch (req.tag | 0) {
      case 0 : 
          var con = req[0];
          try {
            var con$prime = Globnames$ReactTemplate.pop_con(con);
            var vars = Lib$ReactTemplate.variable_section_segment_of_reference(/* ConstRef */Block.__(1, [con]));
            var extra_impls = impls_of_context(vars);
            var newimpls = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return add_section_impls(vars, extra_impls, param);
                  }), Curry._1(Util$ReactTemplate.List[/* hd */1], l)[1]);
            var l$prime_000 = /* tuple */[
              /* ConstRef */Block.__(1, [con$prime]),
              newimpls
            ];
            var l$prime = /* :: */[
              l$prime_000,
              /* [] */0
            ];
            return /* Some */[/* tuple */[
                      /* ImplConstant */Block.__(0, [
                          con$prime,
                          req[1]
                        ]),
                      l$prime
                    ]];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* Some */[/* tuple */[
                        req,
                        l
                      ]];
            } else {
              throw exn;
            }
          }
          break;
      case 1 : 
          try {
            var l$prime$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    var gr = param[0];
                    var vars = Lib$ReactTemplate.variable_section_segment_of_reference(gr);
                    var extra_impls = impls_of_context(vars);
                    return /* tuple */[
                            Globnames$ReactTemplate.isVarRef(gr) ? gr : Globnames$ReactTemplate.pop_global_reference(gr),
                            Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                    return add_section_impls(vars, extra_impls, param);
                                  }), param[1])
                          ];
                  }), l);
            return /* Some */[/* tuple */[
                      /* ImplMutualInductive */Block.__(1, [
                          Globnames$ReactTemplate.pop_kn(req[0]),
                          req[1]
                        ]),
                      l$prime$1
                    ]];
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              return /* Some */[/* tuple */[
                        req,
                        l
                      ]];
            } else {
              throw exn$1;
            }
          }
          break;
      case 2 : 
          var ref = req[0];
          try {
            var vars$1 = Lib$ReactTemplate.variable_section_segment_of_reference(ref);
            var ref$prime = Globnames$ReactTemplate.isVarRef(ref) ? ref : Globnames$ReactTemplate.pop_global_reference(ref);
            var extra_impls$1 = impls_of_context(vars$1);
            var l$prime_000$1 = /* tuple */[
              ref$prime,
              Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                      return add_section_impls(vars$1, extra_impls$1, param);
                    }), Curry._1(Util$ReactTemplate.List[/* hd */1], l)[1])
            ];
            var l$prime$2 = /* :: */[
              l$prime_000$1,
              /* [] */0
            ];
            return /* Some */[/* tuple */[
                      /* ImplInteractive */Block.__(2, [
                          ref$prime,
                          req[1],
                          req[2]
                        ]),
                      l$prime$2
                    ]];
          }
          catch (exn$2){
            if (exn$2 === Caml_builtin_exceptions.not_found) {
              return /* Some */[/* tuple */[
                        req,
                        l
                      ]];
            } else {
              throw exn$2;
            }
          }
          break;
      
    }
  }
}

function rebuild_implicits(param) {
  var l = param[1];
  var req = param[0];
  if (typeof req === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "impargs.ml",
            573,
            17
          ]
        ];
  } else {
    switch (req.tag | 0) {
      case 0 : 
          var con = req[0];
          var oldimpls = Curry._1(Util$ReactTemplate.List[/* hd */1], l)[1];
          var newimpls = compute_constant_implicits(req[1], /* [] */0, con);
          return /* tuple */[
                  req,
                  /* :: */[
                    /* tuple */[
                      /* ConstRef */Block.__(1, [con]),
                      Curry._3(Util$ReactTemplate.List[/* map2 */16], merge_impls, oldimpls, newimpls)
                    ],
                    /* [] */0
                  ]
                ];
      case 1 : 
          var newimpls$1 = compute_all_mib_implicits(req[1], /* [] */0, req[0]);
          var aux = function (olds, news) {
            if (olds) {
              if (news) {
                var match = news[0];
                return /* :: */[
                        /* tuple */[
                          match[0],
                          Curry._3(Util$ReactTemplate.List[/* map2 */16], merge_impls, olds[0][1], match[1])
                        ],
                        aux(olds[1], news[1])
                      ];
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "impargs.ml",
                        585,
                        11
                      ]
                    ];
              }
            } else if (news) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "impargs.ml",
                      585,
                      11
                    ]
                  ];
            } else {
              return /* [] */0;
            }
          };
          return /* tuple */[
                  req,
                  aux(l, newimpls$1)
                ];
      case 2 : 
          var o = req[2];
          var flags = req[1];
          var ref = req[0];
          var tmp;
          if (o) {
            var oldimpls$1 = Curry._1(Util$ReactTemplate.List[/* hd */1], l)[1];
            if (flags[/* auto */0]) {
              var newimpls$2 = Curry._1(Util$ReactTemplate.List[/* hd */1], compute_global_implicits(flags, /* [] */0, ref));
              var p = Curry._1(Util$ReactTemplate.List[/* length */0], newimpls$2[1]) - o[0] | 0;
              var newimpls$3 = Util$ReactTemplate.on_snd(Curry._1(Util$ReactTemplate.List[/* firstn */104], p), newimpls$2);
              tmp = /* :: */[
                /* tuple */[
                  ref,
                  Curry._2(Util$ReactTemplate.List[/* map */10], (function (o) {
                          return merge_impls(o, newimpls$3);
                        }), oldimpls$1)
                ],
                /* [] */0
              ];
            } else {
              tmp = /* :: */[
                /* tuple */[
                  ref,
                  oldimpls$1
                ],
                /* [] */0
              ];
            }
          } else {
            var oldimpls$2 = Curry._1(Util$ReactTemplate.List[/* hd */1], l)[1];
            var newimpls$4 = compute_global_implicits(flags, /* [] */0, ref);
            tmp = /* :: */[
              /* tuple */[
                ref,
                Curry._3(Util$ReactTemplate.List[/* map2 */16], merge_impls, oldimpls$2, newimpls$4)
              ],
              /* [] */0
            ];
          }
          return /* tuple */[
                  Globnames$ReactTemplate.isVarRef(ref) && Lib$ReactTemplate.is_in_section(ref) ? /* ImplLocal */0 : req,
                  tmp
                ];
      
    }
  }
}

function classify_implicits(obj) {
  if (typeof obj[0] === "number") {
    return /* Dispose */0;
  } else {
    return /* Substitute */Block.__(0, [obj]);
  }
}

var init = Libobject$ReactTemplate.default_object("IMPLICITS");

var inImplicits = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_implicits,
      /* load_function */load_implicits,
      /* open_function */init[/* open_function */3],
      /* classify_function */classify_implicits,
      /* subst_function */subst_implicits,
      /* discharge_function */discharge_implicits,
      /* rebuild_function */rebuild_implicits
    ]);

function is_local(local, ref) {
  if (local) {
    return /* true */1;
  } else if (Globnames$ReactTemplate.isVarRef(ref)) {
    return Lib$ReactTemplate.is_in_section(ref);
  } else {
    return /* false */0;
  }
}

function declare_implicits_gen(req, flags, ref) {
  var imps = compute_global_implicits(flags, /* [] */0, ref);
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inImplicits, /* tuple */[
                  req,
                  /* :: */[
                    /* tuple */[
                      ref,
                      imps
                    ],
                    /* [] */0
                  ]
                ]));
}

function declare_implicits(local, ref) {
  var newrecord = implicit_args[0].slice();
  newrecord[/* auto */0] = /* true */1;
  var req = is_local(local, ref) ? /* ImplLocal */0 : /* ImplInteractive */Block.__(2, [
        ref,
        newrecord,
        /* ImplAuto */0
      ]);
  return declare_implicits_gen(req, newrecord, ref);
}

function declare_var_implicits(id) {
  var flags = implicit_args[0];
  return declare_implicits_gen(/* ImplLocal */0, flags, /* VarRef */Block.__(0, [id]));
}

function declare_constant_implicits(con) {
  var flags = implicit_args[0];
  return declare_implicits_gen(/* ImplConstant */Block.__(0, [
                con,
                flags
              ]), flags, /* ConstRef */Block.__(1, [con]));
}

function declare_mib_implicits(kn) {
  var flags = implicit_args[0];
  var imps = Util$ReactTemplate.$$Array[/* map_to_list */44]((function (param) {
          return /* :: */[
                  param[0],
                  Util$ReactTemplate.$$Array[/* to_list */9](param[1])
                ];
        }), compute_mib_implicits(flags, /* [] */0, kn));
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inImplicits, /* tuple */[
                  /* ImplMutualInductive */Block.__(1, [
                      kn,
                      flags
                    ]),
                  Curry._1(Util$ReactTemplate.List[/* flatten */8], imps)
                ]));
}

function compute_implicits_with_manual(env, sigma, typ, enriching, l) {
  var match = compute_auto_implicits(env, sigma, implicit_args[0], enriching, typ);
  return set_manual_implicits(env, implicit_args[0], enriching, match[1], l);
}

function check_inclusion(l) {
  var _param = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return Curry._1(Util$ReactTemplate.List[/* length */0], param[0]);
        }), l);
  while(true) {
    var param = _param;
    if (param) {
      var nl = param[1];
      if (nl) {
        if (Caml_obj.caml_lessequal(param[0], nl[0])) {
          CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Sequences of implicit arguments must be of different lengths."));
        }
        _param = nl;
        continue ;
        
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

function check_rigidity(isrigid) {
  if (isrigid) {
    return 0;
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.strbrk("Multiple sequences of implicit arguments available only for references that cannot be applied to an arbitrarily large number of arguments."));
  }
}

function projection_implicits(env, p, impls) {
  var pb = Environ$ReactTemplate.lookup_projection(p, env);
  return CList$ReactTemplate.skipn_at_least(pb[/* proj_npars */1], impls);
}

function declare_manual_implicits(local, ref, enriching, l) {
  var flags = implicit_args[0];
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_env(env);
  var match = Global$ReactTemplate.type_of_global_in_context(env, ref);
  var enriching$1 = Option$ReactTemplate.$$default(flags[/* auto */0], enriching);
  var match$1 = compute_auto_implicits(env, sigma, flags, enriching$1, EConstr$ReactTemplate.of_constr(match[0]));
  var autoimpls = match$1[1];
  var l$prime;
  if (l) {
    if (l[1]) {
      check_rigidity(match$1[0]);
      var l$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (imps) {
              return /* tuple */[
                      imps,
                      Curry._1(Util$ReactTemplate.List[/* length */0], imps)
                    ];
            }), l);
      var l$2 = Curry._2(Util$ReactTemplate.List[/* sort */38], (function (param, param$1) {
              return param$1[1] - param[1] | 0;
            }), l$1);
      check_inclusion(l$2);
      var nargs = Curry._1(Util$ReactTemplate.List[/* length */0], autoimpls);
      l$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return /* tuple */[
                      /* LessArgsThan */[nargs - param[1] | 0],
                      set_manual_implicits(env, flags, enriching$1, autoimpls, param[0])
                    ];
            }), l$2);
    } else {
      l$prime = /* :: */[
        /* tuple */[
          /* DefaultImpArgs */0,
          set_manual_implicits(env, flags, enriching$1, autoimpls, l[0])
        ],
        /* [] */0
      ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "impargs.ml",
            685,
            12
          ]
        ];
  }
  var req = is_local(local, ref) ? /* ImplLocal */0 : /* ImplInteractive */Block.__(2, [
        ref,
        flags,
        /* ImplManual */[Curry._1(Util$ReactTemplate.List[/* length */0], autoimpls)]
      ]);
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inImplicits, /* tuple */[
                  req,
                  /* :: */[
                    /* tuple */[
                      ref,
                      l$prime
                    ],
                    /* [] */0
                  ]
                ]));
}

function maybe_declare_manual_implicits(local, ref, enriching, l) {
  if (l) {
    return declare_manual_implicits(local, ref, enriching, /* :: */[
                l,
                /* [] */0
              ]);
  } else {
    return /* () */0;
  }
}

function extract_impargs_data(impls) {
  var aux = function (p, param) {
    if (param) {
      var match = param[0];
      var match$1 = match[0];
      if (match$1) {
        var n = match$1[0];
        return /* :: */[
                /* tuple */[
                  /* Some */[/* tuple */[
                      p,
                      n
                    ]],
                  match[1]
                ],
                aux(n + 1 | 0, param[1])
              ];
      } else {
        return /* :: */[
                /* tuple */[
                  /* None */0,
                  match[1]
                ],
                /* [] */0
              ];
      }
    } else {
      return /* [] */0;
    }
  };
  return aux(0, impls);
}

function lift_implicits(n) {
  return Curry._1(Util$ReactTemplate.List[/* map */10], (function (x) {
                var match = x[0];
                if (match.tag) {
                  return x;
                } else {
                  return /* tuple */[
                          /* ExplByPos */Block.__(0, [
                              match[0] + n | 0,
                              match[1]
                            ]),
                          x[1]
                        ];
                }
              }));
}

function make_implicits_list(l) {
  return /* :: */[
          /* tuple */[
            /* DefaultImpArgs */0,
            l
          ],
          /* [] */0
        ];
}

function drop_first_implicits(_p, _l) {
  while(true) {
    var l = _l;
    var p = _p;
    if (p) {
      var match = l[0];
      if (l[1]) {
        if (match) {
          var match$1 = l[1];
          var n = match[0];
          var n$1 = is_status_implicit(match$1[0]) ? n - 1 | 0 : n;
          _l = /* tuple */[
            /* LessArgsThan */[n$1],
            match$1[1]
          ];
          _p = p - 1 | 0;
          continue ;
          
        } else {
          _l = /* tuple */[
            /* DefaultImpArgs */0,
            l[1][1]
          ];
          _p = p - 1 | 0;
          continue ;
          
        }
      } else {
        return l;
      }
    } else {
      return l;
    }
  };
}

function select_impargs_size(n, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      var match$1 = match[0];
      if (param[1]) {
        if (match$1) {
          if (n <= match$1[0]) {
            return match[1];
          } else {
            _param = param[1];
            continue ;
            
          }
        } else {
          return match[1];
        }
      } else {
        return match[1];
      }
    } else {
      return /* [] */0;
    }
  };
}

function select_stronger_impargs(param) {
  if (param) {
    return param[0][1];
  } else {
    return /* [] */0;
  }
}

exports.make_implicit_args = make_implicit_args;
exports.make_strict_implicit_args = make_strict_implicit_args;
exports.make_strongly_strict_implicit_args = make_strongly_strict_implicit_args;
exports.make_reversible_pattern_implicit_args = make_reversible_pattern_implicit_args;
exports.make_contextual_implicit_args = make_contextual_implicit_args;
exports.make_maximal_implicit_args = make_maximal_implicit_args;
exports.is_implicit_args = is_implicit_args;
exports.is_strict_implicit_args = is_strict_implicit_args;
exports.is_strongly_strict_implicit_args = is_strongly_strict_implicit_args;
exports.is_reversible_pattern_implicit_args = is_reversible_pattern_implicit_args;
exports.is_contextual_implicit_args = is_contextual_implicit_args;
exports.is_maximal_implicit_args = is_maximal_implicit_args;
exports.with_implicit_protection = with_implicit_protection;
exports.is_status_implicit = is_status_implicit;
exports.is_inferable_implicit = is_inferable_implicit;
exports.name_of_implicit = name_of_implicit;
exports.maximal_insertion_of = maximal_insertion_of;
exports.force_inference_of = force_inference_of;
exports.positions_of_implicits = positions_of_implicits;
exports.compute_implicits_with_manual = compute_implicits_with_manual;
exports.compute_implicits_names = compute_implicits_names;
exports.declare_var_implicits = declare_var_implicits;
exports.declare_constant_implicits = declare_constant_implicits;
exports.declare_mib_implicits = declare_mib_implicits;
exports.declare_implicits = declare_implicits;
exports.declare_manual_implicits = declare_manual_implicits;
exports.maybe_declare_manual_implicits = maybe_declare_manual_implicits;
exports.implicits_of_global = implicits_of_global;
exports.extract_impargs_data = extract_impargs_data;
exports.lift_implicits = lift_implicits;
exports.make_implicits_list = make_implicits_list;
exports.drop_first_implicits = drop_first_implicits;
exports.projection_implicits = projection_implicits;
exports.select_impargs_size = select_impargs_size;
exports.select_stronger_impargs = select_stronger_impargs;
exports.explicitation_eq = explicitation_eq;
/* implicits_table Not a pure module */
