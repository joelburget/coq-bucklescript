// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Cooking$ReactTemplate = require("./cooking.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Typeops$ReactTemplate = require("./typeops.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Indtypes$ReactTemplate = require("./indtypes.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var CEphemeron$ReactTemplate = require("./cEphemeron.bs.js");
var Cemitcodes$ReactTemplate = require("./cemitcodes.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");
var Opaqueproof$ReactTemplate = require("./opaqueproof.bs.js");

function equal_eff(e1, e2) {
  var match = e1[/* eff */1];
  if (match.tag) {
    var match$1 = e2[/* eff */1];
    if (match$1.tag) {
      return CList$ReactTemplate.for_all2eq((function (param, param$1) {
                    return Names$ReactTemplate.Constant[/* equal */12](param[1], param$1[1]);
                  }), match[0], match$1[0]);
    } else {
      return /* false */0;
    }
  } else {
    var match$2 = e2[/* eff */1];
    if (match$2.tag) {
      return /* false */0;
    } else {
      return Names$ReactTemplate.Constant[/* equal */12](match[0], match$2[0]);
    }
  }
}

function compare(e1, e2) {
  var e1$1 = e1[/* eff */1];
  var e2$1 = e2[/* eff */1];
  if (e1$1.tag) {
    if (e2$1.tag) {
      var cmp = function (param, param$1) {
        return Curry._2(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], param[1], param$1[1]);
      };
      return CList$ReactTemplate.compare(cmp, e1$1[0], e2$1[0]);
    } else {
      return 1;
    }
  } else if (e2$1.tag) {
    return -1;
  } else {
    return Curry._2(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], e1$1[0], e2$1[0]);
  }
}

var SeffOrd = /* module */[/* compare */compare];

var SeffSet = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], SeffOrd);

var empty_001 = /* elts */SeffSet[/* empty */0];

var empty = /* record */[
  /* seff : [] */0,
  empty_001
];

function add(x, es) {
  if (Curry._2(SeffSet[/* mem */2], x, es[/* elts */1])) {
    return es;
  } else {
    return /* record */[
            /* seff : :: */[
              x,
              es[/* seff */0]
            ],
            /* elts */Curry._2(SeffSet[/* add */3], x, es[/* elts */1])
          ];
  }
}

function concat(xes, yes) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], add, xes[/* seff */0], yes);
}

function uniq_seff(l) {
  return Curry._1(Util$ReactTemplate.List[/* rev */4], l[/* seff */0]);
}

function mk_pure_proof(c) {
  return /* tuple */[
          /* tuple */[
            c,
            Univ$ReactTemplate.ContextSet[/* empty */0]
          ],
          empty
        ];
}

function inline_side_effects(env, body, ctx, side_eff) {
  var filter = function (param) {
    var se = param[/* eff */1];
    var cbl;
    cbl = se.tag ? Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return /* tuple */[
                      param[1],
                      param[2],
                      param[3]
                    ];
            }), se[0]) : /* :: */[
        /* tuple */[
          se[0],
          se[1],
          se[2]
        ],
        /* [] */0
      ];
    var not_exists = function (param) {
      try {
        Environ$ReactTemplate.lookup_constant(param[0], env);
        return /* false */0;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* true */1;
        } else {
          throw exn;
        }
      }
    };
    var cbl$1 = Curry._2(Util$ReactTemplate.List[/* filter */27], not_exists, cbl);
    return /* tuple */[
            cbl$1,
            param[/* from_env */0]
          ];
  };
  var side_eff$1 = Curry._2(Util$ReactTemplate.List[/* map */10], filter, side_eff[/* seff */0]);
  var sigs = Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (param) {
          return /* tuple */[
                  param[1],
                  Curry._1(Util$ReactTemplate.List[/* length */0], param[0])
                ];
        }), side_eff$1);
  var side_eff$2 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (accu, param) {
          return Util$ReactTemplate.$at(param[0], accu);
        }), /* [] */0, side_eff$1);
  var side_eff$3 = Curry._1(Util$ReactTemplate.List[/* rev */4], side_eff$2);
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], side_eff$3)) {
    return /* tuple */[
            body,
            ctx,
            sigs
          ];
  } else {
    var cname = function (c) {
      var name = Names$ReactTemplate.Constant[/* to_string */15](c);
      var map = function (c) {
        if (c === /* "." */46 || c === /* "#" */35) {
          return /* "_" */95;
        } else {
          return c;
        }
      };
      var name$1 = Curry._2(Util$ReactTemplate.$$String[/* map */9], map, name);
      return /* Name */[Names$ReactTemplate.Id[/* of_string */5](name$1)];
    };
    var fold = function (param, param$1) {
      var b = param$1[2];
      var cb = param$1[1];
      var c = param$1[0];
      var args = param[3];
      var ctx = param[2];
      var $$var = param[1];
      var subst = param[0];
      var match = cb[/* const_body */1];
      var match$1;
      var exit = 0;
      switch (match.tag | 0) {
        case 0 : 
            exit = 1;
            break;
        case 1 : 
            match$1 = /* tuple */[
              Mod_subst$ReactTemplate.force_constr(match[0]),
              /* false */0
            ];
            break;
        case 2 : 
            if (typeof b === "number" || b[0] !== -746172159) {
              exit = 1;
            } else {
              match$1 = /* tuple */[
                b[1][0],
                /* true */1
              ];
            }
            break;
        
      }
      if (exit === 1) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "term_typing.ml",
                127,
                13
              ]
            ];
      }
      var b$1 = match$1[0];
      var match$2 = cb[/* const_universes */4];
      if (match$2.tag) {
        var subst$1 = Curry._3(Names$ReactTemplate.Cmap_env[/* add */3], c, /* Inl */Block.__(0, [b$1]), subst);
        return /* tuple */[
                subst$1,
                $$var,
                ctx,
                args
              ];
      } else {
        var ty = cb[/* const_type */2];
        var subst$2 = Curry._3(Names$ReactTemplate.Cmap_env[/* add */3], c, /* Inr */Block.__(1, [$$var]), subst);
        var ctx$1 = Univ$ReactTemplate.ContextSet[/* union */6](ctx, match$2[0]);
        return /* tuple */[
                subst$2,
                $$var + 1 | 0,
                ctx$1,
                /* :: */[
                  /* tuple */[
                    cname(c),
                    b$1,
                    ty,
                    match$1[1]
                  ],
                  args
                ]
              ];
      }
    };
    var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, /* tuple */[
          Names$ReactTemplate.Cmap_env[/* empty */0],
          1,
          ctx,
          /* [] */0
        ], side_eff$3);
    var len = match[1];
    var subst = match[0];
    var subst_const = function (i, k, _t) {
      while(true) {
        var t = _t;
        var match = Constr$ReactTemplate.kind(t);
        switch (match.tag | 0) {
          case 0 : 
              var n = match[0];
              if (n <= k) {
                return t;
              } else {
                return Constr$ReactTemplate.mkRel(((n + len | 0) - i | 0) - 1 | 0);
              }
          case 10 : 
              var match$1 = match[0];
              var data;
              try {
                data = /* Some */[Curry._2(Names$ReactTemplate.Cmap_env[/* find */21], match$1[0], subst)];
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  data = /* None */0;
                } else {
                  throw exn;
                }
              }
              if (data) {
                var match$2 = data[0];
                if (match$2.tag) {
                  return Constr$ReactTemplate.mkRel((k + match$2[0] | 0) - i | 0);
                } else {
                  _t = Vars$ReactTemplate.subst_instance_constr(match$1[1], match$2[0]);
                  continue ;
                  
                }
              } else {
                return t;
              }
              break;
          default:
            return Constr$ReactTemplate.map_with_binders((function (param) {
                          return 1 + param | 0;
                        }), (function (k, t) {
                          return subst_const(i, k, t);
                        }), k, t);
        }
      };
    };
    var map_args = function (i, param) {
      var ty = subst_const((len - i | 0) - 1 | 0, 0, param[2]);
      var b = subst_const((len - i | 0) - 1 | 0, 0, param[1]);
      return /* tuple */[
              param[0],
              b,
              ty,
              param[3]
            ];
    };
    var args = Curry._2(Util$ReactTemplate.List[/* mapi */11], map_args, match[3]);
    var body$1 = subst_const(0, 0, body);
    var fold_arg = function (param, accu) {
      var ty = param[2];
      var b = param[1];
      var na = param[0];
      if (param[3]) {
        return Constr$ReactTemplate.mkApp(/* tuple */[
                    Constr$ReactTemplate.mkLambda(/* tuple */[
                          na,
                          ty,
                          accu
                        ]),
                    /* array */[b]
                  ]);
      } else {
        return Constr$ReactTemplate.mkLetIn(/* tuple */[
                    na,
                    b,
                    ty,
                    accu
                  ]);
      }
    };
    var body$2 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], fold_arg, args, body$1);
    return /* tuple */[
            body$2,
            match[2],
            sigs
          ];
  }
}

function is_nth_suffix(_n, _l, suf) {
  while(true) {
    var l = _l;
    var n = _n;
    if (n) {
      if (l) {
        _l = l[1];
        _n = n - 1 | 0;
        continue ;
        
      } else {
        return /* false */0;
      }
    } else {
      return +(l === suf);
    }
  };
}

function check_signatures(curmb, sl) {
  var is_direct_ancestor = function (param, param$1) {
    var curmb = param[1];
    if (curmb) {
      var how_many = param$1[1];
      var sl = param[0];
      try {
        var mb = CEphemeron$ReactTemplate.get(param$1[0]);
        if (sl) {
          if (is_nth_suffix(how_many, mb, curmb[0])) {
            return /* tuple */[
                    /* Some */[sl[0] + how_many | 0],
                    /* Some */[mb]
                  ];
          } else {
            return /* tuple */[
                    /* None */0,
                    /* None */0
                  ];
          }
        } else {
          return /* tuple */[
                  sl,
                  /* None */0
                ];
        }
      }
      catch (exn){
        if (exn === CEphemeron$ReactTemplate.InvalidKey) {
          return /* tuple */[
                  /* None */0,
                  /* None */0
                ];
        } else {
          throw exn;
        }
      }
    } else {
      return /* tuple */[
              /* None */0,
              /* None */0
            ];
    }
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], is_direct_ancestor, /* tuple */[
                /* Some */[0],
                /* Some */[curmb]
              ], sl)[0];
}

function skip_trusted_seff(sl, b, e) {
  var _sl = sl;
  var _b = b;
  var _e = e;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var e$1 = _e;
    var b$1 = _b;
    var sl$1 = _sl;
    var match = Constr$ReactTemplate.kind(b$1);
    if (sl$1) {
      var sl$2 = sl$1[0];
      if (sl$2 !== 0) {
        switch (match.tag | 0) {
          case 8 : 
              var ty = match[2];
              var c = match[1];
              var n = match[0];
              _acc = /* :: */[
                /* `Let */[
                  3802043,
                  /* tuple */[
                    n,
                    c,
                    ty
                  ]
                ],
                acc
              ];
              _e = Environ$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                      n,
                      c,
                      ty
                    ]), e$1);
              _b = match[3];
              _sl = /* Some */[sl$2 - 1 | 0];
              continue ;
              case 9 : 
              var match$1 = Constr$ReactTemplate.kind(match[0]);
              if (match$1.tag === 7) {
                var ty$1 = match$1[1];
                var n$1 = match$1[0];
                _acc = /* :: */[
                  /* `Cut */[
                    3358050,
                    /* tuple */[
                      n$1,
                      ty$1,
                      match[1]
                    ]
                  ],
                  acc
                ];
                _e = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                        n$1,
                        ty$1
                      ]), e$1);
                _b = match$1[2];
                _sl = /* Some */[sl$2 - 1 | 0];
                continue ;
                
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "term_typing.ml",
                        213,
                        14
                      ]
                    ];
              }
              break;
          default:
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "term_typing.ml",
                    215,
                    11
                  ]
                ];
        }
      } else {
        return /* tuple */[
                b$1,
                e$1,
                acc
              ];
      }
    } else {
      return /* tuple */[
              b$1,
              e$1,
              acc
            ];
    }
  };
}

function unzip(_ctx, _j) {
  while(true) {
    var j = _j;
    var ctx = _ctx;
    if (ctx) {
      var match = ctx[0];
      if (match[0] >= 3802043) {
        var match$1 = match[1];
        _j = /* record */[
          /* uj_val */Constr$ReactTemplate.mkLetIn(/* tuple */[
                match$1[0],
                match$1[1],
                match$1[2],
                j[/* uj_val */0]
              ]),
          /* uj_type */j[/* uj_type */1]
        ];
        _ctx = ctx[1];
        continue ;
        
      } else {
        var match$2 = match[1];
        _j = /* record */[
          /* uj_val */Constr$ReactTemplate.mkApp(/* tuple */[
                Constr$ReactTemplate.mkLambda(/* tuple */[
                      match$2[0],
                      match$2[1],
                      j[/* uj_val */0]
                    ]),
                match$2[2]
              ]),
          /* uj_type */j[/* uj_type */1]
        ];
        _ctx = ctx[1];
        continue ;
        
      }
    } else {
      return j;
    }
  };
}

function feedback_completion_typecheck(param) {
  return Option$ReactTemplate.iter((function (state_id) {
                return Feedback$ReactTemplate.feedback(/* None */0, /* Some */[state_id], /* None */0, /* Complete */2);
              }), param);
}

function abstract_constant_universes(param) {
  if (param.tag) {
    var match = Univ$ReactTemplate.abstract_universes(param[0]);
    var sbst = Univ$ReactTemplate.make_instance_subst(match[0]);
    return /* tuple */[
            sbst,
            /* Polymorphic_const */Block.__(1, [match[1]])
          ];
  } else {
    return /* tuple */[
            Univ$ReactTemplate.empty_level_subst,
            /* Monomorphic_const */Block.__(0, [param[0]])
          ];
  }
}

function infer_declaration(trust, env, dcl) {
  switch (dcl.tag | 0) {
    case 0 : 
        var c = dcl[0];
        var match = c[/* const_entry_type */3];
        var exit = 0;
        if (match) {
          var match$1 = c[/* const_entry_universes */4];
          var typ = match[0];
          if (match$1.tag) {
            exit = 1;
          } else if (c[/* const_entry_opaque */5] !== 0) {
            var univs = match$1[0];
            var env$1 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], univs, env);
            var feedback_id = c[/* const_entry_feedback */2];
            var tyj = Typeops$ReactTemplate.infer_type(env$1, typ);
            var proofterm = Future$ReactTemplate.chain(c[/* const_entry_body */0], (function (param) {
                    var match = param[0];
                    var uctx = match[1];
                    var body = match[0];
                    var match$1;
                    if (trust) {
                      var match$2 = inline_side_effects(env$1, body, uctx, param[1]);
                      var uctx$1 = match$2[1];
                      var valid_signatures = check_signatures(trust[0], match$2[2]);
                      var env$2 = Environ$ReactTemplate.push_context_set(/* None */0, uctx$1, env$1);
                      var match$3 = skip_trusted_seff(valid_signatures, match$2[0], env$2);
                      var env$3 = match$3[1];
                      var j = Curry._2(Typeops$ReactTemplate.infer, env$3, match$3[0]);
                      var j$1 = unzip(match$3[2], j);
                      Typeops$ReactTemplate.judge_of_cast(env$3, j$1, /* DEFAULTcast */2, tyj);
                      match$1 = /* tuple */[
                        j$1,
                        uctx$1
                      ];
                    } else {
                      var env$4 = Environ$ReactTemplate.push_context_set(/* None */0, uctx, env$1);
                      var j$2 = Curry._2(Typeops$ReactTemplate.infer, env$4, body);
                      Typeops$ReactTemplate.judge_of_cast(env$4, j$2, /* DEFAULTcast */2, tyj);
                      match$1 = /* tuple */[
                        j$2,
                        uctx
                      ];
                    }
                    var c = Constr$ReactTemplate.hcons(match$1[0][/* uj_val */0]);
                    feedback_completion_typecheck(feedback_id);
                    return /* tuple */[
                            c,
                            match$1[1]
                          ];
                  }));
            var def = /* OpaqueDef */Block.__(2, [Opaqueproof$ReactTemplate.create(proofterm)]);
            return /* record */[
                    /* cook_body */def,
                    /* cook_type */typ,
                    /* cook_proj : None */0,
                    /* cook_universes : Monomorphic_const */Block.__(0, [univs]),
                    /* cook_inline */c[/* const_entry_inline_code */6],
                    /* cook_context */c[/* const_entry_secctx */1]
                  ];
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          var typ$1 = c[/* const_entry_type */3];
          var match$2 = Future$ReactTemplate.join(c[/* const_entry_body */0]);
          var match$3 = match$2[0];
          var ctx = match$3[1];
          var body = match$3[0];
          var match$4 = trust ? inline_side_effects(env, body, ctx, match$2[1]) : /* tuple */[
              body,
              ctx,
              /* [] */0
            ];
          var ctx$1 = match$4[1];
          var match$5 = c[/* const_entry_universes */4];
          var match$6;
          if (match$5.tag) {
            var uctx = match$5[0];
            if (!Univ$ReactTemplate.ContextSet[/* is_empty */1](ctx$1)) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "term_typing.ml",
                      322,
                      17
                    ]
                  ];
            }
            var env$2 = Environ$ReactTemplate.push_context(/* Some */[/* false */0], uctx, env);
            var match$7 = Univ$ReactTemplate.abstract_universes(uctx);
            var sbst = Univ$ReactTemplate.make_instance_subst(match$7[0]);
            match$6 = /* tuple */[
              env$2,
              sbst,
              /* Polymorphic_const */Block.__(1, [match$7[1]])
            ];
          } else {
            var ctx$2 = Univ$ReactTemplate.ContextSet[/* union */6](match$5[0], ctx$1);
            var env$3 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], ctx$2, env);
            match$6 = /* tuple */[
              env$3,
              Univ$ReactTemplate.empty_level_subst,
              /* Monomorphic_const */Block.__(0, [ctx$2])
            ];
          }
          var usubst = match$6[1];
          var env$4 = match$6[0];
          var j = Curry._2(Typeops$ReactTemplate.infer, env$4, match$4[0]);
          var typ$2;
          if (typ$1) {
            var t = typ$1[0];
            var tj = Typeops$ReactTemplate.infer_type(env$4, t);
            Typeops$ReactTemplate.judge_of_cast(env$4, j, /* DEFAULTcast */2, tj);
            typ$2 = Vars$ReactTemplate.subst_univs_level_constr(usubst, t);
          } else {
            typ$2 = Vars$ReactTemplate.subst_univs_level_constr(usubst, j[/* uj_type */1]);
          }
          var def$1 = Constr$ReactTemplate.hcons(Vars$ReactTemplate.subst_univs_level_constr(usubst, j[/* uj_val */0]));
          var def$2 = c[/* const_entry_opaque */5] ? /* OpaqueDef */Block.__(2, [Opaqueproof$ReactTemplate.create(Future$ReactTemplate.from_val(/* None */0, /* tuple */[
                          def$1,
                          Univ$ReactTemplate.ContextSet[/* empty */0]
                        ]))]) : /* Def */Block.__(1, [Mod_subst$ReactTemplate.from_val(def$1)]);
          feedback_completion_typecheck(c[/* const_entry_feedback */2]);
          return /* record */[
                  /* cook_body */def$2,
                  /* cook_type */typ$2,
                  /* cook_proj : None */0,
                  /* cook_universes */match$6[2],
                  /* cook_inline */c[/* const_entry_inline_code */6],
                  /* cook_context */c[/* const_entry_secctx */1]
                ];
        }
        break;
    case 1 : 
        var match$8 = dcl[0];
        var match$9 = match$8[1];
        var uctx$1 = match$9[1];
        var env$5;
        env$5 = uctx$1.tag ? Environ$ReactTemplate.push_context(/* Some */[/* false */0], uctx$1[0], env) : Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], uctx$1[0], env);
        var j$1 = Curry._2(Typeops$ReactTemplate.infer, env$5, match$9[0]);
        var match$10 = abstract_constant_universes(uctx$1);
        var c$1 = Typeops$ReactTemplate.assumption_of_judgment(env$5, j$1);
        var t$1 = Constr$ReactTemplate.hcons(Vars$ReactTemplate.subst_univs_level_constr(match$10[0], c$1));
        return /* record */[
                /* cook_body : Undef */Block.__(0, [match$8[2]]),
                /* cook_type */t$1,
                /* cook_proj : None */0,
                /* cook_universes */match$10[1],
                /* cook_inline : false */0,
                /* cook_context */match$8[0]
              ];
    case 2 : 
        var match$11 = dcl[0];
        var i = match$11[/* proj_entry_arg */1];
        var match$12 = Inductive$ReactTemplate.lookup_mind_specif(env, /* tuple */[
              match$11[/* proj_entry_ind */0],
              0
            ]);
        var mib = match$12[0];
        var match$13 = mib[/* mind_record */1];
        var match$14;
        if (match$13) {
          var match$15 = match$13[0];
          if (match$15) {
            var match$16 = match$15[0];
            var pbs = match$16[2];
            if (i < pbs.length) {
              match$14 = /* tuple */[
                Caml_array.caml_array_get(match$16[1], i),
                Caml_array.caml_array_get(pbs, i)
              ];
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "term_typing.ml",
                      359,
                      6
                    ]
                  ];
            }
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "term_typing.ml",
                    360,
                    13
                  ]
                ];
          }
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "term_typing.ml",
                  360,
                  13
                ]
              ];
        }
        var pb = match$14[1];
        var match$17 = mib[/* mind_universes */8];
        var univs$1;
        switch (match$17.tag | 0) {
          case 0 : 
              univs$1 = /* Monomorphic_const */Block.__(0, [match$17[0]]);
              break;
          case 1 : 
              univs$1 = /* Polymorphic_const */Block.__(1, [match$17[0]]);
              break;
          case 2 : 
              univs$1 = /* Polymorphic_const */Block.__(1, [Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](match$17[0])]);
              break;
          
        }
        var match$18 = pb[/* proj_eta */4];
        return /* record */[
                /* cook_body : Def */Block.__(1, [Mod_subst$ReactTemplate.from_val(Constr$ReactTemplate.hcons(match$18[0]))]),
                /* cook_type */match$18[1],
                /* cook_proj : Some */[pb],
                /* cook_universes */univs$1,
                /* cook_inline : false */0,
                /* cook_context : None */0
              ];
    
  }
}

function build_constant_declaration(kn, env, result) {
  var typ = result[/* cook_type */1];
  var check = function (declared, inferred) {
    var mk_set = function (l) {
      return Curry._3(Util$ReactTemplate.List[/* fold_right */14], Names$ReactTemplate.Id[/* Set */9][/* add */3], Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], l), Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
    };
    var inferred_set = mk_set(inferred);
    var declared_set = mk_set(declared);
    if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* subset */11], inferred_set, declared_set)) {
      return 0;
    } else {
      var l = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], Curry._2(Names$ReactTemplate.Id[/* Set */9][/* diff */8], inferred_set, declared_set));
      var n = Curry._1(Util$ReactTemplate.List[/* length */0], l);
      var declared_vars = Pp$ReactTemplate.pr_sequence(Names$ReactTemplate.Id[/* print */8], Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], declared_set));
      var inferred_vars = Pp$ReactTemplate.pr_sequence(Names$ReactTemplate.Id[/* print */8], Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], inferred_set));
      var missing_vars = Pp$ReactTemplate.pr_sequence(Names$ReactTemplate.Id[/* print */8], Curry._1(Util$ReactTemplate.List[/* rev */4], l));
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist(Pp$ReactTemplate.str, /* :: */[
                                                                                      "The following section ",
                                                                                      /* :: */[
                                                                                        Curry._2(Util$ReactTemplate.$$String[/* plural */33], n, "variable"),
                                                                                        /* :: */[
                                                                                          " ",
                                                                                          /* :: */[
                                                                                            Curry._1(Util$ReactTemplate.$$String[/* conjugate_verb_to_be */34], n),
                                                                                            /* :: */[
                                                                                              " used but not declared:",
                                                                                              /* [] */0
                                                                                            ]
                                                                                          ]
                                                                                        ]
                                                                                      ]
                                                                                    ]), Pp$ReactTemplate.fnl(/* () */0)), missing_vars), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("You can either update your proof to not depend on ")), missing_vars), Pp$ReactTemplate.str(", or you can update your Proof line from")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("Proof using ")), declared_vars), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("to")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("Proof using ")), inferred_vars));
    }
  };
  var sort = function (_, l) {
    return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (decl) {
                  var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl);
                  var partial_arg = Names$ReactTemplate.Id[/* equal */0];
                  var partial_arg$1 = function (param) {
                    return partial_arg(id, param);
                  };
                  var partial_arg$2 = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
                  return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                                return Util$ReactTemplate.$percent$great(partial_arg$2, partial_arg$1, param);
                              }), l);
                }), Environ$ReactTemplate.named_context(env));
  };
  var context_ids = Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], Environ$ReactTemplate.named_context(env));
  var def = result[/* cook_body */0];
  var match = result[/* cook_context */5];
  var match$1;
  if (match) {
    var declared = match[0];
    var tmp;
    switch (def.tag | 0) {
      case 0 : 
          tmp = def;
          break;
      case 1 : 
          var ids_typ = Environ$ReactTemplate.global_vars_set(env, typ);
          var ids_def = Environ$ReactTemplate.global_vars_set(env, Mod_subst$ReactTemplate.force_constr(def[0]));
          var inferred = Environ$ReactTemplate.keep_hyps(env, Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], ids_typ, ids_def));
          check(declared, inferred);
          tmp = def;
          break;
      case 2 : 
          tmp = /* OpaqueDef */Block.__(2, [Opaqueproof$ReactTemplate.iter_direct_opaque((function (c) {
                      var ids_typ = Environ$ReactTemplate.global_vars_set(env, typ);
                      var ids_def = Environ$ReactTemplate.global_vars_set(env, c);
                      var inferred = Environ$ReactTemplate.keep_hyps(env, Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], ids_typ, ids_def));
                      return check(declared, inferred);
                    }), def[0])]);
          break;
      
    }
    match$1 = /* tuple */[
      sort(env, declared),
      tmp
    ];
  } else if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], context_ids)) {
    match$1 = /* tuple */[
      /* [] */0,
      def
    ];
  } else {
    var ids_typ$1 = Environ$ReactTemplate.global_vars_set(env, typ);
    var ids_def$1;
    switch (def.tag | 0) {
      case 0 : 
          ids_def$1 = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
          break;
      case 1 : 
          ids_def$1 = Environ$ReactTemplate.global_vars_set(env, Mod_subst$ReactTemplate.force_constr(def[0]));
          break;
      case 2 : 
          var lc = def[0];
          var vars = Environ$ReactTemplate.global_vars_set(env, Opaqueproof$ReactTemplate.force_proof(Environ$ReactTemplate.opaque_tables(env), lc));
          Opaqueproof$ReactTemplate.force_constraints(Environ$ReactTemplate.opaque_tables(env), lc);
          ids_def$1 = vars;
          break;
      
    }
    match$1 = /* tuple */[
      Environ$ReactTemplate.keep_hyps(env, Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], ids_typ$1, ids_def$1)),
      def
    ];
  }
  var def$1 = match$1[1];
  var hyps = match$1[0];
  var univs = result[/* cook_universes */3];
  var match$2 = result[/* cook_proj */2];
  var res;
  if (match$2) {
    var cb_005 = /* const_proj */result[/* cook_proj */2];
    var cb_006 = /* const_inline_code */result[/* cook_inline */4];
    var cb_007 = /* const_typing_flags */Environ$ReactTemplate.typing_flags(env);
    var cb = /* record */[
      /* const_hyps */hyps,
      /* const_body */def$1,
      /* const_type */typ,
      /* const_body_code : None */0,
      /* const_universes */univs,
      cb_005,
      cb_006,
      cb_007
    ];
    var env$1 = Environ$ReactTemplate.add_constant(kn, cb, env);
    res = Environ$ReactTemplate.compile_constant_body(env$1, univs, def$1);
  } else {
    res = Environ$ReactTemplate.compile_constant_body(env, univs, def$1);
  }
  var tps = Option$ReactTemplate.map(Cemitcodes$ReactTemplate.from_val, res);
  return /* record */[
          /* const_hyps */hyps,
          /* const_body */def$1,
          /* const_type */typ,
          /* const_body_code */tps,
          /* const_universes */univs,
          /* const_proj */result[/* cook_proj */2],
          /* const_inline_code */result[/* cook_inline */4],
          /* const_typing_flags */Environ$ReactTemplate.typing_flags(env)
        ];
}

function translate_constant(mb, env, kn, ce) {
  return build_constant_declaration(kn, env, infer_declaration(mb, env, ce));
}

function constant_entry_of_side_effect(cb, u) {
  var match = cb[/* const_universes */4];
  var univs;
  univs = match.tag ? /* Polymorphic_const_entry */Block.__(1, [Univ$ReactTemplate.AUContext[/* repr */0](match[0])]) : /* Monomorphic_const_entry */Block.__(0, [match[0]]);
  var match$1 = cb[/* const_body */1];
  var pt;
  var exit = 0;
  switch (match$1.tag | 0) {
    case 0 : 
        exit = 1;
        break;
    case 1 : 
        if (u !== 481346541) {
          exit = 1;
        } else {
          pt = /* tuple */[
            Mod_subst$ReactTemplate.force_constr(match$1[0]),
            Univ$ReactTemplate.ContextSet[/* empty */0]
          ];
        }
        break;
    case 2 : 
        if (typeof u === "number") {
          exit = 1;
        } else if (u[0] !== -746172159) {
          exit = 1;
        } else {
          var match$2 = u[1];
          pt = /* tuple */[
            match$2[0],
            match$2[1]
          ];
        }
        break;
    
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "term_typing.ml",
            515,
            11
          ]
        ];
  }
  return /* DefinitionEntry */Block.__(0, [/* record */[
              /* const_entry_body */Future$ReactTemplate.from_val(/* None */0, /* tuple */[
                    pt,
                    /* () */0
                  ]),
              /* const_entry_secctx : None */0,
              /* const_entry_feedback : None */0,
              /* const_entry_type : Some */[cb[/* const_type */2]],
              /* const_entry_universes */univs,
              /* const_entry_opaque */Declareops$ReactTemplate.is_opaque(cb),
              /* const_entry_inline_code */cb[/* const_inline_code */6]
            ]]);
}

function turn_direct(orig) {
  var u = orig[2];
  var cb = orig[1];
  var match = cb[/* const_body */1];
  switch (match.tag | 0) {
    case 0 : 
    case 1 : 
        return orig;
    case 2 : 
        if (typeof u === "number") {
          return orig;
        } else if (u[0] !== -746172159) {
          return orig;
        } else {
          var match$1 = u[1];
          var pt = Future$ReactTemplate.from_val(/* None */0, /* tuple */[
                match$1[0],
                match$1[1]
              ]);
          var newrecord = cb.slice();
          return /* tuple */[
                  orig[0],
                  (newrecord[/* const_body */1] = /* OpaqueDef */Block.__(2, [Opaqueproof$ReactTemplate.create(pt)]), newrecord),
                  u,
                  orig[3]
                ];
        }
        break;
    
  }
}

function export_side_effects(mb, env, c) {
  var body = c[/* const_entry_body */0];
  var match = Future$ReactTemplate.force(body);
  var newrecord = c.slice();
  newrecord[/* const_entry_body */0] = Future$ReactTemplate.chain(body, (function (param) {
          return /* tuple */[
                  param[0],
                  /* () */0
                ];
        }));
  var not_exists = function (param) {
    try {
      Environ$ReactTemplate.lookup_constant(param[0], env);
      return /* false */0;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* true */1;
      } else {
        throw exn;
      }
    }
  };
  var aux = function (param, param$1) {
    var se = param$1[/* eff */1];
    var sl = param[1];
    var acc = param[0];
    var cbl;
    if (se.tag) {
      var k = se[1];
      cbl = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return /* tuple */[
                      param[1],
                      param[2],
                      param[3],
                      /* Schema */[
                        param[0],
                        k
                      ]
                    ];
            }), se[0]);
    } else {
      cbl = /* :: */[
        /* tuple */[
          se[0],
          se[1],
          se[2],
          /* Subproof */0
        ],
        /* [] */0
      ];
    }
    var cbl$1 = Curry._2(Util$ReactTemplate.List[/* filter */27], not_exists, cbl);
    if (cbl$1) {
      return /* tuple */[
              /* :: */[
                cbl$1,
                acc
              ],
              /* :: */[
                /* tuple */[
                  param$1[/* from_env */0],
                  Curry._1(Util$ReactTemplate.List[/* length */0], cbl$1)
                ],
                sl
              ]
            ];
    } else {
      return /* tuple */[
              acc,
              sl
            ];
    }
  };
  var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], aux, /* tuple */[
        /* [] */0,
        /* [] */0
      ], match[1][/* seff */0]);
  var trusted = check_signatures(mb, match$1[1]);
  var push_seff = function (env, param) {
    var match = param[2];
    var cb = param[1];
    var kn = param[0];
    if (typeof match === "number") {
      var env$1 = Environ$ReactTemplate.add_constant(kn, cb, env);
      var match$1 = cb[/* const_universes */4];
      if (match$1.tag) {
        return env$1;
      } else {
        return Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], match$1[0], env$1);
      }
    } else {
      var env$2 = Environ$ReactTemplate.add_constant(kn, cb, env);
      var match$2 = cb[/* const_universes */4];
      if (match$2.tag) {
        return env$2;
      } else {
        var env$3 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], match$2[0], env$2);
        return Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], match[1][1], env$3);
      }
    }
  };
  var _sl = trusted;
  var _seff = match$1[0];
  var _acc = /* [] */0;
  var _env = env;
  while(true) {
    var env$1 = _env;
    var acc = _acc;
    var seff = _seff;
    var sl = _sl;
    var exit = 0;
    if (seff) {
      if (sl) {
        var sl$1 = sl[0];
        if (sl$1 !== 0) {
          var cbs = seff[0];
          var cbs_len = Curry._1(Util$ReactTemplate.List[/* length */0], cbs);
          var cbs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], turn_direct, cbs);
          var env$2 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], push_seff, env$1, cbs$1);
          var ecbs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          param[3]
                        ];
                }), cbs$1);
          _env = env$2;
          _acc = Util$ReactTemplate.$at(ecbs, acc);
          _seff = seff[1];
          _sl = /* Some */[sl$1 - cbs_len | 0];
          continue ;
          
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      return /* tuple */[
              Curry._1(Util$ReactTemplate.List[/* rev */4], acc),
              newrecord
            ];
    }
    if (exit === 1) {
      var match$2 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
              var kn = param$1[0];
              var env = param[0];
              var ce = constant_entry_of_side_effect(param$1[1], param$1[2]);
              var cb = translate_constant(/* Pure */0, env, kn, ce);
              return /* tuple */[
                      push_seff(env, /* tuple */[
                            kn,
                            cb,
                            /* Nothing */481346541,
                            /* Subproof */0
                          ]),
                      /* :: */[
                        /* tuple */[
                          kn,
                          cb,
                          param$1[3]
                        ],
                        param[1]
                      ]
                    ];
            }), /* tuple */[
            env$1,
            /* [] */0
          ], seff[0]);
      _env = match$2[0];
      _acc = Util$ReactTemplate.$at(match$2[1], acc);
      _seff = seff[1];
      continue ;
      
    }
    
  };
}

function translate_local_assum(env, t) {
  var j = Curry._2(Typeops$ReactTemplate.infer, env, t);
  return Typeops$ReactTemplate.assumption_of_judgment(env, j);
}

function translate_recipe(env, kn, r) {
  var match = Names$ReactTemplate.Constant[/* repr3 */6](kn);
  var hcons = Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], match[1]);
  return build_constant_declaration(kn, env, Cooking$ReactTemplate.cook_constant(hcons, env, r));
}

function translate_local_def(env, _, centry) {
  var body = Future$ReactTemplate.from_val(/* None */0, /* tuple */[
        /* tuple */[
          centry[/* secdef_body */0],
          Univ$ReactTemplate.ContextSet[/* empty */0]
        ],
        /* () */0
      ]);
  var centry_001 = /* const_entry_secctx */centry[/* secdef_secctx */1];
  var centry_002 = /* const_entry_feedback */centry[/* secdef_feedback */2];
  var centry_003 = /* const_entry_type */centry[/* secdef_type */3];
  var centry_004 = /* const_entry_universes : Monomorphic_const_entry */Block.__(0, [Univ$ReactTemplate.ContextSet[/* empty */0]]);
  var centry$1 = /* record */[
    /* const_entry_body */body,
    centry_001,
    centry_002,
    centry_003,
    centry_004,
    /* const_entry_opaque : false */0,
    /* const_entry_inline_code : false */0
  ];
  var decl = infer_declaration(/* Pure */0, env, /* DefinitionEntry */Block.__(0, [centry$1]));
  var typ = decl[/* cook_type */1];
  var match = decl[/* cook_universes */3];
  if (match.tag) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "term_typing.ml",
            641,
            27
          ]
        ];
  } else if (!Univ$ReactTemplate.ContextSet[/* is_empty */1](match[0])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "term_typing.ml",
            640,
            29
          ]
        ];
  }
  var match$1 = decl[/* cook_body */0];
  var c;
  switch (match$1.tag | 0) {
    case 0 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "term_typing.ml",
                652,
                15
              ]
            ];
    case 1 : 
        c = Mod_subst$ReactTemplate.force_constr(match$1[0]);
        break;
    case 2 : 
        var o = match$1[0];
        var p = Opaqueproof$ReactTemplate.force_proof(Environ$ReactTemplate.opaque_tables(env), o);
        var cst = Opaqueproof$ReactTemplate.force_constraints(Environ$ReactTemplate.opaque_tables(env), o);
        if (!Univ$ReactTemplate.ContextSet[/* is_empty */1](cst)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "term_typing.ml",
                  650,
                  13
                ]
              ];
        }
        c = p;
        break;
    
  }
  return /* tuple */[
          c,
          typ
        ];
}

var translate_mind = Indtypes$ReactTemplate.check_inductive;

function inline_entry_side_effects(env, ce) {
  var newrecord = ce.slice();
  newrecord[/* const_entry_body */0] = Future$ReactTemplate.chain(ce[/* const_entry_body */0], (function (param) {
          var match = param[0];
          var match$1 = inline_side_effects(env, match[0], match[1], param[1]);
          return /* tuple */[
                  /* tuple */[
                    match$1[0],
                    match$1[1]
                  ],
                  /* () */0
                ];
        }));
  return newrecord;
}

function inline_side_effects$1(env, body, side_eff) {
  return Util$ReactTemplate.pi1(inline_side_effects(env, body, Univ$ReactTemplate.ContextSet[/* empty */0], side_eff));
}

var empty_seff = empty;

var add_seff = add;

var concat_seff = concat;

exports.translate_local_def = translate_local_def;
exports.translate_local_assum = translate_local_assum;
exports.mk_pure_proof = mk_pure_proof;
exports.inline_side_effects = inline_side_effects$1;
exports.inline_entry_side_effects = inline_entry_side_effects;
exports.empty_seff = empty_seff;
exports.add_seff = add_seff;
exports.concat_seff = concat_seff;
exports.uniq_seff = uniq_seff;
exports.equal_eff = equal_eff;
exports.translate_constant = translate_constant;
exports.export_side_effects = export_side_effects;
exports.translate_mind = translate_mind;
exports.translate_recipe = translate_recipe;
exports.infer_declaration = infer_declaration;
exports.build_constant_declaration = build_constant_declaration;
/* SeffSet Not a pure module */
