// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var CString$ReactTemplate = require("./cString.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Impargs$ReactTemplate = require("./impargs.bs.js");
var Miscops$ReactTemplate = require("./miscops.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Classops$ReactTemplate = require("./classops.bs.js");
var Detyping$ReactTemplate = require("./detyping.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Notation$ReactTemplate = require("./notation.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Recordops$ReactTemplate = require("./recordops.bs.js");
var Patternops$ReactTemplate = require("./patternops.bs.js");
var Constrintern$ReactTemplate = require("./constrintern.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Notation_ops$ReactTemplate = require("./notation_ops.bs.js");
var Constrexpr_ops$ReactTemplate = require("./constrexpr_ops.bs.js");

var print_arguments = [/* false */0];

var print_implicits = [/* false */0];

var print_implicits_explicit_args = [/* false */0];

var print_implicits_defensive = [/* true */1];

var print_coercions = [/* false */0];

var print_no_symbol = [/* false */0];

var compare = Caml_obj.caml_compare;

var IRuleSet = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], /* module */[/* compare */compare]);

var inactive_notations_table = Summary$ReactTemplate.ref(/* None */0, "inactive_notations_table", IRuleSet[/* empty */0]);

var inactive_scopes_table = Summary$ReactTemplate.ref(/* None */0, "inactive_scopes_table", CString$ReactTemplate.$$Set[/* empty */0]);

function show_scope(scopt) {
  if (scopt) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("in scope")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(scopt[0]));
  } else {
    return Pp$ReactTemplate.str("");
  }
}

function is_inactive_rule(nr) {
  if (Curry._2(IRuleSet[/* mem */2], nr, inactive_notations_table[0])) {
    return /* true */1;
  } else if (nr.tag) {
    return /* false */0;
  } else {
    var match = nr[0];
    if (match) {
      return Curry._2(CString$ReactTemplate.$$Set[/* mem */2], match[0], inactive_scopes_table[0]);
    } else {
      return /* false */0;
    }
  }
}

function toggle_scope_printing(scope, activate) {
  if (activate) {
    var sc = scope;
    try {
      inactive_scopes_table[0] = Curry._2(CString$ReactTemplate.$$Set[/* remove */5], sc, inactive_scopes_table[0]);
      return /* () */0;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation Scope"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(sc)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is already active.")));
      } else {
        throw exn;
      }
    }
  } else {
    var sc$1 = scope;
    Notation$ReactTemplate.find_scope(sc$1);
    if (Curry._2(CString$ReactTemplate.$$Set[/* mem */2], sc$1, inactive_scopes_table[0])) {
      return Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation Scope"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(sc$1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is already inactive.")));
    } else {
      inactive_scopes_table[0] = Curry._2(CString$ReactTemplate.$$Set[/* add */3], sc$1, inactive_scopes_table[0]);
      return /* () */0;
    }
  }
}

function toggle_notation_printing(scope, notation, activate) {
  if (activate) {
    var nr = /* NotationRule */Block.__(0, [
        scope,
        notation
      ]);
    try {
      inactive_notations_table[0] = Curry._2(IRuleSet[/* remove */5], nr, inactive_notations_table[0]);
      return /* () */0;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        if (nr.tag) {
          return Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(Names$ReactTemplate.KerName[/* to_string */5](nr[0]))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is already active.")));
        } else {
          return Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(nr[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is already active")), show_scope(nr[0])), Pp$ReactTemplate.str(".")));
        }
      } else {
        throw exn;
      }
    }
  } else {
    var nr$1 = /* NotationRule */Block.__(0, [
        scope,
        notation
      ]);
    if (nr$1.tag) {
      inactive_notations_table[0] = Curry._2(IRuleSet[/* add */3], nr$1, inactive_notations_table[0]);
      return /* () */0;
    } else {
      var ntn = nr$1[1];
      var scopt = nr$1[0];
      var match = Notation$ReactTemplate.availability_of_notation(/* tuple */[
            scopt,
            ntn
          ], /* tuple */[
            scopt,
            /* [] */0
          ]);
      if (match) {
        if (Curry._2(IRuleSet[/* mem */2], nr$1, inactive_notations_table[0])) {
          return Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(ntn)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is already inactive")), show_scope(scopt)), Pp$ReactTemplate.str(".")));
        } else {
          inactive_notations_table[0] = Curry._2(IRuleSet[/* add */3], nr$1, inactive_notations_table[0]);
          return /* () */0;
        }
      } else {
        return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Notation"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(ntn), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("does not exist")), scopt ? Pp$ReactTemplate.$plus$plus(show_scope(scopt), Pp$ReactTemplate.str(".")) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("in the empty scope."))));
      }
    }
  }
}

var print_projections = [/* false */0];

var print_meta_as_hole = [/* false */0];

function with_universes(f) {
  return (function (param) {
      return Flags$ReactTemplate.with_option(Detyping$ReactTemplate.print_universes, f, param);
    });
}

function with_meta_as_hole(f) {
  return (function (param) {
      return Flags$ReactTemplate.with_option(print_meta_as_hole, f, param);
    });
}

function without_symbols(f) {
  return (function (param) {
      return Flags$ReactTemplate.with_option(print_no_symbol, f, param);
    });
}

function without_specific_symbols(l) {
  return (function (param, param$1) {
      return Flags$ReactTemplate.with_modified_ref(inactive_notations_table, (function (tbl) {
                    return Curry._2(IRuleSet[/* union */6], Curry._1(IRuleSet[/* of_list */25], l), tbl);
                  }), param, param$1);
    });
}

var record_print = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"record printing",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Records",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return record_print[0];
        }),
      /* optwrite */(function (b) {
          record_print[0] = b;
          return /* () */0;
        })
    ]);

function is_record(indsp) {
  try {
    Recordops$ReactTemplate.lookup_structure(indsp);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function encode_record(r) {
  var indsp = Nametab$ReactTemplate.global_inductive(r);
  if (!is_record(indsp)) {
    CErrors$ReactTemplate.user_err(r[/* loc */1], /* Some */["encode_record"], Pp$ReactTemplate.str("This type is not a structure type."));
  }
  return indsp;
}

function member_message(s, b) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Terms of "), s), Pp$ReactTemplate.str(b ? " are printed using record notation" : " are not printed using record notation"));
}

var PrintingRecordRecord = Detyping$ReactTemplate.PrintingInductiveMake(/* module */[
      /* encode */encode_record,
      /* member_message */member_message,
      /* field */"Record",
      /* title */"Types leading to pretty-printing using record notation: "
    ]);

function member_message$1(s, b) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Terms of "), s), Pp$ReactTemplate.str(b ? " are printed using constructor form" : " are not printed using constructor form"));
}

var PrintingRecordConstructor = Detyping$ReactTemplate.PrintingInductiveMake(/* module */[
      /* encode */encode_record,
      /* member_message */member_message$1,
      /* field */"Constructor",
      /* title */"Types leading to pretty-printing using constructor form: "
    ]);

var PrintingRecord = Goptions$ReactTemplate.MakeRefTable([
      PrintingRecordRecord[0],
      PrintingRecordRecord[1],
      PrintingRecordRecord[2],
      PrintingRecordRecord[3],
      PrintingRecordRecord[4],
      PrintingRecordRecord[5],
      PrintingRecordRecord[6]
    ]);

var PrintingConstructor = Goptions$ReactTemplate.MakeRefTable([
      PrintingRecordConstructor[0],
      PrintingRecordConstructor[1],
      PrintingRecordConstructor[2],
      PrintingRecordConstructor[3],
      PrintingRecordConstructor[4],
      PrintingRecordConstructor[5],
      PrintingRecordConstructor[6]
    ]);

function insert_delimiters(e, param) {
  if (param) {
    var eta_000 = param[0];
    var eta = /* CDelimiters */Block.__(20, [
        eta_000,
        e
      ]);
    return CAst$ReactTemplate.make(/* None */0, eta);
  } else {
    return e;
  }
}

function insert_pat_delimiters(loc, p, param) {
  if (param) {
    return CAst$ReactTemplate.make(loc, /* CPatDelimiters */Block.__(7, [
                  param[0],
                  p
                ]));
  } else {
    return p;
  }
}

function insert_pat_alias(loc, p, na) {
  if (na) {
    return CAst$ReactTemplate.make(loc, /* CPatAlias */Block.__(0, [
                  p,
                  CAst$ReactTemplate.make(loc, na)
                ]));
  } else {
    return p;
  }
}

function default_extern_reference(_, vars, r) {
  var eta = /* Qualid */Block.__(0, [Nametab$ReactTemplate.shortest_qualid_of_global(vars, r)]);
  return CAst$ReactTemplate.make(/* None */0, eta);
}

var my_extern_reference = [default_extern_reference];

function set_extern_reference(f) {
  my_extern_reference[0] = f;
  return /* () */0;
}

function get_extern_reference() {
  return my_extern_reference[0];
}

function extern_reference(_, vars, l) {
  return Curry._3(my_extern_reference[0], /* None */0, vars, l);
}

function add_patt_for_params(ind, l) {
  if (Flags$ReactTemplate.in_debugger[0]) {
    return l;
  } else {
    return Curry._3(Util$ReactTemplate.List[/* addn */109], Inductiveops$ReactTemplate.inductive_nparamdecls(ind), CAst$ReactTemplate.make(/* None */0, /* CPatAtom */Block.__(2, [/* None */0])), l);
  }
}

function add_cpatt_for_params(ind, l) {
  if (Flags$ReactTemplate.in_debugger[0]) {
    return l;
  } else {
    return Curry._3(Util$ReactTemplate.List[/* addn */109], Inductiveops$ReactTemplate.inductive_nparamdecls(ind), DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0])), l);
  }
}

function drop_implicits_in_patt(cst, nb_expl, args) {
  var impl_st = Impargs$ReactTemplate.implicits_of_global(cst);
  var impl_data = Impargs$ReactTemplate.extract_impargs_data(impl_st);
  var impls_fit = function (_l, _param) {
    while(true) {
      var param = _param;
      var l = _l;
      var match = param[0];
      var exit = 0;
      if (match) {
        var match$1 = param[1];
        if (match$1) {
          var match$2 = match$1[0][/* v */0];
          if (match$2.tag === 2) {
            if (match$2[0]) {
              exit = 1;
            } else if (Impargs$ReactTemplate.is_status_implicit(match[0])) {
              _param = /* tuple */[
                match[1],
                match$1[1]
              ];
              continue ;
              
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
        } else {
          return /* None */0;
        }
      } else {
        return /* Some */[Curry._2(Util$ReactTemplate.List[/* rev_append */6], l, param[1])];
      }
      if (exit === 1) {
        var match$3 = param[1];
        if (Impargs$ReactTemplate.is_status_implicit(match[0])) {
          return /* None */0;
        } else {
          _param = /* tuple */[
            match[1],
            match$3[1]
          ];
          _l = /* :: */[
            match$3[0],
            l
          ];
          continue ;
          
        }
      }
      
    };
  };
  if (nb_expl) {
    var imps = Curry._2(Util$ReactTemplate.List[/* skipn_at_least */108], nb_expl, Impargs$ReactTemplate.select_stronger_impargs(impl_st));
    return impls_fit(/* [] */0, /* tuple */[
                imps,
                args
              ]);
  } else {
    var _param = impl_data;
    while(true) {
      var param = _param;
      if (param) {
        var x = impls_fit(/* [] */0, /* tuple */[
              param[0][1],
              args
            ]);
        if (x) {
          return x;
        } else {
          _param = param[1];
          continue ;
          
        }
      } else {
        return /* None */0;
      }
    };
  }
}

function destPrim(param) {
  var match = param[/* v */0];
  if (match.tag === 19) {
    return /* Some */[match[0]];
  } else {
    return /* None */0;
  }
}

function destPatPrim(param) {
  var match = param[/* v */0];
  if (match.tag === 5) {
    return /* Some */[match[0]];
  } else {
    return /* None */0;
  }
}

function is_number(s) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (s.length === i) {
      return /* true */1;
    } else {
      var match = Caml_string.get(s, i);
      if (match > 57 || match < 48) {
        return /* false */0;
      } else {
        _i = i + 1 | 0;
        continue ;
        
      }
    }
  };
}

function is_zero(s) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (s.length === i) {
      return /* true */1;
    } else if (Caml_string.get(s, i) === /* "0" */48) {
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* false */0;
    }
  };
}

function make_notation_gen(loc, ntn, mknot, mkprim, destprim, l, bl) {
  var match = Curry._2(Util$ReactTemplate.List[/* map */10], destprim, l);
  var exit = 0;
  if (ntn === "- _") {
    if (match) {
      var match$1 = match[0];
      if (match$1) {
        var match$2 = match$1[0];
        if (match$2.tag) {
          exit = 1;
        } else if (match$2[1] !== 0) {
          if (match[1]) {
            exit = 1;
          } else if (is_zero(match$2[0])) {
            exit = 1;
          } else {
            if (bl !== /* [] */0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "constrextern.ml",
                      332,
                      8
                    ]
                  ];
            }
            return Curry._1(mknot, /* tuple */[
                        loc,
                        ntn,
                        /* :: */[
                          Curry._1(mknot, /* tuple */[
                                loc,
                                "( _ )",
                                l,
                                /* [] */0
                              ]),
                          /* [] */0
                        ],
                        /* [] */0
                      ]);
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var match$3 = Notation$ReactTemplate.decompose_notation_key(ntn);
    var exit$1 = 0;
    if (match$3) {
      var match$4 = match$3[0];
      if (match$4.tag) {
        exit$1 = 2;
      } else {
        var x = match$4[0];
        var exit$2 = 0;
        if (x === "-") {
          var match$5 = match$3[1];
          if (match$5) {
            var match$6 = match$5[0];
            if (match$6.tag) {
              exit$1 = 2;
            } else if (match$5[1]) {
              exit$1 = 2;
            } else if (l) {
              exit$1 = 2;
            } else {
              var x$1 = match$6[0];
              if (is_number(x$1)) {
                return Curry._1(mkprim, /* tuple */[
                            loc,
                            /* Numeral */Block.__(0, [
                                x$1,
                                /* false */0
                              ])
                          ]);
              } else {
                exit$1 = 2;
              }
            }
          } else {
            exit$2 = 3;
          }
        } else {
          exit$2 = 3;
        }
        if (exit$2 === 3) {
          if (match$3[1]) {
            exit$1 = 2;
          } else if (l) {
            exit$1 = 2;
          } else if (is_number(x)) {
            return Curry._1(mkprim, /* tuple */[
                        loc,
                        /* Numeral */Block.__(0, [
                            x,
                            /* true */1
                          ])
                      ]);
          } else {
            exit$1 = 2;
          }
        }
        
      }
    } else {
      exit$1 = 2;
    }
    if (exit$1 === 2) {
      return Curry._1(mknot, /* tuple */[
                  loc,
                  ntn,
                  l,
                  bl
                ]);
    }
    
  }
  
}

function make_notation(loc, ntn, subst) {
  if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], subst[1]) || !Curry._1(Util$ReactTemplate.List[/* is_empty */45], subst[3])) {
    return CAst$ReactTemplate.make(loc, /* CNotation */Block.__(17, [
                  ntn,
                  subst
                ]));
  } else {
    return make_notation_gen(loc, ntn, (function (param) {
                  return CAst$ReactTemplate.make(param[0], /* CNotation */Block.__(17, [
                                param[1],
                                /* tuple */[
                                  param[2],
                                  /* [] */0,
                                  param[3],
                                  /* [] */0
                                ]
                              ]));
                }), (function (param) {
                  return CAst$ReactTemplate.make(param[0], /* CPrim */Block.__(19, [param[1]]));
                }), destPrim, subst[0], subst[2]);
  }
}

function make_pat_notation(loc, ntn, subst, args) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], subst[1])) {
    return make_notation_gen(loc, ntn, (function (param) {
                  return CAst$ReactTemplate.make(param[0], /* CPatNotation */Block.__(4, [
                                param[1],
                                /* tuple */[
                                  param[2],
                                  /* [] */0
                                ],
                                args
                              ]));
                }), (function (param) {
                  return CAst$ReactTemplate.make(param[0], /* CPatPrim */Block.__(5, [param[1]]));
                }), destPatPrim, subst[0], /* [] */0);
  } else {
    return CAst$ReactTemplate.make(loc, /* CPatNotation */Block.__(4, [
                  ntn,
                  subst,
                  args
                ]));
  }
}

function pattern_printable_in_both_syntax(c) {
  var impl_st = Impargs$ReactTemplate.extract_impargs_data(Impargs$ReactTemplate.implicits_of_global(/* ConstructRef */Block.__(3, [c])));
  var nb_params = Inductiveops$ReactTemplate.inductive_nparams(c[0]);
  return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                var impls = param[1];
                if (Curry._1(Util$ReactTemplate.List[/* length */0], impls) >= nb_params) {
                  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], nb_params, impls);
                  if (Curry._2(Util$ReactTemplate.List[/* for_all */20], Impargs$ReactTemplate.is_status_implicit, match[0])) {
                    return Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (x) {
                                  return 1 - Impargs$ReactTemplate.is_status_implicit(x);
                                }), match[1]);
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              }), impl_st);
}

function lift(f, c) {
  var loc = c[/* loc */1];
  return CAst$ReactTemplate.make(loc, Curry._2(f, loc, DAst$ReactTemplate.get(c)));
}

function extern_cases_pattern_in_scope(scopes, vars, pat) {
  try {
    if (Flags$ReactTemplate.in_debugger[0] || Flags$ReactTemplate.raw_print[0] || print_no_symbol[0]) {
      throw Notation_ops$ReactTemplate.No_match;
    }
    var match = Notation$ReactTemplate.uninterp_prim_token_cases_pattern(pat);
    var p = match[2];
    var match$1 = Notation$ReactTemplate.availability_of_prim_token(p, match[1], scopes);
    if (match$1) {
      var loc = Glob_ops$ReactTemplate.cases_pattern_loc(pat);
      return insert_pat_alias(loc, insert_pat_delimiters(loc, CAst$ReactTemplate.make(loc, /* CPatPrim */Block.__(5, [p])), match$1[0]), match[0]);
    } else {
      throw Notation_ops$ReactTemplate.No_match;
    }
  }
  catch (exn){
    if (exn === Notation_ops$ReactTemplate.No_match) {
      try {
        if (Flags$ReactTemplate.in_debugger[0] || Flags$ReactTemplate.raw_print[0] || print_no_symbol[0]) {
          throw Notation_ops$ReactTemplate.No_match;
        }
        var allscopes = scopes;
        var vars$1 = vars;
        var t = pat;
        var _param = Notation$ReactTemplate.uninterp_cases_pattern_notations(pat);
        while(true) {
          var param = _param;
          if (param) {
            var _rule = param[0];
            var keyrule = _rule[0];
            try {
              if (is_inactive_rule(keyrule)) {
                throw Notation_ops$ReactTemplate.No_match;
              }
              var loc$1 = t[/* loc */1];
              var match$2 = DAst$ReactTemplate.get(t);
              if (match$2.tag) {
                var p$1 = apply_notation_to_pattern(loc$1, /* ConstructRef */Block.__(3, [match$2[0]]), Notation_ops$ReactTemplate.match_notation_constr_cases_pattern(t, _rule[1]), allscopes, vars$1, keyrule);
                return insert_pat_alias(loc$1, p$1, match$2[2]);
              } else {
                var match$3 = match$2[0];
                if (match$3) {
                  return CAst$ReactTemplate.make(loc$1, /* CPatAtom */Block.__(2, [/* Some */[CAst$ReactTemplate.make(loc$1, /* Ident */Block.__(1, [match$3[0]]))]]));
                } else {
                  return CAst$ReactTemplate.make(loc$1, /* CPatAtom */Block.__(2, [/* None */0]));
                }
              }
            }
            catch (exn$1){
              if (exn$1 === Notation_ops$ReactTemplate.No_match) {
                _param = param[1];
                continue ;
                
              } else {
                throw exn$1;
              }
            }
          } else {
            throw Notation_ops$ReactTemplate.No_match;
          }
        };
      }
      catch (exn$2){
        if (exn$2 === Notation_ops$ReactTemplate.No_match) {
          return lift((function (loc, param) {
                        if (param.tag) {
                          var cstrsp = param[0];
                          var args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                  return extern_cases_pattern_in_scope(scopes, vars, param);
                                }), param[1]);
                          var p;
                          try {
                            if (Flags$ReactTemplate.raw_print[0]) {
                              throw Pervasives.Exit;
                            }
                            var projs = Recordops$ReactTemplate.lookup_projections(cstrsp[0]);
                            var ip = function (_projs, _args, _acc) {
                              while(true) {
                                var acc = _acc;
                                var args = _args;
                                var projs = _projs;
                                if (projs) {
                                  if (args) {
                                    var pat = args[0];
                                    var proj = projs[0];
                                    var acc$1;
                                    var exit = 0;
                                    var match = pat[/* v */0];
                                    if (match.tag === 2 && !match[0]) {
                                      acc$1 = acc;
                                    } else {
                                      exit = 1;
                                    }
                                    if (exit === 1) {
                                      if (proj) {
                                        acc$1 = /* :: */[
                                          /* tuple */[
                                            extern_reference(loc, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* ConstRef */Block.__(1, [proj[0]])),
                                            pat
                                          ],
                                          acc
                                        ];
                                      } else {
                                        throw Notation_ops$ReactTemplate.No_match;
                                      }
                                    }
                                    _acc = acc$1;
                                    _args = args[1];
                                    _projs = projs[1];
                                    continue ;
                                    
                                  } else {
                                    throw [
                                          Caml_builtin_exceptions.assert_failure,
                                          [
                                            "constrextern.ml",
                                            413,
                                            18
                                          ]
                                        ];
                                  }
                                } else if (args) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "constrextern.ml",
                                          413,
                                          18
                                        ]
                                      ];
                                } else {
                                  return acc;
                                }
                              };
                            };
                            p = /* CPatRecord */Block.__(6, [Curry._1(Util$ReactTemplate.List[/* rev */4], ip(projs, args, /* [] */0))]);
                          }
                          catch (exn){
                            var exit = 0;
                            if (exn === Caml_builtin_exceptions.not_found) {
                              exit = 1;
                            } else if (exn === Notation_ops$ReactTemplate.No_match) {
                              exit = 1;
                            } else if (exn === Pervasives.Exit) {
                              exit = 1;
                            } else {
                              throw exn;
                            }
                            if (exit === 1) {
                              var c = extern_reference(/* None */0, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* ConstructRef */Block.__(3, [cstrsp]));
                              if (Constrexpr_ops$ReactTemplate.asymmetric_patterns[0]) {
                                p = pattern_printable_in_both_syntax(cstrsp) ? /* CPatCstr */Block.__(1, [
                                      c,
                                      /* None */0,
                                      args
                                    ]) : /* CPatCstr */Block.__(1, [
                                      c,
                                      /* Some */[add_patt_for_params(cstrsp[0], args)],
                                      /* [] */0
                                    ]);
                              } else {
                                var full_args = add_patt_for_params(cstrsp[0], args);
                                var match = drop_implicits_in_patt(/* ConstructRef */Block.__(3, [cstrsp]), 0, full_args);
                                p = match ? /* CPatCstr */Block.__(1, [
                                      c,
                                      /* None */0,
                                      match[0]
                                    ]) : /* CPatCstr */Block.__(1, [
                                      c,
                                      /* Some */[full_args],
                                      /* [] */0
                                    ]);
                              }
                            }
                            
                          }
                          return insert_pat_alias(loc, CAst$ReactTemplate.make(loc, p), param[2])[/* v */0];
                        } else {
                          var match$1 = param[0];
                          if (match$1) {
                            return /* CPatAtom */Block.__(2, [/* Some */[CAst$ReactTemplate.make(loc, /* Ident */Block.__(1, [match$1[0]]))]]);
                          } else {
                            return /* CPatAtom */Block.__(2, [/* None */0]);
                          }
                        }
                      }), pat);
        } else {
          throw exn$2;
        }
      }
    } else {
      throw exn;
    }
  }
}

function apply_notation_to_pattern(loc, gr, param, allscopes, vars, param$1) {
  var scopes = allscopes[1];
  var match = param[1];
  var more_args = match[1];
  var nb_to_drop = match[0];
  var match$1 = param[0];
  var substlist = match$1[1];
  var subst = match$1[0];
  if (param$1.tag) {
    var qid = CAst$ReactTemplate.make(loc, /* Qualid */Block.__(0, [Nametab$ReactTemplate.shortest_qualid_of_syndef(vars, param$1[0])]));
    var l1 = Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (param) {
            var match = param[1];
            return extern_cases_pattern_in_scope(/* tuple */[
                        match[0],
                        Util$ReactTemplate.$at(match[1], scopes)
                      ], vars, param[0]);
          }), subst);
    var l2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            return extern_cases_pattern_in_scope(allscopes, vars, param);
          }), more_args);
    var l2$prime;
    if (Constrexpr_ops$ReactTemplate.asymmetric_patterns[0]) {
      l2$prime = l2;
    } else {
      var match$2 = drop_implicits_in_patt(gr, nb_to_drop + Curry._1(Util$ReactTemplate.List[/* length */0], l1) | 0, l2);
      if (match$2) {
        l2$prime = match$2[0];
      } else {
        throw Notation_ops$ReactTemplate.No_match;
      }
    }
    if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], substlist)) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "constrextern.ml",
              473,
              6
            ]
          ];
    }
    var loc$1 = loc;
    var qid$1 = qid;
    var l = Curry._2(Util$ReactTemplate.List[/* rev_append */6], l1, l2$prime);
    return CAst$ReactTemplate.make(loc$1, Curry._1(Util$ReactTemplate.List[/* is_empty */45], l) ? /* CPatAtom */Block.__(2, [/* Some */[qid$1]]) : /* CPatCstr */Block.__(1, [
                    qid$1,
                    /* None */0,
                    l
                  ]));
  } else {
    var ntn = param$1[1];
    var match$3 = Notation$ReactTemplate.availability_of_notation(/* tuple */[
          param$1[0],
          ntn
        ], allscopes);
    if (match$3) {
      var match$4 = match$3[0];
      var scopes$prime = Option$ReactTemplate.List[/* cons */0](match$4[0], scopes);
      var l$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              var match = param[1];
              return extern_cases_pattern_in_scope(/* tuple */[
                          match[0],
                          Util$ReactTemplate.$at(match[1], scopes$prime)
                        ], vars, param[0]);
            }), subst);
      var ll = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              var match = param[1];
              var subscope_000 = match[0];
              var subscope_001 = Util$ReactTemplate.$at(match[1], scopes$prime);
              var subscope = /* tuple */[
                subscope_000,
                subscope_001
              ];
              return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                            return extern_cases_pattern_in_scope(subscope, vars, param);
                          }), param[0]);
            }), substlist);
      var l2$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return extern_cases_pattern_in_scope(allscopes, vars, param);
            }), more_args);
      var l2$prime$1;
      if (Constrexpr_ops$ReactTemplate.asymmetric_patterns[0] || !Curry._1(Util$ReactTemplate.List[/* is_empty */45], ll)) {
        l2$prime$1 = l2$1;
      } else {
        var match$5 = drop_implicits_in_patt(gr, nb_to_drop, l2$1);
        if (match$5) {
          l2$prime$1 = match$5[0];
        } else {
          throw Notation_ops$ReactTemplate.No_match;
        }
      }
      return insert_pat_delimiters(loc, make_pat_notation(loc, ntn, /* tuple */[
                      l$1,
                      ll
                    ], l2$prime$1), match$4[1]);
    } else {
      throw Notation_ops$ReactTemplate.No_match;
    }
  }
}

function extern_cases_pattern(vars, p) {
  return extern_cases_pattern_in_scope(/* tuple */[
              /* None */0,
              /* [] */0
            ], vars, p);
}

function occur_name(na, aty) {
  if (na) {
    return Constrexpr_ops$ReactTemplate.occur_var_constr_expr(na[0], aty);
  } else {
    return /* false */0;
  }
}

function is_gvar(id, c) {
  var match = DAst$ReactTemplate.get(c);
  if (match.tag === 1) {
    return Names$ReactTemplate.Id[/* equal */0](id, match[0]);
  } else {
    return /* false */0;
  }
}

function is_projection(nargs, param) {
  if (param) {
    if (!Flags$ReactTemplate.in_debugger[0] && !Flags$ReactTemplate.raw_print[0] && print_projections[0]) {
      try {
        var n = Recordops$ReactTemplate.find_projection_nparams(param[0]) + 1 | 0;
        if (n <= nargs) {
          return /* Some */[n];
        } else {
          return /* None */0;
        }
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* None */0;
        } else {
          throw exn;
        }
      }
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function is_hole(param) {
  switch (param.tag | 0) {
    case 12 : 
    case 14 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function is_needed_for_correct_partial_application(tail, imp) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], tail)) {
    return 1 - Impargs$ReactTemplate.maximal_insertion_of(imp);
  } else {
    return /* false */0;
  }
}

var Expl = Caml_exceptions.create("Constrextern-ReactTemplate.Expl");

function explicitize(inctx, impl, param, args) {
  var f = param[1];
  var impl$1 = Constrintern$ReactTemplate.parsing_explicit[0] ? /* [] */0 : impl;
  var n = Curry._1(Util$ReactTemplate.List[/* length */0], args);
  var exprec = function (q, param) {
    var args = param[0];
    var exit = 0;
    if (args) {
      var match = param[1];
      if (match) {
        var impl = match[1];
        var imp = match[0];
        var args$1 = args[1];
        var a = args[0];
        if (Impargs$ReactTemplate.is_status_implicit(imp)) {
          var tail = exprec(q + 1 | 0, /* tuple */[
                args$1,
                impl
              ]);
          var tag = a.tag | 0;
          var a$1 = tag === 250 ? a[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(a) : a
            );
          var visible = Flags$ReactTemplate.raw_print[0] || print_implicits[0] && print_implicits_explicit_args[0] || is_needed_for_correct_partial_application(tail, imp) || print_implicits_defensive[0] && (1 - Impargs$ReactTemplate.is_inferable_implicit(inctx, n, imp) || Flags$ReactTemplate.beautify[0]) && 1 - is_hole(a$1[/* v */0]);
          if (visible) {
            var tag$1 = a.tag | 0;
            var eta = /* ExplByName */Block.__(1, [Impargs$ReactTemplate.name_of_implicit(imp)]);
            return /* :: */[
                    /* tuple */[
                      tag$1 === 250 ? a[0] : (
                          tag$1 === 246 ? CamlinternalLazy.force_lazy_block(a) : a
                        ),
                      /* Some */[CAst$ReactTemplate.make(/* None */0, eta)]
                    ],
                    tail
                  ];
          } else {
            return tail;
          }
        } else {
          var tag$2 = a.tag | 0;
          return /* :: */[
                  /* tuple */[
                    tag$2 === 250 ? a[0] : (
                        tag$2 === 246 ? CamlinternalLazy.force_lazy_block(a) : a
                      ),
                    /* None */0
                  ],
                  exprec(q + 1 | 0, /* tuple */[
                        args$1,
                        impl
                      ])
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      var match$1 = param[1];
      if (match$1) {
        var imp$1 = match$1[0];
        if (Impargs$ReactTemplate.is_status_implicit(imp$1) && Impargs$ReactTemplate.maximal_insertion_of(imp$1)) {
          throw Expl;
        } else {
          return /* [] */0;
        }
      } else {
        exit = 1;
      }
    }
    if (exit === 1) {
      return Curry._2(Util$ReactTemplate.List[/* map */10], (function (a) {
                    var tag = a.tag | 0;
                    return /* tuple */[
                            tag === 250 ? a[0] : (
                                tag === 246 ? CamlinternalLazy.force_lazy_block(a) : a
                              ),
                            /* None */0
                          ];
                  }), args);
    }
    
  };
  var ip = is_projection(Curry._1(Util$ReactTemplate.List[/* length */0], args), param[0]);
  try {
    if (ip) {
      var i = ip[0];
      if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], impl$1) && Impargs$ReactTemplate.is_status_implicit(Curry._2(Util$ReactTemplate.List[/* nth */3], impl$1, i - 1 | 0))) {
        throw Expl;
      } else {
        var match = Curry._2(Util$ReactTemplate.List[/* chop */99], i, args);
        var match$1 = Curry._1(Util$ReactTemplate.List[/* is_empty */45], impl$1) ? /* tuple */[
            /* [] */0,
            /* [] */0
          ] : Curry._2(Util$ReactTemplate.List[/* chop */99], i, impl$1);
        var args1 = exprec(1, /* tuple */[
              match[0],
              match$1[0]
            ]);
        var args2 = exprec(i + 1 | 0, /* tuple */[
              match[1],
              match$1[1]
            ]);
        var ip$1 = /* Some */[Curry._1(Util$ReactTemplate.List[/* length */0], args1)];
        return /* CApp */Block.__(7, [
                  /* tuple */[
                    ip$1,
                    f
                  ],
                  Util$ReactTemplate.$at(args1, args2)
                ]);
      }
    } else {
      var args$1 = exprec(1, /* tuple */[
            args,
            impl$1
          ]);
      if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], args$1)) {
        return f[/* v */0];
      } else {
        return /* CApp */Block.__(7, [
                  /* tuple */[
                    /* None */0,
                    f
                  ],
                  args$1
                ]);
      }
    }
  }
  catch (exn){
    if (exn === Expl) {
      var match$2 = f[/* v */0];
      var match$3;
      if (match$2.tag) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "constrextern.ml",
                608,
                71
              ]
            ];
      } else {
        match$3 = /* tuple */[
          match$2[0],
          match$2[1]
        ];
      }
      var ip$2 = print_projections[0] ? ip : /* None */0;
      return /* CAppExpl */Block.__(6, [
                /* tuple */[
                  ip$2,
                  match$3[0],
                  match$3[1]
                ],
                Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                        var tag = prim.tag | 0;
                        if (tag === 250) {
                          return prim[0];
                        } else if (tag === 246) {
                          return CamlinternalLazy.force_lazy_block(prim);
                        } else {
                          return prim;
                        }
                      }), args)
              ]);
    } else {
      throw exn;
    }
  }
}

function is_start_implicit(param) {
  if (param) {
    var imp = param[0];
    if (Impargs$ReactTemplate.is_status_implicit(imp)) {
      return Impargs$ReactTemplate.maximal_insertion_of(imp);
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function fill_arg_scopes(args, subscopes, scopes) {
  if (args) {
    var args$1 = args[1];
    var a = args[0];
    if (subscopes) {
      return /* :: */[
              /* tuple */[
                a,
                /* tuple */[
                  subscopes[0],
                  scopes
                ]
              ],
              fill_arg_scopes(args$1, subscopes[1], scopes)
            ];
    } else {
      return /* :: */[
              /* tuple */[
                a,
                /* tuple */[
                  /* None */0,
                  scopes
                ]
              ],
              fill_arg_scopes(args$1, /* [] */0, scopes)
            ];
    }
  } else {
    return /* [] */0;
  }
}

function extern_args(extern, env, args) {
  var map = function (param) {
    var argscopes = param[1];
    var arg = param[0];
    return Block.__(246, [(function () {
                  return Curry._3(extern, argscopes, env, arg);
                })]);
  };
  return Curry._2(Util$ReactTemplate.List[/* map */10], map, args);
}

function match_coercion_app(c) {
  var match = DAst$ReactTemplate.get(c);
  if (match.tag === 4) {
    var match$1 = DAst$ReactTemplate.get(match[0]);
    if (match$1.tag) {
      return /* None */0;
    } else {
      return /* Some */[/* tuple */[
                c[/* loc */1],
                match$1[0],
                0,
                match[1]
              ]];
    }
  } else {
    return /* None */0;
  }
}

function remove_coercions(inctx, c) {
  var match = match_coercion_app(c);
  if (match) {
    if (Flags$ReactTemplate.raw_print[0] || print_coercions[0]) {
      return c;
    } else {
      var match$1 = match[0];
      var args = match$1[3];
      var pars = match$1[2];
      var nargs = Curry._1(Util$ReactTemplate.List[/* length */0], args);
      try {
        var match$2 = Classops$ReactTemplate.hide_coercion(match$1[1]);
        if (match$2) {
          var n = match$2[0];
          if ((n - pars | 0) < nargs && (inctx || ((n - pars | 0) + 1 | 0) < nargs)) {
            var l = Curry._2(Util$ReactTemplate.List[/* skipn */107], n - pars | 0, args);
            var match$3;
            if (l) {
              match$3 = /* tuple */[
                l[0],
                l[1]
              ];
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "constrextern.ml",
                      664,
                      54
                    ]
                  ];
            }
            var l$1 = match$3[1];
            var a$prime = remove_coercions(/* true */1, match$3[0]);
            if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l$1)) {
              return a$prime;
            } else {
              return DAst$ReactTemplate.make(match$1[0], /* GApp */Block.__(4, [
                            a$prime,
                            l$1
                          ]));
            }
          } else {
            return c;
          }
        } else {
          return c;
        }
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return c;
        } else {
          throw exn;
        }
      }
    }
  } else {
    return c;
  }
}

function flatten_application(_c) {
  while(true) {
    var c = _c;
    var a = DAst$ReactTemplate.get(c);
    if (a.tag === 4) {
      var match = DAst$ReactTemplate.get(a[0]);
      if (match.tag === 4) {
        var loc = c[/* loc */1];
        _c = DAst$ReactTemplate.make(loc, /* GApp */Block.__(4, [
                match[0],
                Util$ReactTemplate.$at(match[1], a[1])
              ]));
        continue ;
        
      } else {
        return c;
      }
    } else {
      return c;
    }
  };
}

function extern_possible_prim_token(scopes, r) {
  try {
    var match = Notation$ReactTemplate.uninterp_prim_token(r);
    var n = match[1];
    var match$1 = Notation$ReactTemplate.availability_of_prim_token(n, match[0], scopes);
    if (match$1) {
      return /* Some */[insert_delimiters(CAst$ReactTemplate.make(Glob_ops$ReactTemplate.loc_of_glob_constr(r), /* CPrim */Block.__(19, [n])), match$1[0])];
    } else {
      return /* None */0;
    }
  }
  catch (exn){
    if (exn === Notation_ops$ReactTemplate.No_match) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function extended_glob_local_binder_of_decl(_, param) {
  var match = param[2];
  var bk = param[1];
  var p = param[0];
  if (match) {
    var t = param[3];
    var x = match[0];
    var match$1 = DAst$ReactTemplate.get(t);
    var exit = 0;
    if (match$1.tag === 13) {
      if (typeof match$1[1] === "number") {
        if (match$1[2]) {
          exit = 1;
        } else {
          return /* GLocalDef */Block.__(1, [
                    p,
                    bk,
                    x,
                    /* None */0
                  ]);
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* GLocalDef */Block.__(1, [
                p,
                bk,
                x,
                /* Some */[t]
              ]);
    }
    
  } else {
    return /* GLocalAssum */Block.__(0, [
              p,
              bk,
              param[3]
            ]);
  }
}

function extended_glob_local_binder_of_decl$1(loc, u) {
  return DAst$ReactTemplate.make(loc, extended_glob_local_binder_of_decl(loc, u));
}

function extern_glob_sort(s) {
  if (typeof s === "number") {
    if (s !== 0) {
      return /* GSet */1;
    } else {
      return /* GProp */0;
    }
  } else if (Detyping$ReactTemplate.print_universes[0]) {
    return s;
  } else {
    return /* GType */[/* [] */0];
  }
}

function extern_universes(l) {
  if (l && Detyping$ReactTemplate.print_universes[0]) {
    return l;
  } else {
    return /* None */0;
  }
}

function extern(inctx, scopes, vars, r) {
  var r$prime = remove_coercions(inctx, r);
  try {
    if (Flags$ReactTemplate.raw_print[0] || print_no_symbol[0]) {
      throw Notation_ops$ReactTemplate.No_match;
    }
    var scopes$1 = scopes;
    var r$1 = r;
    var r$prime$1 = r$prime;
    var c = extern_possible_prim_token(scopes$1, r$1);
    var c$prime = r$1 === r$prime$1 ? /* None */0 : extern_possible_prim_token(scopes$1, r$prime$1);
    if (c) {
      var n = c[0];
      if (c$prime) {
        if (c$prime[0][/* v */0].tag === 20) {
          return n;
        } else if (c$prime) {
          return c$prime[0];
        } else {
          throw Notation_ops$ReactTemplate.No_match;
        }
      } else {
        return n;
      }
    } else if (c$prime) {
      return c$prime[0];
    } else {
      throw Notation_ops$ReactTemplate.No_match;
    }
  }
  catch (exn){
    if (exn === Notation_ops$ReactTemplate.No_match) {
      try {
        var r$prime$prime = flatten_application(r$prime);
        if (Flags$ReactTemplate.raw_print[0] || print_no_symbol[0]) {
          throw Notation_ops$ReactTemplate.No_match;
        }
        var allscopes = scopes;
        var vars$1 = vars;
        var t = r$prime$prime;
        var _param = Notation$ReactTemplate.uninterp_notations(r$prime$prime);
        while(true) {
          var param = _param;
          if (param) {
            var _rule = param[0];
            var n$1 = _rule[2];
            var keyrule = _rule[0];
            var scopes$2 = allscopes[1];
            var loc = Glob_ops$ReactTemplate.loc_of_glob_constr(t);
            try {
              if (is_inactive_rule(keyrule)) {
                throw Notation_ops$ReactTemplate.No_match;
              }
              var match = DAst$ReactTemplate.get(t);
              var match$1;
              var exit = 0;
              switch (match.tag | 0) {
                case 0 : 
                    if (n$1) {
                      if (n$1[0] !== 0) {
                        throw Notation_ops$ReactTemplate.No_match;
                      } else {
                        var eta = /* GApp */Block.__(4, [
                            t,
                            /* [] */0
                          ]);
                        match$1 = /* tuple */[
                          DAst$ReactTemplate.make(/* None */0, eta),
                          /* [] */0,
                          /* [] */0,
                          /* [] */0
                        ];
                      }
                    } else {
                      exit = 1;
                    }
                    break;
                case 4 : 
                    var args = match[1];
                    var f = match[0];
                    if (n$1) {
                      var n$2 = n$1[0];
                      if (Curry._1(Util$ReactTemplate.List[/* length */0], args) >= n$2) {
                        var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], n$2, args);
                        var match$3 = DAst$ReactTemplate.get(f);
                        var match$4;
                        if (match$3.tag) {
                          match$4 = /* tuple */[
                            /* [] */0,
                            /* [] */0
                          ];
                        } else {
                          var ref = match$3[0];
                          var subscopes;
                          try {
                            subscopes = Curry._2(Util$ReactTemplate.List[/* skipn */107], n$2, Notation$ReactTemplate.find_arguments_scope(ref));
                          }
                          catch (raw_exn){
                            var exn$1 = Js_exn.internalToOCamlException(raw_exn);
                            if (exn$1[0] === Caml_builtin_exceptions.failure) {
                              subscopes = /* [] */0;
                            } else {
                              throw exn$1;
                            }
                          }
                          var impls = Impargs$ReactTemplate.select_impargs_size(Curry._1(Util$ReactTemplate.List[/* length */0], args), Impargs$ReactTemplate.implicits_of_global(ref));
                          var impls$1;
                          try {
                            impls$1 = Curry._2(Util$ReactTemplate.List[/* skipn */107], n$2, impls);
                          }
                          catch (raw_exn$1){
                            var exn$2 = Js_exn.internalToOCamlException(raw_exn$1);
                            if (exn$2[0] === Caml_builtin_exceptions.failure) {
                              impls$1 = /* [] */0;
                            } else {
                              throw exn$2;
                            }
                          }
                          match$4 = /* tuple */[
                            subscopes,
                            impls$1
                          ];
                        }
                        var tmp;
                        if (n$2) {
                          var eta_001 = match$2[0];
                          var eta$1 = /* GApp */Block.__(4, [
                              f,
                              eta_001
                            ]);
                          tmp = DAst$ReactTemplate.make(/* None */0, eta$1);
                        } else {
                          tmp = f;
                        }
                        match$1 = /* tuple */[
                          tmp,
                          match$2[1],
                          match$4[0],
                          match$4[1]
                        ];
                      } else {
                        throw Notation_ops$ReactTemplate.No_match;
                      }
                    } else {
                      var match$5 = DAst$ReactTemplate.get(f);
                      if (match$5.tag) {
                        match$1 = /* tuple */[
                          t,
                          /* [] */0,
                          /* [] */0,
                          /* [] */0
                        ];
                      } else {
                        var ref$1 = match$5[0];
                        var subscopes$1 = Notation$ReactTemplate.find_arguments_scope(ref$1);
                        var impls$2 = Impargs$ReactTemplate.select_impargs_size(Curry._1(Util$ReactTemplate.List[/* length */0], args), Impargs$ReactTemplate.implicits_of_global(ref$1));
                        match$1 = /* tuple */[
                          f,
                          args,
                          subscopes$1,
                          impls$2
                        ];
                      }
                    }
                    break;
                default:
                  exit = 1;
              }
              if (exit === 1) {
                if (n$1) {
                  throw Notation_ops$ReactTemplate.No_match;
                } else {
                  match$1 = /* tuple */[
                    t,
                    /* [] */0,
                    /* [] */0,
                    /* [] */0
                  ];
                }
              }
              var args$1 = match$1[1];
              var match$6 = Notation_ops$ReactTemplate.match_notation_constr(Detyping$ReactTemplate.print_universes[0], match$1[0], _rule[1]);
              var terms = match$6[0];
              var e;
              if (keyrule.tag) {
                var l = Curry._2(Util$ReactTemplate.List[/* map */10], (function(scopes$2){
                    return function (param) {
                      var match = param[1];
                      return /* tuple */[
                              extern(/* true */1, /* tuple */[
                                    match[0],
                                    Util$ReactTemplate.$at(match[1], scopes$2)
                                  ], vars$1, param[0]),
                              /* None */0
                            ];
                    }
                    }(scopes$2)), terms);
                var a_000 = CAst$ReactTemplate.make(loc, /* Qualid */Block.__(0, [Nametab$ReactTemplate.shortest_qualid_of_syndef(vars$1, keyrule[0])]));
                var a = /* CRef */Block.__(0, [
                    a_000,
                    /* None */0
                  ]);
                e = CAst$ReactTemplate.make(loc, Curry._1(Util$ReactTemplate.List[/* is_empty */45], l) ? a : /* CApp */Block.__(7, [
                          /* tuple */[
                            /* None */0,
                            CAst$ReactTemplate.make(/* None */0, a)
                          ],
                          l
                        ]));
              } else {
                var ntn = keyrule[1];
                var match$7 = Notation$ReactTemplate.availability_of_notation(/* tuple */[
                      keyrule[0],
                      ntn
                    ], allscopes);
                if (match$7) {
                  var match$8 = match$7[0];
                  var scopes$prime = Option$ReactTemplate.List[/* cons */0](match$8[0], scopes$2);
                  var l$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function(scopes$prime){
                      return function (param) {
                        var match = param[1];
                        return extern(/* true */1, /* tuple */[
                                    match[0],
                                    Util$ReactTemplate.$at(match[1], scopes$prime)
                                  ], vars$1, param[0]);
                      }
                      }(scopes$prime)), terms);
                  var ll = Curry._2(Util$ReactTemplate.List[/* map */10], (function(scopes$prime){
                      return function (param) {
                        var match = param[1];
                        var partial_arg_000 = match[0];
                        var partial_arg_001 = Util$ReactTemplate.$at(match[1], scopes$prime);
                        var partial_arg = /* tuple */[
                          partial_arg_000,
                          partial_arg_001
                        ];
                        return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      return extern(/* true */1, partial_arg, vars$1, param);
                                    }), param[0]);
                      }
                      }(scopes$prime)), match$6[1]);
                  var bl = Curry._2(Util$ReactTemplate.List[/* map */10], (function(scopes$prime){
                      return function (param) {
                        var match = param[1];
                        var partial_arg_000 = match[0];
                        var partial_arg_001 = Util$ReactTemplate.$at(match[1], scopes$prime);
                        var partial_arg = /* tuple */[
                          partial_arg_000,
                          partial_arg_001
                        ];
                        return Constrexpr_ops$ReactTemplate.mkCPatOr(/* None */0, Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                          return extern_cases_pattern_in_scope(partial_arg, vars$1, param);
                                        }), param[0]));
                      }
                      }(scopes$prime)), match$6[2]);
                  var bll = Curry._2(Util$ReactTemplate.List[/* map */10], (function(scopes$prime){
                      return function (param) {
                        var match = param[1];
                        return Util$ReactTemplate.pi3(extern_local_binder(/* tuple */[
                                        match[0],
                                        Util$ReactTemplate.$at(match[1], scopes$prime)
                                      ], vars$1, param[0]));
                      }
                      }(scopes$prime)), match$6[3]);
                  e = insert_delimiters(make_notation(loc, ntn, /* tuple */[
                            l$1,
                            ll,
                            bl,
                            bll
                          ]), match$8[1]);
                } else {
                  throw Notation_ops$ReactTemplate.No_match;
                }
              }
              if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], args$1)) {
                return e;
              } else {
                var args$2 = fill_arg_scopes(args$1, match$1[2], scopes$2);
                var args$3 = extern_args((function (param, param$1, param$2) {
                        return extern(/* true */1, param, param$1, param$2);
                      }), vars$1, args$2);
                return CAst$ReactTemplate.make(loc, explicitize(/* false */0, match$1[3], /* tuple */[
                                /* None */0,
                                e
                              ], args$3));
              }
            }
            catch (exn$3){
              if (exn$3 === Notation_ops$ReactTemplate.No_match) {
                _param = param[1];
                continue ;
                
              } else {
                throw exn$3;
              }
            }
          } else {
            throw Notation_ops$ReactTemplate.No_match;
          }
        };
      }
      catch (exn$4){
        if (exn$4 === Notation_ops$ReactTemplate.No_match) {
          return lift((function (loc, param) {
                        switch (param.tag | 0) {
                          case 0 : 
                              var ref = param[0];
                              var impl = Impargs$ReactTemplate.select_stronger_impargs(Impargs$ReactTemplate.implicits_of_global(ref));
                              var f = extern_reference(/* None */0, vars, ref);
                              var us = extern_universes(param[1]);
                              if (!Constrintern$ReactTemplate.parsing_explicit[0] && is_start_implicit(impl)) {
                                return /* CAppExpl */Block.__(6, [
                                          /* tuple */[
                                            /* None */0,
                                            f,
                                            us
                                          ],
                                          /* [] */0
                                        ]);
                              } else {
                                return /* CRef */Block.__(0, [
                                          f,
                                          us
                                        ]);
                              }
                          case 1 : 
                              return /* CRef */Block.__(0, [
                                        CAst$ReactTemplate.make(loc, /* Ident */Block.__(1, [param[0]])),
                                        /* None */0
                                      ]);
                          case 2 : 
                              var l = param[1];
                              var exit = 0;
                              if (l) {
                                exit = 1;
                              } else if (print_meta_as_hole[0]) {
                                return /* CHole */Block.__(12, [
                                          /* None */0,
                                          /* IntroAnonymous */0,
                                          /* None */0
                                        ]);
                              } else {
                                exit = 1;
                              }
                              if (exit === 1) {
                                return /* CEvar */Block.__(14, [
                                          param[0],
                                          Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                  return Util$ReactTemplate.on_snd((function (param) {
                                                                return extern(/* false */0, scopes, vars, param);
                                                              }), param);
                                                }), l)
                                        ]);
                              }
                              break;
                          case 3 : 
                              if (print_meta_as_hole[0]) {
                                return /* CHole */Block.__(12, [
                                          /* None */0,
                                          /* IntroAnonymous */0,
                                          /* None */0
                                        ]);
                              } else {
                                var kind = param[0];
                                if (kind.tag) {
                                  return /* CPatVar */Block.__(13, [kind[0]]);
                                } else {
                                  return /* CEvar */Block.__(14, [
                                            kind[0],
                                            /* [] */0
                                          ]);
                                }
                              }
                              break;
                          case 4 : 
                              var args = param[1];
                              var f$1 = param[0];
                              var match = DAst$ReactTemplate.get(f$1);
                              if (match.tag) {
                                return explicitize(inctx, /* [] */0, /* tuple */[
                                            /* None */0,
                                            sub_extern(/* false */0, scopes)(vars, f$1)
                                          ], Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
                                                  return Block.__(246, [(function () {
                                                                return sub_extern(/* true */1, scopes)(vars, c);
                                                              })]);
                                                }), args));
                              } else {
                                var ref$1 = match[0];
                                var subscopes = Notation$ReactTemplate.find_arguments_scope(ref$1);
                                var args$1 = fill_arg_scopes(args, subscopes, scopes[1]);
                                try {
                                  if (Flags$ReactTemplate.raw_print[0]) {
                                    throw Pervasives.Exit;
                                  }
                                  var cstrsp;
                                  if (ref$1.tag === 3) {
                                    cstrsp = ref$1[0];
                                  } else {
                                    throw Caml_builtin_exceptions.not_found;
                                  }
                                  var struc = Recordops$ReactTemplate.lookup_structure(cstrsp[0]);
                                  if (!Curry._1(PrintingRecord[/* active */0], cstrsp[0])) {
                                    if (Curry._1(PrintingConstructor[/* active */0], cstrsp[0])) {
                                      throw Pervasives.Exit;
                                    } else if (!record_print[0]) {
                                      throw Pervasives.Exit;
                                    }
                                    
                                  }
                                  var projs = struc[/* s_PROJ */3];
                                  var locals = struc[/* s_PROJKIND */2];
                                  var cut = function (_args, _n) {
                                    while(true) {
                                      var n = _n;
                                      var args = _args;
                                      if (n) {
                                        if (args) {
                                          _n = n - 1 | 0;
                                          _args = args[1];
                                          continue ;
                                          
                                        } else {
                                          throw Notation_ops$ReactTemplate.No_match;
                                        }
                                      } else {
                                        return args;
                                      }
                                    };
                                  };
                                  var args$2 = cut(args$1, struc[/* s_EXPECTEDPARAM */1]);
                                  var ip = function (_projs, _locs, _args, _acc) {
                                    while(true) {
                                      var acc = _acc;
                                      var args = _args;
                                      var locs = _locs;
                                      var projs = _projs;
                                      if (projs) {
                                        var match = projs[0];
                                        if (match) {
                                          var q = projs[1];
                                          if (locs) {
                                            if (locs[0][1] !== 0) {
                                              if (args) {
                                                var match$1 = args[0];
                                                var head = extern(/* true */1, match$1[1], vars, match$1[0]);
                                                _acc = /* :: */[
                                                  /* tuple */[
                                                    extern_reference(loc, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* ConstRef */Block.__(1, [match[0]])),
                                                    head
                                                  ],
                                                  acc
                                                ];
                                                _args = args[1];
                                                _locs = locs[1];
                                                _projs = q;
                                                continue ;
                                                
                                              } else {
                                                throw Notation_ops$ReactTemplate.No_match;
                                              }
                                            } else {
                                              _locs = locs[1];
                                              _projs = q;
                                              continue ;
                                              
                                            }
                                          } else {
                                            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("projections corruption [Constrextern.extern]."));
                                          }
                                        } else {
                                          throw Notation_ops$ReactTemplate.No_match;
                                        }
                                      } else {
                                        return acc;
                                      }
                                    };
                                  };
                                  return /* CRecord */Block.__(8, [Curry._1(Util$ReactTemplate.List[/* rev */4], ip(projs, locals, args$2, /* [] */0))]);
                                }
                                catch (exn){
                                  var exit$1 = 0;
                                  if (exn === Caml_builtin_exceptions.not_found) {
                                    exit$1 = 1;
                                  } else if (exn === Notation_ops$ReactTemplate.No_match) {
                                    exit$1 = 1;
                                  } else if (exn === Pervasives.Exit) {
                                    exit$1 = 1;
                                  } else {
                                    throw exn;
                                  }
                                  if (exit$1 === 1) {
                                    var args$3 = extern_args((function (param, param$1, param$2) {
                                            return extern(/* true */1, param, param$1, param$2);
                                          }), vars, args$1);
                                    var inctx$1 = inctx;
                                    var impl$1 = Impargs$ReactTemplate.select_stronger_impargs(Impargs$ReactTemplate.implicits_of_global(ref$1));
                                    var param$1 = /* tuple */[
                                      /* Some */[ref$1],
                                      extern_reference(loc, vars, ref$1)
                                    ];
                                    var us$1 = extern_universes(match[1]);
                                    var args$4 = args$3;
                                    var f$2 = param$1[1];
                                    var cf = param$1[0];
                                    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], args$4)) {
                                      return /* CAppExpl */Block.__(6, [
                                                /* tuple */[
                                                  /* None */0,
                                                  f$2,
                                                  us$1
                                                ],
                                                /* [] */0
                                              ]);
                                    } else if (!Constrintern$ReactTemplate.parsing_explicit[0] && (Flags$ReactTemplate.raw_print[0] || print_implicits[0] && !print_implicits_explicit_args[0]) && Curry._2(Util$ReactTemplate.List[/* exists */21], Impargs$ReactTemplate.is_status_implicit, impl$1)) {
                                      var args$5 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                              var tag = prim.tag | 0;
                                              if (tag === 250) {
                                                return prim[0];
                                              } else if (tag === 246) {
                                                return CamlinternalLazy.force_lazy_block(prim);
                                              } else {
                                                return prim;
                                              }
                                            }), args$4);
                                      return /* CAppExpl */Block.__(6, [
                                                /* tuple */[
                                                  is_projection(Curry._1(Util$ReactTemplate.List[/* length */0], args$5), cf),
                                                  f$2,
                                                  us$1
                                                ],
                                                args$5
                                              ]);
                                    } else {
                                      var eta = /* CRef */Block.__(0, [
                                          f$2,
                                          us$1
                                        ]);
                                      return explicitize(inctx$1, impl$1, /* tuple */[
                                                  cf,
                                                  CAst$ReactTemplate.make(/* None */0, eta)
                                                ], args$4);
                                    }
                                  }
                                  
                                }
                              }
                              break;
                          case 5 : 
                              var na = param[0];
                              var t = extern_typ(scopes)(vars, param[2]);
                              var inctx$2 = inctx;
                              var scopes$3 = scopes;
                              var vars$2 = Termops$ReactTemplate.add_vname(vars, na);
                              var na$1 = na;
                              var bk = param[1];
                              var aty = t;
                              var c = param[3];
                              var match$1 = Util$ReactTemplate.set_temporary_memory(/* () */0);
                              var match$2 = DAst$ReactTemplate.get(c);
                              var exit$2 = 0;
                              if (na$1) {
                                if (match$2.tag === 8) {
                                  if (match$2[0] !== 2) {
                                    exit$2 = 1;
                                  } else if (match$2[1]) {
                                    exit$2 = 1;
                                  } else {
                                    var match$3 = match$2[2];
                                    if (match$3) {
                                      var match$4 = match$3[0];
                                      var match$5 = match$4[1];
                                      if (match$5[0]) {
                                        exit$2 = 1;
                                      } else if (match$5[1]) {
                                        exit$2 = 1;
                                      } else if (match$3[1]) {
                                        exit$2 = 1;
                                      } else {
                                        var eqns = match$2[3];
                                        if (eqns) {
                                          var id = na$1[0];
                                          if (is_gvar(id, match$4[0]) && Curry._1(Util$ReactTemplate.List[/* length */0], Curry._1(match$1[0], Detyping$ReactTemplate.factorize_eqns(eqns))) === 1) {
                                            var match$6 = Curry._1(match$1[1], /* () */0);
                                            if (match$6) {
                                              if (match$6[1]) {
                                                throw [
                                                      Caml_builtin_exceptions.assert_failure,
                                                      [
                                                        "constrextern.ml",
                                                        968,
                                                        12
                                                      ]
                                                    ];
                                              } else {
                                                var match$7 = match$6[0][/* v */0];
                                                var b = match$7[2];
                                                var disjpat = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                        if (param) {
                                                          if (param[1]) {
                                                            throw [
                                                                  Caml_builtin_exceptions.assert_failure,
                                                                  [
                                                                    "constrextern.ml",
                                                                    960,
                                                                    59
                                                                  ]
                                                                ];
                                                          } else {
                                                            return param[0];
                                                          }
                                                        } else {
                                                          throw [
                                                                Caml_builtin_exceptions.assert_failure,
                                                                [
                                                                  "constrextern.ml",
                                                                  960,
                                                                  59
                                                                ]
                                                              ];
                                                        }
                                                      }), match$7[1]);
                                                var disjpat$1 = Glob_ops$ReactTemplate.occur_glob_constr(id)(b) ? Curry._2(Util$ReactTemplate.List[/* map */10], Glob_ops$ReactTemplate.set_pat_alias(id), disjpat) : disjpat;
                                                var b$1 = sub_extern(inctx$2, scopes$3)(vars$2, b);
                                                var p = Constrexpr_ops$ReactTemplate.mkCPatOr(/* None */0, Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                            return extern_cases_pattern_in_scope(scopes$3, vars$2, param);
                                                          }), disjpat$1));
                                                var binder = /* CLocalPattern */Block.__(2, [CAst$ReactTemplate.make(c[/* loc */1], /* tuple */[
                                                          p,
                                                          /* None */0
                                                        ])]);
                                                var match$8 = b$1[/* v */0];
                                                if (match$8.tag === 4) {
                                                  return /* CLambdaN */Block.__(4, [
                                                            /* :: */[
                                                              binder,
                                                              match$8[0]
                                                            ],
                                                            match$8[1]
                                                          ]);
                                                } else {
                                                  return /* CLambdaN */Block.__(4, [
                                                            /* :: */[
                                                              binder,
                                                              /* [] */0
                                                            ],
                                                            b$1
                                                          ]);
                                                }
                                              }
                                            } else {
                                              throw [
                                                    Caml_builtin_exceptions.assert_failure,
                                                    [
                                                      "constrextern.ml",
                                                      968,
                                                      12
                                                    ]
                                                  ];
                                            }
                                          } else {
                                            exit$2 = 1;
                                          }
                                        } else {
                                          exit$2 = 1;
                                        }
                                      }
                                    } else {
                                      exit$2 = 1;
                                    }
                                  }
                                } else {
                                  exit$2 = 1;
                                }
                              } else {
                                exit$2 = 1;
                              }
                              if (exit$2 === 1) {
                                var c$1 = sub_extern(inctx$2, scopes$3)(vars$2, c);
                                var match$9 = c$1[/* v */0];
                                if (match$9.tag === 4) {
                                  var bl = match$9[0];
                                  var exit$3 = 0;
                                  if (bl) {
                                    var match$10 = bl[0];
                                    switch (match$10.tag | 0) {
                                      case 0 : 
                                          var match$11 = match$10[1];
                                          if (match$11.tag) {
                                            exit$3 = 2;
                                          } else {
                                            var ty = match$10[2];
                                            if (Constrexpr_ops$ReactTemplate.binding_kind_eq(bk, match$11[0]) && Constrexpr_ops$ReactTemplate.constr_expr_eq(aty, ty) && !occur_name(na$1, ty)) {
                                              return /* CLambdaN */Block.__(4, [
                                                        /* :: */[
                                                          /* CLocalAssum */Block.__(0, [
                                                              /* :: */[
                                                                CAst$ReactTemplate.make(/* None */0, na$1),
                                                                match$10[0]
                                                              ],
                                                              /* Default */Block.__(0, [bk]),
                                                              aty
                                                            ]),
                                                          bl[1]
                                                        ],
                                                        match$9[1]
                                                      ]);
                                            } else {
                                              exit$3 = 2;
                                            }
                                          }
                                          break;
                                      case 1 : 
                                      case 2 : 
                                          exit$3 = 2;
                                          break;
                                      
                                    }
                                  } else {
                                    exit$3 = 2;
                                  }
                                  if (exit$3 === 2) {
                                    return /* CLambdaN */Block.__(4, [
                                              /* :: */[
                                                /* CLocalAssum */Block.__(0, [
                                                    /* :: */[
                                                      CAst$ReactTemplate.make(/* None */0, na$1),
                                                      /* [] */0
                                                    ],
                                                    /* Default */Block.__(0, [bk]),
                                                    aty
                                                  ]),
                                                bl
                                              ],
                                              match$9[1]
                                            ]);
                                  }
                                  
                                } else {
                                  return /* CLambdaN */Block.__(4, [
                                            /* :: */[
                                              /* CLocalAssum */Block.__(0, [
                                                  /* :: */[
                                                    CAst$ReactTemplate.make(/* None */0, na$1),
                                                    /* [] */0
                                                  ],
                                                  /* Default */Block.__(0, [bk]),
                                                  aty
                                                ]),
                                              /* [] */0
                                            ],
                                            c$1
                                          ]);
                                }
                              }
                              case 6 : 
                              var na$2 = param[0];
                              var t$1 = extern_typ(scopes)(vars, param[2]);
                              var scopes$4 = scopes;
                              var vars$3 = Termops$ReactTemplate.add_vname(vars, na$2);
                              var na$3 = na$2;
                              var bk$1 = param[1];
                              var aty$1 = t$1;
                              var c$2 = param[3];
                              var match$12 = Util$ReactTemplate.set_temporary_memory(/* () */0);
                              var match$13 = DAst$ReactTemplate.get(c$2);
                              var exit$4 = 0;
                              if (na$3) {
                                if (match$13.tag === 8) {
                                  if (match$13[0] !== 2) {
                                    exit$4 = 1;
                                  } else if (match$13[1]) {
                                    exit$4 = 1;
                                  } else {
                                    var match$14 = match$13[2];
                                    if (match$14) {
                                      var match$15 = match$14[0];
                                      var match$16 = match$15[1];
                                      if (match$16[0]) {
                                        exit$4 = 1;
                                      } else if (match$16[1]) {
                                        exit$4 = 1;
                                      } else if (match$14[1]) {
                                        exit$4 = 1;
                                      } else {
                                        var eqns$1 = match$13[3];
                                        if (eqns$1) {
                                          var id$1 = na$3[0];
                                          if (is_gvar(id$1, match$15[0]) && Curry._1(Util$ReactTemplate.List[/* length */0], Curry._1(match$12[0], Detyping$ReactTemplate.factorize_eqns(eqns$1))) === 1) {
                                            var match$17 = Curry._1(match$12[1], /* () */0);
                                            if (match$17) {
                                              if (match$17[1]) {
                                                throw [
                                                      Caml_builtin_exceptions.assert_failure,
                                                      [
                                                        "constrextern.ml",
                                                        940,
                                                        12
                                                      ]
                                                    ];
                                              } else {
                                                var match$18 = match$17[0][/* v */0];
                                                var b$2 = match$18[2];
                                                var disjpat$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                        if (param) {
                                                          if (param[1]) {
                                                            throw [
                                                                  Caml_builtin_exceptions.assert_failure,
                                                                  [
                                                                    "constrextern.ml",
                                                                    932,
                                                                    59
                                                                  ]
                                                                ];
                                                          } else {
                                                            return param[0];
                                                          }
                                                        } else {
                                                          throw [
                                                                Caml_builtin_exceptions.assert_failure,
                                                                [
                                                                  "constrextern.ml",
                                                                  932,
                                                                  59
                                                                ]
                                                              ];
                                                        }
                                                      }), match$18[1]);
                                                var disjpat$3 = Glob_ops$ReactTemplate.occur_glob_constr(id$1)(b$2) ? Curry._2(Util$ReactTemplate.List[/* map */10], Glob_ops$ReactTemplate.set_pat_alias(id$1), disjpat$2) : disjpat$2;
                                                var b$3 = extern_typ(scopes$4)(vars$3, b$2);
                                                var p$1 = Constrexpr_ops$ReactTemplate.mkCPatOr(/* None */0, Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                            return extern_cases_pattern_in_scope(scopes$4, vars$3, param);
                                                          }), disjpat$3));
                                                var binder$1 = /* CLocalPattern */Block.__(2, [CAst$ReactTemplate.make(c$2[/* loc */1], /* tuple */[
                                                          p$1,
                                                          /* None */0
                                                        ])]);
                                                var match$19 = b$3[/* v */0];
                                                if (match$19.tag === 3) {
                                                  return /* CProdN */Block.__(3, [
                                                            /* :: */[
                                                              binder$1,
                                                              match$19[0]
                                                            ],
                                                            match$19[1]
                                                          ]);
                                                } else {
                                                  return /* CProdN */Block.__(3, [
                                                            /* :: */[
                                                              binder$1,
                                                              /* [] */0
                                                            ],
                                                            b$3
                                                          ]);
                                                }
                                              }
                                            } else {
                                              throw [
                                                    Caml_builtin_exceptions.assert_failure,
                                                    [
                                                      "constrextern.ml",
                                                      940,
                                                      12
                                                    ]
                                                  ];
                                            }
                                          } else {
                                            exit$4 = 1;
                                          }
                                        } else {
                                          exit$4 = 1;
                                        }
                                      }
                                    } else {
                                      exit$4 = 1;
                                    }
                                  }
                                } else {
                                  exit$4 = 1;
                                }
                              } else {
                                exit$4 = 1;
                              }
                              if (exit$4 === 1) {
                                var c$3 = extern_typ(scopes$4)(vars$3, c$2);
                                var match$20 = c$3[/* v */0];
                                var exit$5 = 0;
                                var exit$6 = 0;
                                if (na$3) {
                                  if (match$20.tag === 3) {
                                    var match$21 = match$20[0];
                                    if (match$21) {
                                      var match$22 = match$21[0];
                                      switch (match$22.tag | 0) {
                                        case 0 : 
                                            var match$23 = match$22[1];
                                            if (match$23.tag) {
                                              exit$6 = 3;
                                            } else {
                                              var ty$1 = match$22[2];
                                              if (Constrexpr_ops$ReactTemplate.binding_kind_eq(bk$1, match$23[0]) && Constrexpr_ops$ReactTemplate.constr_expr_eq(aty$1, ty$1) && !Constrexpr_ops$ReactTemplate.occur_var_constr_expr(na$3[0], ty$1)) {
                                                return /* CProdN */Block.__(3, [
                                                          /* :: */[
                                                            /* CLocalAssum */Block.__(0, [
                                                                /* :: */[
                                                                  CAst$ReactTemplate.make(/* None */0, na$3),
                                                                  match$22[0]
                                                                ],
                                                                /* Default */Block.__(0, [bk$1]),
                                                                aty$1
                                                              ]),
                                                            match$21[1]
                                                          ],
                                                          match$20[1]
                                                        ]);
                                              } else {
                                                exit$6 = 3;
                                              }
                                            }
                                            break;
                                        case 1 : 
                                        case 2 : 
                                            exit$6 = 3;
                                            break;
                                        
                                      }
                                    } else {
                                      exit$6 = 3;
                                    }
                                  } else {
                                    exit$5 = 2;
                                  }
                                } else {
                                  exit$6 = 3;
                                }
                                if (exit$6 === 3) {
                                  if (match$20.tag === 3) {
                                    return /* CProdN */Block.__(3, [
                                              /* :: */[
                                                /* CLocalAssum */Block.__(0, [
                                                    /* :: */[
                                                      CAst$ReactTemplate.make(/* None */0, na$3),
                                                      /* [] */0
                                                    ],
                                                    /* Default */Block.__(0, [bk$1]),
                                                    aty$1
                                                  ]),
                                                match$20[0]
                                              ],
                                              match$20[1]
                                            ]);
                                  } else {
                                    exit$5 = 2;
                                  }
                                }
                                if (exit$5 === 2) {
                                  return /* CProdN */Block.__(3, [
                                            /* :: */[
                                              /* CLocalAssum */Block.__(0, [
                                                  /* :: */[
                                                    CAst$ReactTemplate.make(/* None */0, na$3),
                                                    /* [] */0
                                                  ],
                                                  /* Default */Block.__(0, [bk$1]),
                                                  aty$1
                                                ]),
                                              /* [] */0
                                            ],
                                            c$3
                                          ]);
                                }
                                
                              }
                              case 7 : 
                              var na$4 = param[0];
                              var partial_arg = extern_typ(scopes);
                              return /* CLetIn */Block.__(5, [
                                        CAst$ReactTemplate.make(loc, na$4),
                                        sub_extern(/* false */0, scopes)(vars, param[1]),
                                        Option$ReactTemplate.map((function (param) {
                                                return partial_arg(vars, param);
                                              }), param[2]),
                                        extern(inctx, scopes, Termops$ReactTemplate.add_vname(vars, na$4), param[3])
                                      ]);
                          case 8 : 
                              var tml = param[2];
                              var rtntypopt = param[1];
                              var partial_arg$1 = Names$ReactTemplate.Id[/* Set */9][/* add */3];
                              var partial_arg$2 = Nameops$ReactTemplate.Name[/* fold_right */10];
                              var vars$prime = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                                      return partial_arg$2(partial_arg$1, param, param$1);
                                    }), Glob_ops$ReactTemplate.cases_predicate_names(tml), vars);
                              var partial_arg$3 = extern_typ(scopes);
                              var rtntypopt$prime = Option$ReactTemplate.map((function (param) {
                                      return partial_arg$3(vars$prime, param);
                                    }), rtntypopt);
                              var tml$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      var match = param[1];
                                      var na = match[0];
                                      var tm = param[0];
                                      var match$1 = DAst$ReactTemplate.get(tm);
                                      var na$prime = na ? (
                                          match$1.tag === 1 ? (
                                              Names$ReactTemplate.Id[/* equal */0](na[0], match$1[0]) ? /* None */0 : /* Some */[CAst$ReactTemplate.make(/* None */0, na)]
                                            ) : /* Some */[CAst$ReactTemplate.make(/* None */0, na)]
                                        ) : (
                                          match$1.tag === 1 && rtntypopt && Glob_ops$ReactTemplate.occur_glob_constr(match$1[0])(rtntypopt[0]) ? /* Some */[CAst$ReactTemplate.make(/* None */0, /* Anonymous */0)] : /* None */0
                                        );
                                      return /* tuple */[
                                              sub_extern(/* false */0, scopes)(vars, tm),
                                              na$prime,
                                              Option$ReactTemplate.map((function (param) {
                                                      var match = param[/* v */0];
                                                      var ind = match[0];
                                                      var args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                                                              var eta = /* PatVar */Block.__(0, [x]);
                                                              return DAst$ReactTemplate.make(/* None */0, eta);
                                                            }), match[1]);
                                                      var fullargs = add_cpatt_for_params(ind, args);
                                                      var scopes$5 = scopes;
                                                      var vars$4 = vars;
                                                      var ind$1 = ind;
                                                      var args$1 = fullargs;
                                                      if (Flags$ReactTemplate.in_debugger[0] || Inductiveops$ReactTemplate.inductive_has_local_defs(ind$1)) {
                                                        var c = extern_reference(/* None */0, vars$4, /* IndRef */Block.__(2, [ind$1]));
                                                        var args$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                                return extern_cases_pattern_in_scope(scopes$5, vars$4, param);
                                                              }), args$1);
                                                        var eta_001 = /* Some */[add_patt_for_params(ind$1, args$2)];
                                                        var eta = /* CPatCstr */Block.__(1, [
                                                            c,
                                                            eta_001,
                                                            /* [] */0
                                                          ]);
                                                        return CAst$ReactTemplate.make(/* None */0, eta);
                                                      } else {
                                                        try {
                                                          if (Flags$ReactTemplate.raw_print[0] || print_no_symbol[0]) {
                                                            throw Notation_ops$ReactTemplate.No_match;
                                                          }
                                                          var match$1 = Notation$ReactTemplate.uninterp_prim_token_ind_pattern(ind$1, args$1);
                                                          var p = match$1[1];
                                                          var match$2 = Notation$ReactTemplate.availability_of_prim_token(p, match$1[0], scopes$5);
                                                          if (match$2) {
                                                            var eta$1 = /* CPatPrim */Block.__(5, [p]);
                                                            return insert_pat_delimiters(/* None */0, CAst$ReactTemplate.make(/* None */0, eta$1), match$2[0]);
                                                          } else {
                                                            throw Notation_ops$ReactTemplate.No_match;
                                                          }
                                                        }
                                                        catch (exn){
                                                          if (exn === Notation_ops$ReactTemplate.No_match) {
                                                            try {
                                                              if (Flags$ReactTemplate.raw_print[0] || print_no_symbol[0]) {
                                                                throw Notation_ops$ReactTemplate.No_match;
                                                              }
                                                              var allscopes = scopes$5;
                                                              var vars$5 = vars$4;
                                                              var ind$2 = ind$1;
                                                              var args$3 = args$1;
                                                              var _param = Notation$ReactTemplate.uninterp_ind_pattern_notations(ind$1);
                                                              while(true) {
                                                                var param$1 = _param;
                                                                if (param$1) {
                                                                  var _rule = param$1[0];
                                                                  var keyrule = _rule[0];
                                                                  try {
                                                                    if (is_inactive_rule(keyrule)) {
                                                                      throw Notation_ops$ReactTemplate.No_match;
                                                                    }
                                                                    return apply_notation_to_pattern(/* None */0, /* IndRef */Block.__(2, [ind$2]), Notation_ops$ReactTemplate.match_notation_constr_ind_pattern(ind$2, args$3, _rule[1]), allscopes, vars$5, keyrule);
                                                                  }
                                                                  catch (exn$1){
                                                                    if (exn$1 === Notation_ops$ReactTemplate.No_match) {
                                                                      _param = param$1[1];
                                                                      continue ;
                                                                      
                                                                    } else {
                                                                      throw exn$1;
                                                                    }
                                                                  }
                                                                } else {
                                                                  throw Notation_ops$ReactTemplate.No_match;
                                                                }
                                                              };
                                                            }
                                                            catch (exn$2){
                                                              if (exn$2 === Notation_ops$ReactTemplate.No_match) {
                                                                var c$1 = extern_reference(/* None */0, vars$4, /* IndRef */Block.__(2, [ind$1]));
                                                                var args$4 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                                        return extern_cases_pattern_in_scope(scopes$5, vars$4, param);
                                                                      }), args$1);
                                                                var match$3 = drop_implicits_in_patt(/* IndRef */Block.__(2, [ind$1]), 0, args$4);
                                                                if (match$3) {
                                                                  var eta_002 = match$3[0];
                                                                  var eta$2 = /* CPatCstr */Block.__(1, [
                                                                      c$1,
                                                                      /* None */0,
                                                                      eta_002
                                                                    ]);
                                                                  return CAst$ReactTemplate.make(/* None */0, eta$2);
                                                                } else {
                                                                  var eta_001$1 = /* Some */[args$4];
                                                                  var eta$3 = /* CPatCstr */Block.__(1, [
                                                                      c$1,
                                                                      eta_001$1,
                                                                      /* [] */0
                                                                    ]);
                                                                  return CAst$ReactTemplate.make(/* None */0, eta$3);
                                                                }
                                                              } else {
                                                                throw exn$2;
                                                              }
                                                            }
                                                          } else {
                                                            throw exn;
                                                          }
                                                        }
                                                      }
                                                    }), match[1])
                                            ];
                                    }), tml);
                              var eqns$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      var inctx$3 = inctx;
                                      var scopes$5 = scopes;
                                      var vars$4 = vars;
                                      var param$1 = param;
                                      var match = param$1[/* v */0];
                                      var pll = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                  return extern_cases_pattern_in_scope(scopes$5, vars$4, param);
                                                })), match[1]);
                                      return CAst$ReactTemplate.make(param$1[/* loc */1], /* tuple */[
                                                  pll,
                                                  extern(inctx$3, scopes$5, vars$4, match[2])
                                                ]);
                                    }), Detyping$ReactTemplate.factorize_eqns(param[3]));
                              return /* CCases */Block.__(9, [
                                        param[0],
                                        rtntypopt$prime,
                                        tml$1,
                                        eqns$2
                                      ]);
                          case 9 : 
                              var match$24 = param[1];
                              var typopt = match$24[1];
                              var na$5 = match$24[0];
                              var nal = param[0];
                              var partial_arg$4 = Termops$ReactTemplate.add_vname(vars, na$5);
                              var partial_arg$5 = extern_typ(scopes);
                              return /* CLetTuple */Block.__(10, [
                                        Curry._2(Util$ReactTemplate.List[/* map */10], (function (eta) {
                                                return CAst$ReactTemplate.make(/* None */0, eta);
                                              }), nal),
                                        /* tuple */[
                                          Option$ReactTemplate.map((function () {
                                                  return CAst$ReactTemplate.make(/* None */0, na$5);
                                                }), typopt),
                                          Option$ReactTemplate.map((function (param) {
                                                  return partial_arg$5(partial_arg$4, param);
                                                }), typopt)
                                        ],
                                        sub_extern(/* false */0, scopes)(vars, param[2]),
                                        extern(inctx, scopes, Curry._3(Util$ReactTemplate.List[/* fold_left */13], Termops$ReactTemplate.add_vname, vars, nal), param[3])
                                      ]);
                          case 10 : 
                              var match$25 = param[1];
                              var typopt$1 = match$25[1];
                              var na$6 = match$25[0];
                              var partial_arg$6 = Termops$ReactTemplate.add_vname(vars, na$6);
                              var partial_arg$7 = extern_typ(scopes);
                              return /* CIf */Block.__(11, [
                                        sub_extern(/* false */0, scopes)(vars, param[0]),
                                        /* tuple */[
                                          Option$ReactTemplate.map((function () {
                                                  return CAst$ReactTemplate.make(/* None */0, na$6);
                                                }), typopt$1),
                                          Option$ReactTemplate.map((function (param) {
                                                  return partial_arg$7(partial_arg$6, param);
                                                }), typopt$1)
                                        ],
                                        sub_extern(inctx, scopes)(vars, param[2]),
                                        sub_extern(inctx, scopes)(vars, param[3])
                                      ]);
                          case 11 : 
                              var bv = param[4];
                              var tyv = param[3];
                              var blv = param[2];
                              var idv = param[1];
                              var fk = param[0];
                              var vars$prime$1 = Util$ReactTemplate.$$Array[/* fold_right */16](Names$ReactTemplate.Id[/* Set */9][/* add */3], idv, vars);
                              if (fk.tag) {
                                var listdecl = Util$ReactTemplate.$$Array[/* mapi */14]((function (i, fi) {
                                        var bl = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                return extended_glob_local_binder_of_decl$1(loc, param);
                                              }), Caml_array.caml_array_get(blv, i));
                                        var match = extern_local_binder(scopes, vars, bl);
                                        var ids = match[1];
                                        var partial_arg = Names$ReactTemplate.Id[/* Set */9][/* add */3];
                                        var partial_arg$1 = Nameops$ReactTemplate.Name[/* fold_right */10];
                                        var vars0 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                                                return partial_arg$1(partial_arg, param, param$1);
                                              }), ids, vars);
                                        var partial_arg$2 = Names$ReactTemplate.Id[/* Set */9][/* add */3];
                                        var partial_arg$3 = Nameops$ReactTemplate.Name[/* fold_right */10];
                                        var vars1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                                                return partial_arg$3(partial_arg$2, param, param$1);
                                              }), ids, vars$prime$1);
                                        return /* tuple */[
                                                CAst$ReactTemplate.make(/* None */0, fi),
                                                match[2],
                                                extern_typ(scopes)(vars0, Caml_array.caml_array_get(tyv, i)),
                                                sub_extern(/* false */0, scopes)(vars1, Caml_array.caml_array_get(bv, i))
                                              ];
                                      }), idv);
                                return /* CCoFix */Block.__(2, [
                                          CAst$ReactTemplate.make(loc, Caml_array.caml_array_get(idv, fk[0])),
                                          Util$ReactTemplate.$$Array[/* to_list */9](listdecl)
                                        ]);
                              } else {
                                var match$26 = fk[0];
                                var nv = match$26[0];
                                var listdecl$1 = Util$ReactTemplate.$$Array[/* mapi */14]((function (i, fi) {
                                        var bl = Caml_array.caml_array_get(blv, i);
                                        var ty = Caml_array.caml_array_get(tyv, i);
                                        var def = Caml_array.caml_array_get(bv, i);
                                        var bl$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                return extended_glob_local_binder_of_decl$1(loc, param);
                                              }), bl);
                                        var match = extern_local_binder(scopes, vars, bl$1);
                                        var ids = match[1];
                                        var partial_arg = Names$ReactTemplate.Id[/* Set */9][/* add */3];
                                        var partial_arg$1 = Nameops$ReactTemplate.Name[/* fold_right */10];
                                        var vars0 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                                                return partial_arg$1(partial_arg, param, param$1);
                                              }), ids, vars);
                                        var partial_arg$2 = Names$ReactTemplate.Id[/* Set */9][/* add */3];
                                        var partial_arg$3 = Nameops$ReactTemplate.Name[/* fold_right */10];
                                        var vars1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                                                return partial_arg$3(partial_arg$2, param, param$1);
                                              }), ids, vars$prime$1);
                                        var match$1 = Caml_array.caml_array_get(nv, i)[0];
                                        var n;
                                        if (match$1) {
                                          var eta = Nameops$ReactTemplate.Name[/* get_id */15](Curry._2(Util$ReactTemplate.List[/* nth */3], match[0], match$1[0]));
                                          n = /* Some */[CAst$ReactTemplate.make(/* None */0, eta)];
                                        } else {
                                          n = /* None */0;
                                        }
                                        var ro = extern_recursion_order(scopes, vars, Caml_array.caml_array_get(nv, i)[1]);
                                        return /* tuple */[
                                                CAst$ReactTemplate.make(/* None */0, fi),
                                                /* tuple */[
                                                  n,
                                                  ro
                                                ],
                                                match[2],
                                                extern_typ(scopes)(vars0, ty),
                                                extern(/* false */0, scopes, vars1, def)
                                              ];
                                      }), idv);
                                return /* CFix */Block.__(1, [
                                          CAst$ReactTemplate.make(loc, Caml_array.caml_array_get(idv, match$26[1])),
                                          Util$ReactTemplate.$$Array[/* to_list */9](listdecl$1)
                                        ]);
                              }
                              break;
                          case 12 : 
                              return /* CSort */Block.__(15, [extern_glob_sort(param[0])]);
                          case 13 : 
                              return /* CHole */Block.__(12, [
                                        /* Some */[param[0]],
                                        param[1],
                                        /* None */0
                                      ]);
                          case 14 : 
                              var partial_arg$8 = extern_typ(scopes);
                              return /* CCast */Block.__(16, [
                                        sub_extern(/* true */1, scopes)(vars, param[0]),
                                        Miscops$ReactTemplate.map_cast_type((function (param) {
                                                return partial_arg$8(vars, param);
                                              }), param[1])
                                      ]);
                          case 15 : 
                              var pr = extern_reference(loc, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](param[0])]));
                              return /* CProj */Block.__(21, [
                                        pr,
                                        sub_extern(inctx, scopes)(vars, param[1])
                                      ]);
                          
                        }
                      }), r$prime);
        } else {
          throw exn$4;
        }
      }
    } else {
      throw exn;
    }
  }
}

function extern_typ(param) {
  var partial_arg_000 = Notation$ReactTemplate.current_type_scope_name(/* () */0);
  var partial_arg_001 = param[1];
  var partial_arg = /* tuple */[
    partial_arg_000,
    partial_arg_001
  ];
  return (function (param, param$1) {
      return extern(/* true */1, partial_arg, param, param$1);
    });
}

function sub_extern(inctx, param) {
  var partial_arg_001 = param[1];
  var partial_arg = /* tuple */[
    /* None */0,
    partial_arg_001
  ];
  return (function (param, param$1) {
      return extern(inctx, partial_arg, param, param$1);
    });
}

function extern_local_binder(scopes, vars, param) {
  if (param) {
    var l = param[1];
    var match = DAst$ReactTemplate.get(param[0]);
    switch (match.tag | 0) {
      case 0 : 
          var na = match[0];
          var ty = extern_typ(scopes)(vars, match[2]);
          var match$1 = extern_local_binder(scopes, Nameops$ReactTemplate.Name[/* fold_right */10](Names$ReactTemplate.Id[/* Set */9][/* add */3], na, vars), l);
          var l$1 = match$1[2];
          var ids = match$1[1];
          var assums = match$1[0];
          var exit = 0;
          if (l$1) {
            var match$2 = l$1[0];
            switch (match$2.tag | 0) {
              case 0 : 
                  var ty$prime = match$2[2];
                  if (Constrexpr_ops$ReactTemplate.constr_expr_eq(ty, ty$prime) && (
                      na ? 1 - Constrexpr_ops$ReactTemplate.occur_var_constr_expr(na[0], ty$prime) : /* true */1
                    )) {
                    return /* tuple */[
                            /* :: */[
                              na,
                              assums
                            ],
                            /* :: */[
                              na,
                              ids
                            ],
                            /* :: */[
                              /* CLocalAssum */Block.__(0, [
                                  /* :: */[
                                    CAst$ReactTemplate.make(/* None */0, na),
                                    match$2[0]
                                  ],
                                  match$2[1],
                                  ty$prime
                                ]),
                              l$1[1]
                            ]
                          ];
                  } else {
                    exit = 1;
                  }
                  break;
              case 1 : 
              case 2 : 
                  exit = 1;
                  break;
              
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            return /* tuple */[
                    /* :: */[
                      na,
                      assums
                    ],
                    /* :: */[
                      na,
                      ids
                    ],
                    /* :: */[
                      /* CLocalAssum */Block.__(0, [
                          /* :: */[
                            CAst$ReactTemplate.make(/* None */0, na),
                            /* [] */0
                          ],
                          /* Default */Block.__(0, [match[1]]),
                          ty
                        ]),
                      l$1
                    ]
                  ];
          }
          break;
      case 1 : 
          var na$1 = match[0];
          var match$3 = extern_local_binder(scopes, Nameops$ReactTemplate.Name[/* fold_right */10](Names$ReactTemplate.Id[/* Set */9][/* add */3], na$1, vars), l);
          return /* tuple */[
                  match$3[0],
                  /* :: */[
                    na$1,
                    match$3[1]
                  ],
                  /* :: */[
                    /* CLocalDef */Block.__(1, [
                        CAst$ReactTemplate.make(/* None */0, na$1),
                        extern(/* false */0, scopes, vars, match[2]),
                        Option$ReactTemplate.map((function (param) {
                                return extern(/* false */0, scopes, vars, param);
                              }), match[3])
                      ]),
                    match$3[2]
                  ]
                ];
      case 2 : 
          var ty$1 = Flags$ReactTemplate.raw_print[0] ? /* Some */[extern_typ(scopes)(vars, match[3])] : /* None */0;
          var p = Constrexpr_ops$ReactTemplate.mkCPatOr(/* None */0, Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                      return extern_cases_pattern(vars, param);
                    }), match[0][0]));
          var match$4 = extern_local_binder(scopes, vars, l);
          var eta = /* tuple */[
            p,
            ty$1
          ];
          return /* tuple */[
                  match$4[0],
                  match$4[1],
                  /* :: */[
                    /* CLocalPattern */Block.__(2, [CAst$ReactTemplate.make(/* None */0, eta)]),
                    match$4[2]
                  ]
                ];
      
    }
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0,
            /* [] */0
          ];
  }
}

function extern_recursion_order(scopes, vars, param) {
  if (typeof param === "number") {
    return /* CStructRec */0;
  } else if (param.tag) {
    return /* CMeasureRec */Block.__(1, [
              extern(/* true */1, scopes, vars, param[0]),
              Option$ReactTemplate.map((function (param) {
                      return extern(/* true */1, scopes, vars, param);
                    }), param[1])
            ]);
  } else {
    return /* CWfRec */Block.__(0, [extern(/* true */1, scopes, vars, param[0])]);
  }
}

function extern_glob_constr(vars, c) {
  return extern(/* false */0, /* tuple */[
              /* None */0,
              /* [] */0
            ], vars, c);
}

function extern_glob_type(vars, c) {
  return extern_typ(/* tuple */[
                /* None */0,
                /* [] */0
              ])(vars, c);
}

function extern_constr_gen(lax, goal_concl_style, scopt, env, sigma, t) {
  var avoid = goal_concl_style ? Termops$ReactTemplate.vars_of_env(env) : Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var r = Detyping$ReactTemplate.detype(/* Later */1, /* Some */[lax], goal_concl_style, avoid, env, sigma, t);
  var vars = Termops$ReactTemplate.vars_of_env(env);
  return extern(/* false */0, /* tuple */[
              scopt,
              /* [] */0
            ], vars, r);
}

function extern_constr_in_scope(goal_concl_style, scope, env, sigma, t) {
  return extern_constr_gen(/* false */0, goal_concl_style, /* Some */[scope], env, sigma, t);
}

function extern_constr($staropt$star, goal_concl_style, env, sigma, t) {
  var lax = $staropt$star ? $staropt$star[0] : /* false */0;
  return extern_constr_gen(lax, goal_concl_style, /* None */0, env, sigma, t);
}

function extern_type(goal_concl_style, env, sigma, t) {
  var avoid = goal_concl_style ? Termops$ReactTemplate.vars_of_env(env) : Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var r = Detyping$ReactTemplate.detype(/* Later */1, /* None */0, goal_concl_style, avoid, env, sigma, t);
  return extern_glob_type(Termops$ReactTemplate.vars_of_env(env), r);
}

function extern_sort(sigma, s) {
  return extern_glob_sort(Detyping$ReactTemplate.detype_sort(sigma, s));
}

function extern_closed_glob(lax, goal_concl_style, env, sigma, t) {
  var avoid = goal_concl_style ? Termops$ReactTemplate.vars_of_env(env) : Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var r = Detyping$ReactTemplate.detype_closed_glob(lax, goal_concl_style, avoid, env, sigma, t);
  var vars = Termops$ReactTemplate.vars_of_env(env);
  return extern(/* false */0, /* tuple */[
              /* None */0,
              /* [] */0
            ], vars, r);
}

var any_any_branch = CAst$ReactTemplate.make(/* None */0, /* tuple */[
      /* [] */0,
      /* :: */[
        DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0])),
        /* [] */0
      ],
      DAst$ReactTemplate.make(/* None */0, /* GHole */Block.__(13, [
              /* InternalHole */0,
              /* IntroAnonymous */0,
              /* None */0
            ]))
    ]);

function compute_displayed_name_in_pattern(sigma, avoid, na, c) {
  return Namegen$ReactTemplate.compute_displayed_name_in_gen((function () {
                  return Patternops$ReactTemplate.noccurn_pattern;
                }), sigma)(avoid, na, c);
}

function glob_of_pat(avoid, env, sigma, pat) {
  var eta;
  switch (pat.tag | 0) {
    case 0 : 
        eta = /* GRef */Block.__(0, [
            pat[0],
            /* None */0
          ]);
        break;
    case 1 : 
        eta = /* GVar */Block.__(1, [pat[0]]);
        break;
    case 2 : 
        var evk = pat[0];
        var test = function (decl, param) {
          if (param.tag === 1) {
            return Names$ReactTemplate.Id[/* equal */0](Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), param[0]);
          } else {
            return /* false */0;
          }
        };
        var l = Evd$ReactTemplate.evar_instance_array(test, Evd$ReactTemplate.find(sigma, evk), pat[1]);
        var match = Evd$ReactTemplate.evar_ident(evk, sigma);
        var id = match ? match[0] : Names$ReactTemplate.Id[/* of_string */5]("__");
        eta = /* GEvar */Block.__(2, [
            id,
            Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return Util$ReactTemplate.on_snd((function (param) {
                                  return glob_of_pat(avoid, env, sigma, param);
                                }), param);
                  }), l)
          ]);
        break;
    case 3 : 
        var n = pat[0];
        var id$1;
        try {
          var match$1 = Termops$ReactTemplate.lookup_name_of_rel(n, env);
          id$1 = match$1 ? match$1[0] : CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["glob_constr_of_pattern"], Pp$ReactTemplate.str("index to an anonymous variable."));
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            id$1 = Names$ReactTemplate.Id[/* of_string */5]("_UNBOUND_REL_" + Pervasives.string_of_int(n));
          } else {
            throw exn;
          }
        }
        eta = /* GVar */Block.__(1, [id$1]);
        break;
    case 4 : 
        eta = /* GApp */Block.__(4, [
            glob_of_pat(avoid, env, sigma, pat[0]),
            Util$ReactTemplate.$$Array[/* map_to_list */44]((function (param) {
                    return glob_of_pat(avoid, env, sigma, param);
                  }), pat[1])
          ]);
        break;
    case 5 : 
        var eta$1 = /* GPatVar */Block.__(3, [/* SecondOrderPatVar */Block.__(1, [pat[0]])]);
        eta = /* GApp */Block.__(4, [
            DAst$ReactTemplate.make(/* None */0, eta$1),
            Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return glob_of_pat(avoid, env, sigma, param);
                  }), pat[1])
          ]);
        break;
    case 6 : 
        var eta_000 = /* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](pat[0])]);
        var eta$2 = /* GRef */Block.__(0, [
            eta_000,
            /* None */0
          ]);
        eta = /* GApp */Block.__(4, [
            DAst$ReactTemplate.make(/* None */0, eta$2),
            /* :: */[
              glob_of_pat(avoid, env, sigma, pat[1]),
              /* [] */0
            ]
          ]);
        break;
    case 7 : 
        var c = pat[2];
        var match$2 = compute_displayed_name_in_pattern(sigma, avoid, pat[0], c);
        var na$prime = match$2[0];
        var env$prime = Termops$ReactTemplate.add_name(na$prime, env);
        eta = /* GLambda */Block.__(5, [
            na$prime,
            /* Explicit */0,
            glob_of_pat(avoid, env, sigma, pat[1]),
            glob_of_pat(match$2[1], env$prime, sigma, c)
          ]);
        break;
    case 8 : 
        var c$1 = pat[2];
        var match$3 = compute_displayed_name_in_pattern(sigma, avoid, pat[0], c$1);
        var na$prime$1 = match$3[0];
        var env$prime$1 = Termops$ReactTemplate.add_name(na$prime$1, env);
        eta = /* GProd */Block.__(6, [
            na$prime$1,
            /* Explicit */0,
            glob_of_pat(avoid, env, sigma, pat[1]),
            glob_of_pat(match$3[1], env$prime$1, sigma, c$1)
          ]);
        break;
    case 9 : 
        var c$2 = pat[3];
        var match$4 = Namegen$ReactTemplate.compute_displayed_let_name_in(sigma, /* RenamingForGoal */0, avoid, pat[0], c$2);
        var na$prime$2 = match$4[0];
        var env$prime$2 = Termops$ReactTemplate.add_name(na$prime$2, env);
        eta = /* GLetIn */Block.__(7, [
            na$prime$2,
            glob_of_pat(avoid, env, sigma, pat[1]),
            Option$ReactTemplate.map((function (param) {
                    return glob_of_pat(avoid, env, sigma, param);
                  }), pat[2]),
            glob_of_pat(match$4[1], env$prime$2, sigma, c$2)
          ]);
        break;
    case 10 : 
        eta = /* GSort */Block.__(12, [pat[0]]);
        break;
    case 11 : 
        var match$5 = pat[0];
        eta = match$5 ? /* GPatVar */Block.__(3, [/* FirstOrderPatVar */Block.__(0, [match$5[0]])]) : /* GHole */Block.__(13, [
              /* InternalHole */0,
              /* IntroAnonymous */0,
              /* None */0
            ]);
        break;
    case 12 : 
        eta = /* GIf */Block.__(10, [
            glob_of_pat(avoid, env, sigma, pat[0]),
            /* tuple */[
              /* Anonymous */0,
              /* None */0
            ],
            glob_of_pat(avoid, env, sigma, pat[1]),
            glob_of_pat(avoid, env, sigma, pat[2])
          ]);
        break;
    case 13 : 
        var info = pat[0];
        var exit = 0;
        if (info[/* cip_style */0] !== 0) {
          exit = 1;
        } else if (info[/* cip_ind_tags */2]) {
          exit = 1;
        } else {
          var match$6 = pat[1];
          if (match$6.tag === 11) {
            if (match$6[0]) {
              exit = 1;
            } else {
              var match$7 = pat[3];
              if (match$7) {
                var match$8 = match$7[0];
                if (match$8[0] !== 0) {
                  exit = 1;
                } else if (match$7[1]) {
                  exit = 1;
                } else {
                  var match$9 = Detyping$ReactTemplate.it_destRLambda_or_LetIn_names(match$8[1], glob_of_pat(avoid, env, sigma, match$8[2]));
                  eta = /* GLetTuple */Block.__(9, [
                      match$9[0],
                      /* tuple */[
                        /* Anonymous */0,
                        /* None */0
                      ],
                      glob_of_pat(avoid, env, sigma, pat[2]),
                      match$9[1]
                    ]);
                }
              } else {
                exit = 1;
              }
            }
          } else {
            exit = 1;
          }
        }
        if (exit === 1) {
          var bl = pat[3];
          var p = pat[1];
          var match$10 = info[/* cip_ind */1];
          var mat;
          if (bl) {
            if (match$10) {
              var bl$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                      return /* tuple */[
                              param[0],
                              param[1],
                              glob_of_pat(avoid, env, sigma, param[2])
                            ];
                    }), bl);
              mat = Detyping$ReactTemplate.simple_cases_matrix_of_branches(match$10[0], bl$prime);
            } else {
              mat = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("PCase with some branches but unknown inductive."));
            }
          } else {
            mat = /* [] */0;
          }
          var mat$1 = info[/* cip_extensible */3] ? Util$ReactTemplate.$at(mat, /* :: */[
                  any_any_branch,
                  /* [] */0
                ]) : mat;
          var match$11 = info[/* cip_ind */1];
          var match$12 = info[/* cip_ind_tags */2];
          var match$13;
          var exit$1 = 0;
          if (p.tag === 11 && !p[0]) {
            match$13 = /* tuple */[
              /* tuple */[
                /* Anonymous */0,
                /* None */0
              ],
              /* None */0
            ];
          } else {
            exit$1 = 2;
          }
          if (exit$1 === 2) {
            match$13 = match$11 && match$12 ? Detyping$ReactTemplate.return_type_of_predicate(match$11[0], match$12[0], glob_of_pat(avoid, env, sigma, p)) : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("PCase with non-trivial predicate but unknown inductive."));
          }
          eta = /* GCases */Block.__(8, [
              /* RegularStyle */4,
              match$13[1],
              /* :: */[
                /* tuple */[
                  glob_of_pat(avoid, env, sigma, pat[2]),
                  match$13[0]
                ],
                /* [] */0
              ],
              mat$1
            ]);
        }
        break;
    case 14 : 
        eta = DAst$ReactTemplate.get(Detyping$ReactTemplate.detype_names(/* false */0, avoid, env, Global$ReactTemplate.env(/* () */0), sigma, EConstr$ReactTemplate.of_constr(Constr$ReactTemplate.mkFix(pat[0]))));
        break;
    case 15 : 
        eta = DAst$ReactTemplate.get(Detyping$ReactTemplate.detype_names(/* false */0, avoid, env, Global$ReactTemplate.env(/* () */0), sigma, EConstr$ReactTemplate.of_constr(Constr$ReactTemplate.mkCoFix(pat[0]))));
        break;
    
  }
  return DAst$ReactTemplate.make(/* None */0, eta);
}

function extern_constr_pattern(env, sigma, pat) {
  return extern(/* true */1, /* tuple */[
              /* None */0,
              /* [] */0
            ], Names$ReactTemplate.Id[/* Set */9][/* empty */0], glob_of_pat(Names$ReactTemplate.Id[/* Set */9][/* empty */0], env, sigma, pat));
}

function extern_rel_context(where, env, sigma, sign) {
  var a = Detyping$ReactTemplate.detype_rel_context(/* Later */1, /* None */0, where, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* tuple */[
        Termops$ReactTemplate.names_of_rel_context(env),
        env
      ], sigma, sign);
  var vars = Termops$ReactTemplate.vars_of_env(env);
  var a$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (eta) {
          return extended_glob_local_binder_of_decl$1(/* None */0, eta);
        }), a);
  return Util$ReactTemplate.pi3(extern_local_binder(/* tuple */[
                  /* None */0,
                  /* [] */0
                ], vars, a$1));
}

var print_evar_arguments = Detyping$ReactTemplate.print_evar_arguments;

var print_universes = Detyping$ReactTemplate.print_universes;

exports.extern_cases_pattern = extern_cases_pattern;
exports.extern_glob_constr = extern_glob_constr;
exports.extern_glob_type = extern_glob_type;
exports.extern_constr_pattern = extern_constr_pattern;
exports.extern_closed_glob = extern_closed_glob;
exports.extern_constr = extern_constr;
exports.extern_constr_in_scope = extern_constr_in_scope;
exports.extern_reference = extern_reference;
exports.extern_type = extern_type;
exports.extern_sort = extern_sort;
exports.extern_rel_context = extern_rel_context;
exports.print_implicits = print_implicits;
exports.print_implicits_defensive = print_implicits_defensive;
exports.print_arguments = print_arguments;
exports.print_evar_arguments = print_evar_arguments;
exports.print_coercions = print_coercions;
exports.print_universes = print_universes;
exports.print_no_symbol = print_no_symbol;
exports.print_projections = print_projections;
exports.set_extern_reference = set_extern_reference;
exports.get_extern_reference = get_extern_reference;
exports.with_universes = with_universes;
exports.without_symbols = without_symbols;
exports.without_specific_symbols = without_specific_symbols;
exports.with_meta_as_hole = with_meta_as_hole;
exports.toggle_scope_printing = toggle_scope_printing;
exports.toggle_notation_printing = toggle_notation_printing;
/* IRuleSet Not a pure module */
