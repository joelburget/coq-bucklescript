// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Store$ReactTemplate = require("./store.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Logic_monad$ReactTemplate = require("./logic_monad.bs.js");

function opn(a, param) {
  return /* record */[
          /* head */param[/* head */0],
          /* opened : :: */[
            /* Seq */[
              a,
              /* [] */0
            ],
            param[/* opened */1]
          ]
        ];
}

function close(param) {
  var opened = param[/* opened */1];
  if (opened) {
    var match = opened[1];
    var a = opened[0];
    var head = param[/* head */0];
    if (match) {
      var match$1 = match[0];
      return /* record */[
              /* head */head,
              /* opened : :: */[
                /* Seq */[
                  match$1[0],
                  /* :: */[
                    a,
                    match$1[1]
                  ]
                ],
                match[1]
              ]
            ];
    } else {
      return /* record */[
              /* head : :: */[
                a,
                head
              ],
              /* opened : [] */0
            ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "proofview_monad.ml",
            45,
            12
          ]
        ];
  }
}

function leaf(a, s) {
  return close(opn(a, s));
}

function mirror_tree(param) {
  return /* Seq */[
          param[0],
          List.rev_map(mirror_tree, param[1])
        ];
}

function to_tree(param) {
  if (param[/* opened */1]) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "proofview_monad.ml",
            57,
            31
          ]
        ];
  } else {
    return List.rev_map(mirror_tree, param[/* head */0]);
  }
}

function unbranch(param) {
  var match = param[0];
  if (typeof match === "number") {
    if (match !== 0) {
      return param[1];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "proofview_monad.ml",
              89,
              11
            ]
          ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "proofview_monad.ml",
            89,
            11
          ]
        ];
  }
}

function is_empty_branch(param) {
  var match = param[0];
  if (typeof match === "number" && match !== 0 && !param[1]) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function dispatch(brs) {
  if (CList$ReactTemplate.for_all(is_empty_branch, brs)) {
    return /* None */0;
  } else {
    return /* Some */[/* Seq */[
              /* Dispatch */0,
              brs
            ]];
  }
}

function constr(t) {
  var exit = 0;
  if (typeof t === "number") {
    if (t !== 0) {
      exit = 1;
    } else {
      return dispatch;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return (function (br) {
        return /* Some */[/* Seq */[
                  t,
                  br
                ]];
      });
  }
  
}

function compress_tree(param) {
  return constr(param[0])(CList$ReactTemplate.map_filter(compress_tree, param[1]));
}

function pr_tree(with_sep, param) {
  var match = param[0];
  if (typeof match === "number") {
    if (match) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "proofview_monad.ml",
              123,
              44
            ]
          ];
    } else {
      var tail = with_sep ? Pp$ReactTemplate.str(";") : Pp$ReactTemplate.mt(/* () */0);
      return Pp$ReactTemplate.$plus$plus(pr_dispatch(param[1]), tail);
    }
  } else if (match.tag) {
    var tail$1 = with_sep ? Pp$ReactTemplate.str(";") : Pp$ReactTemplate.mt(/* () */0);
    return Pp$ReactTemplate.$plus$plus(Curry._1(match[0], /* () */0), tail$1);
  } else if (param[1]) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "proofview_monad.ml",
            123,
            44
          ]
        ];
  } else {
    var m = match[0];
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(* "), Curry._1(m, /* () */0)), Pp$ReactTemplate.str(" *)"));
  }
}

function pr_dispatch(brs) {
  var brs$1 = List.map(unbranch, brs);
  var exit = 0;
  if (brs$1) {
    if (brs$1[1]) {
      exit = 1;
    } else {
      return pr_forest(brs$1[0]);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var sep = function () {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("|")), Pp$ReactTemplate.spc(/* () */0));
    };
    var branches = Pp$ReactTemplate.prlist_with_sep(sep, pr_forest, brs$1);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("[>"), Pp$ReactTemplate.spc(/* () */0)), branches), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("]"));
  }
  
}

function pr_forest(param) {
  if (param) {
    var l = param[1];
    var tr = param[0];
    if (l) {
      return Pp$ReactTemplate.$plus$plus(pr_tree(/* true */1, tr), pr_forest(l));
    } else {
      return pr_tree(/* false */0, tr);
    }
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function print(f) {
  return pr_forest(CList$ReactTemplate.map_filter(compress_tree, f));
}

function collapse_tree(n, t) {
  if (n !== 0) {
    var tmp = t[0];
    if (typeof tmp === "number") {
      if (tmp) {
        return /* :: */[
                /* Seq */[
                  /* DBranch */1,
                  CList$ReactTemplate.map_append((function (param) {
                          return collapse_tree(n, param);
                        }), t[1])
                ],
                /* [] */0
              ];
      } else {
        return /* :: */[
                /* Seq */[
                  /* Dispatch */0,
                  CList$ReactTemplate.map_append((function (param) {
                          return collapse_tree(n, param);
                        }), t[1])
                ],
                /* [] */0
              ];
      }
    } else if (tmp.tag) {
      var f = t[1];
      if (f) {
        var partial_arg = n - 1 | 0;
        return CList$ReactTemplate.map_append((function (param) {
                      return collapse_tree(partial_arg, param);
                    }), f);
      } else {
        return /* :: */[
                t,
                /* [] */0
              ];
      }
    } else {
      return /* :: */[
              t,
              /* [] */0
            ];
    }
  } else {
    return /* :: */[
            t,
            /* [] */0
          ];
  }
}

function collapse(n, f) {
  return CList$ReactTemplate.map_append((function (param) {
                return collapse_tree(n, param);
              }), f);
}

var StateStore = Store$ReactTemplate.Make(/* module */[]);

function drop_state(prim) {
  return prim[0];
}

function get_state(prim) {
  return prim[1];
}

function goal_with_state(g, s) {
  return /* tuple */[
          g,
          s
        ];
}

function with_empty_state(g) {
  return /* tuple */[
          g,
          StateStore[/* empty */0]
        ];
}

function map_goal_with_state(f, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          param[1]
        ];
}

function wprod(param, param$1) {
  return /* tuple */[
          param[0] && param$1[0],
          Pervasives.$at(param[1], param$1[1])
        ];
}

var P_000 = /* wunit : tuple */[
  /* true */1,
  /* [] */0
];

var P_002 = /* uunit : record */[
  /* head : [] */0,
  /* opened : [] */0
];

var P = /* module */[
  P_000,
  /* wprod */wprod,
  P_002
];

var Logical = Logic_monad$ReactTemplate.Logical(P);

var get = Curry._2(Logical[/* map */3], (function (prim) {
        return prim[0];
      }), Logical[/* get */7]);

function set(p) {
  return Curry._1(Logical[/* modify */8], (function (param) {
                return /* tuple */[
                        p,
                        param[1]
                      ];
              }));
}

function modify(f) {
  return Curry._1(Logical[/* modify */8], (function (param) {
                return /* tuple */[
                        Curry._1(f, param[0]),
                        param[1]
                      ];
              }));
}

var Pv = /* module */[
  /* get */get,
  /* set */set,
  /* modify */modify
];

var get$1 = Curry._2(Logical[/* map */3], (function (param) {
        return param[/* solution */0];
      }), get);

function set$1(s) {
  return modify((function (pv) {
                return /* record */[
                        /* solution */s,
                        /* comb */pv[/* comb */1],
                        /* shelf */pv[/* shelf */2]
                      ];
              }));
}

function modify$1(f) {
  return modify((function (pv) {
                return /* record */[
                        /* solution */Curry._1(f, pv[/* solution */0]),
                        /* comb */pv[/* comb */1],
                        /* shelf */pv[/* shelf */2]
                      ];
              }));
}

var Solution = /* module */[
  /* get */get$1,
  /* set */set$1,
  /* modify */modify$1
];

var get$2 = Curry._2(Logical[/* map */3], (function (param) {
        return param[/* comb */1];
      }), get);

function set$2(c) {
  return modify((function (pv) {
                return /* record */[
                        /* solution */pv[/* solution */0],
                        /* comb */c,
                        /* shelf */pv[/* shelf */2]
                      ];
              }));
}

function modify$2(f) {
  return modify((function (pv) {
                return /* record */[
                        /* solution */pv[/* solution */0],
                        /* comb */Curry._1(f, pv[/* comb */1]),
                        /* shelf */pv[/* shelf */2]
                      ];
              }));
}

var Comb = /* module */[
  /* get */get$2,
  /* set */set$2,
  /* modify */modify$2
];

var get$3 = Curry._2(Logical[/* map */3], (function (prim) {
        return prim[1];
      }), Logical[/* get */7]);

function set$3(e) {
  return Curry._1(Logical[/* modify */8], (function (param) {
                return /* tuple */[
                        param[0],
                        e
                      ];
              }));
}

function modify$3(f) {
  return Curry._1(Logical[/* modify */8], (function (param) {
                return /* tuple */[
                        param[0],
                        Curry._1(f, param[1])
                      ];
              }));
}

var Env = /* module */[
  /* get */get$3,
  /* set */set$3,
  /* modify */modify$3
];

function put(s) {
  return Curry._1(Logical[/* put */9], /* tuple */[
              s,
              /* [] */0
            ]);
}

var Status = /* module */[/* put */put];

var get$4 = Curry._2(Logical[/* map */3], (function (param) {
        return param[/* shelf */2];
      }), get);

function set$4(c) {
  return modify((function (pv) {
                return /* record */[
                        /* solution */pv[/* solution */0],
                        /* comb */pv[/* comb */1],
                        /* shelf */c
                      ];
              }));
}

function modify$4(f) {
  return modify((function (pv) {
                return /* record */[
                        /* solution */pv[/* solution */0],
                        /* comb */pv[/* comb */1],
                        /* shelf */Curry._1(f, pv[/* shelf */2])
                      ];
              }));
}

var Shelf = /* module */[
  /* get */get$4,
  /* set */set$4,
  /* modify */modify$4
];

function put$1(gs) {
  return Curry._1(Logical[/* put */9], /* tuple */[
              /* true */1,
              gs
            ]);
}

var Giveup = /* module */[/* put */put$1];

var recording = Logical[/* current */10];

function if_recording(t) {
  return Curry._2(Logical[/* >>= */1], recording, (function (r) {
                if (r) {
                  return t;
                } else {
                  return Curry._1(Logical[/* return */0], /* () */0);
                }
              }));
}

function record_trace(t) {
  return Curry._2(Logical[/* local */11], /* true */1, t);
}

var raw_update = Logical[/* update */12];

function update(f) {
  return if_recording(Curry._1(raw_update, f));
}

function opn$1(a) {
  var f = function (param) {
    return opn(a, param);
  };
  return if_recording(Curry._1(raw_update, f));
}

var close$1 = if_recording(Curry._1(raw_update, close));

function leaf$1(a) {
  var f = function (param) {
    return close(opn(a, param));
  };
  return if_recording(Curry._1(raw_update, f));
}

function tag(a, t) {
  return Curry._2(Logical[/* >>= */1], recording, (function (r) {
                if (r) {
                  return Curry._2(Logical[/* >>= */1], Curry._2(Logical[/* >> */2], Curry._1(raw_update, (function (param) {
                                        return opn(a, param);
                                      })), t), (function (a) {
                                return Curry._2(Logical[/* >> */2], Curry._1(raw_update, close), Curry._1(Logical[/* return */0], a));
                              }));
                } else {
                  return t;
                }
              }));
}

var Trace = [
  to_tree,
  opn,
  close,
  leaf
];

var Info = [
  print,
  collapse
];

var InfoL = [
  record_trace,
  update,
  opn$1,
  close$1,
  leaf$1,
  tag
];

exports.Trace = Trace;
exports.Info = Info;
exports.StateStore = StateStore;
exports.drop_state = drop_state;
exports.get_state = get_state;
exports.goal_with_state = goal_with_state;
exports.with_empty_state = with_empty_state;
exports.map_goal_with_state = map_goal_with_state;
exports.P = P;
exports.Logical = Logical;
exports.Pv = Pv;
exports.Solution = Solution;
exports.Comb = Comb;
exports.Env = Env;
exports.Status = Status;
exports.Shelf = Shelf;
exports.Giveup = Giveup;
exports.InfoL = InfoL;
/* StateStore Not a pure module */
