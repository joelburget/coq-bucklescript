// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Trie$ReactTemplate = require("../clib/trie.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function Make(funarg) {
  var $$let = function (Z) {
    var compare = function (x, y) {
      if (x) {
        var match = x[0];
        if (y) {
          var match$1 = y[0];
          var m = Curry._2(funarg[/* compare */0], match[0], match$1[0]);
          if (m) {
            return m;
          } else {
            return match[1] - match$1[1] | 0;
          }
        } else {
          return 1;
        }
      } else if (y) {
        return -1;
      } else {
        return 0;
      }
    };
    var Y_tries = /* module */[/* compare */compare];
    var ZSet = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], Z);
    var nil = ZSet[/* empty */0];
    var is_nil = ZSet[/* is_empty */1];
    var add = ZSet[/* union */6];
    var sub = ZSet[/* diff */8];
    var X_tries = /* module */[
      /* nil */nil,
      /* is_nil */is_nil,
      /* add */add,
      /* sub */sub
    ];
    var Trie = Trie$ReactTemplate.Make(Y_tries)(X_tries);
    var empty = Trie[/* empty */0];
    var path_of = function (dna) {
      var path_of_deferred = function (param) {
        if (param) {
          return pathrec(param[1], param[0]);
        } else {
          return /* [] */0;
        }
      };
      var pathrec = function (deferred, t) {
        var match = Curry._1(dna, t);
        if (match) {
          var match$1 = match[0];
          var v = match$1[1];
          var lbl = match$1[0];
          if (v) {
            return /* :: */[
                    /* Some */[/* tuple */[
                        lbl,
                        Curry._1(Util$ReactTemplate.List[/* length */0], v)
                      ]],
                    pathrec(Util$ReactTemplate.$at(v[1], deferred), v[0])
                  ];
          } else {
            return /* :: */[
                    /* Some */[/* tuple */[
                        lbl,
                        0
                      ]],
                    path_of_deferred(deferred)
                  ];
          }
        } else {
          return /* :: */[
                  /* None */0,
                  path_of_deferred(deferred)
                ];
        }
      };
      return (function (param) {
          return pathrec(/* [] */0, param);
        });
    };
    var tm_of = function (tm, lbl) {
      try {
        return /* :: */[
                /* tuple */[
                  Curry._2(Trie[/* next */2], tm, lbl),
                  /* true */1
                ],
                /* [] */0
              ];
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* [] */0;
        } else {
          throw exn;
        }
      }
    };
    var skip_arg = function (n, tm) {
      if (n) {
        var labels = Curry._1(Trie[/* labels */3], tm);
        var map = function (lbl) {
          if (lbl) {
            return skip_arg((n - 1 | 0) + lbl[0][1] | 0, Curry._2(Trie[/* next */2], tm, lbl));
          } else {
            return skip_arg(n - 1 | 0, Curry._2(Trie[/* next */2], tm, lbl));
          }
        };
        return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], map, labels));
      } else {
        return /* :: */[
                /* tuple */[
                  tm,
                  /* true */1
                ],
                /* [] */0
              ];
      }
    };
    var lookup = function (tm, dna, t) {
      var lookrec = function (t, tm) {
        var match = Curry._1(dna, t);
        if (typeof match === "number") {
          if (match !== 0) {
            return skip_arg(1, tm);
          } else {
            return tm_of(tm, /* None */0);
          }
        } else {
          var match$1 = match[0];
          var v = match$1[1];
          return Util$ReactTemplate.$at(tm_of(tm, /* None */0), Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (l, c) {
                            return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                              var b = param[1];
                                              var tm = param[0];
                                              if (b) {
                                                return lookrec(c, tm);
                                              } else {
                                                return /* :: */[
                                                        /* tuple */[
                                                          tm,
                                                          b
                                                        ],
                                                        /* [] */0
                                                      ];
                                              }
                                            }), l));
                          }), tm_of(tm, /* Some */[/* tuple */[
                                match$1[0],
                                Curry._1(Util$ReactTemplate.List[/* length */0], v)
                              ]]), v));
        }
      };
      return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                        return Curry._1(ZSet[/* elements */19], Curry._1(Trie[/* get */1], param[0]));
                      }), lookrec(t, tm)));
    };
    var add$1 = function (tm, dna, param) {
      var p = path_of(dna)(param[0]);
      return Curry._3(Trie[/* add */4], p, Curry._1(ZSet[/* singleton */4], param[1]), tm);
    };
    var rmv = function (tm, dna, param) {
      var p = path_of(dna)(param[0]);
      return Curry._3(Trie[/* remove */5], p, Curry._1(ZSet[/* singleton */4], param[1]), tm);
    };
    var app = function (f, tm) {
      return Curry._2(Trie[/* iter */6], (function (_, p) {
                    return Curry._2(ZSet[/* iter */12], f, p);
                  }), tm);
    };
    return /* module */[
            /* Y_tries */Y_tries,
            /* ZSet */ZSet,
            /* X_tries */X_tries,
            /* Trie */Trie,
            /* empty */empty,
            /* path_of */path_of,
            /* tm_of */tm_of,
            /* skip_arg */skip_arg,
            /* lookup */lookup,
            /* add */add$1,
            /* rmv */rmv,
            /* app */app
          ];
  };
  return (function (funarg) {
      var $$let$1 = $$let(funarg);
      return [
              $$let$1[4],
              $$let$1[9],
              $$let$1[10],
              $$let$1[8],
              $$let$1[11]
            ];
    });
}

exports.Make = Make;
/* Util-ReactTemplate Not a pure module */
