// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");

function Make(M) {
  var $$return = M[0];
  var $great$great$eq = M[1];
  var $great$great = M[2];
  var map = function (f, param) {
    if (param) {
      var match = param[1];
      var a = param[0];
      if (match) {
        var l = match[1];
        var b = match[0];
        return Curry._2($great$great$eq, Curry._1(f, a), (function (a$prime) {
                      return Curry._2($great$great$eq, Curry._1(f, b), (function (b$prime) {
                                    return Curry._2(M[/* map */3], (function (l$prime) {
                                                  return /* :: */[
                                                          a$prime,
                                                          /* :: */[
                                                            b$prime,
                                                            l$prime
                                                          ]
                                                        ];
                                                }), map(f, l));
                                  }));
                    }));
      } else {
        return Curry._2(M[/* map */3], (function (a$prime) {
                      return /* :: */[
                              a$prime,
                              /* [] */0
                            ];
                    }), Curry._1(f, a));
      }
    } else {
      return Curry._1($$return, /* [] */0);
    }
  };
  var map_right = function (f, param) {
    if (param) {
      var match = param[1];
      var a = param[0];
      if (match) {
        var b = match[0];
        return Curry._2($great$great$eq, map_right(f, match[1]), (function (l$prime) {
                      return Curry._2($great$great$eq, Curry._1(f, b), (function (b$prime) {
                                    return Curry._2(M[/* map */3], (function (a$prime) {
                                                  return /* :: */[
                                                          a$prime,
                                                          /* :: */[
                                                            b$prime,
                                                            l$prime
                                                          ]
                                                        ];
                                                }), Curry._1(f, a));
                                  }));
                    }));
      } else {
        return Curry._2(M[/* map */3], (function (a$prime) {
                      return /* :: */[
                              a$prime,
                              /* [] */0
                            ];
                    }), Curry._1(f, a));
      }
    } else {
      return Curry._1($$return, /* [] */0);
    }
  };
  var fold_right = function (f, l, x) {
    if (l) {
      var match = l[1];
      var a = l[0];
      if (match) {
        var b = match[0];
        return Curry._2($great$great$eq, fold_right(f, match[1], x), (function (acc) {
                      return Curry._2($great$great$eq, Curry._2(f, b, acc), (function (acc) {
                                    return Curry._2(f, a, acc);
                                  }));
                    }));
      } else {
        return Curry._2(f, a, x);
      }
    } else {
      return Curry._1($$return, x);
    }
  };
  var fold_left = function (f, x, param) {
    if (param) {
      var match = param[1];
      var a = param[0];
      if (match) {
        var l = match[1];
        var b = match[0];
        return Curry._2($great$great$eq, Curry._2(f, x, a), (function (x$prime) {
                      return Curry._2($great$great$eq, Curry._2(f, x$prime, b), (function (x$prime$prime) {
                                    return fold_left(f, x$prime$prime, l);
                                  }));
                    }));
      } else {
        return Curry._2(f, x, a);
      }
    } else {
      return Curry._1($$return, x);
    }
  };
  var iter = function (f, param) {
    if (param) {
      var match = param[1];
      var a = param[0];
      if (match) {
        return Curry._2($great$great, Curry._2($great$great, Curry._1(f, a), Curry._1(f, match[0])), iter(f, match[1]));
      } else {
        return Curry._1(f, a);
      }
    } else {
      return Curry._1($$return, /* () */0);
    }
  };
  var map_filter = function (f, param) {
    if (param) {
      var l = param[1];
      return Curry._2($great$great$eq, Curry._1(f, param[0]), (function (param) {
                    if (param) {
                      var b = param[0];
                      return Curry._2($great$great$eq, map_filter(f, l), (function (filtered) {
                                    return Curry._1($$return, /* :: */[
                                                b,
                                                filtered
                                              ]);
                                  }));
                    } else {
                      return map_filter(f, l);
                    }
                  }));
    } else {
      return Curry._1($$return, /* [] */0);
    }
  };
  var fold_left2 = function (r, f, x, l1, l2) {
    if (l1) {
      var match = l1[1];
      var a = l1[0];
      if (match) {
        if (l2) {
          var match$1 = l2[1];
          if (match$1) {
            var l2$1 = match$1[1];
            var b2 = match$1[0];
            var l1$1 = match[1];
            var a2 = match[0];
            return Curry._2($great$great$eq, Curry._3(f, x, a, l2[0]), (function (x$prime) {
                          return Curry._2($great$great$eq, Curry._3(f, x$prime, a2, b2), (function (x$prime$prime) {
                                        return fold_left2(r, f, x$prime$prime, l1$1, l2$1);
                                      }));
                        }));
          } else {
            return r;
          }
        } else {
          return r;
        }
      } else if (l2 && !l2[1]) {
        return Curry._3(f, x, a, l2[0]);
      } else {
        return r;
      }
    } else if (l2) {
      return r;
    } else {
      return Curry._1($$return, x);
    }
  };
  var List = /* module */[
    /* map */map,
    /* map_right */map_right,
    /* fold_right */fold_right,
    /* fold_left */fold_left,
    /* iter */iter,
    /* map_filter */map_filter,
    /* fold_left2 */fold_left2
  ];
  return /* module */[
          /* return */$$return,
          /* >>= */$great$great$eq,
          /* >> */$great$great,
          /* map */M[3],
          /* List */List
        ];
}

exports.Make = Make;
/* No side effect */
