// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var System$ReactTemplate = require("../shims/system.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Control$ReactTemplate = require("../shims/control.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Exninfo$ReactTemplate = require("./exninfo.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Logic_monad$ReactTemplate = require("./logic_monad.bs.js");
var Proofview_monad$ReactTemplate = require("./proofview_monad.bs.js");

function proofview(p) {
  return /* tuple */[
          Curry._2(Util$ReactTemplate.List[/* map */10], Proofview_monad$ReactTemplate.drop_state, p[/* comb */1]),
          p[/* solution */0]
        ];
}

function compact(el, pv) {
  var solution = pv[/* solution */0];
  var nf0 = function (c) {
    return EConstr$ReactTemplate.Unsafe[/* to_constr */0](Evarutil$ReactTemplate.nf_evar(solution, EConstr$ReactTemplate.of_constr(c)));
  };
  var size = Evd$ReactTemplate.fold((function (_, _$1, i) {
          return i + 1 | 0;
        }), solution, 0);
  var new_el = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  Evarutil$ReactTemplate.nf_evar(solution, param[0]),
                  Evarutil$ReactTemplate.nf_evar(solution, param[1])
                ];
        }), el);
  var pruned_solution = Evd$ReactTemplate.drop_all_defined(solution);
  var apply_subst_einfo = function (_, ei) {
    return /* record */[
            /* evar_concl */nf0(ei[/* evar_concl */0]),
            /* evar_hyps */Environ$ReactTemplate.map_named_val(nf0, ei[/* evar_hyps */1]),
            /* evar_body */ei[/* evar_body */2],
            /* evar_filter */ei[/* evar_filter */3],
            /* evar_source */ei[/* evar_source */4],
            /* evar_candidates */Option$ReactTemplate.map(Curry._1(Util$ReactTemplate.List[/* map */10], nf0), ei[/* evar_candidates */5]),
            /* evar_extra */ei[/* evar_extra */6]
          ];
  };
  var new_solution = Evd$ReactTemplate.raw_map_undefined(apply_subst_einfo, pruned_solution);
  var new_size = Evd$ReactTemplate.fold((function (_, _$1, i) {
          return i + 1 | 0;
        }), new_solution, 0);
  Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.str(Curry._2(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "Evars: ",
                        /* Int */Block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* String_literal */Block.__(11, [
                                " -> ",
                                /* Int */Block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* Char_literal */Block.__(12, [
                                        /* "\n" */10,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "Evars: %d -> %d\n"
                  ]), size, new_size)));
  return /* tuple */[
          new_el,
          /* record */[
            /* solution */new_solution,
            /* comb */pv[/* comb */1],
            /* shelf */pv[/* shelf */2]
          ]
        ];
}

var typeclass_resolvable = Curry._1(Evd$ReactTemplate.Store[/* field */5], /* () */0);

var store = Curry._3(Evd$ReactTemplate.Store[/* set */1], Evd$ReactTemplate.Store[/* empty */0], typeclass_resolvable, /* () */0);

var src = Loc$ReactTemplate.tag(/* None */0, /* GoalEvar */1);

function aux(param) {
  if (param.tag) {
    var typ = param[2];
    var match = Evarutil$ReactTemplate.new_evar(param[0], param[1], /* Some */[src], /* None */0, /* None */0, /* Some */[store], /* None */0, /* None */0, typ);
    var econstr = match[1];
    var sigma = match[0];
    var match$1 = EConstr$ReactTemplate.destEvar(sigma, econstr);
    var match$2 = aux(Curry._2(param[3], sigma, econstr));
    var match$3 = match$2[1];
    var entry_000 = /* tuple */[
      econstr,
      typ
    ];
    var entry_001 = match$2[0];
    var entry = /* :: */[
      entry_000,
      entry_001
    ];
    return /* tuple */[
            entry,
            /* record */[
              /* solution */match$3[/* solution */0],
              /* comb : :: */[
                Proofview_monad$ReactTemplate.with_empty_state(match$1[0]),
                match$3[/* comb */1]
              ],
              /* shelf : [] */0
            ]
          ];
  } else {
    return /* tuple */[
            /* [] */0,
            /* record */[
              /* solution */param[0],
              /* comb : [] */0,
              /* shelf : [] */0
            ]
          ];
  }
}

function dependent_init(t) {
  var match = aux(t);
  var v = match[1];
  var solution = Evd$ReactTemplate.reset_future_goals(v[/* solution */0]);
  return /* tuple */[
          match[0],
          /* record */[
            /* solution */solution,
            /* comb */v[/* comb */1],
            /* shelf */v[/* shelf */2]
          ]
        ];
}

function aux$1(sigma, param) {
  if (param) {
    var l = param[1];
    var match = param[0];
    return /* TCons */Block.__(1, [
              match[0],
              sigma,
              match[1],
              (function (sigma, _) {
                  return aux$1(sigma, l);
                })
            ]);
  } else {
    return /* TNil */Block.__(0, [sigma]);
  }
}

function init(sigma, l) {
  return dependent_init(aux$1(sigma, l));
}

function initial_goals(initial) {
  return initial;
}

function finished(param) {
  if (param[/* comb */1]) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function $$return(param) {
  return param[/* solution */0];
}

function partial_proof(entry, pv) {
  return CList$ReactTemplate.map((function (param) {
                var param$1 = pv;
                var c = param;
                return Evarutil$ReactTemplate.nf_evar(param$1[/* solution */0], c);
              }), CList$ReactTemplate.map((function (prim) {
                    return prim[0];
                  }), entry));
}

function focus_context(param) {
  return /* tuple */[
          Curry._2(Util$ReactTemplate.List[/* map */10], Proofview_monad$ReactTemplate.drop_state, param[0]),
          Curry._2(Util$ReactTemplate.List[/* map */10], Proofview_monad$ReactTemplate.drop_state, param[1])
        ];
}

function focus_sublist(i, j, l) {
  var match = CList$ReactTemplate.$$goto(i - 1 | 0, l);
  var match$1;
  try {
    match$1 = CList$ReactTemplate.chop((j - i | 0) + 1 | 0, match[1]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      throw CList$ReactTemplate.IndexOutOfRange;
    } else {
      throw exn;
    }
  }
  return /* tuple */[
          match$1[0],
          /* tuple */[
            match[0],
            match$1[1]
          ]
        ];
}

function unfocus_sublist(param, s) {
  return CList$ReactTemplate.rev_append(param[0], Util$ReactTemplate.$at(s, param[1]));
}

function focus(i, j, sp) {
  var match = focus_sublist(i, j, sp[/* comb */1]);
  var match$1 = match[1];
  return /* tuple */[
          /* record */[
            /* solution */sp[/* solution */0],
            /* comb */match[0],
            /* shelf */sp[/* shelf */2]
          ],
          /* tuple */[
            match$1[0],
            match$1[1]
          ]
        ];
}

function cleared_alias(evd, g) {
  var evk = Proofview_monad$ReactTemplate.drop_state(g);
  var state = Proofview_monad$ReactTemplate.get_state(g);
  return Option$ReactTemplate.map((function (g) {
                return Proofview_monad$ReactTemplate.goal_with_state(g, state);
              }), Evarutil$ReactTemplate.advance(evd, evk));
}

function undefined_evars(defs, l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (evk, l) {
                var match = Evarutil$ReactTemplate.advance(defs, evk);
                if (match) {
                  return Curry._3(Util$ReactTemplate.List[/* add_set */48], Evar$ReactTemplate.equal, match[0], l);
                } else {
                  return l;
                }
              }), l, /* [] */0);
}

function goal_with_state_equal(x, y) {
  return Evar$ReactTemplate.equal(Proofview_monad$ReactTemplate.drop_state(x), Proofview_monad$ReactTemplate.drop_state(y));
}

function $$undefined(defs, l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (evk, l) {
                var match = cleared_alias(defs, evk);
                if (match) {
                  return Curry._3(Util$ReactTemplate.List[/* add_set */48], goal_with_state_equal, match[0], l);
                } else {
                  return l;
                }
              }), l, /* [] */0);
}

function unfocus(param, sp) {
  return /* record */[
          /* solution */sp[/* solution */0],
          /* comb */$$undefined(sp[/* solution */0], unfocus_sublist(/* tuple */[
                    param[0],
                    param[1]
                  ], sp[/* comb */1])),
          /* shelf */sp[/* shelf */2]
        ];
}

function apply(env, t, sp) {
  var ans = Curry._1(Proofview_monad$ReactTemplate.Logical[/* repr */19], Curry._3(Proofview_monad$ReactTemplate.Logical[/* run */20], t, /* false */0, /* tuple */[
            sp,
            env
          ]));
  var ans$1 = Logic_monad$ReactTemplate.NonLogical[/* run */19](ans);
  if (ans$1.tag) {
    var match = ans$1[0];
    var status = match[2];
    var state = match[1][0];
    var status_000 = status[0];
    var status_001 = state[/* shelf */2];
    var status_002 = status[1];
    var status$1 = /* tuple */[
      status_000,
      status_001,
      status_002
    ];
    var state_000 = /* solution */state[/* solution */0];
    var state_001 = /* comb */state[/* comb */1];
    var state$1 = /* record */[
      state_000,
      state_001,
      /* shelf : [] */0
    ];
    return /* tuple */[
            match[0],
            state$1,
            status$1,
            Proofview_monad$ReactTemplate.Trace[/* to_tree */0](match[3])
          ];
  } else {
    var match$1 = ans$1[0];
    return Util$ReactTemplate.iraise(/* tuple */[
                [
                  Logic_monad$ReactTemplate.TacticFailure,
                  match$1[0]
                ],
                match$1[1]
              ]);
  }
}

var tclUNIT = Proofview_monad$ReactTemplate.Logical[/* return */0];

var tclBIND = Proofview_monad$ReactTemplate.Logical[/* >>= */1];

var tclTHEN = Proofview_monad$ReactTemplate.Logical[/* >> */2];

var tclIGNORE = Proofview_monad$ReactTemplate.Logical[/* ignore */5];

function tclZERO(info, e) {
  var info$1 = info ? info[0] : Exninfo$ReactTemplate.$$null;
  return Curry._1(Proofview_monad$ReactTemplate.Logical[/* zero */13], /* tuple */[
              e,
              info$1
            ]);
}

var tclOR = Proofview_monad$ReactTemplate.Logical[/* plus */14];

function tclORELSE(t1, t2) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(Proofview_monad$ReactTemplate.Logical[/* split */15], t1), (function (param) {
                if (param.tag) {
                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* plus */14], Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], param[0]), param[1]);
                } else {
                  return Curry._1(t2, param[0]);
                }
              }));
}

function tclIFCATCH(a, s, f) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(Proofview_monad$ReactTemplate.Logical[/* split */15], a), (function (param) {
                if (param.tag) {
                  var a$prime = param[1];
                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* plus */14], Curry._1(s, param[0]), (function (e) {
                                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(a$prime, e), Curry.__1(s));
                              }));
                } else {
                  return Curry._1(f, param[0]);
                }
              }));
}

var tclONCE = Proofview_monad$ReactTemplate.Logical[/* once */16];

var MoreThanOneSuccess = Caml_exceptions.create("Proofview-ReactTemplate.MoreThanOneSuccess");

CErrors$ReactTemplate.register_handler((function (param) {
        if (param === MoreThanOneSuccess) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This tactic has more than one success."));
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

function tclEXACTLY_ONCE(e, t) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(Proofview_monad$ReactTemplate.Logical[/* split */15], t), (function (param) {
                if (param.tag) {
                  var x = param[0];
                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(Proofview_monad$ReactTemplate.Logical[/* split */15], Curry._1(param[1], /* tuple */[
                                      e,
                                      Exninfo$ReactTemplate.$$null
                                    ])), (function (param) {
                                if (param.tag) {
                                  return tclZERO(/* None */0, MoreThanOneSuccess);
                                } else {
                                  return Curry._1(tclUNIT, x);
                                }
                              }));
                } else {
                  var match = param[0];
                  return tclZERO(/* Some */[match[1]], match[0]);
                }
              }));
}

function tclCASE(t) {
  var map = function (param) {
    if (param.tag) {
      return /* Next */Block.__(1, [
                param[0],
                param[1]
              ]);
    } else {
      return /* Fail */Block.__(0, [param[0]]);
    }
  };
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* map */3], map, Curry._1(Proofview_monad$ReactTemplate.Logical[/* split */15], t));
}

var tclBREAK = Proofview_monad$ReactTemplate.Logical[/* break */17];

var NoSuchGoals = Caml_exceptions.create("Proofview-ReactTemplate.NoSuchGoals");

var nosuchgoals_hook = [(function () {
      return Pp$ReactTemplate.mt(/* () */0);
    })];

function set_nosuchgoals_hook(f) {
  nosuchgoals_hook[0] = f;
  return /* () */0;
}

CErrors$ReactTemplate.register_handler((function (param) {
        if (param[0] === NoSuchGoals) {
          var n = param[1];
          var suffix = Curry._1(nosuchgoals_hook[0], n);
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such "), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], n, "goal"))), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.pr_non_empty_arg((function (x) {
                                return x;
                              }), suffix)));
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

function tclFOCUS_gen(nosuchgoal, i, j, t) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (initial) {
                try {
                  var match = focus(i, j, initial);
                  var context = match[1];
                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Pv[/* set */1](match[0]), t), (function (result) {
                                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Pv[/* modify */2]((function (next) {
                                                  return unfocus(context, next);
                                                })), Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], result));
                              }));
                }
                catch (exn){
                  if (exn === CList$ReactTemplate.IndexOutOfRange) {
                    return nosuchgoal;
                  } else {
                    throw exn;
                  }
                }
              }));
}

function tclFOCUS(i, j, t) {
  return tclFOCUS_gen(tclZERO(/* None */0, [
                  NoSuchGoals,
                  (j + 1 | 0) - i | 0
                ]), i, j, t);
}

function tclTRYFOCUS(i, j, t) {
  return tclFOCUS_gen(Curry._1(tclUNIT, /* () */0), i, j, t);
}

function tclFOCUSLIST(l, t) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (comb) {
                var n = CList$ReactTemplate.length(comb);
                var sanitize = function (param) {
                  var j = param[1];
                  var i = param[0];
                  if (i > j || i > n || j < 1) {
                    return /* None */0;
                  } else {
                    return /* Some */[/* tuple */[
                              i > 1 ? i : 1,
                              j < n ? j : n
                            ]];
                  }
                };
                var l$1 = CList$ReactTemplate.map_filter(sanitize, l);
                if (l$1) {
                  var mi = CList$ReactTemplate.fold_left((function (m, param) {
                          return Caml_primitive.caml_int_min(m, param[0]);
                        }), l$1[0][0], l$1);
                  var match = CList$ReactTemplate.$$goto(mi - 1 | 0, comb);
                  var p = function (x, _) {
                    return CList$ReactTemplate.exists((function (param) {
                                  if (param[0] <= (x + mi | 0)) {
                                    return +((x + mi | 0) <= param[1]);
                                  } else {
                                    return /* false */0;
                                  }
                                }), l$1);
                  };
                  var match$1 = CList$ReactTemplate.partitioni(p)(match[1]);
                  var sub = match$1[0];
                  var mj = (mi - 1 | 0) + CList$ReactTemplate.length(sub) | 0;
                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](CList$ReactTemplate.rev_append(match[0], Util$ReactTemplate.$at(sub, match$1[1]))), tclFOCUS(mi, mj, t));
                } else {
                  return tclZERO(/* None */0, [
                              NoSuchGoals,
                              0
                            ]);
                }
              }));
}

function tclFOCUSID(id, t) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (initial) {
                try {
                  var ev = Evd$ReactTemplate.evar_key(id, initial[/* solution */0]);
                  try {
                    var comb = CList$ReactTemplate.map(Proofview_monad$ReactTemplate.drop_state, initial[/* comb */1]);
                    var n = CList$ReactTemplate.index(Evar$ReactTemplate.equal, ev, comb);
                    var match = focus(n, n, initial);
                    var context = match[1];
                    return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Pv[/* set */1](match[0]), t), (function (result) {
                                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Pv[/* modify */2]((function (next) {
                                                    return unfocus(context, next);
                                                  })), Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], result));
                                }));
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](/* :: */[
                                          Proofview_monad$ReactTemplate.with_empty_state(ev),
                                          /* [] */0
                                        ]), t), (function (result) {
                                    return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](initial[/* comb */1]), Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], result));
                                  }));
                    } else {
                      throw exn;
                    }
                  }
                }
                catch (exn$1){
                  if (exn$1 === Caml_builtin_exceptions.not_found) {
                    return tclZERO(/* None */0, [
                                NoSuchGoals,
                                1
                              ]);
                  } else {
                    throw exn$1;
                  }
                }
              }));
}

var SizeMismatch = Caml_exceptions.create("Proofview-ReactTemplate.SizeMismatch");

CErrors$ReactTemplate.register_handler((function (param) {
        if (param[0] === SizeMismatch) {
          var i = param[1];
          var errmsg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incorrect number of goals"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("(expected ")), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], i, " tactic"))), Pp$ReactTemplate.str(", was given ")), Pp$ReactTemplate.$$int(param[2])), Pp$ReactTemplate.str(")."));
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, errmsg);
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

function iter_goal(i) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (initial) {
                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._3(Proofview_monad$ReactTemplate.Logical[/* List */4][/* fold_left */3], (function (cur, goal) {
                                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Solution[/* get */0], (function (step) {
                                                var match = cleared_alias(step, goal);
                                                if (match) {
                                                  var goal$1 = match[0];
                                                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](/* :: */[
                                                                      goal$1,
                                                                      /* [] */0
                                                                    ]), Curry._1(i, goal$1)), Curry._2(Proofview_monad$ReactTemplate.Logical[/* map */3], (function (comb) {
                                                                    return /* :: */[
                                                                            comb,
                                                                            cur
                                                                          ];
                                                                  }), Proofview_monad$ReactTemplate.Comb[/* get */0]));
                                                } else {
                                                  return Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], cur);
                                                }
                                              }));
                                }), /* [] */0, initial), (function (subgoals) {
                              return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Solution[/* get */0], (function (evd) {
                                            return Proofview_monad$ReactTemplate.Comb[/* set */1]($$undefined(evd, CList$ReactTemplate.flatten(CList$ReactTemplate.rev(subgoals))));
                                          }));
                            }));
              }));
}

function map_goal(i) {
  var rev = Util$ReactTemplate.List[/* rev */4];
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (initial) {
                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._3(Proofview_monad$ReactTemplate.Logical[/* List */4][/* fold_left */3], (function (cur, goal) {
                                  var subgoals = cur[1];
                                  var acc = cur[0];
                                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Solution[/* get */0], (function (step) {
                                                var match = cleared_alias(step, goal);
                                                if (match) {
                                                  var goal$1 = match[0];
                                                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](/* :: */[
                                                                      goal$1,
                                                                      /* [] */0
                                                                    ]), Curry._1(i, goal$1)), (function (res) {
                                                                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._2(Proofview_monad$ReactTemplate.Logical[/* map */3], (function (comb) {
                                                                                  return /* :: */[
                                                                                          comb,
                                                                                          subgoals
                                                                                        ];
                                                                                }), Proofview_monad$ReactTemplate.Comb[/* get */0]), (function (x) {
                                                                              return Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], /* tuple */[
                                                                                          /* :: */[
                                                                                            res,
                                                                                            acc
                                                                                          ],
                                                                                          x
                                                                                        ]);
                                                                            }));
                                                              }));
                                                } else {
                                                  return Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], cur);
                                                }
                                              }));
                                }), /* tuple */[
                                /* [] */0,
                                /* [] */0
                              ], initial), (function (param) {
                              var subgoals = param[1];
                              var results_rev = param[0];
                              return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Solution[/* get */0], (function (evd) {
                                            return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1]($$undefined(evd, CList$ReactTemplate.flatten(CList$ReactTemplate.rev(subgoals)))), Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], Curry._1(rev, results_rev)));
                                          }));
                            }));
              }));
}

function fold_left2_goal(i, s, l) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (initial) {
                var err = Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], /* () */0), (function () {
                        return tclZERO(/* None */0, [
                                    SizeMismatch,
                                    CList$ReactTemplate.length(initial[/* comb */1]),
                                    CList$ReactTemplate.length(l)
                                  ]);
                      }));
                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._5(Proofview_monad$ReactTemplate.Logical[/* List */4][/* fold_left2 */6], err, (function (cur, goal, a) {
                                  var subgoals = cur[1];
                                  var r = cur[0];
                                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Solution[/* get */0], (function (step) {
                                                var match = cleared_alias(step, goal);
                                                if (match) {
                                                  var goal$1 = match[0];
                                                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](/* :: */[
                                                                      goal$1,
                                                                      /* [] */0
                                                                    ]), Curry._3(i, goal$1, a, r)), (function (r) {
                                                                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* map */3], (function (comb) {
                                                                              return /* tuple */[
                                                                                      r,
                                                                                      /* :: */[
                                                                                        comb,
                                                                                        subgoals
                                                                                      ]
                                                                                    ];
                                                                            }), Proofview_monad$ReactTemplate.Comb[/* get */0]);
                                                              }));
                                                } else {
                                                  return Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], cur);
                                                }
                                              }));
                                }), /* tuple */[
                                s,
                                /* [] */0
                              ], initial[/* comb */1], l), (function (param) {
                              var subgoals = param[1];
                              var r = param[0];
                              return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Solution[/* get */0], (function (evd) {
                                            return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1]($$undefined(evd, CList$ReactTemplate.flatten(CList$ReactTemplate.rev(subgoals)))), Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], r));
                                          }));
                            }));
              }));
}

function tclDISPATCHGEN0(join, tacs) {
  if (tacs) {
    if (tacs[1]) {
      var iter = function (_, t, cur) {
        return Curry._2(Proofview_monad$ReactTemplate.Logical[/* map */3], (function (y) {
                      return /* :: */[
                              y,
                              cur
                            ];
                    }), t);
      };
      var ans = fold_left2_goal(iter, /* [] */0, tacs);
      return Curry._2(Proofview_monad$ReactTemplate.Logical[/* map */3], join, ans);
    } else {
      var tac = tacs[0];
      return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (param) {
                    var comb = param[/* comb */1];
                    var exit = 0;
                    if (comb) {
                      if (comb[1]) {
                        exit = 1;
                      } else {
                        var match = cleared_alias(param[/* solution */0], comb[0]);
                        if (match) {
                          return Curry._2(Proofview_monad$ReactTemplate.Logical[/* map */3], (function (res) {
                                        return Curry._1(join, /* :: */[
                                                    res,
                                                    /* [] */0
                                                  ]);
                                      }), tac);
                        } else {
                          return Curry._1(tclUNIT, Curry._1(join, /* [] */0));
                        }
                      }
                    } else {
                      exit = 1;
                    }
                    if (exit === 1) {
                      return tclZERO(/* None */0, [
                                  SizeMismatch,
                                  CList$ReactTemplate.length(comb),
                                  1
                                ]);
                    }
                    
                  }));
    }
  } else {
    return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (comb) {
                  if (comb) {
                    return tclZERO(/* None */0, [
                                SizeMismatch,
                                CList$ReactTemplate.length(comb),
                                0
                              ]);
                  } else {
                    return Curry._1(tclUNIT, Curry._1(join, /* [] */0));
                  }
                }));
  }
}

function tclDISPATCHGEN(join, tacs) {
  var branch = function (t) {
    return Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* DBranch */1, t);
  };
  var tacs$1 = CList$ReactTemplate.map(branch, tacs);
  return Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* Dispatch */0, tclDISPATCHGEN0(join, tacs$1));
}

function tclDISPATCH(tacs) {
  return tclDISPATCHGEN((function () {
                return /* () */0;
              }), tacs);
}

function tclDISPATCHL(tacs) {
  return tclDISPATCHGEN(CList$ReactTemplate.rev, tacs);
}

function extend_to_list(startxs, rx, endxs, l) {
  var duplicate = function (_acc, _param) {
    while(true) {
      var param = _param;
      var acc = _acc;
      if (param) {
        _param = param[1];
        _acc = /* :: */[
          rx,
          acc
        ];
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  var tail = function (_to_match, _rest) {
    while(true) {
      var rest = _rest;
      var to_match = _to_match;
      if (rest) {
        if (to_match) {
          _rest = rest[1];
          _to_match = to_match[1];
          continue ;
          
        } else {
          return duplicate(endxs, rest);
        }
      } else if (to_match) {
        throw [
              SizeMismatch,
              0,
              0
            ];
      } else {
        return duplicate(endxs, rest);
      }
    };
  };
  var copy = function (pref, rest) {
    if (rest) {
      if (pref) {
        return /* :: */[
                pref[0],
                copy(pref[1], rest[1])
              ];
      } else {
        return tail(endxs, rest);
      }
    } else if (pref) {
      throw [
            SizeMismatch,
            0,
            0
          ];
    } else {
      return tail(endxs, rest);
    }
  };
  return copy(startxs, l);
}

function tclEXTEND(tacs1, rtac, tacs2) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (comb) {
                try {
                  return tclDISPATCH(extend_to_list(tacs1, rtac, tacs2, comb));
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === SizeMismatch) {
                    return tclZERO(/* None */0, [
                                SizeMismatch,
                                CList$ReactTemplate.length(comb),
                                CList$ReactTemplate.length(tacs1) + CList$ReactTemplate.length(tacs2) | 0
                              ]);
                  } else {
                    throw exn;
                  }
                }
              }));
}

function tclINDEPENDENT(tac) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (initial) {
                var match = initial[/* comb */1];
                if (match) {
                  if (match[1]) {
                    var tac$1 = Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* DBranch */1, tac);
                    return Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* Dispatch */0, iter_goal((function () {
                                      return tac$1;
                                    })));
                  } else {
                    return tac;
                  }
                } else {
                  return Curry._1(tclUNIT, /* () */0);
                }
              }));
}

function tclINDEPENDENTL(tac) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (initial) {
                var match = initial[/* comb */1];
                if (match) {
                  if (match[1]) {
                    var tac$1 = Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* DBranch */1, tac);
                    return Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* Dispatch */0, map_goal((function () {
                                      return tac$1;
                                    })));
                  } else {
                    return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], tac, (function (x) {
                                  return Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], /* :: */[
                                              x,
                                              /* [] */0
                                            ]);
                                }));
                  }
                } else {
                  return Curry._1(tclUNIT, /* [] */0);
                }
              }));
}

var shelve = Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (initial) {
        return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](/* [] */0), Proofview_monad$ReactTemplate.InfoL[/* leaf */4](/* Tactic */Block.__(1, [(function () {
                                  return Pp$ReactTemplate.str("shelve");
                                })]))), Proofview_monad$ReactTemplate.Shelf[/* modify */2]((function (gls) {
                          return Util$ReactTemplate.$at(gls, CList$ReactTemplate.map(Proofview_monad$ReactTemplate.drop_state, initial));
                        })));
      }));

function shelve_goals(l) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (initial) {
                var comb = CList$ReactTemplate.filter((function (g) {
                        return 1 - CList$ReactTemplate.mem(Proofview_monad$ReactTemplate.drop_state(g), l);
                      }), initial);
                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](comb), Proofview_monad$ReactTemplate.InfoL[/* leaf */4](/* Tactic */Block.__(1, [(function () {
                                          return Pp$ReactTemplate.str("shelve_goals");
                                        })]))), Proofview_monad$ReactTemplate.Shelf[/* modify */2]((function (gls) {
                                  return Util$ReactTemplate.$at(gls, l);
                                })));
              }));
}

function depends_on(sigma, src, tgt) {
  var evi = Evd$ReactTemplate.find(sigma, tgt);
  return Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], src, Evd$ReactTemplate.evars_of_filtered_evar_info(Evarutil$ReactTemplate.nf_evar_info(sigma, evi)));
}

function unifiable_delayed(g, l) {
  return CList$ReactTemplate.exists((function (param) {
                var match = param[1];
                var tag = match.tag | 0;
                var evs = tag === 250 ? match[0] : (
                    tag === 246 ? CamlinternalLazy.force_lazy_block(match) : match
                  );
                if (Evar$ReactTemplate.equal(g, param[0])) {
                  return /* false */0;
                } else {
                  return Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], g, evs);
                }
              }), l);
}

function free_evars(sigma, l) {
  var cache = Evarutil$ReactTemplate.create_undefined_evars_cache(/* () */0);
  var map = function (ev) {
    var evi = Evd$ReactTemplate.find(sigma, ev);
    var fevs = Block.__(246, [(function () {
            return Evarutil$ReactTemplate.filtered_undefined_evars_of_evar_info(/* Some */[cache], sigma, evi);
          })]);
    return /* tuple */[
            ev,
            fevs
          ];
  };
  return Curry._2(Util$ReactTemplate.List[/* map */10], map, l);
}

function free_evars_with_state(sigma, l) {
  var cache = Evarutil$ReactTemplate.create_undefined_evars_cache(/* () */0);
  var map = function (ev) {
    var ev$1 = Proofview_monad$ReactTemplate.drop_state(ev);
    var evi = Evd$ReactTemplate.find(sigma, ev$1);
    var fevs = Block.__(246, [(function () {
            return Evarutil$ReactTemplate.filtered_undefined_evars_of_evar_info(/* Some */[cache], sigma, evi);
          })]);
    return /* tuple */[
            ev$1,
            fevs
          ];
  };
  return Curry._2(Util$ReactTemplate.List[/* map */10], map, l);
}

function unifiable(sigma, g, l) {
  var l$1 = free_evars(sigma, l);
  return unifiable_delayed(g, l$1);
}

function partition_unifiable(sigma, l) {
  var fevs = free_evars_with_state(sigma, l);
  return CList$ReactTemplate.partition((function (g) {
                var g$1 = g;
                var l = fevs;
                var g$2 = Proofview_monad$ReactTemplate.drop_state(g$1);
                return unifiable_delayed(g$2, l);
              }), l);
}

var shelve_unifiable = Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (initial) {
        var match = partition_unifiable(initial[/* solution */0], initial[/* comb */1]);
        var u = match[0];
        return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](match[1]), Proofview_monad$ReactTemplate.InfoL[/* leaf */4](/* Tactic */Block.__(1, [(function () {
                                  return Pp$ReactTemplate.str("shelve_unifiable");
                                })]))), Proofview_monad$ReactTemplate.Shelf[/* modify */2]((function (gls) {
                          return Util$ReactTemplate.$at(gls, CList$ReactTemplate.map(Proofview_monad$ReactTemplate.drop_state, u));
                        })));
      }));

var guard_no_unifiable = Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (initial) {
        var match = partition_unifiable(initial[/* solution */0], initial[/* comb */1]);
        var u = match[0];
        if (u) {
          var l = CList$ReactTemplate.map((function (g) {
                  return Evd$ReactTemplate.dependent_evar_ident(Proofview_monad$ReactTemplate.drop_state(g), initial[/* solution */0]);
                }), u);
          var l$1 = CList$ReactTemplate.map((function (id) {
                  return /* Name */[id];
                }), l);
          return Curry._1(tclUNIT, /* Some */[l$1]);
        } else {
          return Curry._1(tclUNIT, /* None */0);
        }
      }));

function unshelve(l, p) {
  var l$1 = Curry._2(Util$ReactTemplate.List[/* map */10], Proofview_monad$ReactTemplate.with_empty_state, l);
  var l$2 = $$undefined(p[/* solution */0], l$1);
  return /* record */[
          /* solution */p[/* solution */0],
          /* comb */Util$ReactTemplate.$at(p[/* comb */1], l$2),
          /* shelf */p[/* shelf */2]
        ];
}

function mark_in_evm(goal, evd, content) {
  var info = Evd$ReactTemplate.find(evd, content);
  var info$1;
  if (goal) {
    var newrecord = info.slice();
    var x = info[/* evar_source */4];
    var match = x[1];
    var loc = x[0];
    var tmp;
    if (typeof match === "number") {
      tmp = match === 1 ? x : /* tuple */[
          loc,
          /* GoalEvar */1
        ];
    } else {
      switch (match.tag | 0) {
        case 0 : 
            var match$1 = match[1][1];
            tmp = match$1 ? /* tuple */[
                loc,
                /* VarInstance */Block.__(7, [match$1[0]])
              ] : /* tuple */[
                loc,
                /* GoalEvar */1
              ];
            break;
        case 3 : 
            var match$2 = match[1];
            tmp = match$2 ? /* tuple */[
                loc,
                /* VarInstance */Block.__(7, [match$2[0]])
              ] : /* tuple */[
                loc,
                /* GoalEvar */1
              ];
            break;
        case 7 : 
            tmp = x;
            break;
        default:
          tmp = /* tuple */[
            loc,
            /* GoalEvar */1
          ];
      }
    }
    newrecord[/* evar_source */4] = tmp;
    info$1 = newrecord;
  } else {
    info$1 = info;
  }
  var match$3 = Curry._2(Evd$ReactTemplate.Store[/* get */2], info$1[/* evar_extra */6], typeclass_resolvable);
  var info$2;
  if (match$3) {
    info$2 = info$1;
  } else {
    var newrecord$1 = info$1.slice();
    newrecord$1[/* evar_extra */6] = Curry._3(Evd$ReactTemplate.Store[/* set */1], info$1[/* evar_extra */6], typeclass_resolvable, /* () */0);
    info$2 = newrecord$1;
  }
  return Evd$ReactTemplate.add(evd, content, info$2);
}

function with_shelf(tac) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (pv) {
                var shelf = pv[/* shelf */2];
                var solution = pv[/* solution */0];
                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Pv[/* set */1](/* record */[
                                    /* solution */Evd$ReactTemplate.reset_future_goals(solution),
                                    /* comb */pv[/* comb */1],
                                    /* shelf : [] */0
                                  ]), tac), (function (ans) {
                              return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (npv) {
                                            var sigma = npv[/* solution */0];
                                            var gls$prime = Evd$ReactTemplate.future_goals(sigma);
                                            var fgoals = Evd$ReactTemplate.save_future_goals(solution);
                                            var sigma$1 = Evd$ReactTemplate.restore_future_goals(sigma, fgoals);
                                            var gls$prime$1 = undefined_evars(sigma$1, CList$ReactTemplate.rev_append(gls$prime, npv[/* shelf */2]));
                                            var sigma$2 = CList$ReactTemplate.fold_left((function (param, param$1) {
                                                    return mark_in_evm(/* false */0, param, param$1);
                                                  }), sigma$1, gls$prime$1);
                                            var npv_001 = /* comb */npv[/* comb */1];
                                            var npv$1 = /* record */[
                                              /* solution */sigma$2,
                                              npv_001,
                                              /* shelf */shelf
                                            ];
                                            return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Pv[/* set */1](npv$1), Curry._1(tclUNIT, /* tuple */[
                                                            gls$prime$1,
                                                            ans
                                                          ]));
                                          }));
                            }));
              }));
}

function goodmod(p, m) {
  if (m) {
    var p$prime = Caml_int32.mod_(p, m);
    if (p$prime < 0) {
      return p$prime + m | 0;
    } else {
      return p$prime;
    }
  } else {
    return 0;
  }
}

function cycle(n) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.InfoL[/* leaf */4](/* Tactic */Block.__(1, [(function () {
                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("cycle "), Pp$ReactTemplate.$$int(n));
                      })])), Proofview_monad$ReactTemplate.Comb[/* modify */2]((function (initial) {
                    var l = CList$ReactTemplate.length(initial);
                    var n$prime = goodmod(n, l);
                    var match = CList$ReactTemplate.chop(n$prime, initial);
                    return Util$ReactTemplate.$at(match[1], match[0]);
                  })));
}

function swap(i, j) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.InfoL[/* leaf */4](/* Tactic */Block.__(1, [(function () {
                        return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("swap"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(j)));
                      })])), Proofview_monad$ReactTemplate.Comb[/* modify */2]((function (initial) {
                    var l = CList$ReactTemplate.length(initial);
                    var i$1 = i > 0 ? i - 1 | 0 : i;
                    var j$1 = j > 0 ? j - 1 | 0 : j;
                    var i$2 = goodmod(i$1, l);
                    var j$2 = goodmod(j$1, l);
                    return CList$ReactTemplate.map_i((function (k, x) {
                                  if (k === i$2) {
                                    return CList$ReactTemplate.nth(initial, j$2);
                                  } else if (k === j$2) {
                                    return CList$ReactTemplate.nth(initial, i$2);
                                  } else {
                                    return x;
                                  }
                                }), 0, initial);
                  })));
}

var revgoals = Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.InfoL[/* leaf */4](/* Tactic */Block.__(1, [(function () {
                return Pp$ReactTemplate.str("revgoals");
              })])), Proofview_monad$ReactTemplate.Comb[/* modify */2](CList$ReactTemplate.rev));

var numgoals = Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (comb) {
        return Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], CList$ReactTemplate.length(comb));
      }));

var tclEVARMAP = Proofview_monad$ReactTemplate.Solution[/* get */0];

var tclENV = Proofview_monad$ReactTemplate.Env[/* get */0];

function tclEFFECTS(eff) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], /* () */0), (function () {
                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Env[/* set */1](Global$ReactTemplate.env(/* () */0)), Proofview_monad$ReactTemplate.Pv[/* modify */2]((function (initial) {
                                  var eff$1 = eff;
                                  var x = initial;
                                  return /* record */[
                                          /* solution */Evd$ReactTemplate.emit_side_effects(eff$1, x[/* solution */0]),
                                          /* comb */x[/* comb */1],
                                          /* shelf */x[/* shelf */2]
                                        ];
                                })));
              }));
}

var mark_as_unsafe = Proofview_monad$ReactTemplate.Status[/* put */0](/* false */0);

var give_up = Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (initial) {
        return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.Comb[/* set */1](/* [] */0), mark_as_unsafe), Proofview_monad$ReactTemplate.InfoL[/* leaf */4](/* Tactic */Block.__(1, [(function () {
                                  return Pp$ReactTemplate.str("give_up");
                                })]))), Proofview_monad$ReactTemplate.Giveup[/* put */0](CList$ReactTemplate.map(Proofview_monad$ReactTemplate.drop_state, initial)));
      }));

function eq_named_context_val(sigma1, sigma2, ctx1, ctx2) {
  var c1 = Environ$ReactTemplate.named_context_of_val(ctx1);
  var c2 = Environ$ReactTemplate.named_context_of_val(ctx2);
  var eq_named_declaration = function (d1, d2) {
    if (d1.tag) {
      if (!d2.tag || !(Names$ReactTemplate.Id[/* equal */0](d1[0], d2[0]) && Evarutil$ReactTemplate.eq_constr_univs_test(sigma1, sigma2, d1[1], d2[1]))) {
        return /* false */0;
      } else {
        return Evarutil$ReactTemplate.eq_constr_univs_test(sigma1, sigma2, d1[2], d2[2]);
      }
    } else if (!d2.tag && Names$ReactTemplate.Id[/* equal */0](d1[0], d2[0])) {
      return Evarutil$ReactTemplate.eq_constr_univs_test(sigma1, sigma2, d1[1], d2[1]);
    } else {
      return /* false */0;
    }
  };
  return Curry._3(Util$ReactTemplate.List[/* equal */44], eq_named_declaration, c1, c2);
}

function tclPROGRESS(t) {
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (initial) {
                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], t, (function (res) {
                              return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function ($$final) {
                                            var quick_test = +(initial[/* solution */0] === $$final[/* solution */0] && initial[/* comb */1] === $$final[/* comb */1]);
                                            var test = quick_test || Curry._3(Util$ReactTemplate.List[/* for_all2eq */92], (function (i, f) {
                                                    var evars1 = initial[/* solution */0];
                                                    var gl1 = i;
                                                    var evars2 = $$final[/* solution */0];
                                                    var gl2 = f;
                                                    var evi1 = Evd$ReactTemplate.find(evars1, Proofview_monad$ReactTemplate.drop_state(gl1));
                                                    var evi2 = Evd$ReactTemplate.find(evars2, Proofview_monad$ReactTemplate.drop_state(gl2));
                                                    var sigma1 = evars1;
                                                    var sigma2 = evars2;
                                                    var ei1 = evi1;
                                                    var ei2 = evi2;
                                                    if (Evarutil$ReactTemplate.eq_constr_univs_test(sigma1, sigma2, ei1[/* evar_concl */0], ei2[/* evar_concl */0]) && eq_named_context_val(sigma1, sigma2, ei1[/* evar_hyps */1], ei2[/* evar_hyps */1])) {
                                                      var sigma1$1 = sigma1;
                                                      var sigma2$1 = sigma2;
                                                      var b1 = ei1[/* evar_body */2];
                                                      var b2 = ei2[/* evar_body */2];
                                                      if (b1) {
                                                        if (b2) {
                                                          return Evarutil$ReactTemplate.eq_constr_univs_test(sigma1$1, sigma2$1, b1[0], b2[0]);
                                                        } else {
                                                          return /* false */0;
                                                        }
                                                      } else if (b2) {
                                                        return /* false */0;
                                                      } else {
                                                        return /* true */1;
                                                      }
                                                    } else {
                                                      return /* false */0;
                                                    }
                                                  }), initial[/* comb */1], $$final[/* comb */1]);
                                            if (test) {
                                              return tclZERO(/* None */0, [
                                                          CErrors$ReactTemplate.UserError,
                                                          /* Some */["Proofview.tclPROGRESS"],
                                                          Pp$ReactTemplate.str("Failed to progress.")
                                                        ]);
                                            } else {
                                              return Curry._1(tclUNIT, res);
                                            }
                                          }));
                            }));
              }));
}

var Timeout = Caml_exceptions.create("Proofview-ReactTemplate.Timeout");

CErrors$ReactTemplate.register_handler((function (param) {
        if (param === Timeout) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Proofview.tclTIMEOUT"], Pp$ReactTemplate.str("Tactic timeout!"));
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

function tclTIMEOUT(n, t) {
  var t$1 = Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._1(Proofview_monad$ReactTemplate.Logical[/* lift */18], Curry._1(Logic_monad$ReactTemplate.NonLogical[/* return */0], /* () */0)), t);
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Logical[/* get */7], (function (initial) {
                return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Logical[/* current */10], (function (envvar) {
                              return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(Proofview_monad$ReactTemplate.Logical[/* lift */18], Logic_monad$ReactTemplate.NonLogical[/* catch */16](Curry._2(Logic_monad$ReactTemplate.NonLogical[/* >>= */1], Logic_monad$ReactTemplate.NonLogical[/* timeout */17](n, Curry._1(Proofview_monad$ReactTemplate.Logical[/* repr */19], Curry._3(Proofview_monad$ReactTemplate.Logical[/* run */20], t$1, envvar, initial))), (function (r) {
                                                        if (r.tag) {
                                                          return Curry._1(Logic_monad$ReactTemplate.NonLogical[/* return */0], /* Inl */Block.__(0, [r[0]]));
                                                        } else {
                                                          return Curry._1(Logic_monad$ReactTemplate.NonLogical[/* return */0], /* Inr */Block.__(1, [r[0]]));
                                                        }
                                                      })), (function (param) {
                                                    var info = param[1];
                                                    var e = param[0];
                                                    if (e === Logic_monad$ReactTemplate.Timeout) {
                                                      return Curry._1(Logic_monad$ReactTemplate.NonLogical[/* return */0], /* Inr */Block.__(1, [/* tuple */[
                                                                      Timeout,
                                                                      info
                                                                    ]]));
                                                    } else if (e[0] === Logic_monad$ReactTemplate.TacticFailure) {
                                                      return Curry._1(Logic_monad$ReactTemplate.NonLogical[/* return */0], /* Inr */Block.__(1, [/* tuple */[
                                                                      e[1],
                                                                      info
                                                                    ]]));
                                                    } else {
                                                      return Logic_monad$ReactTemplate.NonLogical[/* raise */15](/* Some */[info], e);
                                                    }
                                                  }))), (function (param) {
                                            if (param.tag) {
                                              var match = param[0];
                                              return tclZERO(/* Some */[match[1]], match[0]);
                                            } else {
                                              var match$1 = param[0];
                                              var i = match$1[3];
                                              return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Curry._1(Proofview_monad$ReactTemplate.Logical[/* set */6], match$1[1]), Curry._1(Proofview_monad$ReactTemplate.Logical[/* put */9], match$1[2])), Curry._1(Proofview_monad$ReactTemplate.Logical[/* update */12], (function () {
                                                                    return i;
                                                                  }))), Curry._1(Proofview_monad$ReactTemplate.Logical[/* return */0], match$1[0]));
                                            }
                                          }));
                            }));
              }));
}

function tclTIME(s, t) {
  var pr_time = function (t1, t2, n, msg) {
    var msg$1 = n ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(msg + " after "), Pp$ReactTemplate.$$int(n)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], n, " backtracking"))) : Pp$ReactTemplate.str(msg);
    return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Tactic call"), Pp$ReactTemplate.pr_opt(Pp$ReactTemplate.str, s)), Pp$ReactTemplate.str(" ran for ")), System$ReactTemplate.fmt_time_difference(t1, t2)), Pp$ReactTemplate.str(" ")), Pp$ReactTemplate.surround(msg$1)));
  };
  var aux = function (n, t) {
    return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(tclUNIT, /* () */0), (function () {
                  var tstart = System$ReactTemplate.get_time(/* () */0);
                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Curry._1(Proofview_monad$ReactTemplate.Logical[/* split */15], t), (function (param) {
                                if (param.tag) {
                                  var k = param[1];
                                  var tend = System$ReactTemplate.get_time(/* () */0);
                                  pr_time(tstart, tend, n, "success");
                                  return Curry._2(tclOR, Curry._1(tclUNIT, param[0]), (function (e) {
                                                return aux(n + 1 | 0, Curry._1(k, e));
                                              }));
                                } else {
                                  var match = param[0];
                                  var tend$1 = System$ReactTemplate.get_time(/* () */0);
                                  pr_time(tstart, tend$1, n, "failure");
                                  return tclZERO(/* Some */[match[1]], match[0]);
                                }
                              }));
                }));
  };
  return aux(0, t);
}

function tclEVARS(evd) {
  return Proofview_monad$ReactTemplate.Pv[/* modify */2]((function (ps) {
                return /* record */[
                        /* solution */evd,
                        /* comb */ps[/* comb */1],
                        /* shelf */ps[/* shelf */2]
                      ];
              }));
}

function tclNEWGOALS(gls) {
  return Proofview_monad$ReactTemplate.Pv[/* modify */2]((function (step) {
                var gls$1 = $$undefined(step[/* solution */0], gls);
                return /* record */[
                        /* solution */step[/* solution */0],
                        /* comb */Util$ReactTemplate.$at(step[/* comb */1], gls$1),
                        /* shelf */step[/* shelf */2]
                      ];
              }));
}

var tclSETENV = Proofview_monad$ReactTemplate.Env[/* set */1];

var tclGETGOALS = Proofview_monad$ReactTemplate.Comb[/* get */0];

var tclSETGOALS = Proofview_monad$ReactTemplate.Comb[/* set */1];

var tclGETSHELF = Proofview_monad$ReactTemplate.Shelf[/* get */0];

var tclSETSHELF = Proofview_monad$ReactTemplate.Shelf[/* set */1];

function tclPUTSHELF(to_shelve) {
  return Curry._2(tclBIND, tclGETSHELF, (function (shelf) {
                return Curry._1(tclSETSHELF, Util$ReactTemplate.$at(to_shelve, shelf));
              }));
}

var tclPUTGIVENUP = Proofview_monad$ReactTemplate.Giveup[/* put */0];

function tclEVARSADVANCE(evd) {
  return Proofview_monad$ReactTemplate.Pv[/* modify */2]((function (ps) {
                return /* record */[
                        /* solution */evd,
                        /* comb */$$undefined(evd, ps[/* comb */1]),
                        /* shelf */ps[/* shelf */2]
                      ];
              }));
}

function tclEVARUNIVCONTEXT(ctx) {
  return Proofview_monad$ReactTemplate.Pv[/* modify */2]((function (ps) {
                return /* record */[
                        /* solution */Evd$ReactTemplate.set_universe_context(ps[/* solution */0], ctx),
                        /* comb */ps[/* comb */1],
                        /* shelf */ps[/* shelf */2]
                      ];
              }));
}

function reset_future_goals(p) {
  return /* record */[
          /* solution */Evd$ReactTemplate.reset_future_goals(p[/* solution */0]),
          /* comb */p[/* comb */1],
          /* shelf */p[/* shelf */2]
        ];
}

function mark_as_goal(evd, content) {
  return mark_in_evm(/* true */1, evd, content);
}

function mark_as_unresolvable(p, gl) {
  return /* record */[
          /* solution */mark_in_evm(/* false */0, p[/* solution */0], gl),
          /* comb */p[/* comb */1],
          /* shelf */p[/* shelf */2]
        ];
}

function goal_nf_evar(sigma, gl) {
  var evi = Evd$ReactTemplate.find(sigma, gl);
  var evi$1 = Evarutil$ReactTemplate.nf_evar_info(sigma, evi);
  var sigma$1 = Evd$ReactTemplate.add(sigma, gl, evi$1);
  return /* tuple */[
          gl,
          sigma$1
        ];
}

function catchable_exception(e) {
  if (e[0] === Logic_monad$ReactTemplate.Exception) {
    return /* false */0;
  } else {
    return CErrors$ReactTemplate.noncritical(e);
  }
}

function assume(gl) {
  return gl;
}

function print(param) {
  return /* record */[
          /* it */param[/* self */4],
          /* sigma */param[/* sigma */1]
        ];
}

function state(param) {
  return param[/* state */3];
}

function env(param) {
  return param[/* env */0];
}

function sigma(param) {
  return param[/* sigma */1];
}

function hyps(param) {
  return EConstr$ReactTemplate.named_context(param[/* env */0]);
}

function concl(param) {
  return param[/* concl */2];
}

function extra(param) {
  return Evd$ReactTemplate.find(param[/* sigma */1], param[/* self */4])[/* evar_extra */6];
}

function gmake_with(info, env, sigma, goal, state) {
  return /* record */[
          /* env */Environ$ReactTemplate.reset_with_named_context(Evd$ReactTemplate.evar_filtered_hyps(info), env),
          /* sigma */sigma,
          /* concl */EConstr$ReactTemplate.of_constr(Evd$ReactTemplate.evar_concl(info)),
          /* state */state,
          /* self */goal
        ];
}

function nf_gmake(env, sigma, goal) {
  var state = Proofview_monad$ReactTemplate.get_state(goal);
  var goal$1 = Proofview_monad$ReactTemplate.drop_state(goal);
  var info = Evarutil$ReactTemplate.nf_evar_info(sigma, Evd$ReactTemplate.find(sigma, goal$1));
  var sigma$1 = Evd$ReactTemplate.add(sigma, goal$1, info);
  return /* tuple */[
          gmake_with(info, env, sigma$1, goal$1, state),
          sigma$1
        ];
}

function nf_enter(f) {
  return Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* Dispatch */0, iter_goal((function (goal) {
                    return Curry._2(tclBIND, tclENV, (function (env) {
                                  return Curry._2(tclBIND, tclEVARMAP, (function (sigma) {
                                                try {
                                                  var match = nf_gmake(env, sigma, goal);
                                                  return Curry._2(tclTHEN, tclEVARS(match[1]), Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* DBranch */1, Curry._1(f, match[0])));
                                                }
                                                catch (raw_e){
                                                  var e = Js_exn.internalToOCamlException(raw_e);
                                                  if (catchable_exception(e)) {
                                                    var match$1 = CErrors$ReactTemplate.push(e);
                                                    return tclZERO(/* Some */[match$1[1]], match$1[0]);
                                                  } else {
                                                    throw e;
                                                  }
                                                }
                                              }));
                                }));
                  })));
}

function normalize(param) {
  var self = param[/* self */4];
  var state = param[/* state */3];
  return Curry._2(tclBIND, Proofview_monad$ReactTemplate.Env[/* get */0], (function (env) {
                return Curry._2(tclBIND, tclEVARMAP, (function (sigma) {
                              var match = nf_gmake(env, sigma, Proofview_monad$ReactTemplate.goal_with_state(self, state));
                              return Curry._2(tclTHEN, tclEVARS(match[1]), Curry._1(tclUNIT, match[0]));
                            }));
              }));
}

function gmake(env, sigma, goal) {
  var state = Proofview_monad$ReactTemplate.get_state(goal);
  var goal$1 = Proofview_monad$ReactTemplate.drop_state(goal);
  var info = Evd$ReactTemplate.find(sigma, goal$1);
  return gmake_with(info, env, sigma, goal$1, state);
}

function enter(f) {
  return Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* Dispatch */0, iter_goal((function (goal) {
                    return Curry._2(tclBIND, Proofview_monad$ReactTemplate.Env[/* get */0], (function (env) {
                                  return Curry._2(tclBIND, tclEVARMAP, (function (sigma) {
                                                try {
                                                  var gl = gmake(env, sigma, goal);
                                                  return Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* DBranch */1, Curry._1(f, gl));
                                                }
                                                catch (raw_e){
                                                  var e = Js_exn.internalToOCamlException(raw_e);
                                                  if (catchable_exception(e)) {
                                                    var match = CErrors$ReactTemplate.push(e);
                                                    return tclZERO(/* Some */[match[1]], match[0]);
                                                  } else {
                                                    throw e;
                                                  }
                                                }
                                              }));
                                }));
                  })));
}

function enter_one($staropt$star, f) {
  var __LOC__ = $staropt$star ? $staropt$star[0] : "File \"/Users/joel/code/reason/planetary-frontend/src/proofview.ml\", line 1146, characters 26-33";
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Comb[/* get */0], (function (param) {
                var exit = 0;
                if (param) {
                  if (param[1]) {
                    exit = 1;
                  } else {
                    var goal = param[0];
                    return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Env[/* get */0], (function (env) {
                                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], tclEVARMAP, (function (sigma) {
                                                try {
                                                  return Curry._1(f, gmake(env, sigma, goal));
                                                }
                                                catch (raw_e){
                                                  var e = Js_exn.internalToOCamlException(raw_e);
                                                  if (catchable_exception(e)) {
                                                    var match = CErrors$ReactTemplate.push(e);
                                                    return tclZERO(/* Some */[match[1]], match[0]);
                                                  } else {
                                                    throw e;
                                                  }
                                                }
                                              }));
                                }));
                  }
                } else {
                  exit = 1;
                }
                if (exit === 1) {
                  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(__LOC__), Pp$ReactTemplate.str(" enter_one")));
                }
                
              }));
}

var goals = Curry._2(tclBIND, Proofview_monad$ReactTemplate.Pv[/* get */0], (function (step) {
        var sigma = step[/* solution */0];
        var map = function (goal) {
          var match = cleared_alias(sigma, goal);
          if (match) {
            var goal$1 = match[0];
            var gl = Curry._2(tclBIND, Proofview_monad$ReactTemplate.Env[/* get */0], (function (env) {
                    return Curry._2(tclBIND, tclEVARMAP, (function (sigma) {
                                  return Curry._1(tclUNIT, gmake(env, sigma, goal$1));
                                }));
                  }));
            return /* Some */[gl];
          } else {
            return /* None */0;
          }
        };
        return Curry._1(tclUNIT, CList$ReactTemplate.map_filter(map, step[/* comb */1]));
      }));

function unsolved(param) {
  var self = param[/* self */4];
  return Curry._2(tclBIND, tclEVARMAP, (function (sigma) {
                return Curry._1(tclUNIT, 1 - Option$ReactTemplate.is_empty(Evarutil$ReactTemplate.advance(sigma, self)));
              }));
}

function goal(param) {
  return param[/* self */4];
}

var record_info_trace = Proofview_monad$ReactTemplate.InfoL[/* record_trace */0];

function log(m) {
  return Proofview_monad$ReactTemplate.InfoL[/* leaf */4](/* Msg */Block.__(0, [m]));
}

function name_tactic(m, t) {
  return Proofview_monad$ReactTemplate.InfoL[/* tag */5](/* Tactic */Block.__(1, [m]), t);
}

function pr_info($staropt$star, info) {
  var lvl = $staropt$star ? $staropt$star[0] : 0;
  if (lvl < 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "proofview.ml",
            1197,
            4
          ]
        ];
  }
  return Proofview_monad$ReactTemplate.Info[/* print */0](Proofview_monad$ReactTemplate.Info[/* collapse */1](lvl, info));
}

var Trace = /* module */[
  /* record_info_trace */record_info_trace,
  /* log */log,
  /* name_tactic */name_tactic,
  /* pr_info */pr_info
];

var tclLIFT = Proofview_monad$ReactTemplate.Logical[/* lift */18];

var tclCHECKINTERRUPT = Curry._1(tclLIFT, Logic_monad$ReactTemplate.NonLogical[/* make */18](Control$ReactTemplate.check_for_interrupt));

function tactic($staropt$star, tac) {
  var nf_evars = $staropt$star ? $staropt$star[0] : /* true */1;
  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >>= */1], Proofview_monad$ReactTemplate.Pv[/* get */0], (function (ps) {
                try {
                  var tac$1 = function (g_w_s, evd) {
                    var g = Proofview_monad$ReactTemplate.drop_state(g_w_s);
                    var w = Proofview_monad$ReactTemplate.get_state(g_w_s);
                    var glsigma = Curry._1(tac, /* record */[
                          /* it */g,
                          /* sigma */evd
                        ]);
                    var sigma = glsigma[/* sigma */1];
                    var g$1 = CList$ReactTemplate.map((function (g) {
                            return Proofview_monad$ReactTemplate.goal_with_state(g, w);
                          }), glsigma[/* it */0]);
                    return /* tuple */[
                            g$1,
                            sigma
                          ];
                  };
                  var match = Curry._3(Evd$ReactTemplate.Monad[/* List */4][/* map */0], (function (g_w_s, s) {
                          var g = Proofview_monad$ReactTemplate.drop_state(g_w_s);
                          var w = Proofview_monad$ReactTemplate.get_state(g_w_s);
                          var match = nf_evars ? goal_nf_evar(s, g) : /* tuple */[
                              g,
                              s
                            ];
                          return /* tuple */[
                                  Proofview_monad$ReactTemplate.goal_with_state(match[0], w),
                                  match[1]
                                ];
                        }), ps[/* comb */1], ps[/* solution */0]);
                  var match$1 = Curry._3(Evd$ReactTemplate.Monad[/* List */4][/* map */0], tac$1, match[0], match[1]);
                  var evd = match$1[1];
                  var sgs = CList$ReactTemplate.flatten(match$1[0]);
                  var sgs$1 = $$undefined(evd, sgs);
                  return Curry._2(Proofview_monad$ReactTemplate.Logical[/* >> */2], Proofview_monad$ReactTemplate.InfoL[/* leaf */4](/* Tactic */Block.__(1, [(function () {
                                        return Pp$ReactTemplate.str("<unknown>");
                                      })])), Proofview_monad$ReactTemplate.Pv[/* set */1](/* record */[
                                  /* solution */evd,
                                  /* comb */sgs$1,
                                  /* shelf */ps[/* shelf */2]
                                ]));
                }
                catch (raw_e){
                  var e = Js_exn.internalToOCamlException(raw_e);
                  if (catchable_exception(e)) {
                    var match$2 = CErrors$ReactTemplate.push(e);
                    return tclZERO(/* Some */[match$2[1]], match$2[0]);
                  } else {
                    throw e;
                  }
                }
              }));
}

var nf_evar_goals = Proofview_monad$ReactTemplate.Pv[/* modify */2]((function (ps) {
        var map = function (g, s) {
          return goal_nf_evar(s, g);
        };
        var comb = CList$ReactTemplate.map(Proofview_monad$ReactTemplate.drop_state, ps[/* comb */1]);
        var match = Curry._3(Evd$ReactTemplate.Monad[/* List */4][/* map */0], map, comb, ps[/* solution */0]);
        return /* record */[
                /* solution */match[1],
                /* comb */ps[/* comb */1],
                /* shelf */ps[/* shelf */2]
              ];
      }));

function has_unresolved_evar(pv) {
  return Evd$ReactTemplate.has_undefined(pv[/* solution */0]);
}

function grab(pv) {
  var undef = Evd$ReactTemplate.undefined_map(pv[/* solution */0]);
  var goals = CList$ReactTemplate.rev_map((function (prim) {
          return prim[0];
        }), Curry._1(Evar$ReactTemplate.$$Map[/* bindings */16], undef));
  return /* record */[
          /* solution */pv[/* solution */0],
          /* comb */Curry._2(Util$ReactTemplate.List[/* map */10], Proofview_monad$ReactTemplate.with_empty_state, goals),
          /* shelf */pv[/* shelf */2]
        ];
}

function goals$1(param) {
  return /* record */[
          /* it */Curry._2(Util$ReactTemplate.List[/* map */10], Proofview_monad$ReactTemplate.drop_state, param[/* comb */1]),
          /* sigma */param[/* solution */0]
        ];
}

function top_goals(initial, param) {
  var goals = CList$ReactTemplate.map((function (param) {
          return Constr$ReactTemplate.destEvar(EConstr$ReactTemplate.Unsafe[/* to_constr */0](param[0]))[0];
        }), initial);
  return /* record */[
          /* it */goals,
          /* sigma */param[/* solution */0]
        ];
}

function top_evars(initial) {
  var evars_of_initial = function (param) {
    return Curry._1(Evar$ReactTemplate.$$Set[/* elements */19], Evd$ReactTemplate.evars_of_term(EConstr$ReactTemplate.Unsafe[/* to_constr */0](param[0])));
  };
  return CList$ReactTemplate.flatten(CList$ReactTemplate.map(evars_of_initial, initial));
}

function of_tactic(t, gls) {
  try {
    var init_000 = /* solution */gls[/* sigma */1];
    var init_001 = /* comb : :: */[
      Proofview_monad$ReactTemplate.with_empty_state(gls[/* it */0]),
      /* [] */0
    ];
    var init = /* record */[
      init_000,
      init_001,
      /* shelf : [] */0
    ];
    var match = apply(Evd$ReactTemplate.evar_filtered_env(Evd$ReactTemplate.find(gls[/* sigma */1], gls[/* it */0])), t, init);
    var $$final = match[1];
    return /* record */[
            /* it */CList$ReactTemplate.map(Proofview_monad$ReactTemplate.drop_state, $$final[/* comb */1]),
            /* sigma */$$final[/* solution */0]
          ];
  }
  catch (raw_src){
    var src = Js_exn.internalToOCamlException(raw_src);
    if (src[0] === Logic_monad$ReactTemplate.TacticFailure) {
      var match$1 = CErrors$ReactTemplate.push(src);
      return Util$ReactTemplate.iraise(/* tuple */[
                  src[1],
                  match$1[1]
                ]);
    } else {
      throw src;
    }
  }
}

var put_status = Proofview_monad$ReactTemplate.Status[/* put */0];

function wrap_exceptions(f) {
  try {
    return Curry._1(f, /* () */0);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (catchable_exception(e)) {
      var match = CErrors$ReactTemplate.push(e);
      return tclZERO(/* Some */[match[1]], match[0]);
    } else {
      throw e;
    }
  }
}

var V82 = /* module */[
  /* tactic */tactic,
  /* nf_evar_goals */nf_evar_goals,
  /* has_unresolved_evar */has_unresolved_evar,
  /* grab */grab,
  /* goals */goals$1,
  /* top_goals */top_goals,
  /* top_evars */top_evars,
  /* of_tactic */of_tactic,
  /* put_status */put_status,
  /* catchable_exception */catchable_exception,
  /* wrap_exceptions */wrap_exceptions
];

function $less$plus$great(t1, t2) {
  return Curry._2(tclOR, t1, (function () {
                return t2;
              }));
}

var Notations = /* module */[
  /* >>= */tclBIND,
  /* <*> */tclTHEN,
  /* <+> */$less$plus$great
];

var with_empty_state = Proofview_monad$ReactTemplate.with_empty_state;

var drop_state = Proofview_monad$ReactTemplate.drop_state;

var goal_with_state = Proofview_monad$ReactTemplate.goal_with_state;

var Monad_000 = Proofview_monad$ReactTemplate.Logical[0];

var Monad_001 = Proofview_monad$ReactTemplate.Logical[1];

var Monad_002 = Proofview_monad$ReactTemplate.Logical[2];

var Monad_003 = Proofview_monad$ReactTemplate.Logical[3];

var Monad_004 = Proofview_monad$ReactTemplate.Logical[4];

var Monad = [
  Monad_000,
  Monad_001,
  Monad_002,
  Monad_003,
  Monad_004
];

var Unsafe = [
  tclEVARS,
  tclEVARSADVANCE,
  tclSETENV,
  tclNEWGOALS,
  tclSETGOALS,
  tclGETGOALS,
  tclSETSHELF,
  tclGETSHELF,
  tclPUTSHELF,
  tclPUTGIVENUP,
  tclEVARUNIVCONTEXT,
  reset_future_goals,
  mark_as_goal,
  mark_as_unresolvable,
  Evarutil$ReactTemplate.advance,
  typeclass_resolvable
];

var $$let = Proofview_monad$ReactTemplate.Logical[/* Unsafe */21];

var UnsafeRepr_000 = $$let[1];

var UnsafeRepr_001 = $$let[0];

var UnsafeRepr = [
  UnsafeRepr_000,
  UnsafeRepr_001
];

var Goal = [
  assume,
  normalize,
  concl,
  hyps,
  env,
  sigma,
  extra,
  state,
  nf_enter,
  enter,
  enter_one,
  goals,
  unsolved,
  goal,
  print
];

var NonLogical = Logic_monad$ReactTemplate.NonLogical;

exports.proofview = proofview;
exports.compact = compact;
exports.init = init;
exports.dependent_init = dependent_init;
exports.finished = finished;
exports.$$return = $$return;
exports.partial_proof = partial_proof;
exports.initial_goals = initial_goals;
exports.with_empty_state = with_empty_state;
exports.drop_state = drop_state;
exports.goal_with_state = goal_with_state;
exports.focus_context = focus_context;
exports.focus = focus;
exports.unfocus = unfocus;
exports.apply = apply;
exports.tclUNIT = tclUNIT;
exports.tclBIND = tclBIND;
exports.tclTHEN = tclTHEN;
exports.tclIGNORE = tclIGNORE;
exports.Monad = Monad;
exports.tclZERO = tclZERO;
exports.tclOR = tclOR;
exports.tclORELSE = tclORELSE;
exports.tclIFCATCH = tclIFCATCH;
exports.tclONCE = tclONCE;
exports.MoreThanOneSuccess = MoreThanOneSuccess;
exports.tclEXACTLY_ONCE = tclEXACTLY_ONCE;
exports.tclCASE = tclCASE;
exports.tclBREAK = tclBREAK;
exports.NoSuchGoals = NoSuchGoals;
exports.set_nosuchgoals_hook = set_nosuchgoals_hook;
exports.tclFOCUS = tclFOCUS;
exports.tclFOCUSLIST = tclFOCUSLIST;
exports.tclFOCUSID = tclFOCUSID;
exports.tclTRYFOCUS = tclTRYFOCUS;
exports.SizeMismatch = SizeMismatch;
exports.tclDISPATCH = tclDISPATCH;
exports.tclDISPATCHL = tclDISPATCHL;
exports.tclEXTEND = tclEXTEND;
exports.tclINDEPENDENT = tclINDEPENDENT;
exports.tclINDEPENDENTL = tclINDEPENDENTL;
exports.shelve = shelve;
exports.shelve_goals = shelve_goals;
exports.unifiable = unifiable;
exports.shelve_unifiable = shelve_unifiable;
exports.guard_no_unifiable = guard_no_unifiable;
exports.unshelve = unshelve;
exports.depends_on = depends_on;
exports.with_shelf = with_shelf;
exports.cycle = cycle;
exports.swap = swap;
exports.revgoals = revgoals;
exports.numgoals = numgoals;
exports.tclEVARMAP = tclEVARMAP;
exports.tclENV = tclENV;
exports.tclEFFECTS = tclEFFECTS;
exports.mark_as_unsafe = mark_as_unsafe;
exports.give_up = give_up;
exports.tclPROGRESS = tclPROGRESS;
exports.tclCHECKINTERRUPT = tclCHECKINTERRUPT;
exports.Timeout = Timeout;
exports.tclTIMEOUT = tclTIMEOUT;
exports.tclTIME = tclTIME;
exports.Unsafe = Unsafe;
exports.UnsafeRepr = UnsafeRepr;
exports.Goal = Goal;
exports.Trace = Trace;
exports.NonLogical = NonLogical;
exports.tclLIFT = tclLIFT;
exports.V82 = V82;
exports.Notations = Notations;
/* typeclass_resolvable Not a pure module */
