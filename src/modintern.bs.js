// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Modops$ReactTemplate = require("./modops.bs.js");
var UState$ReactTemplate = require("./uState.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Univdecls$ReactTemplate = require("./univdecls.bs.js");
var Constrintern$ReactTemplate = require("./constrintern.bs.js");

var ModuleInternalizationError = Caml_exceptions.create("Modintern-ReactTemplate.ModuleInternalizationError");

function error_application_to_not_path(loc, me) {
  return Loc$ReactTemplate.raise(loc, [
              Modops$ReactTemplate.ModuleTypingError,
              /* ApplicationToNotPath */Block.__(2, [me])
            ]);
}

function error_incorrect_with_in_module(loc) {
  return Loc$ReactTemplate.raise(loc, [
              ModuleInternalizationError,
              /* IncorrectWithInModule */0
            ]);
}

function error_application_to_module_type(loc) {
  return Loc$ReactTemplate.raise(loc, [
              ModuleInternalizationError,
              /* IncorrectModuleApplication */1
            ]);
}

var lookup_module_or_modtype = Pervasives.failwith("undefined: lookup_module_or_modtype");

function transl_with_decl(env, param) {
  if (param.tag) {
    var fqid = param[0][/* v */0];
    var match = Univdecls$ReactTemplate.interp_univ_decl_opt(env, param[1]);
    var sigma = match[0];
    var match$1 = Constrintern$ReactTemplate.interp_constr(env, sigma, /* None */0, param[2]);
    var c = match$1[0];
    var match$2 = UState$ReactTemplate.check_univ_decl(Flags$ReactTemplate.is_universe_polymorphism(/* () */0), match$1[1], match[1]);
    if (match$2.tag) {
      var match$3 = Univ$ReactTemplate.abstract_universes(match$2[0]);
      var c$1 = EConstr$ReactTemplate.Vars[/* subst_univs_level_constr */16](Univ$ReactTemplate.make_instance_subst(match$3[0]), c);
      var c$2 = EConstr$ReactTemplate.to_constr(sigma, c$1);
      return /* tuple */[
              /* WithDef */Block.__(1, [
                  fqid,
                  /* tuple */[
                    c$2,
                    /* Some */[match$3[1]]
                  ]
                ]),
              Univ$ReactTemplate.ContextSet[/* empty */0]
            ];
    } else {
      var c$3 = EConstr$ReactTemplate.to_constr(sigma, c);
      return /* tuple */[
              /* WithDef */Block.__(1, [
                  fqid,
                  /* tuple */[
                    c$3,
                    /* None */0
                  ]
                ]),
              match$2[0]
            ];
    }
  } else {
    return /* tuple */[
            /* WithMod */Block.__(0, [
                param[0][/* v */0],
                Curry._2(lookup_module_or_modtype, /* Module */0, param[1])[0]
              ]),
            Univ$ReactTemplate.ContextSet[/* empty */0]
          ];
  }
}

function interp_module_ast(env, kind, m, cst) {
  var match = m[/* v */0];
  switch (match.tag | 0) {
    case 0 : 
        var match$1 = Curry._2(lookup_module_or_modtype, kind, CAst$ReactTemplate.make(m[/* loc */1], match[0]));
        return /* tuple */[
                /* MEident */Block.__(0, [match$1[0]]),
                match$1[1],
                cst
              ];
    case 1 : 
        var me2 = match[1];
        var match$2 = interp_module_ast(env, kind, match[0], cst);
        var match$3 = interp_module_ast(env, /* ModAny */2, me2, match$2[2]);
        var me2$prime = match$3[0];
        var mp2;
        switch (me2$prime.tag | 0) {
          case 0 : 
              mp2 = me2$prime[0];
              break;
          case 1 : 
          case 2 : 
              mp2 = error_application_to_not_path(me2[/* loc */1], me2$prime);
              break;
          
        }
        if (match$3[1] === /* ModType */1) {
          error_application_to_module_type(me2[/* loc */1]);
        }
        return /* tuple */[
                /* MEapply */Block.__(1, [
                    match$2[0],
                    mp2
                  ]),
                match$2[1],
                match$3[2]
              ];
    case 2 : 
        var match$4 = interp_module_ast(env, kind, match[0], cst);
        var kind$1 = match$4[1];
        if (!kind$1) {
          error_incorrect_with_in_module(m[/* loc */1]);
        }
        var match$5 = transl_with_decl(env, match[1]);
        var cst$1 = Univ$ReactTemplate.ContextSet[/* union */6](match$4[2], match$5[1]);
        return /* tuple */[
                /* MEwith */Block.__(2, [
                    match$4[0],
                    match$5[0]
                  ]),
                kind$1,
                cst$1
              ];
    
  }
}

function interp_module_ast$1(env, kind, m) {
  return interp_module_ast(env, kind, m, Univ$ReactTemplate.ContextSet[/* empty */0]);
}

exports.ModuleInternalizationError = ModuleInternalizationError;
exports.interp_module_ast = interp_module_ast$1;
/* lookup_module_or_modtype Not a pure module */
