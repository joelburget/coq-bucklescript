// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Buffer = require("bs-platform/lib/js/buffer.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var Loc$ReactTemplate = require("../src/loc.bs.js");
var CAst$ReactTemplate = require("../src/cAst.bs.js");
var Pcoq$ReactTemplate = require("../src/pcoq.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Bigint$ReactTemplate = require("../src/bigint.bs.js");
var CLexer$ReactTemplate = require("../src/cLexer.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Egramcoq$ReactTemplate = require("../parsing/egramcoq.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var Notation$ReactTemplate = require("../src/notation.bs.js");
var Ppvernac$ReactTemplate = require("../src/ppvernac.bs.js");
var CWarnings$ReactTemplate = require("../src/cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Libobject$ReactTemplate = require("../src/libobject.bs.js");
var Syntax_def$ReactTemplate = require("../src/syntax_def.bs.js");
var Constrintern$ReactTemplate = require("../src/constrintern.bs.js");
var Notation_ops$ReactTemplate = require("../src/notation_ops.bs.js");
var Constrexpr_ops$ReactTemplate = require("../src/constrexpr_ops.bs.js");

function cache_token(param) {
  return CLexer$ReactTemplate.add_keyword(param[1]);
}

var init = Libobject$ReactTemplate.default_object("TOKEN");

var inToken = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_token,
      /* load_function */init[/* load_function */2],
      /* open_function */(function (i, o) {
          if (i === 1) {
            return cache_token(o);
          } else {
            return 0;
          }
        }),
      /* classify_function */(function (o) {
          return /* Substitute */Block.__(0, [o]);
        }),
      /* subst_function */Libobject$ReactTemplate.ident_subst_function,
      /* discharge_function */init[/* discharge_function */6],
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

function add_token_obj(s) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inToken, s));
}

var entry_buf = Buffer.create(64);

function pr_entry(e) {
  Buffer.clear(entry_buf);
  var ft = Format.formatter_of_buffer(entry_buf);
  Pcoq$ReactTemplate.Gram[/* entry_print */11](ft, e);
  return Pp$ReactTemplate.str(Buffer.contents(entry_buf));
}

function pr_grammar(name) {
  var exit = 0;
  switch (name) {
    case "binder_constr" : 
    case "constr" : 
    case "operconstr" : 
        exit = 1;
        break;
    case "pattern" : 
        return pr_entry(Pcoq$ReactTemplate.Constr[/* pattern */10]);
    case "vernac" : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Entry vernac_control is"), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(Pcoq$ReactTemplate.Vernac_[/* vernac_control */4])), Pp$ReactTemplate.str("Entry command is")), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(Pcoq$ReactTemplate.Vernac_[/* command */2])), Pp$ReactTemplate.str("Entry syntax is")), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(Pcoq$ReactTemplate.Vernac_[/* syntax */3])), Pp$ReactTemplate.str("Entry gallina is")), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(Pcoq$ReactTemplate.Vernac_[/* gallina */0])), Pp$ReactTemplate.str("Entry gallina_ext is")), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(Pcoq$ReactTemplate.Vernac_[/* gallina_ext */1]));
    default:
      var name$1 = name;
      var gram;
      try {
        gram = /* Some */[Pcoq$ReactTemplate.find_grammars_by_name(name$1)];
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          gram = /* None */0;
        } else {
          throw exn;
        }
      }
      if (gram) {
        var pr_one = function (param) {
          var e = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Entry "), Pp$ReactTemplate.str(Curry._1(Pcoq$ReactTemplate.Gram[/* Entry */3][/* name */2], e))), Pp$ReactTemplate.str(" is")), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(e));
        };
        return Pp$ReactTemplate.prlist(pr_one, gram[0]);
      } else {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Unknown or unprintable grammar entry."));
      }
  }
  if (exit === 1) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Entry constr is"), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(Pcoq$ReactTemplate.Constr[/* constr */0])), Pp$ReactTemplate.str("and lconstr is")), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(Pcoq$ReactTemplate.Constr[/* lconstr */2])), Pp$ReactTemplate.str("where binder_constr is")), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(Pcoq$ReactTemplate.Constr[/* binder_constr */3])), Pp$ReactTemplate.str("and operconstr is")), Pp$ReactTemplate.fnl(/* () */0)), pr_entry(Pcoq$ReactTemplate.Constr[/* operconstr */4]));
  }
  
}

function parse_format(param) {
  var loc = param[/* loc */1];
  var str = param[/* v */0];
  var len = str.length;
  var make_loc = function (i, j) {
    var partial_arg = j - len | 0;
    var partial_arg$1 = i + 1 | 0;
    return Option$ReactTemplate.map((function (param) {
                  return Loc$ReactTemplate.shift_loc(partial_arg$1, partial_arg, param);
                }), loc);
  };
  var push_token = function (loc, a, param) {
    if (param) {
      var match = param[0];
      return /* :: */[
              /* tuple */[
                match[0],
                /* :: */[
                  /* tuple */[
                    loc,
                    a
                  ],
                  match[1]
                ]
              ],
              param[1]
            ];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "metasyntax.ml",
              100,
              12
            ]
          ];
    }
  };
  var push_white = function (i, n, l) {
    if (n) {
      return push_token(make_loc(i, i + n | 0), /* UnpTerminal */Block.__(4, [Curry._2(Util$ReactTemplate.$$String[/* make */0], n, /* " " */32)]), l);
    } else {
      return l;
    }
  };
  var close_quotation = function (start, i) {
    if (i < len && Caml_string.get(str, i) === /* "'" */39) {
      if ((i + 1 | 0) === len || Caml_string.get(str, i + 1 | 0) === /* " " */32) {
        return i + 1 | 0;
      } else {
        return CErrors$ReactTemplate.user_err(make_loc(i + 1 | 0, i + 1 | 0), /* None */0, Pp$ReactTemplate.str("Space expected after quoted expression."));
      }
    } else {
      return CErrors$ReactTemplate.user_err(make_loc(start, i - 1 | 0), /* None */0, Pp$ReactTemplate.str("Beginning of quoted expression expected to be ended by a quote."));
    }
  };
  var spaces = function (_n, _i) {
    while(true) {
      var i = _i;
      var n = _n;
      if (i < len && Caml_string.get(str, i) === /* " " */32) {
        _i = i + 1 | 0;
        _n = n + 1 | 0;
        continue ;
        
      } else {
        return n;
      }
    };
  };
  var nonspaces = function (quoted, _n, _i) {
    while(true) {
      var i = _i;
      var n = _n;
      if (i < len && Caml_string.get(str, i) !== /* " " */32) {
        if (Caml_string.get(str, i) === /* "'" */39 && quoted && ((i + 1 | 0) >= len || Caml_string.get(str, i + 1 | 0) === /* " " */32)) {
          if (n) {
            return n;
          } else {
            return CErrors$ReactTemplate.user_err(make_loc(i - 1 | 0, i), /* None */0, Pp$ReactTemplate.str("Empty quoted token."));
          }
        } else {
          _i = i + 1 | 0;
          _n = n + 1 | 0;
          continue ;
          
        }
      } else if (quoted) {
        return CErrors$ReactTemplate.user_err(make_loc(i, i), /* None */0, Pp$ReactTemplate.str("Spaces are not allowed in (quoted) symbols."));
      } else {
        return n;
      }
    };
  };
  var parse_non_format = function (i) {
    var n = nonspaces(/* false */0, 0, i);
    return push_token(make_loc(i, (i + n | 0) - 1 | 0), /* UnpTerminal */Block.__(4, [Curry._3(Util$ReactTemplate.$$String[/* sub */3], str, i, n)]), parse_token(1, i + n | 0));
  };
  var parse_box = function (start, box, i) {
    var n = spaces(0, i);
    var start$1 = start;
    var stop = (i + n | 0) - 1 | 0;
    var b = Curry._1(box, n);
    var param = parse_token(1, close_quotation(i, i + n | 0));
    if (param) {
      var l = param[1];
      if (l) {
        return push_token(make_loc(start$1, stop), /* UnpBox */Block.__(5, [
                      b,
                      param[0][1]
                    ]), l);
      } else {
        return CErrors$ReactTemplate.user_err(make_loc(start$1, stop), /* None */0, Pp$ReactTemplate.str("Non terminated box in format."));
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "metasyntax.ml",
              106,
              12
            ]
          ];
    }
  };
  var parse_token = function (k, i) {
    var n = spaces(0, i);
    var i$1 = i + n | 0;
    if (i$1 < len) {
      var match = Caml_string.get(str, i$1);
      if (match !== 39) {
        return push_white(i$1 - n | 0, n - k | 0, parse_non_format(i$1));
      } else if ((i$1 + 1 | 0) >= len || Caml_string.get(str, i$1 + 1 | 0) === /* " " */32) {
        return push_white(i$1 - n | 0, n - k | 0, push_token(make_loc(i$1, i$1 + 1 | 0), /* UnpTerminal */Block.__(4, ["'"]), parse_token(1, i$1 + 1 | 0)));
      } else {
        var n$1 = n - k | 0;
        var i$2 = i$1 + 1 | 0;
        if (i$2 < len) {
          var c = Caml_string.get(str, i$2);
          var exit = 0;
          if (c !== 47) {
            exit = 1;
          } else if ((i$2 + 1 | 0) < len && Caml_string.get(str, i$2 + 1 | 0) === /* "/" */47) {
            return push_token(make_loc(i$2 - n$1 | 0, i$2 + 1 | 0), /* UnpCut */Block.__(6, [/* PpFnl */0]), parse_token(1, close_quotation(i$2, i$2 + 2 | 0)));
          } else if ((i$2 + 1 | 0) < len) {
            var p = spaces(0, i$2 + 1 | 0);
            return push_token(make_loc(i$2 - n$1 | 0, i$2 + p | 0), /* UnpCut */Block.__(6, [/* PpBrk */[
                            n$1,
                            p
                          ]]), parse_token(1, close_quotation(i$2, (i$2 + p | 0) + 1 | 0)));
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var tmp;
            var exit$1 = 0;
            var switcher = c - 91 | 0;
            if (switcher > 2 || switcher < 0) {
              exit$1 = 2;
            } else {
              switch (switcher) {
                case 0 : 
                    if ((i$2 + 1 | 0) < len) {
                      var match$1 = Caml_string.get(str, i$2 + 1 | 0);
                      var exit$2 = 0;
                      if (match$1 >= 40) {
                        if (match$1 !== 104) {
                          if (match$1 !== 118) {
                            exit$2 = 3;
                          } else {
                            tmp = parse_box(i$2, (function (n) {
                                    return /* PpVB */Block.__(3, [n]);
                                  }), i$2 + 2 | 0);
                          }
                        } else if ((i$2 + 1 | 0) <= len && Caml_string.get(str, i$2 + 2 | 0) === /* "v" */118) {
                          tmp = parse_box(i$2, (function (n) {
                                  return /* PpHVB */Block.__(2, [n]);
                                }), i$2 + 3 | 0);
                        } else {
                          exit$2 = 3;
                        }
                      } else {
                        exit$2 = match$1 !== 32 && match$1 < 39 ? 3 : 4;
                      }
                      switch (exit$2) {
                        case 3 : 
                            tmp = CErrors$ReactTemplate.user_err(make_loc(i$2, i$2), /* None */0, Pp$ReactTemplate.str("\"v\", \"hv\", \" \" expected after \"[\" in format."));
                            break;
                        case 4 : 
                            tmp = parse_box(i$2, (function (n) {
                                    return /* PpHOVB */Block.__(1, [n]);
                                  }), i$2 + 1 | 0);
                            break;
                        
                      }
                    } else {
                      tmp = CErrors$ReactTemplate.user_err(make_loc(i$2, i$2), /* None */0, Pp$ReactTemplate.str("\"v\", \"hv\" or \" \" expected after \"[\" in format."));
                    }
                    break;
                case 1 : 
                    exit$1 = 2;
                    break;
                case 2 : 
                    tmp = /* :: */[
                      /* tuple */[
                        i$2,
                        /* [] */0
                      ],
                      parse_token(1, close_quotation(i$2, i$2 + 1 | 0))
                    ];
                    break;
                
              }
            }
            if (exit$1 === 2) {
              var n$2 = nonspaces(/* true */1, 0, i$2);
              tmp = push_token(make_loc(i$2, (i$2 + n$2 | 0) - 1 | 0), /* UnpTerminal */Block.__(4, [Curry._3(Util$ReactTemplate.$$String[/* sub */3], str, i$2 - 1 | 0, n$2 + 2 | 0)]), parse_token(1, close_quotation(i$2, i$2 + n$2 | 0)));
            }
            return push_white(i$2, n$1, tmp);
          }
          
        } else if (n$1) {
          return CErrors$ReactTemplate.user_err(make_loc(len - n$1 | 0, len), /* None */0, Pp$ReactTemplate.str("Ending spaces non part of a format annotation."));
        } else {
          return /* [] */0;
        }
      }
    } else {
      return push_white(i$1 - n | 0, n, /* :: */[
                  /* tuple */[
                    len,
                    /* [] */0
                  ],
                  /* [] */0
                ]);
    }
  };
  if (Curry._1(Util$ReactTemplate.$$String[/* is_empty */26], str)) {
    return /* [] */0;
  } else {
    var match = parse_token(0, 0);
    if (match) {
      var match$1 = match[0];
      var i = match$1[0];
      if (match[1]) {
        return CErrors$ReactTemplate.user_err(make_loc(i, i), /* None */0, Pp$ReactTemplate.str("Box closed without being opened."));
      } else {
        return match$1[1];
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "metasyntax.ml",
              190,
              12
            ]
          ];
    }
  }
}

function out_nt(param) {
  if (param.tag === 1) {
    return param[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "metasyntax.ml",
            199,
            48
          ]
        ];
  }
}

var msg_expected_form_of_recursive_notation = "In the notation, the special symbol \"..\" must occur in\na configuration of the form \"x symbs .. symbs y\".";

function find_pattern(nt, _xl, _param) {
  while(true) {
    var param = _param;
    var xl = _xl;
    var exit = 0;
    var s;
    var match = param[0];
    var exit$1 = 0;
    var exit$2 = 0;
    var exit$3 = 0;
    if (match) {
      var x = match[0];
      switch (x.tag | 0) {
        case 0 : 
            var match$1 = param[1];
            if (match$1) {
              var match$2 = match$1[0];
              switch (match$2.tag | 0) {
                case 0 : 
                    if (x[0] === match$2[0]) {
                      _param = /* tuple */[
                        match[1],
                        match$1[1]
                      ];
                      _xl = /* :: */[
                        x,
                        xl
                      ];
                      continue ;
                      
                    } else {
                      exit$3 = 5;
                    }
                    break;
                case 1 : 
                case 2 : 
                    exit$2 = 4;
                    break;
                case 3 : 
                    exit$3 = 5;
                    break;
                
              }
            } else {
              exit$2 = 4;
            }
            break;
        case 1 : 
        case 2 : 
            exit$3 = 5;
            break;
        case 3 : 
            var match$3 = param[1];
            if (match$3) {
              var match$4 = match$3[0];
              if (match$4.tag === 3) {
                if (x[0] === match$4[0]) {
                  _param = /* tuple */[
                    match[1],
                    match$3[1]
                  ];
                  _xl = /* :: */[
                    x,
                    xl
                  ];
                  continue ;
                  
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
            break;
        
      }
    } else {
      var match$5 = param[1];
      if (match$5) {
        var match$6 = match$5[0];
        switch (match$6.tag | 0) {
          case 1 : 
              return /* tuple */[
                      /* tuple */[
                        out_nt(nt),
                        match$6[0],
                        Curry._1(Util$ReactTemplate.List[/* rev */4], xl)
                      ],
                      match$5[1]
                    ];
          case 2 : 
              exit$1 = 3;
              break;
          case 0 : 
          case 3 : 
              exit$3 = 5;
              break;
          
        }
      } else {
        exit$1 = 3;
      }
    }
    if (exit$3 === 5) {
      var match$7 = param[1];
      if (match$7) {
        var match$8 = match$7[0];
        switch (match$8.tag | 0) {
          case 0 : 
              s = match$8[0];
              exit = 2;
              break;
          case 1 : 
          case 2 : 
              exit$2 = 4;
              break;
          case 3 : 
              exit = 1;
              break;
          
        }
      } else {
        exit$2 = 4;
      }
    }
    if (exit$2 === 4) {
      var match$9 = match[0];
      switch (match$9.tag | 0) {
        case 0 : 
            s = match$9[0];
            exit = 2;
            break;
        case 1 : 
        case 2 : 
            exit$1 = 3;
            break;
        
      }
    }
    if (exit$1 === 3) {
      var match$10 = param[1];
      if (match$10) {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Only Terminal or Break expected on left, non-SProdList on right."));
      } else {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(msg_expected_form_of_recursive_notation));
      }
    }
    switch (exit) {
      case 1 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("A break occurs on one side of \"..\" but not on the other side."));
      case 2 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Metasyntax.find_pattern"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The token \""), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str("\" occurs on one side of \"..\" but not on the other side.")));
      
    }
  };
}

function interp_list_parser(_hd, _param) {
  while(true) {
    var param = _param;
    var hd = _hd;
    if (param) {
      var s = param[0];
      var exit = 0;
      switch (s.tag | 0) {
        case 1 : 
            var tl = param[1];
            if (Names$ReactTemplate.Id[/* equal */0](s[0], Notation_ops$ReactTemplate.ldots_var)) {
              if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], hd)) {
                CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(msg_expected_form_of_recursive_notation));
              }
              var hd$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], hd);
              var match = find_pattern(Curry._1(Util$ReactTemplate.List[/* hd */1], hd$1), /* [] */0, /* tuple */[
                    Curry._1(Util$ReactTemplate.List[/* tl */2], hd$1),
                    tl
                  ]);
              var match$1 = match[0];
              var x = match$1[0];
              var match$2 = interp_list_parser(/* [] */0, match[1]);
              return /* tuple */[
                      /* :: */[
                        /* tuple */[
                          x,
                          match$1[1]
                        ],
                        match$2[0]
                      ],
                      /* :: */[
                        /* SProdList */Block.__(2, [
                            x,
                            match$1[2]
                          ]),
                        match$2[1]
                      ]
                    ];
            } else {
              var match$3 = interp_list_parser(/* :: */[
                    s,
                    /* [] */0
                  ], tl);
              return /* tuple */[
                      match$3[0],
                      Curry._2(Util$ReactTemplate.List[/* rev_append */6], hd, match$3[1])
                    ];
            }
            break;
        case 2 : 
            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unexpected SProdList in interp_list_parser."));
        case 0 : 
        case 3 : 
            exit = 1;
            break;
        
      }
      if (exit === 1) {
        var tl$1 = param[1];
        if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], hd)) {
          var match$4 = interp_list_parser(/* [] */0, tl$1);
          return /* tuple */[
                  match$4[0],
                  /* :: */[
                    s,
                    match$4[1]
                  ]
                ];
        } else {
          _param = tl$1;
          _hd = /* :: */[
            s,
            hd
          ];
          continue ;
          
        }
      }
      
    } else {
      return /* tuple */[
              /* [] */0,
              Curry._1(Util$ReactTemplate.List[/* rev */4], hd)
            ];
    }
  };
}

function quote_notation_token(x) {
  var n = x.length;
  var norm = CLexer$ReactTemplate.is_ident(x);
  if (n > 0 && norm || n > 2 && Caml_string.get(x, 0) === /* "'" */39) {
    return "'" + (x + "'");
  } else {
    return x;
  }
}

function is_numeral(symbs) {
  var match = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
          if (param.tag === 3) {
            return /* false */0;
          } else {
            return /* true */1;
          }
        }), symbs);
  var exit = 0;
  var x;
  if (match) {
    var match$1 = match[0];
    if (match$1.tag) {
      return /* false */0;
    } else {
      var x$1 = match$1[0];
      if (x$1 === "-") {
        var match$2 = match[1];
        if (match$2) {
          var match$3 = match$2[0];
          if (match$3.tag) {
            return /* false */0;
          } else if (match$2[1]) {
            return /* false */0;
          } else {
            x = match$3[0];
            exit = 1;
          }
        } else if (match[1]) {
          return /* false */0;
        } else {
          x = x$1;
          exit = 1;
        }
      } else if (match[1]) {
        return /* false */0;
      } else {
        x = x$1;
        exit = 1;
      }
    }
  } else {
    return /* false */0;
  }
  if (exit === 1) {
    try {
      Bigint$ReactTemplate.of_string(x);
      return /* true */1;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  }
  
}

function get_notation_vars(onlyprint, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      switch (match.tag | 0) {
        case 1 : 
            var id = match[0];
            var vars = get_notation_vars(onlyprint, param[1]);
            if (Names$ReactTemplate.Id[/* equal */0](id, Notation_ops$ReactTemplate.ldots_var)) {
              return vars;
            } else if (!onlyprint && Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], id, vars)) {
              return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Metasyntax.get_notation_vars"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Variable "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(" occurs more than once.")));
            } else {
              return /* :: */[
                      id,
                      vars
                    ];
            }
        case 2 : 
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "metasyntax.ml",
                    270,
                    24
                  ]
                ];
        case 0 : 
        case 3 : 
            _param = param[1];
            continue ;
            
      }
    } else {
      return /* [] */0;
    }
  };
}

function analyze_notation_tokens(onlyprint, ntn) {
  var l = Notation$ReactTemplate.decompose_raw_notation(ntn);
  var vars = get_notation_vars(onlyprint, l);
  var match = interp_list_parser(/* [] */0, l);
  var recvars = match[0];
  return /* tuple */[
          recvars,
          Curry._3(Util$ReactTemplate.List[/* subtract */53], Names$ReactTemplate.Id[/* equal */0], vars, Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                      return prim[1];
                    }), recvars)),
          match[1]
        ];
}

function prec_assoc(param) {
  switch (param) {
    case 0 : 
        return /* tuple */[
                /* L */0,
                /* L */0
              ];
    case 1 : 
        return /* tuple */[
                /* L */0,
                /* E */1
              ];
    case 2 : 
        return /* tuple */[
                /* E */1,
                /* L */0
              ];
    
  }
}

function precedence_of_position_and_level(from, param) {
  var match = param[0];
  if (match) {
    var match$1 = param[1];
    var n = match[0];
    if (match$1) {
      var match$2 = match$1[1];
      if (match$2) {
        var match$3 = prec_assoc(match$2[0]);
        return /* tuple */[
                n,
                match$1[0] ? match$3[1] : match$3[0]
              ];
      } else {
        return /* tuple */[
                n,
                /* Prec */[n]
              ];
      }
    } else {
      return /* tuple */[
              n,
              /* Prec */[n]
            ];
    }
  } else {
    return /* tuple */[
            from,
            /* L */0
          ];
  }
}

function precedence_of_entry_type(from, param) {
  if (typeof param === "number") {
    return /* tuple */[
            0,
            /* E */1
          ];
  } else {
    switch (param.tag | 0) {
      case 1 : 
          return precedence_of_position_and_level(from, param[0]);
      case 2 : 
          return precedence_of_position_and_level(from, param[1]);
      case 3 : 
          var n = param[1];
          var n$1 = n ? n[0] : 0;
          return /* tuple */[
                  n$1,
                  /* Prec */[n$1]
                ];
      default:
        return /* tuple */[
                0,
                /* E */1
              ];
    }
  }
}

function starts_with_left_bracket(s) {
  var l = s.length;
  if (l !== 0) {
    if (Caml_string.get(s, 0) === /* "{" */123 || Caml_string.get(s, 0) === /* "[" */91) {
      return /* true */1;
    } else {
      return +(Caml_string.get(s, 0) === /* "(" */40);
    }
  } else {
    return /* false */0;
  }
}

function ends_with_right_bracket(s) {
  var l = s.length;
  if (l !== 0) {
    if (Caml_string.get(s, l - 1 | 0) === /* "}" */125 || Caml_string.get(s, l - 1 | 0) === /* "]" */93) {
      return /* true */1;
    } else {
      return +(Caml_string.get(s, l - 1 | 0) === /* ")" */41);
    }
  } else {
    return /* false */0;
  }
}

function is_left_bracket(s) {
  if (starts_with_left_bracket(s)) {
    return 1 - ends_with_right_bracket(s);
  } else {
    return /* false */0;
  }
}

function is_right_bracket(s) {
  if (starts_with_left_bracket(s)) {
    return /* false */0;
  } else {
    return ends_with_right_bracket(s);
  }
}

function is_comma(s) {
  var l = s.length;
  if (l !== 0) {
    if (Caml_string.get(s, 0) === /* "," */44) {
      return /* true */1;
    } else {
      return +(Caml_string.get(s, 0) === /* ";" */59);
    }
  } else {
    return /* false */0;
  }
}

function is_operator(s) {
  var l = s.length;
  if (l !== 0) {
    if (Caml_string.get(s, 0) === /* "+" */43 || Caml_string.get(s, 0) === /* "*" */42 || Caml_string.get(s, 0) === /* "=" */61 || Caml_string.get(s, 0) === /* "-" */45 || Caml_string.get(s, 0) === /* "/" */47 || Caml_string.get(s, 0) === /* "<" */60 || Caml_string.get(s, 0) === /* ">" */62 || Caml_string.get(s, 0) === /* "@" */64 || Caml_string.get(s, 0) === /* "\\" */92 || Caml_string.get(s, 0) === /* "&" */38 || Caml_string.get(s, 0) === /* "~" */126) {
      return /* true */1;
    } else {
      return +(Caml_string.get(s, 0) === /* "$" */36);
    }
  } else {
    return /* false */0;
  }
}

function is_non_terminal(param) {
  switch (param.tag | 0) {
    case 1 : 
    case 2 : 
        return /* true */1;
    case 0 : 
    case 3 : 
        return /* false */0;
    
  }
}

function is_next_non_terminal(b, param) {
  if (param) {
    return is_non_terminal(param[0]);
  } else {
    return b;
  }
}

function is_next_terminal(param) {
  if (param && !param[0].tag) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_next_break(param) {
  if (param && param[0].tag === 3) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function add_break_if_none(n, b, l) {
  var exit = 0;
  if (l) {
    var match = l[0][1];
    if (match.tag === 6) {
      if (match[0]) {
        return l;
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else if (b) {
    exit = 1;
  } else {
    return /* [] */0;
  }
  if (exit === 1) {
    return /* :: */[
            /* tuple */[
              /* None */0,
              /* UnpCut */Block.__(6, [/* PpBrk */[
                    n,
                    0
                  ]])
            ],
            l
          ];
  }
  
}

function check_open_binder(isopen, sl, m) {
  var pr_token = function (param) {
    switch (param.tag | 0) {
      case 0 : 
          return Pp$ReactTemplate.str(param[0]);
      case 1 : 
      case 2 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "metasyntax.ml",
                  357,
                  9
                ]
              ];
      case 3 : 
          return Pp$ReactTemplate.str("\xe2\x90\xa3");
      
    }
  };
  if (isopen && !Curry._1(Util$ReactTemplate.List[/* is_empty */45], sl)) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("as "), Names$ReactTemplate.Id[/* print */8](m)), Pp$ReactTemplate.str(" is a non-closed binder, no such \"")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_token, sl)), Pp$ReactTemplate.strbrk("\" is allowed to occur.")));
  } else {
    return 0;
  }
}

function unparsing_metavar(i, from, typs) {
  var x = Curry._2(Util$ReactTemplate.List[/* nth */3], typs, i - 1 | 0);
  var prec = precedence_of_entry_type(from, x)[1];
  if (typeof x === "number") {
    if (x) {
      return /* UnpMetaVar */Block.__(0, [
                i,
                prec
              ]);
    } else {
      return /* UnpBinderMetaVar */Block.__(1, [
                i,
                /* Prec */[0]
              ]);
    }
  } else {
    switch (x.tag | 0) {
      case 0 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "metasyntax.ml",
                  376,
                  5
                ]
              ];
      case 3 : 
          return /* UnpBinderMetaVar */Block.__(1, [
                    i,
                    prec
                  ]);
      case 4 : 
          return Pervasives.failwith("TODO");
      default:
        return /* UnpMetaVar */Block.__(0, [
                  i,
                  prec
                ]);
    }
  }
}

function index_id(id, l) {
  return Curry._3(Util$ReactTemplate.List[/* index */77], Names$ReactTemplate.Id[/* equal */0], id, l);
}

function make_hunks(etyps, symbols, from) {
  var match = Curry._1(Util$ReactTemplate.List[/* split */36], etyps);
  var typs = match[1];
  var vars = match[0];
  var make = function (b, param) {
    if (param) {
      var match = param[0];
      switch (match.tag | 0) {
        case 0 : 
            var prods = param[1];
            var s = match[0];
            if (b || Curry._2(Util$ReactTemplate.List[/* exists */21], is_non_terminal, prods)) {
              if (is_comma(s) || is_operator(s)) {
                return /* :: */[
                        /* tuple */[
                          /* None */0,
                          /* UnpTerminal */Block.__(4, [s])
                        ],
                        add_break_if_none(1, b, make(b, prods))
                      ];
              } else if (is_right_bracket(s) && is_next_terminal(prods)) {
                return /* :: */[
                        /* tuple */[
                          /* None */0,
                          /* UnpTerminal */Block.__(4, [s])
                        ],
                        add_break_if_none(0, b, make(b, prods))
                      ];
              } else if (is_left_bracket(s) && is_next_non_terminal(b, prods)) {
                return /* :: */[
                        /* tuple */[
                          /* None */0,
                          /* UnpTerminal */Block.__(4, [s])
                        ],
                        make(b, prods)
                      ];
              } else if (is_next_break(prods)) {
                return /* :: */[
                        /* tuple */[
                          /* None */0,
                          /* UnpTerminal */Block.__(4, [s])
                        ],
                        make(b, prods)
                      ];
              } else {
                return /* :: */[
                        /* tuple */[
                          /* None */0,
                          /* UnpTerminal */Block.__(4, [s + " "])
                        ],
                        make(b, prods)
                      ];
              }
            } else {
              var exit = 0;
              if (prods) {
                if (prods[0].tag) {
                  exit = 1;
                } else {
                  return /* :: */[
                          /* tuple */[
                            /* None */0,
                            /* UnpTerminal */Block.__(4, [s + " "])
                          ],
                          make(b, prods)
                        ];
                }
              } else {
                exit = 1;
              }
              if (exit === 1) {
                return /* :: */[
                        /* tuple */[
                          /* None */0,
                          /* UnpTerminal */Block.__(4, [s])
                        ],
                        make(b, prods)
                      ];
              }
              
            }
            break;
        case 1 : 
            var prods$1 = param[1];
            var i = index_id(match[0], vars);
            var u = unparsing_metavar(i, from, typs);
            if (is_next_non_terminal(b, prods$1)) {
              return /* :: */[
                      /* tuple */[
                        /* None */0,
                        u
                      ],
                      add_break_if_none(1, b, make(b, prods$1))
                    ];
            } else {
              return /* :: */[
                      /* tuple */[
                        /* None */0,
                        u
                      ],
                      make_with_space(b, prods$1)
                    ];
            }
        case 2 : 
            var sl = match[1];
            var m = match[0];
            var i$1 = index_id(m, vars);
            var typ = Curry._2(Util$ReactTemplate.List[/* nth */3], typs, i$1 - 1 | 0);
            var match$1 = precedence_of_entry_type(from, typ);
            var sl$prime = Curry._1(Util$ReactTemplate.List[/* is_empty */45], sl) ? /* :: */[
                /* tuple */[
                  /* None */0,
                  /* UnpCut */Block.__(6, [/* PpBrk */[
                        1,
                        0
                      ]])
                ],
                /* [] */0
              ] : make(/* true */1, sl);
            var hunk;
            if (typeof typ === "number") {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "metasyntax.ml",
                      433,
                      10
                    ]
                  ];
            } else {
              switch (typ.tag | 0) {
                case 0 : 
                    var isopen = typ[0];
                    check_open_binder(isopen, sl, m);
                    hunk = /* UnpBinderListMetaVar */Block.__(3, [
                        i$1,
                        isopen,
                        Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                return prim[1];
                              }), sl$prime)
                      ]);
                    break;
                case 1 : 
                    hunk = /* UnpListMetaVar */Block.__(2, [
                        i$1,
                        match$1[1],
                        Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                return prim[1];
                              }), sl$prime)
                      ]);
                    break;
                default:
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "metasyntax.ml",
                          433,
                          10
                        ]
                      ];
              }
            }
            return /* :: */[
                    /* tuple */[
                      /* None */0,
                      hunk
                    ],
                    make_with_space(b, param[1])
                  ];
        case 3 : 
            var n = match[0];
            var l = make(b, param[1]);
            return /* :: */[
                    /* tuple */[
                      /* None */0,
                      /* UnpCut */Block.__(6, [/* PpBrk */[
                            n,
                            0
                          ]])
                    ],
                    l
                  ];
        
      }
    } else {
      return /* [] */0;
    }
  };
  var make_with_space = function (b, prods) {
    if (prods) {
      var match = prods[0];
      switch (match.tag | 0) {
        case 0 : 
            var s$prime = match[0];
            if (is_operator(s$prime)) {
              return /* :: */[
                      /* tuple */[
                        /* None */0,
                        /* UnpTerminal */Block.__(4, [" " + s$prime])
                      ],
                      add_break_if_none(1, b, make(b, prods[1]))
                    ];
            } else if (is_comma(s$prime) || is_right_bracket(s$prime)) {
              return make(b, prods);
            } else {
              return add_break_if_none(1, b, make(b, prods));
            }
        case 1 : 
        case 2 : 
            return add_break_if_none(1, b, make(b, prods));
        case 3 : 
            return make(b, prods);
        
      }
    } else {
      return /* [] */0;
    }
  };
  return make(/* false */0, symbols);
}

function error_format(loc, _) {
  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("The format does not match the notation."));
}

var warn_format_break = CWarnings$ReactTemplate.create("notation-both-format-and-spaces", "parsing", /* None */0, (function () {
        return Pp$ReactTemplate.strbrk("Discarding format implicitly indicated by multiple spaces in notation because an explicit format modifier is given.");
      }));

function split_format_at_ldots(_hd, _param) {
  while(true) {
    var param = _param;
    var hd = _hd;
    if (param) {
      var u = param[0];
      var match = u[1];
      var exit = 0;
      if (match.tag === 4) {
        if (match[0] === Names$ReactTemplate.Id[/* to_string */7](Notation_ops$ReactTemplate.ldots_var)) {
          return /* tuple */[
                  u[0],
                  Curry._1(Util$ReactTemplate.List[/* rev */4], hd),
                  param[1]
                ];
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        check_no_ldots_in_box(u);
        _param = param[1];
        _hd = /* :: */[
          u,
          hd
        ];
        continue ;
        
      }
      
    } else {
      throw Pervasives.Exit;
    }
  };
}

function check_no_ldots_in_box(param) {
  var match = param[1];
  if (match.tag === 5) {
    try {
      var match$1 = split_format_at_ldots(/* [] */0, match[1]);
      return CErrors$ReactTemplate.user_err(match$1[0], /* None */0, Pp$ReactTemplate.str("The special symbol \"..\" must occur at the same formatting depth than the variables of which it is the ellipse."));
    }
    catch (exn){
      if (exn === Pervasives.Exit) {
        return /* () */0;
      } else {
        throw exn;
      }
    }
  } else {
    return /* () */0;
  }
}

function error_not_same(loc, _) {
  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("The format is not the same on the right- and left-hand sides of the special token \"..\"."));
}

function skip_var_in_recursive_format(param) {
  if (param) {
    var match = param[0];
    var match$1 = match[1];
    if (match$1.tag === 4 && !Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (c) {
              return +(c === " ");
            }), Curry._1(Util$ReactTemplate.$$String[/* explode */27], match$1[0]))) {
      return param[1];
    } else {
      return error_not_same(match[0], /* () */0);
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "metasyntax.ml",
            495,
            10
          ]
        ];
  }
}

function read_recursive_format(_, fmt) {
  var get_head = function (fmt) {
    var sl = skip_var_in_recursive_format(fmt);
    try {
      return split_format_at_ldots(/* [] */0, sl);
    }
    catch (exn){
      if (exn === Pervasives.Exit) {
        return error_not_same(Curry._1(Util$ReactTemplate.List[/* last */105], sl ? sl : fmt)[0], /* () */0);
      } else {
        throw exn;
      }
    }
  };
  var get_tail = function (_param) {
    while(true) {
      var param = _param;
      var match = param[0];
      if (match) {
        var match$1 = param[1];
        var match$2 = match[0];
        var loc = match$2[0];
        if (match$1) {
          var b = match$1[0][1];
          if (Caml_obj.caml_equal(match$2[1], b)) {
            _param = /* tuple */[
              match[1],
              match$1[1]
            ];
            continue ;
            
          } else if (b.tag === 4) {
            return error_not_same(loc, /* () */0);
          } else {
            return error_not_same(param[1][0][0], /* () */0);
          }
        } else {
          return error_not_same(loc, /* () */0);
        }
      } else {
        return skip_var_in_recursive_format(param[1]);
      }
    };
  };
  var match = get_head(fmt);
  var slfmt = match[1];
  return /* tuple */[
          slfmt,
          get_tail(/* tuple */[
                slfmt,
                match[2]
              ])
        ];
}

function is_not_small_constr(param) {
  if (typeof param === "number") {
    return /* false */0;
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return /* true */1;
      case 2 : 
          if (param[0] === "constr" && param[1] === "binder_constr") {
            return /* true */1;
          } else {
            return /* false */0;
          }
          break;
      default:
        return /* false */0;
    }
  }
}

function define_keywords_aux(param) {
  if (param) {
    var n1 = param[0];
    var exit = 0;
    switch (n1.tag | 0) {
      case 1 : 
          if (n1[1]) {
            var match = param[1];
            if (match) {
              var match$1 = match[0];
              switch (match$1.tag | 0) {
                case 0 : 
                    var match$2 = match$1[0];
                    if (typeof match$2 === "number") {
                      exit = 1;
                    } else if (match$2.tag === 2) {
                      var k = match$2[0];
                      if (is_not_small_constr(n1[0])) {
                        Flags$ReactTemplate.if_verbose((function (eta) {
                                return Feedback$ReactTemplate.msg_info(/* None */0, eta);
                              }), Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Identifier '"), Pp$ReactTemplate.str(k)), Pp$ReactTemplate.str("' now a keyword")));
                        CLexer$ReactTemplate.add_keyword(k);
                        return /* :: */[
                                n1,
                                /* :: */[
                                  /* GramConstrTerminal */Block.__(0, [/* KEYWORD */Block.__(0, [k])]),
                                  define_keywords_aux(match[1])
                                ]
                              ];
                      } else {
                        exit = 1;
                      }
                    } else {
                      exit = 1;
                    }
                    break;
                case 1 : 
                case 2 : 
                    exit = 1;
                    break;
                
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          break;
      case 0 : 
      case 2 : 
          exit = 1;
          break;
      
    }
    if (exit === 1) {
      return /* :: */[
              n1,
              define_keywords_aux(param[1])
            ];
    }
    
  } else {
    return /* [] */0;
  }
}

function define_keywords(l) {
  if (l) {
    var match = l[0];
    switch (match.tag | 0) {
      case 0 : 
          var match$1 = match[0];
          if (typeof match$1 === "number") {
            return define_keywords_aux(l);
          } else if (match$1.tag === 2) {
            var k = match$1[0];
            Flags$ReactTemplate.if_verbose((function (eta) {
                    return Feedback$ReactTemplate.msg_info(/* None */0, eta);
                  }), Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Identifier '"), Pp$ReactTemplate.str(k)), Pp$ReactTemplate.str("' now a keyword")));
            CLexer$ReactTemplate.add_keyword(k);
            return /* :: */[
                    /* GramConstrTerminal */Block.__(0, [/* KEYWORD */Block.__(0, [k])]),
                    define_keywords_aux(l[1])
                  ];
          } else {
            return define_keywords_aux(l);
          }
          break;
      case 1 : 
      case 2 : 
          return define_keywords_aux(l);
      
    }
  } else {
    return define_keywords_aux(l);
  }
}

function distribute(a, ll) {
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (l) {
                return Util$ReactTemplate.$at(a, l);
              }), ll);
}

function is_constr_typ(typ, x, etyps) {
  var match = Curry._2(Util$ReactTemplate.List[/* assoc */30], x, etyps);
  if (typeof match === "number") {
    return /* false */0;
  } else {
    switch (match.tag | 0) {
      case 1 : 
          return Caml_obj.caml_equal(typ, match[0]);
      case 2 : 
          return Caml_obj.caml_equal(typ, match[1]);
      default:
        return /* false */0;
    }
  }
}

function include_possible_similar_trailing_pattern(typ, etyps, sl, l) {
  var try_aux = function (n, l) {
    try {
      var n$1 = n + 1 | 0;
      var _param = /* tuple */[
        sl,
        l
      ];
      while(true) {
        var param = _param;
        var match = param[0];
        if (match) {
          var match$1 = match[0];
          if (match$1.tag) {
            throw Pervasives.Exit;
          } else {
            var match$2 = param[1];
            if (match$2) {
              var match$3 = match$2[0];
              if (match$3.tag) {
                throw Pervasives.Exit;
              } else if (match$1[0] === match$3[0]) {
                _param = /* tuple */[
                  match[1],
                  match$2[1]
                ];
                continue ;
                
              } else {
                throw Pervasives.Exit;
              }
            } else {
              throw Pervasives.Exit;
            }
          }
        } else {
          var match$4 = param[1];
          if (match$4) {
            var match$5 = match$4[0];
            if (match$5.tag === 1) {
              if (is_constr_typ(typ, match$5[0], etyps)) {
                return try_aux(n$1, match$4[1]);
              } else {
                throw Pervasives.Exit;
              }
            } else {
              throw Pervasives.Exit;
            }
          } else {
            throw Pervasives.Exit;
          }
        }
      };
    }
    catch (exn){
      if (exn === Pervasives.Exit) {
        return /* tuple */[
                n,
                l
              ];
      } else {
        throw exn;
      }
    }
  };
  return try_aux(0, l);
}

function prod_entry_type(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return /* ETProdName */0;
      case 1 : 
          return /* ETProdReference */1;
      case 2 : 
          return /* ETProdBigint */2;
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "metasyntax.ml",
                  621,
                  18
                ]
              ];
      case 1 : 
          return /* ETProdConstr */Block.__(0, [param[0]]);
      case 2 : 
          return /* ETProdConstr */Block.__(0, [param[1]]);
      case 3 : 
          var n = param[1];
          return /* ETProdPattern */Block.__(1, [n ? n[0] : 0]);
      case 4 : 
          return /* ETProdOther */Block.__(2, [
                    param[0],
                    param[1]
                  ]);
      
    }
  }
}

function make_production(etyps, symbols) {
  var aux = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0];
        switch (match.tag | 0) {
          case 0 : 
              return distribute(/* :: */[
                          /* GramConstrTerminal */Block.__(0, [CLexer$ReactTemplate.terminal(match[0])]),
                          /* [] */0
                        ], aux(param[1]));
          case 1 : 
              var m = match[0];
              var typ = Curry._2(Util$ReactTemplate.List[/* assoc */30], m, etyps);
              return distribute(/* :: */[
                          /* GramConstrNonTerminal */Block.__(1, [
                              prod_entry_type(typ),
                              /* Some */[m]
                            ]),
                          /* [] */0
                        ], aux(param[1]));
          case 2 : 
              var l = param[1];
              var sl = match[1];
              var x = match[0];
              var tkl = Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                          switch (param.tag | 0) {
                            case 0 : 
                                return /* :: */[
                                        CLexer$ReactTemplate.terminal(param[0]),
                                        /* [] */0
                                      ];
                            case 1 : 
                            case 2 : 
                                return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Found a non terminal token in recursive notation separator."));
                            case 3 : 
                                return /* [] */0;
                            
                          }
                        }), sl));
              var match$1 = Curry._2(Util$ReactTemplate.List[/* assoc */30], x, etyps);
              if (typeof match$1 === "number") {
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Components of recursive patterns in notation must be terms or binders."));
              } else {
                switch (match$1.tag | 0) {
                  case 0 : 
                      var o = match$1[0];
                      check_open_binder(o, sl, x);
                      var typ$1;
                      if (o) {
                        if (tkl !== /* [] */0) {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                [
                                  "metasyntax.ml",
                                  647,
                                  33
                                ]
                              ];
                        }
                        typ$1 = /* ETBinderOpen */0;
                      } else {
                        typ$1 = /* ETBinderClosed */[tkl];
                      }
                      return distribute(/* :: */[
                                  /* GramConstrNonTerminal */Block.__(1, [
                                      /* ETProdBinderList */Block.__(4, [typ$1]),
                                      /* Some */[x]
                                    ]),
                                  /* [] */0
                                ], aux(l));
                  case 1 : 
                      var typ$2 = match$1[0];
                      var match$2 = include_possible_similar_trailing_pattern(typ$2, etyps, sl, l);
                      var typ$3 = typ$2;
                      var tkl$1 = tkl;
                      var x$1 = x;
                      var n = 1;
                      var p = match$2[0];
                      var ll = aux(match$2[1]);
                      var camlp5_message_name = /* Some */[Nameops$ReactTemplate.add_suffix(x$1, "_" + Pervasives.string_of_int(n))];
                      var main_000 = /* ETProdConstr */Block.__(0, [typ$3]);
                      var main = /* GramConstrNonTerminal */Block.__(1, [
                          main_000,
                          camlp5_message_name
                        ]);
                      var tks = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                              return /* GramConstrTerminal */Block.__(0, [x]);
                            }), tkl$1);
                      var aux$1 = (function(typ$3,tkl$1,x$1,n,p,main,tks){
                      return function aux$1(_i, _hds, ll) {
                        while(true) {
                          var hds = _hds;
                          var i = _i;
                          if (i < p) {
                            _hds = Util$ReactTemplate.$at(/* :: */[
                                  main,
                                  tks
                                ], hds);
                            _i = i + 1 | 0;
                            continue ;
                            
                          } else if (i === (p + n | 0)) {
                            var hds$1 = Util$ReactTemplate.$at(/* :: */[
                                  /* GramConstrListMark */Block.__(2, [
                                      p + n | 0,
                                      /* true */1,
                                      p
                                    ]),
                                  hds
                                ], /* :: */[
                                  /* GramConstrNonTerminal */Block.__(1, [
                                      /* ETProdConstrList */Block.__(3, [
                                          typ$3,
                                          tkl$1
                                        ]),
                                      /* Some */[x$1]
                                    ]),
                                  /* [] */0
                                ]);
                            return distribute(hds$1, ll);
                          } else {
                            return Util$ReactTemplate.$at(distribute(Util$ReactTemplate.$at(/* :: */[
                                                /* GramConstrListMark */Block.__(2, [
                                                    i + 1 | 0,
                                                    /* false */0,
                                                    p
                                                  ]),
                                                hds
                                              ], /* :: */[
                                                main,
                                                /* [] */0
                                              ]), ll), aux$1(i + 1 | 0, Util$ReactTemplate.$at(/* :: */[
                                                main,
                                                tks
                                              ], hds), ll));
                          }
                        };
                      }
                      }(typ$3,tkl$1,x$1,n,p,main,tks));
                      return aux$1(0, /* [] */0, ll);
                  default:
                    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Components of recursive patterns in notation must be terms or binders."));
                }
              }
              break;
          case 3 : 
              _param = param[1];
              continue ;
              
        }
      } else {
        return /* :: */[
                /* [] */0,
                /* [] */0
              ];
      }
    };
  };
  var prods = aux(symbols);
  return Curry._2(Util$ReactTemplate.List[/* map */10], define_keywords, prods);
}

function find_symbols(_c_current, c_next, c_last, _param) {
  while(true) {
    var param = _param;
    var c_current = _c_current;
    if (param) {
      var match = param[0];
      switch (match.tag | 0) {
        case 0 : 
            _param = param[1];
            _c_current = c_next;
            continue ;
            case 1 : 
            var sl = param[1];
            var prec = Curry._1(Util$ReactTemplate.List[/* is_empty */45], sl) ? c_last : c_current;
            return /* :: */[
                    /* tuple */[
                      match[0],
                      prec
                    ],
                    find_symbols(c_next, c_next, c_last, sl)
                  ];
        case 2 : 
            return /* :: */[
                    /* tuple */[
                      match[0],
                      c_next
                    ],
                    find_symbols(c_next, c_next, c_last, param[1])
                  ];
        case 3 : 
            _param = param[1];
            continue ;
            
      }
    } else {
      return /* [] */0;
    }
  };
}

function border(param) {
  if (param) {
    var match = param[0][1];
    if (typeof match === "number") {
      return /* None */0;
    } else {
      switch (match.tag | 0) {
        case 1 : 
            var match$1 = match[0][1];
            if (match$1) {
              return match$1[1];
            } else {
              return /* None */0;
            }
        case 2 : 
            var match$2 = match[1][1];
            if (match$2) {
              return match$2[1];
            } else {
              return /* None */0;
            }
        default:
          return /* None */0;
      }
    }
  } else {
    return /* None */0;
  }
}

function recompute_assoc(typs) {
  var match = border(typs);
  var match$1 = border(Curry._1(Util$ReactTemplate.List[/* rev */4], typs));
  var exit = 0;
  if (match) {
    if (match[0] >= 2) {
      if (match$1) {
        if (match$1[0] !== 1) {
          return /* Some */[/* LeftA */2];
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "metasyntax.ml",
                  672,
                  33
                ]
              ];
        }
      } else {
        return /* Some */[/* LeftA */2];
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (match$1 && match$1[0] === 1) {
      return /* Some */[/* RightA */1];
    } else {
      return /* None */0;
    }
  }
  
}

function pr_level(_, param) {
  var from = param[0];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("at level "), Pp$ReactTemplate.$$int(from)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("with arguments")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, (function (param) {
                    var from$1 = from;
                    var param$1 = param;
                    var typ = param$1[1];
                    var pplev = function (param) {
                      var match = param[1];
                      var n = param[0];
                      if (typeof match === "number") {
                        switch (match) {
                          case 0 : 
                              if (n === from$1) {
                                return Pp$ReactTemplate.str("at next level");
                              } else {
                                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("at level below "), Pp$ReactTemplate.$$int(n));
                              }
                          case 1 : 
                              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("at level "), Pp$ReactTemplate.$$int(n));
                          case 2 : 
                              return Pp$ReactTemplate.str("Unknown level");
                          
                        }
                      } else if (match[0] === n) {
                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("at level "), Pp$ReactTemplate.$$int(n));
                      } else {
                        return Pp$ReactTemplate.str("Unknown level");
                      }
                    };
                    var tmp;
                    var exit = 0;
                    if (typeof typ === "number") {
                      tmp = Pp$ReactTemplate.mt(/* () */0);
                    } else {
                      switch (typ.tag | 0) {
                        case 1 : 
                        case 2 : 
                        case 3 : 
                            exit = 1;
                            break;
                        default:
                          tmp = Pp$ReactTemplate.mt(/* () */0);
                      }
                    }
                    if (exit === 1) {
                      tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), pplev(param$1[0]));
                    }
                    return Pp$ReactTemplate.$plus$plus(Ppvernac$ReactTemplate.pr_set_entry_type((function () {
                                      return Pp$ReactTemplate.mt(/* () */0);
                                    }), typ), tmp);
                  }), Curry._2(Util$ReactTemplate.List[/* combine */37], param[1], param[2])));
}

function is_active_compat(param) {
  if (param) {
    return +(0 <= Flags$ReactTemplate.version_compare(param[0], Flags$ReactTemplate.compat_version[0]));
  } else {
    return /* true */1;
  }
}

function cache_syntax_extension(param) {
  var se = param[1][1];
  var ntn = se[/* synext_notation */1];
  var prec = se[/* synext_level */0];
  var onlyprint = se[/* synext_notgram */2][/* notgram_onlyprinting */0];
  try {
    var oldprec = Notation$ReactTemplate.level_of_notation(ntn);
    if (Notation$ReactTemplate.level_eq(prec, oldprec)) {
      return 0;
    } else {
      var ntn$1 = ntn;
      var oldprec$1 = oldprec;
      var prec$1 = prec;
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation "), Pp$ReactTemplate.qstring(ntn$1)), Pp$ReactTemplate.str(" is already defined")), Pp$ReactTemplate.spc(/* () */0)), pr_level(ntn$1, oldprec$1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("while it is now required to be")), Pp$ReactTemplate.spc(/* () */0)), pr_level(ntn$1, prec$1)), Pp$ReactTemplate.str(".")));
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (is_active_compat(se[/* synext_compat */5])) {
        Notation$ReactTemplate.declare_notation_level(ntn, prec);
        if (!onlyprint) {
          Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                  var ntn$2 = ntn;
                  var rule = param;
                  try {
                    var ntn_for_grammar = rule[/* notgram_notation */2];
                    if (ntn$2 === ntn_for_grammar) {
                      throw Caml_builtin_exceptions.not_found;
                    }
                    var prec = rule[/* notgram_level */0];
                    var oldprec = Notation$ReactTemplate.level_of_notation(ntn_for_grammar);
                    if (Notation$ReactTemplate.level_eq(prec, oldprec)) {
                      return 0;
                    } else {
                      var ntn$3 = ntn$2;
                      var ntn$prime = ntn_for_grammar;
                      var oldprec$1 = oldprec;
                      var prec$1 = prec;
                      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation "), Pp$ReactTemplate.qstring(ntn$3)), Pp$ReactTemplate.str(" relies on a parsing rule for ")), Pp$ReactTemplate.qstring(ntn$prime)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(" which is already defined")), Pp$ReactTemplate.spc(/* () */0)), pr_level(ntn$3, oldprec$1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("while it is now required to be")), Pp$ReactTemplate.spc(/* () */0)), pr_level(ntn$3, prec$1)), Pp$ReactTemplate.str(".")));
                    }
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      return Egramcoq$ReactTemplate.extend_constr_grammar(rule);
                    } else {
                      throw exn;
                    }
                  }
                }), se[/* synext_notgram */2][/* notgram_rules */1]);
        }
        return Notation$ReactTemplate.declare_notation_rule(ntn, se[/* synext_extra */4], /* tuple */[
                    se[/* synext_unparsing */3],
                    Util$ReactTemplate.pi1(prec)
                  ], se[/* synext_notgram */2]);
      } else {
        return 0;
      }
    } else {
      throw exn;
    }
  }
}

function subst_syntax_extension(param) {
  var match = param[1];
  var sy = match[1];
  var init = sy[/* synext_notgram */2];
  return /* tuple */[
          match[0],
          /* record */[
            /* synext_level */sy[/* synext_level */0],
            /* synext_notation */sy[/* synext_notation */1],
            /* synext_notgram : record */[
              /* notgram_onlyprinting */init[/* notgram_onlyprinting */0],
              /* notgram_rules */Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                      return param;
                    }), sy[/* synext_notgram */2][/* notgram_rules */1])
            ],
            /* synext_unparsing */sy[/* synext_unparsing */3],
            /* synext_extra */sy[/* synext_extra */4],
            /* synext_compat */sy[/* synext_compat */5]
          ]
        ];
}

function classify_syntax_definition(o) {
  if (o[0]) {
    return /* Dispose */0;
  } else {
    return /* Substitute */Block.__(0, [o]);
  }
}

var init$1 = Libobject$ReactTemplate.default_object("SYNTAX-EXTENSION");

var inSyntaxExtension = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$1[/* object_name */0],
      /* cache_function */cache_syntax_extension,
      /* load_function */init$1[/* load_function */2],
      /* open_function */(function (i, o) {
          if (i === 1) {
            return cache_syntax_extension(o);
          } else {
            return 0;
          }
        }),
      /* classify_function */classify_syntax_definition,
      /* subst_function */subst_syntax_extension,
      /* discharge_function */init$1[/* discharge_function */6],
      /* rebuild_function */init$1[/* rebuild_function */7]
    ]);

function interp_modifiers(modl) {
  var _acc = /* record */[
    /* assoc : None */0,
    /* level : None */0,
    /* etyps : [] */0,
    /* only_parsing : false */0,
    /* only_printing : false */0,
    /* compat : None */0,
    /* format : None */0,
    /* extra : [] */0
  ];
  var _param = modl;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var match = param[0];
      if (typeof match === "number") {
        if (match) {
          var newrecord = acc.slice();
          _param = param[1];
          newrecord[/* only_printing */4] = /* true */1;
          _acc = newrecord;
          continue ;
          
        } else {
          var newrecord$1 = acc.slice();
          _param = param[1];
          newrecord$1[/* only_parsing */3] = /* true */1;
          _acc = newrecord$1;
          continue ;
          
        }
      } else {
        switch (match.tag | 0) {
          case 0 : 
              var match$1 = match[0];
              if (match$1) {
                var n = match[1];
                var s = match$1[0];
                var id = Names$ReactTemplate.Id[/* of_string */5](s);
                if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc */3], id, acc[/* etyps */2])) {
                  CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Metasyntax.interp_modifiers"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(s), Pp$ReactTemplate.str(" is already assigned to an entry or constr level.")));
                }
                var typ = /* ETConstr */Block.__(1, [/* Some */[n]]);
                var newrecord$2 = acc.slice();
                _param = /* :: */[
                  /* SetItemLevel */Block.__(0, [
                      match$1[1],
                      n
                    ]),
                  param[1]
                ];
                newrecord$2[/* etyps */2] = /* :: */[
                  /* tuple */[
                    id,
                    typ
                  ],
                  acc[/* etyps */2]
                ];
                _acc = newrecord$2;
                continue ;
                
              } else {
                _param = param[1];
                continue ;
                
              }
              break;
          case 1 : 
              var match$2 = match[0];
              if (match$2) {
                var n$1 = match[2];
                var bk = match[1];
                var s$1 = match$2[0];
                var id$1 = Names$ReactTemplate.Id[/* of_string */5](s$1);
                if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc */3], id$1, acc[/* etyps */2])) {
                  CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Metasyntax.interp_modifiers"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(s$1), Pp$ReactTemplate.str(" is already assigned to an entry or constr level.")));
                }
                var typ$1 = /* ETConstrAsBinder */Block.__(2, [
                    bk,
                    n$1
                  ]);
                var newrecord$3 = acc.slice();
                _param = /* :: */[
                  /* SetItemLevelAsBinder */Block.__(1, [
                      match$2[1],
                      bk,
                      n$1
                    ]),
                  param[1]
                ];
                newrecord$3[/* etyps */2] = /* :: */[
                  /* tuple */[
                    id$1,
                    typ$1
                  ],
                  acc[/* etyps */2]
                ];
                _acc = newrecord$3;
                continue ;
                
              } else {
                _param = param[1];
                continue ;
                
              }
              break;
          case 2 : 
              var newrecord$4 = acc.slice();
              _param = param[1];
              newrecord$4[/* level */1] = /* Some */[match[0]];
              _acc = newrecord$4;
              continue ;
              case 3 : 
              if (!Option$ReactTemplate.is_empty(acc[/* assoc */0])) {
                CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("An associativity is given more than once."));
              }
              var newrecord$5 = acc.slice();
              _param = param[1];
              newrecord$5[/* assoc */0] = /* Some */[match[0]];
              _acc = newrecord$5;
              continue ;
              case 4 : 
              var s$2 = match[0];
              var id$2 = Names$ReactTemplate.Id[/* of_string */5](s$2);
              if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc */3], id$2, acc[/* etyps */2])) {
                CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Metasyntax.interp_modifiers"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(s$2), Pp$ReactTemplate.str(" is already assigned to an entry or constr level.")));
              }
              var newrecord$6 = acc.slice();
              _param = param[1];
              newrecord$6[/* etyps */2] = /* :: */[
                /* tuple */[
                  id$2,
                  match[1]
                ],
                acc[/* etyps */2]
              ];
              _acc = newrecord$6;
              continue ;
              case 5 : 
              var newrecord$7 = acc.slice();
              _param = param[1];
              newrecord$7[/* compat */5] = /* Some */[match[0]];
              _acc = newrecord$7;
              continue ;
              case 6 : 
              var k = match[0];
              if (k === "text") {
                if (!Option$ReactTemplate.is_empty(acc[/* format */6])) {
                  CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("A format is given more than once."));
                }
                var newrecord$8 = acc.slice();
                _param = param[1];
                newrecord$8[/* format */6] = /* Some */[match[1]];
                _acc = newrecord$8;
                continue ;
                
              } else {
                var newrecord$9 = acc.slice();
                _param = param[1];
                newrecord$9[/* extra */7] = /* :: */[
                  /* tuple */[
                    k,
                    match[1][/* v */0]
                  ],
                  acc[/* extra */7]
                ];
                _acc = newrecord$9;
                continue ;
                
              }
              break;
          
        }
      }
    } else {
      return acc;
    }
  };
}

function check_infix_modifiers(modifiers) {
  var t = interp_modifiers(modifiers)[/* etyps */2];
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], t)) {
    return 0;
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Explicit entry level or type unexpected in infix notation."));
  }
}

function check_useless_entry_types(recvars, mainvars, etyps) {
  var match = Curry._1(Util$ReactTemplate.List[/* split */36], recvars);
  var vars = Util$ReactTemplate.$at(match[0], Util$ReactTemplate.$at(match[1], mainvars));
  var match$1 = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
          return 1 - Curry._2(Util$ReactTemplate.List[/* mem */24], param[0], vars);
        }), etyps);
  if (match$1) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Metasyntax.check_useless_entry_types"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](match$1[0][0]), Pp$ReactTemplate.str(" is unbound in the notation.")));
  } else {
    return /* () */0;
  }
}

function check_binder_type(recvars, etyps) {
  var match = Curry._1(Util$ReactTemplate.List[/* split */36], recvars);
  var l = Util$ReactTemplate.$at(match[0], match[1]);
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                var match = param[1];
                if (typeof match === "number" || !(!match.tag && !Curry._2(Util$ReactTemplate.List[/* mem */24], param[0], l))) {
                  return /* () */0;
                } else {
                  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(match[0] ? "binder" : "closed binder"), Pp$ReactTemplate.strbrk(" is only for use in recursive notations for binders.")));
                }
              }), etyps);
}

function not_a_syntax_modifier(param) {
  if (typeof param === "number" || param.tag === 5) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_only_parsing(mods) {
  var test = function (param) {
    if (typeof param === "number" && param === 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* exists */21], test, mods);
}

function is_only_printing(mods) {
  var test = function (param) {
    if (typeof param === "number" && param !== 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* exists */21], test, mods);
}

function get_compat_version(mods) {
  var test = function (param) {
    if (typeof param === "number" || param.tag !== 5) {
      return /* None */0;
    } else {
      return /* Some */[param[0]];
    }
  };
  try {
    return /* Some */[Curry._2(Util$ReactTemplate.List[/* find_map */94], test, mods)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function join_auxiliary_recursive_types(recvars, etyps) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, typs) {
                var y = param[1];
                var x = param[0];
                var xtyp;
                try {
                  xtyp = /* Some */[Curry._2(Util$ReactTemplate.List[/* assoc */30], x, etyps)];
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    xtyp = /* None */0;
                  } else {
                    throw exn;
                  }
                }
                var ytyp;
                try {
                  ytyp = /* Some */[Curry._2(Util$ReactTemplate.List[/* assoc */30], y, etyps)];
                }
                catch (exn$1){
                  if (exn$1 === Caml_builtin_exceptions.not_found) {
                    ytyp = /* None */0;
                  } else {
                    throw exn$1;
                  }
                }
                if (xtyp) {
                  if (ytyp && !Caml_obj.caml_equal(xtyp[0], ytyp[0])) {
                    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("In "), Names$ReactTemplate.Id[/* print */8](x)), Pp$ReactTemplate.str(" .. ")), Names$ReactTemplate.Id[/* print */8](y)), Pp$ReactTemplate.strbrk(", both ends have incompatible types.")));
                  } else {
                    return typs;
                  }
                } else if (ytyp) {
                  return /* :: */[
                          /* tuple */[
                            x,
                            ytyp[0]
                          ],
                          typs
                        ];
                } else {
                  return typs;
                }
              }), recvars, etyps);
}

function internalization_type_of_entry_type(param) {
  if (typeof param === "number" || param.tag) {
    return /* NtnInternTypeAny */0;
  } else {
    return /* NtnInternTypeOnlyBinder */1;
  }
}

function set_internalization_type(typs) {
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                return internalization_type_of_entry_type(param[1]);
              }), typs);
}

function make_internalization_vars(recvars, mainvars, typs) {
  var maintyps = Curry._2(Util$ReactTemplate.List[/* combine */37], mainvars, typs);
  var extratyps = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[1],
                  Curry._2(Util$ReactTemplate.List[/* assoc */30], param[0], maintyps)
                ];
        }), recvars);
  return Util$ReactTemplate.$at(maintyps, extratyps);
}

function make_interpretation_type(isrec, isonlybinding, param) {
  if (typeof param === "number") {
    if (param) {
      return /* NtnTypeConstr */0;
    } else {
      return /* NtnTypeBinder */[/* NtnParsedAsIdent */0];
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          if (isrec) {
            return /* NtnTypeBinderList */2;
          } else {
            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Type binder is only for use in recursive notations for binders."));
          }
      case 1 : 
          if (isrec) {
            return /* NtnTypeConstrList */1;
          } else if (isonlybinding) {
            return /* NtnTypeBinder */[/* NtnBinderParsedAsConstr */Block.__(1, [/* AsIdent */0])];
          } else {
            return /* NtnTypeConstr */0;
          }
      case 2 : 
          return /* NtnTypeBinder */[/* NtnBinderParsedAsConstr */Block.__(1, [param[0]])];
      case 3 : 
          return /* NtnTypeBinder */[/* NtnParsedAsPattern */Block.__(0, [param[0]])];
      default:
        return /* NtnTypeConstr */0;
    }
  }
}

function make_interpretation_vars(recvars, allvars, typs) {
  var eq_subscope = function (param, param$1) {
    if (Option$ReactTemplate.equal((function (prim, prim$1) {
              return +(prim === prim$1);
            }), param[0], param$1[0])) {
      return Curry._3(Util$ReactTemplate.List[/* equal */44], (function (prim, prim$1) {
                    return +(prim === prim$1);
                  }), param[1], param$1[1]);
    } else {
      return /* false */0;
    }
  };
  var check = function (param) {
    var y = param[1];
    var x = param[0];
    var match = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x, allvars);
    var match$1 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], y, allvars);
    if (eq_subscope(match[1], match$1[1])) {
      return 0;
    } else {
      var x$1 = x;
      var y$1 = y;
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Metasyntax.error_not_name_scope"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Variables "), Names$ReactTemplate.Id[/* print */8](x$1)), Pp$ReactTemplate.str(" and ")), Names$ReactTemplate.Id[/* print */8](y$1)), Pp$ReactTemplate.str(" must be in the same scope.")));
    }
  };
  Curry._2(Util$ReactTemplate.List[/* iter */9], check, recvars);
  var useless_recvars = Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
          return prim[1];
        }), recvars);
  var mainvars = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* filter */13], (function (x, _) {
          return 1 - Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], x, useless_recvars);
        }), allvars);
  return Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mapi */23], (function (x, param) {
                return /* tuple */[
                        param[1],
                        make_interpretation_type(Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc */3], x, recvars), param[0], Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], x, typs))
                      ];
              }), mainvars);
}

function check_rule_productivity(l) {
  if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
            switch (param.tag | 0) {
              case 0 : 
              case 2 : 
                  return /* false */0;
              case 1 : 
              case 3 : 
                  return /* true */1;
              
            }
          }), l)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("A notation must include at least one symbol."));
  }
  var tmp;
  tmp = l && l[0].tag === 2 ? /* true */1 : /* false */0;
  if (tmp) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("A recursive notation must start with at least one symbol."));
  } else {
    return 0;
  }
}

var warn_notation_bound_to_variable = CWarnings$ReactTemplate.create("notation-bound-to-variable", "parsing", /* None */0, (function () {
        return Pp$ReactTemplate.strbrk("This notation will not be used for printing as it is bound to a single variable.");
      }));

var warn_non_reversible_notation = CWarnings$ReactTemplate.create("non-reversible-notation", "parsing", /* None */0, (function (param) {
        if (typeof param === "number") {
          if (param !== 0) {
            return Pp$ReactTemplate.strbrk("This notation contains Ltac expressions: it will not be used for printing.");
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "metasyntax.ml",
                    990,
                    33
                  ]
                ];
          }
        } else {
          var ids = param[0];
          var n = Curry._1(Util$ReactTemplate.List[/* length */0], ids);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk(Curry._2(Util$ReactTemplate.$$String[/* plural */33], n, "Variable")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.pr_enum(Names$ReactTemplate.Id[/* print */8], ids)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.strbrk(n > 1 ? "do" : "does")), Pp$ReactTemplate.str(" not occur in the right-hand side.")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.strbrk("The notation will not be used for printing as it is not reversible."));
        }
      }));

function is_not_printable(onlyparse, reversibility, param) {
  if (param.tag === 1) {
    if (!onlyparse) {
      Curry._2(warn_notation_bound_to_variable, /* None */0, /* () */0);
    }
    return /* true */1;
  } else if (!onlyparse && reversibility !== /* APrioriReversible */0) {
    Curry._2(warn_non_reversible_notation, /* None */0, reversibility);
    return /* true */1;
  } else {
    return onlyparse;
  }
}

function find_precedence(lev, etyps, symbols, onlyprint) {
  var aux = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var h = param[0];
        if (h.tag === 3) {
          _param = param[1];
          continue ;
          
        } else {
          return /* Some */[h];
        }
      } else {
        return /* None */0;
      }
    };
  };
  var first_symbol = aux(symbols);
  var last_is_terminal = function () {
    var _b = /* false */0;
    var _param = symbols;
    while(true) {
      var param = _param;
      var b = _b;
      if (param) {
        switch (param[0].tag | 0) {
          case 0 : 
              _param = param[1];
              _b = /* true */1;
              continue ;
              case 1 : 
          case 2 : 
              _param = param[1];
              _b = /* false */0;
              continue ;
              case 3 : 
              _param = param[1];
              continue ;
              
        }
      } else {
        return b;
      }
    };
  };
  if (first_symbol) {
    var match = first_symbol[0];
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          if (last_is_terminal(/* () */0)) {
            if (Option$ReactTemplate.is_empty(lev)) {
              return /* tuple */[
                      /* :: */[
                        /* tuple */[
                          (function (param) {
                              return Feedback$ReactTemplate.msg_info(/* None */0, param);
                            }),
                          Pp$ReactTemplate.strbrk("Setting notation at level 0.")
                        ],
                        /* [] */0
                      ],
                      0
                    ];
            } else {
              return /* tuple */[
                      /* [] */0,
                      Option$ReactTemplate.get(lev)
                    ];
            }
          } else {
            exit = 1;
          }
          break;
      case 1 : 
          var test = function () {
            if (onlyprint) {
              if (Option$ReactTemplate.is_empty(lev)) {
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Explicit level needed in only-printing mode when the level of the leftmost non-terminal is given."));
              } else {
                return /* tuple */[
                        /* [] */0,
                        Option$ReactTemplate.get(lev)
                      ];
              }
            } else {
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The level of the leftmost non-terminal cannot be changed."));
            }
          };
          try {
            var match$1 = Curry._2(Util$ReactTemplate.List[/* assoc */30], match[0], etyps);
            var exit$1 = 0;
            if (typeof match$1 === "number") {
              if (lev) {
                if (lev[0] !== 0) {
                  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("A notation starting with an atomic expression must be at level 0."));
                } else {
                  return /* tuple */[
                          /* [] */0,
                          0
                        ];
                }
              } else {
                return /* tuple */[
                        /* :: */[
                          /* tuple */[
                            (function (param) {
                                return Feedback$ReactTemplate.msg_info(/* None */0, param);
                              }),
                            Pp$ReactTemplate.strbrk("Setting notation at level 0.")
                          ],
                          /* [] */0
                        ],
                        0
                      ];
              }
            } else {
              switch (match$1.tag | 0) {
                case 1 : 
                    return test(/* () */0);
                case 2 : 
                    if (match$1[1]) {
                      return test(/* () */0);
                    } else {
                      exit$1 = 2;
                    }
                    break;
                case 0 : 
                case 3 : 
                case 4 : 
                    exit$1 = 2;
                    break;
                
              }
            }
            if (exit$1 === 2) {
              if (Option$ReactTemplate.is_empty(lev)) {
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Need an explicit level."));
              } else {
                return /* tuple */[
                        /* [] */0,
                        Option$ReactTemplate.get(lev)
                      ];
              }
            }
            
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              if (Option$ReactTemplate.is_empty(lev)) {
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("A left-recursive notation must have an explicit level."));
              } else {
                return /* tuple */[
                        /* [] */0,
                        Option$ReactTemplate.get(lev)
                      ];
              }
            } else {
              throw exn;
            }
          }
          break;
      case 2 : 
      case 3 : 
          exit = 1;
          break;
      
    }
    if (exit === 1) {
      if (Option$ReactTemplate.is_empty(lev)) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot determine the level."));
      }
      return /* tuple */[
              /* [] */0,
              Option$ReactTemplate.get(lev)
            ];
    }
    
  } else {
    return /* tuple */[
            /* [] */0,
            0
          ];
  }
}

function check_curly_brackets_notation_exists() {
  try {
    Notation$ReactTemplate.level_of_notation("{ _ }");
    return /* () */0;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Notations involving patterns of the form \"{ _ }\" are treated \nspecially and require that the notation \"{ _ }\" is already reserved."));
    } else {
      throw exn;
    }
  }
}

function remove_curly_brackets(l) {
  var skip_break = function (_acc, _l) {
    while(true) {
      var l = _l;
      var acc = _acc;
      if (l) {
        var br = l[0];
        if (br.tag === 3) {
          _l = l[1];
          _acc = /* :: */[
            br,
            acc
          ];
          continue ;
          
        } else {
          return /* tuple */[
                  Curry._1(Util$ReactTemplate.List[/* rev */4], acc),
                  l
                ];
        }
      } else {
        return /* tuple */[
                Curry._1(Util$ReactTemplate.List[/* rev */4], acc),
                l
              ];
      }
    };
  };
  var aux = function (deb, param) {
    if (param) {
      var t1 = param[0];
      if (t1.tag) {
        return /* :: */[
                t1,
                aux(/* false */0, param[1])
              ];
      } else if (t1[0] === "{") {
        var match = skip_break(/* [] */0, param[1]);
        var next = match[1];
        if (next) {
          var x = next[0];
          if (x.tag === 1) {
            var match$1 = skip_break(/* [] */0, next[1]);
            var next$prime = match$1[1];
            var exit = 0;
            if (next$prime) {
              var t2 = next$prime[0];
              if (t2.tag) {
                exit = 1;
              } else if (t2[0] === "}") {
                var l$prime$prime = next$prime[1];
                if (deb && Curry._1(Util$ReactTemplate.List[/* is_empty */45], l$prime$prime)) {
                  return /* :: */[
                          t1,
                          /* :: */[
                            x,
                            /* :: */[
                              t2,
                              /* [] */0
                            ]
                          ]
                        ];
                } else {
                  check_curly_brackets_notation_exists(/* () */0);
                  return /* :: */[
                          x,
                          aux(/* false */0, l$prime$prime)
                        ];
                }
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              return Util$ReactTemplate.$at(/* :: */[
                          t1,
                          match[0]
                        ], Util$ReactTemplate.$at(/* :: */[
                              x,
                              match$1[0]
                            ], aux(/* false */0, next$prime)));
            }
            
          } else {
            return /* :: */[
                    t1,
                    aux(/* false */0, next)
                  ];
          }
        } else {
          return /* :: */[
                  t1,
                  aux(/* false */0, next)
                ];
        }
      } else {
        return /* :: */[
                t1,
                aux(/* false */0, param[1])
              ];
      }
    } else {
      return /* [] */0;
    }
  };
  return aux(/* true */1, l);
}

function find_subentry_types(n, assoc, etyps, symbols) {
  var typs = find_symbols(/* tuple */[
        /* NumLevel */[n],
        /* BorderProd */[
          /* Left */0,
          assoc
        ]
      ], /* tuple */[
        /* NumLevel */[200],
        /* InternalProd */0
      ], /* tuple */[
        /* NumLevel */[n],
        /* BorderProd */[
          /* Right */1,
          assoc
        ]
      ], symbols);
  var sy_typs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var etyps$1 = etyps;
          var param$1 = param;
          var typ = param$1[1];
          var x = param$1[0];
          var typ$1;
          try {
            var match = Curry._2(Util$ReactTemplate.List[/* assoc */30], x, etyps$1);
            if (typeof match === "number") {
              typ$1 = match;
            } else {
              switch (match.tag | 0) {
                case 1 : 
                    var match$1 = match[0];
                    if (match$1) {
                      var match$2 = typ[1];
                      var n = match$1[0];
                      typ$1 = match$2 ? /* ETConstr */Block.__(1, [/* tuple */[
                              n,
                              /* BorderProd */[
                                match$2[0],
                                /* None */0
                              ]
                            ]]) : /* ETConstr */Block.__(1, [/* tuple */[
                              n,
                              /* InternalProd */0
                            ]]);
                    } else {
                      typ$1 = /* ETConstr */Block.__(1, [typ]);
                    }
                    break;
                case 2 : 
                    var match$3 = match[1];
                    var bk = match[0];
                    if (match$3) {
                      var match$4 = typ[1];
                      var n$1 = match$3[0];
                      typ$1 = match$4 ? /* ETConstrAsBinder */Block.__(2, [
                            bk,
                            /* tuple */[
                              n$1,
                              /* BorderProd */[
                                match$4[0],
                                /* None */0
                              ]
                            ]
                          ]) : /* ETConstrAsBinder */Block.__(2, [
                            bk,
                            /* tuple */[
                              n$1,
                              /* InternalProd */0
                            ]
                          ]);
                    } else {
                      typ$1 = /* ETConstrAsBinder */Block.__(2, [
                          bk,
                          typ
                        ]);
                    }
                    break;
                case 3 : 
                    typ$1 = /* ETPattern */Block.__(3, [
                        match[0],
                        match[1]
                      ]);
                    break;
                default:
                  typ$1 = match;
              }
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              typ$1 = /* ETConstr */Block.__(1, [typ]);
            } else {
              throw exn;
            }
          }
          return /* tuple */[
                  x,
                  typ$1
                ];
        }), typs);
  var prec = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var n$1 = n;
          var param$1 = param;
          return precedence_of_entry_type(n$1, param$1[1]);
        }), sy_typs);
  return /* tuple */[
          sy_typs,
          prec
        ];
}

function compute_syntax_data(df, modifiers) {
  var mods = interp_modifiers(modifiers);
  var onlyprint = mods[/* only_printing */4];
  var onlyparse = mods[/* only_parsing */3];
  if (onlyprint && onlyparse) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("A notation cannot be both 'only printing' and 'only parsing'."));
  }
  var assoc = Option$ReactTemplate.append(mods[/* assoc */0], /* Some */[/* NonA */0]);
  var match = analyze_notation_tokens(onlyprint, df);
  var symbols = match[2];
  var mainvars = match[1];
  var recvars = match[0];
  check_useless_entry_types(recvars, mainvars, mods[/* etyps */2]);
  check_binder_type(recvars, mods[/* etyps */2]);
  var ntn_for_interp = Notation$ReactTemplate.make_notation_key(symbols);
  var symbols_for_grammar = remove_curly_brackets(symbols);
  var need_squash = 1 - Curry._3(Util$ReactTemplate.List[/* equal */44], Notation$ReactTemplate.symbol_eq, symbols, symbols_for_grammar);
  var ntn_for_grammar = need_squash ? Notation$ReactTemplate.make_notation_key(symbols_for_grammar) : ntn_for_interp;
  if (!onlyprint) {
    check_rule_productivity(symbols_for_grammar);
  }
  var match$1 = find_precedence(mods[/* level */1], mods[/* etyps */2], symbols, onlyprint);
  var n = match$1[1];
  var etyps = join_auxiliary_recursive_types(recvars, mods[/* etyps */2]);
  var match$2 = find_subentry_types(n, assoc, etyps, symbols);
  var prec = match$2[1];
  var sy_typs = match$2[0];
  var match$3 = need_squash ? find_subentry_types(n, assoc, etyps, symbols_for_grammar) : /* tuple */[
      sy_typs,
      prec
    ];
  var sy_typs_for_grammar = match$3[0];
  var i_typs = set_internalization_type(sy_typs);
  var pa_sy_data = /* tuple */[
    sy_typs_for_grammar,
    symbols_for_grammar
  ];
  var pp_sy_data = /* tuple */[
    sy_typs,
    symbols
  ];
  var sy_fulldata_001 = /* tuple */[
    n,
    match$3[1],
    Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
            return prim[1];
          }), sy_typs_for_grammar)
  ];
  var sy_fulldata = /* tuple */[
    ntn_for_grammar,
    sy_fulldata_001,
    need_squash
  ];
  var df$prime_000 = /* tuple */[
    Lib$ReactTemplate.library_dp(/* () */0),
    Lib$ReactTemplate.current_dirpath(/* true */1)
  ];
  var df$prime = /* tuple */[
    df$prime_000,
    df
  ];
  var i_data = /* tuple */[
    ntn_for_interp,
    df$prime
  ];
  return /* record */[
          /* info */i_data,
          /* only_parsing */mods[/* only_parsing */3],
          /* only_printing */mods[/* only_printing */4],
          /* compat */mods[/* compat */5],
          /* format */mods[/* format */6],
          /* extra */mods[/* extra */7],
          /* msgs */match$1[0],
          /* recvars */recvars,
          /* mainvars */mainvars,
          /* intern_typs */i_typs,
          /* level : tuple */[
            n,
            prec,
            Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                    return prim[1];
                  }), sy_typs)
          ],
          /* pa_syntax_data */pa_sy_data,
          /* pp_syntax_data */pp_sy_data,
          /* not_data */sy_fulldata
        ];
}

function compute_pure_syntax_data(df, mods) {
  var sd = compute_syntax_data(df, mods);
  var msgs = sd[/* only_parsing */1] ? /* :: */[
      /* tuple */[
        (function (param) {
            return Feedback$ReactTemplate.msg_warning(/* None */0, param);
          }),
        Pp$ReactTemplate.strbrk("The only parsing modifier has no effect in Reserved Notation.")
      ],
      sd[/* msgs */6]
    ] : sd[/* msgs */6];
  var newrecord = sd.slice();
  newrecord[/* msgs */6] = msgs;
  return newrecord;
}

function load_notation(_, param) {
  return Option$ReactTemplate.iter(Notation$ReactTemplate.declare_scope, param[1][/* notobj_scope */1]);
}

function open_notation(i, param) {
  var nobj = param[1];
  var scope = nobj[/* notobj_scope */1];
  var match = nobj[/* notobj_notation */6];
  var ntn = match[0];
  var pat = nobj[/* notobj_interp */2];
  var onlyprint = nobj[/* notobj_onlyprint */4];
  var fresh = 1 - Notation$ReactTemplate.exists_notation_in_scope(scope, ntn, onlyprint, pat);
  var active = is_active_compat(nobj[/* notobj_compat */5]);
  if (i === 1 && fresh && active) {
    Notation$ReactTemplate.declare_notation_interpretation(ntn, scope, pat, match[1], onlyprint);
    if (nobj[/* notobj_onlyparse */3]) {
      return 0;
    } else {
      return Notation$ReactTemplate.declare_uninterpretation(/* NotationRule */Block.__(0, [
                    scope,
                    ntn
                  ]), pat);
    }
  } else {
    return 0;
  }
}

function cache_notation(o) {
  load_notation(1, o);
  return open_notation(1, o);
}

function subst_notation(param) {
  var nobj = param[1];
  var newrecord = nobj.slice();
  newrecord[/* notobj_interp */2] = Notation_ops$ReactTemplate.subst_interpretation(param[0], nobj[/* notobj_interp */2]);
  return newrecord;
}

function classify_notation(nobj) {
  if (nobj[/* notobj_local */0]) {
    return /* Dispose */0;
  } else {
    return /* Substitute */Block.__(0, [nobj]);
  }
}

var init$2 = Libobject$ReactTemplate.default_object("NOTATION");

var inNotation = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$2[/* object_name */0],
      /* cache_function */cache_notation,
      /* load_function */load_notation,
      /* open_function */open_notation,
      /* classify_function */classify_notation,
      /* subst_function */subst_notation,
      /* discharge_function */init$2[/* discharge_function */6],
      /* rebuild_function */init$2[/* rebuild_function */7]
    ]);

function with_syntax_protection(f, x) {
  var f$1 = function (param) {
    return Pcoq$ReactTemplate.with_grammar_rule_protection((function (param) {
                  return Notation$ReactTemplate.with_notation_protection(f, param);
                }), param);
  };
  var x$1 = x;
  var fs = Lib$ReactTemplate.freeze(/* No */17505);
  try {
    var a = Curry._1(f$1, x$1);
    Lib$ReactTemplate.unfreeze(fs);
    return a;
  }
  catch (raw_reraise){
    var reraise = Js_exn.internalToOCamlException(raw_reraise);
    var reraise$1 = CErrors$ReactTemplate.push(reraise);
    Lib$ReactTemplate.unfreeze(fs);
    return Util$ReactTemplate.iraise(reraise$1);
  }
}

var NoSyntaxRule = Caml_exceptions.create("Metasyntax-ReactTemplate.NoSyntaxRule");

function recover_notation_syntax(ntn) {
  try {
    var prec = Notation$ReactTemplate.level_of_notation(ntn);
    var match = Notation$ReactTemplate.find_notation_printing_rule(ntn);
    var pp_extra_rules = Notation$ReactTemplate.find_notation_extra_printing_rules(ntn);
    var pa_rule = Notation$ReactTemplate.find_notation_parsing_rules(ntn);
    return /* record */[
            /* synext_level */prec,
            /* synext_notation */ntn,
            /* synext_notgram */pa_rule,
            /* synext_unparsing */match[0],
            /* synext_extra */pp_extra_rules,
            /* synext_compat : None */0
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw NoSyntaxRule;
    } else {
      throw exn;
    }
  }
}

function make_pa_rule(level, param, ntn, need_squash) {
  var typs = param[0];
  var assoc = recompute_assoc(typs);
  var prod = make_production(typs, param[1]);
  var sy = /* record */[
    /* notgram_level */level,
    /* notgram_assoc */assoc,
    /* notgram_notation */ntn,
    /* notgram_prods */prod
  ];
  if (need_squash) {
    var sy$1 = sy;
    var sq = recover_notation_syntax("{ _ }");
    return /* :: */[
            sy$1,
            sq[/* synext_notgram */2][/* notgram_rules */1]
          ];
  } else {
    return /* :: */[
            sy,
            /* [] */0
          ];
  }
}

function make_pp_rule(level, param, fmt) {
  var symbols = param[1];
  var typs = param[0];
  if (fmt) {
    var param$1 = /* tuple */[
      level,
      Curry._1(Util$ReactTemplate.List[/* split */36], typs)
    ];
    var symfmt = /* tuple */[
      symbols,
      parse_format(fmt[0])
    ];
    var match = param$1[1];
    var typs$1 = match[1];
    var vars = match[0];
    var from = param$1[0];
    var aux = function (_param) {
      while(true) {
        var param = _param;
        var symbs = param[0];
        var exit = 0;
        var exit$1 = 0;
        var exit$2 = 0;
        var match = param[1];
        if (match) {
          var u = match[0][1];
          switch (u.tag | 0) {
            case 4 : 
                var s$prime = u[0];
                if (s$prime === Curry._2(Util$ReactTemplate.$$String[/* make */0], s$prime.length, /* " " */32)) {
                  var match$1 = aux(/* tuple */[
                        symbs,
                        match[1]
                      ]);
                  return /* tuple */[
                          match$1[0],
                          /* :: */[
                            u,
                            match$1[1]
                          ]
                        ];
                } else {
                  exit$2 = 3;
                }
                break;
            case 5 : 
                var match$2 = aux(/* tuple */[
                      symbs,
                      u[1]
                    ]);
                var match$3 = aux(/* tuple */[
                      match$2[0],
                      match[1]
                    ]);
                return /* tuple */[
                        match$3[0],
                        /* :: */[
                          /* UnpBox */Block.__(5, [
                              u[0],
                              Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                                      return /* tuple */[
                                              /* None */0,
                                              x
                                            ];
                                    }), match$2[1])
                            ]),
                          match$3[1]
                        ]
                      ];
            case 6 : 
                var match$4 = aux(/* tuple */[
                      symbs,
                      match[1]
                    ]);
                return /* tuple */[
                        match$4[0],
                        /* :: */[
                          u,
                          match$4[1]
                        ]
                      ];
            default:
              exit$2 = 3;
          }
        } else {
          exit$2 = 3;
        }
        if (exit$2 === 3) {
          if (symbs) {
            var match$5 = symbs[0];
            switch (match$5.tag | 0) {
              case 0 : 
                  var match$6 = param[1];
                  if (match$6) {
                    var match$7 = match$6[0][1];
                    if (match$7.tag === 4) {
                      var s = match$5[0];
                      if (s === Curry._1(Util$ReactTemplate.$$String[/* drop_simple_quotes */30], match$7[0])) {
                        var match$8 = aux(/* tuple */[
                              symbs[1],
                              match$6[1]
                            ]);
                        return /* tuple */[
                                match$8[0],
                                /* :: */[
                                  /* UnpTerminal */Block.__(4, [s]),
                                  match$8[1]
                                ]
                              ];
                      } else {
                        exit = 1;
                      }
                    } else {
                      exit = 1;
                    }
                  } else {
                    exit$1 = 2;
                  }
                  break;
              case 1 : 
                  var match$9 = param[1];
                  if (match$9) {
                    var match$10 = match$9[0][1];
                    if (match$10.tag === 4) {
                      var s$1 = match$5[0];
                      if (Names$ReactTemplate.Id[/* equal */0](s$1, Names$ReactTemplate.Id[/* of_string */5](match$10[0]))) {
                        var i = index_id(s$1, vars);
                        var match$11 = aux(/* tuple */[
                              symbs[1],
                              match$9[1]
                            ]);
                        return /* tuple */[
                                match$11[0],
                                /* :: */[
                                  unparsing_metavar(i, from, typs$1),
                                  match$11[1]
                                ]
                              ];
                      } else {
                        exit = 1;
                      }
                    } else {
                      exit = 1;
                    }
                  } else {
                    exit$1 = 2;
                  }
                  break;
              case 2 : 
                  var sl = match$5[1];
                  var m = match$5[0];
                  var i$1 = index_id(m, vars);
                  var typ = Curry._2(Util$ReactTemplate.List[/* nth */3], typs$1, i$1 - 1 | 0);
                  var match$12 = precedence_of_entry_type(from, typ);
                  var match$13 = read_recursive_format(sl, param[1]);
                  var fmt = match$13[1];
                  var match$14 = aux(/* tuple */[
                        sl,
                        match$13[0]
                      ]);
                  var slfmt = match$14[1];
                  var sl$1 = match$14[0];
                  if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], sl$1)) {
                    error_format(Curry._1(Util$ReactTemplate.List[/* last */105], fmt)[0], /* () */0);
                  }
                  var match$15 = aux(/* tuple */[
                        symbs[1],
                        fmt
                      ]);
                  var hunk;
                  if (typeof typ === "number") {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "metasyntax.ml",
                            539,
                            8
                          ]
                        ];
                  } else {
                    switch (typ.tag | 0) {
                      case 0 : 
                          var isopen = typ[0];
                          check_open_binder(isopen, sl$1, m);
                          hunk = /* UnpBinderListMetaVar */Block.__(3, [
                              i$1,
                              isopen,
                              slfmt
                            ]);
                          break;
                      case 1 : 
                          hunk = /* UnpListMetaVar */Block.__(2, [
                              i$1,
                              match$12[1],
                              slfmt
                            ]);
                          break;
                      default:
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "metasyntax.ml",
                                539,
                                8
                              ]
                            ];
                    }
                  }
                  return /* tuple */[
                          match$15[0],
                          /* :: */[
                            hunk,
                            match$15[1]
                          ]
                        ];
              case 3 : 
                  exit$1 = 2;
                  break;
              
            }
          } else {
            exit$1 = 2;
          }
        }
        if (exit$1 === 2) {
          if (param[1]) {
            if (symbs) {
              Curry._2(warn_format_break, /* None */0, /* () */0);
              _param = /* tuple */[
                symbs[1],
                param[1]
              ];
              continue ;
              
            } else {
              exit = 1;
            }
          } else {
            return /* tuple */[
                    symbs,
                    /* [] */0
                  ];
          }
        }
        if (exit === 1) {
          return error_format(Curry._1(Util$ReactTemplate.List[/* hd */1], param[1])[0], /* () */0);
        }
        
      };
    };
    var match$1 = aux(symfmt);
    if (match$1[0]) {
      return error_format(/* None */0, /* () */0);
    } else {
      return match$1[1];
    }
  } else {
    return /* :: */[
            /* UnpBox */Block.__(5, [
                /* PpHOVB */Block.__(1, [0]),
                make_hunks(typs, symbols, level)
              ]),
            /* [] */0
          ];
  }
}

function make_syntax_rules(sd) {
  var match = sd[/* not_data */13];
  var pa_rule = make_pa_rule(match[1], sd[/* pa_syntax_data */11], match[0], match[2]);
  var pp_rule = make_pp_rule(Util$ReactTemplate.pi1(sd[/* level */10]), sd[/* pp_syntax_data */12], sd[/* format */4]);
  return /* record */[
          /* synext_level */sd[/* level */10],
          /* synext_notation */sd[/* info */0][0],
          /* synext_notgram : record */[
            /* notgram_onlyprinting */sd[/* only_printing */2],
            /* notgram_rules */pa_rule
          ],
          /* synext_unparsing */pp_rule,
          /* synext_extra */sd[/* extra */5],
          /* synext_compat */sd[/* compat */3]
        ];
}

function to_map(l) {
  var fold = function (accu, param) {
    return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], param[0], param[1], accu);
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, Names$ReactTemplate.Id[/* Map */10][/* empty */0], l);
}

function add_notation_in_scope(local, df, env, c, mods, scope) {
  var sd = compute_syntax_data(df, mods);
  var sy_rules = make_syntax_rules(sd);
  var i_vars = make_internalization_vars(sd[/* recvars */7], sd[/* mainvars */8], sd[/* intern_typs */9]);
  var nenv_000 = /* ninterp_var_type */to_map(i_vars);
  var nenv_001 = /* ninterp_rec_vars */to_map(sd[/* recvars */7]);
  var nenv = /* record */[
    nenv_000,
    nenv_001
  ];
  var match = Constrintern$ReactTemplate.interp_notation_constr(env, /* None */0, nenv, c);
  var ac = match[1];
  var interp = make_interpretation_vars(sd[/* recvars */7], match[0], sd[/* pa_syntax_data */11][0]);
  var map = function (param) {
    var x = param[0];
    try {
      return /* Some */[/* tuple */[
                x,
                Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x, interp)
              ]];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
  };
  var onlyparse = is_not_printable(sd[/* only_parsing */1], match[2], ac);
  var notation_002 = /* notobj_interp : tuple */[
    Curry._2(Util$ReactTemplate.List[/* map_filter */62], map, i_vars),
    ac
  ];
  var notation_004 = /* notobj_onlyprint */sd[/* only_printing */2];
  var notation_005 = /* notobj_compat */sd[/* compat */3];
  var notation_006 = /* notobj_notation */sd[/* info */0];
  var notation = /* record */[
    /* notobj_local */local,
    /* notobj_scope */scope,
    notation_002,
    /* notobj_onlyparse */onlyparse,
    notation_004,
    notation_005,
    notation_006
  ];
  Flags$ReactTemplate.if_verbose(Curry._1(Util$ReactTemplate.List[/* iter */9], (function (param) {
              return Curry._1(param[0], param[1]);
            })), sd[/* msgs */6]);
  Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inSyntaxExtension, /* tuple */[
            local,
            sy_rules
          ]));
  Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inNotation, notation));
  return sd[/* info */0];
}

function add_notation_interpretation_core(local, df, env, $staropt$star, c, scope, onlyparse, onlyprint, compat) {
  var impls = $staropt$star ? $staropt$star[0] : Constrintern$ReactTemplate.empty_internalization_env;
  var match = analyze_notation_tokens(onlyprint, df);
  var symbs = match[2];
  var mainvars = match[1];
  var recvars = match[0];
  var match$1;
  if (is_numeral(symbs)) {
    match$1 = /* tuple */[
      /* [] */0,
      /* false */0
    ];
  } else {
    var sy = recover_notation_syntax(Notation$ReactTemplate.make_notation_key(symbs));
    Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inSyntaxExtension, /* tuple */[
              local,
              sy
            ]));
    var onlyprint$1 = onlyprint || sy[/* synext_notgram */2][/* notgram_onlyprinting */0];
    match$1 = /* tuple */[
      Util$ReactTemplate.pi3(sy[/* synext_level */0]),
      onlyprint$1
    ];
  }
  var i_typs = match$1[0];
  var path_000 = Lib$ReactTemplate.library_dp(/* () */0);
  var path_001 = Lib$ReactTemplate.current_dirpath(/* true */1);
  var path = /* tuple */[
    path_000,
    path_001
  ];
  var df$prime_000 = Notation$ReactTemplate.make_notation_key(symbs);
  var df$prime_001 = /* tuple */[
    path,
    df
  ];
  var df$prime = /* tuple */[
    df$prime_000,
    df$prime_001
  ];
  var i_vars = make_internalization_vars(recvars, mainvars, Curry._2(Util$ReactTemplate.List[/* map */10], internalization_type_of_entry_type, i_typs));
  var nenv_000 = /* ninterp_var_type */to_map(i_vars);
  var nenv_001 = /* ninterp_rec_vars */to_map(recvars);
  var nenv = /* record */[
    nenv_000,
    nenv_001
  ];
  var match$2 = Constrintern$ReactTemplate.interp_notation_constr(env, /* Some */[impls], nenv, c);
  var ac = match$2[1];
  var interp = make_interpretation_vars(recvars, match$2[0], Curry._2(Util$ReactTemplate.List[/* combine */37], mainvars, i_typs));
  var map = function (param) {
    var x = param[0];
    try {
      return /* Some */[/* tuple */[
                x,
                Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x, interp)
              ]];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
  };
  var onlyparse$1 = is_not_printable(onlyparse, match$2[2], ac);
  var notation_002 = /* notobj_interp : tuple */[
    Curry._2(Util$ReactTemplate.List[/* map_filter */62], map, i_vars),
    ac
  ];
  var notation_004 = /* notobj_onlyprint */match$1[1];
  var notation = /* record */[
    /* notobj_local */local,
    /* notobj_scope */scope,
    notation_002,
    /* notobj_onlyparse */onlyparse$1,
    notation_004,
    /* notobj_compat */compat,
    /* notobj_notation */df$prime
  ];
  Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inNotation, notation));
  return df$prime;
}

function add_syntax_extension(local, param) {
  var psd = compute_pure_syntax_data(param[0][/* v */0], param[1]);
  var newrecord = psd.slice();
  var sy_rules = make_syntax_rules((newrecord[/* compat */3] = /* None */0, newrecord));
  Flags$ReactTemplate.if_verbose(Curry._1(Util$ReactTemplate.List[/* iter */9], (function (param) {
              return Curry._1(param[0], param[1]);
            })), psd[/* msgs */6]);
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inSyntaxExtension, /* tuple */[
                  local,
                  sy_rules
                ]));
}

function add_notation_interpretation(_, _$1) {
  return /* () */0;
}

function set_notation_for_interpretation(env, impls, param) {
  var sc = param[2];
  var c = param[1];
  var df = param[0][/* v */0];
  try {
    Flags$ReactTemplate.silently((function () {
            return add_notation_interpretation_core(/* false */0, df, env, /* Some */[impls], c, sc, /* false */0, /* false */0, /* None */0);
          }), /* () */0);
  }
  catch (exn){
    if (exn === NoSyntaxRule) {
      CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Parsing rule for this notation has to be previously declared."));
    } else {
      throw exn;
    }
  }
  return Option$ReactTemplate.iter((function (sc) {
                return Notation$ReactTemplate.open_close_scope(/* tuple */[
                            /* false */0,
                            /* true */1,
                            sc
                          ]);
              }), sc);
}

function add_notation(local, env, c, param, sc) {
  var modifiers = param[1];
  var df = param[0][/* v */0];
  if (Curry._2(Util$ReactTemplate.List[/* for_all */20], not_a_syntax_modifier, modifiers)) {
    var onlyparse = is_only_parsing(modifiers);
    var onlyprint = is_only_printing(modifiers);
    var compat = get_compat_version(modifiers);
    try {
      add_notation_interpretation_core(local, df, env, /* None */0, c, sc, onlyparse, onlyprint, compat);
    }
    catch (exn){
      if (exn === NoSyntaxRule) {
        add_notation_in_scope(local, df, env, c, modifiers, sc);
      } else {
        throw exn;
      }
    }
  } else {
    add_notation_in_scope(local, df, env, c, modifiers, sc);
  }
  return /* () */0;
}

function add_notation_extra_printing_rule(df, k, v) {
  var match = analyze_notation_tokens(/* true */1, df);
  var notk = Notation$ReactTemplate.make_notation_key(match[2]);
  return Notation$ReactTemplate.add_notation_extra_printing_rule(notk, k, v);
}

function inject_var(x) {
  var eta = /* Ident */Block.__(1, [Names$ReactTemplate.Id[/* of_string */5](x)]);
  var eta_000 = CAst$ReactTemplate.make(/* None */0, eta);
  var eta$1 = /* CRef */Block.__(0, [
      eta_000,
      /* None */0
    ]);
  return CAst$ReactTemplate.make(/* None */0, eta$1);
}

function add_infix(local, env, param, pr, sc) {
  var modifiers = param[1];
  var match = param[0];
  check_infix_modifiers(modifiers);
  var metas_000 = inject_var("x");
  var metas_001 = /* :: */[
    inject_var("y"),
    /* [] */0
  ];
  var metas = /* :: */[
    metas_000,
    metas_001
  ];
  var c = Constrexpr_ops$ReactTemplate.mkAppC(/* tuple */[
        pr,
        metas
      ]);
  var df = CAst$ReactTemplate.make(match[/* loc */1], "x " + (quote_notation_token(match[/* v */0]) + " y"));
  return add_notation(local, env, c, /* tuple */[
              df,
              modifiers
            ], sc);
}

function load_scope_command(_, param) {
  return Notation$ReactTemplate.declare_scope(param[1][0]);
}

function open_scope_command(i, param) {
  if (i === 1) {
    var match = param[1];
    var o = match[1];
    var scope = match[0];
    if (typeof o === "number") {
      return Notation$ReactTemplate.remove_delimiters(scope);
    } else if (o.tag) {
      return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                    return Notation$ReactTemplate.declare_scope_class(scope, param);
                  }), o[0]);
    } else {
      return Notation$ReactTemplate.declare_delimiters(scope, o[0]);
    }
  } else {
    return 0;
  }
}

function cache_scope_command(o) {
  load_scope_command(1, o);
  return open_scope_command(1, o);
}

function subst_scope_command(param) {
  var x = param[1];
  var o = x[1];
  var subst = param[0];
  if (typeof o === "number") {
    return x;
  } else if (o.tag) {
    var cl = o[0];
    var cl$prime = Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function (param) {
            return Notation$ReactTemplate.subst_scope_class(subst, param);
          }), cl);
    var cl$prime$1 = Curry._3(Util$ReactTemplate.List[/* for_all2eq */92], (function (prim, prim$1) {
            return +(prim === prim$1);
          }), cl, cl$prime) ? cl : cl$prime;
    return /* tuple */[
            x[0],
            /* ScopeClasses */Block.__(1, [cl$prime$1])
          ];
  } else {
    return x;
  }
}

var init$3 = Libobject$ReactTemplate.default_object("DELIMITERS");

var inScopeCommand = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$3[/* object_name */0],
      /* cache_function */cache_scope_command,
      /* load_function */load_scope_command,
      /* open_function */open_scope_command,
      /* classify_function */(function (obj) {
          return /* Substitute */Block.__(0, [obj]);
        }),
      /* subst_function */subst_scope_command,
      /* discharge_function */init$3[/* discharge_function */6],
      /* rebuild_function */init$3[/* rebuild_function */7]
    ]);

function add_delimiters(scope, key) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inScopeCommand, /* tuple */[
                  scope,
                  /* ScopeDelim */Block.__(0, [key])
                ]));
}

function remove_delimiters(scope) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inScopeCommand, /* tuple */[
                  scope,
                  /* ScopeRemove */0
                ]));
}

function add_class_scope(scope, cl) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inScopeCommand, /* tuple */[
                  scope,
                  /* ScopeClasses */Block.__(1, [cl])
                ]));
}

function add_syntactic_definition(env, ident, param, local, onlyparse) {
  var vars = param[0];
  var match;
  try {
    throw Caml_builtin_exceptions.not_found;
    match = /* tuple */[
      /* [] */0,
      /* APrioriReversible */0,
      /* NRef */Block.__(0, [undefined])
    ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var fold = function (accu, id) {
        return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, /* NtnInternTypeAny */0, accu);
      };
      var i_vars = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, Names$ReactTemplate.Id[/* Map */10][/* empty */0], vars);
      var nenv_001 = /* ninterp_rec_vars */Names$ReactTemplate.Id[/* Map */10][/* empty */0];
      var nenv = /* record */[
        /* ninterp_var_type */i_vars,
        nenv_001
      ];
      var match$1 = Constrintern$ReactTemplate.interp_notation_constr(env, /* None */0, nenv, param[1]);
      var nvars = match$1[0];
      var map = function (id) {
        var match = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, nvars);
        return /* tuple */[
                id,
                match[1]
              ];
      };
      match = /* tuple */[
        Curry._2(Util$ReactTemplate.List[/* map */10], map, vars),
        match$1[2],
        match$1[1]
      ];
    } else {
      throw exn;
    }
  }
  var pat = match[2];
  var onlyparse$1 = onlyparse || !is_not_printable(/* false */0, match[1], pat) ? onlyparse : /* Some */[/* Current */2];
  return Syntax_def$ReactTemplate.declare_syntactic_definition(local, ident, onlyparse$1, /* tuple */[
              match[0],
              pat
            ]);
}

exports.add_token_obj = add_token_obj;
exports.add_infix = add_infix;
exports.add_notation = add_notation;
exports.add_notation_extra_printing_rule = add_notation_extra_printing_rule;
exports.add_delimiters = add_delimiters;
exports.remove_delimiters = remove_delimiters;
exports.add_class_scope = add_class_scope;
exports.add_notation_interpretation = add_notation_interpretation;
exports.set_notation_for_interpretation = set_notation_for_interpretation;
exports.add_syntax_extension = add_syntax_extension;
exports.add_syntactic_definition = add_syntactic_definition;
exports.pr_grammar = pr_grammar;
exports.check_infix_modifiers = check_infix_modifiers;
exports.with_syntax_protection = with_syntax_protection;
/* inToken Not a pure module */
