// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Set = require("bs-platform/lib/js/set.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hashset$ReactTemplate = require("./hashset.bs.js");
var Hashcons$ReactTemplate = require("./hashcons.bs.js");

var Make = $$Set.Make;

function Hashcons(funarg) {
  var $$let = function (H) {
    var $$Set$1 = $$Set.Make(funarg);
    var set_prj = function (prim) {
      return prim;
    };
    var set_inj = function (prim) {
      return prim;
    };
    var spine = function (_s, _accu) {
      while(true) {
        var accu = _accu;
        var s = _s;
        if (s) {
          _accu = /* :: */[
            /* tuple */[
              s[1],
              s[2]
            ],
            accu
          ];
          _s = s[0];
          continue ;
          
        } else {
          return accu;
        }
      };
    };
    var umap = function (f, s) {
      if (s) {
        var l$prime = umap(f, s[0]);
        var r$prime = umap(f, s[2]);
        var v$prime = Curry._1(f, s[1]);
        return /* SNode */[
                l$prime,
                v$prime,
                r$prime,
                s[3]
              ];
      } else {
        return /* SEmpty */0;
      }
    };
    var eqeq = function (_s1, _s2) {
      while(true) {
        var s2 = _s2;
        var s1 = _s1;
        if (s1) {
          if (s2) {
            var match = s2[0];
            var match$1 = s1[0];
            if (match$1[0] === match[0]) {
              _s2 = spine(match[1], s2[1]);
              _s1 = spine(match$1[1], s1[1]);
              continue ;
              
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
        } else if (s2) {
          return /* false */0;
        } else {
          return /* true */1;
        }
      };
    };
    var eq = function (s1, s2) {
      if (s1 === s2) {
        return /* true */1;
      } else {
        return eqeq(spine(s1, /* [] */0), spine(s2, /* [] */0));
      }
    };
    var hash = function (s) {
      return Curry._3($$Set$1[/* fold */13], (function (v, accu) {
                    return Hashset$ReactTemplate.Combine[/* combine */0](Curry._1(H[/* hash */0], v), accu);
                  }), s, 0);
    };
    var Hashed = /* module */[
      /* eq */eq,
      /* hash */hash,
      /* hashcons */umap
    ];
    var include = Hashcons$ReactTemplate.Make([
          umap,
          eq,
          hash
        ]);
    return /* module */[
            /* Set */$$Set$1,
            /* set_prj */set_prj,
            /* set_inj */set_inj,
            /* spine */spine,
            /* umap */umap,
            /* eqeq */eqeq,
            /* Hashed */Hashed,
            /* generate */include[0],
            /* hcons */include[1]
          ];
  };
  return (function (funarg) {
      var $$let$1 = $$let(funarg);
      return [
              $$let$1[7],
              $$let$1[8]
            ];
    });
}

exports.Make = Make;
exports.Hashcons = Hashcons;
/* Hashcons-ReactTemplate Not a pure module */
