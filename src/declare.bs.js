// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Decls$ReactTemplate = require("./decls.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Heads$ReactTemplate = require("./heads.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Impargs$ReactTemplate = require("./impargs.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Notation$ReactTemplate = require("./notation.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Discharge$ReactTemplate = require("./discharge.bs.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Pretyping$ReactTemplate = require("./pretyping.bs.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");
var Opaqueproof$ReactTemplate = require("./opaqueproof.bs.js");
var Safe_typing$ReactTemplate = require("./safe_typing.bs.js");
var Dischargedhypsmap$ReactTemplate = require("./dischargedhypsmap.bs.js");
var InferCumulativity$ReactTemplate = require("./inferCumulativity.bs.js");

function load_constant(i, param) {
  var match = param[0];
  var sp = match[0];
  if (Nametab$ReactTemplate.exists_cci(sp)) {
    CErrors$ReactTemplate.alreadydeclared(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](Libnames$ReactTemplate.basename(sp)), Pp$ReactTemplate.str(" already exists")));
  }
  var con = Global$ReactTemplate.constant_of_delta_kn(match[1]);
  Nametab$ReactTemplate.push(/* Until */Block.__(0, [i]), sp, /* ConstRef */Block.__(1, [con]));
  return Decls$ReactTemplate.add_constant_kind(con, param[1][/* cst_kind */2]);
}

function open_constant(i, param) {
  if (param[1][/* cst_locl */3]) {
    return /* () */0;
  } else {
    var match = param[0];
    var con = Global$ReactTemplate.constant_of_delta_kn(match[1]);
    Nametab$ReactTemplate.push(/* Exactly */Block.__(1, [i]), match[0], /* ConstRef */Block.__(1, [con]));
    var match$1 = Global$ReactTemplate.lookup_constant(con)[/* const_body */1];
    switch (match$1.tag | 0) {
      case 0 : 
      case 1 : 
          return /* () */0;
      case 2 : 
          var match$2 = Opaqueproof$ReactTemplate.get_constraints(Global$ReactTemplate.opaque_tables(/* () */0), match$1[0]);
          if (match$2) {
            var f = match$2[0];
            if (Future$ReactTemplate.is_val(f)) {
              return Global$ReactTemplate.push_context_set(/* false */0, Future$ReactTemplate.force(f));
            } else {
              return /* () */0;
            }
          } else {
            return /* () */0;
          }
          break;
      
    }
  }
}

function exists_name(id) {
  if (Decls$ReactTemplate.variable_exists(id)) {
    return /* true */1;
  } else {
    return Global$ReactTemplate.exists_objlabel(Names$ReactTemplate.Label[/* of_id */5](id));
  }
}

function check_exists(sp) {
  var id = Libnames$ReactTemplate.basename(sp);
  if (exists_name(id)) {
    return CErrors$ReactTemplate.alreadydeclared(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" already exists")));
  } else {
    return 0;
  }
}

function cache_constant(param) {
  var obj = param[1];
  var match = param[0];
  var kn = match[1];
  var sp = match[0];
  var id = Libnames$ReactTemplate.basename(sp);
  var match$1 = Names$ReactTemplate.KerName[/* repr */2](kn);
  var match$2 = obj[/* cst_decl */0];
  var kn$prime = match$2 ? (check_exists(sp), Global$ReactTemplate.add_constant(match$1[1], id, match$2[0])) : (
      Global$ReactTemplate.exists_objlabel(Names$ReactTemplate.Label[/* of_id */5](Libnames$ReactTemplate.basename(sp))) ? Names$ReactTemplate.Constant[/* make1 */1](kn) : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Ex seff not found: "), Names$ReactTemplate.Id[/* print */8](Libnames$ReactTemplate.basename(sp))), Pp$ReactTemplate.str(".")))
    );
  if (!Names$ReactTemplate.Constant[/* equal */12](kn$prime, Names$ReactTemplate.Constant[/* make1 */1](kn))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declare.ml",
            94,
            2
          ]
        ];
  }
  Nametab$ReactTemplate.push(/* Until */Block.__(0, [1]), sp, /* ConstRef */Block.__(1, [Names$ReactTemplate.Constant[/* make1 */1](kn)]));
  var cst = Global$ReactTemplate.lookup_constant(kn$prime);
  Lib$ReactTemplate.add_section_constant(Declareops$ReactTemplate.constant_is_polymorphic(cst), kn$prime)(cst[/* const_hyps */0]);
  Dischargedhypsmap$ReactTemplate.set_discharged_hyps(sp, obj[/* cst_hyps */1]);
  return Decls$ReactTemplate.add_constant_kind(Names$ReactTemplate.Constant[/* make1 */1](kn), obj[/* cst_kind */2]);
}

function discharged_hyps(kn, sechyps) {
  var match = Names$ReactTemplate.KerName[/* repr */2](kn);
  var dir = match[1];
  var args = Util$ReactTemplate.$$Array[/* to_list */9](Lib$ReactTemplate.instance_from_variable_context(sechyps));
  return Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (param) {
                return Libnames$ReactTemplate.make_path(dir, param);
              }), args);
}

function discharge_constant(param) {
  var obj = param[1];
  var kn = param[0][1];
  var con = Names$ReactTemplate.Constant[/* make1 */1](kn);
  var from = Global$ReactTemplate.lookup_constant(con);
  var modlist = Lib$ReactTemplate.replacement_context(/* () */0);
  var match = Lib$ReactTemplate.section_segment_of_constant(con);
  var hyps = match[/* abstr_ctx */0];
  var new_hyps = Util$ReactTemplate.$at(discharged_hyps(kn, hyps), obj[/* cst_hyps */1]);
  var abstract_000 = Curry._1(Lib$ReactTemplate.named_of_variable_context, hyps);
  var abstract_001 = match[/* abstr_subst */1];
  var abstract_002 = match[/* abstr_uctx */2];
  var $$abstract = /* tuple */[
    abstract_000,
    abstract_001,
    abstract_002
  ];
  var new_decl = /* GlobalRecipe */Block.__(1, [/* record */[
        /* from */from,
        /* info : record */[
          /* modlist */modlist,
          /* abstract */$$abstract
        ]
      ]]);
  return /* Some */[/* record */[
            /* cst_decl : Some */[new_decl],
            /* cst_hyps */new_hyps,
            /* cst_kind */obj[/* cst_kind */2],
            /* cst_locl */obj[/* cst_locl */3]
          ]];
}

function dummy_constant(cst) {
  return /* record */[
          /* cst_decl : None */0,
          /* cst_hyps : [] */0,
          /* cst_kind */cst[/* cst_kind */2],
          /* cst_locl */cst[/* cst_locl */3]
        ];
}

function classify_constant(cst) {
  return /* Substitute */Block.__(0, [dummy_constant(cst)]);
}

var init = Libobject$ReactTemplate.default_object("CONSTANT");

var inConstant = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_constant,
      /* load_function */load_constant,
      /* open_function */open_constant,
      /* classify_function */classify_constant,
      /* subst_function */Libobject$ReactTemplate.ident_subst_function,
      /* discharge_function */discharge_constant,
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

var declare_scheme = [(function (_, _$1) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "declare.ml",
              135,
              37
            ]
          ];
    })];

function set_declare_scheme(f) {
  declare_scheme[0] = f;
  return /* () */0;
}

function update_tables(c) {
  Impargs$ReactTemplate.declare_constant_implicits(c);
  Heads$ReactTemplate.declare_head(/* EvalConstRef */Block.__(1, [c]));
  return Notation$ReactTemplate.declare_ref_arguments_scope(Evd$ReactTemplate.empty, /* ConstRef */Block.__(1, [c]));
}

function register_side_effect(param) {
  var role = param[1];
  var c = param[0];
  var o = Curry._1(inConstant, /* record */[
        /* cst_decl : None */0,
        /* cst_hyps : [] */0,
        /* cst_kind : IsProof */Block.__(2, [/* Theorem */0]),
        /* cst_locl : false */0
      ]);
  var id = Names$ReactTemplate.Label[/* to_id */6](Util$ReactTemplate.pi3(Names$ReactTemplate.Constant[/* repr3 */6](c)));
  Lib$ReactTemplate.add_leaf(id, o);
  update_tables(c);
  if (role) {
    return Curry._2(declare_scheme[0], role[1], /* array */[/* tuple */[
                  role[0],
                  c
                ]]);
  } else {
    return /* () */0;
  }
}

var default_univ_entry = /* Monomorphic_const_entry */Block.__(0, [Univ$ReactTemplate.ContextSet[/* empty */0]]);

function definition_entry(fix_exn, $staropt$star, $staropt$star$1, types, $staropt$star$2, $staropt$star$3, body) {
  var opaque = $staropt$star ? $staropt$star[0] : /* false */0;
  var inline = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var univs = $staropt$star$2 ? $staropt$star$2[0] : default_univ_entry;
  var eff = $staropt$star$3 ? $staropt$star$3[0] : Safe_typing$ReactTemplate.empty_private_constants;
  return /* record */[
          /* const_entry_body */Future$ReactTemplate.from_val(fix_exn, /* tuple */[
                /* tuple */[
                  body,
                  Univ$ReactTemplate.ContextSet[/* empty */0]
                ],
                eff
              ]),
          /* const_entry_secctx : None */0,
          /* const_entry_feedback : None */0,
          /* const_entry_type */types,
          /* const_entry_universes */univs,
          /* const_entry_opaque */opaque,
          /* const_entry_inline_code */inline
        ];
}

function declare_constant(_, $staropt$star, id, $staropt$star$1, param) {
  var cd = param[0];
  var local = $staropt$star ? $staropt$star[0] : /* false */0;
  var export_seff = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var is_poly = function (de) {
    var match = de[/* const_entry_universes */4];
    if (match.tag) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  };
  var in_section = Lib$ReactTemplate.sections_are_opened(/* () */0);
  var match;
  var exit = 0;
  switch (cd.tag | 0) {
    case 0 : 
        var de = cd[0];
        if (export_seff || !de[/* const_entry_opaque */5] || is_poly(de)) {
          var match$1 = Global$ReactTemplate.export_private_constants(in_section, de);
          match = /* tuple */[
            match$1[1],
            /* ConstantEntry */Block.__(0, [
                /* PureEntry */1,
                /* DefinitionEntry */Block.__(0, [match$1[0]])
              ])
          ];
        } else {
          exit = 1;
        }
        break;
    case 1 : 
    case 2 : 
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    match = /* tuple */[
      /* [] */0,
      /* ConstantEntry */Block.__(0, [
          /* EffectEntry */0,
          cd
        ])
    ];
  }
  Curry._2(Util$ReactTemplate.List[/* iter */9], register_side_effect, match[0]);
  var cst_000 = /* cst_decl : Some */[match[1]];
  var cst_002 = /* cst_kind */param[1];
  var cst = /* record */[
    cst_000,
    /* cst_hyps : [] */0,
    cst_002,
    /* cst_locl */local
  ];
  var id$1 = id;
  var cst$1 = cst;
  var o = Curry._1(inConstant, cst$1);
  var oname = Lib$ReactTemplate.add_leaf(id$1, o);
  Lib$ReactTemplate.pull_to_head(oname);
  var c = Global$ReactTemplate.constant_of_delta_kn(oname[1]);
  update_tables(c);
  return c;
}

function declare_definition($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, id, types, param) {
  var internal = $staropt$star ? $staropt$star[0] : /* UserIndividualRequest */2;
  var opaque = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var kind = $staropt$star$2 ? $staropt$star$2[0] : /* Definition */0;
  var local = $staropt$star$3 ? $staropt$star$3[0] : /* false */0;
  var cb = definition_entry(/* None */0, /* Some */[opaque], /* None */0, types, /* Some */[param[1]], /* None */0, param[0]);
  return declare_constant(/* Some */[internal], /* Some */[local], id, /* None */0, /* tuple */[
              /* DefinitionEntry */Block.__(0, [cb]),
              /* IsDefinition */Block.__(1, [kind])
            ]);
}

function cache_variable(param) {
  var o = param[1];
  var sp = param[0][0];
  if (o.tag) {
    var match = o[0];
    var match$1 = match[1];
    var d = match$1[1];
    var id = match[0];
    if (Decls$ReactTemplate.variable_exists(id)) {
      CErrors$ReactTemplate.alreadydeclared(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" already exists")));
    }
    var match$2;
    if (d.tag) {
      var poly = d[1];
      var match$3 = d[0];
      var ctx = match$3[1];
      Global$ReactTemplate.push_named_assum(/* tuple */[
            /* tuple */[
              id,
              match$3[0],
              poly
            ],
            ctx
          ]);
      var impl = d[2] ? /* Implicit */1 : /* Explicit */0;
      match$2 = /* tuple */[
        impl,
        /* true */1,
        poly,
        ctx
      ];
    } else {
      var match$4 = Global$ReactTemplate.export_private_constants(/* true */1, d[0]);
      var de = match$4[0];
      Curry._2(Util$ReactTemplate.List[/* iter */9], register_side_effect, match$4[1]);
      var match$5 = Future$ReactTemplate.force(de[/* const_entry_body */0]);
      var match$6 = match$5[0];
      var match$7 = de[/* const_entry_universes */4];
      var match$8;
      match$8 = match$7.tag ? /* tuple */[
          /* true */1,
          Univ$ReactTemplate.ContextSet[/* of_context */14](match$7[0])
        ] : /* tuple */[
          /* false */0,
          match$7[0]
        ];
      var poly$1 = match$8[0];
      var univs = Univ$ReactTemplate.ContextSet[/* union */6](match$6[1], match$8[1]);
      Global$ReactTemplate.push_context_set(1 - poly$1, univs);
      var se_000 = /* secdef_body */match$6[0];
      var se_001 = /* secdef_secctx */de[/* const_entry_secctx */1];
      var se_002 = /* secdef_feedback */de[/* const_entry_feedback */2];
      var se_003 = /* secdef_type */de[/* const_entry_type */3];
      var se = /* record */[
        se_000,
        se_001,
        se_002,
        se_003
      ];
      Global$ReactTemplate.push_named_def(/* tuple */[
            id,
            se
          ]);
      match$2 = /* tuple */[
        /* Explicit */0,
        de[/* const_entry_opaque */5],
        poly$1,
        univs
      ];
    }
    var ctx$1 = match$2[3];
    var poly$2 = match$2[2];
    Nametab$ReactTemplate.push(/* Until */Block.__(0, [1]), Libnames$ReactTemplate.restrict_path(0, sp), /* VarRef */Block.__(0, [id]));
    Lib$ReactTemplate.add_section_variable(id, match$2[0], poly$2, ctx$1);
    Dischargedhypsmap$ReactTemplate.set_discharged_hyps(sp, /* [] */0);
    return Decls$ReactTemplate.add_variable_data(id, /* tuple */[
                match$1[0],
                match$2[1],
                ctx$1,
                poly$2,
                match$1[2]
              ]);
  } else {
    return Global$ReactTemplate.push_context_set(/* false */0, o[0]);
  }
}

function discharge_variable(param) {
  var o = param[1];
  if (o.tag) {
    var id = o[0][0];
    if (Decls$ReactTemplate.variable_polymorphic(id)) {
      return /* None */0;
    } else {
      return /* Some */[/* Inl */Block.__(0, [Decls$ReactTemplate.variable_context(id)])];
    }
  } else {
    return /* Some */[o];
  }
}

var init$1 = Libobject$ReactTemplate.default_object("VARIABLE");

var inVariable = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$1[/* object_name */0],
      /* cache_function */cache_variable,
      /* load_function */init$1[/* load_function */2],
      /* open_function */init$1[/* open_function */3],
      /* classify_function */(function () {
          return /* Dispose */0;
        }),
      /* subst_function */init$1[/* subst_function */5],
      /* discharge_function */discharge_variable,
      /* rebuild_function */init$1[/* rebuild_function */7]
    ]);

function declare_variable(id, obj) {
  var oname = Lib$ReactTemplate.add_leaf(id, Curry._1(inVariable, /* Inr */Block.__(1, [/* tuple */[
                id,
                obj
              ]])));
  Impargs$ReactTemplate.declare_var_implicits(id);
  Notation$ReactTemplate.declare_ref_arguments_scope(Evd$ReactTemplate.empty, /* VarRef */Block.__(0, [id]));
  Heads$ReactTemplate.declare_head(/* EvalVarRef */Block.__(0, [id]));
  return oname;
}

function declare_inductive_argument_scopes(kn, mie) {
  return Curry._2(Util$ReactTemplate.List[/* iteri */79], (function (i, param) {
                Notation$ReactTemplate.declare_ref_arguments_scope(Evd$ReactTemplate.empty, /* IndRef */Block.__(2, [/* tuple */[
                          kn,
                          i
                        ]]));
                for(var j = 1 ,j_finish = Curry._1(Util$ReactTemplate.List[/* length */0], param[/* mind_entry_consnames */3]); j <= j_finish; ++j){
                  Notation$ReactTemplate.declare_ref_arguments_scope(Evd$ReactTemplate.empty, /* ConstructRef */Block.__(3, [/* tuple */[
                            /* tuple */[
                              kn,
                              i
                            ],
                            j
                          ]]));
                }
                return /* () */0;
              }), mie[/* mind_entry_inds */3]);
}

function inductive_names(sp, kn, mie) {
  var match = Libnames$ReactTemplate.repr_path(sp);
  var dp = match[0];
  var kn$1 = Global$ReactTemplate.mind_of_delta_kn(kn);
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, ind) {
                  var n = param[1];
                  var ind_p = /* tuple */[
                    kn$1,
                    n
                  ];
                  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, l) {
                          var p = param[1];
                          var sp = Libnames$ReactTemplate.make_path(dp, l);
                          return /* tuple */[
                                  /* :: */[
                                    /* tuple */[
                                      sp,
                                      /* ConstructRef */Block.__(3, [/* tuple */[
                                            ind_p,
                                            p
                                          ]])
                                    ],
                                    param[0]
                                  ],
                                  p + 1 | 0
                                ];
                        }), /* tuple */[
                        param[0],
                        1
                      ], ind[/* mind_entry_consnames */3]);
                  var sp = Libnames$ReactTemplate.make_path(dp, ind[/* mind_entry_typename */0]);
                  return /* tuple */[
                          /* :: */[
                            /* tuple */[
                              sp,
                              /* IndRef */Block.__(2, [ind_p])
                            ],
                            match[0]
                          ],
                          n + 1 | 0
                        ];
                }), /* tuple */[
                /* [] */0,
                0
              ], mie[/* mind_entry_inds */3])[0];
}

function load_inductive(i, param) {
  var match = param[0];
  var names = inductive_names(match[0], match[1], param[1][1]);
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return Nametab$ReactTemplate.push(/* Until */Block.__(0, [i]), param[0], param[1]);
              }), names);
}

function open_inductive(i, param) {
  var match = param[0];
  var names = inductive_names(match[0], match[1], param[1][1]);
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return Nametab$ReactTemplate.push(/* Exactly */Block.__(1, [i]), param[0], param[1]);
              }), names);
}

function cache_inductive(param) {
  var match = param[1];
  var mie = match[1];
  var match$1 = param[0];
  var kn = match$1[1];
  var sp = match$1[0];
  var names = inductive_names(sp, kn, mie);
  Curry._2(Util$ReactTemplate.List[/* iter */9], check_exists, Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
              return prim[0];
            }), names));
  var id = Libnames$ReactTemplate.basename(sp);
  var match$2 = Names$ReactTemplate.KerName[/* repr */2](kn);
  var kn$prime = Global$ReactTemplate.add_mind(match$2[1], id, mie);
  if (!Names$ReactTemplate.MutInd[/* equal */12](kn$prime, Names$ReactTemplate.MutInd[/* make1 */1](kn))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declare.ml",
            329,
            2
          ]
        ];
  }
  var mind = Global$ReactTemplate.lookup_mind(kn$prime);
  Lib$ReactTemplate.add_section_kn(Declareops$ReactTemplate.inductive_is_polymorphic(mind), kn$prime)(mind[/* mind_hyps */4]);
  Dischargedhypsmap$ReactTemplate.set_discharged_hyps(sp, match[0]);
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return Nametab$ReactTemplate.push(/* Until */Block.__(0, [1]), param[0], param[1]);
              }), names);
}

function discharge_inductive(param) {
  var kn = param[0][1];
  var mind = Global$ReactTemplate.mind_of_delta_kn(kn);
  var mie = Global$ReactTemplate.lookup_mind(mind);
  var repl = Lib$ReactTemplate.replacement_context(/* () */0);
  var info = Lib$ReactTemplate.section_segment_of_mutual_inductive(mind);
  var sechyps = info[/* abstr_ctx */0];
  return /* Some */[/* tuple */[
            discharged_hyps(kn, sechyps),
            Discharge$ReactTemplate.process_inductive(info, repl, mie)
          ]];
}

function dummy_one_inductive_entry(mie) {
  return /* record */[
          /* mind_entry_typename */mie[/* mind_entry_typename */0],
          /* mind_entry_arity */Constr$ReactTemplate.mkProp,
          /* mind_entry_template : false */0,
          /* mind_entry_consnames */mie[/* mind_entry_consnames */3],
          /* mind_entry_lc : [] */0
        ];
}

function dummy_inductive_entry(param) {
  return /* tuple */[
          /* [] */0,
          /* record */[
            /* mind_entry_record : None */0,
            /* mind_entry_finite : BiFinite */2,
            /* mind_entry_params : [] */0,
            /* mind_entry_inds */Curry._2(Util$ReactTemplate.List[/* map */10], dummy_one_inductive_entry, param[1][/* mind_entry_inds */3]),
            /* mind_entry_universes : Monomorphic_ind_entry */Block.__(0, [Univ$ReactTemplate.ContextSet[/* empty */0]]),
            /* mind_entry_private : None */0
          ]
        ];
}

function infer_inductive_subtyping(param) {
  var mind_ent = param[1];
  var pth = param[0];
  var match = mind_ent[/* mind_entry_universes */4];
  switch (match.tag | 0) {
    case 0 : 
    case 1 : 
        return /* tuple */[
                pth,
                mind_ent
              ];
    case 2 : 
        var env = Global$ReactTemplate.env(/* () */0);
        return /* tuple */[
                pth,
                InferCumulativity$ReactTemplate.infer_inductive(env, mind_ent)
              ];
    
  }
}

var init$2 = Libobject$ReactTemplate.default_object("INDUCTIVE");

var inInductive = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$2[/* object_name */0],
      /* cache_function */cache_inductive,
      /* load_function */load_inductive,
      /* open_function */open_inductive,
      /* classify_function */(function (a) {
          return /* Substitute */Block.__(0, [dummy_inductive_entry(a)]);
        }),
      /* subst_function */Libobject$ReactTemplate.ident_subst_function,
      /* discharge_function */discharge_inductive,
      /* rebuild_function */infer_inductive_subtyping
    ]);

function declare_projections(mind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(Global$ReactTemplate.env(/* () */0), /* tuple */[
        mind,
        0
      ]);
  var match$1 = match[0][/* mind_record */1];
  if (match$1) {
    var match$2 = match$1[0];
    if (match$2) {
      Util$ReactTemplate.$$Array[/* iteri */13]((function (i, kn) {
              var id = Names$ReactTemplate.Label[/* to_id */6](Names$ReactTemplate.Constant[/* label */8](kn));
              var entry = /* record */[
                /* proj_entry_ind */mind,
                /* proj_entry_arg */i
              ];
              var kn$prime = declare_constant(/* None */0, /* None */0, id, /* None */0, /* tuple */[
                    /* ProjectionEntry */Block.__(2, [entry]),
                    /* IsDefinition */Block.__(1, [/* StructureComponent */8])
                  ]);
              if (Names$ReactTemplate.Constant[/* equal */12](kn, kn$prime)) {
                return 0;
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "declare.ml",
                        396,
                        3
                      ]
                    ];
              }
            }), match$2[0][1]);
      return /* tuple */[
              /* true */1,
              /* true */1
            ];
    } else {
      return /* tuple */[
              /* true */1,
              /* false */0
            ];
    }
  } else {
    return /* tuple */[
            /* false */0,
            /* false */0
          ];
  }
}

function declare_mind(mie) {
  var match = mie[/* mind_entry_inds */3];
  var id = match ? match[0][/* mind_entry_typename */0] : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("cannot declare an empty list of inductives."));
  var oname = Lib$ReactTemplate.add_leaf(id, Curry._1(inInductive, /* tuple */[
            /* [] */0,
            mie
          ]));
  var mind = Global$ReactTemplate.mind_of_delta_kn(oname[1]);
  var match$1 = declare_projections(mind);
  Impargs$ReactTemplate.declare_mib_implicits(mind);
  declare_inductive_argument_scopes(mind, mie);
  return /* tuple */[
          oname,
          match$1[1]
        ];
}

function pr_rank(i) {
  return Pp$ReactTemplate.pr_nth(i + 1 | 0);
}

function fixpoint_message(indexes, l) {
  var tmp;
  if (l) {
    if (l[1]) {
      tmp = Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Names$ReactTemplate.Id[/* print */8], l), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("are recursively defined")), indexes ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("(decreasing respectively on ")), Pp$ReactTemplate.prvect_with_sep(Pp$ReactTemplate.pr_comma, pr_rank, indexes[0])), Pp$ReactTemplate.str(" arguments)")) : Pp$ReactTemplate.mt(/* () */0)));
    } else {
      var tmp$1;
      if (indexes) {
        var match = indexes[0];
        if (match.length !== 1) {
          tmp$1 = Pp$ReactTemplate.mt(/* () */0);
        } else {
          var i = match[0];
          tmp$1 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" (decreasing on "), Pp$ReactTemplate.pr_nth(i + 1 | 0)), Pp$ReactTemplate.str(" argument)"));
        }
      } else {
        tmp$1 = Pp$ReactTemplate.mt(/* () */0);
      }
      tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](l[0]), Pp$ReactTemplate.str(" is recursively defined")), tmp$1);
    }
  } else {
    tmp = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("no recursive definition."));
  }
  return Flags$ReactTemplate.if_verbose((function (eta) {
                return Feedback$ReactTemplate.msg_info(/* None */0, eta);
              }), tmp);
}

function cofixpoint_message(l) {
  return Flags$ReactTemplate.if_verbose((function (eta) {
                return Feedback$ReactTemplate.msg_info(/* None */0, eta);
              }), l ? (
                l[1] ? Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Names$ReactTemplate.Id[/* print */8], l), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("are corecursively defined"))) : Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](l[0]), Pp$ReactTemplate.str(" is corecursively defined"))
              ) : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("No corecursive definition.")));
}

function recursive_message(isfix, i, l) {
  return Curry._1(isfix ? (function (param) {
                  return fixpoint_message(i, param);
                }) : cofixpoint_message, l);
}

function definition_message(id) {
  return Flags$ReactTemplate.if_verbose((function (eta) {
                return Feedback$ReactTemplate.msg_info(/* None */0, eta);
              }), Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is defined")));
}

function assumption_message(id) {
  return Flags$ReactTemplate.if_verbose((function (eta) {
                return Feedback$ReactTemplate.msg_info(/* None */0, eta);
              }), Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is declared")));
}

function cache_universe_context(param) {
  var ctx = param[1];
  var p = param[0];
  Global$ReactTemplate.push_context_set(p, ctx);
  if (p) {
    return Lib$ReactTemplate.add_section_context(ctx);
  } else {
    return 0;
  }
}

var init$3 = Libobject$ReactTemplate.default_object("Global universe context state");

var input_universe_context = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$3[/* object_name */0],
      /* cache_function */(function (param) {
          return cache_universe_context(param[1]);
        }),
      /* load_function */(function (_, param) {
          return cache_universe_context(param[1]);
        }),
      /* open_function */init$3[/* open_function */3],
      /* classify_function */(function (a) {
          return /* Keep */Block.__(1, [a]);
        }),
      /* subst_function */init$3[/* subst_function */5],
      /* discharge_function */(function (param) {
          var x = param[1];
          if (x[0]) {
            return /* None */0;
          } else {
            return /* Some */[x];
          }
        }),
      /* rebuild_function */init$3[/* rebuild_function */7]
    ]);

function declare_universe_context(poly, ctx) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(input_universe_context, /* tuple */[
                  poly,
                  ctx
                ]));
}

function add_universe(src, param) {
  var level = Univ$ReactTemplate.Level[/* make */8](param[0], param[1]);
  var optpoly = typeof src === "number" ? (
      src !== 0 ? /* Some */[/* false */0] : /* Some */[/* true */1]
    ) : /* None */0;
  return Option$ReactTemplate.iter((function (poly) {
                var ctx = Univ$ReactTemplate.ContextSet[/* add_universe */9](level, Univ$ReactTemplate.ContextSet[/* empty */0]);
                Global$ReactTemplate.push_context_set(poly, ctx);
                Universes$ReactTemplate.add_global_universe(level, poly);
                if (poly) {
                  return Lib$ReactTemplate.add_section_context(ctx);
                } else {
                  return 0;
                }
              }), optpoly);
}

function check_exists$1(sp) {
  var depth = Lib$ReactTemplate.sections_depth(/* () */0);
  var sp$1 = Libnames$ReactTemplate.make_path(Libnames$ReactTemplate.pop_dirpath_n(depth, Libnames$ReactTemplate.dirpath(sp)), Libnames$ReactTemplate.basename(sp));
  if (Nametab$ReactTemplate.exists_universe(sp$1)) {
    return CErrors$ReactTemplate.alreadydeclared(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Universe "), Names$ReactTemplate.Id[/* print */8](Libnames$ReactTemplate.basename(sp$1))), Pp$ReactTemplate.str(" already exists")));
  } else {
    return /* () */0;
  }
}

function qualify_univ(src, orig) {
  if (typeof src === "number") {
    return orig;
  } else {
    var match = Libnames$ReactTemplate.repr_path(orig[0]);
    var sp0 = Names$ReactTemplate.DirPath[/* repr */4](match[0]);
    return /* tuple */[
            Libnames$ReactTemplate.make_path(Names$ReactTemplate.DirPath[/* make */3](/* :: */[
                      src[0],
                      sp0
                    ]), match[1]),
            orig[1] + 1 | 0
          ];
  }
}

function cache_universe(param) {
  var match = param[1];
  var id = match[1];
  var src = match[0];
  var match$1 = qualify_univ(src, /* tuple */[
        param[0][0],
        1
      ]);
  var sp = match$1[0];
  check_exists$1(sp);
  Nametab$ReactTemplate.push_universe(/* Until */Block.__(0, [match$1[1]]), sp, id);
  return add_universe(src, id);
}

function load_universe(i, param) {
  var match = param[1];
  var id = match[1];
  var src = match[0];
  var match$1 = qualify_univ(src, /* tuple */[
        param[0][0],
        i
      ]);
  Nametab$ReactTemplate.push_universe(/* Until */Block.__(0, [match$1[1]]), match$1[0], id);
  return add_universe(src, id);
}

function open_universe(i, param) {
  var match = param[1];
  var match$1 = qualify_univ(match[0], /* tuple */[
        param[0][0],
        i
      ]);
  Nametab$ReactTemplate.push_universe(/* Exactly */Block.__(1, [match$1[1]]), match$1[0], match[1]);
  return /* () */0;
}

function discharge_universe(param) {
  var x = param[1];
  var match = x[0];
  if (typeof match === "number") {
    if (match !== 0) {
      return /* Some */[x];
    } else {
      return /* None */0;
    }
  } else {
    return /* Some */[x];
  }
}

var init$4 = Libobject$ReactTemplate.default_object("Global universe name state");

var input_universe = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$4[/* object_name */0],
      /* cache_function */cache_universe,
      /* load_function */load_universe,
      /* open_function */open_universe,
      /* classify_function */(function (a) {
          return /* Substitute */Block.__(0, [a]);
        }),
      /* subst_function */(function (param) {
          return param[1];
        }),
      /* discharge_function */discharge_universe,
      /* rebuild_function */init$4[/* rebuild_function */7]
    ]);

function declare_univ_binders(gr, pl) {
  if (Global$ReactTemplate.is_polymorphic(gr)) {
    return Universes$ReactTemplate.register_universe_binders(gr, pl);
  } else {
    var l;
    switch (gr.tag | 0) {
      case 0 : 
          l = gr[0];
          break;
      case 1 : 
          l = Names$ReactTemplate.Label[/* to_id */6](Names$ReactTemplate.Constant[/* label */8](gr[0]));
          break;
      case 2 : 
          l = Names$ReactTemplate.Label[/* to_id */6](Names$ReactTemplate.MutInd[/* label */8](gr[0][0]));
          break;
      case 3 : 
          l = CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["declare_univ_binders"], Pp$ReactTemplate.str("declare_univ_binders on an constructor reference"));
          break;
      
    }
    return Curry._2(Names$ReactTemplate.Id[/* Map */10][/* iter */9], (function (id, lvl) {
                  var match = Univ$ReactTemplate.Level[/* name */13](lvl);
                  if (match) {
                    Lib$ReactTemplate.add_leaf(id, Curry._1(input_universe, /* tuple */[
                              /* QualifiedUniv */[l],
                              match[0]
                            ]));
                    return /* () */0;
                  } else {
                    return /* () */0;
                  }
                }), pl);
  }
}

function do_universe(poly, l) {
  var in_section = Lib$ReactTemplate.sections_are_opened(/* () */0);
  if (poly && !in_section) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Constraint"], Pp$ReactTemplate.str("Cannot declare polymorphic universes outside sections"));
  }
  var l$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var lev = Curry._1(Universes$ReactTemplate.new_univ_id, /* () */0);
          return /* tuple */[
                  param[/* v */0],
                  lev
                ];
        }), l);
  var src = poly ? /* BoundUniv */0 : /* UnqualifiedUniv */1;
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                Lib$ReactTemplate.add_leaf(param[0], Curry._1(input_universe, /* tuple */[
                          src,
                          param[1]
                        ]));
                return /* () */0;
              }), l$1);
}

function cache_constraints(param) {
  var match = param[1];
  var ctx = Univ$ReactTemplate.ContextSet[/* add_constraints */10](match[1], Univ$ReactTemplate.ContextSet[/* empty */0]);
  return cache_universe_context(/* tuple */[
              match[0],
              ctx
            ]);
}

function discharge_constraints(param) {
  var a = param[1];
  if (a[0]) {
    return /* None */0;
  } else {
    return /* Some */[a];
  }
}

var init$5 = Libobject$ReactTemplate.default_object("Global universe constraints");

var input_constraints = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$5[/* object_name */0],
      /* cache_function */cache_constraints,
      /* load_function */(function () {
          return cache_constraints;
        }),
      /* open_function */init$5[/* open_function */3],
      /* classify_function */(function (a) {
          return /* Keep */Block.__(1, [a]);
        }),
      /* subst_function */init$5[/* subst_function */5],
      /* discharge_function */discharge_constraints,
      /* rebuild_function */init$5[/* rebuild_function */7]
    ]);

function do_constraint(poly, l) {
  var u_of_id = function (x) {
    var level = Pretyping$ReactTemplate.interp_known_glob_level(/* None */0, Evd$ReactTemplate.from_env(Global$ReactTemplate.env(/* () */0)), x);
    return /* tuple */[
            Universes$ReactTemplate.is_polymorphic(level),
            level
          ];
  };
  var in_section = Lib$ReactTemplate.sections_are_opened(/* () */0);
  if (poly && !in_section) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Constraint"], Pp$ReactTemplate.str("Cannot declare polymorphic constraints outside sections"));
  }
  var check_poly = function (p, p$prime) {
    if (poly || !(p || p$prime)) {
      return /* () */0;
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Constraint"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot declare a global constraint on "), Pp$ReactTemplate.str("a polymorphic universe, use ")), Pp$ReactTemplate.str("Polymorphic Constraint instead")));
    }
  };
  var constraints = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
          var match = u_of_id(param[0]);
          var match$1 = u_of_id(param[2]);
          check_poly(match[0], match$1[0]);
          return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                      match[1],
                      param[1],
                      match$1[1]
                    ], acc);
        }), Univ$ReactTemplate.Constraint[/* empty */0], l);
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(input_constraints, /* tuple */[
                  poly,
                  constraints
                ]));
}

exports.declare_variable = declare_variable;
exports.definition_entry = definition_entry;
exports.declare_constant = declare_constant;
exports.declare_definition = declare_definition;
exports.set_declare_scheme = set_declare_scheme;
exports.declare_mind = declare_mind;
exports.definition_message = definition_message;
exports.assumption_message = assumption_message;
exports.fixpoint_message = fixpoint_message;
exports.cofixpoint_message = cofixpoint_message;
exports.recursive_message = recursive_message;
exports.exists_name = exists_name;
exports.declare_univ_binders = declare_univ_binders;
exports.declare_universe_context = declare_universe_context;
exports.do_universe = do_universe;
exports.do_constraint = do_constraint;
/* inConstant Not a pure module */
