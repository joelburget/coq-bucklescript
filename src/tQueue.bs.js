// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Queue = require("bs-platform/lib/js/queue.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Mutex$ReactTemplate = require("./mutex.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Condition$ReactTemplate = require("../shims/condition.bs.js");

function sort_timestamp(param, param$1) {
  return param[0] - param$1[0] | 0;
}

var age = [0];

function is_empty(t) {
  return +(t[0][0] === /* [] */0);
}

function exists(p, t) {
  return List.exists((function (param) {
                return Curry._1(p, param[1]);
              }), t[0][0]);
}

function pop($staropt$star, t) {
  var match = t[/* contents */0];
  var rel = match[1];
  var picky = $staropt$star ? $staropt$star[0] : (function () {
        return /* true */1;
      });
  var _acc = /* [] */0;
  var _param = match[0];
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var xs = param[1];
      var hd = param[0];
      var x = hd[1];
      if (Curry._1(picky, x)) {
        t[0] = /* tuple */[
          Pervasives.$at(List.rev(acc), xs),
          rel
        ];
        return x;
      } else {
        _param = xs;
        _acc = /* :: */[
          hd,
          acc
        ];
        continue ;
        
      }
    } else {
      throw Queue.Empty;
    }
  };
}

function push(t, x) {
  var match = t[/* contents */0];
  var rel = match[1];
  age[0] = age[0] + 1 | 0;
  t[0] = /* tuple */[
    List.sort(rel, Pervasives.$at(match[0], /* :: */[
              /* tuple */[
                age[0],
                x
              ],
              /* [] */0
            ])),
    rel
  ];
  return /* () */0;
}

function clear(t) {
  var match = t[/* contents */0];
  t[0] = /* tuple */[
    /* [] */0,
    match[1]
  ];
  return /* () */0;
}

function set_rel(rel, t) {
  var match = t[/* contents */0];
  var rel$1 = function (param, param$1) {
    return Curry._2(rel, param[1], param$1[1]);
  };
  t[0] = /* tuple */[
    List.sort(rel$1, match[0]),
    rel$1
  ];
  return /* () */0;
}

function length(param) {
  var match = param[/* contents */0];
  return List.length(match[0]);
}

var BeingDestroyed = Caml_exceptions.create("TQueue-ReactTemplate.BeingDestroyed");

function create() {
  return /* record */[
          /* queue */[/* tuple */[
              /* [] */0,
              sort_timestamp
            ]],
          /* lock */Mutex$ReactTemplate.create(/* () */0),
          /* cond */Condition$ReactTemplate.create(/* () */0),
          /* nwaiting */0,
          /* cond_waiting */Condition$ReactTemplate.create(/* () */0),
          /* release : false */0
        ];
}

function pop$1($staropt$star, $staropt$star$1, tq) {
  var c = tq[/* cond */2];
  var m = tq[/* lock */1];
  var q = tq[/* queue */0];
  var cn = tq[/* cond_waiting */4];
  var picky = $staropt$star ? $staropt$star[0] : (function () {
        return /* true */1;
      });
  var destroy = $staropt$star$1 ? $staropt$star$1[0] : [/* false */0];
  Mutex$ReactTemplate.lock(m);
  if (tq[/* release */5]) {
    Mutex$ReactTemplate.unlock(m);
    throw BeingDestroyed;
  }
  while(!(exists(picky, q) || destroy[0])) {
    tq[/* nwaiting */3] = tq[/* nwaiting */3] + 1 | 0;
    Condition$ReactTemplate.broadcast(cn);
    Condition$ReactTemplate.wait(c, m);
    tq[/* nwaiting */3] = tq[/* nwaiting */3] - 1 | 0;
    if (tq[/* release */5] || destroy[0]) {
      Mutex$ReactTemplate.unlock(m);
      throw BeingDestroyed;
    }
    
  };
  if (destroy[0]) {
    Mutex$ReactTemplate.unlock(m);
    throw BeingDestroyed;
  }
  var x = pop(/* Some */[picky], q);
  Condition$ReactTemplate.signal(c);
  Condition$ReactTemplate.signal(cn);
  Mutex$ReactTemplate.unlock(m);
  return x;
}

function broadcast(param) {
  var m = param[/* lock */1];
  Mutex$ReactTemplate.lock(m);
  Condition$ReactTemplate.broadcast(param[/* cond */2]);
  return Mutex$ReactTemplate.unlock(m);
}

function push$1(param, x) {
  var m = param[/* lock */1];
  var release = param[/* release */5];
  if (release) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("TQueue.push while being destroyed! Only 1 producer/destroyer allowed."));
  }
  Mutex$ReactTemplate.lock(m);
  push(param[/* queue */0], x);
  Condition$ReactTemplate.broadcast(param[/* cond */2]);
  return Mutex$ReactTemplate.unlock(m);
}

function length$1(param) {
  var m = param[/* lock */1];
  Mutex$ReactTemplate.lock(m);
  var n = length(param[/* queue */0]);
  Mutex$ReactTemplate.unlock(m);
  return n;
}

function clear$1(param) {
  var m = param[/* lock */1];
  Mutex$ReactTemplate.lock(m);
  clear(param[/* queue */0]);
  return Mutex$ReactTemplate.unlock(m);
}

function clear_saving(param, f) {
  var m = param[/* lock */1];
  var q = param[/* queue */0];
  Mutex$ReactTemplate.lock(m);
  var saved = /* [] */0;
  while(!is_empty(q)) {
    var elem = pop(/* None */0, q);
    var match = Curry._1(f, elem);
    if (match) {
      saved = /* :: */[
        match[0],
        saved
      ];
    }
    
  };
  Mutex$ReactTemplate.unlock(m);
  return List.rev(saved);
}

function is_empty$1(param) {
  return is_empty(param[/* queue */0]);
}

function destroy(tq) {
  tq[/* release */5] = /* true */1;
  while(tq[/* nwaiting */3] > 0) {
    Mutex$ReactTemplate.lock(tq[/* lock */1]);
    Condition$ReactTemplate.broadcast(tq[/* cond */2]);
    Mutex$ReactTemplate.unlock(tq[/* lock */1]);
  };
  tq[/* release */5] = /* false */0;
  return /* () */0;
}

function wait_until_n_are_waiting_and_queue_empty(j, tq) {
  Mutex$ReactTemplate.lock(tq[/* lock */1]);
  while(!is_empty(tq[/* queue */0]) || tq[/* nwaiting */3] < j) {
    Condition$ReactTemplate.wait(tq[/* cond_waiting */4], tq[/* lock */1]);
  };
  return Mutex$ReactTemplate.unlock(tq[/* lock */1]);
}

function wait_until_n_are_waiting_then_snapshot(j, tq) {
  var l = /* [] */0;
  Mutex$ReactTemplate.lock(tq[/* lock */1]);
  while(!is_empty(tq[/* queue */0])) {
    l = /* :: */[
      pop(/* None */0, tq[/* queue */0]),
      l
    ];
  };
  while(tq[/* nwaiting */3] < j) {
    Condition$ReactTemplate.wait(tq[/* cond_waiting */4], tq[/* lock */1]);
  };
  var partial_arg = tq[/* queue */0];
  List.iter((function (param) {
          return push(partial_arg, param);
        }), List.rev(l));
  if (l !== /* [] */0) {
    Condition$ReactTemplate.broadcast(tq[/* cond */2]);
  }
  Mutex$ReactTemplate.unlock(tq[/* lock */1]);
  return List.rev(l);
}

function set_order(tq, rel) {
  Mutex$ReactTemplate.lock(tq[/* lock */1]);
  set_rel(rel, tq[/* queue */0]);
  return Mutex$ReactTemplate.unlock(tq[/* lock */1]);
}

exports.create = create;
exports.pop = pop$1;
exports.push = push$1;
exports.set_order = set_order;
exports.wait_until_n_are_waiting_and_queue_empty = wait_until_n_are_waiting_and_queue_empty;
exports.broadcast = broadcast;
exports.wait_until_n_are_waiting_then_snapshot = wait_until_n_are_waiting_then_snapshot;
exports.clear = clear$1;
exports.clear_saving = clear_saving;
exports.is_empty = is_empty$1;
exports.BeingDestroyed = BeingDestroyed;
exports.destroy = destroy;
exports.length = length$1;
/* Pp-ReactTemplate Not a pure module */
