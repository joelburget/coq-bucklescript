// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Int$ReactTemplate = require("../src/int.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Future$ReactTemplate = require("../src/future.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var UState$ReactTemplate = require("../src/uState.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Declare$ReactTemplate = require("../src/declare.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Summary$ReactTemplate = require("../src/summary.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Libobject$ReactTemplate = require("../src/libobject.bs.js");
var Mod_subst$ReactTemplate = require("../src/mod_subst.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Declareops$ReactTemplate = require("../src/declareops.bs.js");
var Safe_typing$ReactTemplate = require("../src/safe_typing.bs.js");

var scheme_map = Summary$ReactTemplate.ref(/* None */0, "Schemes", Names$ReactTemplate.Indmap[/* empty */0]);

function cache_scheme(param) {
  var match = param[1];
  var kind = match[0];
  return Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                var kind$1 = kind;
                var param$1 = param;
                var ind = param$1[0];
                var map;
                try {
                  map = Curry._2(Names$ReactTemplate.Indmap[/* find */21], ind, scheme_map[0]);
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    map = Util$ReactTemplate.$$String[/* Map */39][/* empty */0];
                  } else {
                    throw exn;
                  }
                }
                scheme_map[0] = Curry._3(Names$ReactTemplate.Indmap[/* add */3], ind, Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], kind$1, param$1[1], map), scheme_map[0]);
                return /* () */0;
              }), match[1]);
}

function subst_scheme(param) {
  var match = param[1];
  var subst = param[0];
  return /* tuple */[
          match[0],
          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                  var subst$1 = subst;
                  var param$1 = param;
                  return /* tuple */[
                          Mod_subst$ReactTemplate.subst_ind(subst$1, param$1[0]),
                          Mod_subst$ReactTemplate.subst_constant(subst$1, param$1[1])
                        ];
                }), match[1])
        ];
}

function discharge_scheme(param) {
  var match = param[1];
  return /* Some */[/* tuple */[
            match[0],
            Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                    return /* tuple */[
                            Lib$ReactTemplate.discharge_inductive(param[0]),
                            Lib$ReactTemplate.discharge_con(param[1])
                          ];
                  }), match[1])
          ]];
}

var init = Libobject$ReactTemplate.default_object("SCHEME");

var inScheme = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_scheme,
      /* load_function */(function () {
          return cache_scheme;
        }),
      /* open_function */init[/* open_function */3],
      /* classify_function */(function (obj) {
          return /* Substitute */Block.__(0, [obj]);
        }),
      /* subst_function */subst_scheme,
      /* discharge_function */discharge_scheme,
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

var scheme_object_table = Hashtbl.create(/* None */0, 17);

function declare_scheme_object(s, aux, f) {
  if (!Names$ReactTemplate.Id[/* is_valid */3]("ind" + s)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Illegal induction scheme suffix: " + s));
  }
  var key = Curry._1(Util$ReactTemplate.$$String[/* is_empty */26], aux) ? s : aux;
  try {
    Hashtbl.find(scheme_object_table, key);
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["IndTables.declare_scheme_object"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Scheme object "), Pp$ReactTemplate.str(key)), Pp$ReactTemplate.str(" already declared.")));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      Hashtbl.add(scheme_object_table, key, /* tuple */[
            s,
            f
          ]);
      return key;
    } else {
      throw exn;
    }
  }
}

function declare_mutual_scheme_object(s, $staropt$star, f) {
  var aux = $staropt$star ? $staropt$star[0] : "";
  return declare_scheme_object(s, aux, /* MutualSchemeFunction */Block.__(0, [f]));
}

function declare_individual_scheme_object(s, $staropt$star, f) {
  var aux = $staropt$star ? $staropt$star[0] : "";
  return declare_scheme_object(s, aux, /* IndividualSchemeFunction */Block.__(1, [f]));
}

function declare_scheme(kind, indcl) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inScheme, /* tuple */[
                  kind,
                  indcl
                ]));
}

Declare$ReactTemplate.set_declare_scheme(declare_scheme);

function is_visible_name(id) {
  try {
    Nametab$ReactTemplate.locate(Libnames$ReactTemplate.qualid_of_ident(id));
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function compute_name(internal, id) {
  if (internal !== 1) {
    return id;
  } else {
    return Namegen$ReactTemplate.next_ident_away_from(Nameops$ReactTemplate.add_prefix("internal_", id), is_visible_name);
  }
}

function define(internal, id, c, p, univs) {
  var partial_arg = /* Some */[internal];
  var fd = function (param, param$1, param$2, param$3) {
    return Declare$ReactTemplate.declare_constant(partial_arg, param, param$1, param$2, param$3);
  };
  var id$1 = compute_name(internal, id);
  var ctx = UState$ReactTemplate.minimize(univs);
  var c$1 = Universes$ReactTemplate.subst_opt_univs_constr(UState$ReactTemplate.subst(ctx))(c);
  var univs$1 = p ? /* Polymorphic_const_entry */Block.__(1, [UState$ReactTemplate.context(ctx)]) : /* Monomorphic_const_entry */Block.__(0, [UState$ReactTemplate.context_set(ctx)]);
  var entry_000 = /* const_entry_body */Future$ReactTemplate.from_val(/* None */0, /* tuple */[
        /* tuple */[
          c$1,
          Univ$ReactTemplate.ContextSet[/* empty */0]
        ],
        Safe_typing$ReactTemplate.empty_private_constants
      ]);
  var entry = /* record */[
    entry_000,
    /* const_entry_secctx : None */0,
    /* const_entry_feedback : None */0,
    /* const_entry_type : None */0,
    /* const_entry_universes */univs$1,
    /* const_entry_opaque : false */0,
    /* const_entry_inline_code : false */0
  ];
  var kn = Curry._4(fd, /* None */0, id$1, /* None */0, /* tuple */[
        /* DefinitionEntry */Block.__(0, [entry]),
        /* IsDefinition */Block.__(1, [/* Scheme */7])
      ]);
  if (internal !== 1) {
    Declare$ReactTemplate.definition_message(id$1);
  }
  return kn;
}

function define_individual_scheme_base(kind, suff, f, mode, idopt, ind) {
  var match = Curry._2(f, mode, ind);
  var match$1 = match[0];
  var mib = Global$ReactTemplate.lookup_mind(ind[0]);
  var id = idopt ? idopt[0] : Nameops$ReactTemplate.add_suffix(Caml_array.caml_array_get(mib[/* mind_packets */0], ind[1])[/* mind_typename */0], suff);
  var $$const = define(mode, id, match$1[0], Declareops$ReactTemplate.inductive_is_polymorphic(mib), match$1[1]);
  declare_scheme(kind, /* array */[/* tuple */[
          ind,
          $$const
        ]]);
  return /* tuple */[
          $$const,
          Safe_typing$ReactTemplate.add_private(Safe_typing$ReactTemplate.private_con_of_scheme(kind, Global$ReactTemplate.safe_env(/* () */0), /* :: */[
                    /* tuple */[
                      ind,
                      $$const
                    ],
                    /* [] */0
                  ]), match[1])
        ];
}

function define_individual_scheme(kind, mode, names, ind) {
  var match = Hashtbl.find(scheme_object_table, kind);
  var match$1 = match[1];
  if (match$1.tag) {
    return define_individual_scheme_base(kind, match[0], match$1[0], mode, names, ind);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ind_tables.ml",
            162,
            32
          ]
        ];
  }
}

function define_mutual_scheme_base(kind, suff, f, mode, names, mind) {
  var match = Curry._2(f, mode, mind);
  var match$1 = match[0];
  var ctx = match$1[1];
  var mib = Global$ReactTemplate.lookup_mind(mind);
  var ids = Util$ReactTemplate.$$Array[/* init */0](mib[/* mind_packets */0].length, (function (i) {
          try {
            return Curry._2(Int$ReactTemplate.List[/* assoc */1], i, names);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return Nameops$ReactTemplate.add_suffix(Caml_array.caml_array_get(mib[/* mind_packets */0], i)[/* mind_typename */0], suff);
            } else {
              throw exn;
            }
          }
        }));
  var consts = Util$ReactTemplate.$$Array[/* map2 */49]((function (id, cl) {
          return define(mode, id, cl, Declareops$ReactTemplate.inductive_is_polymorphic(mib), ctx);
        }), ids, match$1[0]);
  var schemes = Util$ReactTemplate.$$Array[/* mapi */14]((function (i, cst) {
          return /* tuple */[
                  /* tuple */[
                    mind,
                    i
                  ],
                  cst
                ];
        }), consts);
  declare_scheme(kind, schemes);
  return /* tuple */[
          consts,
          Safe_typing$ReactTemplate.add_private(Safe_typing$ReactTemplate.private_con_of_scheme(kind, Global$ReactTemplate.safe_env(/* () */0), Util$ReactTemplate.$$Array[/* to_list */9](schemes)), match[1])
        ];
}

function define_mutual_scheme(kind, mode, names, mind) {
  var match = Hashtbl.find(scheme_object_table, kind);
  var match$1 = match[1];
  if (match$1.tag) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ind_tables.ml",
            184,
            36
          ]
        ];
  } else {
    return define_mutual_scheme_base(kind, match[0], match$1[0], mode, names, mind);
  }
}

function find_scheme_on_env_too(kind, ind) {
  var s = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], kind, Curry._2(Names$ReactTemplate.Indmap[/* find */21], ind, scheme_map[0]));
  return /* tuple */[
          s,
          Safe_typing$ReactTemplate.add_private(Safe_typing$ReactTemplate.private_con_of_scheme(kind, Global$ReactTemplate.safe_env(/* () */0), /* :: */[
                    /* tuple */[
                      ind,
                      s
                    ],
                    /* [] */0
                  ]), Safe_typing$ReactTemplate.empty_private_constants)
        ];
}

function find_scheme($staropt$star, kind, ind) {
  var mode = $staropt$star ? $staropt$star[0] : /* InternalTacticRequest */1;
  try {
    return find_scheme_on_env_too(kind, ind);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var match = Hashtbl.find(scheme_object_table, kind);
      var match$1 = match[1];
      var s = match[0];
      if (match$1.tag) {
        return define_individual_scheme_base(kind, s, match$1[0], mode, /* None */0, ind);
      } else {
        var match$2 = define_mutual_scheme_base(kind, s, match$1[0], mode, /* [] */0, ind[0]);
        return /* tuple */[
                Caml_array.caml_array_get(match$2[0], ind[1]),
                match$2[1]
              ];
      }
    } else {
      throw exn;
    }
  }
}

function check_scheme(kind, ind) {
  try {
    find_scheme_on_env_too(kind, ind);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

var pr_scheme_kind = Pp$ReactTemplate.str;

exports.declare_mutual_scheme_object = declare_mutual_scheme_object;
exports.declare_individual_scheme_object = declare_individual_scheme_object;
exports.define_individual_scheme = define_individual_scheme;
exports.define_mutual_scheme = define_mutual_scheme;
exports.find_scheme = find_scheme;
exports.check_scheme = check_scheme;
exports.pr_scheme_kind = pr_scheme_kind;
/* scheme_map Not a pure module */
