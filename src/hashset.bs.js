// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("bs-platform/lib/js/sys.js");
var Weak = require("bs-platform/lib/js/weak.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");

function combine(x, y) {
  return Caml_int32.imul(x, 65599) + y | 0;
}

function combine3(x, y, z) {
  return combine(x, combine(y, z));
}

function combine4(x, y, z, t) {
  return combine(x, combine3(y, z, t));
}

function combine5(x, y, z, t, u) {
  return combine(x, combine4(y, z, t, u));
}

function combinesmall(x, y) {
  return Caml_int32.imul(7, x) + y | 0;
}

function Make(funarg) {
  var emptybucket = Weak.create(0);
  var get_index = function (t, h) {
    return Caml_int32.mod_(h & Pervasives.max_int, t[/* table */0].length);
  };
  var create = function (sz) {
    var sz$1 = sz < 7 ? 7 : sz;
    var sz$2 = sz$1 > Sys.max_array_length ? Sys.max_array_length : sz$1;
    return /* record */[
            /* table */Caml_array.caml_make_vect(sz$2, emptybucket),
            /* hashes */Caml_array.caml_make_vect(sz$2, /* int array */[]),
            /* limit */7,
            /* oversize */0,
            /* rover */0
          ];
  };
  var clear = function (t) {
    for(var i = 0 ,i_finish = t[/* table */0].length - 1 | 0; i <= i_finish; ++i){
      Caml_array.caml_array_set(t[/* table */0], i, emptybucket);
      Caml_array.caml_array_set(t[/* hashes */1], i, /* int array */[]);
    }
    t[/* limit */2] = 7;
    t[/* oversize */3] = 0;
    return /* () */0;
  };
  var iter_weak = function (f, t) {
    var iter_bucket = function (_i, j, b) {
      while(true) {
        var i = _i;
        if (i >= Weak.length(b)) {
          return /* () */0;
        } else {
          var match = Weak.check(b, i);
          if (match !== 0) {
            Curry._3(f, b, Caml_array.caml_array_get(t[/* hashes */1], j), i);
            _i = i + 1 | 0;
            continue ;
            
          } else {
            _i = i + 1 | 0;
            continue ;
            
          }
        }
      };
    };
    for(var i = 0 ,i_finish = t[/* table */0].length - 1 | 0; i <= i_finish; ++i){
      iter_bucket(0, i, t[/* table */0][i]);
    }
    return /* () */0;
  };
  var count_bucket = function (_i, b, _accu) {
    while(true) {
      var accu = _accu;
      var i = _i;
      if (i >= Weak.length(b)) {
        return accu;
      } else {
        _accu = accu + (
          Weak.check(b, i) ? 1 : 0
        ) | 0;
        _i = i + 1 | 0;
        continue ;
        
      }
    };
  };
  var min = function (x, y) {
    if ((x - y | 0) < 0) {
      return x;
    } else {
      return y;
    }
  };
  var next_sz = function (n) {
    return min((Caml_int32.imul(3, n) / 2 | 0) + 3 | 0, Sys.max_array_length);
  };
  var prev_sz = function (n) {
    return (((n - 3 | 0) << 1) + 2 | 0) / 3 | 0;
  };
  var test_shrink_bucket = function (t) {
    var bucket = Caml_array.caml_array_get(t[/* table */0], t[/* rover */4]);
    var hbucket = Caml_array.caml_array_get(t[/* hashes */1], t[/* rover */4]);
    var len = Weak.length(bucket);
    var prev_len = prev_sz(len);
    var live = count_bucket(0, bucket, 0);
    if (live <= prev_len) {
      var loop = function (_i, _j) {
        while(true) {
          var j = _j;
          var i = _i;
          if (j >= prev_len) {
            if (Weak.check(bucket, i)) {
              _i = i + 1 | 0;
              continue ;
              
            } else if (Weak.check(bucket, j)) {
              Weak.blit(bucket, j, bucket, i, 1);
              Caml_array.caml_array_set(hbucket, i, Caml_array.caml_array_get(hbucket, j));
              _j = j - 1 | 0;
              _i = i + 1 | 0;
              continue ;
              
            } else {
              _j = j - 1 | 0;
              continue ;
              
            }
          } else {
            return 0;
          }
        };
      };
      loop(0, Weak.length(bucket) - 1 | 0);
      if (prev_len) {
        Caml_obj.caml_obj_truncate(bucket, prev_len + 1 | 0);
        Caml_obj.caml_obj_truncate(hbucket, prev_len);
      } else {
        Caml_array.caml_array_set(t[/* table */0], t[/* rover */4], emptybucket);
        Caml_array.caml_array_set(t[/* hashes */1], t[/* rover */4], /* int array */[]);
      }
      if (len > t[/* limit */2] && prev_len <= t[/* limit */2]) {
        t[/* oversize */3] = t[/* oversize */3] - 1 | 0;
      }
      
    }
    t[/* rover */4] = Caml_int32.mod_(t[/* rover */4] + 1 | 0, t[/* table */0].length);
    return /* () */0;
  };
  var add_aux = function (t, setter, d, h, index) {
    var bucket = Caml_array.caml_array_get(t[/* table */0], index);
    var hashes = Caml_array.caml_array_get(t[/* hashes */1], index);
    var sz = Weak.length(bucket);
    var _i = 0;
    while(true) {
      var i = _i;
      if (i >= sz) {
        var newsz = min((Caml_int32.imul(3, sz) / 2 | 0) + 3 | 0, Sys.max_array_length - 1 | 0);
        if (newsz <= sz) {
          Pervasives.failwith("Weak.Make: hash bucket cannot grow more");
        }
        var newbucket = Weak.create(newsz);
        var newhashes = Caml_array.caml_make_vect(newsz, 0);
        Weak.blit(bucket, 0, newbucket, 0, sz);
        $$Array.blit(hashes, 0, newhashes, 0, sz);
        Curry._3(setter, newbucket, sz, d);
        Caml_array.caml_array_set(newhashes, sz, h);
        Caml_array.caml_array_set(t[/* table */0], index, newbucket);
        Caml_array.caml_array_set(t[/* hashes */1], index, newhashes);
        if (sz <= t[/* limit */2] && newsz > t[/* limit */2]) {
          t[/* oversize */3] = t[/* oversize */3] + 1 | 0;
          for(var _i$1 = 0; _i$1 <= 2; ++_i$1){
            test_shrink_bucket(t);
          }
        }
        if (t[/* oversize */3] > (t[/* table */0].length >> 1)) {
          var t$1 = t;
          var oldlen = t$1[/* table */0].length;
          var newlen = next_sz(oldlen);
          if (newlen > oldlen) {
            var newt = create(newlen);
            var add_weak = (function(newt){
            return function add_weak(ob, oh, oi) {
              var setter = function (nb, ni, _) {
                return Weak.blit(ob, oi, nb, ni, 1);
              };
              var h = Caml_array.caml_array_get(oh, oi);
              return add_aux(newt, setter, /* None */0, h, get_index(newt, h));
            }
            }(newt));
            iter_weak(add_weak, t$1);
            t$1[/* table */0] = newt[/* table */0];
            t$1[/* hashes */1] = newt[/* hashes */1];
            t$1[/* limit */2] = newt[/* limit */2];
            t$1[/* oversize */3] = newt[/* oversize */3];
            t$1[/* rover */4] = Caml_int32.mod_(t$1[/* rover */4], newt[/* table */0].length);
            return /* () */0;
          } else {
            t$1[/* limit */2] = Pervasives.max_int;
            t$1[/* oversize */3] = 0;
            return /* () */0;
          }
        } else {
          return 0;
        }
      } else if (Weak.check(bucket, i)) {
        _i = i + 1 | 0;
        continue ;
        
      } else {
        Curry._3(setter, bucket, i, d);
        return Caml_array.caml_array_set(hashes, i, h);
      }
    };
  };
  var repr = function (h, d, t) {
    var ifnotfound = function (index) {
      add_aux(t, Weak.set, /* Some */[d], h, index);
      return d;
    };
    var h$1 = h;
    var t$1 = t;
    var d$1 = d;
    var ifnotfound$1 = ifnotfound;
    var index = get_index(t$1, h$1);
    var bucket = Caml_array.caml_array_get(t$1[/* table */0], index);
    var hashes = Caml_array.caml_array_get(t$1[/* hashes */1], index);
    var sz = Weak.length(bucket);
    var _i = 0;
    while(true) {
      var i = _i;
      if (i >= sz) {
        return Curry._1(ifnotfound$1, index);
      } else if (h$1 === Caml_array.caml_array_get(hashes, i)) {
        var match = Weak.get(bucket, i);
        if (match) {
          var v = match[0];
          if (Curry._2(funarg[/* eq */0], v, d$1)) {
            return v;
          } else {
            _i = i + 1 | 0;
            continue ;
            
          }
        } else {
          _i = i + 1 | 0;
          continue ;
          
        }
      } else {
        _i = i + 1 | 0;
        continue ;
        
      }
    };
  };
  var stats = function (t) {
    var fold = function (accu, bucket) {
      return Caml_primitive.caml_int_max(count_bucket(0, bucket, 0), accu);
    };
    var max_length = $$Array.fold_left(fold, 0, t[/* table */0]);
    var histogram = Caml_array.caml_make_vect(max_length + 1 | 0, 0);
    var iter = function (bucket) {
      var len = count_bucket(0, bucket, 0);
      return Caml_array.caml_array_set(histogram, len, Caml_array.caml_array_get(histogram, len) + 1 | 0);
    };
    $$Array.iter(iter, t[/* table */0]);
    var fold$1 = function (param, k) {
      var i = param[2];
      return /* tuple */[
              param[0] + Caml_int32.imul(k, i) | 0,
              param[1] + k | 0,
              i + 1 | 0
            ];
    };
    var match = $$Array.fold_left(fold$1, /* tuple */[
          0,
          0,
          0
        ], histogram);
    return /* record */[
            /* num_bindings */match[0],
            /* num_buckets */match[1],
            /* max_bucket_length */histogram.length,
            /* bucket_histogram */histogram
          ];
  };
  return [
          create,
          clear,
          repr,
          stats
        ];
}

var Combine = [
  combine,
  combinesmall,
  combine3,
  combine4,
  combine5
];

exports.Make = Make;
exports.Combine = Combine;
/* No side effect */
