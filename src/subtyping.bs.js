// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Modops$ReactTemplate = require("./modops.bs.js");
var UGraph$ReactTemplate = require("./uGraph.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");

function add_mib_nameobjects(mp, l, mib, map) {
  var ind = Names$ReactTemplate.MutInd[/* make2 */2](mp, l);
  var add_mip_nameobjects = function (j, oib, map) {
    var ip = /* tuple */[
      ind,
      j
    ];
    var map$1 = Util$ReactTemplate.$$Array[/* fold_right_i */37]((function (i, id, map) {
            return Curry._3(Names$ReactTemplate.Label[/* Map */9][/* add */3], Names$ReactTemplate.Label[/* of_id */5](id), /* IndConstr */Block.__(2, [
                          /* tuple */[
                            ip,
                            i + 1 | 0
                          ],
                          mib
                        ]), map);
          }), oib[/* mind_consnames */3], map);
    return Curry._3(Names$ReactTemplate.Label[/* Map */9][/* add */3], Names$ReactTemplate.Label[/* of_id */5](oib[/* mind_typename */0]), /* IndType */Block.__(1, [
                  ip,
                  mib
                ]), map$1);
  };
  return Util$ReactTemplate.$$Array[/* fold_right_i */37](add_mip_nameobjects, mib[/* mind_packets */0], map);
}

var empty_labmap_000 = /* objs */Names$ReactTemplate.Label[/* Map */9][/* empty */0];

var empty_labmap_001 = /* mods */Names$ReactTemplate.Label[/* Map */9][/* empty */0];

var empty_labmap = /* record */[
  empty_labmap_000,
  empty_labmap_001
];

function get_obj(mp, map, l) {
  try {
    return Curry._2(Names$ReactTemplate.Label[/* Map */9][/* find */21], l, map[/* objs */0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Modops$ReactTemplate.error_no_such_label_sub(l, Names$ReactTemplate.ModPath[/* to_string */4](mp));
    } else {
      throw exn;
    }
  }
}

function get_mod(mp, map, l) {
  try {
    return Curry._2(Names$ReactTemplate.Label[/* Map */9][/* find */21], l, map[/* mods */1]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Modops$ReactTemplate.error_no_such_label_sub(l, Names$ReactTemplate.ModPath[/* to_string */4](mp));
    } else {
      throw exn;
    }
  }
}

function make_labmap(mp, list) {
  var add_one = function (param, map) {
    var e = param[1];
    var l = param[0];
    switch (e.tag | 0) {
      case 0 : 
          return /* record */[
                  /* objs */Curry._3(Names$ReactTemplate.Label[/* Map */9][/* add */3], l, /* Constant */Block.__(0, [e[0]]), map[/* objs */0]),
                  /* mods */map[/* mods */1]
                ];
      case 1 : 
          return /* record */[
                  /* objs */add_mib_nameobjects(mp, l, e[0], map[/* objs */0]),
                  /* mods */map[/* mods */1]
                ];
      case 2 : 
          return /* record */[
                  /* objs */map[/* objs */0],
                  /* mods */Curry._3(Names$ReactTemplate.Label[/* Map */9][/* add */3], l, /* Module */Block.__(0, [e[0]]), map[/* mods */1])
                ];
      case 3 : 
          return /* record */[
                  /* objs */map[/* objs */0],
                  /* mods */Curry._3(Names$ReactTemplate.Label[/* Map */9][/* add */3], l, /* Modtype */Block.__(1, [e[0]]), map[/* mods */1])
                ];
      
    }
  };
  return CList$ReactTemplate.fold_right(add_one, list, empty_labmap);
}

function check_conv_error(error, why, cst, poly, f, env, a1, a2) {
  try {
    var cst$prime = Curry._4(f, env, Environ$ReactTemplate.universes(env), a1, a2);
    if (poly) {
      if (Curry._1(Univ$ReactTemplate.Constraint[/* is_empty */1], cst$prime)) {
        return cst;
      } else {
        return Curry._1(error, /* IncompatiblePolymorphism */Block.__(12, [
                      env,
                      a1,
                      a2
                    ]));
      }
    } else {
      return Curry._2(Univ$ReactTemplate.Constraint[/* union */6], cst, cst$prime);
    }
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn === Reduction$ReactTemplate.NotConvertible) {
      return Curry._1(error, why);
    } else if (exn[0] === Univ$ReactTemplate.UniverseInconsistency) {
      return Curry._1(error, /* IncompatibleUniverses */Block.__(11, [exn[1]]));
    } else {
      throw exn;
    }
  }
}

function check_polymorphic_instance(error, env, auctx1, auctx2) {
  if (Univ$ReactTemplate.AUContext[/* size */4](auctx1) !== Univ$ReactTemplate.AUContext[/* size */4](auctx2)) {
    return Curry._1(error, /* IncompatibleInstances */8);
  } else if (UGraph$ReactTemplate.check_subtype(Environ$ReactTemplate.universes(env), auctx2, auctx1)) {
    return Environ$ReactTemplate.push_context(/* Some */[/* false */0], Univ$ReactTemplate.AUContext[/* repr */0](auctx2), env);
  } else {
    return Curry._1(error, /* IncompatibleConstraints */Block.__(13, [auctx1]));
  }
}

function check_signatures(cst, env, mp1, sig1, mp2, sig2, subst1, subst2, reso1, reso2) {
  var map1 = make_labmap(mp1, sig1);
  var check_one_body = function (cst, param) {
    var spec2 = param[1];
    var l = param[0];
    switch (spec2.tag | 0) {
      case 0 : 
          var cst$1 = cst;
          var env$1 = env;
          var l$1 = l;
          var info1 = get_obj(mp1, map1, l);
          var cb2 = spec2[0];
          var spec2$1 = spec2;
          var subst1$1 = subst1;
          var subst2$1 = subst2;
          var error = function (why) {
            return Modops$ReactTemplate.error_signature_mismatch(l$1, spec2$1, why);
          };
          var check_conv = function (cst, poly, f) {
            return (function (param, param$1, param$2, param$3) {
                return check_conv_error(error, cst, poly, f, param, param$1, param$2, param$3);
              });
          };
          var check_type = function (poly, cst, env, t1, t2) {
            var err = /* NotConvertibleTypeField */Block.__(3, [
                env,
                t1,
                t2
              ]);
            var match;
            if (Term$ReactTemplate.isArity(t2)) {
              var match$1 = Term$ReactTemplate.destArity(t2);
              var s2 = match$1[1];
              var ctx2 = match$1[0];
              if (s2.tag) {
                if (Univ$ReactTemplate.is_univ_variable(s2[0])) {
                  match = /* tuple */[
                    t1,
                    t2
                  ];
                } else {
                  try {
                    var match$2 = Reduction$ReactTemplate.dest_arity(env, t1);
                    var s1 = match$2[1];
                    var ctx1 = match$2[0];
                    match = s1.tag ? (
                        Univ$ReactTemplate.is_univ_variable(s1[0]) ? Modops$ReactTemplate.error_signature_mismatch(l$1, spec2$1, /* NoTypeConstraintExpected */7) : /* tuple */[
                            Term$ReactTemplate.mkArity(/* tuple */[
                                  ctx1,
                                  Sorts$ReactTemplate.prop
                                ]),
                            Term$ReactTemplate.mkArity(/* tuple */[
                                  ctx2,
                                  Sorts$ReactTemplate.prop
                                ])
                          ]
                      ) : /* tuple */[
                        Term$ReactTemplate.mkArity(/* tuple */[
                              ctx1,
                              Sorts$ReactTemplate.prop
                            ]),
                        Term$ReactTemplate.mkArity(/* tuple */[
                              ctx2,
                              Sorts$ReactTemplate.prop
                            ])
                      ];
                  }
                  catch (exn){
                    if (exn === Reduction$ReactTemplate.NotArity) {
                      match = Modops$ReactTemplate.error_signature_mismatch(l$1, spec2$1, err);
                    } else {
                      throw exn;
                    }
                  }
                }
              } else {
                match = /* tuple */[
                  t1,
                  t2
                ];
              }
            } else {
              match = /* tuple */[
                t1,
                t2
              ];
            }
            return check_conv(err, cst, poly)((function (eta) {
                          return (function (param, param$1, param$2) {
                              return Reduction$ReactTemplate.infer_conv_leq(/* None */0, /* None */0, /* None */0, eta, param, param$1, param$2);
                            });
                        }), env, match[0], match[1]);
          };
          switch (info1.tag | 0) {
            case 0 : 
                var cb1 = info1[0];
                if (!(Curry._1(Util$ReactTemplate.List[/* is_empty */45], cb1[/* const_hyps */0]) && Curry._1(Util$ReactTemplate.List[/* is_empty */45], cb2[/* const_hyps */0]))) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "subtyping.ml",
                          312,
                          15
                        ]
                      ];
                }
                var cb1$1 = Declareops$ReactTemplate.subst_const_body(subst1$1, cb1);
                var cb2$1 = Declareops$ReactTemplate.subst_const_body(subst2$1, cb2);
                var match = cb1$1[/* const_universes */4];
                var match$1 = cb2$1[/* const_universes */4];
                var match$2;
                match$2 = match.tag ? (
                    match$1.tag ? /* tuple */[
                        /* true */1,
                        check_polymorphic_instance(error, env$1, match[0], match$1[0])
                      ] : Modops$ReactTemplate.error_signature_mismatch(l$1, spec2$1, /* PolymorphicStatusExpected */Block.__(5, [/* false */0]))
                  ) : (
                    match$1.tag ? Modops$ReactTemplate.error_signature_mismatch(l$1, spec2$1, /* PolymorphicStatusExpected */Block.__(5, [/* true */1])) : /* tuple */[
                        /* false */0,
                        env$1
                      ]
                  );
                var env$2 = match$2[1];
                var poly = match$2[0];
                var typ1 = cb1$1[/* const_type */2];
                var typ2 = cb2$1[/* const_type */2];
                var cst$2 = check_type(poly, cst$1, env$2, typ1, typ2);
                var match$3 = cb2$1[/* const_body */1];
                switch (match$3.tag | 0) {
                  case 1 : 
                      var match$4 = cb1$1[/* const_body */1];
                      switch (match$4.tag | 0) {
                        case 1 : 
                            var c1 = Mod_subst$ReactTemplate.force_constr(match$4[0]);
                            var c2 = Mod_subst$ReactTemplate.force_constr(match$3[0]);
                            return check_conv(/* NotConvertibleBodyField */3, cst$2, poly)((function (eta) {
                                          return (function (param, param$1, param$2) {
                                              return Reduction$ReactTemplate.infer_conv(/* None */0, /* None */0, /* None */0, eta, param, param$1, param$2);
                                            });
                                        }), env$2, c1, c2);
                        case 0 : 
                        case 2 : 
                            return Modops$ReactTemplate.error_signature_mismatch(l$1, spec2$1, /* NotConvertibleBodyField */3);
                        
                      }
                      break;
                  case 0 : 
                  case 2 : 
                      return cst$2;
                  
                }
                break;
            case 1 : 
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The kernel does not recognize yet that a parameter can be instantiated by an inductive type. Hint: you can rename the inductive type and give a definition to map the old name to the new name."));
            case 2 : 
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The kernel does not recognize yet that a parameter can be instantiated by a constructor. Hint: you can rename the constructor and give a definition to map the old name to the new name."));
            
          }
      case 1 : 
          var cst$3 = cst;
          var env$3 = env;
          var mp1$1 = mp1;
          var l$2 = l;
          var info1$1 = get_obj(mp1, map1, l);
          var mp2$1 = mp2;
          var mib2 = spec2[0];
          var spec2$2 = spec2;
          var subst1$2 = subst1;
          var subst2$2 = subst2;
          var reso1$1 = reso1;
          var reso2$1 = reso2;
          var kn1 = Names$ReactTemplate.KerName[/* make2 */1](mp1$1, l$2);
          var kn2 = Names$ReactTemplate.KerName[/* make2 */1](mp2$1, l$2);
          var error$1 = function (why) {
            return Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, why);
          };
          var check_conv$1 = function (why, cst, poly, f) {
            return (function (param, param$1, param$2) {
                return check_conv_error(error$1, why, cst, poly, f, param, param$1, param$2);
              });
          };
          var mib1;
          switch (info1$1.tag | 0) {
            case 1 : 
                mib1 = info1$1[0][1] !== 0 ? Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, /* InductiveFieldExpected */Block.__(0, [mib2])) : Declareops$ReactTemplate.subst_mind_body(subst1$2, info1$1[1]);
                break;
            case 0 : 
            case 2 : 
                mib1 = Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, /* InductiveFieldExpected */Block.__(0, [mib2]));
                break;
            
          }
          var match$5 = mib1[/* mind_universes */8];
          var match$6 = mib2[/* mind_universes */8];
          var match$7;
          switch (match$5.tag | 0) {
            case 0 : 
                switch (match$6.tag | 0) {
                  case 0 : 
                      match$7 = /* tuple */[
                        env$3,
                        Univ$ReactTemplate.Instance[/* empty */0]
                      ];
                      break;
                  case 1 : 
                      var why = /* CumulativeStatusExpected */Block.__(4, [Declareops$ReactTemplate.inductive_is_cumulative(mib2)]);
                      match$7 = Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, why);
                      break;
                  case 2 : 
                      var why$1 = /* CumulativeStatusExpected */Block.__(4, [Declareops$ReactTemplate.inductive_is_cumulative(mib2)]);
                      match$7 = Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, why$1);
                      break;
                  
                }
                break;
            case 1 : 
                switch (match$6.tag | 0) {
                  case 0 : 
                      var why$2 = /* CumulativeStatusExpected */Block.__(4, [Declareops$ReactTemplate.inductive_is_cumulative(mib2)]);
                      match$7 = Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, why$2);
                      break;
                  case 1 : 
                      var auctx$prime = match$6[0];
                      var env$4 = check_polymorphic_instance(error$1, env$3, match$5[0], auctx$prime);
                      match$7 = /* tuple */[
                        env$4,
                        Univ$ReactTemplate.make_abstract_instance(auctx$prime)
                      ];
                      break;
                  case 2 : 
                      var why$3 = /* CumulativeStatusExpected */Block.__(4, [Declareops$ReactTemplate.inductive_is_cumulative(mib2)]);
                      match$7 = Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, why$3);
                      break;
                  
                }
                break;
            case 2 : 
                var cumi = match$5[0];
                switch (match$6.tag | 0) {
                  case 0 : 
                      var why$4 = /* CumulativeStatusExpected */Block.__(4, [Declareops$ReactTemplate.inductive_is_cumulative(mib2)]);
                      match$7 = Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, why$4);
                      break;
                  case 1 : 
                      var why$5 = /* CumulativeStatusExpected */Block.__(4, [Declareops$ReactTemplate.inductive_is_cumulative(mib2)]);
                      match$7 = Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, why$5);
                      break;
                  case 2 : 
                      var cumi$prime = match$6[0];
                      var v = Univ$ReactTemplate.ACumulativityInfo[/* variance */1](cumi);
                      var v$prime = Univ$ReactTemplate.ACumulativityInfo[/* variance */1](cumi$prime);
                      if (!Util$ReactTemplate.$$Array[/* for_all2 */27](Univ$ReactTemplate.Variance[/* check_subtype */0], v$prime, v)) {
                        CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Variance of "), Names$ReactTemplate.KerName[/* print */7](kn1)), Pp$ReactTemplate.str(" is not compatible with the one of ")), Names$ReactTemplate.KerName[/* print */7](kn2)));
                      }
                      var auctx = Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](cumi);
                      var auctx$prime$1 = Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](cumi$prime);
                      var env$5 = check_polymorphic_instance(error$1, env$3, auctx, auctx$prime$1);
                      match$7 = /* tuple */[
                        env$5,
                        Univ$ReactTemplate.make_abstract_instance(auctx$prime$1)
                      ];
                      break;
                  
                }
                break;
            
          }
          var inst = match$7[1];
          var env$6 = match$7[0];
          var mib2$1 = Declareops$ReactTemplate.subst_mind_body(subst2$2, mib2);
          var check_packet = function (cst, p1, p2) {
            var check = function (f, test, why) {
              if (Curry._2(test, Curry._1(f, p1), Curry._1(f, p2))) {
                return 0;
              } else {
                return Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, why);
              }
            };
            var partial_arg = Names$ReactTemplate.Id[/* equal */0];
            var partial_arg$1 = Util$ReactTemplate.$$Array[/* equal */21];
            check((function (p) {
                    return p[/* mind_consnames */3];
                  }), (function (param, param$1) {
                    return partial_arg$1(partial_arg, param, param$1);
                  }), /* NotSameConstructorNamesField */4);
            check((function (p) {
                    return p[/* mind_typename */0];
                  }), Names$ReactTemplate.Id[/* equal */0], /* NotSameInductiveNameInBlockField */5);
            check((function (p) {
                    return p[/* mind_nrealargs */5];
                  }), (function (prim, prim$1) {
                    return +(prim === prim$1);
                  }), /* NotConvertibleInductiveField */Block.__(1, [p2[/* mind_typename */0]]));
            var ty1 = Inductive$ReactTemplate.type_of_inductive(env$6, /* tuple */[
                  /* tuple */[
                    mib1,
                    p1
                  ],
                  inst
                ]);
            var ty2 = Inductive$ReactTemplate.type_of_inductive(env$6, /* tuple */[
                  /* tuple */[
                    mib2$1,
                    p2
                  ],
                  inst
                ]);
            var cst$1 = cst;
            var name = p2[/* mind_typename */0];
            var t1 = ty1;
            var t2 = ty2;
            var match = Reduction$ReactTemplate.dest_arity(env$6, t1);
            var s1 = match[1];
            var match$1 = Reduction$ReactTemplate.dest_arity(env$6, t2);
            var s2 = match$1[1];
            var match$2;
            match$2 = s1.tag ? (
                s2.tag ? /* tuple */[
                    Sorts$ReactTemplate.prop,
                    Sorts$ReactTemplate.prop
                  ] : Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, /* NotConvertibleInductiveField */Block.__(1, [name]))
              ) : (
                s2.tag ? Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, /* NotConvertibleInductiveField */Block.__(1, [name])) : /* tuple */[
                    s1,
                    s2
                  ]
              );
            return check_conv$1(/* NotConvertibleInductiveField */Block.__(1, [name]), cst$1, Declareops$ReactTemplate.inductive_is_polymorphic(mib1), (function (eta) {
                            return (function (param, param$1, param$2) {
                                return Reduction$ReactTemplate.infer_conv_leq(/* None */0, /* None */0, /* None */0, eta, param, param$1, param$2);
                              });
                          }))(env$6, Term$ReactTemplate.mkArity(/* tuple */[
                            match[0],
                            match$2[0]
                          ]), Term$ReactTemplate.mkArity(/* tuple */[
                            match$1[0],
                            match$2[1]
                          ]));
          };
          var mind = Names$ReactTemplate.MutInd[/* make1 */1](kn1);
          var check_cons_types = function (_, cst, p1, p2) {
            return Util$ReactTemplate.$$Array[/* fold_left3 */41]((function (cst, id, t1, t2) {
                          return check_conv$1(/* NotConvertibleConstructorField */Block.__(2, [id]), cst, Declareops$ReactTemplate.inductive_is_polymorphic(mib1), (function (eta) {
                                          return (function (param, param$1, param$2) {
                                              return Reduction$ReactTemplate.infer_conv(/* None */0, /* None */0, /* None */0, eta, param, param$1, param$2);
                                            });
                                        }))(env$6, t1, t2);
                        }), cst, p2[/* mind_consnames */3], Inductive$ReactTemplate.arities_of_specif(/* tuple */[
                            mind,
                            inst
                          ], /* tuple */[
                            mib1,
                            p1
                          ]), Inductive$ReactTemplate.arities_of_specif(/* tuple */[
                            mind,
                            inst
                          ], /* tuple */[
                            mib2$1,
                            p2
                          ]));
          };
          var check = function (f, test, why) {
            if (Curry._2(test, Curry._1(f, mib1), Curry._1(f, mib2$1))) {
              return 0;
            } else {
              var why$1 = Curry._1(why, Curry._1(f, mib2$1));
              return Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, why$1);
            }
          };
          check((function (mib) {
                  return +(mib[/* mind_finite */2] !== /* CoFinite */1);
                }), (function (prim, prim$1) {
                  return +(prim === prim$1);
                }), (function (x) {
                  return /* FiniteInductiveFieldExpected */Block.__(6, [x]);
                }));
          check((function (mib) {
                  return mib[/* mind_ntypes */3];
                }), (function (prim, prim$1) {
                  return +(prim === prim$1);
                }), (function (x) {
                  return /* InductiveNumbersFieldExpected */Block.__(7, [x]);
                }));
          if (!(Curry._1(Util$ReactTemplate.List[/* is_empty */45], mib1[/* mind_hyps */4]) && Curry._1(Util$ReactTemplate.List[/* is_empty */45], mib2$1[/* mind_hyps */4]))) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "subtyping.ml",
                    209,
                    2
                  ]
                ];
          }
          if (!(mib1[/* mind_packets */0].length >= 1 && mib2$1[/* mind_packets */0].length >= 1)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "subtyping.ml",
                    210,
                    2
                  ]
                ];
          }
          check((function (mib) {
                  return mib[/* mind_nparams */5];
                }), (function (prim, prim$1) {
                  return +(prim === prim$1);
                }), (function (x) {
                  return /* InductiveParamsNumberField */Block.__(8, [x]);
                }));
          var kn2$prime = Mod_subst$ReactTemplate.kn_of_delta(reso2$1, kn2);
          if (!(Names$ReactTemplate.KerName[/* equal */9](kn2, kn2$prime) || Names$ReactTemplate.MutInd[/* equal */12](Mod_subst$ReactTemplate.mind_of_delta_kn(reso1$1, kn1), Mod_subst$ReactTemplate.subst_mind(subst2$2, Names$ReactTemplate.MutInd[/* make */0](kn2, kn2$prime))))) {
            Modops$ReactTemplate.error_signature_mismatch(l$2, spec2$2, /* NotEqualInductiveAliases */6);
          }
          check((function (mib) {
                  return +(mib[/* mind_record */1] !== /* None */0);
                }), (function (prim, prim$1) {
                  return +(prim === prim$1);
                }), (function (x) {
                  return /* RecordFieldExpected */Block.__(9, [x]);
                }));
          if (mib1[/* mind_record */1] !== /* None */0) {
            var names_prod_letin = function (_t) {
              while(true) {
                var t = _t;
                var match = Constr$ReactTemplate.kind(t);
                switch (match.tag | 0) {
                  case 5 : 
                      _t = match[0];
                      continue ;
                      case 6 : 
                      return /* :: */[
                              match[0],
                              names_prod_letin(match[2])
                            ];
                  case 8 : 
                      return /* :: */[
                              match[0],
                              names_prod_letin(match[3])
                            ];
                  default:
                    return /* [] */0;
                }
              };
            };
            if (mib1[/* mind_packets */0].length !== 1) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "subtyping.ml",
                      237,
                      4
                    ]
                  ];
            }
            if (mib2$1[/* mind_packets */0].length !== 1) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "subtyping.ml",
                      238,
                      4
                    ]
                  ];
            }
            if (Caml_array.caml_array_get(mib1[/* mind_packets */0], 0)[/* mind_user_lc */4].length !== 1) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "subtyping.ml",
                      239,
                      4
                    ]
                  ];
            }
            if (Caml_array.caml_array_get(mib2$1[/* mind_packets */0], 0)[/* mind_user_lc */4].length !== 1) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "subtyping.ml",
                      240,
                      4
                    ]
                  ];
            }
            check((function (mib) {
                    var nparamdecls = Curry._1(Util$ReactTemplate.List[/* length */0], mib[/* mind_params_ctxt */7]);
                    var names = names_prod_letin(Caml_array.caml_array_get(Caml_array.caml_array_get(mib[/* mind_packets */0], 0)[/* mind_user_lc */4], 0));
                    return Curry._2(Util$ReactTemplate.List[/* chop */99], nparamdecls, names)[1];
                  }), Curry._1(Util$ReactTemplate.List[/* equal */44], Names$ReactTemplate.Name[/* equal */4]), (function (x) {
                    return /* RecordProjectionsExpected */Block.__(10, [x]);
                  }));
          }
          var cst$4 = Util$ReactTemplate.$$Array[/* fold_left2 */40](check_packet, cst$3, mib1[/* mind_packets */0], mib2$1[/* mind_packets */0]);
          return Util$ReactTemplate.$$Array[/* fold_left2_i */42](check_cons_types, cst$4, mib1[/* mind_packets */0], mib2$1[/* mind_packets */0]);
      case 2 : 
          var match$8 = get_mod(mp1, map1, l);
          if (match$8.tag) {
            return Modops$ReactTemplate.error_signature_mismatch(l, spec2, /* ModuleFieldExpected */1);
          } else {
            var cst$5 = cst;
            var env$7 = env;
            var msb1 = match$8[0];
            var msb2 = spec2[0];
            var subst1$3 = subst1;
            var subst2$3 = subst2;
            var mty1 = Modops$ReactTemplate.module_type_of_module(msb1);
            var mty2 = Modops$ReactTemplate.module_type_of_module(msb2);
            return check_modtypes(cst$5, env$7, mty1, mty2, subst1$3, subst2$3, /* false */0);
          }
          break;
      case 3 : 
          var mtb2 = spec2[0];
          var match$9 = get_mod(mp1, map1, l);
          var mtb1;
          mtb1 = match$9.tag ? match$9[0] : Modops$ReactTemplate.error_signature_mismatch(l, spec2, /* ModuleTypeFieldExpected */2);
          var env$8 = Modops$ReactTemplate.add_module_type(mtb2[/* mod_mp */0], mtb2, Modops$ReactTemplate.add_module_type(mtb1[/* mod_mp */0], mtb1, env));
          return check_modtypes(cst, env$8, mtb1, mtb2, subst1, subst2, /* true */1);
      
    }
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], check_one_body, cst, sig2);
}

function check_modtypes(cst, env, mtb1, mtb2, subst1, subst2, equiv) {
  if (mtb1 === mtb2 || mtb1[/* mod_type */2] === mtb2[/* mod_type */2]) {
    return cst;
  } else {
    var _cst = cst;
    var _env = env;
    var _str1 = mtb1[/* mod_type */2];
    var _str2 = mtb2[/* mod_type */2];
    var equiv$1 = equiv;
    var _subst1 = subst1;
    var subst2$1 = subst2;
    while(true) {
      var subst1$1 = _subst1;
      var str2 = _str2;
      var str1 = _str1;
      var env$1 = _env;
      var cst$1 = _cst;
      if (str1.tag) {
        var body_t1 = str1[2];
        if (str2.tag) {
          var arg_t2 = str2[1];
          var mp2 = /* MPbound */Block.__(1, [str2[0]]);
          var subst1$2 = Mod_subst$ReactTemplate.join(Mod_subst$ReactTemplate.map_mbid(str1[0], mp2, arg_t2[/* mod_delta */5]), subst1$1);
          var cst$2 = check_modtypes(cst$1, env$1, arg_t2, str1[1], subst2$1, subst1$2, equiv$1);
          var env$2 = Modops$ReactTemplate.add_module_type(mp2, arg_t2, env$1);
          var env$3 = Modops$ReactTemplate.is_functor(body_t1) ? env$2 : Modops$ReactTemplate.add_module(/* record */[
                  /* mod_mp */mtb1[/* mod_mp */0],
                  /* mod_expr : Abstract */0,
                  /* mod_type */Modops$ReactTemplate.subst_signature(subst1$2)(body_t1),
                  /* mod_type_alg : None */0,
                  /* mod_constraints */mtb1[/* mod_constraints */4],
                  /* mod_delta */mtb1[/* mod_delta */5],
                  /* mod_retroknowledge : ModBodyRK */[/* [] */0]
                ], env$2);
          _subst1 = subst1$2;
          _str2 = str2[2];
          _str1 = body_t1;
          _env = env$3;
          _cst = cst$2;
          continue ;
          
        } else {
          return Modops$ReactTemplate.error_incompatible_modtypes(mtb1, mtb2);
        }
      } else {
        var list1 = str1[0];
        if (str2.tag) {
          return Modops$ReactTemplate.error_incompatible_modtypes(mtb1, mtb2);
        } else {
          var list2 = str2[0];
          if (equiv$1) {
            var subst2$2 = Mod_subst$ReactTemplate.add_mp(mtb2[/* mod_mp */0], mtb1[/* mod_mp */0], mtb1[/* mod_delta */5], subst2$1);
            var cst1 = check_signatures(cst$1, env$1, mtb1[/* mod_mp */0], list1, mtb2[/* mod_mp */0], list2, subst1$1, subst2$2, mtb1[/* mod_delta */5], mtb2[/* mod_delta */5]);
            var cst2 = check_signatures(cst$1, env$1, mtb2[/* mod_mp */0], list2, mtb1[/* mod_mp */0], list1, subst2$2, subst1$1, mtb2[/* mod_delta */5], mtb1[/* mod_delta */5]);
            return Curry._2(Univ$ReactTemplate.Constraint[/* union */6], cst1, cst2);
          } else {
            return check_signatures(cst$1, env$1, mtb1[/* mod_mp */0], list1, mtb2[/* mod_mp */0], list2, subst1$1, subst2$1, mtb1[/* mod_delta */5], mtb2[/* mod_delta */5]);
          }
        }
      }
    };
  }
}

function check_subtypes(env, sup, $$super) {
  var env$1 = Modops$ReactTemplate.add_module_type(sup[/* mod_mp */0], sup, env);
  var env$2 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], $$super[/* mod_constraints */4], env$1);
  return check_modtypes(Univ$ReactTemplate.Constraint[/* empty */0], env$2, Modops$ReactTemplate.strengthen(sup, sup[/* mod_mp */0]), $$super, Mod_subst$ReactTemplate.empty_subst, Mod_subst$ReactTemplate.map_mp($$super[/* mod_mp */0], sup[/* mod_mp */0], sup[/* mod_delta */5]), /* false */0);
}

exports.check_subtypes = check_subtypes;
/* Pp-ReactTemplate Not a pure module */
