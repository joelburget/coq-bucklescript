// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("./pretype_errors.bs.js");

function normalize_evar(evd, ev) {
  var match = EConstr$ReactTemplate.kind(evd, EConstr$ReactTemplate.mkEvar(ev));
  if (match.tag === 3) {
    var match$1 = match[0];
    return /* tuple */[
            match$1[0],
            match$1[1]
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "evarsolve.ml",
            30,
            9
          ]
        ];
  }
}

function get_polymorphic_positions(sigma, f) {
  var match = EConstr$ReactTemplate.kind(sigma, f);
  var exit = 0;
  var ind;
  switch (match.tag | 0) {
    case 11 : 
        ind = match[0][0];
        exit = 1;
        break;
    case 12 : 
        ind = match[0][0][0];
        exit = 1;
        break;
    default:
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "evarsolve.ml",
              40,
              9
            ]
          ];
  }
  if (exit === 1) {
    var match$1 = Global$ReactTemplate.lookup_inductive(ind);
    var match$2 = match$1[1][/* mind_arity */2];
    if (match$2.tag) {
      return match$2[0][/* template_param_levels */0];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "evarsolve.ml",
              38,
              26
            ]
          ];
    }
  }
  
}

function refresh_universes($staropt$star, $staropt$star$1, $staropt$star$2, pbty, env, evd, t) {
  var status = $staropt$star ? $staropt$star[0] : Evd$ReactTemplate.univ_rigid;
  var onlyalg = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var refreshset = $staropt$star$2 ? $staropt$star$2[0] : /* false */0;
  var evdref = [evd];
  var modified = [/* false */0];
  var refresh_sort = function (status, direction, s) {
    var s$1 = EConstr$ReactTemplate.ESorts[/* kind */1](evdref[0], s);
    var s$prime = Evarutil$ReactTemplate.evd_comb0((function (param) {
            return Evd$ReactTemplate.new_sort_variable(/* None */0, /* None */0, status, param);
          }), evdref);
    var evd = direction ? Evd$ReactTemplate.set_leq_sort(env, evdref[0], s$prime, s$1) : Evd$ReactTemplate.set_leq_sort(env, evdref[0], s$1, s$prime);
    modified[0] = /* true */1;
    evdref[0] = evd;
    return EConstr$ReactTemplate.mkSort(s$prime);
  };
  var refresh = function (onlyalg, status, direction, t) {
    var match = EConstr$ReactTemplate.kind(evdref[0], t);
    switch (match.tag | 0) {
      case 4 : 
          var s = match[0];
          var match$1 = EConstr$ReactTemplate.ESorts[/* kind */1](evdref[0], s);
          if (match$1.tag) {
            var match$2 = Univ$ReactTemplate.universe_level(match$1[0]);
            if (match$2) {
              var l = match$2[0];
              var match$3 = Evd$ReactTemplate.universe_rigidity(evd, l);
              if (match$3) {
                if (onlyalg && match$3[0]) {
                  evdref[0] = Evd$ReactTemplate.make_flexible_variable(evdref[0], /* false */0, l);
                  return t;
                } else {
                  return t;
                }
              } else if (onlyalg) {
                return t;
              } else {
                return refresh_sort(status, direction, s);
              }
            } else {
              return refresh_sort(status, direction, s);
            }
          } else if (match$1[0] !== 0 || !(refreshset && !direction)) {
            return t;
          } else {
            return refresh_sort(status, direction, s);
          }
          break;
      case 6 : 
          return EConstr$ReactTemplate.mkProd(/* tuple */[
                      match[0],
                      match[1],
                      refresh(onlyalg, status, direction, match[2])
                    ]);
      default:
        return t;
    }
  };
  var refresh_term_evars = function (onevars, top, t) {
    var match = EConstr$ReactTemplate.kind(evdref[0], t);
    var exit = 0;
    switch (match.tag | 0) {
      case 3 : 
          if (onevars) {
            var ev = match[0][0];
            var evi = Evd$ReactTemplate.find(evdref[0], ev);
            var ty$prime = refresh(onlyalg, Evd$ReactTemplate.univ_flexible, /* true */1, EConstr$ReactTemplate.of_constr(evi[/* evar_concl */0]));
            if (modified[0]) {
              var newrecord = evi.slice();
              evdref[0] = Evd$ReactTemplate.add(evdref[0], ev, (newrecord[/* evar_concl */0] = EConstr$ReactTemplate.Unsafe[/* to_constr */0](ty$prime), newrecord));
              return /* () */0;
            } else {
              return /* () */0;
            }
          } else {
            exit = 1;
          }
          break;
      case 9 : 
          var args = match[1];
          var f = match[0];
          if (Termops$ReactTemplate.is_template_polymorphic(env, evdref[0], f)) {
            var pos = get_polymorphic_positions(evdref[0], f);
            var args$1 = args;
            var pos$1 = pos;
            var _i = 0;
            var _param = pos$1;
            while(true) {
              var param = _param;
              var i = _i;
              if (param) {
                if (param[0]) {
                  if (i < args$1.length) {
                    refresh_term_evars(/* true */1, /* false */0, Caml_array.caml_array_get(args$1, i));
                  }
                  _param = param[1];
                  _i = i + 1 | 0;
                  continue ;
                  
                } else {
                  if (i < args$1.length) {
                    refresh_term_evars(/* false */0, /* false */0, Caml_array.caml_array_get(args$1, i));
                  }
                  _param = param[1];
                  _i = i + 1 | 0;
                  continue ;
                  
                }
              } else {
                return /* () */0;
              }
            };
          } else if (top && EConstr$ReactTemplate.isEvar(evdref[0], f)) {
            refresh_term_evars(/* true */1, /* false */0, f);
            return Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                          return refresh_term_evars(onevars, /* false */0, param);
                        }), args);
          } else {
            exit = 1;
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      return EConstr$ReactTemplate.iter(evdref[0], (function (param) {
                    return refresh_term_evars(onevars, /* false */0, param);
                  }), t);
    }
    
  };
  var t$prime = EConstr$ReactTemplate.isArity(evdref[0], t) ? (
      pbty ? refresh(onlyalg, status, pbty[0], t) : refresh(/* true */1, Evd$ReactTemplate.univ_flexible, /* false */0, t)
    ) : (refresh_term_evars(/* false */0, /* true */1, t), t);
  if (modified[0]) {
    return /* tuple */[
            evdref[0],
            t$prime
          ];
  } else {
    return /* tuple */[
            evdref[0],
            t
          ];
  }
}

function get_type_of_refresh($staropt$star, $staropt$star$1, env, sigma, c) {
  var polyprop = $staropt$star ? $staropt$star[0] : /* true */1;
  var lax = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var ty = Retyping$ReactTemplate.get_type_of(/* Some */[polyprop], /* Some */[lax], env, sigma, c);
  return refresh_universes(/* None */0, /* None */0, /* None */0, /* Some */[/* false */0], env, sigma, ty);
}

function is_success(param) {
  if (param.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function add_conv_oriented_pb($staropt$star, param, evd) {
  var env = param[1];
  var pbty = param[0];
  var tail = $staropt$star ? $staropt$star[0] : /* true */1;
  var t1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](param[2]);
  var t2 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](param[3]);
  if (pbty) {
    if (pbty[0] !== 0) {
      return Evd$ReactTemplate.add_conv_pb(/* Some */[tail], /* tuple */[
                  /* CUMUL */1,
                  env,
                  t1,
                  t2
                ], evd);
    } else {
      return Evd$ReactTemplate.add_conv_pb(/* Some */[tail], /* tuple */[
                  /* CUMUL */1,
                  env,
                  t2,
                  t1
                ], evd);
    }
  } else {
    return Evd$ReactTemplate.add_conv_pb(/* Some */[tail], /* tuple */[
                /* CONV */0,
                env,
                t1,
                t2
              ], evd);
  }
}

var IllTypedInstance = Caml_exceptions.create("Evarsolve-ReactTemplate.IllTypedInstance");

function recheck_applications(conv_algo, env, evdref, t) {
  var aux = function (env, t) {
    var match = EConstr$ReactTemplate.kind(evdref[0], t);
    if (match.tag === 9) {
      var args = match[1];
      var f = match[0];
      aux(env, f);
      var fty = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, evdref[0], f);
      var argsty = Util$ReactTemplate.$$Array[/* map */12]((function (x) {
              aux(env, x);
              return Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, evdref[0], x);
            }), args);
      var _i = 0;
      var _ty = fty;
      while(true) {
        var ty = _ty;
        var i = _i;
        if (i < argsty.length) {
          var match$1 = EConstr$ReactTemplate.kind(evdref[0], Reductionops$ReactTemplate.whd_all(env)(evdref[0], ty));
          if (match$1.tag === 6) {
            var dom = match$1[1];
            var match$2 = Curry._5(conv_algo, env, evdref[0], /* CUMUL */1, Caml_array.caml_array_get(argsty, i), dom);
            if (match$2.tag) {
              return Pretype_errors$ReactTemplate.error_cannot_unify(/* None */0, env, match$2[0], /* Some */[match$2[1]], /* tuple */[
                          Caml_array.caml_array_get(argsty, i),
                          dom
                        ]);
            } else {
              evdref[0] = match$2[0];
              _ty = EConstr$ReactTemplate.Vars[/* subst1 */4](Caml_array.caml_array_get(args, i), match$1[2]);
              _i = i + 1 | 0;
              continue ;
              
            }
          } else {
            throw [
                  IllTypedInstance,
                  env,
                  ty,
                  Caml_array.caml_array_get(argsty, i)
                ];
          }
        } else {
          return /* () */0;
        }
      };
    } else {
      return EConstr$ReactTemplate.iter_with_full_binders(evdref[0], EConstr$ReactTemplate.push_rel, aux, env, t);
    }
  };
  return aux(env, t);
}

function inst_of_vars(sign) {
  var partial_arg = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
  return Util$ReactTemplate.$$Array[/* map_of_list */45]((function (param) {
                return Util$ReactTemplate.$percent$great(partial_arg, EConstr$ReactTemplate.mkVar, param);
              }), sign);
}

function restrict_evar_key(evd, evk, filter, candidates) {
  var exit = 0;
  if (filter) {
    exit = 1;
  } else if (candidates) {
    exit = 1;
  } else {
    return /* tuple */[
            evd,
            evk
          ];
  }
  if (exit === 1) {
    var evi = Evd$ReactTemplate.find_undefined(evd, evk);
    var oldfilter = Evd$ReactTemplate.evar_filter(evi);
    var exit$1 = 0;
    if (filter) {
      if (candidates) {
        exit$1 = 2;
      } else if (Evd$ReactTemplate.Filter[/* equal */0](oldfilter, filter[0])) {
        return /* tuple */[
                evd,
                evk
              ];
      } else {
        exit$1 = 2;
      }
    } else {
      exit$1 = 2;
    }
    if (exit$1 === 2) {
      var filter$1 = filter ? filter[0] : Evd$ReactTemplate.evar_filter(evi);
      var candidates$1 = candidates ? /* Some */[candidates[0]] : Option$ReactTemplate.map((function (l) {
                return Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, l);
              }), evi[/* evar_candidates */5]);
      return Evarutil$ReactTemplate.restrict_evar(evd, evk, filter$1, /* None */0, candidates$1);
    }
    
  }
  
}

function restrict_applied_evar(evd, param, filter, candidates) {
  var argsv = param[1];
  var evk = param[0];
  var match = restrict_evar_key(evd, evk, filter, candidates);
  var evd$1 = match[0];
  var newargsv;
  if (filter) {
    var evi = Evd$ReactTemplate.find(evd$1, evk);
    var subfilter = Evd$ReactTemplate.Filter[/* compose */5](Evd$ReactTemplate.evar_filter(evi), filter[0]);
    newargsv = Evd$ReactTemplate.Filter[/* filter_array */3](subfilter, argsv);
  } else {
    newargsv = argsv;
  }
  return /* tuple */[
          evd$1,
          /* tuple */[
            match[1],
            newargsv
          ]
        ];
}

function restrict_evar(evd, evk, filter, candidates) {
  return restrict_evar_key(evd, evk, filter, candidates)[0];
}

function restrict_instance(evd, evk, filter, argsv) {
  if (filter) {
    var evi = Evd$ReactTemplate.find(evd, evk);
    return Evd$ReactTemplate.Filter[/* filter_array */3](Evd$ReactTemplate.Filter[/* compose */5](Evd$ReactTemplate.evar_filter(evi), filter[0]), argsv);
  } else {
    return argsv;
  }
}

function noccur_evar(env, evd, evk, c) {
  var cache = [Int$ReactTemplate.$$Set[/* empty */0]];
  var occur_rec = function (_check_types, acc, _c) {
    while(true) {
      var c = _c;
      var check_types = _check_types;
      var k = acc[0];
      var match = EConstr$ReactTemplate.kind(evd, c);
      var exit = 0;
      switch (match.tag | 0) {
        case 0 : 
            var i = match[0];
            if (i > k) {
              if (Curry._2(Int$ReactTemplate.$$Set[/* mem */2], i - k | 0, cache[0])) {
                return 0;
              } else {
                var decl = Environ$ReactTemplate.lookup_rel(i, acc[1]);
                if (check_types) {
                  cache[0] = Curry._2(Int$ReactTemplate.$$Set[/* add */3], i - k | 0, cache[0]);
                  occur_rec(/* false */0, acc, EConstr$ReactTemplate.Vars[/* lift */0](i, EConstr$ReactTemplate.of_constr(Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl))));
                }
                if (decl.tag) {
                  cache[0] = Curry._2(Int$ReactTemplate.$$Set[/* add */3], i - k | 0, cache[0]);
                  _c = EConstr$ReactTemplate.Vars[/* lift */0](i, EConstr$ReactTemplate.of_constr(decl[1]));
                  _check_types = /* false */0;
                  continue ;
                  
                } else {
                  return /* () */0;
                }
              }
            } else {
              exit = 1;
            }
            break;
        case 3 : 
            var ev$prime = match[0];
            if (Evar$ReactTemplate.equal(evk, ev$prime[0])) {
              throw Termops$ReactTemplate.Occur;
            } else {
              if (check_types) {
                occur_rec(/* false */0, acc, EConstr$ReactTemplate.existential_type(evd, ev$prime));
              }
              return Util$ReactTemplate.$$Array[/* iter */11]((function(check_types){
                        return function (param) {
                          return occur_rec(check_types, acc, param);
                        }
                        }(check_types)), ev$prime[1]);
            }
            break;
        case 16 : 
            _c = match[1];
            _check_types = /* true */1;
            continue ;
            default:
          exit = 1;
      }
      if (exit === 1) {
        return EConstr$ReactTemplate.iter_with_full_binders(evd, (function (rd, param) {
                      return /* tuple */[
                              param[0] + 1 | 0,
                              EConstr$ReactTemplate.push_rel(rd, param[1])
                            ];
                    }), (function(check_types){
                  return function (param, param$1) {
                    return occur_rec(check_types, param, param$1);
                  }
                  }(check_types)), acc, c);
      }
      
    };
  };
  try {
    occur_rec(/* false */0, /* tuple */[
          0,
          env
        ], c);
    return /* true */1;
  }
  catch (exn){
    if (exn === Termops$ReactTemplate.Occur) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function of_alias(param) {
  if (param.tag) {
    return EConstr$ReactTemplate.mkVar(param[0]);
  } else {
    return EConstr$ReactTemplate.mkRel(param[0]);
  }
}

function to_alias(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 0 : 
        return /* Some */[/* RelAlias */Block.__(0, [match[0]])];
    case 1 : 
        return /* Some */[/* VarAlias */Block.__(1, [match[0]])];
    default:
      return /* None */0;
  }
}

function is_alias(sigma, c, alias) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 0 : 
        if (alias.tag) {
          return /* false */0;
        } else {
          return +(match[0] === alias[0]);
        }
        break;
    case 1 : 
        if (alias.tag) {
          return Names$ReactTemplate.Id[/* equal */0](match[0], alias[0]);
        } else {
          return /* false */0;
        }
        break;
    default:
      return /* false */0;
  }
}

function eq_alias(a, b) {
  if (a.tag) {
    if (b.tag) {
      return Names$ReactTemplate.Id[/* equal */0](a[0], b[0]);
    } else {
      return /* false */0;
    }
  } else if (b.tag) {
    return /* false */0;
  } else {
    return +(b[0] === a[0]);
  }
}

var empty_aliasing = /* tuple */[
  /* None */0,
  /* [] */0
];

function push_alias(param, a) {
  return /* tuple */[
          param[0],
          /* :: */[
            a,
            param[1]
          ]
        ];
}

function lift_aliasing(n, param) {
  var map = function (a) {
    if (a.tag) {
      return a;
    } else {
      return /* RelAlias */Block.__(0, [a[0] + n | 0]);
    }
  };
  return /* tuple */[
          Option$ReactTemplate.map((function (c) {
                  return EConstr$ReactTemplate.Vars[/* lift */0](n, c);
                }), param[0]),
          Curry._2(Util$ReactTemplate.List[/* map */10], map, param[1])
        ];
}

function compute_var_aliases(sign, sigma) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, aliases) {
                var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl);
                if (decl.tag) {
                  var t = decl[1];
                  var match = EConstr$ReactTemplate.kind(sigma, t);
                  if (match.tag === 1) {
                    var id$prime = match[0];
                    var aliases_of_id;
                    try {
                      aliases_of_id = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$prime, aliases);
                    }
                    catch (exn){
                      if (exn === Caml_builtin_exceptions.not_found) {
                        aliases_of_id = empty_aliasing;
                      } else {
                        throw exn;
                      }
                    }
                    return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, push_alias(aliases_of_id, /* VarAlias */Block.__(1, [id$prime])), aliases);
                  } else {
                    return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, /* tuple */[
                                /* Some */[t],
                                /* [] */0
                              ], aliases);
                  }
                } else {
                  return aliases;
                }
              }), sign, Names$ReactTemplate.Id[/* Map */10][/* empty */0]);
}

function compute_rel_aliases(var_aliases, rels, sigma) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, param) {
                  var aliases = param[1];
                  var n = param[0];
                  var tmp;
                  if (decl.tag) {
                    var t = decl[1];
                    var match = EConstr$ReactTemplate.kind(sigma, t);
                    switch (match.tag | 0) {
                      case 0 : 
                          var p = match[0];
                          var aliases_of_n;
                          try {
                            aliases_of_n = Int$ReactTemplate.$$Map[/* find */21](p + n | 0, aliases);
                          }
                          catch (exn){
                            if (exn === Caml_builtin_exceptions.not_found) {
                              aliases_of_n = empty_aliasing;
                            } else {
                              throw exn;
                            }
                          }
                          tmp = Curry._3(Int$ReactTemplate.$$Map[/* add */3], n, push_alias(aliases_of_n, /* RelAlias */Block.__(0, [p + n | 0])), aliases);
                          break;
                      case 1 : 
                          var id$prime = match[0];
                          var aliases_of_n$1;
                          try {
                            aliases_of_n$1 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$prime, var_aliases);
                          }
                          catch (exn$1){
                            if (exn$1 === Caml_builtin_exceptions.not_found) {
                              aliases_of_n$1 = empty_aliasing;
                            } else {
                              throw exn$1;
                            }
                          }
                          tmp = Curry._3(Int$ReactTemplate.$$Map[/* add */3], n, push_alias(aliases_of_n$1, /* VarAlias */Block.__(1, [id$prime])), aliases);
                          break;
                      default:
                        var c = EConstr$ReactTemplate.Vars[/* lift */0](n, EConstr$ReactTemplate.mkCast(/* tuple */[
                                  t,
                                  /* DEFAULTcast */2,
                                  decl[2]
                                ]));
                        tmp = Curry._3(Int$ReactTemplate.$$Map[/* add */3], n, /* tuple */[
                              /* Some */[c],
                              /* [] */0
                            ], aliases);
                    }
                  } else {
                    tmp = aliases;
                  }
                  return /* tuple */[
                          n - 1 | 0,
                          tmp
                        ];
                }), rels, /* tuple */[
                Curry._1(Util$ReactTemplate.List[/* length */0], rels),
                Int$ReactTemplate.$$Map[/* empty */0]
              ])[1];
}

function make_alias_map(env, sigma) {
  var var_aliases = compute_var_aliases(EConstr$ReactTemplate.named_context(env), sigma);
  var rel_aliases = compute_rel_aliases(var_aliases, EConstr$ReactTemplate.rel_context(env), sigma);
  return /* record */[
          /* rel_aliases */rel_aliases,
          /* var_aliases */var_aliases
        ];
}

function lift_aliases(n, aliases) {
  if (n) {
    var rel_aliases = Curry._3(Int$ReactTemplate.$$Map[/* fold */10], (function (p, l) {
            return Curry._2(Int$ReactTemplate.$$Map[/* add */3], p + n | 0, lift_aliasing(n, l));
          }), aliases[/* rel_aliases */0], Int$ReactTemplate.$$Map[/* empty */0]);
    return /* record */[
            /* rel_aliases */rel_aliases,
            /* var_aliases */aliases[/* var_aliases */1]
          ];
  } else {
    return aliases;
  }
}

function get_alias_chain_of(_, aliases, x) {
  if (x.tag) {
    try {
      return Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x[0], aliases[/* var_aliases */1]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return empty_aliasing;
      } else {
        throw exn;
      }
    }
  } else {
    try {
      return Int$ReactTemplate.$$Map[/* find */21](x[0], aliases[/* rel_aliases */0]);
    }
    catch (exn$1){
      if (exn$1 === Caml_builtin_exceptions.not_found) {
        return empty_aliasing;
      } else {
        throw exn$1;
      }
    }
  }
}

function normalize_alias_opt_alias(sigma, aliases, x) {
  var match = get_alias_chain_of(sigma, aliases, x);
  var match$1 = match[1];
  if (match$1) {
    return /* Some */[match$1[0]];
  } else {
    return /* None */0;
  }
}

function normalize_alias_opt(sigma, aliases, x) {
  var match = to_alias(sigma, x);
  if (match) {
    return normalize_alias_opt_alias(sigma, aliases, match[0]);
  } else {
    return /* None */0;
  }
}

function normalize_alias(sigma, aliases, x) {
  var match = normalize_alias_opt_alias(sigma, aliases, x);
  if (match) {
    return match[0];
  } else {
    return x;
  }
}

function normalize_alias_var(sigma, var_aliases, id) {
  var aliases_000 = /* rel_aliases */Int$ReactTemplate.$$Map[/* empty */0];
  var aliases = /* record */[
    aliases_000,
    /* var_aliases */var_aliases
  ];
  var match = normalize_alias(sigma, aliases, /* VarAlias */Block.__(1, [id]));
  if (match.tag) {
    return match[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "evarsolve.ml",
            374,
            18
          ]
        ];
  }
}

function extend_alias(sigma, decl, param) {
  var var_aliases = param[/* var_aliases */1];
  var rel_aliases = Curry._3(Int$ReactTemplate.$$Map[/* fold */10], (function (n, l) {
          return Curry._2(Int$ReactTemplate.$$Map[/* add */3], n + 1 | 0, lift_aliasing(1, l));
        }), param[/* rel_aliases */0], Int$ReactTemplate.$$Map[/* empty */0]);
  var rel_aliases$1;
  if (decl.tag) {
    var t = decl[1];
    var match = EConstr$ReactTemplate.kind(sigma, t);
    switch (match.tag | 0) {
      case 0 : 
          var p = match[0];
          var aliases_of_binder;
          try {
            aliases_of_binder = Int$ReactTemplate.$$Map[/* find */21](p + 1 | 0, rel_aliases);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              aliases_of_binder = empty_aliasing;
            } else {
              throw exn;
            }
          }
          rel_aliases$1 = Curry._3(Int$ReactTemplate.$$Map[/* add */3], 1, push_alias(aliases_of_binder, /* RelAlias */Block.__(0, [p + 1 | 0])), rel_aliases);
          break;
      case 1 : 
          var id$prime = match[0];
          var aliases_of_binder$1;
          try {
            aliases_of_binder$1 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$prime, var_aliases);
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              aliases_of_binder$1 = empty_aliasing;
            } else {
              throw exn$1;
            }
          }
          rel_aliases$1 = Curry._3(Int$ReactTemplate.$$Map[/* add */3], 1, push_alias(aliases_of_binder$1, /* VarAlias */Block.__(1, [id$prime])), rel_aliases);
          break;
      default:
        var c = EConstr$ReactTemplate.Vars[/* lift */0](1, t);
        rel_aliases$1 = Curry._3(Int$ReactTemplate.$$Map[/* add */3], 1, /* tuple */[
              /* Some */[c],
              /* [] */0
            ], rel_aliases);
    }
  } else {
    rel_aliases$1 = rel_aliases;
  }
  return /* record */[
          /* rel_aliases */rel_aliases$1,
          /* var_aliases */var_aliases
        ];
}

function expand_alias_once(sigma, aliases, x) {
  var match = get_alias_chain_of(sigma, aliases, x);
  var match$1 = match[0];
  if (match$1) {
    if (match[1]) {
      return /* Some */[of_alias(Curry._1(Util$ReactTemplate.List[/* last */105], match[1]))];
    } else {
      return /* Some */[match$1[0]];
    }
  } else if (match[1]) {
    return /* Some */[of_alias(Curry._1(Util$ReactTemplate.List[/* last */105], match[1]))];
  } else {
    return /* None */0;
  }
}

function expansions_of_var(sigma, aliases, x) {
  var match = get_alias_chain_of(sigma, aliases, x);
  return /* :: */[
          x,
          Curry._1(Util$ReactTemplate.List[/* rev */4], match[1])
        ];
}

function expansion_of_var(sigma, aliases, x) {
  var match = get_alias_chain_of(sigma, aliases, x);
  var match$1 = match[0];
  if (match$1) {
    return /* tuple */[
            /* true */1,
            match$1[0]
          ];
  } else {
    var match$2 = match[1];
    if (match$2) {
      return /* tuple */[
              /* true */1,
              of_alias(match$2[0])
            ];
    } else {
      return /* tuple */[
              /* false */0,
              of_alias(x)
            ];
    }
  }
}

function expand_vars_in_term_using(sigma, aliases, t) {
  var match = EConstr$ReactTemplate.kind(sigma, t);
  switch (match.tag | 0) {
    case 0 : 
        return of_alias(normalize_alias(sigma, aliases, /* RelAlias */Block.__(0, [match[0]])));
    case 1 : 
        return of_alias(normalize_alias(sigma, aliases, /* VarAlias */Block.__(1, [match[0]])));
    default:
      var self = function (aliases, c) {
        return expand_vars_in_term_using(sigma, aliases, c);
      };
      return Termops$ReactTemplate.map_constr_with_full_binders(sigma, (function (param, param$1) {
                    return extend_alias(sigma, param, param$1);
                  }), self, aliases, t);
  }
}

function expand_vars_in_term(env, sigma) {
  var partial_arg = make_alias_map(env, sigma);
  return (function (param) {
      return expand_vars_in_term_using(sigma, partial_arg, param);
    });
}

function free_vars_and_rels_up_alias_expansion(sigma, aliases, c) {
  var acc1 = [Int$ReactTemplate.$$Set[/* empty */0]];
  var acc2 = [Names$ReactTemplate.Id[/* Set */9][/* empty */0]];
  var acc3 = [Int$ReactTemplate.$$Set[/* empty */0]];
  var acc4 = [Names$ReactTemplate.Id[/* Set */9][/* empty */0]];
  var cache_rel = [Int$ReactTemplate.$$Set[/* empty */0]];
  var cache_var = [Names$ReactTemplate.Id[/* Set */9][/* empty */0]];
  var is_in_cache = function (depth, param) {
    if (param.tag) {
      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], param[0], cache_var[0]);
    } else {
      return Curry._2(Int$ReactTemplate.$$Set[/* mem */2], param[0] - depth | 0, cache_rel[0]);
    }
  };
  var put_in_cache = function (depth, param) {
    if (param.tag) {
      cache_var[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], param[0], cache_var[0]);
      return /* () */0;
    } else {
      cache_rel[0] = Curry._2(Int$ReactTemplate.$$Set[/* add */3], param[0] - depth | 0, cache_rel[0]);
      return /* () */0;
    }
  };
  var frec = function (_param, c) {
    while(true) {
      var param = _param;
      var depth = param[1];
      var aliases = param[0];
      var ck = EConstr$ReactTemplate.kind(sigma, c);
      var exit = 0;
      switch (ck.tag | 0) {
        case 0 : 
        case 1 : 
            exit = 1;
            break;
        case 10 : 
        case 11 : 
        case 12 : 
            exit = 2;
            break;
        default:
          return EConstr$ReactTemplate.iter_with_full_binders(sigma, (function (d, param) {
                        return /* tuple */[
                                extend_alias(sigma, d, param[0]),
                                param[1] + 1 | 0
                              ];
                      }), frec, /* tuple */[
                      aliases,
                      depth
                    ], c);
      }
      switch (exit) {
        case 1 : 
            var ck$1;
            switch (ck.tag | 0) {
              case 0 : 
                  ck$1 = /* RelAlias */Block.__(0, [ck[0]]);
                  break;
              case 1 : 
                  ck$1 = /* VarAlias */Block.__(1, [ck[0]]);
                  break;
              default:
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "evarsolve.ml",
                        440,
                        13
                      ]
                    ];
            }
            if (is_in_cache(depth, ck$1)) {
              return /* () */0;
            } else {
              put_in_cache(depth, ck$1);
              var match = expansion_of_var(sigma, aliases, ck$1);
              if (match[0]) {
                if (ck$1.tag) {
                  acc4[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], ck$1[0], acc4[0]);
                } else {
                  var n = ck$1[0];
                  if (n >= (depth + 1 | 0)) {
                    acc3[0] = Curry._2(Int$ReactTemplate.$$Set[/* add */3], n - depth | 0, acc3[0]);
                  }
                  
                }
              }
              var match$1 = EConstr$ReactTemplate.kind(sigma, match[1]);
              switch (match$1.tag | 0) {
                case 0 : 
                    var n$1 = match$1[0];
                    if (n$1 >= (depth + 1 | 0)) {
                      acc1[0] = Curry._2(Int$ReactTemplate.$$Set[/* add */3], n$1 - depth | 0, acc1[0]);
                      return /* () */0;
                    } else {
                      return 0;
                    }
                case 1 : 
                    acc2[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], match$1[0], acc2[0]);
                    return /* () */0;
                default:
                  _param = /* tuple */[
                    aliases,
                    depth
                  ];
                  continue ;
                  
              }
            }
            break;
        case 2 : 
            acc2[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], Environ$ReactTemplate.vars_of_global(Global$ReactTemplate.env(/* () */0), EConstr$ReactTemplate.to_constr(sigma, c)), acc2[0]);
            return /* () */0;
        
      }
    };
  };
  frec(/* tuple */[
        aliases,
        0
      ], c);
  return /* tuple */[
          acc1[0],
          acc2[0],
          acc3[0],
          acc4[0]
        ];
}

function expand_and_check_vars(sigma, aliases, l) {
  var map = function (a) {
    var match = get_alias_chain_of(sigma, aliases, a);
    if (match[0]) {
      return /* None */0;
    } else {
      var match$1 = match[1];
      if (match$1) {
        return /* Some */[match$1[0]];
      } else {
        return /* Some */[a];
      }
    }
  };
  return Option$ReactTemplate.List[/* map */3](map, l);
}

function alias_distinct(l) {
  var _param = /* tuple */[
    Int$ReactTemplate.$$Set[/* empty */0],
    Names$ReactTemplate.Id[/* Set */9][/* empty */0]
  ];
  var _param$1 = l;
  while(true) {
    var param = _param$1;
    var param$1 = _param;
    if (param) {
      var match = param[0];
      var vars = param$1[1];
      var rels = param$1[0];
      if (match.tag) {
        var id = match[0];
        if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, vars)) {
          return /* false */0;
        } else {
          _param$1 = param[1];
          _param = /* tuple */[
            rels,
            Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, vars)
          ];
          continue ;
          
        }
      } else {
        var n = match[0];
        if (Curry._2(Int$ReactTemplate.$$Set[/* mem */2], n, rels)) {
          return /* false */0;
        } else {
          _param$1 = param[1];
          _param = /* tuple */[
            Curry._2(Int$ReactTemplate.$$Set[/* add */3], n, rels),
            vars
          ];
          continue ;
          
        }
      }
    } else {
      return /* true */1;
    }
  };
}

function get_actual_deps(evd, aliases, l, t) {
  if (Termops$ReactTemplate.occur_meta_or_existential(evd, t)) {
    return l;
  } else {
    var match = free_vars_and_rels_up_alias_expansion(evd, aliases, t);
    var fv_ids = match[1];
    var fv_rels = match[0];
    return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                  if (param.tag) {
                    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], param[0], fv_ids);
                  } else {
                    return Curry._2(Int$ReactTemplate.$$Set[/* mem */2], param[0], fv_rels);
                  }
                }), l);
  }
}

function remove_instance_local_defs(evd, evk, args) {
  var evi = Evd$ReactTemplate.find(evd, evk);
  var len = args.length;
  var aux = function (_sign, _i) {
    while(true) {
      var i = _i;
      var sign = _sign;
      if (sign) {
        if (sign[0].tag) {
          _i = i + 1 | 0;
          _sign = sign[1];
          continue ;
          
        } else {
          if (i >= len) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "evarsolve.ml",
                    505,
                    13
                  ]
                ];
          }
          return /* :: */[
                  args[i],
                  aux(sign[1], i + 1 | 0)
                ];
        }
      } else {
        if (i !== len) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "evarsolve.ml",
                  503,
                  13
                ]
              ];
        }
        return /* [] */0;
      }
    };
  };
  return aux(Evd$ReactTemplate.evar_filtered_context(evi), 0);
}

function find_unification_pattern_args(env, evd, l, t) {
  var aliases = make_alias_map(env, evd);
  var x = expand_and_check_vars(evd, aliases, l);
  if (x && alias_distinct(get_actual_deps(evd, aliases, x[0], t))) {
    return x;
  } else {
    return /* None */0;
  }
}

function is_unification_pattern_evar(env, evd, param, l, t) {
  var evk = param[0];
  var match = Option$ReactTemplate.List[/* map */3]((function (c) {
          return to_alias(evd, c);
        }), l);
  if (match) {
    if (noccur_evar(env, evd, evk, t)) {
      var args = remove_instance_local_defs(evd, evk, param[1]);
      var args$1 = Option$ReactTemplate.List[/* map */3]((function (c) {
              return to_alias(evd, c);
            }), args);
      if (args$1) {
        var args$2 = args$1[0];
        var n = Curry._1(Util$ReactTemplate.List[/* length */0], args$2);
        var match$1 = find_unification_pattern_args(env, evd, Util$ReactTemplate.$at(args$2, match[0]), t);
        if (match$1) {
          return /* Some */[Curry._2(Util$ReactTemplate.List[/* skipn */107], n, match$1[0])];
        } else {
          return /* None */0;
        }
      } else {
        return /* None */0;
      }
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function is_unification_pattern_pure_evar(env, evd, param, t) {
  var is_ev = is_unification_pattern_evar(env, evd, /* tuple */[
        param[0],
        param[1]
      ], /* [] */0, t);
  if (is_ev) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_unification_pattern(param, evd, f, l, t) {
  var env = param[0];
  var match = EConstr$ReactTemplate.kind(evd, f);
  switch (match.tag | 0) {
    case 2 : 
        var env$1 = env;
        var evd$1 = evd;
        var nb = param[1];
        var m = match[0];
        var l$1 = l;
        var t$1 = t;
        var map = function (a) {
          var match = EConstr$ReactTemplate.kind(evd$1, a);
          if (match.tag) {
            return /* None */0;
          } else {
            var n = match[0];
            if (n <= nb) {
              return /* Some */[/* RelAlias */Block.__(0, [n])];
            } else {
              return /* None */0;
            }
          }
        };
        var match$1 = Option$ReactTemplate.List[/* map */3](map, l$1);
        if (match$1) {
          var x = find_unification_pattern_args(env$1, evd$1, match$1[0], t$1);
          if (x && !Termops$ReactTemplate.dependent(evd$1, EConstr$ReactTemplate.mkMeta(m), t$1)) {
            return x;
          } else {
            return /* None */0;
          }
        } else {
          return /* None */0;
        }
    case 3 : 
        return is_unification_pattern_evar(env, evd, match[0], l, t);
    default:
      return /* None */0;
  }
}

function solve_pattern_eqn(env, sigma, l, c) {
  return Reductionops$ReactTemplate.shrink_eta(Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (a, c) {
                    var c$prime = Termops$ReactTemplate.subst_term(sigma, EConstr$ReactTemplate.Vars[/* lift */0](1, of_alias(a)), EConstr$ReactTemplate.Vars[/* lift */0](1, c));
                    if (a.tag) {
                      var d = EConstr$ReactTemplate.lookup_named(a[0], env);
                      return EConstr$ReactTemplate.mkNamedLambda_or_LetIn(d, c$prime);
                    } else {
                      var n = a[0];
                      var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
                      var d$1 = Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], (function (param) {
                              return partial_arg(n, param);
                            }), EConstr$ReactTemplate.lookup_rel(n, env));
                      return EConstr$ReactTemplate.mkLambda_or_LetIn(d$1, c$prime);
                    }
                  }), l, c));
}

function make_projectable_subst(aliases, sigma, evi, args) {
  var sign = Evd$ReactTemplate.evar_filtered_context(evi);
  var sign$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
          return Termops$ReactTemplate.map_named_decl(EConstr$ReactTemplate.of_constr, d);
        }), sign);
  var evar_aliases = compute_var_aliases(sign$1, sigma);
  var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, param) {
          var cstrs = param[2];
          var all = param[1];
          var args = param[0];
          if (decl.tag) {
            if (args) {
              var rest = args[1];
              var a = args[0];
              var id = decl[0];
              var match = EConstr$ReactTemplate.kind(sigma, decl[1]);
              if (match.tag === 1) {
                var idc = normalize_alias_var(sigma, evar_aliases, match[0]);
                var sub;
                try {
                  sub = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], idc, all);
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    sub = /* [] */0;
                  } else {
                    throw exn;
                  }
                }
                if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                          return EConstr$ReactTemplate.eq_constr(sigma, a, param[0]);
                        }), sub)) {
                  return /* tuple */[
                          rest,
                          all,
                          cstrs
                        ];
                } else {
                  return /* tuple */[
                          rest,
                          Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], idc, /* :: */[
                                /* tuple */[
                                  a,
                                  normalize_alias_opt(sigma, aliases, a),
                                  id
                                ],
                                sub
                              ], all),
                          cstrs
                        ];
                }
              } else {
                return /* tuple */[
                        rest,
                        Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, /* :: */[
                              /* tuple */[
                                a,
                                normalize_alias_opt(sigma, aliases, a),
                                id
                              ],
                              /* [] */0
                            ], all),
                        cstrs
                      ];
              }
            } else {
              return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Instance does not match its signature."));
            }
          } else if (args) {
            var a$1 = args[0];
            var id$1 = decl[0];
            var match$1 = Termops$ReactTemplate.decompose_app_vect(sigma, a$1);
            var match$2 = EConstr$ReactTemplate.kind(sigma, match$1[0]);
            var cstrs$1;
            if (match$2.tag === 12) {
              var cstr = match$2[0];
              var l;
              try {
                l = Curry._2(Names$ReactTemplate.Constrmap[/* find */21], cstr[0], cstrs);
              }
              catch (exn$1){
                if (exn$1 === Caml_builtin_exceptions.not_found) {
                  l = /* [] */0;
                } else {
                  throw exn$1;
                }
              }
              cstrs$1 = Curry._3(Names$ReactTemplate.Constrmap[/* add */3], cstr[0], /* :: */[
                    /* tuple */[
                      match$1[1],
                      id$1
                    ],
                    l
                  ], cstrs);
            } else {
              cstrs$1 = cstrs;
            }
            return /* tuple */[
                    args[1],
                    Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id$1, /* :: */[
                          /* tuple */[
                            a$1,
                            normalize_alias_opt(sigma, aliases, a$1),
                            id$1
                          ],
                          /* [] */0
                        ], all),
                    cstrs$1
                  ];
          } else {
            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Instance does not match its signature."));
          }
        }), sign$1, /* tuple */[
        Util$ReactTemplate.$$Array[/* rev_to_list */63](args),
        Names$ReactTemplate.Id[/* Map */10][/* empty */0],
        Names$ReactTemplate.Constrmap[/* empty */0]
      ]);
  return /* tuple */[
          match[1],
          match[2]
        ];
}

function define_evar_from_virtual_equation(define_fun, env, evd, src, t_in_env, ty_t_in_sign, sign, filter, inst_in_env) {
  var match = Evarutil$ReactTemplate.new_evar_instance(sign, evd, ty_t_in_sign, /* Some */[src], /* Some */[filter], /* None */0, /* None */0, /* None */0, /* None */0, inst_in_env);
  var evar_in_env = match[1];
  var evd$1 = match[0];
  var t_in_env$1 = Evarutil$ReactTemplate.whd_evar(evd$1, t_in_env);
  var match$1 = EConstr$ReactTemplate.destEvar(evd$1, evar_in_env);
  var evd$2 = Curry._5(define_fun, env, evd$1, /* None */0, EConstr$ReactTemplate.destEvar(evd$1, evar_in_env), t_in_env$1);
  var ctxt = EConstr$ReactTemplate.named_context_of_val(sign);
  var inst_in_sign = inst_of_vars(Evd$ReactTemplate.Filter[/* filter_list */2](filter, ctxt));
  var evar_in_sign = EConstr$ReactTemplate.mkEvar(/* tuple */[
        match$1[0],
        inst_in_sign
      ]);
  return /* tuple */[
          evd$2,
          Evarutil$ReactTemplate.whd_evar(evd$2, evar_in_sign)
        ];
}

var MorePreciseOccurCheckNeeeded = Caml_exceptions.create("Evarsolve-ReactTemplate.MorePreciseOccurCheckNeeeded");

function materialize_evar(define_fun, env, evd, k, param, ty_in_env) {
  var evk1 = param[0];
  if (Evd$ReactTemplate.is_defined(evd, evk1)) {
    throw MorePreciseOccurCheckNeeeded;
  }
  var match = EConstr$ReactTemplate.destEvar(evd, EConstr$ReactTemplate.mkEvar(/* tuple */[
            evk1,
            param[1]
          ]));
  var evk1$1 = match[0];
  var evi1 = Evd$ReactTemplate.find_undefined(evd, evk1$1);
  var match$1 = Termops$ReactTemplate.env_rel_context_chop(k, env);
  var sign1 = Evd$ReactTemplate.evar_hyps(evi1);
  var filter1 = Evd$ReactTemplate.evar_filter(evi1);
  var src = Evarutil$ReactTemplate.subterm_source(evk1$1, evi1[/* evar_source */4]);
  var ids1 = Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], EConstr$ReactTemplate.named_context_of_val(sign1));
  var avoid = Environ$ReactTemplate.ids_of_named_context_val(sign1);
  var inst_in_sign = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.mkVar, Evd$ReactTemplate.Filter[/* filter_list */2](filter1, ids1));
  var match$2 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (d, param) {
          var avoid = param[6];
          var evd = param[5];
          var env = param[4];
          var inst_in_env = param[2];
          var filter = param[1];
          var sign = param[0];
          var exit = 0;
          var na;
          var t_in_env;
          na = d[0];
          if (d.tag) {
            t_in_env = d[2];
            exit = 1;
          } else {
            t_in_env = d[1];
            exit = 1;
          }
          if (exit === 1) {
            var id = Namegen$ReactTemplate.next_name_away(na, avoid);
            var s = Retyping$ReactTemplate.get_sort_of(/* None */0, env, evd, t_in_env);
            var match = refresh_universes(/* Some */[Evd$ReactTemplate.univ_flexible], /* None */0, /* None */0, /* Some */[/* false */0], env, evd, EConstr$ReactTemplate.mkSort(s));
            var match$1 = define_evar_from_virtual_equation(define_fun, env, match[0], src, t_in_env, match[1], sign, filter, inst_in_env);
            var t_in_sign = match$1[1];
            var evd$1 = match$1[0];
            var match$2;
            if (d.tag) {
              var match$3 = define_evar_from_virtual_equation(define_fun, env, evd$1, src, d[1], t_in_sign, sign, filter, inst_in_env);
              match$2 = /* tuple */[
                match$3[0],
                /* LocalDef */Block.__(1, [
                    id,
                    match$3[1],
                    t_in_sign
                  ])
              ];
            } else {
              match$2 = /* tuple */[
                evd$1,
                /* LocalAssum */Block.__(0, [
                    id,
                    t_in_sign
                  ])
              ];
            }
            var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
            var partial_arg$1 = EConstr$ReactTemplate.Vars[/* lift */0];
            return /* tuple */[
                    EConstr$ReactTemplate.push_named_context_val(match$2[1], sign),
                    Evd$ReactTemplate.Filter[/* extend */4](1, filter),
                    /* :: */[
                      EConstr$ReactTemplate.mkRel(1),
                      Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                              return partial_arg(1, param);
                            }), inst_in_env)
                    ],
                    /* :: */[
                      EConstr$ReactTemplate.mkRel(1),
                      Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                              return partial_arg$1(1, param);
                            }), param[3])
                    ],
                    EConstr$ReactTemplate.push_rel(d, env),
                    match$2[0],
                    Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid)
                  ];
          }
          
        }), match$1[1], /* tuple */[
        sign1,
        filter1,
        Util$ReactTemplate.$$Array[/* to_list */9](match[1]),
        inst_in_sign,
        match$1[0],
        evd,
        avoid
      ]);
  var evd$1 = match$2[5];
  var inst2_in_env = match$2[2];
  var filter2 = match$2[1];
  var sign2 = match$2[0];
  var s = Retyping$ReactTemplate.get_sort_of(/* None */0, env, evd$1, ty_in_env);
  var match$3 = refresh_universes(/* Some */[Evd$ReactTemplate.univ_flexible], /* None */0, /* None */0, /* Some */[/* false */0], env, evd$1, EConstr$ReactTemplate.mkSort(s));
  var match$4 = define_evar_from_virtual_equation(define_fun, env, match$3[0], src, ty_in_env, match$3[1], sign2, filter2, inst2_in_env);
  var match$5 = Evarutil$ReactTemplate.new_evar_instance(sign2, match$4[0], match$4[1], /* Some */[src], /* Some */[filter2], /* None */0, /* None */0, /* None */0, /* None */0, match$2[3]);
  var ev2_in_sign = match$5[1];
  var evd$2 = match$5[0];
  var ev2_in_env_000 = EConstr$ReactTemplate.destEvar(evd$2, ev2_in_sign)[0];
  var ev2_in_env_001 = Util$ReactTemplate.$$Array[/* of_list */10](inst2_in_env);
  var ev2_in_env = /* tuple */[
    ev2_in_env_000,
    ev2_in_env_001
  ];
  return /* tuple */[
          evd$2,
          ev2_in_sign,
          ev2_in_env
        ];
}

function restrict_upon_filter(evd, evk, p, args) {
  var oldfullfilter = Evd$ReactTemplate.evar_filter(Evd$ReactTemplate.find_undefined(evd, evk));
  var len = args.length;
  return Evd$ReactTemplate.Filter[/* restrict_upon */7](oldfullfilter, len, (function (i) {
                return Curry._1(p, args[i]);
              }));
}

function find_projectable_constructor(env, evd, cstr, k, args, cstr_subst) {
  try {
    var l = Curry._2(Names$ReactTemplate.Constrmap[/* find */21], cstr, cstr_subst);
    var partial_arg = -k | 0;
    var partial_arg$1 = EConstr$ReactTemplate.Vars[/* lift */0];
    var args$1 = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
            return partial_arg$1(partial_arg, param);
          }), args);
    var l$1 = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
            return Util$ReactTemplate.$$Array[/* for_all2 */27]((function (c1, c2) {
                          return Reductionops$ReactTemplate.is_conv(/* None */0, env, evd)(c1, c2);
                        }), args$1, param[0]);
          }), l);
    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                  return prim[1];
                }), l$1);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

var NotUnique = Caml_exceptions.create("Evarsolve-ReactTemplate.NotUnique");

var NotUniqueInType = Caml_exceptions.create("Evarsolve-ReactTemplate.NotUniqueInType");

function assoc_up_to_alias(sigma, aliases, y, yc, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      var match = param[0];
      var id = match[2];
      var c = match[0];
      if (is_alias(sigma, c, y)) {
        return id;
      } else if (l) {
        _param = l;
        continue ;
        
      } else {
        var match$1 = normalize_alias_opt(sigma, aliases, c);
        var exit = 0;
        if (match$1) {
          if (eq_alias(yc, match$1[0])) {
            return id;
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          if (is_alias(sigma, c, yc)) {
            return id;
          } else {
            throw Caml_builtin_exceptions.not_found;
          }
        }
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_projectable_vars(with_evars, aliases, sigma, y, subst) {
  var yc = normalize_alias(sigma, aliases, y);
  var is_projectable = function (_, idcl, subst$prime) {
    try {
      var id = assoc_up_to_alias(sigma, aliases, y, yc, idcl);
      return /* :: */[
              /* tuple */[
                id,
                /* ProjectVar */0
              ],
              subst$prime
            ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        if (with_evars) {
          var f = function (param) {
            return EConstr$ReactTemplate.isEvar(sigma, param[0]);
          };
          var idcl$prime = Curry._2(Util$ReactTemplate.List[/* filter */27], f, idcl);
          if (idcl$prime) {
            if (idcl$prime[1]) {
              return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("More than one non var in aliases class of evar instance."));
            } else {
              var match = idcl$prime[0];
              var t = EConstr$ReactTemplate.destEvar(sigma, match[0]);
              var evi = Evd$ReactTemplate.find(sigma, t[0]);
              var match$1 = make_projectable_subst(aliases, sigma, evi, t[1]);
              var l = find_projectable_vars(with_evars, aliases, sigma, y, match$1[0]);
              if (l) {
                if (l[1]) {
                  return subst$prime;
                } else {
                  var match$2 = l[0];
                  return /* :: */[
                          /* tuple */[
                            match[2],
                            /* ProjectEvar */[
                              t,
                              evi,
                              match$2[0],
                              match$2[1]
                            ]
                          ],
                          subst$prime
                        ];
                }
              } else {
                return subst$prime;
              }
            }
          } else {
            return subst$prime;
          }
        } else {
          return subst$prime;
        }
      } else {
        throw exn;
      }
    }
  };
  return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], is_projectable, subst, /* [] */0);
}

function filter_solution(param) {
  if (param) {
    if (param[1]) {
      throw NotUnique;
    } else {
      var match = param[0];
      return /* tuple */[
              EConstr$ReactTemplate.mkVar(match[0]),
              match[1]
            ];
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_solution_type(evarenv, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      var id = match[0];
      if (match[1]) {
        var l = param[1];
        if (l) {
          _param = l;
          continue ;
          
        } else {
          return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], EConstr$ReactTemplate.lookup_named(id, evarenv));
        }
      } else {
        return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], EConstr$ReactTemplate.lookup_named(id, evarenv));
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "evarsolve.ml",
              846,
              10
            ]
          ];
    }
  };
}

function is_preferred_projection_over(sign, param, param$1) {
  var p$prime = param$1[1];
  var exit = 0;
  if (param[1]) {
    if (p$prime) {
      exit = 1;
    } else {
      return /* false */0;
    }
  } else if (p$prime) {
    return /* true */1;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return +(Curry._3(Util$ReactTemplate.List[/* index */77], Names$ReactTemplate.Id[/* equal */0], param[0], sign) < Curry._3(Util$ReactTemplate.List[/* index */77], Names$ReactTemplate.Id[/* equal */0], param$1[0], sign));
  }
  
}

function choose_projection(evi, sols) {
  var sign = Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], Evd$ReactTemplate.evar_filtered_context(evi));
  if (sols) {
    return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (x, y) {
                  if (is_preferred_projection_over(sign, x, y)) {
                    return x;
                  } else {
                    return y;
                  }
                }), sols[1], sols[0]);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "evarsolve.ml",
            865,
            9
          ]
        ];
  }
}

function do_projection_effects(define_fun, env, ty, evd, param) {
  if (param) {
    var evi = param[1];
    var match = param[0];
    var evd$1 = Evd$ReactTemplate.define(match[0], Constr$ReactTemplate.mkVar(param[2]), evd);
    var evd$2 = do_projection_effects(define_fun, env, ty, evd$1, param[3]);
    var tag = ty.tag | 0;
    var ty$1 = Reductionops$ReactTemplate.whd_all(env)(evd$2, tag === 250 ? ty[0] : (
            tag === 246 ? CamlinternalLazy.force_lazy_block(ty) : ty
          ));
    if (EConstr$ReactTemplate.isSort(evd$2, ty$1)) {
      return evd$2;
    } else {
      var subst = Evarutil$ReactTemplate.make_pure_subst(evi, match[1]);
      var ty$prime = EConstr$ReactTemplate.Vars[/* replace_vars */8](subst, EConstr$ReactTemplate.of_constr(evi[/* evar_concl */0]));
      if (EConstr$ReactTemplate.isEvar(evd$2, ty$prime)) {
        return Curry._5(define_fun, env, evd$2, /* Some */[/* false */0], EConstr$ReactTemplate.destEvar(evd$2, ty$prime), ty$1);
      } else {
        return evd$2;
      }
    }
  } else {
    return evd;
  }
}

function invert_arg_from_subst(evd, aliases, k0, subst_in_env_extended_with_k_binders, c_in_env_extended_with_k_binders) {
  var effects = [/* [] */0];
  var aux = function (k, t) {
    var match = EConstr$ReactTemplate.kind(evd, t);
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          var i = match[0];
          if (i > (k0 + k | 0)) {
            return aux$prime(k, /* RelAlias */Block.__(0, [i - k | 0]));
          } else {
            exit = 1;
          }
          break;
      case 1 : 
          return aux$prime(k, /* VarAlias */Block.__(1, [match[0]]));
      default:
        exit = 1;
    }
    if (exit === 1) {
      return EConstr$ReactTemplate.map_with_binders(evd, (function (prim) {
                    return prim + 1 | 0;
                  }), aux, k, t);
    }
    
  };
  var aux$prime = function (k, t) {
    try {
      var aliases$1 = aliases;
      var sigma = evd;
      var effects$1 = effects;
      var t$1 = t;
      var subst = subst_in_env_extended_with_k_binders;
      var match = filter_solution(find_projectable_vars(/* false */0, aliases$1, sigma, t$1, subst));
      effects$1[0] = /* :: */[
        match[1],
        effects$1[0]
      ];
      return match[0];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var match$1 = expand_alias_once(evd, aliases, t);
        if (match$1) {
          return aux(k, match$1[0]);
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
      } else {
        throw exn;
      }
    }
  };
  try {
    var c = aux(0, c_in_env_extended_with_k_binders);
    return /* Invertible */[/* UniqueProjection */[
              c,
              effects[0]
            ]];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* CannotInvert */0;
    } else if (exn === NotUnique) {
      return /* Invertible */[/* NoUniqueProjection */0];
    } else {
      throw exn;
    }
  }
}

function invert_arg(fullenv, evd, aliases, k, evk, subst_in_env_extended_with_k_binders, c_in_env_extended_with_k_binders) {
  var res = invert_arg_from_subst(evd, aliases, k, subst_in_env_extended_with_k_binders, c_in_env_extended_with_k_binders);
  if (res) {
    var match = res[0];
    if (match && !noccur_evar(fullenv, evd, evk, match[0])) {
      return /* CannotInvert */0;
    } else {
      return res;
    }
  } else {
    return res;
  }
}

var NotEnoughInformationToInvert = Caml_exceptions.create("Evarsolve-ReactTemplate.NotEnoughInformationToInvert");

function extract_candidates(sols) {
  try {
    return /* UpdateWith */[Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    if (param[1]) {
                      throw Pervasives.Exit;
                    } else {
                      return EConstr$ReactTemplate.mkVar(param[0]);
                    }
                  }), sols)];
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* NoUpdate */0;
    } else {
      throw exn;
    }
  }
}

function invert_invertible_arg(fullenv, evd, aliases, k, param, args$prime) {
  var evk = param[0];
  var evi = Evd$ReactTemplate.find_undefined(evd, evk);
  var match = make_projectable_subst(aliases, evd, evi, param[1]);
  var subst = match[0];
  var invert = function (arg) {
    var param = invert_arg(fullenv, evd, aliases, k, evk, subst, arg);
    if (param) {
      var match = param[0];
      if (match) {
        return match[0];
      } else {
        throw NotEnoughInformationToInvert;
      }
    } else {
      throw NotEnoughInformationToInvert;
    }
  };
  return Util$ReactTemplate.$$Array[/* map */12](invert, args$prime);
}

function set_of_evctx(l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (s, decl) {
                return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), s);
              }), Names$ReactTemplate.Id[/* Set */9][/* empty */0], l);
}

function filter_effective_candidates(evd, evi, filter, candidates) {
  if (filter) {
    var ids = set_of_evctx(Evd$ReactTemplate.Filter[/* filter_list */2](filter[0], Evd$ReactTemplate.evar_context(evi)));
    return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (a) {
                  return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* subset */11], Termops$ReactTemplate.collect_vars(evd, a), ids);
                }), candidates);
  } else {
    return candidates;
  }
}

function filter_candidates(evd, evk, filter, candidates_update) {
  var evi = Evd$ReactTemplate.find_undefined(evd, evk);
  var candidates = candidates_update ? /* Some */[candidates_update[0]] : Option$ReactTemplate.map((function (l) {
            return Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, l);
          }), evi[/* evar_candidates */5]);
  if (candidates) {
    var l = candidates[0];
    var l$prime = filter_effective_candidates(evd, evi, filter, l);
    if (Curry._1(Util$ReactTemplate.List[/* length */0], l) === Curry._1(Util$ReactTemplate.List[/* length */0], l$prime) && candidates_update === /* NoUpdate */0) {
      return /* NoUpdate */0;
    } else {
      return /* UpdateWith */[l$prime];
    }
  } else {
    return /* NoUpdate */0;
  }
}

function closure_of_filter(evd, evk, param) {
  if (param) {
    var evi = Evd$ReactTemplate.find_undefined(evd, evk);
    var vars = Termops$ReactTemplate.collect_vars(evd, EConstr$ReactTemplate.of_constr(Evd$ReactTemplate.evar_concl(evi)));
    var test = function (b, decl) {
      if (b) {
        return /* true */1;
      } else if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), vars)) {
        return /* true */1;
      } else if (decl.tag) {
        var c = EConstr$ReactTemplate.of_constr(decl[1]);
        return 1 - (EConstr$ReactTemplate.isRel(evd, c) || EConstr$ReactTemplate.isVar(evd, c));
      } else {
        return /* false */0;
      }
    };
    var newfilter = Evd$ReactTemplate.Filter[/* map_along */8](test, param[0], Evd$ReactTemplate.evar_context(evi));
    var partial_arg = Evd$ReactTemplate.Filter[/* map_along */8];
    var newfilter$1 = Option$ReactTemplate.cata((function (param) {
            return partial_arg((function (prim, prim$1) {
                          if (prim) {
                            return prim$1;
                          } else {
                            return /* false */0;
                          }
                        }), newfilter, param);
          }), newfilter, Evd$ReactTemplate.Filter[/* repr */10](Evd$ReactTemplate.evar_filter(evi)));
    if (Evd$ReactTemplate.Filter[/* equal */0](newfilter$1, Evd$ReactTemplate.evar_filter(evi))) {
      return /* None */0;
    } else {
      return /* Some */[newfilter$1];
    }
  } else {
    return /* None */0;
  }
}

function restrict_hyps(evd, evk, filter, candidates) {
  var candidates$1 = filter_candidates(evd, evk, /* Some */[filter], candidates);
  var typablefilter = closure_of_filter(evd, evk, /* Some */[filter]);
  return /* tuple */[
          typablefilter,
          candidates$1
        ];
}

var EvarSolvedWhileRestricting = Caml_exceptions.create("Evarsolve-ReactTemplate.EvarSolvedWhileRestricting");

function do_restrict_hyps(evd, ev, filter, candidates) {
  var evk = ev[0];
  var match = filter ? restrict_hyps(evd, evk, filter[0], candidates) : /* tuple */[
      /* None */0,
      candidates
    ];
  var candidates$1 = match[1];
  var filter$1 = match[0];
  if (candidates$1) {
    var match$1 = candidates$1[0];
    if (match$1) {
      if (match$1[1]) {
        return restrict_applied_evar(evd, ev, filter$1, candidates$1);
      } else {
        var evd$1 = Evd$ReactTemplate.define(evk, EConstr$ReactTemplate.Unsafe[/* to_constr */0](match$1[0]), evd);
        throw [
              EvarSolvedWhileRestricting,
              evd$1,
              EConstr$ReactTemplate.mkEvar(ev)
            ];
      }
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not solvable."));
    }
  } else if (filter$1) {
    return restrict_applied_evar(evd, ev, filter$1, candidates$1);
  } else {
    return /* tuple */[
            evd,
            ev
          ];
  }
}

function instantiate_evar_array(evi, c, args) {
  return EConstr$ReactTemplate.of_constr(Evd$ReactTemplate.instantiate_evar_array(evi, EConstr$ReactTemplate.Unsafe[/* to_constr */0](c), Util$ReactTemplate.$$Array[/* map */12](EConstr$ReactTemplate.Unsafe[/* to_constr */0], args)));
}

function filter_compatible_candidates(conv_algo, env, evd, evi, args, rhs, c) {
  var c$prime = instantiate_evar_array(evi, c, args);
  var match = Curry._5(conv_algo, env, evd, /* CONV */0, rhs, c$prime);
  if (match.tag) {
    return /* None */0;
  } else {
    return /* Some */[/* tuple */[
              c,
              match[0]
            ]];
  }
}

var DoesNotPreserveCandidateRestriction = Caml_exceptions.create("Evarsolve-ReactTemplate.DoesNotPreserveCandidateRestriction");

function restrict_candidates(conv_algo, env, evd, filter1, param, param$1) {
  var argsv2 = param$1[1];
  var argsv1 = param[1];
  var evk1 = param[0];
  var evi1 = Evd$ReactTemplate.find(evd, evk1);
  var evi2 = Evd$ReactTemplate.find(evd, param$1[0]);
  var match = evi1[/* evar_candidates */5];
  var match$1 = evi2[/* evar_candidates */5];
  if (match$1) {
    if (match) {
      var l1 = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, match[0]);
      var l2 = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, match$1[0]);
      var l1$1 = filter_effective_candidates(evd, evi1, filter1, l1);
      var l1$prime = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (c1) {
              var c1$prime = instantiate_evar_array(evi1, c1, argsv1);
              var filter = function (c2) {
                var compatibility = filter_compatible_candidates(conv_algo, env, evd, evi2, argsv2, c1$prime, c2);
                if (compatibility) {
                  return /* true */1;
                } else {
                  return /* false */0;
                }
              };
              var filtered = Curry._2(Util$ReactTemplate.List[/* filter */27], filter, l2);
              if (filtered) {
                return /* true */1;
              } else {
                return /* false */0;
              }
            }), l1$1);
      if (Curry._1(Util$ReactTemplate.List[/* length */0], l1$1) === Curry._1(Util$ReactTemplate.List[/* length */0], l1$prime)) {
        return /* NoUpdate */0;
      } else {
        return /* UpdateWith */[l1$prime];
      }
    } else {
      throw DoesNotPreserveCandidateRestriction;
    }
  } else {
    return filter_candidates(evd, evk1, filter1, /* NoUpdate */0);
  }
}

var CannotProject = Caml_exceptions.create("Evarsolve-ReactTemplate.CannotProject");

function is_constrainable_in(_top, evd, k, g, _t) {
  while(true) {
    var t = _t;
    var top = _top;
    var match = g[1];
    var match$1 = Termops$ReactTemplate.decompose_app_vect(evd, t);
    var args = match$1[1];
    var match$2 = EConstr$ReactTemplate.kind(evd, match$1[0]);
    switch (match$2.tag | 0) {
      case 0 : 
          var n = match$2[0];
          if (n <= k) {
            return /* true */1;
          } else {
            return Curry._2(Int$ReactTemplate.$$Set[/* mem */2], n, match[0]);
          }
      case 1 : 
          return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], match$2[0], match[1]);
      case 3 : 
          if (top) {
            return /* true */1;
          } else {
            return 1 - Evar$ReactTemplate.equal(match$2[0][0], g[0]);
          }
      case 4 : 
          return /* true */1;
      case 6 : 
          if (is_constrainable_in(/* false */0, evd, k, g, match$2[1])) {
            _t = match$2[2];
            _top = /* false */0;
            continue ;
            
          } else {
            return /* false */0;
          }
          break;
      case 11 : 
          return Util$ReactTemplate.$$Array[/* for_all */26]((function (param) {
                        return is_constrainable_in(/* false */0, evd, k, g, param);
                      }), args);
      case 12 : 
          var n$1 = Inductiveops$ReactTemplate.inductive_nparams(match$2[0][0][0]);
          if (n$1 > args.length) {
            return /* true */1;
          } else {
            var params = Util$ReactTemplate.$$Array[/* chop */46](n$1, args)[0];
            return Util$ReactTemplate.$$Array[/* for_all */26]((function (param) {
                          return is_constrainable_in(/* false */0, evd, k, g, param);
                        }), params);
          }
          break;
      default:
        return /* true */1;
    }
  };
}

var EvarSolvedOnTheFly = Caml_exceptions.create("Evarsolve-ReactTemplate.EvarSolvedOnTheFly");

function project_evar_on_evar(force, g, env, evd, aliases, k2, pbty, ev1, ev2) {
  var evk2 = ev2[0];
  var fvs2 = free_vars_and_rels_up_alias_expansion(evd, aliases, EConstr$ReactTemplate.mkEvar(ev2));
  var filter1 = restrict_upon_filter(evd, ev1[0], (function (param) {
          var env$1 = env;
          var evd$1 = evd;
          var aliases$1 = aliases;
          var force$1 = force;
          var k = k2;
          var ev = evk2;
          var param$1 = fvs2;
          var t = param;
          var fv_ids = param$1[1];
          var fv_rels = param$1[0];
          var match = to_alias(evd$1, t);
          if (match) {
            var t$1 = match[0];
            var match$1 = expansion_of_var(evd$1, aliases$1, t$1);
            if (match$1[0]) {
              if (t$1.tag) {
                return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], t$1[0], param$1[3]);
              } else {
                return Curry._2(Int$ReactTemplate.$$Set[/* mem */2], t$1[0], param$1[2]);
              }
            } else if (t$1.tag) {
              return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], t$1[0], fv_ids);
            } else {
              var n = t$1[0];
              if (n <= k) {
                return /* true */1;
              } else {
                return Curry._2(Int$ReactTemplate.$$Set[/* mem */2], n, fv_rels);
              }
            }
          } else if (!force$1 || noccur_evar(env$1, evd$1, ev, t)) {
            return is_constrainable_in(/* true */1, evd$1, k, /* tuple */[
                        ev,
                        /* tuple */[
                          fv_rels,
                          fv_ids
                        ]
                      ], t);
          } else {
            return /* false */0;
          }
        }), ev1[1]);
  var candidates1;
  try {
    candidates1 = restrict_candidates(g, env, evd, filter1, ev1, ev2);
  }
  catch (exn){
    if (exn === DoesNotPreserveCandidateRestriction) {
      var match = do_restrict_hyps(evd, ev1, filter1, /* NoUpdate */0);
      throw [
            CannotProject,
            match[0],
            match[1]
          ];
    } else {
      throw exn;
    }
  }
  var match$1;
  try {
    match$1 = do_restrict_hyps(evd, ev1, filter1, candidates1);
  }
  catch (raw_exn){
    var exn$1 = Js_exn.internalToOCamlException(raw_exn);
    if (exn$1[0] === EvarSolvedWhileRestricting) {
      throw [
            EvarSolvedOnTheFly,
            exn$1[1],
            exn$1[2]
          ];
    } else {
      throw exn$1;
    }
  }
  var ev1$prime = match$1[1];
  var evd$1 = match$1[0];
  if (Option$ReactTemplate.is_empty(pbty) && is_unification_pattern_pure_evar(env, evd$1, ev2, EConstr$ReactTemplate.mkEvar(ev1))) {
    try {
      return /* tuple */[
              evd$1,
              EConstr$ReactTemplate.mkEvar(/* tuple */[
                    ev1$prime[0],
                    invert_invertible_arg(env, evd$1, aliases, k2, ev2, ev1$prime[1])
                  ])
            ];
    }
    catch (exn$2){
      if (exn$2 === NotEnoughInformationToInvert) {
        throw [
              CannotProject,
              evd$1,
              ev1$prime
            ];
      } else {
        throw exn$2;
      }
    }
  } else {
    throw [
          CannotProject,
          evd$1,
          ev1$prime
        ];
  }
}

function check_evar_instance(evd, evk1, body, conv_algo) {
  var evi = Evd$ReactTemplate.find(evd, evk1);
  var evenv = Evd$ReactTemplate.evar_env(evi);
  var ty;
  try {
    ty = Retyping$ReactTemplate.get_type_of(/* None */0, /* Some */[/* true */1], evenv, evd, body);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Retyping$ReactTemplate.RetypeError) {
      ty = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Ill-typed evar instance"));
    } else {
      throw exn;
    }
  }
  var match = Curry._5(conv_algo, evenv, evd, /* CUMUL */1, ty, EConstr$ReactTemplate.of_constr(evi[/* evar_concl */0]));
  if (match.tag) {
    throw [
          IllTypedInstance,
          evenv,
          ty,
          EConstr$ReactTemplate.of_constr(evi[/* evar_concl */0])
        ];
  } else {
    return match[0];
  }
}

function update_evar_source(ev1, ev2, evd) {
  var match = Evd$ReactTemplate.evar_source(ev2, evd);
  var evs2 = match[1];
  var exit = 0;
  if (typeof evs2 === "number") {
    return evd;
  } else {
    switch (evs2.tag | 0) {
      case 0 : 
          if (evs2[2] !== 0) {
            return evd;
          } else {
            exit = 1;
          }
          break;
      case 3 : 
          exit = 1;
          break;
      default:
        return evd;
    }
  }
  if (exit === 1) {
    var evi = Evd$ReactTemplate.find(evd, ev1);
    var newrecord = evi.slice();
    return Evd$ReactTemplate.add(evd, ev1, (newrecord[/* evar_source */4] = /* tuple */[
                  match[0],
                  evs2
                ], newrecord));
  }
  
}

function solve_evar_evar_l2r(force, f, g, env, evd, aliases, pbty, ev1, ev2) {
  var evk2 = ev2[0];
  try {
    var match = project_evar_on_evar(force, g, env, evd, aliases, 0, pbty, ev1, ev2);
    var body = match[1];
    var evd$1 = match[0];
    var evd$prime = Evd$ReactTemplate.define(evk2, EConstr$ReactTemplate.Unsafe[/* to_constr */0](body), evd$1);
    var evd$prime$1 = update_evar_source(EConstr$ReactTemplate.destEvar(evd$1, body)[0], evk2, evd$prime);
    return check_evar_instance(evd$prime$1, evk2, body, g);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === EvarSolvedOnTheFly) {
      return Curry._5(f, env, exn[1], pbty, ev2, exn[2]);
    } else {
      throw exn;
    }
  }
}

function opp_problem(param) {
  if (param) {
    return /* Some */[1 - param[0]];
  } else {
    return /* None */0;
  }
}

function preferred_orientation(evd, evk1, evk2) {
  var match = Evd$ReactTemplate.find_undefined(evd, evk1)[/* evar_source */4];
  var src1 = match[1];
  var match$1 = Evd$ReactTemplate.find_undefined(evd, evk2)[/* evar_source */4];
  var src2 = match$1[1];
  var exit = 0;
  if (typeof src1 === "number") {
    exit = 1;
  } else {
    switch (src1.tag | 0) {
      case 0 : 
          if (src1[2] !== 0) {
            exit = 1;
          } else {
            return /* true */1;
          }
          break;
      case 3 : 
          return /* true */1;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    if (typeof src2 === "number") {
      return /* true */1;
    } else {
      switch (src2.tag | 0) {
        case 0 : 
            if (src2[2] !== 0) {
              return /* true */1;
            } else {
              return /* false */0;
            }
        case 3 : 
            return /* false */0;
        default:
          return /* true */1;
      }
    }
  }
  
}

function solve_evar_evar($staropt$star, f, g, env, evd, pbty, ev1, ev2) {
  var evk2 = ev2[0];
  var evk1 = ev1[0];
  var force = $staropt$star ? $staropt$star[0] : /* false */0;
  var pbty$1 = force ? /* None */0 : pbty;
  var evi = Evd$ReactTemplate.find(evd, evk1);
  var downcast = function (evk, t, evd) {
    return Evd$ReactTemplate.downcast(evk, EConstr$ReactTemplate.Unsafe[/* to_constr */0](t), evd);
  };
  var evd$1;
  try {
    var evienv = Evd$ReactTemplate.evar_env(evi);
    var match = Reduction$ReactTemplate.dest_arity(evienv, evi[/* evar_concl */0]);
    var i = match[1];
    var ctx1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
            return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, c);
          }), match[0]);
    var evi2 = Evd$ReactTemplate.find(evd, evk2);
    var evi2env = Evd$ReactTemplate.evar_env(evi2);
    var match$1 = Reduction$ReactTemplate.dest_arity(evi2env, evi2[/* evar_concl */0]);
    var j = match$1[1];
    var ctx2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
            return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, c);
          }), match$1[0]);
    var ui = Sorts$ReactTemplate.univ_of_sort(i);
    var uj = Sorts$ReactTemplate.univ_of_sort(j);
    if (i === j || Evd$ReactTemplate.check_eq(evd, ui, uj)) {
      evd$1 = evd;
    } else if (Evd$ReactTemplate.check_leq(evd, ui, uj)) {
      var t2 = EConstr$ReactTemplate.it_mkProd_or_LetIn(EConstr$ReactTemplate.mkSort(i), ctx2);
      evd$1 = downcast(evk2, t2, evd);
    } else if (Evd$ReactTemplate.check_leq(evd, uj, ui)) {
      var t1 = EConstr$ReactTemplate.it_mkProd_or_LetIn(EConstr$ReactTemplate.mkSort(j), ctx1);
      evd$1 = downcast(evk1, t1, evd);
    } else {
      var match$2 = Evd$ReactTemplate.new_sort_variable(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg, evd);
      var k = match$2[1];
      var t1$1 = EConstr$ReactTemplate.it_mkProd_or_LetIn(EConstr$ReactTemplate.mkSort(k), ctx1);
      var t2$1 = EConstr$ReactTemplate.it_mkProd_or_LetIn(EConstr$ReactTemplate.mkSort(k), ctx2);
      var evd$2 = Evd$ReactTemplate.set_leq_sort(env, Evd$ReactTemplate.set_leq_sort(env, match$2[0], k, i), k, j);
      evd$1 = downcast(evk2, t2$1, downcast(evk1, t1$1, evd$2));
    }
  }
  catch (exn){
    if (exn === Reduction$ReactTemplate.NotArity) {
      evd$1 = evd;
    } else {
      throw exn;
    }
  }
  var force$1 = force;
  var f$1 = f;
  var g$1 = g;
  var env$1 = env;
  var evd$3 = evd$1;
  var pbty$2 = pbty$1;
  var ev1$1 = ev1;
  var ev2$1 = ev2;
  var aliases = make_alias_map(env$1, evd$3);
  if (preferred_orientation(evd$3, ev1$1[0], ev2$1[0])) {
    try {
      return solve_evar_evar_l2r(force$1, f$1, g$1, env$1, evd$3, aliases, opp_problem(pbty$2), ev2$1, ev1$1);
    }
    catch (raw_exn){
      var exn$1 = Js_exn.internalToOCamlException(raw_exn);
      if (exn$1[0] === CannotProject) {
        var ev2$2 = exn$1[2];
        try {
          return solve_evar_evar_l2r(force$1, f$1, g$1, env$1, exn$1[1], aliases, pbty$2, ev1$1, ev2$2);
        }
        catch (raw_exn$1){
          var exn$2 = Js_exn.internalToOCamlException(raw_exn$1);
          if (exn$2[0] === CannotProject) {
            return add_conv_oriented_pb(/* Some */[/* true */1], /* tuple */[
                        pbty$2,
                        env$1,
                        EConstr$ReactTemplate.mkEvar(exn$2[2]),
                        EConstr$ReactTemplate.mkEvar(ev2$2)
                      ], exn$2[1]);
          } else {
            throw exn$2;
          }
        }
      } else {
        throw exn$1;
      }
    }
  } else {
    try {
      return solve_evar_evar_l2r(force$1, f$1, g$1, env$1, evd$3, aliases, pbty$2, ev1$1, ev2$1);
    }
    catch (raw_exn$2){
      var exn$3 = Js_exn.internalToOCamlException(raw_exn$2);
      if (exn$3[0] === CannotProject) {
        var ev1$2 = exn$3[2];
        try {
          return solve_evar_evar_l2r(force$1, f$1, g$1, env$1, exn$3[1], aliases, opp_problem(pbty$2), ev2$1, ev1$2);
        }
        catch (raw_exn$3){
          var exn$4 = Js_exn.internalToOCamlException(raw_exn$3);
          if (exn$4[0] === CannotProject) {
            return add_conv_oriented_pb(/* Some */[/* true */1], /* tuple */[
                        pbty$2,
                        env$1,
                        EConstr$ReactTemplate.mkEvar(ev1$2),
                        EConstr$ReactTemplate.mkEvar(exn$4[2])
                      ], exn$4[1]);
          } else {
            throw exn$4;
          }
        }
      } else {
        throw exn$3;
      }
    }
  }
}

function solve_refl($staropt$star, conv_algo, env, evd, pbty, evk, argsv1, argsv2) {
  var can_drop = $staropt$star ? $staropt$star[0] : /* false */0;
  var evdref = [evd];
  var eq_constr = function (c1, c2) {
    var match = EConstr$ReactTemplate.eq_constr_universes(env, evdref[0], c1, c2);
    if (match) {
      try {
        Evd$ReactTemplate.add_universe_constraints(evdref[0], match[0]);
        return /* true */1;
      }
      catch (exn){
        if (exn === Evd$ReactTemplate.UniversesDiffer) {
          return /* false */0;
        } else {
          throw exn;
        }
      }
    } else {
      return /* false */0;
    }
  };
  if (Util$ReactTemplate.$$Array[/* equal */21](eq_constr, argsv1, argsv2)) {
    return evdref[0];
  } else {
    var args = Util$ReactTemplate.$$Array[/* map2 */49]((function (a1, a2) {
            return /* tuple */[
                    a1,
                    a2
                  ];
          }), argsv1, argsv2);
    var untypedfilter = restrict_upon_filter(evd, evk, (function (param) {
            return Curry._5(conv_algo, env, evd, /* CONV */0, param[0], param[1]);
          }), args);
    var candidates = filter_candidates(evd, evk, untypedfilter, /* NoUpdate */0);
    var filter = closure_of_filter(evd, evk, untypedfilter);
    var match = restrict_applied_evar(evd, /* tuple */[
          evk,
          argsv1
        ], filter, candidates);
    var ev1 = match[1];
    var evd$1 = match[0];
    if (Evar$ReactTemplate.equal(ev1[0], evk) && can_drop) {
      return evd$1;
    } else {
      var argsv2$1 = restrict_instance(evd$1, evk, filter, argsv2);
      var ev2_000 = ev1[0];
      var ev2 = /* tuple */[
        ev2_000,
        argsv2$1
      ];
      return add_conv_oriented_pb(/* None */0, /* tuple */[
                  pbty,
                  env,
                  EConstr$ReactTemplate.mkEvar(ev1),
                  EConstr$ReactTemplate.mkEvar(ev2)
                ], evd$1);
    }
  }
}

var NoCandidates = Caml_exceptions.create("Evarsolve-ReactTemplate.NoCandidates");

var IncompatibleCandidates = Caml_exceptions.create("Evarsolve-ReactTemplate.IncompatibleCandidates");

function occur_evar_upto_types(sigma, n, c) {
  var c$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](c);
  var seen = [Evar$ReactTemplate.$$Set[/* empty */0]];
  var occur_rec = function (_c) {
    while(true) {
      var c = _c;
      var match = Constr$ReactTemplate.kind(c);
      if (match.tag === 3) {
        var e = match[0];
        var sp = e[0];
        if (Evar$ReactTemplate.equal(sp, n)) {
          throw Termops$ReactTemplate.Occur;
        } else if (Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], sp, seen[0])) {
          return Util$ReactTemplate.$$Array[/* iter */11](occur_rec, e[1]);
        } else {
          seen[0] = Curry._2(Evar$ReactTemplate.$$Set[/* add */3], sp, seen[0]);
          Option$ReactTemplate.iter(occur_rec, Evd$ReactTemplate.existential_opt_value(sigma, e));
          _c = Evd$ReactTemplate.existential_type(sigma, e);
          continue ;
          
        }
      } else {
        return Constr$ReactTemplate.iter(occur_rec, c);
      }
    };
  };
  try {
    occur_rec(c$1);
    return /* false */0;
  }
  catch (exn){
    if (exn === Termops$ReactTemplate.Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

var NotInvertibleUsingOurAlgorithm = Caml_exceptions.create("Evarsolve-ReactTemplate.NotInvertibleUsingOurAlgorithm");

var NotEnoughInformationToProgress = Caml_exceptions.create("Evarsolve-ReactTemplate.NotEnoughInformationToProgress");

var NotEnoughInformationEvarEvar = Caml_exceptions.create("Evarsolve-ReactTemplate.NotEnoughInformationEvarEvar");

var OccurCheckIn = Caml_exceptions.create("Evarsolve-ReactTemplate.OccurCheckIn");

var MetaOccurInBodyInternal = Caml_exceptions.create("Evarsolve-ReactTemplate.MetaOccurInBodyInternal");

function invert_definition(conv_algo, choose, env, evd, _, ev, rhs) {
  var argsv = ev[1];
  var evk = ev[0];
  var aliases = make_alias_map(env, evd);
  var evdref = [evd];
  var progress = [/* false */0];
  var evi = Evd$ReactTemplate.find(evd, evk);
  var match = make_projectable_subst(aliases, evd, evi, argsv);
  var cstr_subst = match[1];
  var subst = match[0];
  var project_variable = function (t) {
    try {
      var sols = find_projectable_vars(/* true */1, aliases, evdref[0], t, subst);
      var match;
      if (sols) {
        if (sols[1]) {
          if (choose) {
            var match$1 = choose_projection(evi, sols);
            match = /* tuple */[
              EConstr$ReactTemplate.mkVar(match$1[0]),
              match$1[1]
            ];
          } else {
            throw [
                  NotUniqueInType,
                  sols
                ];
          }
        } else {
          var match$2 = sols[0];
          match = /* tuple */[
            EConstr$ReactTemplate.mkVar(match$2[0]),
            match$2[1]
          ];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
      var ty = Block.__(246, [(function () {
              return Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, evdref[0], of_alias(t));
            })]);
      var partial_arg = /* Some */[choose];
      var evd = do_projection_effects((function (param, param$1, param$2, param$3, param$4) {
              return evar_define(conv_algo, partial_arg, param, param$1, param$2, param$3, param$4);
            }), env, ty, evdref[0], match[1]);
      evdref[0] = evd;
      return match[0];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              NotInvertibleUsingOurAlgorithm,
              of_alias(t)
            ];
      } else if (exn[0] === NotUniqueInType) {
        var sols$1 = exn[1];
        if (!progress[0]) {
          throw [
                NotEnoughInformationToProgress,
                sols$1
              ];
        }
        var ty$1 = find_solution_type(Evd$ReactTemplate.evar_filtered_env(evi), sols$1);
        var ty$prime = instantiate_evar_array(evi, ty$1, argsv);
        var partial_arg$1 = /* Some */[choose];
        var match$3 = materialize_evar((function (param, param$1, param$2, param$3, param$4) {
                return evar_define(conv_algo, partial_arg$1, param, param$1, param$2, param$3, param$4);
              }), env, evdref[0], 0, ev, ty$prime);
        var ev$prime = match$3[2];
        var evk$prime = ev$prime[0];
        var evd$1 = match$3[0];
        var ts = expansions_of_var(evd$1, aliases, t);
        var test = function (c) {
          if (EConstr$ReactTemplate.isEvar(evd$1, c)) {
            return /* true */1;
          } else {
            return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                          return is_alias(evd$1, c, param);
                        }), ts);
          }
        };
        var filter = restrict_upon_filter(evd$1, evk, test, ev$prime[1]);
        var filter$1 = closure_of_filter(evd$1, evk$prime, filter);
        var candidates = extract_candidates(sols$1);
        var evd$2;
        if (candidates) {
          evd$2 = restrict_evar(evd$1, evk$prime, filter$1, candidates);
        } else {
          var match$4 = restrict_applied_evar(evd$1, ev$prime, filter$1, /* NoUpdate */0);
          evd$2 = add_conv_oriented_pb(/* Some */[/* false */0], /* tuple */[
                /* None */0,
                env,
                EConstr$ReactTemplate.mkEvar(match$4[1]),
                of_alias(t)
              ], match$4[0]);
        }
        evdref[0] = evd$2;
        return match$3[1];
      } else {
        throw exn;
      }
    }
  };
  var imitate = function (envk, _t) {
    while(true) {
      var t = _t;
      var k = envk[1];
      var env$prime = envk[0];
      var match = EConstr$ReactTemplate.kind(evdref[0], t);
      var exit = 0;
      switch (match.tag | 0) {
        case 0 : 
            var i = match[0];
            if (i > k) {
              var match$1 = Environ$ReactTemplate.lookup_rel(i - k | 0, env$prime);
              if (match$1.tag) {
                try {
                  return project_variable(/* RelAlias */Block.__(0, [i - k | 0]));
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === NotInvertibleUsingOurAlgorithm) {
                    _t = EConstr$ReactTemplate.Vars[/* lift */0](i, EConstr$ReactTemplate.of_constr(match$1[1]));
                    continue ;
                    
                  } else {
                    throw exn;
                  }
                }
              } else {
                return project_variable(/* RelAlias */Block.__(0, [i - k | 0]));
              }
            } else {
              exit = 1;
            }
            break;
        case 1 : 
            var id = match[0];
            var match$2 = Environ$ReactTemplate.lookup_named(id, env$prime);
            if (match$2.tag) {
              try {
                return project_variable(/* VarAlias */Block.__(1, [id]));
              }
              catch (raw_exn$1){
                var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
                if (exn$1[0] === NotInvertibleUsingOurAlgorithm) {
                  _t = EConstr$ReactTemplate.of_constr(match$2[1]);
                  continue ;
                  
                } else {
                  throw exn$1;
                }
              }
            } else {
              return project_variable(/* VarAlias */Block.__(1, [id]));
            }
            break;
        case 3 : 
            var ev$prime = match[0];
            if (Evar$ReactTemplate.equal(evk, ev$prime[0])) {
              throw [
                    OccurCheckIn,
                    evd,
                    rhs
                  ];
            }
            var aliases$1 = lift_aliases(k, aliases);
            try {
              var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
              var ev_001 = Util$ReactTemplate.$$Array[/* map */12]((function(k,partial_arg){
                  return function (param) {
                    return partial_arg(k, param);
                  }
                  }(k,partial_arg)), argsv);
              var ev$1 = /* tuple */[
                evk,
                ev_001
              ];
              var match$3 = project_evar_on_evar(/* false */0, conv_algo, env$prime, evdref[0], aliases$1, k, /* None */0, ev$prime, ev$1);
              evdref[0] = match$3[0];
              return match$3[1];
            }
            catch (raw_exn$2){
              var exn$2 = Js_exn.internalToOCamlException(raw_exn$2);
              if (exn$2[0] === EvarSolvedOnTheFly) {
                evdref[0] = exn$2[1];
                _t = exn$2[2];
                continue ;
                
              } else if (exn$2[0] === CannotProject) {
                var evd$1 = exn$2[1];
                if (!progress[0]) {
                  throw [
                        NotEnoughInformationEvarEvar,
                        t
                      ];
                }
                var ty = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env$prime, evd$1, t);
                var partial_arg$1 = /* Some */[choose];
                var match$4 = materialize_evar((function(partial_arg$1){
                    return function (param, param$1, param$2, param$3, param$4) {
                      return evar_define(conv_algo, partial_arg$1, param, param$1, param$2, param$3, param$4);
                    }
                    }(partial_arg$1)), env$prime, evd$1, k, ev, ty);
                var evd$2 = match$4[0];
                var ev$prime$1 = normalize_evar(evd$2, exn$2[2]);
                var evk$prime = ev$prime$1[0];
                var evd$3;
                try {
                  var match$5 = project_evar_on_evar(/* false */0, conv_algo, env$prime, evd$2, aliases$1, 0, /* None */0, match$4[2], ev$prime$1);
                  var body = match$5[1];
                  var evd$4 = Evd$ReactTemplate.define(evk$prime, EConstr$ReactTemplate.Unsafe[/* to_constr */0](body), match$5[0]);
                  evd$3 = check_evar_instance(evd$4, evk$prime, body, conv_algo);
                }
                catch (raw_exn$3){
                  var exn$3 = Js_exn.internalToOCamlException(raw_exn$3);
                  if (exn$3[0] === EvarSolvedOnTheFly) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "evarsolve.ml",
                            1535,
                            38
                          ]
                        ];
                  } else if (exn$3[0] === CannotProject) {
                    evd$3 = add_conv_oriented_pb(/* None */0, /* tuple */[
                          /* None */0,
                          env$prime,
                          EConstr$ReactTemplate.mkEvar(exn$3[2]),
                          EConstr$ReactTemplate.mkEvar(ev$prime$1)
                        ], exn$3[1]);
                  } else {
                    throw exn$3;
                  }
                }
                evdref[0] = evd$3;
                return match$4[1];
              } else {
                throw exn$2;
              }
            }
            break;
        case 8 : 
            _t = EConstr$ReactTemplate.Vars[/* subst1 */4](match[1], match[3]);
            continue ;
            default:
          exit = 1;
      }
      if (exit === 1) {
        progress[0] = /* true */1;
        var match$6 = Termops$ReactTemplate.decompose_app_vect(evdref[0], t);
        var match$7 = EConstr$ReactTemplate.kind(evdref[0], match$6[0]);
        var match$8;
        if (match$7.tag === 12) {
          if (EConstr$ReactTemplate.Vars[/* noccur_between */13](evdref[0], 1, k, t)) {
            var l = find_projectable_constructor(env, evd, match$7[0][0], k, match$6[1], cstr_subst);
            match$8 = l ? /* Some */[Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.mkVar, l)] : /* None */0;
          } else {
            match$8 = /* None */0;
          }
        } else {
          match$8 = /* None */0;
        }
        if (match$8) {
          var l$1 = match$8[0];
          var ty$1 = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env$prime, evdref[0], t);
          var candidates;
          try {
            var t$1 = Termops$ReactTemplate.map_constr_with_full_binders(evdref[0], (function (d, param) {
                    return /* tuple */[
                            EConstr$ReactTemplate.push_rel(d, param[0]),
                            param[1] + 1 | 0
                          ];
                  }), imitate, envk, t);
            candidates = /* :: */[
              t$1,
              l$1
            ];
          }
          catch (raw_e){
            var e = Js_exn.internalToOCamlException(raw_e);
            if (CErrors$ReactTemplate.noncritical(e)) {
              candidates = l$1;
            } else {
              throw e;
            }
          }
          var exit$1 = 0;
          if (candidates) {
            if (candidates[1]) {
              exit$1 = 2;
            } else {
              return candidates[0];
            }
          } else {
            exit$1 = 2;
          }
          if (exit$1 === 2) {
            var partial_arg$2 = /* Some */[choose];
            var match$9 = materialize_evar((function(partial_arg$2){
                return function (param, param$1, param$2, param$3, param$4) {
                  return evar_define(conv_algo, partial_arg$2, param, param$1, param$2, param$3, param$4);
                }
                }(partial_arg$2)), env$prime, evdref[0], k, ev, ty$1);
            evdref[0] = restrict_evar(match$9[0], match$9[2][0], /* None */0, /* UpdateWith */[candidates]);
            return match$9[1];
          }
          
        } else {
          return Termops$ReactTemplate.map_constr_with_full_binders(evdref[0], (function (d, param) {
                        return /* tuple */[
                                EConstr$ReactTemplate.push_rel(d, param[0]),
                                param[1] + 1 | 0
                              ];
                      }), imitate, envk, t);
        }
      }
      
    };
  };
  var rhs$1 = Reductionops$ReactTemplate.whd_beta(evd, rhs);
  var fast = function (rhs) {
    var filter_ctxt = Evd$ReactTemplate.evar_filtered_context(evi);
    var names = [Names$ReactTemplate.Id[/* Set */9][/* empty */0]];
    var is_id_subst = function (_ctxt, _s) {
      while(true) {
        var s = _s;
        var ctxt = _ctxt;
        if (ctxt) {
          if (s) {
            var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], ctxt[0]);
            names[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, names[0]);
            if (EConstr$ReactTemplate.isVarId(evd, id, s[0])) {
              _s = s[1];
              _ctxt = ctxt[1];
              continue ;
              
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
        } else if (s) {
          return /* false */0;
        } else {
          return /* true */1;
        }
      };
    };
    if (is_id_subst(filter_ctxt, Util$ReactTemplate.$$Array[/* to_list */9](argsv)) && EConstr$ReactTemplate.Vars[/* closed0 */15](evd, rhs)) {
      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* subset */11], Termops$ReactTemplate.collect_vars(evd, rhs), names[0]);
    } else {
      return /* false */0;
    }
  };
  var body;
  if (fast(rhs$1)) {
    body = EConstr$ReactTemplate.of_constr(EConstr$ReactTemplate.to_constr(evd, rhs$1));
  } else {
    var t$prime = imitate(/* tuple */[
          env,
          0
        ], rhs$1);
    if (progress[0]) {
      recheck_applications(conv_algo, Evd$ReactTemplate.evar_env(evi), evdref, t$prime);
      body = t$prime;
    } else {
      body = t$prime;
    }
  }
  return /* tuple */[
          evdref[0],
          body
        ];
}

function evar_define(conv_algo, $staropt$star, env, evd, pbty, ev, rhs) {
  var argsv = ev[1];
  var evk = ev[0];
  var choose = $staropt$star ? $staropt$star[0] : /* false */0;
  var match = EConstr$ReactTemplate.kind(evd, rhs);
  if (match.tag === 3) {
    var ev2 = match[0];
    if (Evar$ReactTemplate.equal(evk, ev2[0])) {
      return solve_refl(/* Some */[choose], (function (param, param$1, param$2, param$3, param$4) {
                    var conv_algo$1 = conv_algo;
                    var env = param;
                    var evd = param$1;
                    var c = param$2;
                    var c$prime = param$3;
                    var rhs = param$4;
                    return is_success(Curry._5(conv_algo$1, env, evd, c, c$prime, rhs));
                  }), env, evd, pbty, evk, argsv, ev2[1]);
    } else {
      return solve_evar_evar(/* Some */[choose], (function (eta) {
                    return (function (param, param$1, param$2, param$3) {
                        var param$4 = /* None */0;
                        var param$5 = eta;
                        var param$6 = param;
                        var param$7 = param$1;
                        var param$8 = param$2;
                        var param$9 = param$3;
                        return evar_define(conv_algo, param$4, param$5, param$6, param$7, param$8, param$9);
                      });
                  }), conv_algo, env, evd, pbty, ev, ev2);
    }
  } else {
    try {
      var conv_algo$1 = conv_algo;
      var env$1 = env;
      var evd$1 = evd;
      var param = ev;
      var rhs$1 = rhs;
      var argsv$1 = param[1];
      var evk$1 = param[0];
      var evi = Evd$ReactTemplate.find(evd$1, evk$1);
      var match$1 = evi[/* evar_candidates */5];
      if (match$1) {
        var l$prime = Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function (c) {
                return filter_compatible_candidates(conv_algo$1, env$1, evd$1, evi, argsv$1, rhs$1, EConstr$ReactTemplate.of_constr(c));
              }), match$1[0]);
        if (l$prime) {
          if (l$prime[1]) {
            if (Curry._1(Util$ReactTemplate.List[/* length */0], l$prime) < Curry._1(Util$ReactTemplate.List[/* length */0], l$prime)) {
              var candidates = Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                      return prim[0];
                    }), l$prime);
              return restrict_evar(evd$1, evk$1, /* None */0, /* UpdateWith */[candidates]);
            } else {
              return evd$1;
            }
          } else {
            var match$2 = l$prime[0];
            var evd$2 = match$2[1];
            var c = match$2[0];
            if (Evd$ReactTemplate.is_undefined(evd$2, evk$1)) {
              var evd$prime = Evd$ReactTemplate.define(evk$1, EConstr$ReactTemplate.Unsafe[/* to_constr */0](c), evd$2);
              return check_evar_instance(evd$prime, evk$1, c, conv_algo$1);
            } else {
              return evd$2;
            }
          }
        } else {
          throw IncompatibleCandidates;
        }
      } else {
        throw NoCandidates;
      }
    }
    catch (exn){
      if (exn === NoCandidates) {
        try {
          var match$3 = invert_definition(conv_algo, choose, env, evd, pbty, ev, rhs);
          var body = match$3[1];
          var evd$prime$1 = match$3[0];
          if (Termops$ReactTemplate.occur_meta(evd$prime$1, body)) {
            throw MetaOccurInBodyInternal;
          }
          if (occur_evar_upto_types(evd$prime$1, evk, body)) {
            throw [
                  OccurCheckIn,
                  evd$prime$1,
                  body
                ];
          }
          var match$4 = refresh_universes(/* None */0, /* None */0, /* None */0, pbty, env, evd$prime$1, body);
          var body$1 = match$4[1];
          var evd$prime$2 = check_evar_instance(match$4[0], evk, body$1, conv_algo);
          return Evd$ReactTemplate.define(evk, EConstr$ReactTemplate.Unsafe[/* to_constr */0](body$1), evd$prime$2);
        }
        catch (raw_e){
          var e = Js_exn.internalToOCamlException(raw_e);
          if (e[0] === NotEnoughInformationToProgress) {
            var env$2 = env;
            var evd$3 = evd;
            var pbty$1 = pbty;
            var ev$1 = ev;
            var sols = e[1];
            var rhs$2 = rhs;
            var evk$2 = ev$1[0];
            var rhs$3 = expand_vars_in_term(env$2, evd$3)(rhs$2);
            var filter = restrict_upon_filter(evd$3, evk$2, (function (a) {
                    if (!(EConstr$ReactTemplate.isRel(evd$3, a) || EConstr$ReactTemplate.isVar(evd$3, a)) || Termops$ReactTemplate.dependent(evd$3, a, rhs$3)) {
                      return /* true */1;
                    } else {
                      return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                                    return EConstr$ReactTemplate.isVarId(evd$3, param[0], a);
                                  }), sols);
                    }
                  }), ev$1[1]);
            var filter$1 = closure_of_filter(evd$3, evk$2, filter);
            var candidates$1 = extract_candidates(sols);
            if (candidates$1) {
              return restrict_evar(evd$3, evk$2, filter$1, /* UpdateWith */[candidates$1[0]]);
            } else {
              var match$5 = restrict_applied_evar(evd$3, ev$1, filter$1, /* NoUpdate */0);
              var pb_002 = EConstr$ReactTemplate.mkEvar(match$5[1]);
              var pb = /* tuple */[
                pbty$1,
                env$2,
                pb_002,
                rhs$3
              ];
              return add_conv_oriented_pb(/* None */0, pb, match$5[0]);
            }
          } else if (e[0] === NotEnoughInformationEvarEvar) {
            return add_conv_oriented_pb(/* None */0, /* tuple */[
                        pbty,
                        env,
                        EConstr$ReactTemplate.mkEvar(ev),
                        e[1]
                      ], evd);
          } else if (e === MorePreciseOccurCheckNeeeded) {
            return add_conv_oriented_pb(/* None */0, /* tuple */[
                        pbty,
                        env,
                        EConstr$ReactTemplate.mkEvar(ev),
                        rhs
                      ], evd);
          } else if (e[0] === NotInvertibleUsingOurAlgorithm) {
            throw e;
          } else if (e === MetaOccurInBodyInternal) {
            throw e;
          } else if (e[0] === OccurCheckIn) {
            var rhs$4 = e[2];
            var evd$4 = e[1];
            var c$1 = Reductionops$ReactTemplate.whd_all(env)(evd$4, rhs$4);
            var match$6 = EConstr$ReactTemplate.kind(evd$4, c$1);
            if (match$6.tag === 3) {
              var match$7 = match$6[0];
              if (Evar$ReactTemplate.equal(evk, match$7[0])) {
                return solve_refl(/* None */0, (function (env, sigma, pb, c, c$prime) {
                              return Curry._4(Reductionops$ReactTemplate.is_fconv(/* None */0, pb), env, sigma, c, c$prime);
                            }), env, evd$4, pbty, evk, argsv, match$7[1]);
              } else {
                throw [
                      OccurCheckIn,
                      evd$4,
                      rhs$4
                    ];
              }
            } else {
              throw [
                    OccurCheckIn,
                    evd$4,
                    rhs$4
                  ];
            }
          } else {
            throw e;
          }
        }
      } else {
        throw exn;
      }
    }
  }
}

function reconsider_unif_constraints(conv_algo, evd) {
  var match = Evd$ReactTemplate.extract_changed_conv_pbs(evd, (function (param, param$1) {
          var evd$1 = evd;
          var lev = param;
          var param$2 = param$1;
          var t1 = EConstr$ReactTemplate.of_constr(param$2[2]);
          var t2 = EConstr$ReactTemplate.of_constr(param$2[3]);
          var tmp;
          try {
            tmp = Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], Evarutil$ReactTemplate.head_evar(evd$1, t1), lev);
          }
          catch (exn){
            if (exn === Evarutil$ReactTemplate.NoHeadEvar) {
              tmp = /* false */0;
            } else {
              throw exn;
            }
          }
          if (tmp) {
            return /* true */1;
          } else {
            try {
              return Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], Evarutil$ReactTemplate.head_evar(evd$1, t2), lev);
            }
            catch (exn$1){
              if (exn$1 === Evarutil$ReactTemplate.NoHeadEvar) {
                return /* false */0;
              } else {
                throw exn$1;
              }
            }
          }
        }));
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (p, x) {
                if (p.tag) {
                  return p;
                } else {
                  var x$1 = Curry._5(conv_algo, x[1], p[0], x[0], EConstr$ReactTemplate.of_constr(x[2]), EConstr$ReactTemplate.of_constr(x[3]));
                  if (x$1.tag) {
                    return /* UnifFailure */Block.__(1, [
                              x$1[0],
                              /* CannotSolveConstraint */Block.__(6, [
                                  x,
                                  x$1[1]
                                ])
                            ]);
                  } else {
                    return x$1;
                  }
                }
              }), /* Success */Block.__(0, [match[0]]), match[1]);
}

function solve_simple_eqn(conv_algo, $staropt$star, env, evd, param) {
  var t2 = param[2];
  var ev1 = param[1];
  var evk1 = ev1[0];
  var choose = $staropt$star ? $staropt$star[0] : /* false */0;
  try {
    var t2$1 = Reductionops$ReactTemplate.whd_betaiota(evd, t2);
    var evd$1 = evar_define(conv_algo, /* Some */[choose], env, evd, param[0], ev1, t2$1);
    return reconsider_unif_constraints(conv_algo, evd$1);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === NotInvertibleUsingOurAlgorithm) {
      return /* UnifFailure */Block.__(1, [
                evd,
                /* NotClean */Block.__(1, [
                    ev1,
                    env,
                    exn[1]
                  ])
              ]);
    } else if (exn[0] === OccurCheckIn) {
      return /* UnifFailure */Block.__(1, [
                exn[1],
                /* OccurCheck */Block.__(0, [
                    evk1,
                    exn[2]
                  ])
              ]);
    } else if (exn === MetaOccurInBodyInternal) {
      return /* UnifFailure */Block.__(1, [
                evd,
                /* MetaOccurInBody */Block.__(3, [evk1])
              ]);
    } else if (exn[0] === IllTypedInstance) {
      return /* UnifFailure */Block.__(1, [
                evd,
                /* InstanceNotSameType */Block.__(4, [
                    evk1,
                    exn[1],
                    exn[2],
                    exn[3]
                  ])
              ]);
    } else if (exn === IncompatibleCandidates) {
      return /* UnifFailure */Block.__(1, [
                evd,
                /* ConversionFailed */Block.__(2, [
                    env,
                    EConstr$ReactTemplate.mkEvar(ev1),
                    t2
                  ])
              ]);
    } else {
      throw exn;
    }
  }
}

var reconsider_conv_pbs = reconsider_unif_constraints;

exports.of_alias = of_alias;
exports.is_success = is_success;
exports.expand_vars_in_term = expand_vars_in_term;
exports.evar_define = evar_define;
exports.refresh_universes = refresh_universes;
exports.solve_refl = solve_refl;
exports.solve_evar_evar = solve_evar_evar;
exports.solve_simple_eqn = solve_simple_eqn;
exports.reconsider_unif_constraints = reconsider_unif_constraints;
exports.reconsider_conv_pbs = reconsider_conv_pbs;
exports.is_unification_pattern_evar = is_unification_pattern_evar;
exports.is_unification_pattern = is_unification_pattern;
exports.solve_pattern_eqn = solve_pattern_eqn;
exports.noccur_evar = noccur_evar;
exports.IllTypedInstance = IllTypedInstance;
exports.check_evar_instance = check_evar_instance;
exports.remove_instance_local_defs = remove_instance_local_defs;
exports.get_type_of_refresh = get_type_of_refresh;
/* Pp-ReactTemplate Not a pure module */
