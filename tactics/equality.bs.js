// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Int$ReactTemplate = require("../src/int.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var CAst$ReactTemplate = require("../src/cAst.bs.js");
var Evar$ReactTemplate = require("../src/evar.bs.js");
var Goal$ReactTemplate = require("../src/goal.bs.js");
var Hook$ReactTemplate = require("../src/hook.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Vars$ReactTemplate = require("../src/vars.bs.js");
var Clenv$ReactTemplate = require("../proofs/clenv.bs.js");
var Logic$ReactTemplate = require("../src/logic.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Sorts$ReactTemplate = require("../src/sorts.bs.js");
var Coqlib$ReactTemplate = require("../library/coqlib.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Indrec$ReactTemplate = require("../src/indrec.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var Tacred$ReactTemplate = require("../src/tacred.bs.js");
var Typing$ReactTemplate = require("../src/typing.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Tacmach$ReactTemplate = require("../proofs/tacmach.bs.js");
var Tactics$ReactTemplate = require("../src/tactics.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Clenvtac$ReactTemplate = require("../proofs/clenvtac.bs.js");
var Evarconv$ReactTemplate = require("../src/evarconv.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Locusops$ReactTemplate = require("../src/locusops.bs.js");
var Retyping$ReactTemplate = require("../src/retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Eqschemes$ReactTemplate = require("./eqschemes.bs.js");
var Globnames$ReactTemplate = require("../src/globnames.bs.js");
var Hipattern$ReactTemplate = require("./hipattern.bs.js");
var Inductive$ReactTemplate = require("../src/inductive.bs.js");
var Proofview$ReactTemplate = require("../src/proofview.bs.js");
var Tacticals$ReactTemplate = require("./tacticals.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Ind_tables$ReactTemplate = require("./ind_tables.bs.js");
var Elimschemes$ReactTemplate = require("./elimschemes.bs.js");
var Unification$ReactTemplate = require("../pretyping/unification.bs.js");
var Inductiveops$ReactTemplate = require("../src/inductiveops.bs.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("../src/pretype_errors.bs.js");
var Constr_matching$ReactTemplate = require("../src/constr_matching.bs.js");

function use_injection_pattern_l2r_order(param) {
  if (param) {
    return param[0][/* injection_pattern_l2r_order */2];
  } else {
    return /* true */1;
  }
}

var injection_in_context = [/* false */0];

function use_injection_in_context(param) {
  if (param) {
    return param[0][/* injection_in_context */1];
  } else {
    return injection_in_context[0];
  }
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"injection in context",
      /* optkey : :: */[
        "Structural",
        /* :: */[
          "Injection",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return injection_in_context[0];
        }),
      /* optwrite */(function (b) {
          injection_in_context[0] = b;
          return /* () */0;
        })
    ]);

var rewrite_core_unif_flags_008 = /* frozen_evars */Evar$ReactTemplate.$$Set[/* empty */0];

var rewrite_core_unif_flags = /* record */[
  /* modulo_conv_on_closed_terms : None */0,
  /* use_metas_eagerly_in_conv_on_closed_terms : true */1,
  /* use_evars_eagerly_in_conv_on_closed_terms : false */0,
  /* modulo_delta */Names$ReactTemplate.empty_transparent_state,
  /* modulo_delta_types */Names$ReactTemplate.empty_transparent_state,
  /* check_applied_meta_types : true */1,
  /* use_pattern_unification : true */1,
  /* use_meta_bound_pattern_unification : true */1,
  rewrite_core_unif_flags_008,
  /* restrict_conv_on_strict_subterms : false */0,
  /* modulo_betaiota : false */0,
  /* modulo_eta : true */1
];

var rewrite_unif_flags = /* record */[
  /* core_unify_flags */rewrite_core_unif_flags,
  /* merge_unify_flags */rewrite_core_unif_flags,
  /* subterm_unify_flags */rewrite_core_unif_flags,
  /* allow_K_in_toplevel_higher_order_unification : false */0,
  /* resolve_evars : true */1
];

function make_flags(frzevars, sigma, flags, clause) {
  if (frzevars) {
    var sigma$1 = sigma;
    var flags$1 = flags;
    var clause$1 = clause;
    var newevars = Evarutil$ReactTemplate.undefined_evars_of_term(sigma$1, Clenv$ReactTemplate.clenv_type(clause$1));
    var evars = Evd$ReactTemplate.fold_undefined((function (evk, _, evars) {
            if (Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], evk, newevars)) {
              return evars;
            } else {
              return Curry._2(Evar$ReactTemplate.$$Set[/* add */3], evk, evars);
            }
          }), sigma$1, Evar$ReactTemplate.$$Set[/* empty */0]);
    var newrecord = flags$1[/* core_unify_flags */0].slice();
    var newrecord$1 = flags$1[/* merge_unify_flags */1].slice();
    var newrecord$2 = flags$1[/* subterm_unify_flags */2].slice();
    return /* record */[
            /* core_unify_flags */(newrecord[/* frozen_evars */8] = evars, newrecord),
            /* merge_unify_flags */(newrecord$1[/* frozen_evars */8] = evars, newrecord$1),
            /* subterm_unify_flags */(newrecord$2[/* frozen_evars */8] = evars, newrecord$2),
            /* allow_K_in_toplevel_higher_order_unification */flags$1[/* allow_K_in_toplevel_higher_order_unification */3],
            /* resolve_evars */flags$1[/* resolve_evars */4]
          ];
  } else {
    return flags;
  }
}

function side_tac(tac, sidetac) {
  if (sidetac) {
    return Tacticals$ReactTemplate.New[/* tclTHENSFIRSTn */13](tac, /* array */[Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0)], sidetac[0]);
  } else {
    return tac;
  }
}

var rewrite_conv_closed_core_unif_flags_000 = /* modulo_conv_on_closed_terms : Some */[Names$ReactTemplate.full_transparent_state];

var rewrite_conv_closed_core_unif_flags_008 = /* frozen_evars */Evar$ReactTemplate.$$Set[/* empty */0];

var rewrite_conv_closed_core_unif_flags = /* record */[
  rewrite_conv_closed_core_unif_flags_000,
  /* use_metas_eagerly_in_conv_on_closed_terms : true */1,
  /* use_evars_eagerly_in_conv_on_closed_terms : false */0,
  /* modulo_delta */Names$ReactTemplate.empty_transparent_state,
  /* modulo_delta_types */Names$ReactTemplate.full_transparent_state,
  /* check_applied_meta_types : true */1,
  /* use_pattern_unification : true */1,
  /* use_meta_bound_pattern_unification : true */1,
  rewrite_conv_closed_core_unif_flags_008,
  /* restrict_conv_on_strict_subterms : false */0,
  /* modulo_betaiota : false */0,
  /* modulo_eta : true */1
];

var rewrite_conv_closed_unif_flags = /* record */[
  /* core_unify_flags */rewrite_conv_closed_core_unif_flags,
  /* merge_unify_flags */rewrite_conv_closed_core_unif_flags,
  /* subterm_unify_flags */rewrite_conv_closed_core_unif_flags,
  /* allow_K_in_toplevel_higher_order_unification : false */0,
  /* resolve_evars : false */0
];

var rewrite_keyed_core_unif_flags_000 = /* modulo_conv_on_closed_terms : Some */[Names$ReactTemplate.full_transparent_state];

var rewrite_keyed_core_unif_flags_008 = /* frozen_evars */Evar$ReactTemplate.$$Set[/* empty */0];

var rewrite_keyed_core_unif_flags = /* record */[
  rewrite_keyed_core_unif_flags_000,
  /* use_metas_eagerly_in_conv_on_closed_terms : true */1,
  /* use_evars_eagerly_in_conv_on_closed_terms : false */0,
  /* modulo_delta */Names$ReactTemplate.full_transparent_state,
  /* modulo_delta_types */Names$ReactTemplate.full_transparent_state,
  /* check_applied_meta_types : true */1,
  /* use_pattern_unification : true */1,
  /* use_meta_bound_pattern_unification : true */1,
  rewrite_keyed_core_unif_flags_008,
  /* restrict_conv_on_strict_subterms : false */0,
  /* modulo_betaiota : true */1,
  /* modulo_eta : true */1
];

var rewrite_keyed_unif_flags = /* record */[
  /* core_unify_flags */rewrite_keyed_core_unif_flags,
  /* merge_unify_flags */rewrite_keyed_core_unif_flags,
  /* subterm_unify_flags */rewrite_keyed_core_unif_flags,
  /* allow_K_in_toplevel_higher_order_unification : false */0,
  /* resolve_evars : false */0
];

function rewrite_elim(with_evars, frzevars, cls, c, e) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var flags = Unification$ReactTemplate.is_keyed_unification(/* () */0) ? rewrite_keyed_unif_flags : rewrite_conv_closed_unif_flags;
                var flags$1 = make_flags(frzevars, Tacmach$ReactTemplate.New[/* project */3](gl), flags, c);
                return Tactics$ReactTemplate.general_elim_clause(with_evars, flags$1, cls, c, e);
              }));
}

function tclNOTSAMEGOAL(tac) {
  return Proofview$ReactTemplate.Goal[/* nf_enter */8]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var ev = Proofview$ReactTemplate.Goal[/* goal */13](gl);
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], tac, (function () {
                              return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.Goal[/* goals */11], (function (gls) {
                                            var check = function (accu, gl$prime) {
                                              return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], gl$prime, (function (gl$prime) {
                                                            return Curry._1(Proofview$ReactTemplate.tclUNIT, accu || Goal$ReactTemplate.V82[/* same_goal */9](sigma, ev, Tacmach$ReactTemplate.New[/* project */3](gl$prime), Proofview$ReactTemplate.Goal[/* goal */13](gl$prime)));
                                                          }));
                                            };
                                            return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Curry._3(Proofview$ReactTemplate.Monad[/* List */4][/* fold_left */3], check, /* false */0, gls), (function (has_same) {
                                                          if (has_same) {
                                                            return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Tactic generated a subgoal identical to the original goal."));
                                                          } else {
                                                            return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                                                          }
                                                        }));
                                          }));
                            }));
              }));
}

function general_elim_clause(with_evars, frzevars, cls, rew, elim) {
  return Proofview$ReactTemplate.tclORELSE(cls ? rewrite_elim(with_evars, frzevars, cls, rew, elim) : tclNOTSAMEGOAL(rewrite_elim(with_evars, frzevars, cls, rew, elim)), (function (param) {
                var info = param[1];
                var e = param[0];
                if (e[0] === Pretype_errors$ReactTemplate.PretypeError) {
                  var match = e[3];
                  if (match.tag === 8) {
                    return Proofview$ReactTemplate.tclZERO(/* None */0, [
                                Pretype_errors$ReactTemplate.PretypeError,
                                e[1],
                                e[2],
                                /* NoOccurrenceFound */Block.__(8, [
                                    match[0],
                                    cls
                                  ])
                              ]);
                  } else {
                    return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                  }
                } else {
                  return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                }
              }));
}

var match = Hook$ReactTemplate.make(/* None */0, /* () */0);

var forward_general_setoid_rewrite_clause = match[0];

function jmeq_same_dom(env, sigma, param) {
  if (param) {
    var match = EConstr$ReactTemplate.decompose_prod_assum(sigma, param[0]);
    var env$1 = EConstr$ReactTemplate.push_rel_context(match[0], env);
    var match$1 = EConstr$ReactTemplate.decompose_app(sigma, match[1]);
    var match$2 = match$1[1];
    if (match$2) {
      var match$3 = match$2[1];
      if (match$3) {
        var match$4 = match$3[1];
        if (match$4) {
          var match$5 = match$4[1];
          if (match$5 && !match$5[1]) {
            return Reductionops$ReactTemplate.is_conv(/* None */0, env$1, sigma)(match$2[0], match$4[0]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  } else {
    return /* true */1;
  }
}

function find_elim(hdcncl, lft2rgt, dep, cls, ot) {
  return Proofview$ReactTemplate.Goal[/* enter_one */10](/* None */0, (function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var inccl = Option$ReactTemplate.is_empty(cls);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                if ((Termops$ReactTemplate.is_global(sigma, Coqlib$ReactTemplate.glob_eq, hdcncl) || Termops$ReactTemplate.is_global(sigma, Coqlib$ReactTemplate.glob_jmeq, hdcncl) && jmeq_same_dom(env, sigma, ot)) && !dep) {
                  var match = EConstr$ReactTemplate.kind(sigma, hdcncl);
                  var c;
                  if (match.tag === 11) {
                    var pr1 = Indrec$ReactTemplate.lookup_eliminator(match[0][0], Tacticals$ReactTemplate.New[/* elimination_sort_of_clause */52](cls, gl));
                    var exit = 0;
                    if (lft2rgt) {
                      if (lft2rgt[0] !== 0) {
                        if (cls) {
                          c = Globnames$ReactTemplate.destConstRef(pr1);
                        } else {
                          exit = 1;
                        }
                      } else if (cls) {
                        exit = 1;
                      } else {
                        c = Globnames$ReactTemplate.destConstRef(pr1);
                      }
                    } else {
                      c = Globnames$ReactTemplate.destConstRef(pr1);
                    }
                    if (exit === 1) {
                      var c1 = Globnames$ReactTemplate.destConstRef(pr1);
                      var match$1 = Names$ReactTemplate.Constant[/* repr3 */6](Names$ReactTemplate.Constant[/* make1 */1](Names$ReactTemplate.Constant[/* canonical */5](c1)));
                      var l$prime = Names$ReactTemplate.Label[/* of_id */5](Nameops$ReactTemplate.add_suffix(Names$ReactTemplate.Label[/* to_id */6](match$1[2]), "_r"));
                      var c1$prime = Global$ReactTemplate.constant_of_delta_kn(Names$ReactTemplate.KerName[/* make */0](match$1[0], match$1[1], l$prime));
                      try {
                        Global$ReactTemplate.lookup_constant(c1$prime);
                        c = c1$prime;
                      }
                      catch (exn){
                        if (exn === Caml_builtin_exceptions.not_found) {
                          c = CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Equality.find_elim"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot find rewrite principle "), Names$ReactTemplate.Label[/* print */7](l$prime)), Pp$ReactTemplate.str(".")));
                        } else {
                          throw exn;
                        }
                      }
                    }
                    
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "equality.ml",
                            374,
                            1
                          ]
                        ];
                  }
                  return Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](/* ConstRef */Block.__(1, [c]));
                } else {
                  var scheme_name = dep !== 0 ? (
                      lft2rgt ? (
                          lft2rgt[0] !== 0 ? (
                              inccl !== 0 ? Eqschemes$ReactTemplate.rew_l2r_dep_scheme_kind : Eqschemes$ReactTemplate.rew_l2r_forward_dep_scheme_kind
                            ) : (
                              inccl !== 0 ? Eqschemes$ReactTemplate.rew_r2l_dep_scheme_kind : Eqschemes$ReactTemplate.rew_r2l_forward_dep_scheme_kind
                            )
                        ) : (
                          inccl !== 0 ? Eqschemes$ReactTemplate.rew_r2l_dep_scheme_kind : Eqschemes$ReactTemplate.rew_r2l_forward_dep_scheme_kind
                        )
                    ) : (
                      lft2rgt ? (
                          lft2rgt[0] !== 0 ? (
                              inccl !== 0 ? Eqschemes$ReactTemplate.rew_l2r_scheme_kind : Eqschemes$ReactTemplate.rew_r2l_scheme_kind
                            ) : (
                              inccl !== 0 ? Eqschemes$ReactTemplate.rew_r2l_scheme_kind : Eqschemes$ReactTemplate.rew_l2r_scheme_kind
                            )
                        ) : (
                          inccl !== 0 ? Eqschemes$ReactTemplate.rew_r2l_scheme_kind : Eqschemes$ReactTemplate.rew_l2r_scheme_kind
                        )
                    );
                  var match$2 = EConstr$ReactTemplate.kind(sigma, hdcncl);
                  if (match$2.tag === 11) {
                    var match$3 = Ind_tables$ReactTemplate.find_scheme(/* None */0, scheme_name, match$2[0][0]);
                    return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.tclEFFECTS(match$3[1]), Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](/* ConstRef */Block.__(1, [match$3[0]])));
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "equality.ml",
                            396,
                            9
                          ]
                        ];
                  }
                }
              }));
}

function type_of_clause(cls, gl) {
  if (cls) {
    return Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](cls[0], gl);
  } else {
    return Proofview$ReactTemplate.Goal[/* concl */2](gl);
  }
}

function leibniz_rewrite_ebindings_clause(cls, lft2rgt, tac, c, t, l, with_evars, frzevars, dep_proof_ok, hdcncl) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var evd = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var isatomic = EConstr$ReactTemplate.isProd(evd, Reductionops$ReactTemplate.whd_zeta(evd, hdcncl));
                var dep_fun = isatomic ? Termops$ReactTemplate.dependent : Termops$ReactTemplate.dependent_no_evar;
                var type_of_cls = type_of_clause(cls, gl);
                var dep = dep_proof_ok && Curry._3(dep_fun, evd, c, type_of_cls);
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], find_elim(hdcncl, lft2rgt, dep, cls, /* Some */[t]), (function (elim) {
                              var with_evars$1 = with_evars;
                              var frzevars$1 = frzevars;
                              var tac$1 = tac;
                              var cls$1 = cls;
                              var c$1 = c;
                              var t$1 = t;
                              var l$1 = l;
                              var l2r = lft2rgt ? lft2rgt[0] : /* false */0;
                              var elim$1 = /* record */[
                                /* elimindex : None */0,
                                /* elimrename : None */0,
                                /* elimbody : tuple */[
                                  elim,
                                  /* NoBindings */0
                                ]
                              ];
                              var match;
                              if (tac$1) {
                                var match$1 = tac$1[0];
                                var tac$2 = match$1[0];
                                switch (match$1[1]) {
                                  case 0 : 
                                      match = /* tuple */[
                                        /* false */0,
                                        /* false */0,
                                        /* Some */[tac$2]
                                      ];
                                      break;
                                  case 1 : 
                                      match = /* tuple */[
                                        /* true */1,
                                        /* true */1,
                                        /* Some */[Tacticals$ReactTemplate.New[/* tclCOMPLETE */31](tac$2)]
                                      ];
                                      break;
                                  case 2 : 
                                      match = /* tuple */[
                                        /* true */1,
                                        /* false */0,
                                        /* Some */[Tacticals$ReactTemplate.New[/* tclCOMPLETE */31](tac$2)]
                                      ];
                                      break;
                                  
                                }
                              } else {
                                match = /* tuple */[
                                  /* false */0,
                                  /* false */0,
                                  /* None */0
                                ];
                              }
                              var tac$3 = match[2];
                              var firstonly = match[1];
                              var all = match[0];
                              var try_clause = function (c) {
                                return side_tac(Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](c[/* evd */1]), general_elim_clause(with_evars$1, frzevars$1, cls$1, c, elim$1)), tac$3);
                              };
                              return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                            var instantiate_lemma = function (concl) {
                                              if (all) {
                                                var frzevars$2 = frzevars$1;
                                                var gl$1 = gl;
                                                var c$2 = c$1;
                                                var ty = t$1;
                                                var l$2 = l$1;
                                                var l2r$1 = l2r;
                                                var concl$1 = concl;
                                                var env = Proofview$ReactTemplate.Goal[/* env */4](gl$1);
                                                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl$1);
                                                var eqclause = Curry._2(Tacmach$ReactTemplate.New[/* pf_apply */0](Clenv$ReactTemplate.make_clenv_binding, gl$1), /* tuple */[
                                                      c$2,
                                                      ty
                                                    ], l$2);
                                                var match = Termops$ReactTemplate.decompose_app_vect(sigma, Clenv$ReactTemplate.clenv_type(eqclause));
                                                var args = match[1];
                                                var arglen = args.length;
                                                if (arglen < 2) {
                                                  CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The term provided is not an applied relation."));
                                                }
                                                var c1 = Caml_array.caml_array_get(args, arglen - 2 | 0);
                                                var c2 = Caml_array.caml_array_get(args, arglen - 1 | 0);
                                                var try_occ = function (param) {
                                                  return Clenvtac$ReactTemplate.clenv_pose_dependent_evars(/* true */1, /* record */[
                                                              /* env */eqclause[/* env */0],
                                                              /* evd */param[0],
                                                              /* templval */eqclause[/* templval */2],
                                                              /* templtyp */eqclause[/* templtyp */3]
                                                            ]);
                                                };
                                                var flags = make_flags(frzevars$2, Tacmach$ReactTemplate.New[/* project */3](gl$1), rewrite_unif_flags, eqclause);
                                                var occs = Unification$ReactTemplate.w_unify_to_subterm_all(env, eqclause[/* evd */1], /* Some */[flags], /* tuple */[
                                                      l2r$1 ? c1 : c2,
                                                      concl$1
                                                    ]);
                                                return Curry._2(Util$ReactTemplate.List[/* map */10], try_occ, occs);
                                              } else {
                                                var gl$2 = gl;
                                                var c$3 = c$1;
                                                var l$3 = l$1;
                                                var match$1 = Tacmach$ReactTemplate.New[/* pf_type_of */8](gl$2, c$3);
                                                var ct = match$1[1];
                                                var sigma$1 = match$1[0];
                                                var t$2;
                                                try {
                                                  t$2 = Tacred$ReactTemplate.reduce_to_quantified_ind(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl$2), sigma$1, ct)[1];
                                                }
                                                catch (raw_exn){
                                                  var exn = Js_exn.internalToOCamlException(raw_exn);
                                                  if (exn[0] === CErrors$ReactTemplate.UserError) {
                                                    t$2 = ct;
                                                  } else {
                                                    throw exn;
                                                  }
                                                }
                                                var eqclause$1 = Clenv$ReactTemplate.make_clenv_binding(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl$2), sigma$1)(/* tuple */[
                                                      c$3,
                                                      t$2
                                                    ], l$3);
                                                return /* :: */[
                                                        eqclause$1,
                                                        /* [] */0
                                                      ];
                                              }
                                            };
                                            var typ = cls$1 ? Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](cls$1[0], gl) : Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
                                            var cs = instantiate_lemma(typ);
                                            if (firstonly) {
                                              return Tacticals$ReactTemplate.New[/* tclFIRST */23](Curry._2(Util$ReactTemplate.List[/* map */10], try_clause, cs));
                                            } else {
                                              return Tacticals$ReactTemplate.New[/* tclMAP */20](try_clause, cs);
                                            }
                                          }));
                            }));
              }));
}

function adjust_rewriting_direction(args, lft2rgt) {
  if (args) {
    if (args[1]) {
      return /* Some */[lft2rgt];
    } else {
      if (!lft2rgt) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Rewriting non-symmetric equality not allowed from right-to-left."));
      }
      return /* None */0;
    }
  } else {
    return /* Some */[lft2rgt];
  }
}

function rewrite_side_tac(tac, sidetac) {
  return side_tac(tac, Option$ReactTemplate.map((function (prim) {
                    return prim[0];
                  }), sidetac));
}

function general_rewrite_ebindings_clause(cls, lft2rgt, occs, frzevars, dep_proof_ok, tac, param, with_evars) {
  var l = param[1];
  var c = param[0];
  if (occs !== /* AllOccurrences */0) {
    return rewrite_side_tac(Curry._5(Hook$ReactTemplate.get(forward_general_setoid_rewrite_clause), cls, lft2rgt, occs, /* tuple */[
                    c,
                    l
                  ], /* [] */0), tac);
  } else {
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                  var ctype = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c);
                  var match = EConstr$ReactTemplate.decompose_prod_assum(sigma, Reductionops$ReactTemplate.whd_betaiotazeta(sigma, ctype));
                  var t = match[1];
                  var rels = match[0];
                  var match$1 = Hipattern$ReactTemplate.match_with_equality_type(sigma, t);
                  if (match$1) {
                    var match$2 = match$1[0];
                    var lft2rgt$1 = adjust_rewriting_direction(match$2[1], lft2rgt);
                    return leibniz_rewrite_ebindings_clause(cls, lft2rgt$1, tac, c, EConstr$ReactTemplate.it_mkProd_or_LetIn(t, rels), l, with_evars, frzevars, dep_proof_ok, match$2[0]);
                  } else {
                    return Proofview$ReactTemplate.tclORELSE(rewrite_side_tac(Curry._5(Hook$ReactTemplate.get(forward_general_setoid_rewrite_clause), cls, lft2rgt, occs, /* tuple */[
                                        c,
                                        l
                                      ], /* [] */0), tac), (function (param) {
                                  var info = param[1];
                                  var e = param[0];
                                  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                                                var env$prime = EConstr$ReactTemplate.push_rel_context(rels, env);
                                                var match = Reductionops$ReactTemplate.splay_prod_assum(env$prime, sigma)(t);
                                                var t$prime = match[1];
                                                var match$1 = Hipattern$ReactTemplate.match_with_equality_type(sigma, t$prime);
                                                if (match$1) {
                                                  var match$2 = match$1[0];
                                                  var lft2rgt$2 = adjust_rewriting_direction(match$2[1], lft2rgt);
                                                  return leibniz_rewrite_ebindings_clause(cls, lft2rgt$2, tac, c, EConstr$ReactTemplate.it_mkProd_or_LetIn(t$prime, Util$ReactTemplate.$at(match[0], rels)), l, with_evars, frzevars, dep_proof_ok, match$2[0]);
                                                } else {
                                                  return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                                                }
                                              }));
                                }));
                  }
                }));
  }
}

function general_rewrite_ebindings(param, param$1, param$2, param$3, param$4, param$5, param$6) {
  return general_rewrite_ebindings_clause(/* None */0, param, param$1, param$2, param$3, param$4, param$5, param$6);
}

function general_rewrite_bindings(l2r, occs, frzevars, dep_proof_ok, tac, param) {
  var partial_arg_000 = param[0];
  var partial_arg_001 = param[1];
  var partial_arg = /* tuple */[
    partial_arg_000,
    partial_arg_001
  ];
  return (function (param) {
      return general_rewrite_ebindings_clause(/* None */0, l2r, occs, frzevars, dep_proof_ok, tac, partial_arg, param);
    });
}

function general_rewrite(l2r, occs, frzevars, dep_proof_ok, tac, c) {
  return general_rewrite_bindings(l2r, occs, frzevars, dep_proof_ok, tac, /* tuple */[
                c,
                /* NoBindings */0
              ])(/* false */0);
}

function general_rewrite_ebindings_in(l2r, occs, frzevars, dep_proof_ok, tac, id) {
  var partial_arg = /* Some */[id];
  return (function (param, param$1) {
      return general_rewrite_ebindings_clause(partial_arg, l2r, occs, frzevars, dep_proof_ok, tac, param, param$1);
    });
}

function general_rewrite_bindings_in(l2r, occs, frzevars, dep_proof_ok, tac, id, param) {
  var partial_arg_000 = param[0];
  var partial_arg_001 = param[1];
  var partial_arg = /* tuple */[
    partial_arg_000,
    partial_arg_001
  ];
  var partial_arg$1 = /* Some */[id];
  return (function (param) {
      return general_rewrite_ebindings_clause(partial_arg$1, l2r, occs, frzevars, dep_proof_ok, tac, partial_arg, param);
    });
}

function general_rewrite_in(l2r, occs, frzevars, dep_proof_ok, tac, id, c) {
  var partial_arg = /* tuple */[
    c,
    /* NoBindings */0
  ];
  var partial_arg$1 = /* Some */[id];
  return (function (param) {
      return general_rewrite_ebindings_clause(partial_arg$1, l2r, occs, frzevars, dep_proof_ok, tac, partial_arg, param);
    });
}

function general_rewrite_clause(l2r, with_evars, tac, c, cl) {
  var partial_arg = Curry._2(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
          if (param.tag) {
            return acc;
          } else {
            return /* :: */[
                    param[0],
                    acc
                  ];
          }
        }), /* [] */0);
  var occs_of = function (param) {
    return Locusops$ReactTemplate.occurrences_map(partial_arg, param);
  };
  var match = cl[/* onhyps */0];
  if (match) {
    var l = match[0];
    var do_hyps = function (param) {
      if (param) {
        var match = param[0][0];
        return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](general_rewrite_ebindings_in(l2r, Curry._1(occs_of, match[0]), /* false */0, /* true */1, tac, match[1])(c, with_evars), do_hyps(param[1]));
      } else {
        return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
      }
    };
    if (cl[/* concl_occs */1] === /* NoOccurrences */1) {
      return do_hyps(l);
    } else {
      return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](general_rewrite_ebindings(l2r, Curry._1(occs_of, cl[/* concl_occs */1]), /* false */0, /* true */1, tac, c, with_evars), do_hyps(l));
    }
  } else {
    var do_hyps_atleastonce = function (param) {
      if (param) {
        return Tacticals$ReactTemplate.New[/* tclIFTHENFIRSTTRYELSEMUST */27](general_rewrite_ebindings_in(l2r, /* AllOccurrences */0, /* false */0, /* true */1, tac, param[0])(c, with_evars), do_hyps_atleastonce(param[1]));
      } else {
        return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Nothing to rewrite."));
      }
    };
    var ids = function (gl) {
      var ids_in_c = Termops$ReactTemplate.global_vars_set(Proofview$ReactTemplate.Goal[/* env */4](gl), Tacmach$ReactTemplate.New[/* project */3](gl), c[0]);
      var ids_of_hyps = Tacmach$ReactTemplate.New[/* pf_ids_of_hyps */11](gl);
      return Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], (function (id, l) {
                    return Curry._3(Util$ReactTemplate.List[/* remove */88], Names$ReactTemplate.Id[/* equal */0], id, l);
                  }), ids_in_c, ids_of_hyps);
    };
    var do_hyps$1 = Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
            return do_hyps_atleastonce(ids(gl));
          }));
    if (cl[/* concl_occs */1] === /* NoOccurrences */1) {
      return do_hyps$1;
    } else {
      return Tacticals$ReactTemplate.New[/* tclIFTHENFIRSTTRYELSEMUST */27](general_rewrite_ebindings(l2r, Curry._1(occs_of, cl[/* concl_occs */1]), /* false */0, /* true */1, tac, c, with_evars), do_hyps$1);
    }
  }
}

function apply_special_clear_request(clear_flag, f) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                try {
                  var match = Curry._2(f, env, sigma);
                  return Tactics$ReactTemplate.apply_clear_request(clear_flag, Tactics$ReactTemplate.use_clear_hyp_by_default(/* () */0), match[1][0]);
                }
                catch (raw_e){
                  var e = Js_exn.internalToOCamlException(raw_e);
                  if (Logic$ReactTemplate.catchable_exception(e)) {
                    return Tacticals$ReactTemplate.New[/* tclIDTAC */1];
                  } else {
                    throw e;
                  }
                }
              }));
}

function general_multi_rewrite(with_evars, l, cl, tac) {
  var do1 = function (l2r, f) {
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                  var match = Curry._2(f, env, sigma);
                  return Tacticals$ReactTemplate.New[/* tclWITHHOLES */35](with_evars, general_rewrite_clause(l2r, with_evars, tac, match[1], cl), match[0]);
                }));
  };
  var doN = function (l2r, c, param) {
    if (typeof param === "number") {
      if (param) {
        return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](do1(l2r, c), doN(l2r, c, /* RepeatStar */0));
      } else {
        return Tacticals$ReactTemplate.New[/* tclREPEAT_MAIN */30](do1(l2r, c));
      }
    } else if (param.tag) {
      var n = param[0];
      if (n <= 0) {
        return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
      } else {
        return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](Tacticals$ReactTemplate.New[/* tclTRY */21](do1(l2r, c)), doN(l2r, c, /* UpTo */Block.__(1, [n - 1 | 0])));
      }
    } else {
      var n$1 = param[0];
      if (n$1 <= 0) {
        return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
      } else if (n$1 !== 1) {
        return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](do1(l2r, c), doN(l2r, c, /* Precisely */Block.__(0, [n$1 - 1 | 0])));
      } else {
        return do1(l2r, c);
      }
    }
  };
  var loop = function (param) {
    if (param) {
      var match = param[0];
      var c = match[3];
      return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](Tacticals$ReactTemplate.New[/* tclTHEN */2](doN(match[0], c, match[1]), apply_special_clear_request(match[2], c)), loop(param[1]));
    } else {
      return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
    }
  };
  return loop(l);
}

function rewriteLR(param, param$1) {
  return general_rewrite(/* true */1, /* AllOccurrences */0, /* true */1, /* true */1, param, param$1);
}

function rewriteRL(param, param$1) {
  return general_rewrite(/* false */0, /* AllOccurrences */0, /* true */1, /* true */1, param, param$1);
}

var classes_dirpath = Names$ReactTemplate.DirPath[/* make */3](Curry._2(Util$ReactTemplate.List[/* map */10], Names$ReactTemplate.Id[/* of_string */5], /* :: */[
          "Classes",
          /* :: */[
            "Coq",
            /* [] */0
          ]
        ]));

function init_setoid() {
  if (Libnames$ReactTemplate.is_dirpath_prefix_of(classes_dirpath, Lib$ReactTemplate.cwd(/* () */0))) {
    return /* () */0;
  } else {
    return Coqlib$ReactTemplate.check_required_library(/* :: */[
                "Coq",
                /* :: */[
                  "Setoids",
                  /* :: */[
                    "Setoid",
                    /* [] */0
                  ]
                ]
              ]);
  }
}

function check_setoid(cl) {
  return Option$ReactTemplate.fold_left(Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (b, param) {
                    if (b) {
                      return /* true */1;
                    } else {
                      return +(Locusops$ReactTemplate.occurrences_map((function (x) {
                                      return x;
                                    }), param[0][0]) !== /* AllOccurrences */0);
                    }
                  })), +(Locusops$ReactTemplate.occurrences_map((function (x) {
                      return x;
                    }), cl[/* concl_occs */1]) !== /* AllOccurrences */0 && Locusops$ReactTemplate.occurrences_map((function (x) {
                      return x;
                    }), cl[/* concl_occs */1]) !== /* NoOccurrences */1), cl[/* onhyps */0]);
}

function replace_core(clause, l2r, eq) {
  if (check_setoid(clause)) {
    init_setoid(/* () */0);
  }
  return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](Tactics$ReactTemplate.assert_as(/* false */0, /* None */0, /* None */0, eq), Tacticals$ReactTemplate.New[/* onLastHypId */42]((function (id) {
                    return Tacticals$ReactTemplate.New[/* tclTHEN */2](Tacticals$ReactTemplate.New[/* tclTRY */21](general_rewrite_clause(l2r, /* false */0, /* None */0, /* tuple */[
                                        EConstr$ReactTemplate.mkVar(id),
                                        /* NoBindings */0
                                      ], clause)), Tactics$ReactTemplate.clear(/* :: */[
                                    id,
                                    /* [] */0
                                  ]));
                  })));
}

function replace_using_leibniz(clause, c1, c2, l2r, unsafe, try_prove_eq_opt) {
  var try_prove_eq = try_prove_eq_opt ? Tacticals$ReactTemplate.New[/* tclCOMPLETE */31](try_prove_eq_opt[0]) : Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var get_type_of = Tacmach$ReactTemplate.New[/* pf_apply */0]((function (eta) {
                        return (function (param, param$1) {
                            return Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, eta, param, param$1);
                          });
                      }), gl);
                var t1 = Curry._1(get_type_of, c1);
                var t2 = Curry._1(get_type_of, c2);
                var evd;
                if (unsafe) {
                  evd = /* Some */[Tacmach$ReactTemplate.New[/* project */3](gl)];
                } else {
                  try {
                    evd = /* Some */[Evarconv$ReactTemplate.the_conv_x(Proofview$ReactTemplate.Goal[/* env */4](gl), /* None */0, t1, t2, Tacmach$ReactTemplate.New[/* project */3](gl))];
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Evarconv$ReactTemplate.UnableToUnify) {
                      evd = /* None */0;
                    } else {
                      throw exn;
                    }
                  }
                }
                if (evd) {
                  var e = Coqlib$ReactTemplate.build_coq_eq(/* () */0);
                  var sym = Coqlib$ReactTemplate.build_coq_eq_sym(/* () */0);
                  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](sym), (function (sym) {
                                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](e), (function (e) {
                                              var eq = EConstr$ReactTemplate.applist(/* tuple */[
                                                    e,
                                                    /* :: */[
                                                      t1,
                                                      /* :: */[
                                                        c1,
                                                        /* :: */[
                                                          c2,
                                                          /* [] */0
                                                        ]
                                                      ]
                                                    ]
                                                  ]);
                                              return Tacticals$ReactTemplate.New[/* tclTHENLAST */17](replace_core(clause, l2r, eq), Tacticals$ReactTemplate.New[/* tclFIRST */23](/* :: */[
                                                              Tactics$ReactTemplate.assumption,
                                                              /* :: */[
                                                                Tacticals$ReactTemplate.New[/* tclTHEN */2](Tactics$ReactTemplate.apply(sym), Tactics$ReactTemplate.assumption),
                                                                /* :: */[
                                                                  try_prove_eq,
                                                                  /* [] */0
                                                                ]
                                                              ]
                                                            ]));
                                            }));
                              }));
                } else {
                  return Tacticals$ReactTemplate.New[/* tclFAIL */3](0, Pp$ReactTemplate.str("Terms do not have convertible types"));
                }
              }));
}

function replace(c1, c2) {
  return replace_using_leibniz(Locusops$ReactTemplate.onConcl, c2, c1, /* false */0, /* false */0, /* None */0);
}

function replace_by(c1, c2, tac) {
  return replace_using_leibniz(Locusops$ReactTemplate.onConcl, c2, c1, /* false */0, /* false */0, /* Some */[tac]);
}

function replace_in_clause_maybe_by(c1, c2, cl, tac_opt) {
  return replace_using_leibniz(cl, c2, c1, /* false */0, /* false */0, tac_opt);
}

var DiscrFound = Caml_exceptions.create("Equality-ReactTemplate.DiscrFound");

var keep_proof_equalities_for_injection = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"injection on prop arguments",
      /* optkey : :: */[
        "Keep",
        /* :: */[
          "Proof",
          /* :: */[
            "Equalities",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return keep_proof_equalities_for_injection[0];
        }),
      /* optwrite */(function (b) {
          keep_proof_equalities_for_injection[0] = b;
          return /* () */0;
        })
    ]);

function keep_proof_equalities(param) {
  if (param) {
    return param[0][/* keep_proof_equalities */0];
  } else {
    return keep_proof_equalities_for_injection[0];
  }
}

function find_positions(env, sigma, keep_proofs, no_discr, t1, t2) {
  var project = function (env, sorts, posn, t1, t2) {
    var ty1 = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, t1);
    var s = Retyping$ReactTemplate.get_sort_family_of(/* Some */[/* true */1], /* None */0, env, sigma, ty1);
    if (Curry._2(Sorts$ReactTemplate.List[/* mem */0], s, sorts)) {
      return /* :: */[
              /* tuple */[
                Curry._1(Util$ReactTemplate.List[/* rev */4], posn),
                t1,
                t2
              ],
              /* [] */0
            ];
    } else {
      return /* [] */0;
    }
  };
  var findrec = function (sorts, posn, t1, t2) {
    var match = Reductionops$ReactTemplate.whd_all_stack(env)(sigma, t1);
    var args1 = match[1];
    var hd1 = match[0];
    var match$1 = Reductionops$ReactTemplate.whd_all_stack(env)(sigma, t2);
    var args2 = match$1[1];
    var hd2 = match$1[0];
    var match$2 = EConstr$ReactTemplate.kind(sigma, hd1);
    var match$3 = EConstr$ReactTemplate.kind(sigma, hd2);
    var exit = 0;
    if (match$2.tag === 12) {
      if (match$3.tag === 12) {
        var sp2 = match$3[0][0];
        var match$4 = match$2[0];
        var sp1 = match$4[0];
        var ind1 = sp1[0];
        if (Curry._1(Util$ReactTemplate.List[/* length */0], args1) === Inductiveops$ReactTemplate.constructor_nallargs_env(env, sp1)) {
          var sorts$prime = Sorts$ReactTemplate.List[/* intersect */1](sorts, Inductiveops$ReactTemplate.allowed_sorts(env, sp1[0]));
          if (Names$ReactTemplate.eq_constructor(sp1, sp2)) {
            var nparams = Inductiveops$ReactTemplate.inductive_nparams_env(env, ind1);
            var match$5 = Curry._2(Util$ReactTemplate.List[/* chop */99], nparams, args1);
            var match$6 = Curry._2(Util$ReactTemplate.List[/* chop */99], nparams, args2);
            var match$7 = Inductive$ReactTemplate.lookup_mind_specif(env, ind1);
            var params1 = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.Unsafe[/* to_constr */0], match$5[0]);
            var u1 = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$4[1]);
            var ctxt = Inductiveops$ReactTemplate.get_constructor(/* tuple */[
                    /* tuple */[
                      ind1,
                      u1
                    ],
                    match$7[0],
                    match$7[1],
                    params1
                  ], sp1[1])[/* cs_args */3];
            var adjust = function (i) {
              return Vars$ReactTemplate.adjust_rel_to_rel_context(ctxt, i + 1 | 0) - 1 | 0;
            };
            return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._4(Util$ReactTemplate.List[/* map2_i */68], (function (i) {
                              var partial_arg_000 = /* tuple */[
                                sp1,
                                adjust(i)
                              ];
                              var partial_arg = /* :: */[
                                partial_arg_000,
                                posn
                              ];
                              return (function (param, param$1) {
                                  return findrec(sorts$prime, partial_arg, param, param$1);
                                });
                            }), 0, match$5[1], match$6[1]));
          } else if (Curry._2(Sorts$ReactTemplate.List[/* mem */0], /* InType */2, sorts$prime) && !no_discr) {
            throw [
                  DiscrFound,
                  Curry._1(Util$ReactTemplate.List[/* rev */4], posn),
                  sp1,
                  sp2
                ];
          } else {
            return project(env, sorts, posn, EConstr$ReactTemplate.applist(/* tuple */[
                            hd1,
                            args1
                          ]), EConstr$ReactTemplate.applist(/* tuple */[
                            hd2,
                            args2
                          ]));
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var t1_0 = EConstr$ReactTemplate.applist(/* tuple */[
            hd1,
            args1
          ]);
      var t2_0 = EConstr$ReactTemplate.applist(/* tuple */[
            hd2,
            args2
          ]);
      if (Reductionops$ReactTemplate.is_conv(/* None */0, env, sigma)(t1_0, t2_0)) {
        return /* [] */0;
      } else {
        return project(env, sorts, posn, t1_0, t2_0);
      }
    }
    
  };
  try {
    var sorts = keep_proofs ? /* :: */[
        /* InSet */1,
        /* :: */[
          /* InType */2,
          /* :: */[
            /* InProp */0,
            /* [] */0
          ]
        ]
      ] : /* :: */[
        /* InSet */1,
        /* :: */[
          /* InType */2,
          /* [] */0
        ]
      ];
    return /* Inr */Block.__(1, [findrec(sorts, /* [] */0, t1, t2)]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === DiscrFound) {
      return /* Inl */Block.__(0, [/* tuple */[
                  exn[1],
                  exn[2],
                  exn[3]
                ]]);
    } else {
      throw exn;
    }
  }
}

function use_keep_proofs(param) {
  if (param) {
    return param[0];
  } else {
    return keep_proof_equalities_for_injection[0];
  }
}

function discriminable(env, sigma, t1, t2) {
  var match = find_positions(env, sigma, /* false */0, /* false */0, t1, t2);
  if (match.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function injectable(env, sigma, keep_proofs, t1, t2) {
  var match = find_positions(env, sigma, use_keep_proofs(keep_proofs), /* true */1, t1, t2);
  if (match.tag) {
    var match$1 = match[0];
    if (match$1 && (match$1[0][0] || match$1[1])) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "equality.ml",
            783,
            15
          ]
        ];
  }
}

function descend_then(env, sigma, head, dirn) {
  var match;
  try {
    match = Inductiveops$ReactTemplate.find_rectype(env, sigma, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, head));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      match = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot project on an inductive type derived from a dependency."));
    } else {
      throw exn;
    }
  }
  var indf = match[0];
  var match$1 = Inductiveops$ReactTemplate.dest_ind_family(indf);
  var match$2 = Tacred$ReactTemplate.check_privacy(env, match$1[0]);
  var ind = match$2[0];
  var match$3 = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  var mip = match$3[1];
  var cstr = Inductiveops$ReactTemplate.get_constructors(env, indf);
  var dirn_nlams = Caml_array.caml_array_get(cstr, dirn - 1 | 0)[/* cs_nargs */2];
  var dirn_env = Environ$ReactTemplate.push_rel_context(Caml_array.caml_array_get(cstr, dirn - 1 | 0)[/* cs_args */3], env);
  return /* tuple */[
          dirn_nlams,
          dirn_env,
          (function (sigma, dirnval, param) {
              var dfltval = param[0];
              var deparsign = Inductiveops$ReactTemplate.make_arity_signature(env, sigma, /* true */1, indf);
              var p = EConstr$ReactTemplate.it_mkLambda_or_LetIn(EConstr$ReactTemplate.Vars[/* lift */0](mip[/* mind_nrealargs */5] + 1 | 0, param[1]), deparsign);
              var build_branch = function (i) {
                var result = i === dirn ? dirnval : dfltval;
                var cs_args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
                        return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
                      }), Caml_array.caml_array_get(cstr, i - 1 | 0)[/* cs_args */3]);
                var args = Namegen$ReactTemplate.name_context(env, sigma, cs_args);
                return EConstr$ReactTemplate.it_mkLambda_or_LetIn(result, args);
              };
              var brl = Curry._2(Util$ReactTemplate.List[/* map */10], build_branch, Curry._2(Util$ReactTemplate.List[/* interval */55], 1, mip[/* mind_consnames */3].length));
              var ci = Inductiveops$ReactTemplate.make_case_info(env, ind, /* RegularStyle */4);
              return Inductiveops$ReactTemplate.make_case_or_project(env, sigma, indf, ci, p, head, Util$ReactTemplate.$$Array[/* of_list */10](brl));
            })
        ];
}

function build_selector(env, sigma, dirn, c, ind, special, $$default) {
  var match;
  try {
    match = Inductiveops$ReactTemplate.find_rectype(env, sigma, ind);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      match = CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Equality.construct_discriminator"], Pp$ReactTemplate.str("Cannot discriminate on inductive constructors with dependent types."));
    } else {
      throw exn;
    }
  }
  var indf = match[0];
  var match$1 = Inductiveops$ReactTemplate.dest_ind_family(indf);
  var match$2 = Tacred$ReactTemplate.check_privacy(env, match$1[0]);
  var ind$1 = match$2[0];
  var typ = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, $$default);
  var match$3 = Inductive$ReactTemplate.lookup_mind_specif(env, ind$1);
  var deparsign = Inductiveops$ReactTemplate.make_arity_signature(env, sigma, /* true */1, indf);
  var p = EConstr$ReactTemplate.it_mkLambda_or_LetIn(typ, deparsign);
  var cstrs = Inductiveops$ReactTemplate.get_constructors(env, indf);
  var build_branch = function (i) {
    var endpt = i === dirn ? special : $$default;
    var args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
            return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
          }), Caml_array.caml_array_get(cstrs, i - 1 | 0)[/* cs_args */3]);
    return EConstr$ReactTemplate.it_mkLambda_or_LetIn(endpt, args);
  };
  var brl = Curry._2(Util$ReactTemplate.List[/* map */10], build_branch, Curry._2(Util$ReactTemplate.List[/* interval */55], 1, match$3[1][/* mind_consnames */3].length));
  var ci = Inductiveops$ReactTemplate.make_case_info(env, ind$1, /* RegularStyle */4);
  return Inductiveops$ReactTemplate.make_case_or_project(env, sigma, indf, ci, p, c, Util$ReactTemplate.$$Array[/* of_list */10](brl));
}

function build_discriminator(env, sigma, true_0, false_0, dirn, c, param) {
  if (param) {
    var match = param[0];
    var match$1 = descend_then(env, sigma, c, match[0][1]);
    var newc = EConstr$ReactTemplate.mkRel(match$1[0] - match[1] | 0);
    var subval = build_discriminator(match$1[1], sigma, true_0, false_0, dirn, newc, param[1]);
    return Curry._3(match$1[2], sigma, subval, /* tuple */[
                false_0,
                EConstr$ReactTemplate.mkSort(/* Prop */Block.__(0, [/* Null */1]))
              ]);
  } else {
    var ind = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c);
    return build_selector(env, sigma, dirn, c, ind, true_0, false_0);
  }
}

function gen_absurdity(id) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var hyp_typ = Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](id, gl);
                if (Hipattern$ReactTemplate.is_empty_type(sigma, hyp_typ)) {
                  return Tactics$ReactTemplate.simplest_elim(EConstr$ReactTemplate.mkVar(id));
                } else {
                  return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Not the negation of an equality."));
                }
              }));
}

function ind_scheme_of_eq(lbeq) {
  var match = Global$ReactTemplate.lookup_inductive(Globnames$ReactTemplate.destIndRef(lbeq[/* eq */0]));
  var kind = Inductive$ReactTemplate.inductive_sort_family(match[1]);
  var kind$1 = kind ? Elimschemes$ReactTemplate.ind_scheme_kind_from_type : Elimschemes$ReactTemplate.ind_scheme_kind_from_prop;
  var match$1 = Ind_tables$ReactTemplate.find_scheme(/* None */0, kind$1, Globnames$ReactTemplate.destIndRef(lbeq[/* eq */0]));
  return /* tuple */[
          /* ConstRef */Block.__(1, [match$1[0]]),
          match$1[1]
        ];
}

function discrimination_pf(e, param, discriminator, lbeq) {
  var t2 = param[2];
  var t1 = param[1];
  var t = param[0];
  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](Coqlib$ReactTemplate.build_coq_I(/* () */0)), (function (i) {
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](Coqlib$ReactTemplate.build_coq_False(/* () */0)), (function (absurd_term) {
                              var match = ind_scheme_of_eq(lbeq);
                              return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.tclEFFECTS(match[1]), Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](match[0])), (function (eq_elim) {
                                            return Curry._1(Proofview$ReactTemplate.tclUNIT, /* tuple */[
                                                        EConstr$ReactTemplate.applist(/* tuple */[
                                                              eq_elim,
                                                              /* :: */[
                                                                t,
                                                                /* :: */[
                                                                  t1,
                                                                  /* :: */[
                                                                    EConstr$ReactTemplate.mkNamedLambda(e, t, discriminator),
                                                                    /* :: */[
                                                                      i,
                                                                      /* :: */[
                                                                        t2,
                                                                        /* [] */0
                                                                      ]
                                                                    ]
                                                                  ]
                                                                ]
                                                              ]
                                                            ]),
                                                        absurd_term
                                                      ]);
                                          }));
                            }));
              }));
}

var eq_baseid = Names$ReactTemplate.Id[/* of_string */5]("e");

function apply_on_clause(param, clause) {
  var sigma = clause[/* evd */1];
  var f_clause = Clenv$ReactTemplate.mk_clenv_from_env(clause[/* env */0], sigma, /* None */0, /* tuple */[
        param[0],
        param[1]
      ]);
  var match = EConstr$ReactTemplate.kind(sigma, Termops$ReactTemplate.last_arg(f_clause[/* evd */1], f_clause[/* templval */2][/* rebus */0]));
  var argmv;
  argmv = match.tag === 2 ? match[0] : CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Ill-formed clause applicator."));
  return Clenv$ReactTemplate.clenv_fchain(/* Some */[/* false */0], /* None */0, argmv, f_clause, clause);
}

function discr_positions(env, sigma, param, eq_clause, cpath, dirn) {
  var match = param[2];
  var t2 = match[2];
  var t1 = match[1];
  var t = match[0];
  var eqn = param[1];
  var lbeq = param[0];
  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](Coqlib$ReactTemplate.build_coq_True(/* () */0)), (function (true_0) {
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](Coqlib$ReactTemplate.build_coq_False(/* () */0)), (function (false_0) {
                              var e = Namegen$ReactTemplate.next_ident_away(eq_baseid, Termops$ReactTemplate.vars_of_env(env));
                              var e_env = EConstr$ReactTemplate.push_named(/* LocalAssum */Block.__(0, [
                                      e,
                                      t
                                    ]), env);
                              var discriminator;
                              try {
                                discriminator = Curry._1(Proofview$ReactTemplate.tclUNIT, build_discriminator(e_env, sigma, true_0, false_0, dirn, EConstr$ReactTemplate.mkVar(e), cpath));
                              }
                              catch (raw_ex){
                                var ex = Js_exn.internalToOCamlException(raw_ex);
                                if (ex[0] === CErrors$ReactTemplate.UserError) {
                                  discriminator = Proofview$ReactTemplate.tclZERO(/* None */0, ex);
                                } else {
                                  throw ex;
                                }
                              }
                              return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], discriminator, (function (discriminator) {
                                            return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], discrimination_pf(e, /* tuple */[
                                                            t,
                                                            t1,
                                                            t2
                                                          ], discriminator, lbeq), (function (param) {
                                                          var absurd_term = param[1];
                                                          var pf_ty = EConstr$ReactTemplate.mkArrow(eqn, absurd_term);
                                                          var absurd_clause = apply_on_clause(/* tuple */[
                                                                param[0],
                                                                pf_ty
                                                              ], eq_clause);
                                                          var pf = Clenvtac$ReactTemplate.clenv_value_cast_meta(absurd_clause);
                                                          return Tacticals$ReactTemplate.New[/* tclTHENS */18](Tactics$ReactTemplate.assert_after(/* Anonymous */0)(absurd_term), /* :: */[
                                                                      Tacticals$ReactTemplate.New[/* onLastHypId */42](gen_absurdity),
                                                                      /* :: */[
                                                                        Proofview$ReactTemplate.V82[/* tactic */0](/* None */0, Tacmach$ReactTemplate.refine(pf)),
                                                                        /* [] */0
                                                                      ]
                                                                    ]);
                                                        }));
                                          }));
                            }));
              }));
}

function discrEq(u, eq_clause) {
  var match = u[2];
  var t2 = match[2];
  var t1 = match[1];
  var sigma = eq_clause[/* evd */1];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var match = find_positions(env, sigma, /* false */0, /* false */0, t1, t2);
                if (match.tag) {
                  return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Not a discriminable equality."));
                } else {
                  var match$1 = match[0];
                  return discr_positions(env, sigma, u, eq_clause, match$1[0], match$1[1][1]);
                }
              }));
}

function onEquality(with_evars, tac, param) {
  var lbindc = param[1];
  var c = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var partial_arg = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6];
                var type_of = function (param) {
                  return partial_arg(gl, param);
                };
                var reduce_to_quantified_ind = Tacmach$ReactTemplate.New[/* pf_apply */0](Tacred$ReactTemplate.reduce_to_quantified_ind, gl);
                var t = Curry._1(type_of, c);
                var t$prime;
                try {
                  t$prime = Curry._1(reduce_to_quantified_ind, t)[1];
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === CErrors$ReactTemplate.UserError) {
                    t$prime = t;
                  } else {
                    throw exn;
                  }
                }
                var eq_clause = Curry._2(Tacmach$ReactTemplate.New[/* pf_apply */0](Clenv$ReactTemplate.make_clenv_binding, gl), /* tuple */[
                      c,
                      t$prime
                    ], lbindc);
                var eq_clause$prime = Clenvtac$ReactTemplate.clenv_pose_dependent_evars(with_evars, eq_clause);
                var eqn = Clenv$ReactTemplate.clenv_type(eq_clause$prime);
                var match = Hipattern$ReactTemplate.find_this_eq_data_decompose(gl, eqn);
                return Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](eq_clause$prime[/* evd */1]), Curry._2(tac, /* tuple */[
                                match[0],
                                eqn,
                                match[2]
                              ], eq_clause$prime));
              }));
}

function onNegatedEquality(with_evars, tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var ccl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var match = EConstr$ReactTemplate.kind(sigma, Tacred$ReactTemplate.hnf_constr(env, sigma, ccl));
                if (match.tag === 6 && Hipattern$ReactTemplate.is_empty_type(sigma, match[2])) {
                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](Tactics$ReactTemplate.introf, Tacticals$ReactTemplate.New[/* onLastHypId */42]((function (id) {
                                    return onEquality(with_evars, tac, /* tuple */[
                                                EConstr$ReactTemplate.mkVar(id),
                                                /* NoBindings */0
                                              ]);
                                  })));
                } else {
                  return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Not a negated primitive equality."));
                }
              }));
}

function discrSimpleClause(with_evars, param) {
  if (param) {
    return onEquality(with_evars, discrEq, /* tuple */[
                EConstr$ReactTemplate.mkVar(param[0]),
                /* NoBindings */0
              ]);
  } else {
    return onNegatedEquality(with_evars, discrEq);
  }
}

function discr(with_evars) {
  return (function (param) {
      return onEquality(with_evars, discrEq, param);
    });
}

function discrEverywhere(with_evars) {
  return Tacticals$ReactTemplate.New[/* tclTHEN */2](Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0), Tacticals$ReactTemplate.New[/* tclTHEN */2](Tacticals$ReactTemplate.New[/* tclREPEAT */29](Tactics$ReactTemplate.introf), Tacticals$ReactTemplate.New[/* tryAllHyps */47]((function (id) {
                        return Tacticals$ReactTemplate.New[/* tclCOMPLETE */31](discr(with_evars)(/* tuple */[
                                        EConstr$ReactTemplate.mkVar(id),
                                        /* NoBindings */0
                                      ]));
                      }))));
}

function discr_tac(with_evars, param) {
  if (param) {
    return Tactics$ReactTemplate.onInductionArg((function () {
                  return discr(with_evars);
                }), param[0]);
  } else {
    return discrEverywhere(with_evars);
  }
}

var partial_arg = Tacticals$ReactTemplate.New[/* onClause */49];

var discrConcl = (function (param) {
      return partial_arg((function (param) {
                    return discrSimpleClause(/* false */0, param);
                  }), param);
    })(Locusops$ReactTemplate.onConcl);

function discrHyp(id) {
  var partial_arg = Tacticals$ReactTemplate.New[/* onClause */49];
  return (function (param) {
              return partial_arg((function (param) {
                            return discrSimpleClause(/* false */0, param);
                          }), param);
            })(Locusops$ReactTemplate.onHyp(id));
}

function minimal_free_rels(env, sigma, param) {
  var cty = param[1];
  var cty_rels = Termops$ReactTemplate.free_rels(sigma, cty);
  var cty$prime = Tacred$ReactTemplate.simpl(env, sigma, cty);
  var rels$prime = Termops$ReactTemplate.free_rels(sigma, cty$prime);
  if (Curry._2(Int$ReactTemplate.$$Set[/* subset */11], cty_rels, rels$prime)) {
    return /* tuple */[
            cty,
            cty_rels
          ];
  } else {
    return /* tuple */[
            cty$prime,
            rels$prime
          ];
  }
}

function minimal_free_rels_rec(env, sigma) {
  var minimalrec_free_rels_rec = function (prev_rels, param) {
    var c = param[0];
    var match = minimal_free_rels(env, sigma, /* tuple */[
          c,
          param[1]
        ]);
    var direct_rels = match[1];
    var combined_rels = Curry._2(Int$ReactTemplate.$$Set[/* union */6], prev_rels, direct_rels);
    var folder = function (rels, i) {
      return minimalrec_free_rels_rec(rels, /* tuple */[
                    c,
                    Typing$ReactTemplate.unsafe_type_of(env, sigma, EConstr$ReactTemplate.mkRel(i))
                  ])[1];
    };
    return /* tuple */[
            match[0],
            Curry._3(Util$ReactTemplate.List[/* fold_left */13], folder, combined_rels, Curry._1(Int$ReactTemplate.$$Set[/* elements */19], Curry._2(Int$ReactTemplate.$$Set[/* diff */8], direct_rels, prev_rels)))
          ];
  };
  var partial_arg = Int$ReactTemplate.$$Set[/* empty */0];
  return (function (param) {
      return minimalrec_free_rels_rec(partial_arg, param);
    });
}

function sig_clausal_form(env, sigma, _, siglen, ty, dflt) {
  var sigdata = Coqlib$ReactTemplate.build_sigma_type(/* () */0);
  var evdref = [Evd$ReactTemplate.clear_metas(sigma)];
  var sigrec_clausal_form = function (siglen, p_i) {
    if (siglen) {
      var match = Reductionops$ReactTemplate.whd_beta_stack(evdref[0], p_i);
      var match$1 = match[1];
      var match$2;
      var exit = 0;
      if (match$1) {
        var match$3 = match$1[1];
        if (match$3 && !match$3[1]) {
          match$2 = /* tuple */[
            match$1[0],
            match$3[0]
          ];
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        match$2 = CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["sig_clausal_form"], Pp$ReactTemplate.str("should be a sigma type."));
      }
      var p_i_minus_1 = match$2[1];
      var a = match$2[0];
      var ev = Evarutil$ReactTemplate.e_new_evar(env, evdref, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, a);
      var rty = Reductionops$ReactTemplate.beta_applist(sigma, /* tuple */[
            p_i_minus_1,
            /* :: */[
              ev,
              /* [] */0
            ]
          ]);
      var tuple_tail = sigrec_clausal_form(siglen - 1 | 0, rty);
      var match$4 = EConstr$ReactTemplate.kind(evdref[0], ev);
      var evopt;
      evopt = match$4.tag === 3 ? /* None */0 : /* Some */[ev];
      if (evopt) {
        var w = evopt[0];
        var w_type = Typing$ReactTemplate.unsafe_type_of(env, evdref[0], w);
        if (Evarconv$ReactTemplate.e_cumul(env, /* None */0, evdref, w_type, a)) {
          var exist_term = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                  return Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env, param, param$1);
                }), evdref, sigdata[/* intro */3]);
          var exist_term$1 = EConstr$ReactTemplate.of_constr(exist_term);
          return EConstr$ReactTemplate.applist(/* tuple */[
                      exist_term$1,
                      /* :: */[
                        a,
                        /* :: */[
                          p_i_minus_1,
                          /* :: */[
                            w,
                            /* :: */[
                              tuple_tail,
                              /* [] */0
                            ]
                          ]
                        ]
                      ]
                    ]);
        } else {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot solve a unification problem."));
        }
      } else {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot solve a unification problem."));
      }
    } else {
      var dflt_typ = Typing$ReactTemplate.unsafe_type_of(env, sigma, dflt);
      try {
        evdref[0] = Evarconv$ReactTemplate.the_conv_x_leq(env, /* None */0, dflt_typ, p_i, evdref[0]);
        evdref[0] = Evarconv$ReactTemplate.solve_unif_constraints_with_heuristics(env, /* None */0, evdref[0]);
        return dflt;
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Evarconv$ReactTemplate.UnableToUnify) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot solve a unification problem."));
        } else {
          throw exn;
        }
      }
    }
  };
  var scf = sigrec_clausal_form(siglen, ty);
  return /* tuple */[
          evdref[0],
          Evarutil$ReactTemplate.nf_evar(evdref[0], scf)
        ];
}

function make_iterated_tuple(env, sigma, dflt, param) {
  var z = param[0];
  var match = minimal_free_rels_rec(env, sigma)(/* tuple */[
        z,
        param[1]
      ]);
  var zty = match[0];
  var sort_of_zty = Retyping$ReactTemplate.get_sort_of(/* None */0, env, sigma, zty);
  var sorted_rels = Curry._1(Int$ReactTemplate.$$Set[/* elements */19], match[1]);
  var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param) {
          var t = param[1];
          var sigma = param[0];
          return (function (param) {
              var env$1 = env;
              var sigma$1 = sigma;
              var param$1 = t;
              var lind = param;
              var rty = param$1[1];
              if (EConstr$ReactTemplate.Vars[/* noccurn */12](sigma$1, lind, rty)) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "equality.ml",
                        1101,
                        2
                      ]
                    ];
              }
              Retyping$ReactTemplate.get_sort_of(/* None */0, env$1, sigma$1, rty);
              var sigdata = Coqlib$ReactTemplate.build_sigma_type(/* () */0);
              var match = Typing$ReactTemplate.type_of(/* Some */[/* true */1], env$1, sigma$1, EConstr$ReactTemplate.mkRel(lind));
              var a = match[1];
              var na = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], EConstr$ReactTemplate.lookup_rel(lind, env$1));
              var rty$1 = EConstr$ReactTemplate.Vars[/* lift */0](1 - lind | 0, EConstr$ReactTemplate.Vars[/* liftn */1](lind, lind + 1 | 0, rty));
              var p = EConstr$ReactTemplate.mkLambda(/* tuple */[
                    na,
                    a,
                    rty$1
                  ]);
              var match$1 = Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env$1, match[0], sigdata[/* intro */3]);
              var match$2 = Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env$1, match$1[0], sigdata[/* typ */4]);
              var exist_term = EConstr$ReactTemplate.of_constr(match$1[1]);
              var sig_term = EConstr$ReactTemplate.of_constr(match$2[1]);
              return /* tuple */[
                      match$2[0],
                      /* tuple */[
                        EConstr$ReactTemplate.applist(/* tuple */[
                              exist_term,
                              /* :: */[
                                a,
                                /* :: */[
                                  p,
                                  /* :: */[
                                    EConstr$ReactTemplate.mkRel(lind),
                                    /* :: */[
                                      param$1[0],
                                      /* [] */0
                                    ]
                                  ]
                                ]
                              ]
                            ]),
                        EConstr$ReactTemplate.applist(/* tuple */[
                              sig_term,
                              /* :: */[
                                a,
                                /* :: */[
                                  p,
                                  /* [] */0
                                ]
                              ]
                            ])
                      ]
                    ];
            });
        }), /* tuple */[
        sigma,
        /* tuple */[
          z,
          zty
        ]
      ], sorted_rels);
  var match$2 = match$1[1];
  var tuplety = match$2[1];
  var sigma$1 = match$1[0];
  if (!EConstr$ReactTemplate.Vars[/* closed0 */15](sigma$1, tuplety)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "equality.ml",
            1287,
            2
          ]
        ];
  }
  var n = Curry._1(Util$ReactTemplate.List[/* length */0], sorted_rels);
  var match$3 = sig_clausal_form(env, sigma$1, sort_of_zty, n, tuplety, dflt);
  return /* tuple */[
          match$3[0],
          /* tuple */[
            match$2[0],
            tuplety,
            match$3[1]
          ]
        ];
}

function build_injrec(env, sigma, dflt, c, param) {
  if (param) {
    var match = param[0];
    try {
      var match$1 = descend_then(env, sigma, c, match[0][1]);
      var newc = EConstr$ReactTemplate.mkRel(match$1[0] - match[1] | 0);
      var match$2 = build_injrec(match$1[1], sigma, dflt, newc, param[1]);
      var match$3 = match$2[1];
      var dfltval = match$3[2];
      var tuplety = match$3[1];
      var sigma$1 = match$2[0];
      var res = Curry._3(match$1[2], sigma$1, match$3[0], /* tuple */[
            dfltval,
            tuplety
          ]);
      return /* tuple */[
              sigma$1,
              /* tuple */[
                res,
                tuplety,
                dfltval
              ]
            ];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === CErrors$ReactTemplate.UserError) {
        return Pervasives.failwith("caught");
      } else {
        throw exn;
      }
    }
  } else {
    return make_iterated_tuple(env, sigma, dflt, /* tuple */[
                c,
                Typing$ReactTemplate.unsafe_type_of(env, sigma, c)
              ]);
  }
}

function build_injector(env, sigma, dflt, c, cpath) {
  var match = build_injrec(env, sigma, dflt, c, cpath);
  var match$1 = match[1];
  return /* tuple */[
          match[0],
          /* tuple */[
            match$1[0],
            match$1[1]
          ]
        ];
}

var eq_dec_scheme_kind_name = [(function () {
      return Pervasives.failwith("eq_dec_scheme undefined");
    })];

function set_eq_dec_scheme_kind(k) {
  eq_dec_scheme_kind_name[0] = (function () {
      return k;
    });
  return /* () */0;
}

function inject_if_homogenous_dependent_pair(ty) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                try {
                  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                  var match = Hipattern$ReactTemplate.find_this_eq_data_decompose(gl, ty);
                  var match$1 = match[2];
                  var eqTypeDest = EConstr$ReactTemplate.decompose_app(sigma, match$1[0])[0];
                  if (!Termops$ReactTemplate.is_global(sigma, Coqlib$ReactTemplate.build_sigma_type(/* () */0)[/* typ */4], eqTypeDest)) {
                    throw Pervasives.Exit;
                  }
                  var match$2 = Termops$ReactTemplate.decompose_app_vect(sigma, match$1[1]);
                  var ar1 = match$2[1];
                  var match$3 = Termops$ReactTemplate.decompose_app_vect(sigma, match$1[2]);
                  var ar2 = match$3[1];
                  if (!Termops$ReactTemplate.is_global(sigma, Coqlib$ReactTemplate.build_sigma_type(/* () */0)[/* intro */3], match$2[0])) {
                    throw Pervasives.Exit;
                  }
                  if (!Termops$ReactTemplate.is_global(sigma, Coqlib$ReactTemplate.build_sigma_type(/* () */0)[/* intro */3], match$3[0])) {
                    throw Pervasives.Exit;
                  }
                  var match$4;
                  try {
                    match$4 = Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0](Inductiveops$ReactTemplate.find_mrectype, gl), Caml_array.caml_array_get(ar1, 0));
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      throw Pervasives.Exit;
                    } else {
                      throw exn;
                    }
                  }
                  var ind = match$4[0][0];
                  if (!(Ind_tables$ReactTemplate.check_scheme(Curry._1(eq_dec_scheme_kind_name[0], /* () */0), ind) && Curry._2(Tacmach$ReactTemplate.New[/* pf_apply */0]((function (eta) {
                                  return (function (param) {
                                      return Reductionops$ReactTemplate.is_conv(/* None */0, eta, param);
                                    });
                                }), gl), Caml_array.caml_array_get(ar1, 2), Caml_array.caml_array_get(ar2, 2)))) {
                    throw Pervasives.Exit;
                  }
                  Coqlib$ReactTemplate.check_required_library(/* :: */[
                        "Coq",
                        /* :: */[
                          "Logic",
                          /* :: */[
                            "Eqdep_dec",
                            /* [] */0
                          ]
                        ]
                      ]);
                  var new_eq_args = /* array */[
                    Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, Caml_array.caml_array_get(ar1, 3)),
                    Caml_array.caml_array_get(ar1, 3),
                    Caml_array.caml_array_get(ar2, 3)
                  ];
                  var inj2 = Coqlib$ReactTemplate.coq_reference("inj_pair2_eq_dec is missing", /* :: */[
                        "Logic",
                        /* :: */[
                          "Eqdep_dec",
                          /* [] */0
                        ]
                      ], "inj_pair2_eq_dec");
                  var match$5 = Ind_tables$ReactTemplate.find_scheme(/* None */0, Curry._1(eq_dec_scheme_kind_name[0], /* () */0), ind);
                  var c = match$5[0];
                  return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                              Proofview$ReactTemplate.tclEFFECTS(match$5[1]),
                              /* :: */[
                                Tactics$ReactTemplate.intro,
                                /* :: */[
                                  Tacticals$ReactTemplate.New[/* onLastHyp */43]((function (hyp) {
                                          return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](Coqlib$ReactTemplate.glob_eq), (function (ceq) {
                                                        return Tacticals$ReactTemplate.New[/* tclTHENS */18](Tactics$ReactTemplate.cut(EConstr$ReactTemplate.mkApp(/* tuple */[
                                                                            ceq,
                                                                            new_eq_args
                                                                          ])), /* :: */[
                                                                    Tactics$ReactTemplate.clear(/* :: */[
                                                                          EConstr$ReactTemplate.destVar(sigma, hyp),
                                                                          /* [] */0
                                                                        ]),
                                                                    /* :: */[
                                                                      Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](inj2), (function (inj2) {
                                                                              return Proofview$ReactTemplate.V82[/* tactic */0](/* None */0, Tacmach$ReactTemplate.refine(EConstr$ReactTemplate.mkApp(/* tuple */[
                                                                                                  inj2,
                                                                                                  /* array */[
                                                                                                    Caml_array.caml_array_get(ar1, 0),
                                                                                                    EConstr$ReactTemplate.mkConst(c),
                                                                                                    Caml_array.caml_array_get(ar1, 1),
                                                                                                    Caml_array.caml_array_get(ar1, 2),
                                                                                                    Caml_array.caml_array_get(ar1, 3),
                                                                                                    Caml_array.caml_array_get(ar2, 3),
                                                                                                    hyp
                                                                                                  ]
                                                                                                ])));
                                                                            })),
                                                                      /* [] */0
                                                                    ]
                                                                  ]);
                                                      }));
                                        })),
                                  /* [] */0
                                ]
                              ]
                            ]);
                }
                catch (exn$1){
                  if (exn$1 === Pervasives.Exit) {
                    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                  } else {
                    throw exn$1;
                  }
                }
              }));
}

function simplify_args(env, sigma, t) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  var match$1 = match[1];
  var eq = match[0];
  if (match$1) {
    var match$2 = match$1[1];
    if (match$2) {
      var match$3 = match$2[1];
      if (match$3) {
        var match$4 = match$3[1];
        var c2 = match$3[0];
        var c1 = match$2[0];
        var t$1 = match$1[0];
        if (match$4) {
          if (match$4[1]) {
            return t;
          } else {
            return EConstr$ReactTemplate.applist(/* tuple */[
                        eq,
                        /* :: */[
                          t$1,
                          /* :: */[
                            Tacred$ReactTemplate.simpl(env, sigma, c1),
                            /* :: */[
                              c2,
                              /* :: */[
                                Tacred$ReactTemplate.simpl(env, sigma, match$4[0]),
                                /* [] */0
                              ]
                            ]
                          ]
                        ]
                      ]);
          }
        } else {
          return EConstr$ReactTemplate.applist(/* tuple */[
                      eq,
                      /* :: */[
                        t$1,
                        /* :: */[
                          Tacred$ReactTemplate.simpl(env, sigma, c1),
                          /* :: */[
                            Tacred$ReactTemplate.simpl(env, sigma, c2),
                            /* [] */0
                          ]
                        ]
                      ]
                    ]);
        }
      } else {
        return t;
      }
    } else {
      return t;
    }
  } else {
    return t;
  }
}

function inject_at_positions(env, sigma, l2r, param, eq_clause, posns, tac) {
  var match = param[2];
  var t2 = match[2];
  var t1 = match[1];
  var t = match[0];
  var eq = param[0];
  var e = Namegen$ReactTemplate.next_ident_away(eq_baseid, Termops$ReactTemplate.vars_of_env(env));
  var e_env = EConstr$ReactTemplate.push_named(/* LocalAssum */Block.__(0, [
          e,
          t
        ]), env);
  var evdref = [sigma];
  var filter = function (param) {
    try {
      var match = build_injector(e_env, evdref[0], param[1], EConstr$ReactTemplate.mkVar(e), param[0]);
      var match$1 = match[1];
      var injfun = EConstr$ReactTemplate.mkNamedLambda(e, t, match$1[0]);
      var match$2 = Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env, match[0], eq[/* congr */5]);
      var congr = EConstr$ReactTemplate.of_constr(match$2[1]);
      var pf = EConstr$ReactTemplate.applist(/* tuple */[
            congr,
            /* :: */[
              t,
              /* :: */[
                match$1[1],
                /* :: */[
                  injfun,
                  /* :: */[
                    t1,
                    /* :: */[
                      t2,
                      /* [] */0
                    ]
                  ]
                ]
              ]
            ]
          ]);
      var match$3 = Typing$ReactTemplate.type_of(/* None */0, env, match$2[0], pf);
      var sigma = match$3[0];
      var inj_clause = apply_on_clause(/* tuple */[
            pf,
            match$3[1]
          ], eq_clause);
      var pf$1 = Clenvtac$ReactTemplate.clenv_value_cast_meta(inj_clause);
      var ty = simplify_args(env, sigma, Clenv$ReactTemplate.clenv_type(inj_clause));
      evdref[0] = sigma;
      return /* Some */[/* tuple */[
                pf$1,
                ty
              ]];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
  };
  var injectors = Curry._2(Util$ReactTemplate.List[/* map_filter */62], filter, posns);
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], injectors)) {
    return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Failed to decompose the equality."));
  } else {
    return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](evdref[0]), Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](Curry._1(Proofview$ReactTemplate.tclIGNORE, Curry._2(Proofview$ReactTemplate.Monad[/* List */4][/* map */0], (function (param) {
                              var ty = param[1];
                              return Tacticals$ReactTemplate.New[/* tclTHENS */18](Tactics$ReactTemplate.cut(ty), /* :: */[
                                          inject_if_homogenous_dependent_pair(ty),
                                          /* :: */[
                                            Proofview$ReactTemplate.V82[/* tactic */0](/* None */0, Tacmach$ReactTemplate.refine(param[0])),
                                            /* [] */0
                                          ]
                                        ]);
                            }), l2r ? Curry._1(Util$ReactTemplate.List[/* rev */4], injectors) : injectors)), Curry._1(tac, Curry._1(Util$ReactTemplate.List[/* length */0], injectors))));
  }
}

function get_previous_hyp_position(id, gl) {
  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
  var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
  var _dest = /* MoveLast */1;
  var _param = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
  while(true) {
    var param = _param;
    var dest = _dest;
    if (param) {
      var hyp = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], param[0]);
      if (Names$ReactTemplate.Id[/* equal */0](hyp, id)) {
        return dest;
      } else {
        _param = param[1];
        _dest = /* MoveAfter */Block.__(0, [hyp]);
        continue ;
        
      }
    } else {
      throw [
            Logic$ReactTemplate.RefinerError,
            env,
            sigma,
            /* NoSuchHyp */Block.__(7, [id])
          ];
    }
  };
}

function injEq(flags, $staropt$star, with_evars, clear_flag, ipats) {
  var old = $staropt$star ? $staropt$star[0] : /* false */0;
  var match;
  if (ipats) {
    var b = use_injection_pattern_l2r_order(flags);
    match = /* tuple */[
      ipats,
      b,
      b,
      b
    ];
  } else {
    match = !old && use_injection_in_context(flags) ? /* tuple */[
        /* Some */[/* [] */0],
        /* true */1,
        /* true */1,
        /* true */1
      ] : /* tuple */[
        /* None */0,
        /* false */0,
        /* false */0,
        /* false */0
      ];
  }
  var bounded_intro = match[3];
  var dft_clear_flag = match[2];
  var l2r = match[1];
  var ipats_style = match[0];
  var post_tac = function (c, n) {
    if (ipats_style) {
      var ipats = ipats_style[0];
      return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                    var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                    var match = EConstr$ReactTemplate.kind(sigma, c);
                    var destopt;
                    destopt = match.tag === 1 ? get_previous_hyp_position(match[0], gl) : /* MoveLast */1;
                    var clear_tac = Tacticals$ReactTemplate.New[/* tclTRY */21](Tactics$ReactTemplate.apply_clear_request(clear_flag, dft_clear_flag, c));
                    var intro_tac = bounded_intro ? Tactics$ReactTemplate.intro_patterns_bound_to(with_evars, n, destopt)(ipats) : Tactics$ReactTemplate.intro_patterns_to(with_evars, destopt)(ipats);
                    return Tacticals$ReactTemplate.New[/* tclTHEN */2](clear_tac, intro_tac);
                  }));
    } else {
      return Tacticals$ReactTemplate.New[/* tclIDTAC */1];
    }
  };
  var partial_arg = keep_proof_equalities(flags);
  return (function (param, param$1) {
      var keep_proofs = partial_arg;
      var tac = post_tac;
      var l2r$1 = l2r;
      var u = param;
      var eq_clause = param$1;
      var match = u[2];
      var sigma = eq_clause[/* evd */1];
      var env = eq_clause[/* env */0];
      var match$1 = find_positions(env, sigma, keep_proofs, /* true */1, match[1], match[2]);
      if (match$1.tag) {
        var posns = match$1[0];
        var exit = 0;
        if (posns) {
          if (posns[0][0]) {
            exit = 1;
          } else if (posns[1]) {
            exit = 1;
          } else {
            return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Nothing to inject."));
          }
        } else {
          var suggestion = keep_proofs ? "" : " You can try to use option Set Keep Proof Equalities.";
          return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.strbrk("No information can be deduced from this equality and the injectivity of constructors. This may be because the terms are convertible, or due to pattern matching restrictions in the sort Prop." + suggestion));
        }
        if (exit === 1) {
          return inject_at_positions(env, sigma, l2r$1, u, eq_clause, posns, Curry._1(tac, Clenv$ReactTemplate.clenv_value(eq_clause)));
        }
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "equality.ml",
                1403,
                5
              ]
            ];
      }
    });
}

function inj(flags, ipats, with_evars, clear_flag) {
  var partial_arg = injEq(flags, /* None */0, with_evars, clear_flag, ipats);
  return (function (param) {
      return onEquality(with_evars, partial_arg, param);
    });
}

function injClause(flags, ipats, with_evars, param) {
  if (param) {
    return Tactics$ReactTemplate.onInductionArg((function (param) {
                  return inj(flags, ipats, with_evars, param);
                }), param[0]);
  } else {
    return onNegatedEquality(with_evars, injEq(flags, /* None */0, with_evars, /* None */0, ipats));
  }
}

function simpleInjClause(flags, with_evars, param) {
  if (param) {
    return Tactics$ReactTemplate.onInductionArg((function (clear_flag) {
                  var partial_arg = injEq(flags, /* Some */[/* true */1], with_evars, clear_flag, /* None */0);
                  return (function (param) {
                      return onEquality(with_evars, partial_arg, param);
                    });
                }), param[0]);
  } else {
    return onNegatedEquality(with_evars, injEq(flags, /* Some */[/* true */1], with_evars, /* None */0, /* None */0));
  }
}

function injConcl(flags) {
  return injClause(flags, /* None */0, /* false */0, /* None */0);
}

function injHyp(flags, clear_flag, id) {
  return injClause(flags, /* None */0, /* false */0, /* Some */[/* tuple */[
                clear_flag,
                /* ElimOnIdent */Block.__(1, [CAst$ReactTemplate.make(/* None */0, id)])
              ]]);
}

function decompEqThen(keep_proofs, ntac, u, clause) {
  var match = u[2];
  var t2 = match[2];
  var t1 = match[1];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = clause[/* evd */1];
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var match = find_positions(env, sigma, keep_proofs, /* false */0, t1, t2);
                if (match.tag) {
                  var posns = match[0];
                  if (posns) {
                    return inject_at_positions(env, sigma, /* true */1, u, clause, posns, Curry._1(ntac, Clenv$ReactTemplate.clenv_value(clause)));
                  } else {
                    return Curry._2(ntac, Clenv$ReactTemplate.clenv_value(clause), 0);
                  }
                } else {
                  var match$1 = match[0];
                  return discr_positions(env, sigma, u, clause, match$1[0], match$1[1][1]);
                }
              }));
}

function dEqThen(keep_proofs, with_evars, ntac, param) {
  if (param) {
    return Tactics$ReactTemplate.onInductionArg((function (clear_flag) {
                  var partial_arg = Curry._1(ntac, clear_flag);
                  var partial_arg$1 = use_keep_proofs(keep_proofs);
                  var partial_arg$2 = function (param, param$1) {
                    return decompEqThen(partial_arg$1, partial_arg, param, param$1);
                  };
                  return (function (param) {
                      return onEquality(with_evars, partial_arg$2, param);
                    });
                }), param[0]);
  } else {
    var partial_arg = Curry._1(ntac, /* None */0);
    var partial_arg$1 = use_keep_proofs(keep_proofs);
    return onNegatedEquality(with_evars, (function (param, param$1) {
                  return decompEqThen(partial_arg$1, partial_arg, param, param$1);
                }));
  }
}

function dEq(keep_proofs, with_evars) {
  return (function (param) {
      return dEqThen(keep_proofs, with_evars, (function (clear_flag, c, _) {
                    return Tactics$ReactTemplate.apply_clear_request(clear_flag, Tactics$ReactTemplate.use_clear_hyp_by_default(/* () */0), c);
                  }), param);
    });
}

function intro_decomp_eq(tac, data, param) {
  var t = param[1];
  var c = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var cl = Curry._2(Tacmach$ReactTemplate.New[/* pf_apply */0](Clenv$ReactTemplate.make_clenv_binding, gl), /* tuple */[
                      c,
                      t
                    ], /* NoBindings */0);
                return decompEqThen(keep_proof_equalities_for_injection[0], (function () {
                              return tac;
                            }), data, cl);
              }));
}

Tactics$ReactTemplate.declare_intro_decomp_eq(intro_decomp_eq);

function decomp_tuple_term(env, sigma, c, t) {
  var decomprec = function (inner_code, ex, exty) {
    var iterated_decomp;
    try {
      var match = Hipattern$ReactTemplate.find_sigma_data_decompose(env, sigma)(ex);
      var match$1 = match[1];
      var car = match$1[3];
      var p = match$1[2];
      var a = match$1[1];
      var i = match$1[0];
      var match$2 = match[0];
      var car_code = EConstr$ReactTemplate.applist(/* tuple */[
            EConstr$ReactTemplate.mkConstU(/* tuple */[
                  Globnames$ReactTemplate.destConstRef(match$2[/* proj1 */0]),
                  i
                ]),
            /* :: */[
              a,
              /* :: */[
                p,
                /* :: */[
                  inner_code,
                  /* [] */0
                ]
              ]
            ]
          ]);
      var cdr_code = EConstr$ReactTemplate.applist(/* tuple */[
            EConstr$ReactTemplate.mkConstU(/* tuple */[
                  Globnames$ReactTemplate.destConstRef(match$2[/* proj2 */1]),
                  i
                ]),
            /* :: */[
              a,
              /* :: */[
                p,
                /* :: */[
                  inner_code,
                  /* [] */0
                ]
              ]
            ]
          ]);
      var cdrtyp = Reductionops$ReactTemplate.beta_applist(sigma, /* tuple */[
            p,
            /* :: */[
              car,
              /* [] */0
            ]
          ]);
      iterated_decomp = Curry._2(Util$ReactTemplate.List[/* map */10], (function (l) {
              return /* :: */[
                      /* tuple */[
                        /* tuple */[
                          car,
                          a
                        ],
                        car_code
                      ],
                      l
                    ];
            }), decomprec(cdr_code, match$1[4], cdrtyp));
    }
    catch (exn){
      if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
        iterated_decomp = /* [] */0;
      } else {
        throw exn;
      }
    }
    return /* :: */[
            /* :: */[
              /* tuple */[
                /* tuple */[
                  ex,
                  exty
                ],
                inner_code
              ],
              /* [] */0
            ],
            iterated_decomp
          ];
  };
  return decomprec(EConstr$ReactTemplate.mkRel(1), c, t);
}

function subst_tuple_term(env, sigma, dep_pair1, dep_pair2, b) {
  var typ = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, dep_pair1);
  var decomps1 = decomp_tuple_term(env, sigma, dep_pair1, typ);
  var decomps2 = decomp_tuple_term(env, sigma, dep_pair2, typ);
  var n = Caml_primitive.caml_int_min(Curry._1(Util$ReactTemplate.List[/* length */0], decomps1), Curry._1(Util$ReactTemplate.List[/* length */0], decomps2));
  var decomp1 = Curry._2(Util$ReactTemplate.List[/* nth */3], decomps1, n - 1 | 0);
  var decomp2 = Curry._2(Util$ReactTemplate.List[/* nth */3], decomps2, n - 1 | 0);
  var match = Curry._1(Util$ReactTemplate.List[/* split */36], decomp1);
  var match$1 = Curry._1(Util$ReactTemplate.List[/* split */36], decomp2);
  var abst_B = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, body) {
          return Namegen$ReactTemplate.lambda_create(env, sigma, /* tuple */[
                      param[1],
                      Termops$ReactTemplate.subst_term(sigma, param[0], body)
                    ]);
        }), match[0], b);
  var pred_body = Reductionops$ReactTemplate.beta_applist(sigma, /* tuple */[
        abst_B,
        match[1]
      ]);
  var body = EConstr$ReactTemplate.mkApp(/* tuple */[
        Namegen$ReactTemplate.lambda_create(env, sigma, /* tuple */[
              typ,
              pred_body
            ]),
        /* array */[dep_pair1]
      ]);
  var expected_goal = Reductionops$ReactTemplate.beta_applist(sigma, /* tuple */[
        abst_B,
        Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                return prim[0];
              }), match$1[0])
      ]);
  var expected_goal$1 = Reductionops$ReactTemplate.nf_betaiota(env, sigma, expected_goal);
  var match$2 = Typing$ReactTemplate.type_of(/* None */0, env, sigma, expected_goal$1);
  var match$3 = Typing$ReactTemplate.type_of(/* None */0, env, match$2[0], body);
  return /* tuple */[
          match$3[0],
          /* tuple */[
            body,
            expected_goal$1
          ]
        ];
}

function try_rewrite(tac) {
  return Proofview$ReactTemplate.tclORELSE(tac, (function (param) {
                var e = param[0];
                if (e === Constr_matching$ReactTemplate.PatternMatchingFailure) {
                  return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Not a primitive equality here."));
                } else if (Logic$ReactTemplate.catchable_exception(e)) {
                  return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.strbrk("Cannot find a well-typed generalization of the goal that makes the proof progress."));
                } else {
                  return Proofview$ReactTemplate.tclZERO(/* Some */[param[1]], e);
                }
              }));
}

function cutSubstClause(l2r, eqn, cls) {
  if (cls) {
    var l2r$1 = l2r;
    var eqn$1 = eqn;
    var id = cls[0];
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                  var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                  var match = Hipattern$ReactTemplate.find_eq_data_decompose(gl, eqn$1);
                  var match$1 = match[2];
                  var e2 = match$1[2];
                  var e1 = match$1[1];
                  var typ = Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](id, gl);
                  var match$2 = l2r$1 ? /* tuple */[
                      e1,
                      e2
                    ] : /* tuple */[
                      e2,
                      e1
                    ];
                  var match$3 = subst_tuple_term(env, sigma, match$2[0], match$2[1], typ);
                  var match$4 = match$3[1];
                  var expected = match$4[1];
                  var typ$1 = match$4[0];
                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$3[0]), Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                      Tactics$ReactTemplate.change_in_hyp(/* None */0, (function (param, param$1) {
                                              return Tactics$ReactTemplate.make_change_arg(typ$1, param, param$1);
                                            }), /* tuple */[
                                            id,
                                            /* InHypTypeOnly */1
                                          ]),
                                      /* :: */[
                                        replace_core(Locusops$ReactTemplate.onHyp(id), l2r$1, eqn$1),
                                        /* [] */0
                                      ]
                                    ]), Tactics$ReactTemplate.change_in_hyp(/* None */0, (function (param, param$1) {
                                        return Tactics$ReactTemplate.make_change_arg(expected, param, param$1);
                                      }), /* tuple */[
                                      id,
                                      /* InHypTypeOnly */1
                                    ])));
                }));
  } else {
    var l2r$2 = l2r;
    var eqn$2 = eqn;
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                  var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                  var match = Hipattern$ReactTemplate.find_eq_data_decompose(gl, eqn$2);
                  var match$1 = match[2];
                  var e2 = match$1[2];
                  var e1 = match$1[1];
                  var typ = Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
                  var match$2 = l2r$2 ? /* tuple */[
                      e1,
                      e2
                    ] : /* tuple */[
                      e2,
                      e1
                    ];
                  var match$3 = subst_tuple_term(env, sigma, match$2[0], match$2[1], typ);
                  var match$4 = match$3[1];
                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$3[0]), Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                      Tactics$ReactTemplate.change_concl(match$4[0]),
                                      /* :: */[
                                        replace_core(Locusops$ReactTemplate.onConcl, l2r$2, eqn$2),
                                        /* [] */0
                                      ]
                                    ]), Tactics$ReactTemplate.change_concl(match$4[1])));
                }));
  }
}

function cutRewriteClause(l2r, eqn, cls) {
  return try_rewrite(cutSubstClause(l2r, eqn, cls));
}

function cutRewriteInHyp(l2r, eqn, id) {
  return cutRewriteClause(l2r, eqn, /* Some */[id]);
}

function cutRewriteInConcl(l2r, eqn) {
  return cutRewriteClause(l2r, eqn, /* None */0);
}

function substClause(l2r, c, cls) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var eq = Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0]((function (eta) {
                            return (function (param, param$1) {
                                return Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, eta, param, param$1);
                              });
                          }), gl), c);
                return Tacticals$ReactTemplate.New[/* tclTHENS */18](cutSubstClause(l2r, eq, cls), /* :: */[
                            Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0),
                            /* :: */[
                              Tactics$ReactTemplate.exact_no_check(c),
                              /* [] */0
                            ]
                          ]);
              }));
}

function rewriteClause(l2r, c, cls) {
  return try_rewrite(substClause(l2r, c, cls));
}

function rewriteInHyp(l2r, c, id) {
  return rewriteClause(l2r, c, /* Some */[id]);
}

function rewriteInConcl(l2r, c) {
  return rewriteClause(l2r, c, /* None */0);
}

var regular_subst_tactic = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"more regular behavior of tactic subst",
      /* optkey : :: */[
        "Regular",
        /* :: */[
          "Subst",
          /* :: */[
            "Tactic",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return regular_subst_tactic[0];
        }),
      /* optwrite */(function (param) {
          regular_subst_tactic[0] = param;
          return /* () */0;
        })
    ]);

function restrict_to_eq_and_identity(eq) {
  if (!Globnames$ReactTemplate.is_global(Coqlib$ReactTemplate.glob_eq, eq) && !Globnames$ReactTemplate.is_global(Coqlib$ReactTemplate.glob_identity, eq)) {
    throw Constr_matching$ReactTemplate.PatternMatchingFailure;
  } else {
    return 0;
  }
}

var FoundHyp = Caml_exceptions.create("Equality-ReactTemplate.FoundHyp");

function subst_one(dep_proof_ok, x, param) {
  var dir = param[2];
  var hyp = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var dephyps = Curry._1(Util$ReactTemplate.List[/* rev */4], Util$ReactTemplate.pi3(Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (dcl, param) {
                                var allhyps = param[2];
                                var deps = param[1];
                                var dest = param[0];
                                var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], dcl);
                                if (!Names$ReactTemplate.Id[/* equal */0](id, hyp) && Curry._2(Util$ReactTemplate.List[/* exists */21], (function (y) {
                                          return Termops$ReactTemplate.occur_var_in_decl(env, sigma, y, dcl);
                                        }), deps)) {
                                  var id_dest = regular_subst_tactic[0] ? dest : /* MoveLast */1;
                                  return /* tuple */[
                                          dest,
                                          /* :: */[
                                            id,
                                            deps
                                          ],
                                          /* :: */[
                                            /* tuple */[
                                              id_dest,
                                              id
                                            ],
                                            allhyps
                                          ]
                                        ];
                                } else {
                                  return /* tuple */[
                                          /* MoveBefore */Block.__(1, [id]),
                                          deps,
                                          allhyps
                                        ];
                                }
                              }), hyps, /* tuple */[
                              /* MoveBefore */Block.__(1, [x]),
                              /* :: */[
                                x,
                                /* [] */0
                              ],
                              /* [] */0
                            ])));
                var depconcl = Termops$ReactTemplate.occur_var(env, sigma, x, concl);
                var need_rewrite = 1 - Curry._1(Util$ReactTemplate.List[/* is_empty */45], dephyps) || depconcl;
                return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](Util$ReactTemplate.$at(need_rewrite ? /* :: */[
                                  Tactics$ReactTemplate.revert(Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                              return prim[1];
                                            }), dephyps)),
                                  /* :: */[
                                    general_rewrite(dir, /* AllOccurrences */0, /* true */1, dep_proof_ok, /* None */0, EConstr$ReactTemplate.mkVar(hyp)),
                                    /* :: */[
                                      Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                                              return Tactics$ReactTemplate.intro_move(/* Some */[param[1]], param[0]);
                                            }), dephyps),
                                      /* [] */0
                                    ]
                                  ]
                                ] : /* :: */[
                                  Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0),
                                  /* [] */0
                                ], /* :: */[
                                Tacticals$ReactTemplate.New[/* tclTRY */21](Tactics$ReactTemplate.clear(/* :: */[
                                          x,
                                          /* :: */[
                                            hyp,
                                            /* [] */0
                                          ]
                                        ])),
                                /* [] */0
                              ]));
              }));
}

function subst_gen(dep_proof_ok, ids) {
  return Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                var dep_proof_ok$1 = dep_proof_ok;
                var x = param;
                return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                              var decl = Tacmach$ReactTemplate.New[/* pf_get_hyp */14](x, gl);
                              if (Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* is_local_def */6], decl)) {
                                return Tacticals$ReactTemplate.New[/* tclTHEN */2](Tactics$ReactTemplate.unfold_body(x), Tactics$ReactTemplate.clear(/* :: */[
                                                x,
                                                /* [] */0
                                              ]));
                              } else {
                                var res;
                                try {
                                  var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                                  var test = function (hyp, _) {
                                    var gl$1 = gl;
                                    var x$1 = x;
                                    var d = hyp;
                                    var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
                                    try {
                                      var is_var = function (id, c) {
                                        var match = EConstr$ReactTemplate.kind(Tacmach$ReactTemplate.New[/* project */3](gl$1), c);
                                        if (match.tag === 1) {
                                          return Names$ReactTemplate.Id[/* equal */0](id, match[0]);
                                        } else {
                                          return /* false */0;
                                        }
                                      };
                                      var c = Tacmach$ReactTemplate.New[/* pf_nf_evar */23](gl$1, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], d));
                                      var match = Util$ReactTemplate.pi3(Hipattern$ReactTemplate.find_eq_data_decompose(gl$1, c));
                                      var rhs = match[2];
                                      var lhs = match[1];
                                      if (is_var(x$1, lhs) && !Termops$ReactTemplate.local_occur_var(Tacmach$ReactTemplate.New[/* project */3](gl$1), x$1, rhs)) {
                                        throw [
                                              FoundHyp,
                                              /* tuple */[
                                                id,
                                                rhs,
                                                /* true */1
                                              ]
                                            ];
                                      }
                                      if (is_var(x$1, rhs) && !Termops$ReactTemplate.local_occur_var(Tacmach$ReactTemplate.New[/* project */3](gl$1), x$1, lhs)) {
                                        throw [
                                              FoundHyp,
                                              /* tuple */[
                                                id,
                                                lhs,
                                                /* false */0
                                              ]
                                            ];
                                      } else {
                                        return 0;
                                      }
                                    }
                                    catch (exn){
                                      if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
                                        return /* () */0;
                                      } else {
                                        throw exn;
                                      }
                                    }
                                  };
                                  Context$ReactTemplate.Named[/* fold_outside */9](test, hyps, /* () */0);
                                  res = CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Subst"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot find any non-recursive equality over "), Names$ReactTemplate.Id[/* print */8](x)), Pp$ReactTemplate.str(".")));
                                }
                                catch (raw_exn){
                                  var exn = Js_exn.internalToOCamlException(raw_exn);
                                  if (exn[0] === FoundHyp) {
                                    res = exn[1];
                                  } else {
                                    throw exn;
                                  }
                                }
                                return subst_one(dep_proof_ok$1, x, res);
                              }
                            }));
              }), ids);
}

function subst(param) {
  return subst_gen(/* true */1, param);
}

function subst_all($staropt$star, _) {
  var flags = $staropt$star ? $staropt$star[0] : /* record */[
      /* only_leibniz : false */0,
      /* rewrite_dependent_proof : true */1
    ];
  if (regular_subst_tactic[0]) {
    var find_equations = function (gl) {
      var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
      var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
      var select_equation_name = function (decl) {
        try {
          var param = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl);
          var match = Hipattern$ReactTemplate.find_eq_data_decompose(gl, param);
          var match$1 = match[2];
          var u = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match[1]);
          var eq = Universes$ReactTemplate.constr_of_global_univ(/* tuple */[
                match[0][/* eq */0],
                u
              ]);
          if (flags[/* only_leibniz */0]) {
            restrict_to_eq_and_identity(eq);
          }
          var match$2 = EConstr$ReactTemplate.kind(sigma, match$1[1]);
          var match$3 = EConstr$ReactTemplate.kind(sigma, match$1[2]);
          var exit = 0;
          if (match$2.tag === 1) {
            if (Tacred$ReactTemplate.is_evaluable(env, /* EvalVarRef */Block.__(0, [match$2[0]]))) {
              exit = 1;
            } else {
              return /* Some */[Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl)];
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            if (match$3.tag === 1 && !Tacred$ReactTemplate.is_evaluable(env, /* EvalVarRef */Block.__(0, [match$3[0]]))) {
              return /* Some */[Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl)];
            } else {
              return /* None */0;
            }
          }
          
        }
        catch (exn){
          if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
            return /* None */0;
          } else {
            throw exn;
          }
        }
      };
      var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
      return Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._2(Util$ReactTemplate.List[/* map_filter */62], select_equation_name, hyps));
    };
    var $$process = function (hyp) {
      return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                    var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                    var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                    var c = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], Tacmach$ReactTemplate.New[/* pf_get_hyp */14](hyp, gl));
                    var match = Hipattern$ReactTemplate.find_eq_data_decompose(gl, c);
                    var match$1 = match[2];
                    var y = match$1[2];
                    var x = match$1[1];
                    if (EConstr$ReactTemplate.eq_constr(sigma, x, y)) {
                      return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                    } else {
                      var match$2 = EConstr$ReactTemplate.kind(sigma, x);
                      var match$3 = EConstr$ReactTemplate.kind(sigma, y);
                      var exit = 0;
                      if (match$2.tag === 1) {
                        var x$prime = match$2[0];
                        if (!Termops$ReactTemplate.dependent(sigma, x, y) && !Tacred$ReactTemplate.is_evaluable(env, /* EvalVarRef */Block.__(0, [x$prime]))) {
                          return subst_one(flags[/* rewrite_dependent_proof */1], x$prime, /* tuple */[
                                      hyp,
                                      y,
                                      /* true */1
                                    ]);
                        } else {
                          exit = 1;
                        }
                      } else {
                        exit = 1;
                      }
                      if (exit === 1) {
                        if (match$3.tag === 1) {
                          var y$prime = match$3[0];
                          if (!Termops$ReactTemplate.dependent(sigma, y, x) && !Tacred$ReactTemplate.is_evaluable(env, /* EvalVarRef */Block.__(0, [y$prime]))) {
                            return subst_one(flags[/* rewrite_dependent_proof */1], y$prime, /* tuple */[
                                        hyp,
                                        x,
                                        /* false */0
                                      ]);
                          } else {
                            return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                          }
                        } else {
                          return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                        }
                      }
                      
                    }
                  }));
    };
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var ids = find_equations(gl);
                  return Tacticals$ReactTemplate.New[/* tclMAP */20]($$process, ids);
                }));
  } else {
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                  var test = function (param) {
                    try {
                      var match = Hipattern$ReactTemplate.find_eq_data_decompose(gl, param[1]);
                      var match$1 = match[2];
                      var y = match$1[2];
                      var x = match$1[1];
                      var u = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match[1]);
                      var eq = Universes$ReactTemplate.constr_of_global_univ(/* tuple */[
                            match[0][/* eq */0],
                            u
                          ]);
                      if (flags[/* only_leibniz */0]) {
                        restrict_to_eq_and_identity(eq);
                      }
                      if (EConstr$ReactTemplate.eq_constr(sigma, x, y)) {
                        Pervasives.failwith("caught");
                      }
                      var match$2 = EConstr$ReactTemplate.kind(sigma, x);
                      if (match$2.tag === 1) {
                        return match$2[0];
                      } else {
                        var match$3 = EConstr$ReactTemplate.kind(sigma, y);
                        if (match$3.tag === 1) {
                          return match$3[0];
                        } else {
                          return Pervasives.failwith("caught");
                        }
                      }
                    }
                    catch (exn){
                      if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
                        return Pervasives.failwith("caught");
                      } else {
                        throw exn;
                      }
                    }
                  };
                  var test$1 = function (p) {
                    try {
                      return /* Some */[test(p)];
                    }
                    catch (raw_exn){
                      var exn = Js_exn.internalToOCamlException(raw_exn);
                      if (exn[0] === Caml_builtin_exceptions.failure) {
                        return /* None */0;
                      } else {
                        throw exn;
                      }
                    }
                  };
                  var hyps = Tacmach$ReactTemplate.New[/* pf_hyps_types */13](gl);
                  var ids = Curry._2(Util$ReactTemplate.List[/* map_filter */62], test$1, hyps);
                  var ids$1 = Curry._1(Util$ReactTemplate.List[/* uniquize */95], ids);
                  return subst_gen(flags[/* rewrite_dependent_proof */1], ids$1);
                }));
  }
}

function replace_term(dir_opt, c) {
  var partial_arg = dir_opt ? (
      dir_opt[0] !== 0 ? (function (param, param$1) {
            var c$1 = c;
            var t = param;
            var gl = param$1;
            try {
              var match = Util$ReactTemplate.pi3(Hipattern$ReactTemplate.find_eq_data_decompose(gl, t));
              if (Tacmach$ReactTemplate.New[/* pf_conv_x */9](gl, c$1, match[1])) {
                return /* true */1;
              } else {
                return Pervasives.failwith("not convertible");
              }
            }
            catch (exn){
              if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
                return Pervasives.failwith("not an equality");
              } else {
                throw exn;
              }
            }
          }) : (function (param, param$1) {
            var c$1 = c;
            var t = param;
            var gl = param$1;
            try {
              var match = Util$ReactTemplate.pi3(Hipattern$ReactTemplate.find_eq_data_decompose(gl, t));
              if (Tacmach$ReactTemplate.New[/* pf_conv_x */9](gl, c$1, match[2])) {
                return /* false */0;
              } else {
                return Pervasives.failwith("not convertible");
              }
            }
            catch (exn){
              if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
                return Pervasives.failwith("not an equality");
              } else {
                throw exn;
              }
            }
          })
    ) : (function (param, param$1) {
        var c$1 = c;
        var t = param;
        var gl = param$1;
        try {
          var match = Util$ReactTemplate.pi3(Hipattern$ReactTemplate.find_eq_data_decompose(gl, t));
          if (Tacmach$ReactTemplate.New[/* pf_conv_x */9](gl, c$1, match[1])) {
            return /* true */1;
          } else if (Tacmach$ReactTemplate.New[/* pf_conv_x */9](gl, c$1, match[2])) {
            return /* false */0;
          } else {
            return Pervasives.failwith("not convertible");
          }
        }
        catch (exn){
          if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
            return Pervasives.failwith("not an equality");
          } else {
            throw exn;
          }
        }
      });
  return (function (param) {
      var cond_eq_term = partial_arg;
      var cl = param;
      return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                    var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                    var _hyps = hyps;
                    var gl$1 = gl;
                    while(true) {
                      var hyps$1 = _hyps;
                      if (hyps$1) {
                        var rest = hyps$1[1];
                        var hyp = hyps$1[0];
                        var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], hyp);
                        try {
                          var dir = Curry._2(cond_eq_term, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], hyp), gl$1);
                          return general_rewrite_clause(dir, /* false */0, /* None */0, /* tuple */[
                                      EConstr$ReactTemplate.mkVar(id),
                                      /* NoBindings */0
                                    ], cl);
                        }
                        catch (raw_exn){
                          var exn = Js_exn.internalToOCamlException(raw_exn);
                          if (exn[0] === Caml_builtin_exceptions.failure) {
                            _hyps = rest;
                            continue ;
                            
                          } else if (exn[0] === CErrors$ReactTemplate.UserError) {
                            _hyps = rest;
                            continue ;
                            
                          } else {
                            throw exn;
                          }
                        }
                      } else {
                        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such assumption."));
                      }
                    };
                  }));
    });
}

function gmr(l2r, with_evars, tac, c) {
  return general_rewrite_clause(l2r, with_evars, /* None */0, tac, c);
}

Hook$ReactTemplate.set(Tactics$ReactTemplate.general_rewrite_clause, gmr);

Hook$ReactTemplate.set(Tactics$ReactTemplate.subst_one, subst_one);

var general_setoid_rewrite_clause = match[1];

exports.general_rewrite_bindings = general_rewrite_bindings;
exports.general_rewrite = general_rewrite;
exports.rewriteLR = rewriteLR;
exports.rewriteRL = rewriteRL;
exports.general_setoid_rewrite_clause = general_setoid_rewrite_clause;
exports.general_rewrite_ebindings_clause = general_rewrite_ebindings_clause;
exports.general_rewrite_bindings_in = general_rewrite_bindings_in;
exports.general_rewrite_in = general_rewrite_in;
exports.general_rewrite_clause = general_rewrite_clause;
exports.general_multi_rewrite = general_multi_rewrite;
exports.replace_in_clause_maybe_by = replace_in_clause_maybe_by;
exports.replace = replace;
exports.replace_by = replace_by;
exports.discr = discr;
exports.discrConcl = discrConcl;
exports.discrHyp = discrHyp;
exports.discrEverywhere = discrEverywhere;
exports.discr_tac = discr_tac;
exports.inj = inj;
exports.injClause = injClause;
exports.injHyp = injHyp;
exports.injConcl = injConcl;
exports.simpleInjClause = simpleInjClause;
exports.dEq = dEq;
exports.dEqThen = dEqThen;
exports.make_iterated_tuple = make_iterated_tuple;
exports.cutRewriteInHyp = cutRewriteInHyp;
exports.cutRewriteInConcl = cutRewriteInConcl;
exports.rewriteInHyp = rewriteInHyp;
exports.rewriteInConcl = rewriteInConcl;
exports.discriminable = discriminable;
exports.injectable = injectable;
exports.subst_gen = subst_gen;
exports.subst = subst;
exports.subst_all = subst_all;
exports.replace_term = replace_term;
exports.set_eq_dec_scheme_kind = set_eq_dec_scheme_kind;
exports.build_selector = build_selector;
/*  Not a pure module */
