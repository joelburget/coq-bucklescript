// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function compare(cmp, v1, v2) {
  if (v1 === v2) {
    return 0;
  } else {
    var len = v1.length;
    var c = Caml_primitive.caml_int_compare(len, v2.length);
    if (c !== 0) {
      return c;
    } else {
      var _i = len - 1 | 0;
      while(true) {
        var i = _i;
        if (i < 0) {
          return 0;
        } else {
          var x = v1[i];
          var y = v2[i];
          var c$1 = Curry._2(cmp, x, y);
          if (c$1 !== 0) {
            return c$1;
          } else {
            _i = i - 1 | 0;
            continue ;
            
          }
        }
      };
    }
  }
}

function equal_norefl(cmp, t1, t2) {
  var len = t1.length;
  if (len !== t2.length) {
    return /* false */0;
  } else {
    var _i = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return /* true */1;
      } else {
        var x = t1[i];
        var y = t2[i];
        if (Curry._2(cmp, x, y)) {
          _i = i - 1 | 0;
          continue ;
          
        } else {
          return /* false */0;
        }
      }
    };
  }
}

function equal(cmp, t1, t2) {
  if (t1 === t2) {
    return /* true */1;
  } else {
    return equal_norefl(cmp, t1, t2);
  }
}

function is_empty(array) {
  return +(array.length === 0);
}

function exists(f, v) {
  var _n = v.length - 1 | 0;
  while(true) {
    var n = _n;
    if (n !== -1) {
      if (Curry._1(f, v[n])) {
        return /* true */1;
      } else {
        _n = n - 1 | 0;
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function exists2(f, v1, v2) {
  var lv1 = v1.length;
  if (lv1 === v2.length) {
    var _n = lv1 - 1 | 0;
    while(true) {
      var n = _n;
      if (n !== -1) {
        if (Curry._2(f, v1[n], v2[n])) {
          return /* true */1;
        } else {
          _n = n - 1 | 0;
          continue ;
          
        }
      } else {
        return /* false */0;
      }
    };
  } else {
    return /* false */0;
  }
}

function for_all(f, v) {
  var _n = v.length - 1 | 0;
  while(true) {
    var n = _n;
    if (n !== -1) {
      var ans = Curry._1(f, v[n]);
      if (ans) {
        _n = n - 1 | 0;
        continue ;
        
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function for_all2(f, v1, v2) {
  var lv1 = v1.length;
  if (lv1 === v2.length) {
    var _n = lv1 - 1 | 0;
    while(true) {
      var n = _n;
      if (n !== -1) {
        var ans = Curry._2(f, v1[n], v2[n]);
        if (ans) {
          _n = n - 1 | 0;
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* true */1;
      }
    };
  } else {
    return /* false */0;
  }
}

function for_all3(f, v1, v2, v3) {
  var lv1 = v1.length;
  if (lv1 === v2.length && lv1 === v3.length) {
    var _n = lv1 - 1 | 0;
    while(true) {
      var n = _n;
      if (n !== -1) {
        var ans = Curry._3(f, v1[n], v2[n], v3[n]);
        if (ans) {
          _n = n - 1 | 0;
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* true */1;
      }
    };
  } else {
    return /* false */0;
  }
}

function for_all4(f, v1, v2, v3, v4) {
  var lv1 = v1.length;
  if (lv1 === v2.length && lv1 === v3.length && lv1 === v4.length) {
    var _n = lv1 - 1 | 0;
    while(true) {
      var n = _n;
      if (n !== -1) {
        var ans = Curry._4(f, v1[n], v2[n], v3[n], v4[n]);
        if (ans) {
          _n = n - 1 | 0;
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* true */1;
      }
    };
  } else {
    return /* false */0;
  }
}

function for_all_i(f, i, v) {
  var len = v.length;
  var _i = i;
  var _n = 0;
  while(true) {
    var n = _n;
    var i$1 = _i;
    if (n === len) {
      return /* true */1;
    } else if (Curry._2(f, i$1, v[n])) {
      _n = n + 1 | 0;
      _i = i$1 + 1 | 0;
      continue ;
      
    } else {
      return /* false */0;
    }
  };
}

var Found = Caml_exceptions.create("CArray-ReactTemplate.Found");

function findi(pred, arr) {
  try {
    for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
      if (Curry._2(pred, i, arr[i])) {
        throw [
              Found,
              i
            ];
      }
      
    }
    return /* None */0;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Found) {
      return /* Some */[exn[1]];
    } else {
      throw exn;
    }
  }
}

function hd(v) {
  var match = v.length;
  if (match !== 0) {
    return v[0];
  } else {
    return Pervasives.failwith("Array.hd");
  }
}

function tl(v) {
  var n = v.length;
  if (n !== 0) {
    return $$Array.sub(v, 1, n - 1 | 0);
  } else {
    return Pervasives.failwith("Array.tl");
  }
}

function last(v) {
  var n = v.length;
  if (n !== 0) {
    return v[n - 1 | 0];
  } else {
    return Pervasives.failwith("Array.last");
  }
}

function cons(e, v) {
  var len = v.length;
  var ans = Caml_array.caml_make_vect(v.length + 1 | 0, e);
  $$Array.blit(v, 0, ans, 1, len);
  return ans;
}

function rev(t) {
  var n = t.length;
  if (n <= 0) {
    return /* () */0;
  } else {
    for(var i = 0 ,i_finish = (n / 2 | 0) - 1 | 0; i <= i_finish; ++i){
      var tmp = t[(n - 1 | 0) - i | 0];
      t[(n - 1 | 0) - i | 0] = t[i];
      t[i] = tmp;
    }
    return /* () */0;
  }
}

function fold_right_i(f, v, a) {
  var _a = a;
  var _n = v.length;
  while(true) {
    var n = _n;
    var a$1 = _a;
    if (n) {
      var k = n - 1 | 0;
      _n = k;
      _a = Curry._3(f, k, v[k], a$1);
      continue ;
      
    } else {
      return a$1;
    }
  };
}

function fold_left_i(f, v, a) {
  var n = a.length;
  var _i = 0;
  var _v = v;
  while(true) {
    var v$1 = _v;
    var i = _i;
    if (i === n) {
      return v$1;
    } else {
      _v = Curry._3(f, i, v$1, a[i]);
      _i = i + 1 | 0;
      continue ;
      
    }
  };
}

function fold_right2(f, v1, v2, a) {
  var lv1 = v1.length;
  if (v2.length !== lv1) {
    Pervasives.invalid_arg("Array.fold_right2");
  }
  var _a = a;
  var _n = lv1;
  while(true) {
    var n = _n;
    var a$1 = _a;
    if (n) {
      var k = n - 1 | 0;
      _n = k;
      _a = Curry._3(f, v1[k], v2[k], a$1);
      continue ;
      
    } else {
      return a$1;
    }
  };
}

function fold_left2(f, a, v1, v2) {
  var lv1 = v1.length;
  if (v2.length !== lv1) {
    Pervasives.invalid_arg("Array.fold_left2");
  }
  var _a = a;
  var _n = 0;
  while(true) {
    var n = _n;
    var a$1 = _a;
    if (n >= lv1) {
      return a$1;
    } else {
      _n = n + 1 | 0;
      _a = Curry._3(f, a$1, v1[n], v2[n]);
      continue ;
      
    }
  };
}

function fold_left2_i(f, a, v1, v2) {
  var lv1 = v1.length;
  if (v2.length !== lv1) {
    Pervasives.invalid_arg("Array.fold_left2");
  }
  var _a = a;
  var _n = 0;
  while(true) {
    var n = _n;
    var a$1 = _a;
    if (n >= lv1) {
      return a$1;
    } else {
      _n = n + 1 | 0;
      _a = Curry._4(f, n, a$1, v1[n], v2[n]);
      continue ;
      
    }
  };
}

function fold_left3(f, a, v1, v2, v3) {
  var lv1 = v1.length;
  if (v2.length !== lv1 || v3.length !== lv1) {
    Pervasives.invalid_arg("Array.fold_left2");
  }
  var _a = a;
  var _n = 0;
  while(true) {
    var n = _n;
    var a$1 = _a;
    if (n >= lv1) {
      return a$1;
    } else {
      _n = n + 1 | 0;
      _a = Curry._4(f, a$1, v1[n], v2[n], v3[n]);
      continue ;
      
    }
  };
}

function fold_left_from(n, f, a, v) {
  var len = v.length;
  if (n < 0) {
    Pervasives.invalid_arg("Array.fold_left_from");
  }
  var _a = a;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var a$1 = _a;
    if (n$1 >= len) {
      return a$1;
    } else {
      _n = n$1 + 1 | 0;
      _a = Curry._2(f, a$1, v[n$1]);
      continue ;
      
    }
  };
}

function rev_of_list(param) {
  if (param) {
    var l = param[1];
    var len = List.length(l);
    var ans = Caml_array.caml_make_vect(len + 1 | 0, param[0]);
    var set = function (_i, _param) {
      while(true) {
        var param = _param;
        var i = _i;
        if (param) {
          ans[i] = param[0];
          _param = param[1];
          _i = i - 1 | 0;
          continue ;
          
        } else {
          return /* () */0;
        }
      };
    };
    set(len - 1 | 0, l);
    return ans;
  } else {
    return /* array */[];
  }
}

function map_of_list(f, l) {
  var len = List.length(l);
  var fill = function (_i, v, _param) {
    while(true) {
      var param = _param;
      var i = _i;
      if (param) {
        v[i] = Curry._1(f, param[0]);
        _param = param[1];
        _i = i + 1 | 0;
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  };
  if (l) {
    var ans = Caml_array.caml_make_vect(len, Curry._1(f, l[0]));
    fill(1, ans, l[1]);
    return ans;
  } else {
    return /* array */[];
  }
}

function chop(n, v) {
  var vlen = v.length;
  if (n > vlen) {
    Pervasives.failwith("Array.chop");
  }
  return /* tuple */[
          $$Array.sub(v, 0, n),
          $$Array.sub(v, n, vlen - n | 0)
        ];
}

function smartmap(f, ar) {
  var len = ar.length;
  var i = 0;
  var $$break = /* true */1;
  var temp = /* None */0;
  while($$break && i < len) {
    var v = ar[i];
    var v$prime = Curry._1(f, v);
    if (v === v$prime) {
      i = i + 1 | 0;
    } else {
      $$break = /* false */0;
      temp = /* Some */[v$prime];
    }
  };
  if (i < len) {
    var ans = $$Array.copy(ar);
    var match = temp;
    var v$1;
    if (match) {
      v$1 = match[0];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cArray.ml",
              335,
              37
            ]
          ];
    }
    ans[i] = v$1;
    i = i + 1 | 0;
    while(i < len) {
      var v$2 = ans[i];
      var v$prime$1 = Curry._1(f, v$2);
      if (v$2 !== v$prime$1) {
        ans[i] = v$prime$1;
      }
      i = i + 1 | 0;
    };
    return ans;
  } else {
    return ar;
  }
}

function smartfoldmap(f, accu, ar) {
  var len = ar.length;
  var i = 0;
  var $$break = /* true */1;
  var r = accu;
  var temp = /* None */0;
  while($$break && i < len) {
    var v = ar[i];
    var match = Curry._2(f, r, v);
    var v$prime = match[1];
    r = match[0];
    if (v === v$prime) {
      i = i + 1 | 0;
    } else {
      $$break = /* false */0;
      temp = /* Some */[v$prime];
    }
  };
  if (i < len) {
    var ans = $$Array.copy(ar);
    var match$1 = temp;
    var v$1;
    if (match$1) {
      v$1 = match$1[0];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cArray.ml",
              367,
              37
            ]
          ];
    }
    ans[i] = v$1;
    i = i + 1 | 0;
    while(i < len) {
      var v$2 = ar[i];
      var match$2 = Curry._2(f, r, v$2);
      var v$prime$1 = match$2[1];
      r = match$2[0];
      if (v$2 !== v$prime$1) {
        ans[i] = v$prime$1;
      }
      i = i + 1 | 0;
    };
    return /* tuple */[
            r,
            ans
          ];
  } else {
    return /* tuple */[
            r,
            ar
          ];
  }
}

function map2(f, v1, v2) {
  var len1 = v1.length;
  var len2 = v2.length;
  if (len1 !== len2) {
    Pervasives.invalid_arg("Array.map2");
  }
  if (len1) {
    var res = Caml_array.caml_make_vect(len1, Curry._2(f, v1[0], v2[0]));
    for(var i = 1 ,i_finish = len1 - 1 | 0; i <= i_finish; ++i){
      res[i] = Curry._2(f, v1[i], v2[i]);
    }
    return res;
  } else {
    return /* array */[];
  }
}

function map2_i(f, v1, v2) {
  var len1 = v1.length;
  var len2 = v2.length;
  if (len1 !== len2) {
    Pervasives.invalid_arg("Array.map2");
  }
  if (len1) {
    var res = Caml_array.caml_make_vect(len1, Curry._3(f, 0, v1[0], v2[0]));
    for(var i = 1 ,i_finish = len1 - 1 | 0; i <= i_finish; ++i){
      res[i] = Curry._3(f, i, v1[i], v2[i]);
    }
    return res;
  } else {
    return /* array */[];
  }
}

function map3(f, v1, v2, v3) {
  var len1 = v1.length;
  if (len1 !== v2.length || len1 !== v3.length) {
    Pervasives.invalid_arg("Array.map3");
  }
  if (len1) {
    var res = Caml_array.caml_make_vect(len1, Curry._3(f, v1[0], v2[0], v3[0]));
    for(var i = 1 ,i_finish = len1 - 1 | 0; i <= i_finish; ++i){
      res[i] = Curry._3(f, v1[i], v2[i], v3[i]);
    }
    return res;
  } else {
    return /* array */[];
  }
}

function map_left(f, a) {
  var l = a.length;
  if (l) {
    var r = Caml_array.caml_make_vect(l, Curry._1(f, a[0]));
    for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = Curry._1(f, a[i]);
    }
    return r;
  } else {
    return /* array */[];
  }
}

function iter2(f, v1, v2) {
  var len1 = v1.length;
  var len2 = v2.length;
  if (len2 !== len1) {
    Pervasives.invalid_arg("Array.iter2");
  }
  for(var i = 0 ,i_finish = len1 - 1 | 0; i <= i_finish; ++i){
    Curry._2(f, v1[i], v2[i]);
  }
  return /* () */0;
}

function fold_right_map(f, v, e) {
  var e$prime = [e];
  var v$prime = $$Array.map((function (x) {
          var match = Curry._2(f, x, e$prime[0]);
          e$prime[0] = match[1];
          return match[0];
        }), v);
  return /* tuple */[
          v$prime,
          e$prime[0]
        ];
}

function fold_left_map(f, e, v) {
  var e$prime = [e];
  var v$prime = $$Array.map((function (x) {
          var match = Curry._2(f, e$prime[0], x);
          e$prime[0] = match[0];
          return match[1];
        }), v);
  return /* tuple */[
          e$prime[0],
          v$prime
        ];
}

function fold_right2_map(f, v1, v2, e) {
  var e$prime = [e];
  var v$prime = map2((function (x1, x2) {
          var match = Curry._3(f, x1, x2, e$prime[0]);
          e$prime[0] = match[1];
          return match[0];
        }), v1, v2);
  return /* tuple */[
          v$prime,
          e$prime[0]
        ];
}

function fold_left2_map(f, e, v1, v2) {
  var e$prime = [e];
  var v$prime = map2((function (x1, x2) {
          var match = Curry._3(f, e$prime[0], x1, x2);
          e$prime[0] = match[0];
          return match[1];
        }), v1, v2);
  return /* tuple */[
          e$prime[0],
          v$prime
        ];
}

function distinct(v) {
  var visited = Hashtbl.create(/* None */0, 23);
  try {
    $$Array.iter((function (x) {
            if (Hashtbl.mem(visited, x)) {
              throw Pervasives.Exit;
            } else {
              return Hashtbl.add(visited, x, x);
            }
          }), v);
    return /* true */1;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function rev_to_list(a) {
  var _i = 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i >= a.length) {
      return res;
    } else {
      _res = /* :: */[
        a[i],
        res
      ];
      _i = i + 1 | 0;
      continue ;
      
    }
  };
}

function filter_with(filter, v) {
  return $$Array.of_list(CList$ReactTemplate.filter_with(filter, $$Array.to_list(v)));
}

function map(f, arg, v) {
  if (v.length !== 0) {
    var len = v.length;
    var x0 = v[0];
    var ans = Caml_array.caml_make_vect(len, Curry._2(f, arg, x0));
    for(var i = 1 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
      var x = v[i];
      ans[i] = Curry._2(f, arg, x);
    }
    return ans;
  } else {
    return /* array */[];
  }
}

function smartmap$1(f, arg, ar) {
  var len = ar.length;
  var i = 0;
  var $$break = /* true */1;
  var temp = /* None */0;
  while($$break && i < len) {
    var v = ar[i];
    var v$prime = Curry._2(f, arg, v);
    if (v === v$prime) {
      i = i + 1 | 0;
    } else {
      $$break = /* false */0;
      temp = /* Some */[v$prime];
    }
  };
  if (i < len) {
    var ans = $$Array.copy(ar);
    var match = temp;
    var v$1;
    if (match) {
      v$1 = match[0];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cArray.ml",
              528,
              39
            ]
          ];
    }
    ans[i] = v$1;
    i = i + 1 | 0;
    while(i < len) {
      var v$2 = ans[i];
      var v$prime$1 = Curry._2(f, arg, v$2);
      if (v$2 !== v$prime$1) {
        ans[i] = v$prime$1;
      }
      i = i + 1 | 0;
    };
    return ans;
  } else {
    return ar;
  }
}

function iter(f, arg, v) {
  var len = v.length;
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    var x = v[i];
    Curry._2(f, arg, x);
  }
  return /* () */0;
}

var Fun1 = /* module */[
  /* map */map,
  /* smartmap */smartmap$1,
  /* iter */iter
];

var init = $$Array.init;

var make_matrix = $$Array.make_matrix;

var create_matrix = $$Array.create_matrix;

var append = $$Array.append;

var concat = $$Array.concat;

var sub = $$Array.sub;

var copy = $$Array.copy;

var fill = $$Array.fill;

var blit = $$Array.blit;

var to_list = $$Array.to_list;

var of_list = $$Array.of_list;

var iter$1 = $$Array.iter;

var map$1 = $$Array.map;

var iteri = $$Array.iteri;

var mapi = $$Array.mapi;

var fold_left = $$Array.fold_left;

var fold_right = $$Array.fold_right;

var sort = $$Array.sort;

var stable_sort = $$Array.stable_sort;

var fast_sort = $$Array.fast_sort;

var map_to_list = CList$ReactTemplate.map_of_array;

var fold_map = fold_left_map;

var fold_map$prime = fold_right_map;

var fold_map2$prime = fold_right2_map;

exports.init = init;
exports.make_matrix = make_matrix;
exports.create_matrix = create_matrix;
exports.append = append;
exports.concat = concat;
exports.sub = sub;
exports.copy = copy;
exports.fill = fill;
exports.blit = blit;
exports.to_list = to_list;
exports.of_list = of_list;
exports.iter = iter$1;
exports.map = map$1;
exports.iteri = iteri;
exports.mapi = mapi;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.sort = sort;
exports.stable_sort = stable_sort;
exports.fast_sort = fast_sort;
exports.compare = compare;
exports.equal = equal;
exports.equal_norefl = equal_norefl;
exports.is_empty = is_empty;
exports.exists = exists;
exports.exists2 = exists2;
exports.for_all = for_all;
exports.for_all2 = for_all2;
exports.for_all3 = for_all3;
exports.for_all4 = for_all4;
exports.for_all_i = for_all_i;
exports.findi = findi;
exports.hd = hd;
exports.tl = tl;
exports.last = last;
exports.cons = cons;
exports.rev = rev;
exports.fold_right_i = fold_right_i;
exports.fold_left_i = fold_left_i;
exports.fold_right2 = fold_right2;
exports.fold_left2 = fold_left2;
exports.fold_left3 = fold_left3;
exports.fold_left2_i = fold_left2_i;
exports.fold_left_from = fold_left_from;
exports.map_to_list = map_to_list;
exports.map_of_list = map_of_list;
exports.chop = chop;
exports.smartmap = smartmap;
exports.smartfoldmap = smartfoldmap;
exports.map2 = map2;
exports.map2_i = map2_i;
exports.map3 = map3;
exports.map_left = map_left;
exports.iter2 = iter2;
exports.fold_left_map = fold_left_map;
exports.fold_right_map = fold_right_map;
exports.fold_left2_map = fold_left2_map;
exports.fold_right2_map = fold_right2_map;
exports.fold_map = fold_map;
exports.fold_map$prime = fold_map$prime;
exports.fold_map2$prime = fold_map2$prime;
exports.distinct = distinct;
exports.rev_of_list = rev_of_list;
exports.rev_to_list = rev_to_list;
exports.filter_with = filter_with;
exports.Fun1 = Fun1;
/* No side effect */
