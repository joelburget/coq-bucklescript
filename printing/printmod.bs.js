// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Vars$ReactTemplate = require("../src/vars.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Modops$ReactTemplate = require("../src/modops.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var States$ReactTemplate = require("../src/states.bs.js");
var UState$ReactTemplate = require("../src/uState.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Printer$ReactTemplate = require("../src/printer.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Inductive$ReactTemplate = require("../src/inductive.bs.js");
var Mod_subst$ReactTemplate = require("../src/mod_subst.bs.js");
var Reduction$ReactTemplate = require("../src/reduction.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Declareops$ReactTemplate = require("../src/declareops.bs.js");
var Declaremods$ReactTemplate = require("../src/declaremods.bs.js");

var definition = "module.definition";

var keyword = "module.keyword";

var $$short = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"short module printing",
      /* optkey : :: */[
        "Short",
        /* :: */[
          "Module",
          /* :: */[
            "Printing",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return $$short[0];
        }),
      /* optwrite */(function (param) {
          $$short[0] = param;
          return /* () */0;
        })
    ]);

var r = [0];

function mk_fake_top() {
  r[0] = r[0] + 1 | 0;
  return Names$ReactTemplate.Id[/* of_string */5]("FAKETOP" + Pervasives.string_of_int(r[0]));
}

function get_new_id(locals, id) {
  var avoid = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (accu, param) {
          return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], param[1], accu);
        }), Names$ReactTemplate.Id[/* Set */9][/* empty */0], locals);
  var _l = avoid;
  var _id = id;
  while(true) {
    var id$1 = _id;
    var l = _l;
    var dir = Names$ReactTemplate.DirPath[/* make */3](/* :: */[
          id$1,
          /* [] */0
        ]);
    if (Nametab$ReactTemplate.exists_module(dir)) {
      _id = Namegen$ReactTemplate.next_ident_away(id$1, l);
      _l = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id$1, l);
      continue ;
      
    } else {
      return id$1;
    }
  };
}

function print_params(env, sigma, params) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], params)) {
    return Pp$ReactTemplate.mt(/* () */0);
  } else {
    return Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_rel_context(env, sigma, params), Pp$ReactTemplate.brk(/* tuple */[
                    1,
                    2
                  ]));
  }
}

function print_constructors(envpar, sigma, names, types) {
  var pc = Pp$ReactTemplate.prlist_with_sep((function () {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.brk(/* tuple */[
                          1,
                          0
                        ]), Pp$ReactTemplate.str("| "));
        }), (function (param) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](param[0]), Pp$ReactTemplate.str(" : ")), Printer$ReactTemplate.pr_lconstr_env(envpar, sigma, param[1]));
        }), Util$ReactTemplate.$$Array[/* to_list */9](Util$ReactTemplate.$$Array[/* map2 */49]((function (n, t) {
                  return /* tuple */[
                          n,
                          t
                        ];
                }), names, types)));
  return Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("  "), pc));
}

function instantiate_cumulativity_info(cumi) {
  var univs = Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](cumi);
  var expose = function (ctx) {
    var inst = Univ$ReactTemplate.AUContext[/* instance */3](ctx);
    var cst = Univ$ReactTemplate.AUContext[/* instantiate */6](inst, ctx);
    return Univ$ReactTemplate.UContext[/* make */0](/* tuple */[
                inst,
                cst
              ]);
  };
  return Univ$ReactTemplate.CumulativityInfo[/* make */0](/* tuple */[
              expose(univs),
              Univ$ReactTemplate.ACumulativityInfo[/* variance */1](cumi)
            ]);
}

function prodec_rec(_l, _subst, _c) {
  while(true) {
    var c = _c;
    var subst = _subst;
    var l = _l;
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 6 : 
          var na = match[0];
          var id = na ? na[0] : Names$ReactTemplate.Id[/* of_string */5]("_");
          _c = match[2];
          _subst = /* :: */[
            Constr$ReactTemplate.mkVar(id),
            subst
          ];
          _l = /* :: */[
            /* tuple */[
              id,
              /* true */1,
              Vars$ReactTemplate.substl(subst, match[1])
            ],
            l
          ];
          continue ;
          case 8 : 
          var na$1 = match[0];
          var id$1 = na$1 ? na$1[0] : Names$ReactTemplate.Id[/* of_string */5]("_");
          _c = match[3];
          _subst = /* :: */[
            Constr$ReactTemplate.mkVar(id$1),
            subst
          ];
          _l = /* :: */[
            /* tuple */[
              id$1,
              /* false */0,
              Vars$ReactTemplate.substl(subst, match[1])
            ],
            l
          ];
          continue ;
          default:
        return Curry._1(Util$ReactTemplate.List[/* rev */4], l);
    }
  };
}

function pr_mutual_inductive_body(env, mind, mib, udecl) {
  if (mib[/* mind_record */1] !== /* None */0 && !Flags$ReactTemplate.raw_print[0]) {
    var env$1 = env;
    var mind$1 = mind;
    var mib$1 = mib;
    var udecl$1 = udecl;
    var u = Declareops$ReactTemplate.inductive_is_polymorphic(mib$1) ? Univ$ReactTemplate.AUContext[/* instance */3](Declareops$ReactTemplate.inductive_polymorphic_context(mib$1)) : Univ$ReactTemplate.Instance[/* empty */0];
    var mip = Caml_array.caml_array_get(mib$1[/* mind_packets */0], 0);
    var params = Inductive$ReactTemplate.inductive_paramdecls(/* tuple */[
          mib$1,
          u
        ]);
    var nparamdecls = Curry._1(Context$ReactTemplate.Rel[/* length */3], params);
    var args = Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, params);
    var arity = Reduction$ReactTemplate.hnf_prod_applist_assum(env$1, nparamdecls, Inductive$ReactTemplate.type_of_inductive(env$1, /* tuple */[
              /* tuple */[
                mib$1,
                mip
              ],
              u
            ]), args);
    var cstrtypes = Inductive$ReactTemplate.type_of_constructors(/* tuple */[
          /* tuple */[
            mind$1,
            0
          ],
          u
        ], /* tuple */[
          mib$1,
          mip
        ]);
    var cstrtype = Reduction$ReactTemplate.hnf_prod_applist_assum(env$1, nparamdecls, Caml_array.caml_array_get(cstrtypes, 0), args);
    var fields = prodec_rec(/* [] */0, /* [] */0, cstrtype);
    var envpar = Environ$ReactTemplate.push_rel_context(params, env$1);
    var bl = Universes$ReactTemplate.universe_binders_with_opt_names(/* IndRef */Block.__(2, [/* tuple */[
              mind$1,
              0
            ]]), Util$ReactTemplate.$$Array[/* to_list */9](Univ$ReactTemplate.Instance[/* to_array */3](u)), udecl$1);
    var sigma = Evd$ReactTemplate.from_ctx(UState$ReactTemplate.of_binders(bl));
    var match = mib$1[/* mind_finite */2];
    var keyword;
    switch (match) {
      case 0 : 
          keyword = "Inductive";
          break;
      case 1 : 
          keyword = "CoInductive";
          break;
      case 2 : 
          keyword = "Record";
          break;
      
    }
    var s = Pp$ReactTemplate.str(keyword);
    var match$1 = mib$1[/* mind_universes */8];
    var tmp;
    switch (match$1.tag | 0) {
      case 0 : 
      case 1 : 
          tmp = Pp$ReactTemplate.str("");
          break;
      case 2 : 
          tmp = Printer$ReactTemplate.pr_cumulativity_info(sigma, instantiate_cumulativity_info(match$1[0]));
          break;
      
    }
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_polymorphic(Declareops$ReactTemplate.inductive_is_polymorphic(mib$1)), Printer$ReactTemplate.pr_cumulative(Declareops$ReactTemplate.inductive_is_polymorphic(mib$1), Declareops$ReactTemplate.inductive_is_cumulative(mib$1))), Pp$ReactTemplate.tag(definition, s)), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](mip[/* mind_typename */0])), Pp$ReactTemplate.brk(/* tuple */[
                                                                    1,
                                                                    4
                                                                  ])), print_params(env$1, sigma, params)), Pp$ReactTemplate.str(": ")), Printer$ReactTemplate.pr_lconstr_env(envpar, sigma, arity)), Pp$ReactTemplate.brk(/* tuple */[
                                                    1,
                                                    2
                                                  ])), Pp$ReactTemplate.str(":= ")), Names$ReactTemplate.Id[/* print */8](Caml_array.caml_array_get(mip[/* mind_consnames */3], 0)))), Pp$ReactTemplate.brk(/* tuple */[
                                    1,
                                    2
                                  ])), Pp$ReactTemplate.hv(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{ "), Pp$ReactTemplate.prlist_with_sep((function () {
                                          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(";"), Pp$ReactTemplate.brk(/* tuple */[
                                                          2,
                                                          0
                                                        ]));
                                        }), (function (param) {
                                          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](param[0]), Pp$ReactTemplate.str(param[1] ? " : " : " := ")), Printer$ReactTemplate.pr_lconstr_env(envpar, sigma, param[2]));
                                        }), fields)))), Pp$ReactTemplate.str(" }")), tmp));
  } else {
    var env$2 = env;
    var mind$2 = mind;
    var mib$2 = mib;
    var udecl$2 = udecl;
    var inds = Curry._2(Util$ReactTemplate.List[/* init */46], mib$2[/* mind_packets */0].length, (function (x) {
            return /* tuple */[
                    mind$2,
                    x
                  ];
          }));
    var match$2 = mib$2[/* mind_finite */2];
    var keyword$1;
    switch (match$2) {
      case 0 : 
          keyword$1 = "Inductive";
          break;
      case 1 : 
          keyword$1 = "CoInductive";
          break;
      case 2 : 
          keyword$1 = "Variant";
          break;
      
    }
    var univs = Declareops$ReactTemplate.inductive_is_polymorphic(mib$2) ? Util$ReactTemplate.$$Array[/* to_list */9](Univ$ReactTemplate.Instance[/* to_array */3](Univ$ReactTemplate.AUContext[/* instance */3](Declareops$ReactTemplate.inductive_polymorphic_context(mib$2)))) : /* [] */0;
    var bl$1 = Universes$ReactTemplate.universe_binders_with_opt_names(/* IndRef */Block.__(2, [/* tuple */[
              mind$2,
              0
            ]]), univs, udecl$2);
    var sigma$1 = Evd$ReactTemplate.from_ctx(UState$ReactTemplate.of_binders(bl$1));
    var s$1 = Pp$ReactTemplate.str(keyword$1);
    var match$3 = mib$2[/* mind_universes */8];
    var tmp$1;
    switch (match$3.tag | 0) {
      case 0 : 
      case 1 : 
          tmp$1 = Pp$ReactTemplate.str("");
          break;
      case 2 : 
          tmp$1 = Printer$ReactTemplate.pr_cumulativity_info(sigma$1, instantiate_cumulativity_info(match$3[0]));
          break;
      
    }
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_polymorphic(Declareops$ReactTemplate.inductive_is_polymorphic(mib$2)), Printer$ReactTemplate.pr_cumulative(Declareops$ReactTemplate.inductive_is_polymorphic(mib$2), Declareops$ReactTemplate.inductive_is_cumulative(mib$2))), Pp$ReactTemplate.tag(definition, s$1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str("  with "));
                            }), (function (param) {
                              var env$3 = env$2;
                              var sigma$2 = sigma$1;
                              var mib$3 = mib$2;
                              var ind = param;
                              var u = Declareops$ReactTemplate.inductive_is_polymorphic(mib$3) ? Univ$ReactTemplate.AUContext[/* instance */3](Declareops$ReactTemplate.inductive_polymorphic_context(mib$3)) : Univ$ReactTemplate.Instance[/* empty */0];
                              var mip = Caml_array.caml_array_get(mib$3[/* mind_packets */0], ind[1]);
                              var params = Inductive$ReactTemplate.inductive_paramdecls(/* tuple */[
                                    mib$3,
                                    u
                                  ]);
                              var nparamdecls = Curry._1(Context$ReactTemplate.Rel[/* length */3], params);
                              var args = Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, params);
                              var arity = Reduction$ReactTemplate.hnf_prod_applist_assum(env$3, nparamdecls, Inductive$ReactTemplate.type_of_inductive(env$3, /* tuple */[
                                        /* tuple */[
                                          mib$3,
                                          mip
                                        ],
                                        u
                                      ]), args);
                              var cstrtypes = Inductive$ReactTemplate.type_of_constructors(/* tuple */[
                                    ind,
                                    u
                                  ], /* tuple */[
                                    mib$3,
                                    mip
                                  ]);
                              var cstrtypes$1 = Util$ReactTemplate.$$Array[/* map */12]((function (c) {
                                      return Reduction$ReactTemplate.hnf_prod_applist_assum(env$3, nparamdecls, c, args);
                                    }), cstrtypes);
                              var envpar = Environ$ReactTemplate.push_rel_context(params, env$3);
                              var inst;
                              if (Declareops$ReactTemplate.inductive_is_polymorphic(mib$3)) {
                                var ctx = Declareops$ReactTemplate.inductive_polymorphic_context(mib$3);
                                var ctx$1 = Univ$ReactTemplate.UContext[/* make */0](/* tuple */[
                                      u,
                                      Univ$ReactTemplate.AUContext[/* instantiate */6](u, ctx)
                                    ]);
                                inst = Printer$ReactTemplate.pr_universe_instance(sigma$2, ctx$1);
                              } else {
                                inst = Pp$ReactTemplate.mt(/* () */0);
                              }
                              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](mip[/* mind_typename */0]), inst), Pp$ReactTemplate.brk(/* tuple */[
                                                                          1,
                                                                          4
                                                                        ])), print_params(env$3, sigma$2, params)), Pp$ReactTemplate.str(": ")), Printer$ReactTemplate.pr_lconstr_env(envpar, sigma$2, arity)), Pp$ReactTemplate.str(" :="))), Pp$ReactTemplate.brk(/* tuple */[
                                                  0,
                                                  2
                                                ])), print_constructors(envpar, sigma$2, mip[/* mind_consnames */3], cstrtypes$1));
                            }), inds)), tmp$1));
  }
}

function print_local_modpath(locals, param) {
  switch (param.tag | 0) {
    case 0 : 
        throw Caml_builtin_exceptions.not_found;
    case 1 : 
        return Names$ReactTemplate.Id[/* print */8](Curry._3(Util$ReactTemplate.List[/* assoc_f */125], Names$ReactTemplate.MBId[/* equal */0], param[0], locals));
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(print_local_modpath(locals, param[0]), Pp$ReactTemplate.str(".")), Names$ReactTemplate.Label[/* print */7](param[1]));
    
  }
}

function print_modpath(locals, mp) {
  try {
    return Libnames$ReactTemplate.pr_qualid(Nametab$ReactTemplate.shortest_qualid_of_module(mp));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return print_local_modpath(locals, mp);
    } else {
      throw exn;
    }
  }
}

function print_kn(locals, kn) {
  try {
    return Libnames$ReactTemplate.pr_qualid(Nametab$ReactTemplate.shortest_qualid_of_modtype(kn));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      try {
        return print_local_modpath(locals, kn);
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          return print_modpath(locals, kn);
        } else {
          throw exn$1;
        }
      }
    } else {
      throw exn;
    }
  }
}

function nametab_register_dir(obj_mp) {
  var id = mk_fake_top(/* () */0);
  var obj_dir = Names$ReactTemplate.DirPath[/* make */3](/* :: */[
        id,
        /* [] */0
      ]);
  return Nametab$ReactTemplate.push_dir(/* Until */Block.__(0, [1]), obj_dir, /* DirModule */Block.__(3, [/* record */[
                  /* obj_dir */obj_dir,
                  /* obj_mp */obj_mp,
                  /* obj_sec */Names$ReactTemplate.DirPath[/* empty */5]
                ]]));
}

function nametab_register_body(mp, dir, param) {
  var body = param[1];
  var l = param[0];
  var push = function (id, ref) {
    return Nametab$ReactTemplate.push(/* Until */Block.__(0, [1 + Curry._1(Util$ReactTemplate.List[/* length */0], Names$ReactTemplate.DirPath[/* repr */4](dir)) | 0]), Libnames$ReactTemplate.make_path(dir, id), ref);
  };
  switch (body.tag | 0) {
    case 0 : 
        return push(Names$ReactTemplate.Label[/* to_id */6](l), /* ConstRef */Block.__(1, [Names$ReactTemplate.Constant[/* make2 */2](mp, l)]));
    case 1 : 
        var mind = Names$ReactTemplate.MutInd[/* make2 */2](mp, l);
        return Util$ReactTemplate.$$Array[/* iteri */13]((function (i, mip) {
                      push(mip[/* mind_typename */0], /* IndRef */Block.__(2, [/* tuple */[
                                mind,
                                i
                              ]]));
                      return Util$ReactTemplate.$$Array[/* iteri */13]((function (j, id) {
                                    return push(id, /* ConstructRef */Block.__(3, [/* tuple */[
                                                    /* tuple */[
                                                      mind,
                                                      i
                                                    ],
                                                    j + 1 | 0
                                                  ]]));
                                  }), mip[/* mind_consnames */3]);
                    }), body[0][/* mind_packets */0]);
    case 2 : 
    case 3 : 
        return /* () */0;
    
  }
}

function nametab_register_module_body(mp, struc) {
  nametab_register_dir(mp);
  var partial_arg = Names$ReactTemplate.DirPath[/* empty */5];
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return nametab_register_body(mp, partial_arg, param);
              }), struc);
}

function get_typ_expr_alg(mtb) {
  var match = mtb[/* mod_type_alg */3];
  if (match) {
    var match$1 = match[0];
    if (match$1.tag) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      return match$1[0];
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function nametab_register_modparam(mbid, mtb) {
  var id = Names$ReactTemplate.MBId[/* to_id */5](mbid);
  var match = mtb[/* mod_type */2];
  if (match.tag) {
    return id;
  } else {
    try {
      Declaremods$ReactTemplate.process_module_binding(mbid, get_typ_expr_alg(mtb));
      return id;
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (CErrors$ReactTemplate.noncritical(e)) {
        var mp = /* MPbound */Block.__(1, [mbid]);
        var check = function (id) {
          return Nametab$ReactTemplate.exists_dir(Names$ReactTemplate.DirPath[/* make */3](/* :: */[
                          id,
                          /* [] */0
                        ]));
        };
        var id$1 = Namegen$ReactTemplate.next_ident_away_from(id, check);
        var dir = Names$ReactTemplate.DirPath[/* make */3](/* :: */[
              id$1,
              /* [] */0
            ]);
        nametab_register_dir(mp);
        Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return nametab_register_body(mp, dir, param);
              }), match[0]);
        return id$1;
      } else {
        throw e;
      }
    }
  }
}

function print_struct(is_impl, env, mp, struc) {
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                var is_impl$1 = is_impl;
                var env$1 = env;
                var mp$1 = mp;
                var param$1 = param;
                var body = param$1[1];
                var l = param$1[0];
                var name = Names$ReactTemplate.Label[/* print */7](l);
                var tmp;
                switch (body.tag | 0) {
                  case 0 : 
                      var cb = body[0];
                      var ctx = Declareops$ReactTemplate.constant_polymorphic_context(cb);
                      var u = Declareops$ReactTemplate.constant_is_polymorphic(cb) ? Univ$ReactTemplate.AUContext[/* instance */3](ctx) : Univ$ReactTemplate.Instance[/* empty */0];
                      var ctx$1 = Univ$ReactTemplate.UContext[/* make */0](/* tuple */[
                            u,
                            Univ$ReactTemplate.AUContext[/* instantiate */6](u, ctx)
                          ]);
                      var match = cb[/* const_body */1];
                      var tmp$1;
                      switch (match.tag | 0) {
                        case 0 : 
                            var s = Pp$ReactTemplate.str("Parameter");
                            tmp$1 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(definition, s), Pp$ReactTemplate.spc(/* () */0));
                            break;
                        case 1 : 
                            var s$1 = Pp$ReactTemplate.str("Definition");
                            tmp$1 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(definition, s$1), Pp$ReactTemplate.spc(/* () */0));
                            break;
                        case 2 : 
                            if (is_impl$1) {
                              var s$2 = Pp$ReactTemplate.str("Theorem");
                              tmp$1 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(definition, s$2), Pp$ReactTemplate.spc(/* () */0));
                            } else {
                              var s$3 = Pp$ReactTemplate.str("Parameter");
                              tmp$1 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(definition, s$3), Pp$ReactTemplate.spc(/* () */0));
                            }
                            break;
                        
                      }
                      var tmp$2;
                      if (env$1) {
                        var env$2 = env$1[0];
                        var match$1 = cb[/* const_body */1];
                        var tmp$3;
                        switch (match$1.tag | 0) {
                          case 1 : 
                              tmp$3 = is_impl$1 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":= "), Printer$ReactTemplate.pr_lconstr_env(env$2, Evd$ReactTemplate.empty, Vars$ReactTemplate.subst_instance_constr(u, Mod_subst$ReactTemplate.force_constr(match$1[0])))))) : Pp$ReactTemplate.mt(/* () */0);
                              break;
                          case 0 : 
                          case 2 : 
                              tmp$3 = Pp$ReactTemplate.mt(/* () */0);
                              break;
                          
                        }
                        tmp$2 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" :"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Printer$ReactTemplate.pr_ltype_env(env$2, Evd$ReactTemplate.empty, Vars$ReactTemplate.subst_instance_constr(u, cb[/* const_type */2])))), tmp$3), Pp$ReactTemplate.str(".")), Printer$ReactTemplate.pr_universe_ctx(Evd$ReactTemplate.empty, /* None */0, ctx$1));
                      } else {
                        tmp$2 = Pp$ReactTemplate.mt(/* () */0);
                      }
                      tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(tmp$1, name), tmp$2);
                      break;
                  case 1 : 
                      var mib = body[0];
                      try {
                        var env$3 = Option$ReactTemplate.get(env$1);
                        tmp = pr_mutual_inductive_body(env$3, Names$ReactTemplate.MutInd[/* make2 */2](mp$1, l), mib, /* None */0);
                      }
                      catch (raw_e){
                        var e = Js_exn.internalToOCamlException(raw_e);
                        if (CErrors$ReactTemplate.noncritical(e)) {
                          var match$2 = mib[/* mind_finite */2];
                          var keyword$1;
                          switch (match$2) {
                            case 0 : 
                                var s$4 = Pp$ReactTemplate.str("Inductive");
                                keyword$1 = Pp$ReactTemplate.tag(definition, s$4);
                                break;
                            case 1 : 
                                var s$5 = Pp$ReactTemplate.str("CoInductive");
                                keyword$1 = Pp$ReactTemplate.tag(definition, s$5);
                                break;
                            case 2 : 
                                var s$6 = Pp$ReactTemplate.str("Variant");
                                keyword$1 = Pp$ReactTemplate.tag(definition, s$6);
                                break;
                            
                          }
                          tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(keyword$1, Pp$ReactTemplate.spc(/* () */0)), name);
                        } else {
                          throw e;
                        }
                      }
                      break;
                  case 2 : 
                      var s$7 = Pp$ReactTemplate.str("Module");
                      tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$7), Pp$ReactTemplate.spc(/* () */0)), name);
                      break;
                  case 3 : 
                      var s$8 = Pp$ReactTemplate.str("Module Type");
                      tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$8), Pp$ReactTemplate.spc(/* () */0)), name);
                      break;
                  
                }
                return Pp$ReactTemplate.hov(2, tmp);
              }), struc);
}

function print_structure(is_type, env, mp, _, struc) {
  var env$prime = Option$ReactTemplate.map((function (param) {
          return Modops$ReactTemplate.add_structure(mp, struc, Mod_subst$ReactTemplate.empty_delta_resolver, param);
        }), env);
  nametab_register_module_body(mp, struc);
  var kwd = is_type ? "Sig" : "Struct";
  var s = Pp$ReactTemplate.str(kwd);
  var s$1 = Pp$ReactTemplate.str("End");
  return Pp$ReactTemplate.hv(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s), Pp$ReactTemplate.spc(/* () */0)), print_struct(/* false */0, env$prime, mp, struc)), Pp$ReactTemplate.brk(/* tuple */[
                          1,
                          -2
                        ])), Pp$ReactTemplate.tag(keyword, s$1)));
}

function flatten_app(_mexpr, _l) {
  while(true) {
    var l = _l;
    var mexpr = _mexpr;
    switch (mexpr.tag | 0) {
      case 0 : 
          return /* :: */[
                  mexpr[0],
                  l
                ];
      case 1 : 
          _l = /* :: */[
            mexpr[1],
            l
          ];
          _mexpr = mexpr[0];
          continue ;
          case 2 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "printmod.ml",
                  376,
                  16
                ]
              ];
      
    }
  };
}

function print_typ_expr(env, mp, locals, mty) {
  switch (mty.tag | 0) {
    case 0 : 
        return print_kn(locals, mty[0]);
    case 1 : 
        var lapp = flatten_app(mty, /* [] */0);
        var fapp = Curry._1(Util$ReactTemplate.List[/* hd */1], lapp);
        var mapp = Curry._1(Util$ReactTemplate.List[/* tl */2], lapp);
        return Pp$ReactTemplate.hov(3, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), print_kn(locals, fapp)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                                  return print_modpath(locals, param);
                                }), mapp)), Pp$ReactTemplate.str(")")));
    case 2 : 
        var match = mty[1];
        var me = mty[0];
        if (match.tag) {
          var s = Curry._2(Util$ReactTemplate.$$String[/* concat */6], ".", Curry._2(Util$ReactTemplate.List[/* map */10], Names$ReactTemplate.Id[/* to_string */7], match[0]));
          var env$1 = Global$ReactTemplate.env(/* () */0);
          var s$1 = Pp$ReactTemplate.str("Definition");
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(print_typ_expr(/* None */0, mp, locals, me), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.tag(definition, s$1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":=")), Pp$ReactTemplate.spc(/* () */0)), Printer$ReactTemplate.pr_lconstr_env(env$1, Evd$ReactTemplate.empty, match[1][0])));
        } else {
          var s$2 = Curry._2(Util$ReactTemplate.$$String[/* concat */6], ".", Curry._2(Util$ReactTemplate.List[/* map */10], Names$ReactTemplate.Id[/* to_string */7], match[0]));
          var s$3 = Pp$ReactTemplate.str("Module");
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(print_typ_expr(env, mp, locals, me), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.tag(keyword, s$3)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(s$2)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":=")), Pp$ReactTemplate.spc(/* () */0)), print_modpath(locals, match[1])));
        }
        break;
    
  }
}

function print_mod_expr(_, _$1, locals, me) {
  switch (me.tag | 0) {
    case 0 : 
        return print_modpath(locals, me[0]);
    case 1 : 
        var lapp = flatten_app(me, /* [] */0);
        return Pp$ReactTemplate.hov(3, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                                  return print_modpath(locals, param);
                                }), lapp)), Pp$ReactTemplate.str(")")));
    case 2 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "printmod.ml",
                408,
                16
              ]
            ];
    
  }
}

function print_functor(fty, fatom, is_type, env, mp, locals, param) {
  if (param.tag) {
    var mtb1 = param[1];
    var mbid = param[0];
    var id = nametab_register_modparam(mbid, mtb1);
    var mp1 = /* MPbound */Block.__(1, [mbid]);
    var pr_mtb1 = Curry._4(fty, env, mp1, locals, mtb1);
    var env$prime = Option$ReactTemplate.map((function (param) {
            return Modops$ReactTemplate.add_module_type(mp1, mtb1, param);
          }), env);
    var locals$prime_000 = /* tuple */[
      mbid,
      get_new_id(locals, Names$ReactTemplate.MBId[/* to_id */5](mbid))
    ];
    var locals$prime = /* :: */[
      locals$prime_000,
      locals
    ];
    var kwd = is_type ? "Funsig" : "Functor";
    var s = Pp$ReactTemplate.str(kwd);
    return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("(")), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(":")), pr_mtb1), Pp$ReactTemplate.str(")")), Pp$ReactTemplate.spc(/* () */0)), print_functor(fty, fatom, is_type, env$prime, mp, locals$prime, param[2])));
  } else {
    return Curry._5(fatom, is_type, env, mp, locals, param[0]);
  }
}

function print_expression(x) {
  return (function (param, param$1, param$2, param$3) {
      return print_functor(print_modtype, (function (param) {
                    if (param !== 0) {
                      return print_typ_expr;
                    } else {
                      return print_mod_expr;
                    }
                  }), x, param, param$1, param$2, param$3);
    });
}

function print_modtype(env, mp, locals, mtb) {
  var match = mtb[/* mod_type_alg */3];
  if (match) {
    return print_expression(/* true */1)(env, mp, locals, match[0]);
  } else {
    return print_functor(print_modtype, print_structure, /* true */1, env, mp, locals, mtb[/* mod_type */2]);
  }
}

function printable_body(dir) {
  var dir$1 = Libnames$ReactTemplate.pop_dirpath(dir);
  if (Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], dir$1)) {
    return /* true */1;
  } else {
    try {
      var match = Nametab$ReactTemplate.locate_dir(Libnames$ReactTemplate.qualid_of_dirpath(dir$1));
      switch (match.tag | 0) {
        case 1 : 
            return /* false */0;
        case 0 : 
        case 3 : 
            return printable_body(dir$1);
        case 2 : 
        case 4 : 
            return /* true */1;
        
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* true */1;
      } else {
        throw exn;
      }
    }
  }
}

function print_expression$prime(is_type, env, mp, me) {
  return States$ReactTemplate.with_state_protection((function (e) {
                return print_expression(is_type)(env, mp, /* [] */0, e);
              }), me);
}

function print_signature$prime(is_type, env, mp, me) {
  return States$ReactTemplate.with_state_protection((function (e) {
                return print_functor(print_modtype, print_structure, is_type, env, mp, /* [] */0, e);
              }), me);
}

function unsafe_print_module(env, mp, with_body, mb) {
  var name = print_modpath(/* [] */0, mp);
  var pr_equals = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str(":= "));
  var match = mb[/* mod_expr */1];
  var body;
  var exit = 0;
  if (with_body !== 0 && !(typeof match === "number" && match === 0)) {
    exit = 1;
  } else {
    body = Pp$ReactTemplate.mt(/* () */0);
  }
  if (exit === 1) {
    body = typeof match === "number" ? Pp$ReactTemplate.$plus$plus(pr_equals, print_signature$prime(/* false */0, env, mp, mb[/* mod_type */2])) : (
        match.tag ? Pp$ReactTemplate.$plus$plus(pr_equals, print_signature$prime(/* false */0, env, mp, match[0])) : Pp$ReactTemplate.$plus$plus(pr_equals, print_expression$prime(/* false */0, env, mp, match[0]))
      );
  }
  var match$1 = mb[/* mod_expr */1];
  var match$2 = mb[/* mod_type_alg */3];
  var modtype;
  var exit$1 = 0;
  if (typeof match$1 === "number" && match$1 !== 0) {
    modtype = Pp$ReactTemplate.mt(/* () */0);
  } else {
    exit$1 = 1;
  }
  if (exit$1 === 1) {
    modtype = match$2 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.brk(/* tuple */[
                    1,
                    1
                  ]), Pp$ReactTemplate.str(": ")), print_expression$prime(/* true */1, env, mp, match$2[0])) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.brk(/* tuple */[
                    1,
                    1
                  ]), Pp$ReactTemplate.str(": ")), print_signature$prime(/* true */1, env, mp, mb[/* mod_type */2]));
  }
  var s = Pp$ReactTemplate.str("Module");
  return Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s), Pp$ReactTemplate.spc(/* () */0)), name), modtype), body));
}

var ShortPrinting = Caml_exceptions.create("Printmod-ReactTemplate.ShortPrinting");

function print_module(with_body, mp) {
  var me = Global$ReactTemplate.lookup_module(mp);
  try {
    if ($$short[0]) {
      throw ShortPrinting;
    }
    return Pp$ReactTemplate.$plus$plus(unsafe_print_module(/* Some */[Global$ReactTemplate.env(/* () */0)], mp, with_body, me), Pp$ReactTemplate.fnl(/* () */0));
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      return Pp$ReactTemplate.$plus$plus(unsafe_print_module(/* None */0, mp, with_body, me), Pp$ReactTemplate.fnl(/* () */0));
    } else {
      throw e;
    }
  }
}

function print_modtype$1(kn) {
  var mtb = Global$ReactTemplate.lookup_modtype(kn);
  var name = print_kn(/* [] */0, kn);
  var s = Pp$ReactTemplate.str("Module Type");
  var tmp;
  try {
    if ($$short[0]) {
      throw ShortPrinting;
    }
    tmp = print_signature$prime(/* true */1, /* Some */[Global$ReactTemplate.env(/* () */0)], kn, mtb[/* mod_type */2]);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      tmp = print_signature$prime(/* true */1, /* None */0, kn, mtb[/* mod_type */2]);
    } else {
      throw e;
    }
  }
  return Pp$ReactTemplate.hv(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s), Pp$ReactTemplate.spc(/* () */0)), name), Pp$ReactTemplate.str(" =")), Pp$ReactTemplate.spc(/* () */0)), tmp));
}

exports.printable_body = printable_body;
exports.pr_mutual_inductive_body = pr_mutual_inductive_body;
exports.print_module = print_module;
exports.print_modtype = print_modtype$1;
/*  Not a pure module */
