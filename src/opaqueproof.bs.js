// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");

var empty_opaquetab_000 = /* opaque_val */Int$ReactTemplate.$$Map[/* empty */0];

var empty_opaquetab_002 = /* opaque_dir */Names$ReactTemplate.DirPath[/* initial */8];

var empty_opaquetab = /* record */[
  empty_opaquetab_000,
  /* opaque_len */0,
  empty_opaquetab_002
];

function default_get_opaque(dp, _) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.pr_sequence(Pp$ReactTemplate.str, /* :: */[
                  "Cannot access opaque proofs in library",
                  /* :: */[
                    Names$ReactTemplate.DirPath[/* to_string */7](dp),
                    /* [] */0
                  ]
                ]));
}

function default_get_univ(dp, _) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.pr_sequence(Pp$ReactTemplate.str, /* :: */[
                  "Cannot access universe constraints of opaque proofs in library ",
                  /* :: */[
                    Names$ReactTemplate.DirPath[/* to_string */7](dp),
                    /* [] */0
                  ]
                ]));
}

var get_opaque = [default_get_opaque];

var get_univ = [default_get_univ];

function set_indirect_opaque_accessor(f) {
  get_opaque[0] = f;
  return /* () */0;
}

function set_indirect_univ_accessor(f) {
  get_univ[0] = f;
  return /* () */0;
}

function create(cu) {
  return /* Direct */Block.__(1, [
            /* [] */0,
            cu
          ]);
}

function turn_indirect(dp, o, tab) {
  if (o.tag) {
    var id = tab[/* opaque_len */1];
    var opaque_val = Curry._3(Int$ReactTemplate.$$Map[/* add */3], id, /* tuple */[
          o[0],
          o[1]
        ], tab[/* opaque_val */0]);
    var opaque_dir = Curry._2(Names$ReactTemplate.DirPath[/* equal */0], dp, tab[/* opaque_dir */2]) ? tab[/* opaque_dir */2] : (
        Curry._2(Names$ReactTemplate.DirPath[/* equal */0], tab[/* opaque_dir */2], Names$ReactTemplate.DirPath[/* initial */8]) ? dp : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Using the same opaque table for multiple dirpaths."))
      );
    var ntab_001 = /* opaque_len */id + 1 | 0;
    var ntab = /* record */[
      /* opaque_val */opaque_val,
      ntab_001,
      /* opaque_dir */opaque_dir
    ];
    return /* tuple */[
            /* Indirect */Block.__(0, [
                /* [] */0,
                dp,
                id
              ]),
            ntab
          ];
  } else if (Curry._2(Int$ReactTemplate.$$Map[/* mem */2], o[2], tab[/* opaque_val */0])) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Already an indirect opaque."));
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Indirect in a different table."));
  }
}

function subst_opaque(sub, param) {
  if (param.tag) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Substituting a Direct opaque."));
  } else {
    return /* Indirect */Block.__(0, [
              /* :: */[
                sub,
                param[0]
              ],
              param[1],
              param[2]
            ]);
  }
}

function iter_direct_opaque(f, param) {
  if (param.tag) {
    return /* Direct */Block.__(1, [
              param[0],
              Future$ReactTemplate.chain(param[1], (function (param) {
                      var c = param[0];
                      Curry._1(f, c);
                      return /* tuple */[
                              c,
                              param[1]
                            ];
                    }))
            ]);
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not a direct opaque."));
  }
}

function discharge_direct_opaque(cook_constr, ci, param) {
  if (param.tag) {
    return /* Direct */Block.__(1, [
              /* :: */[
                ci,
                param[0]
              ],
              Future$ReactTemplate.chain(param[1], (function (param) {
                      return /* tuple */[
                              Curry._1(cook_constr, param[0]),
                              param[1]
                            ];
                    }))
            ]);
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not a direct opaque."));
  }
}

function join_opaque(param, param$1) {
  if (param$1.tag) {
    Future$ReactTemplate.join(param$1[1]);
    return /* () */0;
  } else if (Curry._2(Names$ReactTemplate.DirPath[/* equal */0], param$1[1], param[/* opaque_dir */2])) {
    var fp = Int$ReactTemplate.$$Map[/* find */21](param$1[2], param[/* opaque_val */0])[1];
    Future$ReactTemplate.join(fp);
    return /* () */0;
  } else {
    return 0;
  }
}

function uuid_opaque(param, param$1) {
  if (param$1.tag) {
    return /* Some */[Future$ReactTemplate.uuid(param$1[1])];
  } else if (Curry._2(Names$ReactTemplate.DirPath[/* equal */0], param$1[1], param[/* opaque_dir */2])) {
    return /* Some */[Future$ReactTemplate.uuid(Int$ReactTemplate.$$Map[/* find */21](param$1[2], param[/* opaque_val */0])[1])];
  } else {
    return /* None */0;
  }
}

function force_proof(param, param$1) {
  if (param$1.tag) {
    return Future$ReactTemplate.force(param$1[1])[0];
  } else {
    var i = param$1[2];
    var dp = param$1[1];
    var pt = Curry._2(Names$ReactTemplate.DirPath[/* equal */0], dp, param[/* opaque_dir */2]) ? Future$ReactTemplate.chain(Int$ReactTemplate.$$Map[/* find */21](i, param[/* opaque_val */0])[1], (function (prim) {
              return prim[0];
            })) : Curry._2(get_opaque[0], dp, i);
    var c = Future$ReactTemplate.force(pt);
    return Mod_subst$ReactTemplate.force_constr(List.fold_right(Mod_subst$ReactTemplate.subst_substituted, param$1[0], Mod_subst$ReactTemplate.from_val(c)));
  }
}

function force_constraints(param, param$1) {
  if (param$1.tag) {
    return Future$ReactTemplate.force(param$1[1])[1];
  } else {
    var i = param$1[2];
    var dp = param$1[1];
    if (Curry._2(Names$ReactTemplate.DirPath[/* equal */0], dp, param[/* opaque_dir */2])) {
      return Future$ReactTemplate.force(Int$ReactTemplate.$$Map[/* find */21](i, param[/* opaque_val */0])[1])[1];
    } else {
      var match = Curry._2(get_univ[0], dp, i);
      if (match) {
        return Future$ReactTemplate.force(match[0]);
      } else {
        return Univ$ReactTemplate.ContextSet[/* empty */0];
      }
    }
  }
}

function get_constraints(param, param$1) {
  if (param$1.tag) {
    return /* Some */[Future$ReactTemplate.chain(param$1[1], (function (prim) {
                    return prim[1];
                  }))];
  } else {
    var i = param$1[2];
    var dp = param$1[1];
    if (Curry._2(Names$ReactTemplate.DirPath[/* equal */0], dp, param[/* opaque_dir */2])) {
      return /* Some */[Future$ReactTemplate.chain(Int$ReactTemplate.$$Map[/* find */21](i, param[/* opaque_val */0])[1], (function (prim) {
                      return prim[1];
                    }))];
    } else {
      return Curry._2(get_univ[0], dp, i);
    }
  }
}

function get_proof(param, param$1) {
  if (param$1.tag) {
    return Future$ReactTemplate.chain(param$1[1], (function (prim) {
                  return prim[0];
                }));
  } else {
    var i = param$1[2];
    var dp = param$1[1];
    var l = param$1[0];
    var pt = Curry._2(Names$ReactTemplate.DirPath[/* equal */0], dp, param[/* opaque_dir */2]) ? Future$ReactTemplate.chain(Int$ReactTemplate.$$Map[/* find */21](i, param[/* opaque_val */0])[1], (function (prim) {
              return prim[0];
            })) : Curry._2(get_opaque[0], dp, i);
    return Future$ReactTemplate.chain(pt, (function (c) {
                  return Mod_subst$ReactTemplate.force_constr(List.fold_right(Mod_subst$ReactTemplate.subst_substituted, l, Mod_subst$ReactTemplate.from_val(c)));
                }));
  }
}

var a_constr = Future$ReactTemplate.from_val(/* None */0, Constr$ReactTemplate.mkRel(1));

var a_univ = Future$ReactTemplate.from_val(/* None */0, Univ$ReactTemplate.ContextSet[/* empty */0]);

function dump(param) {
  var n = param[/* opaque_len */1];
  var opaque_table = Caml_array.caml_make_vect(n, a_constr);
  var univ_table = Caml_array.caml_make_vect(n, a_univ);
  var disch_table = Caml_array.caml_make_vect(n, /* [] */0);
  var f2t_map = [Future$ReactTemplate.UUIDMap[/* empty */0]];
  Curry._2(Int$ReactTemplate.$$Map[/* iter */9], (function (n, param) {
          var cu = param[1];
          var match = Future$ReactTemplate.split2(cu);
          var u = match[1];
          var c = match[0];
          Future$ReactTemplate.sink(u);
          Future$ReactTemplate.sink(c);
          Caml_array.caml_array_set(opaque_table, n, c);
          Caml_array.caml_array_set(univ_table, n, u);
          Caml_array.caml_array_set(disch_table, n, param[0]);
          f2t_map[0] = Curry._3(Future$ReactTemplate.UUIDMap[/* add */3], Future$ReactTemplate.uuid(cu), n, f2t_map[0]);
          return /* () */0;
        }), param[/* opaque_val */0]);
  return /* tuple */[
          opaque_table,
          univ_table,
          disch_table,
          f2t_map[0]
        ];
}

exports.empty_opaquetab = empty_opaquetab;
exports.create = create;
exports.turn_indirect = turn_indirect;
exports.force_proof = force_proof;
exports.force_constraints = force_constraints;
exports.get_proof = get_proof;
exports.get_constraints = get_constraints;
exports.subst_opaque = subst_opaque;
exports.iter_direct_opaque = iter_direct_opaque;
exports.discharge_direct_opaque = discharge_direct_opaque;
exports.uuid_opaque = uuid_opaque;
exports.join_opaque = join_opaque;
exports.dump = dump;
exports.set_indirect_opaque_accessor = set_indirect_opaque_accessor;
exports.set_indirect_univ_accessor = set_indirect_univ_accessor;
/* a_constr Not a pure module */
