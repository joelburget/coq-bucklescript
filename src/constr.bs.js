// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Int$ReactTemplate = require("./int.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var UGraph$ReactTemplate = require("./uGraph.bs.js");
var Hashset$ReactTemplate = require("./hashset.bs.js");
var Hashcons$ReactTemplate = require("./hashcons.bs.js");

var rels = /* array */[
  /* Rel */Block.__(0, [1]),
  /* Rel */Block.__(0, [2]),
  /* Rel */Block.__(0, [3]),
  /* Rel */Block.__(0, [4]),
  /* Rel */Block.__(0, [5]),
  /* Rel */Block.__(0, [6]),
  /* Rel */Block.__(0, [7]),
  /* Rel */Block.__(0, [8]),
  /* Rel */Block.__(0, [9]),
  /* Rel */Block.__(0, [10]),
  /* Rel */Block.__(0, [11]),
  /* Rel */Block.__(0, [12]),
  /* Rel */Block.__(0, [13]),
  /* Rel */Block.__(0, [14]),
  /* Rel */Block.__(0, [15]),
  /* Rel */Block.__(0, [16])
];

function mkRel(n) {
  if (0 < n && n <= 16) {
    return Caml_array.caml_array_get(rels, n - 1 | 0);
  } else {
    return /* Rel */Block.__(0, [n]);
  }
}

var mkProp = /* Sort */Block.__(4, [Sorts$ReactTemplate.prop]);

var mkSet = /* Sort */Block.__(4, [Sorts$ReactTemplate.set]);

function mkType(u) {
  return /* Sort */Block.__(4, [/* Type */Block.__(1, [u])]);
}

function mkSort(s) {
  if (s.tag) {
    return /* Sort */Block.__(4, [s]);
  } else if (s[0] !== 0) {
    return mkProp;
  } else {
    return mkSet;
  }
}

function mkCast(param) {
  var t2 = param[2];
  var k2 = param[1];
  var t1 = param[0];
  if (t1.tag === 5) {
    var k1 = t1[1];
    if ((k1 === /* VMcast */0 || k1 === /* NATIVEcast */1) && k1 === k2) {
      return /* Cast */Block.__(5, [
                t1[0],
                k1,
                t2
              ]);
    } else {
      return /* Cast */Block.__(5, [
                t1,
                k2,
                t2
              ]);
    }
  } else {
    return /* Cast */Block.__(5, [
              t1,
              k2,
              t2
            ]);
  }
}

function mkProd(param) {
  return /* Prod */Block.__(6, [
            param[0],
            param[1],
            param[2]
          ]);
}

function mkLambda(param) {
  return /* Lambda */Block.__(7, [
            param[0],
            param[1],
            param[2]
          ]);
}

function mkLetIn(param) {
  return /* LetIn */Block.__(8, [
            param[0],
            param[1],
            param[2],
            param[3]
          ]);
}

function mkApp(param) {
  var a = param[1];
  var f = param[0];
  if (a.length) {
    if (f.tag === 9) {
      return /* App */Block.__(9, [
                f[0],
                Util$ReactTemplate.$$Array[/* append */3](f[1], a)
              ]);
    } else {
      return /* App */Block.__(9, [
                f,
                a
              ]);
    }
  } else {
    return f;
  }
}

function map_puniverses(f, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          param[1]
        ];
}

function mkConst(c) {
  return /* Const */Block.__(10, [/* tuple */[
              c,
              Univ$ReactTemplate.Instance[/* empty */0]
            ]]);
}

function mkConstU(c) {
  return /* Const */Block.__(10, [c]);
}

function mkProj(param) {
  return /* Proj */Block.__(16, [
            param[0],
            param[1]
          ]);
}

function mkEvar(e) {
  return /* Evar */Block.__(3, [e]);
}

function mkInd(m) {
  return /* Ind */Block.__(11, [/* tuple */[
              m,
              Univ$ReactTemplate.Instance[/* empty */0]
            ]]);
}

function mkIndU(m) {
  return /* Ind */Block.__(11, [m]);
}

function mkConstruct(c) {
  return /* Construct */Block.__(12, [/* tuple */[
              c,
              Univ$ReactTemplate.Instance[/* empty */0]
            ]]);
}

function mkConstructU(c) {
  return /* Construct */Block.__(12, [c]);
}

function mkConstructUi(param) {
  var match = param[0];
  return /* Construct */Block.__(12, [/* tuple */[
              /* tuple */[
                match[0],
                param[1]
              ],
              match[1]
            ]]);
}

function mkCase(param) {
  return /* Case */Block.__(13, [
            param[0],
            param[1],
            param[2],
            param[3]
          ]);
}

function mkFix(fix) {
  return /* Fix */Block.__(14, [fix]);
}

function mkCoFix(cofix) {
  return /* CoFix */Block.__(15, [cofix]);
}

function mkMeta(n) {
  return /* Meta */Block.__(2, [n]);
}

function mkVar(id) {
  return /* Var */Block.__(1, [id]);
}

function kind(c) {
  return c;
}

function of_kind(k) {
  switch (k.tag | 0) {
    case 5 : 
        return mkCast(/* tuple */[
                    k[0],
                    k[1],
                    k[2]
                  ]);
    case 9 : 
        return mkApp(/* tuple */[
                    k[0],
                    k[1]
                  ]);
    default:
      return k;
  }
}

var DestKO = Caml_exceptions.create("Constr-ReactTemplate.DestKO");

function isMeta(c) {
  if (c.tag === 2) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isSort(c) {
  if (c.tag === 4) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isprop(_c) {
  while(true) {
    var c = _c;
    switch (c.tag | 0) {
      case 4 : 
          if (c[0].tag) {
            return /* false */0;
          } else {
            return /* true */1;
          }
          break;
      case 5 : 
          _c = c[0];
          continue ;
          default:
        return /* false */0;
    }
  };
}

function is_Prop(_c) {
  while(true) {
    var c = _c;
    switch (c.tag | 0) {
      case 4 : 
          var match = c[0];
          if (!match.tag && match[0] !== 0) {
            return /* true */1;
          } else {
            return /* false */0;
          }
          break;
      case 5 : 
          _c = c[0];
          continue ;
          default:
        return /* false */0;
    }
  };
}

function is_Set(_c) {
  while(true) {
    var c = _c;
    switch (c.tag | 0) {
      case 4 : 
          var match = c[0];
          if (!match.tag && match[0] === 0) {
            return /* true */1;
          } else {
            return /* false */0;
          }
          break;
      case 5 : 
          _c = c[0];
          continue ;
          default:
        return /* false */0;
    }
  };
}

function is_Type(_c) {
  while(true) {
    var c = _c;
    switch (c.tag | 0) {
      case 4 : 
          if (c[0].tag) {
            return /* true */1;
          } else {
            return /* false */0;
          }
          break;
      case 5 : 
          _c = c[0];
          continue ;
          default:
        return /* false */0;
    }
  };
}

function iskind(c) {
  if (isprop(c)) {
    return /* true */1;
  } else {
    return is_Type(c);
  }
}

function isEvar(c) {
  if (c.tag === 3) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isEvar_or_Meta(c) {
  switch (c.tag | 0) {
    case 2 : 
    case 3 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function isCast(c) {
  if (c.tag === 5) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isRel(c) {
  if (c.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function isRelN(n, c) {
  if (c.tag) {
    return /* false */0;
  } else {
    return +(n === c[0]);
  }
}

function isVar(c) {
  if (c.tag === 1) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isVarId(id, c) {
  if (c.tag === 1) {
    return Names$ReactTemplate.Id[/* equal */0](id, c[0]);
  } else {
    return /* false */0;
  }
}

function isInd(c) {
  if (c.tag === 11) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isProd(c) {
  if (c.tag === 6) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isLambda(c) {
  if (c.tag === 7) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isLetIn(c) {
  if (c.tag === 8) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isApp(c) {
  if (c.tag === 9) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isConst(c) {
  if (c.tag === 10) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isConstruct(c) {
  if (c.tag === 12) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isCase(c) {
  if (c.tag === 13) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isProj(c) {
  if (c.tag === 16) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isFix(c) {
  if (c.tag === 14) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isCoFix(c) {
  if (c.tag === 15) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function destRel(c) {
  if (c.tag) {
    throw DestKO;
  } else {
    return c[0];
  }
}

function destMeta(c) {
  if (c.tag === 2) {
    return c[0];
  } else {
    throw DestKO;
  }
}

function destVar(c) {
  if (c.tag === 1) {
    return c[0];
  } else {
    throw DestKO;
  }
}

function destSort(c) {
  if (c.tag === 4) {
    return c[0];
  } else {
    throw DestKO;
  }
}

function destCast(c) {
  if (c.tag === 5) {
    return /* tuple */[
            c[0],
            c[1],
            c[2]
          ];
  } else {
    throw DestKO;
  }
}

function destProd(c) {
  if (c.tag === 6) {
    return /* tuple */[
            c[0],
            c[1],
            c[2]
          ];
  } else {
    throw DestKO;
  }
}

function destLambda(c) {
  if (c.tag === 7) {
    return /* tuple */[
            c[0],
            c[1],
            c[2]
          ];
  } else {
    throw DestKO;
  }
}

function destLetIn(c) {
  if (c.tag === 8) {
    return /* tuple */[
            c[0],
            c[1],
            c[2],
            c[3]
          ];
  } else {
    throw DestKO;
  }
}

function destApp(c) {
  if (c.tag === 9) {
    return /* tuple */[
            c[0],
            c[1]
          ];
  } else {
    throw DestKO;
  }
}

function destConst(c) {
  if (c.tag === 10) {
    return c[0];
  } else {
    throw DestKO;
  }
}

function destEvar(c) {
  if (c.tag === 3) {
    return c[0];
  } else {
    throw DestKO;
  }
}

function destInd(c) {
  if (c.tag === 11) {
    return c[0];
  } else {
    throw DestKO;
  }
}

function destConstruct(c) {
  if (c.tag === 12) {
    return c[0];
  } else {
    throw DestKO;
  }
}

function destCase(c) {
  if (c.tag === 13) {
    return /* tuple */[
            c[0],
            c[1],
            c[2],
            c[3]
          ];
  } else {
    throw DestKO;
  }
}

function destProj(c) {
  if (c.tag === 16) {
    return /* tuple */[
            c[0],
            c[1]
          ];
  } else {
    throw DestKO;
  }
}

function destFix(c) {
  if (c.tag === 14) {
    return c[0];
  } else {
    throw DestKO;
  }
}

function destCoFix(c) {
  if (c.tag === 15) {
    return c[0];
  } else {
    throw DestKO;
  }
}

function decompose_app(c) {
  if (c.tag === 9) {
    return /* tuple */[
            c[0],
            Util$ReactTemplate.$$Array[/* to_list */9](c[1])
          ];
  } else {
    return /* tuple */[
            c,
            /* [] */0
          ];
  }
}

function decompose_appvect(c) {
  if (c.tag === 9) {
    return /* tuple */[
            c[0],
            c[1]
          ];
  } else {
    return /* tuple */[
            c,
            /* array */[]
          ];
  }
}

function fold(f, acc, c) {
  var exit = 0;
  switch (c.tag | 0) {
    case 3 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](f, acc, c[0][1]);
    case 5 : 
        return Curry._2(f, Curry._2(f, acc, c[0]), c[2]);
    case 6 : 
    case 7 : 
        exit = 1;
        break;
    case 8 : 
        return Curry._2(f, Curry._2(f, Curry._2(f, acc, c[1]), c[2]), c[3]);
    case 9 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](f, Curry._2(f, acc, c[0]), c[1]);
    case 13 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](f, Curry._2(f, Curry._2(f, acc, c[1]), c[2]), c[3]);
    case 14 : 
        var match = c[0][1];
        return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (acc, t, b) {
                      return Curry._2(f, Curry._2(f, acc, t), b);
                    }), acc, match[1], match[2]);
    case 15 : 
        var match$1 = c[0][1];
        return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (acc, t, b) {
                      return Curry._2(f, Curry._2(f, acc, t), b);
                    }), acc, match$1[1], match$1[2]);
    case 16 : 
        return Curry._2(f, acc, c[1]);
    default:
      return acc;
  }
  if (exit === 1) {
    return Curry._2(f, Curry._2(f, acc, c[1]), c[2]);
  }
  
}

function iter(f, c) {
  var exit = 0;
  switch (c.tag | 0) {
    case 3 : 
        return Util$ReactTemplate.$$Array[/* iter */11](f, c[0][1]);
    case 5 : 
        Curry._1(f, c[0]);
        return Curry._1(f, c[2]);
    case 6 : 
    case 7 : 
        Curry._1(f, c[1]);
        return Curry._1(f, c[2]);
    case 8 : 
        Curry._1(f, c[1]);
        Curry._1(f, c[2]);
        return Curry._1(f, c[3]);
    case 9 : 
        Curry._1(f, c[0]);
        return Util$ReactTemplate.$$Array[/* iter */11](f, c[1]);
    case 13 : 
        Curry._1(f, c[1]);
        Curry._1(f, c[2]);
        return Util$ReactTemplate.$$Array[/* iter */11](f, c[3]);
    case 14 : 
    case 15 : 
        exit = 1;
        break;
    case 16 : 
        return Curry._1(f, c[1]);
    default:
      return /* () */0;
  }
  if (exit === 1) {
    var match = c[0][1];
    Util$ReactTemplate.$$Array[/* iter */11](f, match[1]);
    return Util$ReactTemplate.$$Array[/* iter */11](f, match[2]);
  }
  
}

function iter_with_binders(g, f, n, c) {
  var exit = 0;
  switch (c.tag | 0) {
    case 3 : 
        return CArray$ReactTemplate.Fun1[/* iter */2](f, n, c[0][1]);
    case 5 : 
        Curry._2(f, n, c[0]);
        return Curry._2(f, n, c[2]);
    case 6 : 
    case 7 : 
        exit = 1;
        break;
    case 8 : 
        Curry._2(f, n, c[1]);
        Curry._2(f, n, c[2]);
        return Curry._2(f, Curry._1(g, n), c[3]);
    case 9 : 
        Curry._2(f, n, c[0]);
        return CArray$ReactTemplate.Fun1[/* iter */2](f, n, c[1]);
    case 13 : 
        Curry._2(f, n, c[1]);
        Curry._2(f, n, c[2]);
        return CArray$ReactTemplate.Fun1[/* iter */2](f, n, c[3]);
    case 14 : 
        var match = c[0][1];
        var tl = match[1];
        CArray$ReactTemplate.Fun1[/* iter */2](f, n, tl);
        return CArray$ReactTemplate.Fun1[/* iter */2](f, Util$ReactTemplate.iterate(g, tl.length, n), match[2]);
    case 15 : 
        var match$1 = c[0][1];
        var tl$1 = match$1[1];
        CArray$ReactTemplate.Fun1[/* iter */2](f, n, tl$1);
        return CArray$ReactTemplate.Fun1[/* iter */2](f, Util$ReactTemplate.iterate(g, tl$1.length, n), match$1[2]);
    case 16 : 
        return Curry._2(f, n, c[1]);
    default:
      return /* () */0;
  }
  if (exit === 1) {
    Curry._2(f, n, c[1]);
    return Curry._2(f, Curry._1(g, n), c[2]);
  }
  
}

function map(f, c) {
  switch (c.tag | 0) {
    case 3 : 
        var match = c[0];
        var l = match[1];
        var l$prime = Util$ReactTemplate.$$Array[/* smartmap */47](f, l);
        if (l$prime === l) {
          return c;
        } else {
          return /* Evar */Block.__(3, [/* tuple */[
                      match[0],
                      l$prime
                    ]]);
        }
    case 5 : 
        var t = c[2];
        var b = c[0];
        var b$prime = Curry._1(f, b);
        var t$prime = Curry._1(f, t);
        if (b$prime === b && t$prime === t) {
          return c;
        } else {
          return mkCast(/* tuple */[
                      b$prime,
                      c[1],
                      t$prime
                    ]);
        }
    case 6 : 
        var b$1 = c[2];
        var t$1 = c[1];
        var b$prime$1 = Curry._1(f, b$1);
        var t$prime$1 = Curry._1(f, t$1);
        if (b$prime$1 === b$1 && t$prime$1 === t$1) {
          return c;
        } else {
          return mkProd(/* tuple */[
                      c[0],
                      t$prime$1,
                      b$prime$1
                    ]);
        }
    case 7 : 
        var b$2 = c[2];
        var t$2 = c[1];
        var b$prime$2 = Curry._1(f, b$2);
        var t$prime$2 = Curry._1(f, t$2);
        if (b$prime$2 === b$2 && t$prime$2 === t$2) {
          return c;
        } else {
          return mkLambda(/* tuple */[
                      c[0],
                      t$prime$2,
                      b$prime$2
                    ]);
        }
    case 8 : 
        var k = c[3];
        var t$3 = c[2];
        var b$3 = c[1];
        var b$prime$3 = Curry._1(f, b$3);
        var t$prime$3 = Curry._1(f, t$3);
        var k$prime = Curry._1(f, k);
        if (b$prime$3 === b$3 && t$prime$3 === t$3 && k$prime === k) {
          return c;
        } else {
          return mkLetIn(/* tuple */[
                      c[0],
                      b$prime$3,
                      t$prime$3,
                      k$prime
                    ]);
        }
    case 9 : 
        var l$1 = c[1];
        var b$4 = c[0];
        var b$prime$4 = Curry._1(f, b$4);
        var l$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](f, l$1);
        if (b$prime$4 === b$4 && l$prime$1 === l$1) {
          return c;
        } else {
          return mkApp(/* tuple */[
                      b$prime$4,
                      l$prime$1
                    ]);
        }
    case 13 : 
        var bl = c[3];
        var b$5 = c[2];
        var p = c[1];
        var b$prime$5 = Curry._1(f, b$5);
        var p$prime = Curry._1(f, p);
        var bl$prime = Util$ReactTemplate.$$Array[/* smartmap */47](f, bl);
        if (b$prime$5 === b$5 && p$prime === p && bl$prime === bl) {
          return c;
        } else {
          return mkCase(/* tuple */[
                      c[0],
                      p$prime,
                      b$prime$5,
                      bl$prime
                    ]);
        }
    case 14 : 
        var match$1 = c[0];
        var match$2 = match$1[1];
        var bl$1 = match$2[2];
        var tl = match$2[1];
        var tl$prime = Util$ReactTemplate.$$Array[/* smartmap */47](f, tl);
        var bl$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](f, bl$1);
        if (tl$prime === tl && bl$prime$1 === bl$1) {
          return c;
        } else {
          return /* Fix */Block.__(14, [/* tuple */[
                      match$1[0],
                      /* tuple */[
                        match$2[0],
                        tl$prime,
                        bl$prime$1
                      ]
                    ]]);
        }
    case 15 : 
        var match$3 = c[0];
        var match$4 = match$3[1];
        var bl$2 = match$4[2];
        var tl$1 = match$4[1];
        var tl$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](f, tl$1);
        var bl$prime$2 = Util$ReactTemplate.$$Array[/* smartmap */47](f, bl$2);
        if (tl$prime$1 === tl$1 && bl$prime$2 === bl$2) {
          return c;
        } else {
          return /* CoFix */Block.__(15, [/* tuple */[
                      match$3[0],
                      /* tuple */[
                        match$4[0],
                        tl$prime$1,
                        bl$prime$2
                      ]
                    ]]);
        }
    case 16 : 
        var t$4 = c[1];
        var t$prime$4 = Curry._1(f, t$4);
        if (t$prime$4 === t$4) {
          return c;
        } else {
          return mkProj(/* tuple */[
                      c[0],
                      t$prime$4
                    ]);
        }
    default:
      return c;
  }
}

function fold_map(f, accu, c) {
  switch (c.tag | 0) {
    case 3 : 
        var match = c[0];
        var l = match[1];
        var match$1 = Util$ReactTemplate.$$Array[/* smartfoldmap */48](f, accu, l);
        var l$prime = match$1[1];
        var accu$1 = match$1[0];
        if (l$prime === l) {
          return /* tuple */[
                  accu$1,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$1,
                  /* Evar */Block.__(3, [/* tuple */[
                        match[0],
                        l$prime
                      ]])
                ];
        }
    case 5 : 
        var t = c[2];
        var b = c[0];
        var match$2 = Curry._2(f, accu, b);
        var b$prime = match$2[1];
        var match$3 = Curry._2(f, match$2[0], t);
        var t$prime = match$3[1];
        var accu$2 = match$3[0];
        if (b$prime === b && t$prime === t) {
          return /* tuple */[
                  accu$2,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$2,
                  mkCast(/* tuple */[
                        b$prime,
                        c[1],
                        t$prime
                      ])
                ];
        }
    case 6 : 
        var b$1 = c[2];
        var t$1 = c[1];
        var match$4 = Curry._2(f, accu, b$1);
        var b$prime$1 = match$4[1];
        var match$5 = Curry._2(f, match$4[0], t$1);
        var t$prime$1 = match$5[1];
        var accu$3 = match$5[0];
        if (b$prime$1 === b$1 && t$prime$1 === t$1) {
          return /* tuple */[
                  accu$3,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$3,
                  mkProd(/* tuple */[
                        c[0],
                        t$prime$1,
                        b$prime$1
                      ])
                ];
        }
    case 7 : 
        var b$2 = c[2];
        var t$2 = c[1];
        var match$6 = Curry._2(f, accu, b$2);
        var b$prime$2 = match$6[1];
        var match$7 = Curry._2(f, match$6[0], t$2);
        var t$prime$2 = match$7[1];
        var accu$4 = match$7[0];
        if (b$prime$2 === b$2 && t$prime$2 === t$2) {
          return /* tuple */[
                  accu$4,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$4,
                  mkLambda(/* tuple */[
                        c[0],
                        t$prime$2,
                        b$prime$2
                      ])
                ];
        }
    case 8 : 
        var k = c[3];
        var t$3 = c[2];
        var b$3 = c[1];
        var match$8 = Curry._2(f, accu, b$3);
        var b$prime$3 = match$8[1];
        var match$9 = Curry._2(f, match$8[0], t$3);
        var t$prime$3 = match$9[1];
        var match$10 = Curry._2(f, match$9[0], k);
        var k$prime = match$10[1];
        var accu$5 = match$10[0];
        if (b$prime$3 === b$3 && t$prime$3 === t$3 && k$prime === k) {
          return /* tuple */[
                  accu$5,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$5,
                  mkLetIn(/* tuple */[
                        c[0],
                        b$prime$3,
                        t$prime$3,
                        k$prime
                      ])
                ];
        }
    case 9 : 
        var l$1 = c[1];
        var b$4 = c[0];
        var match$11 = Curry._2(f, accu, b$4);
        var b$prime$4 = match$11[1];
        var match$12 = Util$ReactTemplate.$$Array[/* smartfoldmap */48](f, match$11[0], l$1);
        var l$prime$1 = match$12[1];
        var accu$6 = match$12[0];
        if (b$prime$4 === b$4 && l$prime$1 === l$1) {
          return /* tuple */[
                  accu$6,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$6,
                  mkApp(/* tuple */[
                        b$prime$4,
                        l$prime$1
                      ])
                ];
        }
    case 13 : 
        var bl = c[3];
        var b$5 = c[2];
        var p = c[1];
        var match$13 = Curry._2(f, accu, b$5);
        var b$prime$5 = match$13[1];
        var match$14 = Curry._2(f, match$13[0], p);
        var p$prime = match$14[1];
        var match$15 = Util$ReactTemplate.$$Array[/* smartfoldmap */48](f, match$14[0], bl);
        var bl$prime = match$15[1];
        var accu$7 = match$15[0];
        if (b$prime$5 === b$5 && p$prime === p && bl$prime === bl) {
          return /* tuple */[
                  accu$7,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$7,
                  mkCase(/* tuple */[
                        c[0],
                        p$prime,
                        b$prime$5,
                        bl$prime
                      ])
                ];
        }
    case 14 : 
        var match$16 = c[0];
        var match$17 = match$16[1];
        var bl$1 = match$17[2];
        var tl = match$17[1];
        var match$18 = Util$ReactTemplate.$$Array[/* smartfoldmap */48](f, accu, tl);
        var tl$prime = match$18[1];
        var match$19 = Util$ReactTemplate.$$Array[/* smartfoldmap */48](f, match$18[0], bl$1);
        var bl$prime$1 = match$19[1];
        var accu$8 = match$19[0];
        if (tl$prime === tl && bl$prime$1 === bl$1) {
          return /* tuple */[
                  accu$8,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$8,
                  /* Fix */Block.__(14, [/* tuple */[
                        match$16[0],
                        /* tuple */[
                          match$17[0],
                          tl$prime,
                          bl$prime$1
                        ]
                      ]])
                ];
        }
    case 15 : 
        var match$20 = c[0];
        var match$21 = match$20[1];
        var bl$2 = match$21[2];
        var tl$1 = match$21[1];
        var match$22 = Util$ReactTemplate.$$Array[/* smartfoldmap */48](f, accu, tl$1);
        var tl$prime$1 = match$22[1];
        var match$23 = Util$ReactTemplate.$$Array[/* smartfoldmap */48](f, match$22[0], bl$2);
        var bl$prime$2 = match$23[1];
        var accu$9 = match$23[0];
        if (tl$prime$1 === tl$1 && bl$prime$2 === bl$2) {
          return /* tuple */[
                  accu$9,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$9,
                  /* CoFix */Block.__(15, [/* tuple */[
                        match$20[0],
                        /* tuple */[
                          match$21[0],
                          tl$prime$1,
                          bl$prime$2
                        ]
                      ]])
                ];
        }
    case 16 : 
        var t$4 = c[1];
        var match$24 = Curry._2(f, accu, t$4);
        var t$prime$4 = match$24[1];
        var accu$10 = match$24[0];
        if (t$prime$4 === t$4) {
          return /* tuple */[
                  accu$10,
                  c
                ];
        } else {
          return /* tuple */[
                  accu$10,
                  mkProj(/* tuple */[
                        c[0],
                        t$prime$4
                      ])
                ];
        }
    default:
      return /* tuple */[
              accu,
              c
            ];
  }
}

function map_with_binders(g, f, l, c0) {
  switch (c0.tag | 0) {
    case 3 : 
        var match = c0[0];
        var al = match[1];
        var al$prime = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, al);
        if (al$prime === al) {
          return c0;
        } else {
          return /* Evar */Block.__(3, [/* tuple */[
                      match[0],
                      al$prime
                    ]]);
        }
    case 5 : 
        var t = c0[2];
        var c = c0[0];
        var c$prime = Curry._2(f, l, c);
        var t$prime = Curry._2(f, l, t);
        if (c$prime === c && t$prime === t) {
          return c0;
        } else {
          return mkCast(/* tuple */[
                      c$prime,
                      c0[1],
                      t$prime
                    ]);
        }
    case 6 : 
        var c$1 = c0[2];
        var t$1 = c0[1];
        var t$prime$1 = Curry._2(f, l, t$1);
        var c$prime$1 = Curry._2(f, Curry._1(g, l), c$1);
        if (t$prime$1 === t$1 && c$prime$1 === c$1) {
          return c0;
        } else {
          return mkProd(/* tuple */[
                      c0[0],
                      t$prime$1,
                      c$prime$1
                    ]);
        }
    case 7 : 
        var c$2 = c0[2];
        var t$2 = c0[1];
        var t$prime$2 = Curry._2(f, l, t$2);
        var c$prime$2 = Curry._2(f, Curry._1(g, l), c$2);
        if (t$prime$2 === t$2 && c$prime$2 === c$2) {
          return c0;
        } else {
          return mkLambda(/* tuple */[
                      c0[0],
                      t$prime$2,
                      c$prime$2
                    ]);
        }
    case 8 : 
        var c$3 = c0[3];
        var t$3 = c0[2];
        var b = c0[1];
        var b$prime = Curry._2(f, l, b);
        var t$prime$3 = Curry._2(f, l, t$3);
        var c$prime$3 = Curry._2(f, Curry._1(g, l), c$3);
        if (b$prime === b && t$prime$3 === t$3 && c$prime$3 === c$3) {
          return c0;
        } else {
          return mkLetIn(/* tuple */[
                      c0[0],
                      b$prime,
                      t$prime$3,
                      c$prime$3
                    ]);
        }
    case 9 : 
        var al$1 = c0[1];
        var c$4 = c0[0];
        var c$prime$4 = Curry._2(f, l, c$4);
        var al$prime$1 = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, al$1);
        if (c$prime$4 === c$4 && al$prime$1 === al$1) {
          return c0;
        } else {
          return mkApp(/* tuple */[
                      c$prime$4,
                      al$prime$1
                    ]);
        }
    case 13 : 
        var bl = c0[3];
        var c$5 = c0[2];
        var p = c0[1];
        var p$prime = Curry._2(f, l, p);
        var c$prime$5 = Curry._2(f, l, c$5);
        var bl$prime = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, bl);
        if (p$prime === p && c$prime$5 === c$5 && bl$prime === bl) {
          return c0;
        } else {
          return mkCase(/* tuple */[
                      c0[0],
                      p$prime,
                      c$prime$5,
                      bl$prime
                    ]);
        }
    case 14 : 
        var match$1 = c0[0];
        var match$2 = match$1[1];
        var bl$1 = match$2[2];
        var tl = match$2[1];
        var tl$prime = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, tl);
        var l$prime = Util$ReactTemplate.iterate(g, tl.length, l);
        var bl$prime$1 = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l$prime, bl$1);
        if (tl$prime === tl && bl$prime$1 === bl$1) {
          return c0;
        } else {
          return /* Fix */Block.__(14, [/* tuple */[
                      match$1[0],
                      /* tuple */[
                        match$2[0],
                        tl$prime,
                        bl$prime$1
                      ]
                    ]]);
        }
    case 15 : 
        var match$3 = c0[0];
        var match$4 = match$3[1];
        var tl$1 = match$4[1];
        var tl$prime$1 = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l, tl$1);
        var l$prime$1 = Util$ReactTemplate.iterate(g, tl$1.length, l);
        var bl$prime$2 = CArray$ReactTemplate.Fun1[/* smartmap */1](f, l$prime$1, match$4[2]);
        return /* CoFix */Block.__(15, [/* tuple */[
                    match$3[0],
                    /* tuple */[
                      match$4[0],
                      tl$prime$1,
                      bl$prime$2
                    ]
                  ]]);
    case 16 : 
        var t$4 = c0[1];
        var t$prime$4 = Curry._2(f, l, t$4);
        if (t$prime$4 === t$4) {
          return c0;
        } else {
          return mkProj(/* tuple */[
                      c0[0],
                      t$prime$4
                    ]);
        }
    default:
      return c0;
  }
}

function compare_head_gen_leq_with(kind1, kind2, leq_universes, leq_sorts, eq, leq, nargs, t1, t2) {
  var match = Curry._1(kind1, t1);
  var match$1 = Curry._1(kind2, t2);
  var exit = 0;
  var exit$1 = 0;
  var exit$2 = 0;
  switch (match.tag | 0) {
    case 0 : 
        switch (match$1.tag | 0) {
          case 0 : 
              return +(match[0] === match$1[0]);
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          default:
            exit = 1;
        }
        break;
    case 1 : 
        switch (match$1.tag | 0) {
          case 1 : 
              return Names$ReactTemplate.Id[/* equal */0](match[0], match$1[0]);
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          default:
            exit = 1;
        }
        break;
    case 2 : 
        switch (match$1.tag | 0) {
          case 2 : 
              return +(match[0] === match$1[0]);
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          default:
            exit = 1;
        }
        break;
    case 3 : 
        var match$2 = match[0];
        switch (match$1.tag | 0) {
          case 3 : 
              var match$3 = match$1[0];
              if (Evar$ReactTemplate.equal(match$2[0], match$3[0])) {
                return Util$ReactTemplate.$$Array[/* equal */21](Curry._1(eq, 0), match$2[1], match$3[1]);
              } else {
                return /* false */0;
              }
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          default:
            exit = 1;
        }
        break;
    case 4 : 
        switch (match$1.tag | 0) {
          case 4 : 
              return Curry._2(leq_sorts, match[0], match$1[0]);
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          default:
            exit = 1;
        }
        break;
    case 5 : 
        return Curry._3(leq, nargs, match[0], t2);
    case 6 : 
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 6 : 
              if (Curry._3(eq, 0, match[1], match$1[1])) {
                return Curry._3(leq, 0, match[2], match$1[2]);
              } else {
                return /* false */0;
              }
          case 9 : 
              exit$1 = 2;
              break;
          default:
            exit = 1;
        }
        break;
    case 7 : 
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 7 : 
              if (Curry._3(eq, 0, match[1], match$1[1])) {
                return Curry._3(eq, 0, match[2], match$1[2]);
              } else {
                return /* false */0;
              }
          case 9 : 
              exit$1 = 2;
              break;
          default:
            exit = 1;
        }
        break;
    case 8 : 
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 8 : 
              if (Curry._3(eq, 0, match[1], match$1[1]) && Curry._3(eq, 0, match[2], match$1[2])) {
                return Curry._3(leq, nargs, match[3], match$1[3]);
              } else {
                return /* false */0;
              }
          case 9 : 
              exit$1 = 2;
              break;
          default:
            exit = 1;
        }
        break;
    case 9 : 
        exit$2 = 3;
        break;
    case 10 : 
        var match$4 = match[0];
        var c1 = match$4[0];
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          case 10 : 
              var match$5 = match$1[0];
              if (Names$ReactTemplate.Constant[/* equal */12](c1, match$5[0])) {
                return Curry._4(leq_universes, /* ConstRef */Block.__(1, [c1]), nargs, match$4[1], match$5[1]);
              } else {
                return /* false */0;
              }
          default:
            exit = 1;
        }
        break;
    case 11 : 
        var match$6 = match[0];
        var c1$1 = match$6[0];
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          case 11 : 
              var match$7 = match$1[0];
              if (Names$ReactTemplate.eq_ind(c1$1, match$7[0])) {
                return Curry._4(leq_universes, /* IndRef */Block.__(2, [c1$1]), nargs, match$6[1], match$7[1]);
              } else {
                return /* false */0;
              }
          default:
            exit = 1;
        }
        break;
    case 12 : 
        var match$8 = match[0];
        var c1$2 = match$8[0];
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          case 12 : 
              var match$9 = match$1[0];
              if (Names$ReactTemplate.eq_constructor(c1$2, match$9[0])) {
                return Curry._4(leq_universes, /* ConstructRef */Block.__(3, [c1$2]), nargs, match$8[1], match$9[1]);
              } else {
                return /* false */0;
              }
          default:
            exit = 1;
        }
        break;
    case 13 : 
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          case 13 : 
              if (Curry._3(eq, 0, match[1], match$1[1]) && Curry._3(eq, 0, match[2], match$1[2])) {
                return Util$ReactTemplate.$$Array[/* equal */21](Curry._1(eq, 0), match[3], match$1[3]);
              } else {
                return /* false */0;
              }
          default:
            exit = 1;
        }
        break;
    case 14 : 
        var match$10 = match[0];
        var match$11 = match$10[1];
        var match$12 = match$10[0];
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          case 14 : 
              var match$13 = match$1[0];
              var match$14 = match$13[1];
              var match$15 = match$13[0];
              if (match$12[1] === match$15[1] && Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
                        return +(prim === prim$1);
                      }), match$12[0], match$15[0]) && Util$ReactTemplate.$$Array[/* equal_norefl */22](Curry._1(eq, 0), match$11[1], match$14[1])) {
                return Util$ReactTemplate.$$Array[/* equal_norefl */22](Curry._1(eq, 0), match$11[2], match$14[2]);
              } else {
                return /* false */0;
              }
          default:
            exit = 1;
        }
        break;
    case 15 : 
        var match$16 = match[0];
        var match$17 = match$16[1];
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          case 15 : 
              var match$18 = match$1[0];
              var match$19 = match$18[1];
              if (match$16[0] === match$18[0] && Util$ReactTemplate.$$Array[/* equal_norefl */22](Curry._1(eq, 0), match$17[1], match$19[1])) {
                return Util$ReactTemplate.$$Array[/* equal_norefl */22](Curry._1(eq, 0), match$17[2], match$19[2]);
              } else {
                return /* false */0;
              }
          default:
            exit = 1;
        }
        break;
    case 16 : 
        switch (match$1.tag | 0) {
          case 5 : 
              exit$2 = 3;
              break;
          case 9 : 
              exit$1 = 2;
              break;
          case 16 : 
              if (Names$ReactTemplate.Projection[/* equal */5](match[0], match$1[0])) {
                return Curry._3(eq, 0, match[1], match$1[1]);
              } else {
                return /* false */0;
              }
          default:
            exit = 1;
        }
        break;
    
  }
  if (exit$2 === 3) {
    if (match$1.tag === 5) {
      return Curry._3(leq, nargs, t1, match$1[0]);
    } else {
      var match$20 = match[0];
      if (match$20.tag === 5) {
        return Curry._3(leq, nargs, mkApp(/* tuple */[
                        match$20[0],
                        match[1]
                      ]), t2);
      } else {
        exit$1 = 2;
      }
    }
  }
  if (exit$1 === 2) {
    if (match$1.tag === 9) {
      var match$21 = match$1[0];
      if (match$21.tag === 5) {
        return Curry._3(leq, nargs, t1, mkApp(/* tuple */[
                        match$21[0],
                        match$1[1]
                      ]));
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    if (match.tag === 9) {
      var l1 = match[1];
      if (match$1.tag === 9) {
        var l2 = match$1[1];
        var len = l1.length;
        if (len === l2.length && Curry._3(eq, nargs + len | 0, match[0], match$1[0])) {
          return Util$ReactTemplate.$$Array[/* equal_norefl */22](Curry._1(eq, 0), l1, l2);
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  }
  
}

function compare_head_gen_leq(leq_universes, leq_sorts, eq, leq, t1, t2) {
  return (function (param) {
      return compare_head_gen_leq_with(kind, kind, leq_universes, leq_sorts, eq, leq, t1, t2, param);
    });
}

function compare_head_gen_with(kind1, kind2, eq_universes, eq_sorts, eq, t1, t2) {
  return (function (param) {
      return compare_head_gen_leq_with(kind1, kind2, eq_universes, eq_sorts, eq, eq, t1, t2, param);
    });
}

function compare_head_gen(eq_universes, eq_sorts, eq, t1, t2) {
  return compare_head_gen_leq(eq_universes, eq_sorts, eq, eq, t1, t2);
}

function compare_head(param, param$1, param$2) {
  return compare_head_gen((function (_, _$1) {
                return Univ$ReactTemplate.Instance[/* equal */5];
              }), Sorts$ReactTemplate.equal, param, param$1, param$2);
}

function eq_constr(nargs, m, n) {
  if (m === n) {
    return /* true */1;
  } else {
    return compare_head_gen((function (_, _$1) {
                    return Univ$ReactTemplate.Instance[/* equal */5];
                  }), Sorts$ReactTemplate.equal, eq_constr, nargs, m)(n);
  }
}

function equal(n, m) {
  return eq_constr(0, m, n);
}

function eq_constr_univs(univs, m, n) {
  if (m === n) {
    return /* true */1;
  } else {
    var eq_universes = function (_, _$1) {
      return (function (param, param$1) {
          return UGraph$ReactTemplate.check_eq_instances(univs, param, param$1);
        });
    };
    var eq_sorts = function (s1, s2) {
      if (s1 === s2) {
        return /* true */1;
      } else {
        return UGraph$ReactTemplate.check_eq(univs, Sorts$ReactTemplate.univ_of_sort(s1), Sorts$ReactTemplate.univ_of_sort(s2));
      }
    };
    var eq_constr$prime = function (nargs, m, n) {
      if (m === n) {
        return /* true */1;
      } else {
        return compare_head_gen(eq_universes, eq_sorts, eq_constr$prime, nargs, m)(n);
      }
    };
    return compare_head_gen(eq_universes, eq_sorts, eq_constr$prime, 0, m)(n);
  }
}

function leq_constr_univs(univs, m, n) {
  if (m === n) {
    return /* true */1;
  } else {
    var eq_universes = function (_, _$1) {
      return (function (param, param$1) {
          return UGraph$ReactTemplate.check_eq_instances(univs, param, param$1);
        });
    };
    var eq_sorts = function (s1, s2) {
      if (s1 === s2) {
        return /* true */1;
      } else {
        return UGraph$ReactTemplate.check_eq(univs, Sorts$ReactTemplate.univ_of_sort(s1), Sorts$ReactTemplate.univ_of_sort(s2));
      }
    };
    var leq_sorts = function (s1, s2) {
      if (s1 === s2) {
        return /* true */1;
      } else {
        return UGraph$ReactTemplate.check_leq(univs, Sorts$ReactTemplate.univ_of_sort(s1), Sorts$ReactTemplate.univ_of_sort(s2));
      }
    };
    var eq_constr$prime = function (nargs, m, n) {
      if (m === n) {
        return /* true */1;
      } else {
        return compare_head_gen(eq_universes, eq_sorts, eq_constr$prime, nargs, m)(n);
      }
    };
    var compare_leq = function (nargs, m, n) {
      return compare_head_gen_leq(eq_universes, leq_sorts, eq_constr$prime, leq_constr$prime, nargs, m)(n);
    };
    var leq_constr$prime = function (nargs, m, n) {
      if (m === n) {
        return /* true */1;
      } else {
        return compare_leq(nargs, m, n);
      }
    };
    return compare_leq(0, m, n);
  }
}

function eq_constr_univs_infer(univs, m, n) {
  if (m === n) {
    return /* tuple */[
            /* true */1,
            Univ$ReactTemplate.Constraint[/* empty */0]
          ];
  } else {
    var cstrs = [Univ$ReactTemplate.Constraint[/* empty */0]];
    var eq_universes = function (_, _$1) {
      return (function (param, param$1) {
          return UGraph$ReactTemplate.check_eq_instances(univs, param, param$1);
        });
    };
    var eq_sorts = function (s1, s2) {
      if (Sorts$ReactTemplate.equal(s1, s2)) {
        return /* true */1;
      } else {
        var u1 = Sorts$ReactTemplate.univ_of_sort(s1);
        var u2 = Sorts$ReactTemplate.univ_of_sort(s2);
        if (UGraph$ReactTemplate.check_eq(univs, u1, u2)) {
          return /* true */1;
        } else {
          cstrs[0] = Univ$ReactTemplate.enforce_eq(u1, u2, cstrs[0]);
          return /* true */1;
        }
      }
    };
    var eq_constr$prime = function (nargs, m, n) {
      if (m === n) {
        return /* true */1;
      } else {
        return compare_head_gen(eq_universes, eq_sorts, eq_constr$prime, nargs, m)(n);
      }
    };
    var res = compare_head_gen(eq_universes, eq_sorts, eq_constr$prime, 0, m)(n);
    return /* tuple */[
            res,
            cstrs[0]
          ];
  }
}

function leq_constr_univs_infer(univs, m, n) {
  if (m === n) {
    return /* tuple */[
            /* true */1,
            Univ$ReactTemplate.Constraint[/* empty */0]
          ];
  } else {
    var cstrs = [Univ$ReactTemplate.Constraint[/* empty */0]];
    var eq_universes = function (_, _$1, l, l$prime) {
      return UGraph$ReactTemplate.check_eq_instances(univs, l, l$prime);
    };
    var eq_sorts = function (s1, s2) {
      if (Sorts$ReactTemplate.equal(s1, s2)) {
        return /* true */1;
      } else {
        var u1 = Sorts$ReactTemplate.univ_of_sort(s1);
        var u2 = Sorts$ReactTemplate.univ_of_sort(s2);
        if (UGraph$ReactTemplate.check_eq(univs, u1, u2)) {
          return /* true */1;
        } else {
          cstrs[0] = Univ$ReactTemplate.enforce_eq(u1, u2, cstrs[0]);
          return /* true */1;
        }
      }
    };
    var leq_sorts = function (s1, s2) {
      if (Sorts$ReactTemplate.equal(s1, s2)) {
        return /* true */1;
      } else {
        var u1 = Sorts$ReactTemplate.univ_of_sort(s1);
        var u2 = Sorts$ReactTemplate.univ_of_sort(s2);
        if (UGraph$ReactTemplate.check_leq(univs, u1, u2)) {
          return /* true */1;
        } else {
          cstrs[0] = Univ$ReactTemplate.enforce_leq(u1, u2, cstrs[0]);
          return /* true */1;
        }
      }
    };
    var eq_constr$prime = function (nargs, m, n) {
      if (m === n) {
        return /* true */1;
      } else {
        return compare_head_gen(eq_universes, eq_sorts, eq_constr$prime, nargs, m)(n);
      }
    };
    var compare_leq = function (nargs, m, n) {
      return compare_head_gen_leq(eq_universes, leq_sorts, eq_constr$prime, leq_constr$prime, nargs, m)(n);
    };
    var leq_constr$prime = function (nargs, m, n) {
      if (m === n) {
        return /* true */1;
      } else {
        return compare_leq(nargs, m, n);
      }
    };
    var res = compare_leq(0, m, n);
    return /* tuple */[
            res,
            cstrs[0]
          ];
  }
}

function eq_constr_nounivs(m, n) {
  if (m === n) {
    return /* true */1;
  } else {
    return compare_head_gen((function (_, _$1, _$2, _$3) {
                    return /* true */1;
                  }), (function (_, _$1) {
                    return /* true */1;
                  }), (function () {
                    return eq_constr_nounivs;
                  }), 0, m)(n);
  }
}

function compare(m, n) {
  var f = compare;
  var t1 = m;
  var t2 = n;
  var $eq$unknown = function (f, g, i1, i2, j1, j2) {
    var c = Curry._2(f, i1, i2);
    if (c) {
      return c;
    } else {
      return Curry._2(g, j1, j2);
    }
  };
  var $eq$eq$unknown = function (fg, h, i1, i2, j1, j2, k1, k2) {
    var c = Curry._4(fg, i1, i2, j1, j2);
    if (c) {
      return c;
    } else {
      return Curry._2(h, k1, k2);
    }
  };
  var fix_cmp = function (param, param$1) {
    var partial_arg = Util$ReactTemplate.$$Array[/* compare */20];
    return $eq$unknown((function (param, param$1) {
                  return partial_arg(Caml_primitive.caml_int_compare, param, param$1);
                }), Caml_primitive.caml_int_compare, param[0], param$1[0], param[1], param$1[1]);
  };
  var exit = 0;
  var t1$1;
  var c1;
  var t2$1;
  var c2;
  var exit$1 = 0;
  var exit$2 = 0;
  switch (t1.tag | 0) {
    case 0 : 
        switch (t2.tag | 0) {
          case 0 : 
              return Caml_primitive.caml_int_compare(t1[0], t2[0]);
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          default:
            exit = 1;
        }
        break;
    case 1 : 
        switch (t2.tag | 0) {
          case 0 : 
              return 1;
          case 1 : 
              return Curry._2(Names$ReactTemplate.Id[/* compare */1], t1[0], t2[0]);
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          default:
            return -1;
        }
        break;
    case 2 : 
        switch (t2.tag | 0) {
          case 0 : 
          case 1 : 
              return 1;
          case 2 : 
              return Caml_primitive.caml_int_compare(t1[0], t2[0]);
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          default:
            return -1;
        }
        break;
    case 3 : 
        var match = t1[0];
        switch (t2.tag | 0) {
          case 0 : 
          case 1 : 
          case 2 : 
              return 1;
          case 3 : 
              var match$1 = t2[0];
              var partial_arg = Util$ReactTemplate.$$Array[/* compare */20];
              return $eq$unknown(Evar$ReactTemplate.compare, (function (param, param$1) {
                            return partial_arg(f, param, param$1);
                          }), match[0], match$1[0], match[1], match$1[1]);
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          default:
            return -1;
        }
        break;
    case 4 : 
        switch (t2.tag | 0) {
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
              return 1;
          case 4 : 
              return Sorts$ReactTemplate.compare(t1[0], t2[0]);
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          default:
            return -1;
        }
        break;
    case 5 : 
        return Curry._2(f, t1[0], t2);
    case 6 : 
        switch (t2.tag | 0) {
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
              return 1;
          case 5 : 
              exit$2 = 4;
              break;
          case 6 : 
              t1$1 = t1[1];
              c1 = t1[2];
              t2$1 = t2[1];
              c2 = t2[2];
              exit = 2;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          default:
            return -1;
        }
        break;
    case 7 : 
        switch (t2.tag | 0) {
          case 5 : 
              exit$2 = 4;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
              return 1;
          case 7 : 
              t1$1 = t1[1];
              c1 = t1[2];
              t2$1 = t2[1];
              c2 = t2[2];
              exit = 2;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          default:
            return -1;
        }
        break;
    case 8 : 
        switch (t2.tag | 0) {
          case 5 : 
              exit$2 = 4;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
              return 1;
          case 8 : 
              return $eq$eq$unknown((function (param, param$1, param$2, param$3) {
                            return $eq$unknown(f, f, param, param$1, param$2, param$3);
                          }), f, t1[1], t2[1], t1[2], t2[2], t1[3], t2[3]);
          case 9 : 
              exit$1 = 3;
              break;
          default:
            return -1;
        }
        break;
    case 9 : 
        exit$2 = 4;
        break;
    case 10 : 
        switch (t2.tag | 0) {
          case 5 : 
              exit$2 = 4;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
          case 8 : 
              return 1;
          case 9 : 
              exit$1 = 3;
              break;
          case 10 : 
              return Curry._2(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], t1[0][0], t2[0][0]);
          default:
            return -1;
        }
        break;
    case 11 : 
        switch (t2.tag | 0) {
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
          case 8 : 
          case 10 : 
              return 1;
          case 11 : 
              return Names$ReactTemplate.ind_ord(t1[0][0], t2[0][0]);
          default:
            return -1;
        }
        break;
    case 12 : 
        switch (t2.tag | 0) {
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
          case 8 : 
          case 10 : 
          case 11 : 
              return 1;
          case 12 : 
              return Names$ReactTemplate.constructor_ord(t1[0][0], t2[0][0]);
          default:
            return -1;
        }
        break;
    case 13 : 
        switch (t2.tag | 0) {
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
          case 8 : 
          case 10 : 
          case 11 : 
          case 12 : 
              return 1;
          case 13 : 
              var partial_arg$1 = Util$ReactTemplate.$$Array[/* compare */20];
              return $eq$eq$unknown((function (param, param$1, param$2, param$3) {
                            return $eq$unknown(f, f, param, param$1, param$2, param$3);
                          }), (function (param, param$1) {
                            return partial_arg$1(f, param, param$1);
                          }), t1[1], t2[1], t1[2], t2[2], t1[3], t2[3]);
          default:
            return -1;
        }
        break;
    case 14 : 
        var match$2 = t1[0];
        var match$3 = match$2[1];
        switch (t2.tag | 0) {
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
          case 8 : 
          case 10 : 
          case 11 : 
          case 12 : 
          case 13 : 
              return 1;
          case 14 : 
              var match$4 = t2[0];
              var match$5 = match$4[1];
              var partial_arg$2 = Util$ReactTemplate.$$Array[/* compare */20];
              var partial_arg$3 = function (param, param$1) {
                return partial_arg$2(f, param, param$1);
              };
              var partial_arg$4 = Util$ReactTemplate.$$Array[/* compare */20];
              return $eq$eq$unknown((function (param, param$1, param$2, param$3) {
                            return $eq$unknown(fix_cmp, partial_arg$3, param, param$1, param$2, param$3);
                          }), (function (param, param$1) {
                            return partial_arg$4(f, param, param$1);
                          }), match$2[0], match$4[0], match$3[1], match$5[1], match$3[2], match$5[2]);
          case 15 : 
          case 16 : 
              return -1;
          
        }
        break;
    case 15 : 
        var match$6 = t1[0];
        var match$7 = match$6[1];
        switch (t2.tag | 0) {
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
          case 8 : 
          case 10 : 
          case 11 : 
          case 12 : 
          case 13 : 
          case 14 : 
              return 1;
          case 15 : 
              var match$8 = t2[0];
              var match$9 = match$8[1];
              var partial_arg$5 = Util$ReactTemplate.$$Array[/* compare */20];
              var partial_arg$6 = function (param, param$1) {
                return partial_arg$5(f, param, param$1);
              };
              var partial_arg$7 = Util$ReactTemplate.$$Array[/* compare */20];
              return $eq$eq$unknown((function (param, param$1, param$2, param$3) {
                            return $eq$unknown(Caml_primitive.caml_int_compare, partial_arg$6, param, param$1, param$2, param$3);
                          }), (function (param, param$1) {
                            return partial_arg$7(f, param, param$1);
                          }), match$6[0], match$8[0], match$7[1], match$9[1], match$7[2], match$9[2]);
          case 16 : 
              return -1;
          
        }
        break;
    case 16 : 
        switch (t2.tag | 0) {
          case 5 : 
              exit$2 = 4;
              break;
          case 9 : 
              exit$1 = 3;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
          case 8 : 
          case 10 : 
          case 11 : 
          case 12 : 
          case 13 : 
          case 14 : 
          case 15 : 
              return 1;
          case 16 : 
              return $eq$unknown(Names$ReactTemplate.Projection[/* compare */8], f, t1[0], t2[0], t1[1], t2[1]);
          
        }
        break;
    
  }
  if (exit$2 === 4) {
    if (t2.tag === 5) {
      return Curry._2(f, t1, t2[0]);
    } else {
      var match$10 = t1[0];
      if (match$10.tag === 5) {
        return Curry._2(f, mkApp(/* tuple */[
                        match$10[0],
                        t1[1]
                      ]), t2);
      } else {
        exit$1 = 3;
      }
    }
  }
  if (exit$1 === 3) {
    if (t2.tag === 9) {
      var match$11 = t2[0];
      if (match$11.tag === 5) {
        return Curry._2(f, t1, mkApp(/* tuple */[
                        match$11[0],
                        t2[1]
                      ]));
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  }
  switch (exit) {
    case 1 : 
        switch (t1.tag | 0) {
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
          case 8 : 
              return -1;
          case 9 : 
              switch (t2.tag | 0) {
                case 0 : 
                case 1 : 
                case 2 : 
                case 3 : 
                case 4 : 
                case 6 : 
                case 7 : 
                case 8 : 
                    return 1;
                case 9 : 
                    var partial_arg$8 = Util$ReactTemplate.$$Array[/* compare */20];
                    return $eq$unknown(f, (function (param, param$1) {
                                  return partial_arg$8(f, param, param$1);
                                }), t1[0], t2[0], t1[1], t2[1]);
                default:
                  return -1;
              }
              break;
          default:
            return 1;
        }
        break;
    case 2 : 
        return $eq$unknown(f, f, t1$1, t2$1, c1, c2);
    
  }
}

function array_eqeq(t1, t2) {
  if (t1 === t2) {
    return /* true */1;
  } else if (t1.length === t2.length) {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === t1.length) {
        return /* true */1;
      } else if (Caml_array.caml_array_get(t1, i) === Caml_array.caml_array_get(t2, i)) {
        _i = i + 1 | 0;
        continue ;
        
      } else {
        return /* false */0;
      }
    };
  } else {
    return /* false */0;
  }
}

function hasheq(t1, t2) {
  switch (t1.tag | 0) {
    case 0 : 
        if (t2.tag) {
          return /* false */0;
        } else {
          return +(t1[0] === t2[0]);
        }
        break;
    case 1 : 
        if (t2.tag === 1) {
          return +(t1[0] === t2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 2 : 
        if (t2.tag === 2) {
          return +(t1[0] === t2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 3 : 
        var match = t1[0];
        if (t2.tag === 3) {
          var match$1 = t2[0];
          if (match[0] === match$1[0]) {
            return array_eqeq(match[1], match$1[1]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
        break;
    case 4 : 
        if (t2.tag === 4) {
          return +(t1[0] === t2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 5 : 
        if (t2.tag === 5 && t1[0] === t2[0] && t1[1] === t2[1]) {
          return +(t1[2] === t2[2]);
        } else {
          return /* false */0;
        }
        break;
    case 6 : 
        if (t2.tag === 6 && t1[0] === t2[0] && t1[1] === t2[1]) {
          return +(t1[2] === t2[2]);
        } else {
          return /* false */0;
        }
        break;
    case 7 : 
        if (t2.tag === 7 && t1[0] === t2[0] && t1[1] === t2[1]) {
          return +(t1[2] === t2[2]);
        } else {
          return /* false */0;
        }
        break;
    case 8 : 
        if (t2.tag === 8 && t1[0] === t2[0] && t1[1] === t2[1] && t1[2] === t2[2]) {
          return +(t1[3] === t2[3]);
        } else {
          return /* false */0;
        }
        break;
    case 9 : 
        if (t2.tag === 9 && t1[0] === t2[0]) {
          return array_eqeq(t1[1], t2[1]);
        } else {
          return /* false */0;
        }
        break;
    case 10 : 
        var match$2 = t1[0];
        if (t2.tag === 10) {
          var match$3 = t2[0];
          if (match$2[0] === match$3[0]) {
            return +(match$2[1] === match$3[1]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
        break;
    case 11 : 
        var match$4 = t1[0];
        if (t2.tag === 11) {
          var match$5 = t2[0];
          if (match$4[0] === match$5[0]) {
            return +(match$4[1] === match$5[1]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
        break;
    case 12 : 
        var match$6 = t1[0];
        if (t2.tag === 12) {
          var match$7 = t2[0];
          if (match$6[0] === match$7[0]) {
            return +(match$6[1] === match$7[1]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
        break;
    case 13 : 
        if (t2.tag === 13 && t1[0] === t2[0] && t1[1] === t2[1] && t1[2] === t2[2]) {
          return array_eqeq(t1[3], t2[3]);
        } else {
          return /* false */0;
        }
        break;
    case 14 : 
        var match$8 = t1[0];
        var match$9 = match$8[1];
        var match$10 = match$8[0];
        if (t2.tag === 14) {
          var match$11 = t2[0];
          var match$12 = match$11[1];
          var match$13 = match$11[0];
          if (match$10[1] === match$13[1] && Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
                    return +(prim === prim$1);
                  }), match$10[0], match$13[0]) && array_eqeq(match$9[0], match$12[0]) && array_eqeq(match$9[1], match$12[1])) {
            return array_eqeq(match$9[2], match$12[2]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
        break;
    case 15 : 
        var match$14 = t1[0];
        var match$15 = match$14[1];
        if (t2.tag === 15) {
          var match$16 = t2[0];
          var match$17 = match$16[1];
          if (match$14[0] === match$16[0] && array_eqeq(match$15[0], match$17[0]) && array_eqeq(match$15[1], match$17[1])) {
            return array_eqeq(match$15[2], match$17[2]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
        break;
    case 16 : 
        if (t2.tag === 16 && t1[0] === t2[0]) {
          return +(t1[1] === t2[1]);
        } else {
          return /* false */0;
        }
        break;
    
  }
}

var HashsetTerm = Hashset$ReactTemplate.Make(/* module */[/* eq */hasheq]);

var HashsetTermArray = Hashset$ReactTemplate.Make(/* module */[/* eq */array_eqeq]);

var term_table = Curry._1(HashsetTerm[/* create */0], 19991);

var term_array_table = Curry._1(HashsetTermArray[/* create */0], 4999);

var sh_instance = Univ$ReactTemplate.Instance[/* share */9];

function hashcons(param) {
  var sh_id = param[6];
  var sh_na = param[5];
  var sh_con = param[4];
  var sh_ind = param[3];
  var sh_construct = param[2];
  var sh_ci = param[1];
  var sh_sort = param[0];
  var hash_term = function (t) {
    switch (t.tag | 0) {
      case 0 : 
          return /* tuple */[
                  t,
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](16, t[0])
                ];
      case 1 : 
          var i = t[0];
          return /* tuple */[
                  /* Var */Block.__(1, [Curry._1(sh_id, i)]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](1, Curry._1(Names$ReactTemplate.Id[/* hash */2], i))
                ];
      case 2 : 
          return /* tuple */[
                  t,
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](15, t[0])
                ];
      case 3 : 
          var match = t[0];
          var e = match[0];
          var match$1 = hash_term_array(match[1]);
          return /* tuple */[
                  /* Evar */Block.__(3, [/* tuple */[
                        e,
                        match$1[0]
                      ]]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](8, Hashset$ReactTemplate.Combine[/* combine */0](Evar$ReactTemplate.hash(e), match$1[1]))
                ];
      case 4 : 
          var s = t[0];
          return /* tuple */[
                  /* Sort */Block.__(4, [Curry._1(sh_sort, s)]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](2, Sorts$ReactTemplate.hash(s))
                ];
      case 5 : 
          var k = t[1];
          var match$2 = sh_rec(t[0]);
          var match$3 = sh_rec(t[2]);
          return /* tuple */[
                  /* Cast */Block.__(5, [
                      match$2[0],
                      k,
                      match$3[0]
                    ]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](3, Hashset$ReactTemplate.Combine[/* combine3 */2](match$2[1], k, match$3[1]))
                ];
      case 6 : 
          var na = t[0];
          var match$4 = sh_rec(t[1]);
          var match$5 = sh_rec(t[2]);
          return /* tuple */[
                  /* Prod */Block.__(6, [
                      Curry._1(sh_na, na),
                      match$4[0],
                      match$5[0]
                    ]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](4, Hashset$ReactTemplate.Combine[/* combine3 */2](Names$ReactTemplate.Name[/* hash */5](na), match$4[1], match$5[1]))
                ];
      case 7 : 
          var na$1 = t[0];
          var match$6 = sh_rec(t[1]);
          var match$7 = sh_rec(t[2]);
          return /* tuple */[
                  /* Lambda */Block.__(7, [
                      Curry._1(sh_na, na$1),
                      match$6[0],
                      match$7[0]
                    ]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](5, Hashset$ReactTemplate.Combine[/* combine3 */2](Names$ReactTemplate.Name[/* hash */5](na$1), match$6[1], match$7[1]))
                ];
      case 8 : 
          var na$2 = t[0];
          var match$8 = sh_rec(t[1]);
          var match$9 = sh_rec(t[2]);
          var match$10 = sh_rec(t[3]);
          return /* tuple */[
                  /* LetIn */Block.__(8, [
                      Curry._1(sh_na, na$2),
                      match$8[0],
                      match$9[0],
                      match$10[0]
                    ]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](6, Hashset$ReactTemplate.Combine[/* combine4 */3](Names$ReactTemplate.Name[/* hash */5](na$2), match$8[1], match$9[1], match$10[1]))
                ];
      case 9 : 
          var match$11 = sh_rec(t[0]);
          var match$12 = hash_term_array(t[1]);
          return /* tuple */[
                  /* App */Block.__(9, [
                      match$11[0],
                      match$12[0]
                    ]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](7, Hashset$ReactTemplate.Combine[/* combine */0](match$12[1], match$11[1]))
                ];
      case 10 : 
          var match$13 = t[0];
          var c = match$13[0];
          var c$prime = Curry._1(sh_con, c);
          var match$14 = Curry._1(sh_instance, match$13[1]);
          return /* tuple */[
                  /* Const */Block.__(10, [/* tuple */[
                        c$prime,
                        match$14[0]
                      ]]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](9, Hashset$ReactTemplate.Combine[/* combine */0](Curry._1(Names$ReactTemplate.Constant[/* SyntacticOrd */11][/* hash */2], c), match$14[1]))
                ];
      case 11 : 
          var match$15 = t[0];
          var ind = match$15[0];
          var match$16 = Curry._1(sh_instance, match$15[1]);
          return /* tuple */[
                  /* Ind */Block.__(11, [/* tuple */[
                        Curry._1(sh_ind, ind),
                        match$16[0]
                      ]]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](10, Hashset$ReactTemplate.Combine[/* combine */0](Names$ReactTemplate.ind_syntactic_hash(ind), match$16[1]))
                ];
      case 12 : 
          var match$17 = t[0];
          var c$1 = match$17[0];
          var match$18 = Curry._1(sh_instance, match$17[1]);
          return /* tuple */[
                  /* Construct */Block.__(12, [/* tuple */[
                        Curry._1(sh_construct, c$1),
                        match$18[0]
                      ]]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](11, Hashset$ReactTemplate.Combine[/* combine */0](Names$ReactTemplate.constructor_syntactic_hash(c$1), match$18[1]))
                ];
      case 13 : 
          var match$19 = sh_rec(t[1]);
          var match$20 = sh_rec(t[2]);
          var match$21 = hash_term_array(t[3]);
          var hbl = Hashset$ReactTemplate.Combine[/* combine */0](Hashset$ReactTemplate.Combine[/* combine */0](match$20[1], match$19[1]), match$21[1]);
          return /* tuple */[
                  /* Case */Block.__(13, [
                      Curry._1(sh_ci, t[0]),
                      match$19[0],
                      match$20[0],
                      match$21[0]
                    ]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](12, hbl)
                ];
      case 14 : 
          var match$22 = t[0];
          var match$23 = match$22[1];
          var lna = match$23[0];
          var match$24 = hash_term_array(match$23[2]);
          var match$25 = hash_term_array(match$23[1]);
          Util$ReactTemplate.$$Array[/* iteri */13]((function (i, x) {
                  lna[i] = Curry._1(sh_na, x);
                  return /* () */0;
                }), lna);
          var fold = function (accu, na) {
            return Hashset$ReactTemplate.Combine[/* combine */0](Names$ReactTemplate.Name[/* hash */5](na), accu);
          };
          var hna = Util$ReactTemplate.$$Array[/* fold_left */15](fold, 0, lna);
          var h = Hashset$ReactTemplate.Combine[/* combine3 */2](hna, match$24[1], match$25[1]);
          return /* tuple */[
                  /* Fix */Block.__(14, [/* tuple */[
                        match$22[0],
                        /* tuple */[
                          lna,
                          match$25[0],
                          match$24[0]
                        ]
                      ]]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](13, h)
                ];
      case 15 : 
          var match$26 = t[0];
          var match$27 = match$26[1];
          var lna$1 = match$27[0];
          var match$28 = hash_term_array(match$27[2]);
          var match$29 = hash_term_array(match$27[1]);
          Util$ReactTemplate.$$Array[/* iteri */13]((function (i, x) {
                  lna$1[i] = Curry._1(sh_na, x);
                  return /* () */0;
                }), lna$1);
          var fold$1 = function (accu, na) {
            return Hashset$ReactTemplate.Combine[/* combine */0](Names$ReactTemplate.Name[/* hash */5](na), accu);
          };
          var hna$1 = Util$ReactTemplate.$$Array[/* fold_left */15](fold$1, 0, lna$1);
          var h$1 = Hashset$ReactTemplate.Combine[/* combine3 */2](hna$1, match$28[1], match$29[1]);
          return /* tuple */[
                  /* CoFix */Block.__(15, [/* tuple */[
                        match$26[0],
                        /* tuple */[
                          lna$1,
                          match$29[0],
                          match$28[0]
                        ]
                      ]]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](14, h$1)
                ];
      case 16 : 
          var match$30 = sh_rec(t[1]);
          var p$prime = Curry._1(Names$ReactTemplate.Projection[/* hcons */7], t[0]);
          return /* tuple */[
                  /* Proj */Block.__(16, [
                      p$prime,
                      match$30[0]
                    ]),
                  Hashset$ReactTemplate.Combine[/* combinesmall */1](17, Hashset$ReactTemplate.Combine[/* combine */0](Curry._1(Names$ReactTemplate.Projection[/* SyntacticOrd */1][/* hash */2], p$prime), match$30[1]))
                ];
      
    }
  };
  var sh_rec = function (t) {
    var match = hash_term(t);
    var h = match[1] & 1073741823;
    return /* tuple */[
            Curry._3(HashsetTerm[/* repr */2], h, match[0], term_table),
            h
          ];
  };
  var hash_term_array = function (t) {
    var accu = 0;
    for(var i = 0 ,i_finish = t.length - 1 | 0; i <= i_finish; ++i){
      var match = sh_rec(t[i]);
      accu = Hashset$ReactTemplate.Combine[/* combine */0](accu, match[1]);
      t[i] = match[0];
    }
    var h = accu & 1073741823;
    return /* tuple */[
            Curry._3(HashsetTermArray[/* repr */2], h, t, term_array_table),
            h
          ];
  };
  hash_term_array(rels);
  return (function (t) {
      return sh_rec(t)[0];
    });
}

function hash(_t) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](16, t[0]);
      case 1 : 
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, Curry._1(Names$ReactTemplate.Id[/* hash */2], t[0]));
      case 2 : 
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](15, t[0]);
      case 3 : 
          var match = t[0];
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](8, Hashset$ReactTemplate.Combine[/* combine */0](Evar$ReactTemplate.hash(match[0]), hash_term_array(match[1])));
      case 4 : 
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](2, Sorts$ReactTemplate.hash(t[0]));
      case 5 : 
          var hc = hash(t[0]);
          var ht = hash(t[2]);
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](3, Hashset$ReactTemplate.Combine[/* combine3 */2](hc, t[1], ht));
      case 6 : 
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](4, Hashset$ReactTemplate.Combine[/* combine */0](hash(t[1]), hash(t[2])));
      case 7 : 
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](5, Hashset$ReactTemplate.Combine[/* combine */0](hash(t[1]), hash(t[2])));
      case 8 : 
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](6, Hashset$ReactTemplate.Combine[/* combine3 */2](hash(t[1]), hash(t[2]), hash(t[3])));
      case 9 : 
          var c = t[0];
          if (c.tag === 5) {
            _t = mkApp(/* tuple */[
                  c[0],
                  t[1]
                ]);
            continue ;
            
          } else {
            return Hashset$ReactTemplate.Combine[/* combinesmall */1](7, Hashset$ReactTemplate.Combine[/* combine */0](hash_term_array(t[1]), hash(c)));
          }
          break;
      case 10 : 
          var match$1 = t[0];
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](9, Hashset$ReactTemplate.Combine[/* combine */0](Names$ReactTemplate.Constant[/* hash */13](match$1[0]), Univ$ReactTemplate.Instance[/* hash */8](match$1[1])));
      case 11 : 
          var match$2 = t[0];
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](10, Hashset$ReactTemplate.Combine[/* combine */0](Names$ReactTemplate.ind_hash(match$2[0]), Univ$ReactTemplate.Instance[/* hash */8](match$2[1])));
      case 12 : 
          var match$3 = t[0];
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](11, Hashset$ReactTemplate.Combine[/* combine */0](Names$ReactTemplate.constructor_hash(match$3[0]), Univ$ReactTemplate.Instance[/* hash */8](match$3[1])));
      case 13 : 
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](12, Hashset$ReactTemplate.Combine[/* combine3 */2](hash(t[2]), hash(t[1]), hash_term_array(t[3])));
      case 14 : 
          var match$4 = t[0][1];
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](13, Hashset$ReactTemplate.Combine[/* combine */0](hash_term_array(match$4[2]), hash_term_array(match$4[1])));
      case 15 : 
          var match$5 = t[0][1];
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](14, Hashset$ReactTemplate.Combine[/* combine */0](hash_term_array(match$5[2]), hash_term_array(match$5[1])));
      case 16 : 
          return Hashset$ReactTemplate.Combine[/* combinesmall */1](17, Hashset$ReactTemplate.Combine[/* combine */0](Names$ReactTemplate.Projection[/* hash */6](t[0]), hash(t[1])));
      
    }
  };
}

function hash_term_array(t) {
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (acc, t) {
                return Hashset$ReactTemplate.Combine[/* combine */0](hash(t), acc);
              }), 0, t);
}

function hashcons$1(hind, ci) {
  return /* record */[
          /* ci_ind */Curry._1(hind, ci[/* ci_ind */0]),
          /* ci_npar */ci[/* ci_npar */1],
          /* ci_cstr_ndecls */ci[/* ci_cstr_ndecls */2],
          /* ci_cstr_nargs */ci[/* ci_cstr_nargs */3],
          /* ci_pp_info */ci[/* ci_pp_info */4]
        ];
}

function eq(ci, ci$prime) {
  if (ci[/* ci_ind */0] === ci$prime[/* ci_ind */0] && ci[/* ci_npar */1] === ci$prime[/* ci_npar */1] && Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
            return +(prim === prim$1);
          }), ci[/* ci_cstr_ndecls */2], ci$prime[/* ci_cstr_ndecls */2]) && Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
            return +(prim === prim$1);
          }), ci[/* ci_cstr_nargs */3], ci$prime[/* ci_cstr_nargs */3])) {
    var info1 = ci[/* ci_pp_info */4];
    var info2 = ci$prime[/* ci_pp_info */4];
    if (Curry._3(Util$ReactTemplate.List[/* equal */44], (function (prim, prim$1) {
              return +(prim === prim$1);
            }), info1[/* ind_tags */0], info2[/* ind_tags */0]) && Util$ReactTemplate.$$Array[/* equal */21](Curry._1(Util$ReactTemplate.List[/* equal */44], (function (prim, prim$1) {
                  return +(prim === prim$1);
                })), info1[/* cstr_tags */1], info2[/* cstr_tags */1])) {
      return +(info1[/* style */2] === info2[/* style */2]);
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

var hash_bool_list = Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (n, b) {
        return Hashset$ReactTemplate.Combine[/* combine */0](n, b ? 0 : 1);
      }));

function hash_pp_info(info) {
  var match = info[/* style */2];
  var h2 = Curry._2(hash_bool_list, 0, info[/* ind_tags */0]);
  var h3 = Util$ReactTemplate.$$Array[/* fold_left */15](hash_bool_list, 0, info[/* cstr_tags */1]);
  return Hashset$ReactTemplate.Combine[/* combine3 */2](match, h2, h3);
}

function hash$1(ci) {
  var h1 = Names$ReactTemplate.ind_hash(ci[/* ci_ind */0]);
  var h2 = Int$ReactTemplate.hash(ci[/* ci_npar */1]);
  var h3 = Util$ReactTemplate.$$Array[/* fold_left */15](Hashset$ReactTemplate.Combine[/* combine */0], 0, ci[/* ci_cstr_ndecls */2]);
  var h4 = Util$ReactTemplate.$$Array[/* fold_left */15](Hashset$ReactTemplate.Combine[/* combine */0], 0, ci[/* ci_cstr_nargs */3]);
  var h5 = hash_pp_info(ci[/* ci_pp_info */4]);
  return Hashset$ReactTemplate.Combine[/* combine5 */4](h1, h2, h3, h4, h5);
}

var Hcaseinfo = Hashcons$ReactTemplate.Make([
      hashcons$1,
      eq,
      hash$1
    ]);

var hcons_caseinfo = Hashcons$ReactTemplate.simple_hcons(Hcaseinfo[/* generate */0], Hcaseinfo[/* hcons */1], Names$ReactTemplate.hcons_ind);

var hcons = hashcons(/* tuple */[
      Sorts$ReactTemplate.hcons,
      hcons_caseinfo,
      Names$ReactTemplate.hcons_construct,
      Names$ReactTemplate.hcons_ind,
      Names$ReactTemplate.hcons_con,
      Names$ReactTemplate.Name[/* hcons */6],
      Names$ReactTemplate.Id[/* hcons */13]
    ]);

var is_small = Sorts$ReactTemplate.is_small;

var case_info_hash = hash$1;

exports.mkRel = mkRel;
exports.mkVar = mkVar;
exports.mkMeta = mkMeta;
exports.mkEvar = mkEvar;
exports.mkSort = mkSort;
exports.mkProp = mkProp;
exports.mkSet = mkSet;
exports.mkType = mkType;
exports.mkCast = mkCast;
exports.mkProd = mkProd;
exports.mkLambda = mkLambda;
exports.mkLetIn = mkLetIn;
exports.mkApp = mkApp;
exports.map_puniverses = map_puniverses;
exports.mkConst = mkConst;
exports.mkConstU = mkConstU;
exports.mkProj = mkProj;
exports.mkInd = mkInd;
exports.mkIndU = mkIndU;
exports.mkConstruct = mkConstruct;
exports.mkConstructU = mkConstructU;
exports.mkConstructUi = mkConstructUi;
exports.mkCase = mkCase;
exports.mkFix = mkFix;
exports.mkCoFix = mkCoFix;
exports.kind = kind;
exports.of_kind = of_kind;
exports.isRel = isRel;
exports.isRelN = isRelN;
exports.isVar = isVar;
exports.isVarId = isVarId;
exports.isInd = isInd;
exports.isEvar = isEvar;
exports.isMeta = isMeta;
exports.isEvar_or_Meta = isEvar_or_Meta;
exports.isSort = isSort;
exports.isCast = isCast;
exports.isApp = isApp;
exports.isLambda = isLambda;
exports.isLetIn = isLetIn;
exports.isProd = isProd;
exports.isConst = isConst;
exports.isConstruct = isConstruct;
exports.isFix = isFix;
exports.isCoFix = isCoFix;
exports.isCase = isCase;
exports.isProj = isProj;
exports.is_Prop = is_Prop;
exports.is_Set = is_Set;
exports.isprop = isprop;
exports.is_Type = is_Type;
exports.iskind = iskind;
exports.is_small = is_small;
exports.DestKO = DestKO;
exports.destRel = destRel;
exports.destMeta = destMeta;
exports.destVar = destVar;
exports.destSort = destSort;
exports.destCast = destCast;
exports.destProd = destProd;
exports.destLambda = destLambda;
exports.destLetIn = destLetIn;
exports.destApp = destApp;
exports.decompose_app = decompose_app;
exports.decompose_appvect = decompose_appvect;
exports.destConst = destConst;
exports.destEvar = destEvar;
exports.destInd = destInd;
exports.destConstruct = destConstruct;
exports.destCase = destCase;
exports.destProj = destProj;
exports.destFix = destFix;
exports.destCoFix = destCoFix;
exports.equal = equal;
exports.eq_constr_univs = eq_constr_univs;
exports.leq_constr_univs = leq_constr_univs;
exports.eq_constr_univs_infer = eq_constr_univs_infer;
exports.leq_constr_univs_infer = leq_constr_univs_infer;
exports.eq_constr_nounivs = eq_constr_nounivs;
exports.compare = compare;
exports.fold = fold;
exports.map = map;
exports.fold_map = fold_map;
exports.map_with_binders = map_with_binders;
exports.iter = iter;
exports.iter_with_binders = iter_with_binders;
exports.compare_head = compare_head;
exports.compare_head_gen = compare_head_gen;
exports.compare_head_gen_leq_with = compare_head_gen_leq_with;
exports.compare_head_gen_with = compare_head_gen_with;
exports.compare_head_gen_leq = compare_head_gen_leq;
exports.hash = hash;
exports.case_info_hash = case_info_hash;
exports.hcons = hcons;
/* HashsetTerm Not a pure module */
