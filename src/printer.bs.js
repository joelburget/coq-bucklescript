// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Goal$ReactTemplate = require("./goal.bs.js");
var Hook$ReactTemplate = require("./hook.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Proof$ReactTemplate = require("./proof.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Pfedit$ReactTemplate = require("./pfedit.bs.js");
var Refine$ReactTemplate = require("./refine.bs.js");
var Tacred$ReactTemplate = require("./tacred.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Refiner$ReactTemplate = require("./refiner.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Detyping$ReactTemplate = require("./detyping.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Ppconstr$ReactTemplate = require("./ppconstr.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var Constrextern$ReactTemplate = require("./constrextern.bs.js");
var Proof_bullet$ReactTemplate = require("./proof_bullet.bs.js");

var enable_unfocused_goal_printing = [/* false */0];

var enable_goal_tags_printing = [/* false */0];

var enable_goal_names_printing = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"printing of unfocused goal",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Unfocused",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return enable_unfocused_goal_printing[0];
        }),
      /* optwrite */(function (b) {
          enable_unfocused_goal_printing[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"printing of goal tags",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Goal",
          /* :: */[
            "Tags",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return enable_goal_tags_printing[0];
        }),
      /* optwrite */(function (b) {
          enable_goal_tags_printing[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"printing of goal names",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Goal",
          /* :: */[
            "Names",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return enable_goal_names_printing[0];
        }),
      /* optwrite */(function (b) {
          enable_goal_names_printing[0] = b;
          return /* () */0;
        })
    ]);

function pr_econstr_n_core(goal_concl_style, env, sigma, n, t) {
  return Ppconstr$ReactTemplate.pr_constr_expr_n(n, Constrextern$ReactTemplate.extern_constr(/* None */0, goal_concl_style, env, sigma, t));
}

function pr_econstr_core(goal_concl_style, env, sigma, t) {
  return Ppconstr$ReactTemplate.pr_constr_expr(Constrextern$ReactTemplate.extern_constr(/* None */0, goal_concl_style, env, sigma, t));
}

function pr_leconstr_core(goal_concl_style, env, sigma, t) {
  return Ppconstr$ReactTemplate.pr_lconstr_expr(Constrextern$ReactTemplate.extern_constr(/* None */0, goal_concl_style, env, sigma, t));
}

function pr_constr_n_env(env, sigma, n, c) {
  return pr_econstr_n_core(/* false */0, env, sigma, n, EConstr$ReactTemplate.of_constr(c));
}

function pr_lconstr_env(env, sigma, c) {
  return pr_leconstr_core(/* false */0, env, sigma, EConstr$ReactTemplate.of_constr(c));
}

function pr_constr_env(env, sigma, c) {
  return pr_econstr_core(/* false */0, env, sigma, EConstr$ReactTemplate.of_constr(c));
}

Hook$ReactTemplate.set(Refine$ReactTemplate.pr_constr, pr_constr_env);

function pr_lconstr_goal_style_env(env, sigma, c) {
  return pr_leconstr_core(/* true */1, env, sigma, EConstr$ReactTemplate.of_constr(c));
}

function pr_constr_goal_style_env(env, sigma, c) {
  return pr_econstr_core(/* true */1, env, sigma, EConstr$ReactTemplate.of_constr(c));
}

function pr_open_lconstr_env(env, sigma, param) {
  return pr_lconstr_env(env, sigma, param[1]);
}

function pr_open_constr_env(env, sigma, param) {
  return pr_constr_env(env, sigma, param[1]);
}

function pr_econstr_n_env(env, sigma, c) {
  return (function (param) {
      return pr_econstr_n_core(/* false */0, env, sigma, c, param);
    });
}

function pr_leconstr_env(env, sigma, c) {
  return pr_leconstr_core(/* false */0, env, sigma, c);
}

function pr_econstr_env(env, sigma, c) {
  return pr_econstr_core(/* false */0, env, sigma, c);
}

function pr_lconstr(t) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_lconstr_env(match[1], match[0], t);
}

function pr_constr(t) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_constr_env(match[1], match[0], t);
}

function pr_open_lconstr(param) {
  return pr_lconstr(param[1]);
}

function pr_open_constr(param) {
  return pr_constr(param[1]);
}

function pr_leconstr(c) {
  return pr_lconstr(EConstr$ReactTemplate.Unsafe[/* to_constr */0](c));
}

function pr_econstr(c) {
  return pr_constr(EConstr$ReactTemplate.Unsafe[/* to_constr */0](c));
}

function pr_constr_under_binders_env_gen(pr, env, sigma, param) {
  var assums = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
          return /* tuple */[
                  /* Name */[id],
                  Constr$ReactTemplate.mkProp
                ];
        }), param[0]);
  return Curry._3(pr, Termops$ReactTemplate.push_rels_assum(assums)(env), sigma, param[1]);
}

function pr_constr_under_binders_env(param, param$1, param$2) {
  return pr_constr_under_binders_env_gen(pr_econstr_env, param, param$1, param$2);
}

function pr_lconstr_under_binders_env(param, param$1, param$2) {
  return pr_constr_under_binders_env_gen(pr_leconstr_env, param, param$1, param$2);
}

function pr_constr_under_binders(c) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_constr_under_binders_env(match[1], match[0], c);
}

function pr_lconstr_under_binders(c) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_lconstr_under_binders_env(match[1], match[0], c);
}

function pr_etype_core(goal_concl_style, env, sigma, t) {
  return Ppconstr$ReactTemplate.pr_constr_expr(Constrextern$ReactTemplate.extern_type(goal_concl_style, env, sigma, t));
}

function pr_letype_core(goal_concl_style, env, sigma, t) {
  return Ppconstr$ReactTemplate.pr_lconstr_expr(Constrextern$ReactTemplate.extern_type(goal_concl_style, env, sigma, t));
}

function pr_ltype_env(env, sigma, c) {
  return pr_letype_core(/* false */0, env, sigma, EConstr$ReactTemplate.of_constr(c));
}

function pr_type_env(env, sigma, c) {
  return pr_etype_core(/* false */0, env, sigma, EConstr$ReactTemplate.of_constr(c));
}

function pr_ltype(t) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_ltype_env(match[1], match[0], t);
}

function pr_type(t) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_type_env(match[1], match[0], t);
}

function pr_etype_env(env, sigma, c) {
  return pr_etype_core(/* false */0, env, sigma, c);
}

function pr_letype_env(env, sigma, c) {
  return pr_letype_core(/* false */0, env, sigma, c);
}

function pr_goal_concl_style_env(env, sigma, c) {
  return pr_letype_core(/* true */1, env, sigma, c);
}

function pr_ljudge_env(env, sigma, j) {
  return /* tuple */[
          pr_leconstr_env(env, sigma, j[/* uj_val */0]),
          pr_leconstr_env(env, sigma, j[/* uj_type */1])
        ];
}

function pr_ljudge(j) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_ljudge_env(match[1], match[0], j);
}

function pr_lglob_constr_env(env, c) {
  return Ppconstr$ReactTemplate.pr_lconstr_expr(Constrextern$ReactTemplate.extern_glob_constr(Termops$ReactTemplate.vars_of_env(env), c));
}

function pr_glob_constr_env(env, c) {
  return Ppconstr$ReactTemplate.pr_constr_expr(Constrextern$ReactTemplate.extern_glob_constr(Termops$ReactTemplate.vars_of_env(env), c));
}

function pr_lglob_constr(c) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_lglob_constr_env(match[1], c);
}

function pr_glob_constr(c) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_glob_constr_env(match[1], c);
}

function pr_closed_glob_n_env(env, sigma, n, c) {
  return Ppconstr$ReactTemplate.pr_constr_expr_n(n, Constrextern$ReactTemplate.extern_closed_glob(/* None */0, /* false */0, env, sigma, c));
}

function pr_closed_glob_env(env, sigma, c) {
  return Ppconstr$ReactTemplate.pr_constr_expr(Constrextern$ReactTemplate.extern_closed_glob(/* None */0, /* false */0, env, sigma, c));
}

function pr_closed_glob(c) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_closed_glob_env(match[1], match[0], c);
}

function pr_lconstr_pattern_env(env, sigma, c) {
  return Ppconstr$ReactTemplate.pr_lconstr_pattern_expr(Constrextern$ReactTemplate.extern_constr_pattern(Termops$ReactTemplate.names_of_rel_context(env), sigma, c));
}

function pr_constr_pattern_env(env, sigma, c) {
  return Ppconstr$ReactTemplate.pr_constr_pattern_expr(Constrextern$ReactTemplate.extern_constr_pattern(Termops$ReactTemplate.names_of_rel_context(env), sigma, c));
}

function pr_cases_pattern(t) {
  return Ppconstr$ReactTemplate.pr_cases_pattern_expr(Constrextern$ReactTemplate.extern_cases_pattern(Names$ReactTemplate.Id[/* Set */9][/* empty */0], t));
}

function pr_lconstr_pattern(t) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_lconstr_pattern_env(match[1], match[0], t);
}

function pr_constr_pattern(t) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_constr_pattern_env(match[1], match[0], t);
}

function pr_sort(sigma, s) {
  return Ppconstr$ReactTemplate.pr_glob_sort(Constrextern$ReactTemplate.extern_sort(sigma, s));
}

Termops$ReactTemplate.set_print_constr((function (env, sigma, t) {
        return Ppconstr$ReactTemplate.pr_lconstr_expr(Constrextern$ReactTemplate.extern_constr(/* Some */[/* true */1], /* false */0, env, sigma, t));
      }));

function pr_in_comment(pr, x) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(* "), Curry._1(pr, x)), Pp$ReactTemplate.str(" *)"));
}

function id_of_global(env, param) {
  switch (param.tag | 0) {
    case 0 : 
        return param[0];
    case 1 : 
        return Names$ReactTemplate.Label[/* to_id */6](Names$ReactTemplate.Constant[/* label */8](param[0]));
    case 2 : 
        var match = param[0];
        var i = match[1];
        var kn = match[0];
        if (i !== 0) {
          return Caml_array.caml_array_get(Environ$ReactTemplate.lookup_mind(kn, env)[/* mind_packets */0], i)[/* mind_typename */0];
        } else {
          return Names$ReactTemplate.Label[/* to_id */6](Names$ReactTemplate.MutInd[/* label */8](kn));
        }
    case 3 : 
        var match$1 = param[0];
        var match$2 = match$1[0];
        return Caml_array.caml_array_get(Caml_array.caml_array_get(Environ$ReactTemplate.lookup_mind(match$2[0], env)[/* mind_packets */0], match$2[1])[/* mind_consnames */3], match$1[1] - 1 | 0);
    
  }
}

function dirpath_of_mp(param) {
  switch (param.tag | 0) {
    case 0 : 
        return param[0];
    case 1 : 
        return Names$ReactTemplate.DirPath[/* make */3](/* :: */[
                    Names$ReactTemplate.MBId[/* to_id */5](param[0]),
                    /* [] */0
                  ]);
    case 2 : 
        return Libnames$ReactTemplate.add_dirpath_suffix(dirpath_of_mp(param[0]), Names$ReactTemplate.Label[/* to_id */6](param[1]));
    
  }
}

function dirpath_of_global(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Names$ReactTemplate.DirPath[/* empty */5];
    case 1 : 
        return dirpath_of_mp(Names$ReactTemplate.Constant[/* modpath */7](param[0]));
    case 2 : 
        return dirpath_of_mp(Names$ReactTemplate.MutInd[/* modpath */7](param[0][0]));
    case 3 : 
        return dirpath_of_mp(Names$ReactTemplate.MutInd[/* modpath */7](param[0][0][0]));
    
  }
}

function qualid_of_global(env, r) {
  return Libnames$ReactTemplate.make_qualid(dirpath_of_global(r), id_of_global(env, r));
}

function safe_gen(f, env, sigma, c) {
  var orig_extern_ref = Constrextern$ReactTemplate.get_extern_reference(/* () */0);
  var extern_ref = function (loc, vars, r) {
    try {
      return Curry._3(orig_extern_ref, /* None */0, vars, r);
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (CErrors$ReactTemplate.noncritical(e)) {
        return CAst$ReactTemplate.make(loc, /* Qualid */Block.__(0, [qualid_of_global(env, r)]));
      } else {
        throw e;
      }
    }
  };
  Constrextern$ReactTemplate.set_extern_reference(extern_ref);
  try {
    var p = Curry._3(f, env, sigma, c);
    Constrextern$ReactTemplate.set_extern_reference(orig_extern_ref);
    return p;
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      Constrextern$ReactTemplate.set_extern_reference(orig_extern_ref);
      return Pp$ReactTemplate.str("??");
    } else {
      throw e;
    }
  }
}

function safe_pr_lconstr_env(param, param$1, param$2) {
  return safe_gen(pr_lconstr_env, param, param$1, param$2);
}

function safe_pr_constr_env(param, param$1, param$2) {
  return safe_gen(pr_constr_env, param, param$1, param$2);
}

function safe_pr_lconstr(t) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return safe_pr_lconstr_env(match[1], match[0], t);
}

function safe_pr_constr(t) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return safe_pr_constr_env(match[1], match[0], t);
}

function pr_universe_ctx_set(sigma, c) {
  if (Detyping$ReactTemplate.print_universes[0] && !Univ$ReactTemplate.ContextSet[/* is_empty */1](c)) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), pr_in_comment((function (c) {
                      return Pp$ReactTemplate.v(0, Univ$ReactTemplate.pr_universe_context_set(Termops$ReactTemplate.pr_evd_level(sigma), c));
                    }), c));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_universe_ctx(sigma, variance, c) {
  if (Detyping$ReactTemplate.print_universes[0] && !Univ$ReactTemplate.UContext[/* is_empty */2](c)) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), pr_in_comment((function (c) {
                      return Pp$ReactTemplate.v(0, Univ$ReactTemplate.pr_universe_context(Termops$ReactTemplate.pr_evd_level(sigma), variance, c));
                    }), c));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_constant_universes(sigma, param) {
  if (param.tag) {
    return pr_universe_ctx(sigma, /* None */0, param[0]);
  } else {
    return pr_universe_ctx_set(sigma, param[0]);
  }
}

function pr_cumulativity_info(sigma, cumi) {
  if (Detyping$ReactTemplate.print_universes[0] && !Univ$ReactTemplate.UContext[/* is_empty */2](Univ$ReactTemplate.CumulativityInfo[/* univ_context */3](cumi))) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), pr_in_comment((function (uii) {
                      return Pp$ReactTemplate.v(0, Univ$ReactTemplate.pr_cumulativity_info(Termops$ReactTemplate.pr_evd_level(sigma), uii));
                    }), cumi));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

var partial_arg = Names$ReactTemplate.Id[/* Set */9][/* empty */0];

function pr_global(param) {
  return Nametab$ReactTemplate.pr_global_env(partial_arg, param);
}

function pr_puniverses(f, env, param) {
  return Pp$ReactTemplate.$plus$plus(Curry._2(f, env, param[0]), Constrextern$ReactTemplate.print_universes[0] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(*"), Univ$ReactTemplate.Instance[/* pr */11](Universes$ReactTemplate.pr_with_global_universes, /* None */0)(param[1])), Pp$ReactTemplate.str("*)")) : Pp$ReactTemplate.mt(/* () */0));
}

function pr_constant(env, cst) {
  return Nametab$ReactTemplate.pr_global_env(Termops$ReactTemplate.vars_of_env(env), /* ConstRef */Block.__(1, [cst]));
}

function pr_existential(env, sigma, ev) {
  return pr_lconstr_env(env, sigma, Constr$ReactTemplate.mkEvar(ev));
}

function pr_inductive(env, ind) {
  return pr_lconstr_env(env, Evd$ReactTemplate.empty, Constr$ReactTemplate.mkInd(ind));
}

function pr_constructor(env, cstr) {
  return pr_lconstr_env(env, Evd$ReactTemplate.empty, Constr$ReactTemplate.mkConstruct(cstr));
}

function pr_pconstant(param, param$1) {
  return pr_puniverses(pr_constant, param, param$1);
}

function pr_pinductive(param, param$1) {
  return pr_puniverses(pr_inductive, param, param$1);
}

function pr_pconstructor(param, param$1) {
  return pr_puniverses(pr_constructor, param, param$1);
}

function pr_evaluable_reference(ref) {
  return pr_global(Tacred$ReactTemplate.global_of_evaluable_reference(ref));
}

var compact_context = [/* false */0];

function match_000() {
  return compact_context[0];
}

function match_001(b) {
  compact_context[0] = b;
  return /* () */0;
}

var get_compact_context = match_000;

function pr_compacted_decl(env, sigma, decl) {
  var match;
  if (decl.tag) {
    var c = decl[1];
    var pb = pr_lconstr_env(env, sigma, c);
    var pb$1 = Constr$ReactTemplate.isCast(c) ? Pp$ReactTemplate.surround(pb) : pb;
    match = /* tuple */[
      decl[0],
      Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" := "), pb$1), Pp$ReactTemplate.cut(/* () */0)),
      decl[2]
    ];
  } else {
    match = /* tuple */[
      decl[0],
      Pp$ReactTemplate.mt(/* () */0),
      decl[1]
    ];
  }
  var pids = Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Ppconstr$ReactTemplate.pr_id, match[0]);
  var pt = pr_ltype_env(env, sigma, match[2]);
  var ptyp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" : "), pt);
  return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pids, match[1]), ptyp));
}

function pr_named_decl(env, sigma, decl) {
  return pr_compacted_decl(env, sigma, Curry._1(Context$ReactTemplate.Compacted[/* Declaration */0][/* of_named_decl */1], decl));
}

function pr_rel_decl(env, sigma, decl) {
  var na = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
  var typ = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl);
  var pbody;
  if (decl.tag) {
    var c = decl[1];
    var pb = pr_lconstr_env(env, sigma, c);
    var pb$1 = Constr$ReactTemplate.isCast(c) ? Pp$ReactTemplate.surround(pb) : pb;
    pbody = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":="), Pp$ReactTemplate.spc(/* () */0)), pb$1), Pp$ReactTemplate.spc(/* () */0));
  } else {
    pbody = Pp$ReactTemplate.mt(/* () */0);
  }
  var ptyp = pr_ltype_env(env, sigma, typ);
  if (na) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_id(na[0]), Pp$ReactTemplate.spc(/* () */0)), pbody), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), ptyp));
  } else {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("<>"), Pp$ReactTemplate.spc(/* () */0)), pbody), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), ptyp));
  }
}

function pr_named_context_of(env, sigma) {
  var make_decl_list = function (env, d, pps) {
    return /* :: */[
            pr_named_decl(env, sigma, d),
            pps
          ];
  };
  var psl = Curry._1(Util$ReactTemplate.List[/* rev */4], Environ$ReactTemplate.fold_named_context(make_decl_list, env, /* [] */0));
  return Pp$ReactTemplate.hv(0, Pp$ReactTemplate.prlist_with_sep((function () {
                    return Pp$ReactTemplate.ws(2);
                  }), (function (x) {
                    return x;
                  }), psl));
}

function pr_var_list_decl(env, sigma, decl) {
  return Pp$ReactTemplate.hov(0, pr_compacted_decl(env, sigma, decl));
}

function pr_named_context(env, sigma, ne_context) {
  return Pp$ReactTemplate.hv(0, Context$ReactTemplate.Named[/* fold_outside */9]((function (d, pps) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.ws(2)), pr_named_decl(env, sigma, d));
                  }), ne_context, Pp$ReactTemplate.mt(/* () */0)));
}

function pr_rel_context(env, sigma, rel_context) {
  var rel_context$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
          return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
        }), rel_context);
  return Ppconstr$ReactTemplate.pr_binders(Constrextern$ReactTemplate.extern_rel_context(/* None */0, env, sigma, rel_context$1));
}

function pr_rel_context_of(env, sigma) {
  return pr_rel_context(env, sigma, Environ$ReactTemplate.rel_context(env));
}

function pr_context_unlimited(env, sigma) {
  var sign_env = Context$ReactTemplate.Compacted[/* fold */1]((function (d, pps) {
          var pidt = pr_compacted_decl(env, sigma, d);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.fnl(/* () */0)), pidt);
        }), Termops$ReactTemplate.compact_named_context(Environ$ReactTemplate.named_context(env)), Pp$ReactTemplate.mt(/* () */0));
  var db_env = Environ$ReactTemplate.fold_rel_context((function (env, d, pps) {
          var pnat = pr_rel_decl(env, sigma, d);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.fnl(/* () */0)), pnat);
        }), env, Pp$ReactTemplate.mt(/* () */0));
  return Pp$ReactTemplate.$plus$plus(sign_env, db_env);
}

function pr_ne_context_of(header, env, sigma) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], Environ$ReactTemplate.rel_context(env)) && Curry._1(Util$ReactTemplate.List[/* is_empty */45], Environ$ReactTemplate.named_context(env))) {
    return Pp$ReactTemplate.mt(/* () */0);
  } else {
    var penv = pr_context_unlimited(env, sigma);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(header, penv), Pp$ReactTemplate.fnl(/* () */0));
  }
}

function should_compact(env, sigma, typ) {
  if (Curry._1(get_compact_context, /* () */0)) {
    var type_of_typ = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, EConstr$ReactTemplate.of_constr(typ));
    return 1 - Constr$ReactTemplate.is_Prop(EConstr$ReactTemplate.to_constr(sigma, type_of_typ));
  } else {
    return /* false */0;
  }
}

function bld_sign_env(env, sigma, _ctxt, _pps) {
  while(true) {
    var pps = _pps;
    var ctxt = _ctxt;
    if (ctxt) {
      var d = ctxt[0];
      var exit = 0;
      if (d.tag) {
        exit = 1;
      } else if (should_compact(env, sigma, d[1])) {
        var match = bld_sign_env_id(env, sigma, ctxt, Pp$ReactTemplate.mt(/* () */0), /* true */1);
        _pps = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.brk(/* tuple */[
                      0,
                      0
                    ])), Pp$ReactTemplate.hov(0, match[0]));
        _ctxt = match[1];
        continue ;
        
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var pidt = pr_var_list_decl(env, sigma, d);
        var pps$prime = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.brk(/* tuple */[
                      0,
                      0
                    ])), pidt);
        _pps = pps$prime;
        _ctxt = ctxt[1];
        continue ;
        
      }
      
    } else {
      return pps;
    }
  };
}

function bld_sign_env_id(env, sigma, _ctxt, _pps, _is_start) {
  while(true) {
    var is_start = _is_start;
    var pps = _pps;
    var ctxt = _ctxt;
    if (ctxt) {
      var d = ctxt[0];
      if (d.tag) {
        return /* tuple */[
                pps,
                ctxt
              ];
      } else if (should_compact(env, sigma, d[1])) {
        var pidt = pr_var_list_decl(env, sigma, d);
        var pps$prime = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, is_start ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.brk(/* tuple */[
                        3,
                        0
                      ])), pidt);
        _is_start = /* false */0;
        _pps = pps$prime;
        _ctxt = ctxt[1];
        continue ;
        
      } else {
        return /* tuple */[
                pps,
                ctxt
              ];
      }
    } else {
      return /* tuple */[
              pps,
              ctxt
            ];
    }
  };
}

function pr_context_limit_compact(n, env, sigma) {
  var ctxt = Termops$ReactTemplate.compact_named_context(Environ$ReactTemplate.named_context(env));
  var lgth = Curry._1(Util$ReactTemplate.List[/* length */0], ctxt);
  var n_capped;
  if (n) {
    var n$1 = n[0];
    n_capped = n$1 > lgth ? lgth : n$1;
  } else {
    n_capped = lgth;
  }
  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], n_capped, ctxt);
  var hidden_dots = Curry._2(Util$ReactTemplate.$$String[/* make */0], Curry._1(Util$ReactTemplate.List[/* length */0], match[1]), /* "." */46);
  var sign_env = Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(hidden_dots), Pp$ReactTemplate.mt(/* () */0)), bld_sign_env(env, sigma, Curry._1(Util$ReactTemplate.List[/* rev */4], match[0]), Pp$ReactTemplate.mt(/* () */0))));
  var db_env = Environ$ReactTemplate.fold_rel_context((function (env, d, pps) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.fnl(/* () */0)), pr_rel_decl(env, sigma, d));
        }), env, Pp$ReactTemplate.mt(/* () */0));
  return Pp$ReactTemplate.$plus$plus(sign_env, db_env);
}

var print_hyps_limit = [/* None */0];

Goptions$ReactTemplate.declare_int_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"the hypotheses limit",
      /* optkey : :: */[
        "Hyps",
        /* :: */[
          "Limit",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return print_hyps_limit[0];
        }),
      /* optwrite */(function (x) {
          print_hyps_limit[0] = x;
          return /* () */0;
        })
    ]);

function pr_context_of(env, sigma) {
  var match = print_hyps_limit[0];
  if (match) {
    return Pp$ReactTemplate.hv(0, pr_context_limit_compact(/* Some */[match[0]], env, sigma));
  } else {
    return Pp$ReactTemplate.hv(0, pr_context_limit_compact(/* None */0, env, sigma));
  }
}

function pr_predicate(pr_elt, param) {
  var elts = param[1];
  var pr_elts = Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_elt, elts);
  if (param[0]) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("all"), Curry._1(Util$ReactTemplate.List[/* is_empty */45], elts) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" except: "), pr_elts));
  } else if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], elts)) {
    return Pp$ReactTemplate.str("none");
  } else {
    return pr_elts;
  }
}

function pr_cpred(p) {
  var partial_arg = Global$ReactTemplate.env(/* () */0);
  return pr_predicate((function (param) {
                return pr_constant(partial_arg, param);
              }), Curry._1(Names$ReactTemplate.Cpred[/* elements */14], p));
}

function pr_idpred(p) {
  return pr_predicate(Names$ReactTemplate.Id[/* print */8], Curry._1(Names$ReactTemplate.Id[/* Pred */11][/* elements */14], p));
}

function pr_transparent_state(param) {
  return Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("VARIABLES: "), pr_idpred(param[0])), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("CONSTANTS: ")), pr_cpred(param[1])), Pp$ReactTemplate.fnl(/* () */0)));
}

function default_pr_goal(gs) {
  var g = Refiner$ReactTemplate.sig_it(gs);
  var sigma = Refiner$ReactTemplate.project(gs);
  var env = Goal$ReactTemplate.V82[/* env */0](sigma, g);
  var concl = Goal$ReactTemplate.V82[/* concl */3](sigma, g);
  var goal = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_context_of(env, sigma), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str("============================")), Pp$ReactTemplate.cut(/* () */0)), pr_goal_concl_style_env(env, sigma, concl));
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("  "), Pp$ReactTemplate.v(0, goal));
}

function pr_goal_tag(g) {
  return Pp$ReactTemplate.str(" (ID " + (Goal$ReactTemplate.uid(g) + ")"));
}

function pr_goal_name(sigma, g) {
  if (enable_goal_names_printing[0]) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" "), Pp$ReactTemplate.surround(Termops$ReactTemplate.pr_existential_key(sigma, g)));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_goal_header(nme, sigma, g) {
  var match = Goal$ReactTemplate.V82[/* nf_evar */11](sigma, g);
  var g$1 = match[0];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("subgoal "), nme), enable_goal_tags_printing[0] ? pr_goal_tag(g$1) : Pp$ReactTemplate.str("")), enable_goal_names_printing[0] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" "), Pp$ReactTemplate.surround(Termops$ReactTemplate.pr_existential_key(match[1], g$1))) : Pp$ReactTemplate.mt(/* () */0));
}

function pr_concl(n, sigma, g) {
  var match = Goal$ReactTemplate.V82[/* nf_evar */11](sigma, g);
  var sigma$1 = match[1];
  var g$1 = match[0];
  var env = Goal$ReactTemplate.V82[/* env */0](sigma$1, g$1);
  var pc = pr_goal_concl_style_env(env, sigma$1, Goal$ReactTemplate.V82[/* concl */3](sigma$1, g$1));
  var header = pr_goal_header(Pp$ReactTemplate.$$int(n), sigma$1, g$1);
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(header, Pp$ReactTemplate.str(" is:")), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str(" ")), pc);
}

function pr_evgl_sign(sigma, evi) {
  var env = Evd$ReactTemplate.evar_env(evi);
  var ps = pr_named_context_of(env, sigma);
  var match = Evd$ReactTemplate.Filter[/* repr */10](Evd$ReactTemplate.evar_filter(evi));
  var match$1 = match ? Curry._3(Util$ReactTemplate.List[/* filter2 */61], (function (b, _) {
            return 1 - b;
          }), match[0], Evd$ReactTemplate.evar_context(evi)) : /* tuple */[
      /* [] */0,
      /* [] */0
    ];
  var ids = Curry._2(Util$ReactTemplate.List[/* rev_map */12], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], match$1[1]);
  var warn = Curry._1(Util$ReactTemplate.List[/* is_empty */45], ids) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" ("), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Ppconstr$ReactTemplate.pr_id, ids)), Pp$ReactTemplate.str(" cannot be used)"));
  var pc = pr_lconstr_env(env, sigma, evi[/* evar_concl */0]);
  var match$2 = evi[/* evar_body */2];
  var match$3 = evi[/* evar_candidates */5];
  var candidates = match$2 || !match$3 ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("= {")), Pp$ReactTemplate.prlist_with_sep((function () {
                    return Pp$ReactTemplate.str("|");
                  }), (function (param) {
                    return pr_lconstr_env(env, sigma, param);
                  }), match$3[0])), Pp$ReactTemplate.str("}"));
  return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), ps), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("|- ")), pc), Pp$ReactTemplate.str("]")), candidates), warn));
}

function pr_evar(sigma, param) {
  var pegl = pr_evgl_sign(sigma, param[1]);
  return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Termops$ReactTemplate.pr_existential_key(sigma, param[0]), Pp$ReactTemplate.str(" : ")), pegl));
}

function pr_evars_int_hd(pr, sigma, i, param) {
  if (param) {
    var rest = param[1];
    var match = param[0];
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Curry._3(pr, i, match[0], match[1])), rest ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), pr_evars_int_hd(pr, sigma, i + 1 | 0, rest)) : Pp$ReactTemplate.mt(/* () */0));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_evars_int(sigma, shelf, givenup, i, evs) {
  var pr_status = function (i) {
    if (Curry._2(Util$ReactTemplate.List[/* mem */24], i, shelf)) {
      return Pp$ReactTemplate.str(" (shelved)");
    } else if (Curry._2(Util$ReactTemplate.List[/* mem */24], i, givenup)) {
      return Pp$ReactTemplate.str(" (given up)");
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  };
  return pr_evars_int_hd((function (i, evk, evi) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Existential "), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(" =")), Pp$ReactTemplate.spc(/* () */0)), pr_evar(sigma, /* tuple */[
                                    evk,
                                    evi
                                  ])), pr_status(evk));
              }), sigma, i, Curry._1(Evar$ReactTemplate.$$Map[/* bindings */16], evs));
}

function pr_evars(sigma, evs) {
  return pr_evars_int_hd((function (_, evk, evi) {
                return pr_evar(sigma, /* tuple */[
                            evk,
                            evi
                          ]);
              }), sigma, 1, Curry._1(Evar$ReactTemplate.$$Map[/* bindings */16], evs));
}

function pr_ne_evar_set(hd, tl, sigma, l) {
  if (l !== Evar$ReactTemplate.$$Set[/* empty */0]) {
    var l$1 = Curry._3(Evar$ReactTemplate.$$Set[/* fold */13], (function (ev) {
            return Curry._2(Evar$ReactTemplate.$$Map[/* add */3], ev, Evarutil$ReactTemplate.nf_evar_info(sigma, Evd$ReactTemplate.find(sigma, ev)));
          }), l, Evar$ReactTemplate.$$Map[/* empty */0]);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(hd, pr_evars(sigma, l$1)), tl);
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_selected_subgoal(name, sigma, g) {
  var pg = default_pr_goal(/* record */[
        /* it */g,
        /* sigma */sigma
      ]);
  var header = pr_goal_header(name, sigma, g);
  return Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(header, Pp$ReactTemplate.str(" is:")), Pp$ReactTemplate.cut(/* () */0)), pg));
}

function default_pr_subgoal(n, sigma) {
  return (function (param) {
      var _p = n;
      var _param = param;
      while(true) {
        var param$1 = _param;
        var p = _p;
        if (param$1) {
          if (p === 1) {
            return pr_selected_subgoal(Pp$ReactTemplate.$$int(n), sigma, param$1[0]);
          } else {
            _param = param$1[1];
            _p = p - 1 | 0;
            continue ;
            
          }
        } else {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such goal."));
        }
      };
    });
}

function print_evar_constraints(gl, sigma) {
  var pr_env;
  if (gl) {
    var env = Goal$ReactTemplate.V82[/* env */0](sigma, gl[0]);
    pr_env = (function (e$prime) {
        if (Curry._1(Context$ReactTemplate.Named[/* equal */5](Constr$ReactTemplate.equal, Environ$ReactTemplate.named_context(env)), Environ$ReactTemplate.named_context(e$prime))) {
          if (Curry._1(Context$ReactTemplate.Rel[/* equal */4](Constr$ReactTemplate.equal, Environ$ReactTemplate.rel_context(env)), Environ$ReactTemplate.rel_context(e$prime))) {
            return Pp$ReactTemplate.mt(/* () */0);
          } else {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_rel_context_of(e$prime, sigma), Pp$ReactTemplate.str(" |-")), Pp$ReactTemplate.spc(/* () */0));
          }
        } else {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_context_of(e$prime, sigma), Pp$ReactTemplate.str(" |-")), Pp$ReactTemplate.spc(/* () */0));
        }
      });
  } else {
    pr_env = (function (e$prime) {
        return pr_context_of(e$prime, sigma);
      });
  }
  var pr_evconstr = function (param) {
    var t1 = Evarutil$ReactTemplate.nf_evar(sigma, EConstr$ReactTemplate.of_constr(param[2]));
    var t2 = Evarutil$ReactTemplate.nf_evar(sigma, EConstr$ReactTemplate.of_constr(param[3]));
    var env = Namegen$ReactTemplate.make_all_name_different(param[1], sigma);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" "), Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(pr_env, env), pr_leconstr_env(env, sigma, t1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(param[0] !== 0 ? "<=" : "==")), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env, sigma, t2))));
  };
  var pr_candidate = function (ev, evi, param) {
    var acc = param[1];
    var candidates = param[0];
    if (Option$ReactTemplate.has_some(evi[/* evar_candidates */5])) {
      return /* tuple */[
              candidates + 1 | 0,
              Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(acc, pr_evar(sigma, /* tuple */[
                            ev,
                            evi
                          ])), Pp$ReactTemplate.fnl(/* () */0))
            ];
    } else {
      return /* tuple */[
              candidates,
              acc
            ];
    }
  };
  var match = Evd$ReactTemplate.extract_all_conv_pbs(sigma);
  var cstrs = match[1];
  var constraints = Curry._1(Util$ReactTemplate.List[/* is_empty */45], cstrs) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], Curry._1(Util$ReactTemplate.List[/* length */0], cstrs), "unification constraint"))), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, pr_evconstr, cstrs)));
  var match$1 = Evd$ReactTemplate.fold_undefined(pr_candidate, sigma, /* tuple */[
        0,
        Pp$ReactTemplate.mt(/* () */0)
      ]);
  var candidates = match$1[0];
  return Pp$ReactTemplate.$plus$plus(constraints, candidates > 0 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], candidates, "existential"))), Pp$ReactTemplate.str(" with candidates:")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(0, match$1[1])) : Pp$ReactTemplate.mt(/* () */0));
}

var should_print_dependent_evars = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"Printing Dependent Evars Line",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Dependent",
          /* :: */[
            "Evars",
            /* :: */[
              "Line",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */(function () {
          return should_print_dependent_evars[0];
        }),
      /* optwrite */(function (v) {
          should_print_dependent_evars[0] = v;
          return /* () */0;
        })
    ]);

function print_dependent_evars(gl, sigma, seeds) {
  var constraints = print_evar_constraints(gl, sigma);
  var evars = function () {
    if (should_print_dependent_evars[0]) {
      var evars$1 = Evarutil$ReactTemplate.gather_dependent_evars(sigma, seeds);
      var evars$2 = Curry._3(Evar$ReactTemplate.$$Map[/* fold */10], (function (e, i, s) {
              var e$prime = Evar$ReactTemplate.print(e);
              if (i) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(s, Pp$ReactTemplate.str(" ")), e$prime), Pp$ReactTemplate.str(" using ")), Curry._3(Evar$ReactTemplate.$$Set[/* fold */13], (function (d, s) {
                                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Evar$ReactTemplate.print(d), Pp$ReactTemplate.str(" ")), s);
                                }), i[0], Pp$ReactTemplate.str(",")));
              } else {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(s, Pp$ReactTemplate.str(" ")), e$prime), Pp$ReactTemplate.str(" open,"));
              }
            }), evars$1, Pp$ReactTemplate.str(""));
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.cut(/* () */0), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str("(dependent evars:")), evars$2), Pp$ReactTemplate.str(")"));
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  };
  return Pp$ReactTemplate.$plus$plus(constraints, evars(/* () */0));
}

function default_pr_subgoals($staropt$star, close_cmd, sigma, seeds, shelf, stack, unfocused, goals) {
  var pr_first = $staropt$star ? $staropt$star[0] : /* true */1;
  var print_stack = function (a, param) {
    if (param) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(a), Pp$ReactTemplate.str("-")), print_stack(param[0], param[1]));
    } else {
      return Pp$ReactTemplate.$$int(a);
    }
  };
  var print_unfocused_nums = function (l) {
    if (l) {
      return /* Some */[Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("unfocused: "), print_stack(l[0], l[1]))];
    } else {
      return /* None */0;
    }
  };
  var print_shelf = function (l) {
    if (l) {
      return /* Some */[Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("shelved: "), Pp$ReactTemplate.$$int(Curry._1(Util$ReactTemplate.List[/* length */0], l)))];
    } else {
      return /* None */0;
    }
  };
  var print_comma_separated_list = function (_a, _l) {
    while(true) {
      var l = _l;
      var a = _a;
      if (l) {
        _l = l[1];
        _a = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(a, Pp$ReactTemplate.str(", ")), l[0]);
        continue ;
        
      } else {
        return a;
      }
    };
  };
  var print_extra_list = function (l) {
    if (l) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("(")), print_comma_separated_list(l[0], l[1])), Pp$ReactTemplate.str(")"));
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  };
  var extra = Option$ReactTemplate.List[/* flatten */1](/* :: */[
        print_unfocused_nums(stack),
        /* :: */[
          print_shelf(shelf),
          /* [] */0
        ]
      ]);
  var print_extra = print_extra_list(extra);
  var needed = 1 - CList$ReactTemplate.is_empty(extra) && pr_first;
  var focused_if_needed = needed ? Pp$ReactTemplate.str(" focused ") : Pp$ReactTemplate.str(" ");
  var pr_rec = function (n, param) {
    if (param) {
      var pc = pr_concl(n, sigma, param[0]);
      var prest = pr_rec(n + 1 | 0, param[1]);
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.cut(/* () */0), pc), prest);
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  };
  var print_multiple_goals = function (g, l) {
    if (pr_first) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(default_pr_goal(/* record */[
                          /* it */g,
                          /* sigma */sigma
                        ]), l ? Pp$ReactTemplate.cut(/* () */0) : Pp$ReactTemplate.mt(/* () */0)), pr_rec(2, l));
    } else {
      return pr_rec(1, /* :: */[
                  g,
                  l
                ]);
    }
  };
  if (close_cmd) {
    Feedback$ReactTemplate.msg_info(/* None */0, close_cmd[0]);
  }
  if (goals) {
    var rest = goals[1];
    var g1 = goals[0];
    var goals$1 = print_multiple_goals(g1, rest);
    var ngoals = Curry._1(Util$ReactTemplate.List[/* length */0], rest) + 1 | 0;
    return Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(ngoals), focused_if_needed), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], ngoals, "subgoal"))), print_extra), Pp$ReactTemplate.str(enable_goal_names_printing[0] ? ", subgoal 1" : "")), enable_goal_tags_printing[0] ? pr_goal_tag(g1) : Pp$ReactTemplate.str("")), pr_goal_name(sigma, g1)), Pp$ReactTemplate.cut(/* () */0)), goals$1), unfocused ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.cut(/* () */0), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str("*** Unfocused goals:")), Pp$ReactTemplate.cut(/* () */0)), pr_rec(Curry._1(Util$ReactTemplate.List[/* length */0], rest) + 2 | 0, unfocused)) : Pp$ReactTemplate.str("")), print_dependent_evars(/* Some */[g1], sigma, seeds)));
  } else {
    var exl = Evd$ReactTemplate.undefined_map(sigma);
    if (Curry._1(Evar$ReactTemplate.$$Map[/* is_empty */1], exl)) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No more subgoals."), print_dependent_evars(/* None */0, sigma, seeds));
    } else {
      var pei = pr_evars_int(sigma, shelf, /* [] */0, 1, exl);
      return Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No more subgoals,"), Pp$ReactTemplate.str(" but there are non-instantiated existential variables:")), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.hov(0, pei)), print_dependent_evars(/* None */0, sigma, seeds)), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str("You can use Grab Existential Variables.")));
    }
  }
}

var default_printer_pr = /* record */[
  /* pr_subgoals */default_pr_subgoals,
  /* pr_subgoal */default_pr_subgoal,
  /* pr_goal */default_pr_goal
];

var printer_pr = [default_printer_pr];

function set_printer_pr(param) {
  printer_pr[0] = param;
  return /* () */0;
}

function pr_subgoals(pr_first, x) {
  return Curry._2(printer_pr[0][/* pr_subgoals */0], pr_first, x);
}

function pr_subgoal(x) {
  return Curry._1(printer_pr[0][/* pr_subgoal */1], x);
}

function pr_goal(x) {
  return Curry._1(printer_pr[0][/* pr_goal */2], x);
}

function pr_open_subgoals(proof) {
  var match = Proof$ReactTemplate.proof(proof);
  var given_up = match[3];
  var shelf = match[2];
  var goals = match[0];
  var stack = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return Curry._1(Util$ReactTemplate.List[/* length */0], param[0]) + Curry._1(Util$ReactTemplate.List[/* length */0], param[1]) | 0;
        }), match[1]);
  var seeds = Proof$ReactTemplate.V82[/* top_evars */3](proof);
  if (goals) {
    var match$1 = Proof$ReactTemplate.V82[/* background_subgoals */1](proof);
    var match$2 = Curry._2(Util$ReactTemplate.List[/* partition */29], (function (x) {
            return Curry._2(Util$ReactTemplate.List[/* mem */24], x, goals);
          }), match$1[/* it */0]);
    var unfocused_if_needed = enable_unfocused_goal_printing[0] ? match$2[1] : /* [] */0;
    return Curry._6(pr_subgoals(/* Some */[/* true */1], /* None */0), match$1[/* sigma */1], seeds, shelf, /* [] */0, unfocused_if_needed, match$2[0]);
  } else {
    var match$3 = Proof$ReactTemplate.V82[/* background_subgoals */1](proof);
    var bsigma = match$3[/* sigma */1];
    var bgoals = match$3[/* it */0];
    if (bgoals) {
      var s = Proof_bullet$ReactTemplate.suggest(proof);
      var end_cmd = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("This subproof is complete, but there are some unfocused goals."), Pp$ReactTemplate.ismt(s) ? s : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), s)), Pp$ReactTemplate.fnl(/* () */0));
      return Curry._6(pr_subgoals(/* Some */[/* false */0], /* Some */[end_cmd]), bsigma, seeds, shelf, /* [] */0, /* [] */0, bgoals);
    } else if (shelf) {
      Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.str("All the remaining goals are on the shelf."));
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Curry._6(pr_subgoals(/* Some */[/* false */0], /* None */0), bsigma, seeds, /* [] */0, /* [] */0, /* [] */0, shelf));
    } else if (given_up) {
      Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.str("No more subgoals, but there are some goals you gave up:"));
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Curry._6(pr_subgoals(/* Some */[/* false */0], /* None */0), bsigma, seeds, /* [] */0, /* [] */0, /* [] */0, given_up)), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("You need to go back and solve them."));
    } else {
      return Curry._6(pr_subgoals(/* None */0, /* None */0), match[4], seeds, shelf, stack, /* [] */0, goals);
    }
  }
}

function pr_nth_open_subgoal(proof, n) {
  var match = Proof$ReactTemplate.proof(proof);
  return Curry._2(pr_subgoal(n), match[4], match[0]);
}

function pr_goal_by_id(proof, id) {
  try {
    return Proof$ReactTemplate.in_proof(proof, (function (sigma) {
                  var g = Evd$ReactTemplate.evar_key(id, sigma);
                  return pr_selected_subgoal(Ppconstr$ReactTemplate.pr_id(id), sigma, g);
                }));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such goal."));
    } else {
      throw exn;
    }
  }
}

function pr_prim_rule(param) {
  var c = param[0];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(Termops$ReactTemplate.occur_meta(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(c)) ? "refine " : "exact "), Constrextern$ReactTemplate.with_meta_as_hole(pr_constr)(c));
}

function compare(x, y) {
  switch (x.tag | 0) {
    case 0 : 
        if (y.tag) {
          return -1;
        } else {
          return Curry._2(Names$ReactTemplate.Id[/* compare */1], x[0], y[0]);
        }
        break;
    case 1 : 
        switch (y.tag | 0) {
          case 0 : 
              return 1;
          case 1 : 
              var x$1 = x[0];
              var y$1 = y[0];
              switch (x$1.tag | 0) {
                case 0 : 
                    switch (y$1.tag | 0) {
                      case 0 : 
                          return Curry._2(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], x$1[0], y$1[0]);
                      case 1 : 
                          return 1;
                      case 2 : 
                          return -1;
                      
                    }
                    break;
                case 1 : 
                    switch (y$1.tag | 0) {
                      case 0 : 
                          return 1;
                      case 1 : 
                          return Curry._2(Names$ReactTemplate.MutInd[/* CanOrd */9][/* compare */0], x$1[0], y$1[0]);
                      case 2 : 
                          return -1;
                      
                    }
                    break;
                case 2 : 
                    switch (y$1.tag | 0) {
                      case 0 : 
                      case 1 : 
                          return 1;
                      case 2 : 
                          return Curry._2(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], x$1[0], y$1[0]);
                      
                    }
                    break;
                
              }
          case 2 : 
          case 3 : 
              return -1;
          
        }
        break;
    case 2 : 
        switch (y.tag | 0) {
          case 0 : 
          case 1 : 
              return 1;
          case 2 : 
              return Curry._2(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], x[0], y[0]);
          case 3 : 
              return -1;
          
        }
        break;
    case 3 : 
        switch (y.tag | 0) {
          case 0 : 
          case 1 : 
          case 2 : 
              return 1;
          case 3 : 
              return Curry._2(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], x[0], y[0]);
          
        }
        break;
    
  }
}

var ContextObjectSet = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], [compare]);

var ContextObjectMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], [compare]);

function pr_assumptionset(env, sigma, s) {
  if (Curry._1(ContextObjectMap[/* is_empty */1], s) && Environ$ReactTemplate.engagement(env) === /* PredicativeSet */1) {
    return Pp$ReactTemplate.str("Closed under the global context");
  } else {
    var safe_pr_constant = function (env, kn) {
      try {
        return pr_constant(env, kn);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var match = Names$ReactTemplate.Constant[/* repr3 */6](kn);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(Names$ReactTemplate.ModPath[/* to_string */4](match[0])), Pp$ReactTemplate.str(".")), Names$ReactTemplate.Label[/* print */7](match[2]));
        } else {
          throw exn;
        }
      }
    };
    var safe_pr_ltype = function (typ) {
      try {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" : "), pr_ltype(typ));
      }
      catch (raw_e){
        var e = Js_exn.internalToOCamlException(raw_e);
        if (CErrors$ReactTemplate.noncritical(e)) {
          return Pp$ReactTemplate.mt(/* () */0);
        } else {
          throw e;
        }
      }
    };
    var safe_pr_ltype_relctx = function (param) {
      var env$1 = Environ$ReactTemplate.push_rel_context(param[0], env);
      try {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" "), pr_ltype_env(env$1, sigma, param[1]));
      }
      catch (raw_e){
        var e = Js_exn.internalToOCamlException(raw_e);
        if (CErrors$ReactTemplate.noncritical(e)) {
          return Pp$ReactTemplate.mt(/* () */0);
        } else {
          throw e;
        }
      }
    };
    var pr_axiom = function (env, ax, typ) {
      switch (ax.tag | 0) {
        case 0 : 
            return Pp$ReactTemplate.$plus$plus(safe_pr_constant(env, ax[0]), safe_pr_ltype(typ));
        case 1 : 
            return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.MutInd[/* print */15](ax[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.strbrk("is positive.")));
        case 2 : 
            return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(safe_pr_constant(env, ax[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.strbrk("is positive.")));
        
      }
    };
    var fold = function (t, typ, accu) {
      var tr = accu[3];
      var o = accu[2];
      var a = accu[1];
      var v = accu[0];
      switch (t.tag | 0) {
        case 0 : 
            var $$var = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_id(t[0]), Pp$ReactTemplate.str(" : ")), pr_ltype(typ));
            return /* tuple */[
                    /* :: */[
                      $$var,
                      v
                    ],
                    a,
                    o,
                    tr
                  ];
        case 1 : 
            var l = t[1];
            var axiom = t[0];
            if (l) {
              var ax = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_axiom(env, axiom, typ), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.cut, (function (param) {
                          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" used in "), Names$ReactTemplate.Label[/* print */7](param[0])), Pp$ReactTemplate.str(" to prove:")), safe_pr_ltype_relctx(/* tuple */[
                                          param[1],
                                          param[2]
                                        ]));
                        }), l));
              return /* tuple */[
                      v,
                      /* :: */[
                        ax,
                        a
                      ],
                      o,
                      tr
                    ];
            } else {
              var ax$1 = pr_axiom(env, axiom, typ);
              return /* tuple */[
                      v,
                      /* :: */[
                        ax$1,
                        a
                      ],
                      o,
                      tr
                    ];
            }
            break;
        case 2 : 
            var opq = Pp$ReactTemplate.$plus$plus(safe_pr_constant(env, t[0]), safe_pr_ltype(typ));
            return /* tuple */[
                    v,
                    a,
                    /* :: */[
                      opq,
                      o
                    ],
                    tr
                  ];
        case 3 : 
            var tran = Pp$ReactTemplate.$plus$plus(safe_pr_constant(env, t[0]), safe_pr_ltype(typ));
            return /* tuple */[
                    v,
                    a,
                    o,
                    /* :: */[
                      tran,
                      tr
                    ]
                  ];
        
      }
    };
    var match = Curry._3(ContextObjectMap[/* fold */10], fold, s, /* tuple */[
          /* [] */0,
          /* [] */0,
          /* [] */0,
          /* [] */0
        ]);
    var theory = Environ$ReactTemplate.is_impredicative_set(env) ? /* :: */[
        Pp$ReactTemplate.str("Set is impredicative"),
        /* [] */0
      ] : /* [] */0;
    var theory$1 = Environ$ReactTemplate.type_in_type(env) ? /* :: */[
        Pp$ReactTemplate.str("Type hierarchy is collapsed (logic is inconsistent)"),
        theory
      ] : theory;
    var opt_list = function (title, l) {
      if (l) {
        var section = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(title, Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.v(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (s) {
                        return s;
                      }), l)));
        return /* Some */[section];
      } else {
        return /* None */0;
      }
    };
    var assums_000 = opt_list(Pp$ReactTemplate.str("Transparent constants:"), match[3]);
    var assums_001 = /* :: */[
      opt_list(Pp$ReactTemplate.str("Section Variables:"), match[0]),
      /* :: */[
        opt_list(Pp$ReactTemplate.str("Axioms:"), match[1]),
        /* :: */[
          opt_list(Pp$ReactTemplate.str("Opaque constants:"), match[2]),
          /* :: */[
            opt_list(Pp$ReactTemplate.str("Theory:"), theory$1),
            /* [] */0
          ]
        ]
      ]
    ];
    var assums = /* :: */[
      assums_000,
      assums_001
    ];
    return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (x) {
                  return x;
                }), Option$ReactTemplate.List[/* flatten */1](assums));
  }
}

function xor(a, b) {
  if (a && !b) {
    return /* true */1;
  } else if (a) {
    return /* false */0;
  } else {
    return b;
  }
}

function pr_cumulative(poly, cum) {
  if (poly) {
    if (cum) {
      return Pp$ReactTemplate.str("Cumulative ");
    } else {
      return Pp$ReactTemplate.str("NonCumulative ");
    }
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_polymorphic(b) {
  var print = xor(Flags$ReactTemplate.is_universe_polymorphism(/* () */0), b);
  if (print) {
    if (b) {
      return Pp$ReactTemplate.str("Polymorphic ");
    } else {
      return Pp$ReactTemplate.str("Monomorphic ");
    }
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_universe_instance(evd, ctx) {
  var inst = Univ$ReactTemplate.UContext[/* instance */3](ctx);
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@{"), Univ$ReactTemplate.Instance[/* pr */11](Termops$ReactTemplate.pr_evd_level(evd), /* None */0)(inst)), Pp$ReactTemplate.str("}"));
}

var pr_global_env = Nametab$ReactTemplate.pr_global_env;

var pr_existential_key = Termops$ReactTemplate.pr_existential_key;

var set_compact_context = match_001;

var prterm = pr_lconstr;

exports.enable_unfocused_goal_printing = enable_unfocused_goal_printing;
exports.enable_goal_tags_printing = enable_goal_tags_printing;
exports.enable_goal_names_printing = enable_goal_names_printing;
exports.pr_lconstr_env = pr_lconstr_env;
exports.pr_lconstr = pr_lconstr;
exports.pr_lconstr_goal_style_env = pr_lconstr_goal_style_env;
exports.pr_constr_env = pr_constr_env;
exports.pr_constr = pr_constr;
exports.pr_constr_goal_style_env = pr_constr_goal_style_env;
exports.pr_constr_n_env = pr_constr_n_env;
exports.safe_pr_lconstr_env = safe_pr_lconstr_env;
exports.safe_pr_lconstr = safe_pr_lconstr;
exports.safe_pr_constr_env = safe_pr_constr_env;
exports.safe_pr_constr = safe_pr_constr;
exports.pr_econstr_env = pr_econstr_env;
exports.pr_econstr = pr_econstr;
exports.pr_leconstr_env = pr_leconstr_env;
exports.pr_leconstr = pr_leconstr;
exports.pr_econstr_n_env = pr_econstr_n_env;
exports.pr_etype_env = pr_etype_env;
exports.pr_letype_env = pr_letype_env;
exports.pr_open_constr_env = pr_open_constr_env;
exports.pr_open_constr = pr_open_constr;
exports.pr_open_lconstr_env = pr_open_lconstr_env;
exports.pr_open_lconstr = pr_open_lconstr;
exports.pr_constr_under_binders_env = pr_constr_under_binders_env;
exports.pr_constr_under_binders = pr_constr_under_binders;
exports.pr_lconstr_under_binders_env = pr_lconstr_under_binders_env;
exports.pr_lconstr_under_binders = pr_lconstr_under_binders;
exports.pr_goal_concl_style_env = pr_goal_concl_style_env;
exports.pr_ltype_env = pr_ltype_env;
exports.pr_ltype = pr_ltype;
exports.pr_type_env = pr_type_env;
exports.pr_type = pr_type;
exports.pr_closed_glob_n_env = pr_closed_glob_n_env;
exports.pr_closed_glob_env = pr_closed_glob_env;
exports.pr_closed_glob = pr_closed_glob;
exports.pr_ljudge_env = pr_ljudge_env;
exports.pr_ljudge = pr_ljudge;
exports.pr_lglob_constr_env = pr_lglob_constr_env;
exports.pr_lglob_constr = pr_lglob_constr;
exports.pr_glob_constr_env = pr_glob_constr_env;
exports.pr_glob_constr = pr_glob_constr;
exports.pr_lconstr_pattern_env = pr_lconstr_pattern_env;
exports.pr_lconstr_pattern = pr_lconstr_pattern;
exports.pr_constr_pattern_env = pr_constr_pattern_env;
exports.pr_constr_pattern = pr_constr_pattern;
exports.pr_cases_pattern = pr_cases_pattern;
exports.pr_sort = pr_sort;
exports.pr_polymorphic = pr_polymorphic;
exports.pr_cumulative = pr_cumulative;
exports.pr_universe_instance = pr_universe_instance;
exports.pr_universe_ctx = pr_universe_ctx;
exports.pr_universe_ctx_set = pr_universe_ctx_set;
exports.pr_constant_universes = pr_constant_universes;
exports.pr_cumulativity_info = pr_cumulativity_info;
exports.pr_global_env = pr_global_env;
exports.pr_global = pr_global;
exports.pr_constant = pr_constant;
exports.pr_existential_key = pr_existential_key;
exports.pr_existential = pr_existential;
exports.pr_constructor = pr_constructor;
exports.pr_inductive = pr_inductive;
exports.pr_evaluable_reference = pr_evaluable_reference;
exports.pr_pconstant = pr_pconstant;
exports.pr_pinductive = pr_pinductive;
exports.pr_pconstructor = pr_pconstructor;
exports.set_compact_context = set_compact_context;
exports.get_compact_context = get_compact_context;
exports.pr_context_unlimited = pr_context_unlimited;
exports.pr_ne_context_of = pr_ne_context_of;
exports.pr_named_decl = pr_named_decl;
exports.pr_compacted_decl = pr_compacted_decl;
exports.pr_rel_decl = pr_rel_decl;
exports.pr_named_context = pr_named_context;
exports.pr_named_context_of = pr_named_context_of;
exports.pr_rel_context = pr_rel_context;
exports.pr_rel_context_of = pr_rel_context_of;
exports.pr_context_of = pr_context_of;
exports.pr_predicate = pr_predicate;
exports.pr_cpred = pr_cpred;
exports.pr_idpred = pr_idpred;
exports.pr_transparent_state = pr_transparent_state;
exports.pr_goal = pr_goal;
exports.pr_subgoals = pr_subgoals;
exports.pr_subgoal = pr_subgoal;
exports.pr_concl = pr_concl;
exports.pr_open_subgoals = pr_open_subgoals;
exports.pr_nth_open_subgoal = pr_nth_open_subgoal;
exports.pr_evar = pr_evar;
exports.pr_evars_int = pr_evars_int;
exports.pr_evars = pr_evars;
exports.pr_ne_evar_set = pr_ne_evar_set;
exports.pr_prim_rule = pr_prim_rule;
exports.prterm = prterm;
exports.ContextObjectSet = ContextObjectSet;
exports.ContextObjectMap = ContextObjectMap;
exports.pr_assumptionset = pr_assumptionset;
exports.pr_goal_by_id = pr_goal_by_id;
exports.set_printer_pr = set_printer_pr;
exports.default_printer_pr = default_printer_pr;
/*  Not a pure module */
