// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Miscops$ReactTemplate = require("./miscops.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");

function cases_pattern_loc(c) {
  return c[/* loc */1];
}

function alias_of_pat(pat) {
  return DAst$ReactTemplate.with_val((function (param) {
                if (param.tag) {
                  return param[2];
                } else {
                  return param[0];
                }
              }), pat);
}

function set_pat_alias(id) {
  return (function (param) {
      return DAst$ReactTemplate.map((function (pat) {
                    if (pat.tag) {
                      if (pat[2]) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "glob_ops.ml",
                                33,
                                11
                              ]
                            ];
                      } else {
                        return /* PatCstr */Block.__(1, [
                                  pat[0],
                                  pat[1],
                                  /* Name */[id]
                                ]);
                      }
                    } else if (pat[0]) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "glob_ops.ml",
                              33,
                              11
                            ]
                          ];
                    } else {
                      return /* PatVar */Block.__(0, [/* Name */[id]]);
                    }
                  }), param);
    });
}

function cases_predicate_names(tml) {
  return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    var match = param[1];
                    var match$1 = match[1];
                    var na = match[0];
                    if (match$1) {
                      return /* :: */[
                              na,
                              match$1[0][/* v */0][1]
                            ];
                    } else {
                      return /* :: */[
                              na,
                              /* [] */0
                            ];
                    }
                  }), tml));
}

function mkGApp(loc, p, t) {
  var match = DAst$ReactTemplate.get(p);
  var tmp;
  tmp = match.tag === 4 ? /* GApp */Block.__(4, [
        match[0],
        Util$ReactTemplate.$at(match[1], /* :: */[
              t,
              /* [] */0
            ])
      ]) : /* GApp */Block.__(4, [
        p,
        /* :: */[
          t,
          /* [] */0
        ]
      ]);
  return DAst$ReactTemplate.make(loc, tmp);
}

function binding_kind_eq(bk1, bk2) {
  if (bk1 !== 0) {
    if (bk2 !== 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (bk2 !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function case_style_eq(s1, s2) {
  switch (s1) {
    case 0 : 
        if (s2 !== 0) {
          return /* false */0;
        } else {
          return /* true */1;
        }
    case 1 : 
        if (s2 !== 1) {
          return /* false */0;
        } else {
          return /* true */1;
        }
    case 2 : 
        if (s2 !== 2) {
          return /* false */0;
        } else {
          return /* true */1;
        }
    case 3 : 
        if (s2 !== 3) {
          return /* false */0;
        } else {
          return /* true */1;
        }
    case 4 : 
        if (s2 >= 4) {
          return /* true */1;
        } else {
          return /* false */0;
        }
    
  }
}

function cases_pattern_eq(p1, p2) {
  var match = DAst$ReactTemplate.get(p1);
  var match$1 = DAst$ReactTemplate.get(p2);
  if (match.tag) {
    if (!match$1.tag || !(Names$ReactTemplate.eq_constructor(match[0], match$1[0]) && Curry._3(Util$ReactTemplate.List[/* equal */44], cases_pattern_eq, match[1], match$1[1]))) {
      return /* false */0;
    } else {
      return Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match[2], match$1[2]);
    }
  } else if (match$1.tag) {
    return /* false */0;
  } else {
    return Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match[0], match$1[0]);
  }
}

function cast_type_eq(eq, t1, t2) {
  if (typeof t1 === "number") {
    if (typeof t2 === "number") {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (t1.tag) {
    if (typeof t2 === "number" || !t2.tag) {
      return /* false */0;
    } else {
      return Curry._2(eq, t1[0], t2[0]);
    }
  } else if (typeof t2 === "number" || t2.tag) {
    return /* false */0;
  } else {
    return Curry._2(eq, t1[0], t2[0]);
  }
}

function fix_kind_eq(f, k1, k2) {
  if (k1.tag) {
    if (k2.tag) {
      return +(k1[0] === k2[0]);
    } else {
      return /* false */0;
    }
  } else {
    var match = k1[0];
    var a1 = match[0];
    if (k2.tag) {
      return /* false */0;
    } else {
      var eq = function (param, param$1) {
        if (Option$ReactTemplate.equal((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), param[0], param$1[0])) {
          var f$1 = f;
          var o1 = param[1];
          var o2 = param$1[1];
          if (typeof o1 === "number") {
            if (typeof o2 === "number") {
              return /* true */1;
            } else {
              return /* false */0;
            }
          } else if (o1.tag) {
            if (typeof o2 === "number" || !o2.tag || !Curry._2(f$1, o1[0], o2[0])) {
              return /* false */0;
            } else {
              return Option$ReactTemplate.equal(f$1, o1[1], o2[1]);
            }
          } else if (typeof o2 === "number" || o2.tag) {
            return /* false */0;
          } else {
            return Curry._2(f$1, o1[0], o2[0]);
          }
        } else {
          return /* false */0;
        }
      };
      if (match[1] === k2[0][1]) {
        return Util$ReactTemplate.$$Array[/* equal */21](eq, a1, a1);
      } else {
        return /* false */0;
      }
    }
  }
}

function mk_glob_constr_eq(f, c1, c2) {
  var match = DAst$ReactTemplate.get(c1);
  var match$1 = DAst$ReactTemplate.get(c2);
  switch (match.tag | 0) {
    case 0 : 
        if (match$1.tag) {
          return /* false */0;
        } else {
          return Globnames$ReactTemplate.eq_gr(match[0], match$1[0]);
        }
        break;
    case 1 : 
        if (match$1.tag === 1) {
          return Names$ReactTemplate.Id[/* equal */0](match[0], match$1[0]);
        } else {
          return /* false */0;
        }
        break;
    case 2 : 
        if (match$1.tag === 2 && Names$ReactTemplate.Id[/* equal */0](match[0], match$1[0])) {
          return Curry._3(Util$ReactTemplate.List[/* equal */44], (function (param, param$1) {
                        var f$1 = f;
                        var param$2 = param;
                        var param$3 = param$1;
                        if (Names$ReactTemplate.Id[/* equal */0](param$2[0], param$3[0])) {
                          return Curry._2(f$1, param$2[1], param$3[1]);
                        } else {
                          return /* false */0;
                        }
                      }), match[1], match$1[1]);
        } else {
          return /* false */0;
        }
        break;
    case 3 : 
        if (match$1.tag === 3) {
          var k1 = match[0];
          var k2 = match$1[0];
          if (k1.tag) {
            if (k2.tag) {
              return Names$ReactTemplate.Id[/* equal */0](k1[0], k2[0]);
            } else {
              return /* false */0;
            }
          } else if (k2.tag) {
            return /* false */0;
          } else {
            return Names$ReactTemplate.Id[/* equal */0](k1[0], k2[0]);
          }
        } else {
          return /* false */0;
        }
        break;
    case 4 : 
        if (match$1.tag === 4 && Curry._2(f, match[0], match$1[0])) {
          return Curry._3(Util$ReactTemplate.List[/* equal */44], f, match[1], match$1[1]);
        } else {
          return /* false */0;
        }
        break;
    case 5 : 
        if (match$1.tag === 5 && Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match[0], match$1[0]) && binding_kind_eq(match[1], match$1[1]) && Curry._2(f, match[2], match$1[2])) {
          return Curry._2(f, match[3], match$1[3]);
        } else {
          return /* false */0;
        }
        break;
    case 6 : 
        if (match$1.tag === 6 && Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match[0], match$1[0]) && binding_kind_eq(match[1], match$1[1]) && Curry._2(f, match[2], match$1[2])) {
          return Curry._2(f, match[3], match$1[3]);
        } else {
          return /* false */0;
        }
        break;
    case 7 : 
        if (match$1.tag === 7 && Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match[0], match$1[0]) && Curry._2(f, match[1], match$1[1]) && Option$ReactTemplate.equal(f, match[2], match$1[2])) {
          return Curry._2(f, match[3], match$1[3]);
        } else {
          return /* false */0;
        }
        break;
    case 8 : 
        if (match$1.tag === 8 && case_style_eq(match[0], match$1[0]) && Option$ReactTemplate.equal(f, match[1], match$1[1]) && Curry._3(Util$ReactTemplate.List[/* equal */44], (function (param, param$1) {
                  var f$1 = f;
                  var param$2 = param;
                  var param$3 = param$1;
                  var eqp = function (param, param$1) {
                    var match = param$1[/* v */0];
                    var match$1 = param[/* v */0];
                    if (Names$ReactTemplate.eq_ind(match$1[0], match[0])) {
                      return Curry._3(Util$ReactTemplate.List[/* equal */44], Nameops$ReactTemplate.Name[/* equal */4], match$1[1], match[1]);
                    } else {
                      return /* false */0;
                    }
                  };
                  if (Curry._2(f$1, param$2[0], param$3[0])) {
                    var param$4 = param$2[1];
                    var param$5 = param$3[1];
                    if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], param$4[0], param$5[0])) {
                      return Option$ReactTemplate.equal(eqp, param$4[1], param$5[1]);
                    } else {
                      return /* false */0;
                    }
                  } else {
                    return /* false */0;
                  }
                }), match[2], match$1[2])) {
          return Curry._3(Util$ReactTemplate.List[/* equal */44], (function (param, param$1) {
                        var f$1 = f;
                        var param$2 = param;
                        var param$3 = param$1;
                        var match = param$3[/* v */0];
                        var match$1 = param$2[/* v */0];
                        if (Curry._3(Util$ReactTemplate.List[/* equal */44], Names$ReactTemplate.Id[/* equal */0], match$1[0], match[0]) && Curry._3(Util$ReactTemplate.List[/* equal */44], cases_pattern_eq, match$1[1], match[1])) {
                          return Curry._2(f$1, match$1[2], match[2]);
                        } else {
                          return /* false */0;
                        }
                      }), match[3], match$1[3]);
        } else {
          return /* false */0;
        }
        break;
    case 9 : 
        var match$2 = match[1];
        if (match$1.tag === 9) {
          var match$3 = match$1[1];
          if (Curry._3(Util$ReactTemplate.List[/* equal */44], Nameops$ReactTemplate.Name[/* equal */4], match[0], match$1[0]) && Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match$2[0], match$3[0]) && Option$ReactTemplate.equal(f, match$2[1], match$3[1]) && Curry._2(f, match[2], match$1[2])) {
            return Curry._2(f, match[3], match$1[3]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
        break;
    case 10 : 
        var match$4 = match[1];
        if (match$1.tag === 10) {
          var match$5 = match$1[1];
          if (Curry._2(f, match[0], match$1[0]) && Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match$4[0], match$5[0]) && Option$ReactTemplate.equal(f, match$4[1], match$5[1]) && Curry._2(f, match[2], match$1[2])) {
            return Curry._2(f, match[3], match$1[3]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
        break;
    case 11 : 
        if (match$1.tag === 11 && fix_kind_eq(f, match[0], match$1[0]) && Util$ReactTemplate.$$Array[/* equal */21](Names$ReactTemplate.Id[/* equal */0], match[1], match$1[1]) && Util$ReactTemplate.$$Array[/* equal */21]((function (l1, l2) {
                  return Curry._3(Util$ReactTemplate.List[/* equal */44], (function (param, param$1) {
                                var f$1 = f;
                                var param$2 = param;
                                var param$3 = param$1;
                                if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], param$2[0], param$3[0]) && binding_kind_eq(param$2[1], param$3[1]) && Option$ReactTemplate.equal(f$1, param$2[2], param$3[2])) {
                                  return Curry._2(f$1, param$2[3], param$3[3]);
                                } else {
                                  return /* false */0;
                                }
                              }), l1, l2);
                }), match[2], match$1[2]) && Util$ReactTemplate.$$Array[/* equal */21](f, match[3], match$1[3])) {
          return Util$ReactTemplate.$$Array[/* equal */21](f, match[4], match$1[4]);
        } else {
          return /* false */0;
        }
        break;
    case 12 : 
        if (match$1.tag === 12) {
          return Miscops$ReactTemplate.glob_sort_eq(match[0], match$1[0]);
        } else {
          return /* false */0;
        }
        break;
    case 13 : 
        if (match$1.tag === 13 && Option$ReactTemplate.equal((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), match[2], match$1[2])) {
          return Miscops$ReactTemplate.intro_pattern_naming_eq(match[1], match$1[1]);
        } else {
          return /* false */0;
        }
        break;
    case 14 : 
        if (match$1.tag === 14 && Curry._2(f, match[0], match$1[0])) {
          return cast_type_eq(f, match[1], match$1[1]);
        } else {
          return /* false */0;
        }
        break;
    case 15 : 
        if (match$1.tag === 15 && Names$ReactTemplate.Projection[/* equal */5](match[0], match$1[0])) {
          return Curry._2(f, match[1], match$1[1]);
        } else {
          return /* false */0;
        }
        break;
    
  }
}

function glob_constr_eq(c) {
  return (function (param) {
      return mk_glob_constr_eq(glob_constr_eq, c, param);
    });
}

function map_glob_constr_left_to_right(f) {
  return (function (param) {
      return DAst$ReactTemplate.map((function (x) {
                    switch (x.tag | 0) {
                      case 4 : 
                          var comp1 = Curry._1(f, x[0]);
                          var comp2 = Curry._2(Util$ReactTemplate.List[/* map_left */66], f, x[1]);
                          return /* GApp */Block.__(4, [
                                    comp1,
                                    comp2
                                  ]);
                      case 5 : 
                          var comp1$1 = Curry._1(f, x[2]);
                          var comp2$1 = Curry._1(f, x[3]);
                          return /* GLambda */Block.__(5, [
                                    x[0],
                                    x[1],
                                    comp1$1,
                                    comp2$1
                                  ]);
                      case 6 : 
                          var comp1$2 = Curry._1(f, x[2]);
                          var comp2$2 = Curry._1(f, x[3]);
                          return /* GProd */Block.__(6, [
                                    x[0],
                                    x[1],
                                    comp1$2,
                                    comp2$2
                                  ]);
                      case 7 : 
                          var comp1$3 = Curry._1(f, x[1]);
                          var compt = Option$ReactTemplate.map(f, x[2]);
                          var comp2$3 = Curry._1(f, x[3]);
                          return /* GLetIn */Block.__(7, [
                                    x[0],
                                    comp1$3,
                                    compt,
                                    comp2$3
                                  ]);
                      case 8 : 
                          var comp1$4 = Option$ReactTemplate.map(f, x[1]);
                          var comp2$4 = Curry._2(Util$ReactTemplate.List[/* map_left */66], (function (param) {
                                  return /* tuple */[
                                          Curry._1(f, param[0]),
                                          param[1]
                                        ];
                                }), x[2]);
                          var comp3 = Curry._2(Util$ReactTemplate.List[/* map_left */66], (function (param) {
                                  return CAst$ReactTemplate.map((function (param) {
                                                return /* tuple */[
                                                        param[0],
                                                        param[1],
                                                        Curry._1(f, param[2])
                                                      ];
                                              }), param);
                                }), x[3]);
                          return /* GCases */Block.__(8, [
                                    x[0],
                                    comp1$4,
                                    comp2$4,
                                    comp3
                                  ]);
                      case 9 : 
                          var match = x[1];
                          var comp1$5 = Option$ReactTemplate.map(f, match[1]);
                          var comp2$5 = Curry._1(f, x[2]);
                          var comp3$1 = Curry._1(f, x[3]);
                          return /* GLetTuple */Block.__(9, [
                                    x[0],
                                    /* tuple */[
                                      match[0],
                                      comp1$5
                                    ],
                                    comp2$5,
                                    comp3$1
                                  ]);
                      case 10 : 
                          var match$1 = x[1];
                          var comp1$6 = Option$ReactTemplate.map(f, match$1[1]);
                          var comp2$6 = Curry._1(f, x[2]);
                          var comp3$2 = Curry._1(f, x[3]);
                          return /* GIf */Block.__(10, [
                                    Curry._1(f, x[0]),
                                    /* tuple */[
                                      match$1[0],
                                      comp1$6
                                    ],
                                    comp2$6,
                                    comp3$2
                                  ]);
                      case 11 : 
                          var comp1$7 = Util$ReactTemplate.$$Array[/* map */12](Curry._1(Util$ReactTemplate.List[/* map_left */66], (function (param) {
                                      var f$1 = f;
                                      var param$1 = param;
                                      var comp1 = Option$ReactTemplate.map(f$1, param$1[2]);
                                      var comp2 = Curry._1(f$1, param$1[3]);
                                      return /* tuple */[
                                              param$1[0],
                                              param$1[1],
                                              comp1,
                                              comp2
                                            ];
                                    })), x[2]);
                          var comp2$7 = Util$ReactTemplate.$$Array[/* map */12](f, x[3]);
                          var comp3$3 = Util$ReactTemplate.$$Array[/* map */12](f, x[4]);
                          return /* GRec */Block.__(11, [
                                    x[0],
                                    x[1],
                                    comp1$7,
                                    comp2$7,
                                    comp3$3
                                  ]);
                      case 14 : 
                          var comp1$8 = Curry._1(f, x[0]);
                          var comp2$8 = Miscops$ReactTemplate.map_cast_type(f, x[1]);
                          return /* GCast */Block.__(14, [
                                    comp1$8,
                                    comp2$8
                                  ]);
                      case 15 : 
                          return /* GProj */Block.__(15, [
                                    x[0],
                                    Curry._1(f, x[1])
                                  ]);
                      default:
                        return x;
                    }
                  }), param);
    });
}

function fold_return_type(f, acc, param) {
  return Option$ReactTemplate.fold_left(f, acc, param[1]);
}

function fold_glob_constr(f, acc) {
  return (function (param) {
      return DAst$ReactTemplate.with_val((function (param) {
                    var exit = 0;
                    switch (param.tag | 0) {
                      case 1 : 
                          return acc;
                      case 4 : 
                          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], f, Curry._2(f, acc, param[0]), param[1]);
                      case 5 : 
                      case 6 : 
                          exit = 1;
                          break;
                      case 7 : 
                          return Curry._2(f, Option$ReactTemplate.fold_left(f, Curry._2(f, acc, param[1]), param[2]), param[3]);
                      case 8 : 
                          var fold_pattern = function (acc, param) {
                            return Curry._2(f, acc, param[/* v */0][2]);
                          };
                          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold_pattern, Curry._3(Util$ReactTemplate.List[/* fold_left */13], f, Option$ReactTemplate.fold_left(f, acc, param[1]), Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                                return prim[0];
                                              }), param[2])), param[3]);
                      case 9 : 
                          return Curry._2(f, Curry._2(f, fold_return_type(f, acc, param[1]), param[2]), param[3]);
                      case 10 : 
                          return Curry._2(f, Curry._2(f, Curry._2(f, fold_return_type(f, acc, param[1]), param[0]), param[2]), param[3]);
                      case 11 : 
                          var acc$1 = Util$ReactTemplate.$$Array[/* fold_left */15](Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
                                      return Curry._2(f, Option$ReactTemplate.fold_left(f, acc, param[2]), param[3]);
                                    })), acc, param[2]);
                          return Util$ReactTemplate.$$Array[/* fold_left */15](f, Util$ReactTemplate.$$Array[/* fold_left */15](f, acc$1, param[3]), param[4]);
                      case 14 : 
                          var k = param[1];
                          var acc$2 = typeof k === "number" ? acc : Curry._2(f, acc, k[0]);
                          return Curry._2(f, acc$2, param[0]);
                      case 15 : 
                          return Curry._2(f, acc, param[1]);
                      default:
                        return acc;
                    }
                    if (exit === 1) {
                      return Curry._2(f, Curry._2(f, acc, param[2]), param[3]);
                    }
                    
                  }), param);
    });
}

function fold_return_type_with_binders(f, g, v, acc, param) {
  return Option$ReactTemplate.fold_left(Curry._1(f, Nameops$ReactTemplate.Name[/* fold_right */10](g, param[0], v)), acc, param[1]);
}

function fold_glob_constr_with_binders(g, f, v, acc) {
  return (function (param) {
      return DAst$ReactTemplate.with_val((function (param) {
                    var exit = 0;
                    switch (param.tag | 0) {
                      case 1 : 
                          return acc;
                      case 4 : 
                          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], Curry._1(f, v), Curry._3(f, v, acc, param[0]), param[1]);
                      case 5 : 
                      case 6 : 
                          exit = 1;
                          break;
                      case 7 : 
                          return Curry._3(f, Nameops$ReactTemplate.Name[/* fold_right */10](g, param[0], v), Option$ReactTemplate.fold_left(Curry._1(f, v), Curry._3(f, v, acc, param[1]), param[2]), param[3]);
                      case 8 : 
                          var fold_pattern = function (acc, param) {
                            var match = param[/* v */0];
                            return Curry._3(f, Curry._3(Util$ReactTemplate.List[/* fold_right */14], g, match[0], v), acc, match[2]);
                          };
                          var fold_tomatch = function (param, param$1) {
                            var match = param$1[1];
                            return /* tuple */[
                                    Option$ReactTemplate.fold_left((function (v$prime$prime, param) {
                                            var partial_arg = Nameops$ReactTemplate.Name[/* fold_right */10];
                                            return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                                                          return partial_arg(g, param, param$1);
                                                        }), param[/* v */0][1], v$prime$prime);
                                          }), Nameops$ReactTemplate.Name[/* fold_right */10](g, match[0], param[0]), match[1]),
                                    Curry._3(f, v, param[1], param$1[0])
                                  ];
                          };
                          var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold_tomatch, /* tuple */[
                                v,
                                acc
                              ], param[2]);
                          var acc$1 = Option$ReactTemplate.fold_left(Curry._1(f, match[0]), match[1], param[1]);
                          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold_pattern, acc$1, param[3]);
                      case 9 : 
                          var partial_arg = Nameops$ReactTemplate.Name[/* fold_right */10];
                          return Curry._3(f, Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                                            return partial_arg(g, param, param$1);
                                          }), param[0], v), Curry._3(f, v, fold_return_type_with_binders(f, g, v, acc, param[1]), param[2]), param[3]);
                      case 10 : 
                          return Curry._3(f, v, Curry._3(f, v, Curry._3(f, v, fold_return_type_with_binders(f, g, v, acc, param[1]), param[0]), param[2]), param[3]);
                      case 11 : 
                          var bv = param[4];
                          var tyl = param[3];
                          var bll = param[2];
                          var idl = param[1];
                          var f$prime = function (i, acc, _) {
                            var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                                    var v = param[0];
                                    return /* tuple */[
                                            Nameops$ReactTemplate.Name[/* fold_right */10](g, param$1[0], v),
                                            Curry._3(f, v, Option$ReactTemplate.fold_left(Curry._1(f, v), param[1], param$1[2]), param$1[3])
                                          ];
                                  }), /* tuple */[
                                  v,
                                  acc
                                ], Caml_array.caml_array_get(bll, i));
                            var v$1 = match[0];
                            return Curry._3(f, Util$ReactTemplate.$$Array[/* fold_right */16](g, idl, v$1), Curry._3(f, v$1, match[1], Caml_array.caml_array_get(tyl, i)), Caml_array.caml_array_get(bv, i));
                          };
                          return Util$ReactTemplate.$$Array[/* fold_left_i */38](f$prime, acc, idl);
                      case 14 : 
                          var k = param[1];
                          var acc$2 = typeof k === "number" ? acc : Curry._3(f, v, acc, k[0]);
                          return Curry._3(f, v, acc$2, param[0]);
                      case 15 : 
                          return Curry._3(f, v, acc, param[1]);
                      default:
                        return acc;
                    }
                    if (exit === 1) {
                      return Curry._3(f, Nameops$ReactTemplate.Name[/* fold_right */10](g, param[0], v), Curry._3(f, v, acc, param[2]), param[3]);
                    }
                    
                  }), param);
    });
}

function iter_glob_constr(f) {
  return fold_glob_constr((function () {
                return f;
              }), /* () */0);
}

function occur_glob_constr(id) {
  var occur = function (barred, acc, c) {
    var match = DAst$ReactTemplate.get(c);
    if (match.tag === 1) {
      return Names$ReactTemplate.Id[/* equal */0](id, match[0]);
    } else {
      var g = function (id$prime, barred) {
        if (barred) {
          return /* true */1;
        } else {
          return Names$ReactTemplate.Id[/* equal */0](id, id$prime);
        }
      };
      var f = function (barred, acc, c) {
        if (acc) {
          return /* true */1;
        } else if (barred) {
          return /* false */0;
        } else {
          return occur(/* false */0, acc, c);
        }
      };
      return fold_glob_constr_with_binders(g, f, barred, acc)(c);
    }
  };
  return (function (param) {
      return occur(/* false */0, /* false */0, param);
    });
}

function vars(bound, vs, c) {
  var match = DAst$ReactTemplate.get(c);
  if (match.tag === 1) {
    var id$prime = match[0];
    if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id$prime, bound)) {
      return vs;
    } else {
      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id$prime, vs);
    }
  } else {
    return fold_glob_constr_with_binders(Names$ReactTemplate.Id[/* Set */9][/* add */3], vars, bound, vs)(c);
  }
}

function free_glob_vars(rt) {
  return vars(Names$ReactTemplate.Id[/* Set */9][/* empty */0], Names$ReactTemplate.Id[/* Set */9][/* empty */0], rt);
}

function glob_visible_short_qualid(c) {
  var aux = function (acc, c) {
    var match = DAst$ReactTemplate.get(c);
    if (match.tag) {
      return fold_glob_constr(aux, acc)(c);
    } else {
      var qualid = Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], match[0]);
      var match$1 = Libnames$ReactTemplate.repr_qualid(qualid);
      if (Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], match$1[0])) {
        return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], match$1[1], acc);
      } else {
        return acc;
      }
    }
  };
  return aux(Names$ReactTemplate.Id[/* Set */9][/* empty */0], c);
}

var warn_variable_collision = CWarnings$ReactTemplate.create("variable-collision", "ltac", /* None */0, (function (name) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Collision between bound variables of name "), Names$ReactTemplate.Id[/* print */8](name));
      }));

function add_and_check_ident(id, set) {
  if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, set)) {
    warn_variable_collision(/* None */0, id);
  }
  return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, set);
}

function vars$1(bound) {
  return fold_glob_constr_with_binders((function (id, _) {
                bound[0] = add_and_check_ident(id, bound[0]);
                return /* () */0;
              }), (function (_, _$1) {
                return vars$1(bound);
              }), /* () */0, /* () */0);
}

function bound_glob_vars(rt) {
  var bound = [Names$ReactTemplate.Id[/* Set */9][/* empty */0]];
  vars$1(bound)(rt);
  return bound[0];
}

function map_case_pattern_binders(f) {
  return (function (param) {
      return DAst$ReactTemplate.map((function (x) {
                    if (x.tag) {
                      var na = x[2];
                      var ps = x[1];
                      var rna = Curry._1(f, na);
                      var rps = CList$ReactTemplate.smartmap((function (p) {
                              return map_case_pattern_binders(f)(p);
                            }), ps);
                      if (rna === na && rps === ps) {
                        return x;
                      } else {
                        return /* PatCstr */Block.__(1, [
                                  x[0],
                                  rps,
                                  rna
                                ]);
                      }
                    } else {
                      var na$1 = x[0];
                      var r = Curry._1(f, na$1);
                      if (r === na$1) {
                        return x;
                      } else {
                        return /* PatVar */Block.__(0, [r]);
                      }
                    }
                  }), param);
    });
}

function map_pattern_binders(f, tomatch, branches) {
  return /* tuple */[
          CList$ReactTemplate.smartmap((function (tm) {
                  var f$1 = f;
                  var x = tm;
                  var match = x[1];
                  var inp = match[1];
                  var r = Option$ReactTemplate.smartmap((function (p) {
                          var f$2 = f$1;
                          var x = p;
                          var match = x[/* v */0];
                          var nal = match[1];
                          var r = CList$ReactTemplate.smartmap(f$2, nal);
                          if (r === nal) {
                            return x;
                          } else {
                            return CAst$ReactTemplate.make(x[/* loc */1], /* tuple */[
                                        match[0],
                                        r
                                      ]);
                          }
                        }), inp);
                  if (r === inp) {
                    return x;
                  } else {
                    return /* tuple */[
                            x[0],
                            /* tuple */[
                              Curry._1(f$1, match[0]),
                              r
                            ]
                          ];
                  }
                }), tomatch),
          CList$ReactTemplate.smartmap((function (br) {
                  var f$1 = f;
                  var x = br;
                  var match = x[/* v */0];
                  var cll = match[1];
                  var r = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (cl) {
                          return map_case_pattern_binders(f$1)(cl);
                        }), cll);
                  if (r === cll) {
                    return x;
                  } else {
                    return CAst$ReactTemplate.make(x[/* loc */1], /* tuple */[
                                match[0],
                                r,
                                match[2]
                              ]);
                  }
                }), branches)
        ];
}

function map_cases_branch(f) {
  return (function (param) {
      return CAst$ReactTemplate.map((function (param) {
                    return /* tuple */[
                            param[0],
                            param[1],
                            Curry._1(f, param[2])
                          ];
                  }), param);
    });
}

function map_pattern(f, tomatch, branches) {
  return /* tuple */[
          Curry._2(Util$ReactTemplate.List[/* map */10], (function (tm) {
                  var f$1 = f;
                  var param = tm;
                  return /* tuple */[
                          Curry._1(f$1, param[0]),
                          param[1]
                        ];
                }), tomatch),
          Curry._2(Util$ReactTemplate.List[/* map */10], (function (br) {
                  return map_cases_branch(f)(br);
                }), branches)
        ];
}

function loc_of_glob_constr(c) {
  return c[/* loc */1];
}

function collide_id(l, id) {
  return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                if (Names$ReactTemplate.Id[/* equal */0](id, param[0])) {
                  return /* true */1;
                } else {
                  return Names$ReactTemplate.Id[/* equal */0](id, param[1]);
                }
              }), l);
}

function test_id(l, id) {
  if (collide_id(l, id)) {
    throw Caml_builtin_exceptions.not_found;
  } else {
    return 0;
  }
}

function test_na(l, na) {
  return Nameops$ReactTemplate.Name[/* iter */11]((function (param) {
                return test_id(l, param);
              }), na);
}

function update_subst(na, l) {
  var in_range = function (id, l) {
    return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                  return Names$ReactTemplate.Id[/* equal */0](id, param[1]);
                }), l);
  };
  var l$prime = Nameops$ReactTemplate.Name[/* fold_right */10](Names$ReactTemplate.Id[/* List */12][/* remove_assoc */4], na, l);
  return Nameops$ReactTemplate.Name[/* fold_right */10]((function (id, _) {
                if (in_range(id, l$prime)) {
                  var id$prime = Namegen$ReactTemplate.next_ident_away_from(id, (function (id$prime) {
                          return in_range(id$prime, l$prime);
                        }));
                  return /* tuple */[
                          /* Name */[id$prime],
                          /* :: */[
                            /* tuple */[
                              id,
                              id$prime
                            ],
                            l
                          ]
                        ];
                } else {
                  return /* tuple */[
                          na,
                          l
                        ];
                }
              }), na, /* tuple */[
              na,
              l
            ]);
}

var UnsoundRenaming = Caml_exceptions.create("Glob_ops-ReactTemplate.UnsoundRenaming");

function rename_var(l, id) {
  try {
    var id$prime = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id, l);
    var match = Curry._2(Util$ReactTemplate.List[/* extract_first */90], (function (param) {
            return Names$ReactTemplate.Id[/* equal */0](param[1], id$prime);
          }), l);
    if (Names$ReactTemplate.Id[/* equal */0](id, match[1][0])) {
      return id$prime;
    } else {
      throw UnsoundRenaming;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                return Names$ReactTemplate.Id[/* equal */0](id, param[1]);
              }), l)) {
        throw UnsoundRenaming;
      } else {
        return id;
      }
    } else {
      throw exn;
    }
  }
}

function rename_glob_vars(l, c) {
  var c$1 = DAst$ReactTemplate.map_with_loc((function (_, r) {
          switch (r.tag | 0) {
            case 0 : 
                var match = r[0];
                if (match.tag) {
                  return DAst$ReactTemplate.get(map_glob_constr_left_to_right((function (param) {
                                      return rename_glob_vars(l, param);
                                    }))(c));
                } else {
                  var id = match[0];
                  if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                            return Names$ReactTemplate.Id[/* equal */0](id, param[1]);
                          }), l)) {
                    throw UnsoundRenaming;
                  } else {
                    return r;
                  }
                }
                break;
            case 1 : 
                var id$1 = r[0];
                var id$prime = rename_var(l, id$1);
                if (id$1 === id$prime) {
                  return r;
                } else {
                  return /* GVar */Block.__(1, [id$prime]);
                }
            case 5 : 
                var match$1 = update_subst(r[0], l);
                return /* GLambda */Block.__(5, [
                          match$1[0],
                          r[1],
                          rename_glob_vars(l, r[2]),
                          rename_glob_vars(match$1[1], r[3])
                        ]);
            case 6 : 
                var na = r[0];
                var match$2 = update_subst(na, l);
                return /* GProd */Block.__(6, [
                          na,
                          r[1],
                          rename_glob_vars(l, r[2]),
                          rename_glob_vars(match$2[1], r[3])
                        ]);
            case 7 : 
                var match$3 = update_subst(r[0], l);
                return /* GLetIn */Block.__(7, [
                          match$3[0],
                          rename_glob_vars(l, r[1]),
                          Option$ReactTemplate.map((function (param) {
                                  return rename_glob_vars(l, param);
                                }), r[2]),
                          rename_glob_vars(match$3[1], r[3])
                        ]);
            case 8 : 
                var test_pred_pat = function (param) {
                  test_na(l, param[0]);
                  return Option$ReactTemplate.iter((function (param) {
                                return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                                              return test_na(l, param);
                                            }), param[/* v */0][1]);
                              }), param[1]);
                };
                var test_clause = function (idl) {
                  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                                return test_id(l, param);
                              }), idl);
                };
                var po = Option$ReactTemplate.map((function (param) {
                        return rename_glob_vars(l, param);
                      }), r[1]);
                var tomatchl = Curry._2(Util$ReactTemplate.List[/* map_left */66], (function (param) {
                        var x = param[1];
                        test_pred_pat(x);
                        return /* tuple */[
                                rename_glob_vars(l, param[0]),
                                x
                              ];
                      }), r[2]);
                var cls = Curry._2(Util$ReactTemplate.List[/* map_left */66], (function (param) {
                        return CAst$ReactTemplate.map((function (param) {
                                      var idl = param[0];
                                      test_clause(idl);
                                      return /* tuple */[
                                              idl,
                                              param[1],
                                              rename_glob_vars(l, param[2])
                                            ];
                                    }), param);
                      }), r[3]);
                return /* GCases */Block.__(8, [
                          r[0],
                          po,
                          tomatchl,
                          cls
                        ]);
            case 9 : 
                var match$4 = r[1];
                var na$1 = match$4[0];
                var nal = r[0];
                Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                        return test_na(l, param);
                      }), /* :: */[
                      na$1,
                      nal
                    ]);
                return /* GLetTuple */Block.__(9, [
                          nal,
                          /* tuple */[
                            na$1,
                            Option$ReactTemplate.map((function (param) {
                                    return rename_glob_vars(l, param);
                                  }), match$4[1])
                          ],
                          rename_glob_vars(l, r[2]),
                          rename_glob_vars(l, r[3])
                        ]);
            case 10 : 
                var match$5 = r[1];
                var na$2 = match$5[0];
                test_na(l, na$2);
                return /* GIf */Block.__(10, [
                          rename_glob_vars(l, r[0]),
                          /* tuple */[
                            na$2,
                            Option$ReactTemplate.map((function (param) {
                                    return rename_glob_vars(l, param);
                                  }), match$5[1])
                          ],
                          rename_glob_vars(l, r[2]),
                          rename_glob_vars(l, r[3])
                        ]);
            case 11 : 
                var idl = r[1];
                Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                        return test_id(l, param);
                      }), idl);
                return /* GRec */Block.__(11, [
                          r[0],
                          idl,
                          Util$ReactTemplate.$$Array[/* map */12](Curry._1(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      var na = param[0];
                                      test_na(l, na);
                                      return /* tuple */[
                                              na,
                                              param[1],
                                              Option$ReactTemplate.map((function (param) {
                                                      return rename_glob_vars(l, param);
                                                    }), param[2]),
                                              rename_glob_vars(l, param[3])
                                            ];
                                    })), r[2]),
                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                  return rename_glob_vars(l, param);
                                }), r[3]),
                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                  return rename_glob_vars(l, param);
                                }), r[4])
                        ]);
            default:
              return DAst$ReactTemplate.get(map_glob_constr_left_to_right((function (param) {
                                  return rename_glob_vars(l, param);
                                }))(c));
          }
        }), c);
  return DAst$ReactTemplate.make(c$1[/* loc */1], DAst$ReactTemplate.get(c$1));
}

function is_gvar(id, c) {
  var match = DAst$ReactTemplate.get(c);
  if (match.tag === 1) {
    return Names$ReactTemplate.Id[/* equal */0](id, match[0]);
  } else {
    return /* false */0;
  }
}

function cases_pattern_of_glob_constr(na) {
  return (function (param) {
      return DAst$ReactTemplate.map((function (param) {
                    switch (param.tag | 0) {
                      case 0 : 
                          var match = param[0];
                          if (match.tag === 3) {
                            return /* PatCstr */Block.__(1, [
                                      match[0],
                                      /* [] */0,
                                      na
                                    ]);
                          } else {
                            throw Caml_builtin_exceptions.not_found;
                          }
                          break;
                      case 1 : 
                          if (na) {
                            throw Caml_builtin_exceptions.not_found;
                          } else {
                            return /* PatVar */Block.__(0, [/* Name */[param[0]]]);
                          }
                          break;
                      case 4 : 
                          var match$1 = DAst$ReactTemplate.get(param[0]);
                          if (match$1.tag) {
                            throw Caml_builtin_exceptions.not_found;
                          } else {
                            var match$2 = match$1[0];
                            if (match$2.tag === 3) {
                              return /* PatCstr */Block.__(1, [
                                        match$2[0],
                                        Curry._2(Util$ReactTemplate.List[/* map */10], cases_pattern_of_glob_constr(/* Anonymous */0), param[1]),
                                        na
                                      ]);
                            } else {
                              throw Caml_builtin_exceptions.not_found;
                            }
                          }
                          break;
                      case 7 : 
                          var na$prime = param[0];
                          if (na$prime) {
                            if (param[2]) {
                              throw Caml_builtin_exceptions.not_found;
                            } else if (is_gvar(na$prime[0], param[3]) && na === /* Anonymous */0) {
                              return DAst$ReactTemplate.get(cases_pattern_of_glob_constr(na$prime)(param[1]));
                            } else {
                              throw Caml_builtin_exceptions.not_found;
                            }
                          } else {
                            throw Caml_builtin_exceptions.not_found;
                          }
                          break;
                      case 13 : 
                          return /* PatVar */Block.__(0, [na]);
                      default:
                        throw Caml_builtin_exceptions.not_found;
                    }
                  }), param);
    });
}

function drop_local_defs(typi, args) {
  var match = Term$ReactTemplate.decompose_prod_assum(typi);
  var aux = function (_decls, _args) {
    while(true) {
      var args = _args;
      var decls = _decls;
      var exit = 0;
      if (decls) {
        if (decls[0].tag) {
          if (args) {
            var match = DAst$ReactTemplate.get(args[0]);
            if (match.tag) {
              throw Caml_builtin_exceptions.not_found;
            } else if (match[0]) {
              throw Caml_builtin_exceptions.not_found;
            } else {
              _args = args[1];
              _decls = decls[1];
              continue ;
              
            }
          } else {
            exit = 1;
          }
        } else if (args) {
          return /* :: */[
                  args[0],
                  aux(decls[1], args[1])
                ];
        } else {
          exit = 1;
        }
      } else if (args) {
        exit = 1;
      } else {
        return /* [] */0;
      }
      if (exit === 1) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "glob_ops.ml",
                511,
                13
              ]
            ];
      }
      
    };
  };
  return aux(Curry._1(Util$ReactTemplate.List[/* rev */4], match[0]), args);
}

function add_patterns_for_params_remove_local_defs(param, l) {
  var j = param[1];
  var match = Global$ReactTemplate.lookup_inductive(param[0]);
  var mip = match[1];
  var mib = match[0];
  var nparams = mib[/* mind_nparams */5];
  var l$1;
  if (Caml_array.caml_array_get(mip[/* mind_consnrealdecls */10], j - 1 | 0) === Caml_array.caml_array_get(mip[/* mind_consnrealargs */9], j - 1 | 0)) {
    l$1 = l;
  } else {
    var typi = Caml_array.caml_array_get(mip[/* mind_nf_lc */8], j - 1 | 0);
    var match$1 = Term$ReactTemplate.decompose_prod_n_assum(Curry._1(Context$ReactTemplate.Rel[/* length */3], mib[/* mind_params_ctxt */7]))(typi);
    l$1 = drop_local_defs(match$1[1], l);
  }
  return Curry._3(Util$ReactTemplate.List[/* addn */109], nparams, DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0])), l$1);
}

function add_alias(loc, na, c) {
  if (na) {
    return /* GLetIn */Block.__(7, [
              na,
              DAst$ReactTemplate.make(loc, c),
              /* None */0,
              DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [na[0]]))
            ]);
  } else {
    return c;
  }
}

function glob_constr_of_cases_pattern_aux(isclosed, x) {
  return DAst$ReactTemplate.map_with_loc((function (loc, param) {
                if (param.tag) {
                  var l = param[1];
                  var cstr = param[0];
                  if (l) {
                    var ref = DAst$ReactTemplate.make(loc, /* GRef */Block.__(0, [
                            /* ConstructRef */Block.__(3, [cstr]),
                            /* None */0
                          ]));
                    var l$1 = add_patterns_for_params_remove_local_defs(cstr, l);
                    return add_alias(loc, param[2], /* GApp */Block.__(4, [
                                  ref,
                                  Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                          return glob_constr_of_cases_pattern_aux(isclosed, param);
                                        }), l$1)
                                ]));
                  } else {
                    return add_alias(loc, param[2], /* GRef */Block.__(0, [
                                  /* ConstructRef */Block.__(3, [cstr]),
                                  /* None */0
                                ]));
                  }
                } else {
                  var match = param[0];
                  if (match) {
                    if (isclosed) {
                      throw Caml_builtin_exceptions.not_found;
                    } else {
                      return /* GVar */Block.__(1, [match[0]]);
                    }
                  } else if (isclosed) {
                    throw Caml_builtin_exceptions.not_found;
                  } else {
                    return /* GHole */Block.__(13, [
                              /* QuestionMark */Block.__(3, [
                                  /* Define */[/* false */0],
                                  /* Anonymous */0
                                ]),
                              /* IntroAnonymous */0,
                              /* None */0
                            ]);
                  }
                }
              }), x);
}

function glob_constr_of_closed_cases_pattern(p) {
  var match = DAst$ReactTemplate.get(p);
  if (match.tag) {
    var loc = p[/* loc */1];
    return /* tuple */[
            match[2],
            glob_constr_of_cases_pattern_aux(/* true */1, DAst$ReactTemplate.make(loc, /* PatCstr */Block.__(1, [
                        match[0],
                        match[1],
                        /* Anonymous */0
                      ])))
          ];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function glob_constr_of_cases_pattern(p) {
  return glob_constr_of_cases_pattern_aux(/* false */0, p);
}

function ltac_interp_name(param, n) {
  if (n) {
    var id = n[0];
    try {
      return /* Name */[Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, param[/* ltac_idents */2])];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id, param[/* ltac_genargs */3])) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Ltac variable"), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is not bound to an identifier.")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("It cannot be used in a binder.")));
        } else {
          return n;
        }
      } else {
        throw exn;
      }
    }
  } else {
    return /* Anonymous */0;
  }
}

var empty_lvar_000 = /* ltac_constrs */Names$ReactTemplate.Id[/* Map */10][/* empty */0];

var empty_lvar_001 = /* ltac_uconstrs */Names$ReactTemplate.Id[/* Map */10][/* empty */0];

var empty_lvar_002 = /* ltac_idents */Names$ReactTemplate.Id[/* Map */10][/* empty */0];

var empty_lvar_003 = /* ltac_genargs */Names$ReactTemplate.Id[/* Map */10][/* empty */0];

var empty_lvar = /* record */[
  empty_lvar_000,
  empty_lvar_001,
  empty_lvar_002,
  empty_lvar_003
];

var map_glob_constr = map_glob_constr_left_to_right;

exports.cases_pattern_eq = cases_pattern_eq;
exports.alias_of_pat = alias_of_pat;
exports.set_pat_alias = set_pat_alias;
exports.cast_type_eq = cast_type_eq;
exports.glob_constr_eq = glob_constr_eq;
exports.cases_pattern_loc = cases_pattern_loc;
exports.cases_predicate_names = cases_predicate_names;
exports.mkGApp = mkGApp;
exports.map_glob_constr = map_glob_constr;
exports.map_glob_constr_left_to_right = map_glob_constr_left_to_right;
exports.warn_variable_collision = warn_variable_collision;
exports.mk_glob_constr_eq = mk_glob_constr_eq;
exports.fold_glob_constr = fold_glob_constr;
exports.fold_glob_constr_with_binders = fold_glob_constr_with_binders;
exports.iter_glob_constr = iter_glob_constr;
exports.occur_glob_constr = occur_glob_constr;
exports.free_glob_vars = free_glob_vars;
exports.bound_glob_vars = bound_glob_vars;
exports.loc_of_glob_constr = loc_of_glob_constr;
exports.glob_visible_short_qualid = glob_visible_short_qualid;
exports.UnsoundRenaming = UnsoundRenaming;
exports.rename_var = rename_var;
exports.rename_glob_vars = rename_glob_vars;
exports.map_pattern_binders = map_pattern_binders;
exports.map_pattern = map_pattern;
exports.cases_pattern_of_glob_constr = cases_pattern_of_glob_constr;
exports.glob_constr_of_closed_cases_pattern = glob_constr_of_closed_cases_pattern;
exports.glob_constr_of_cases_pattern = glob_constr_of_cases_pattern;
exports.add_patterns_for_params_remove_local_defs = add_patterns_for_params_remove_local_defs;
exports.ltac_interp_name = ltac_interp_name;
exports.empty_lvar = empty_lvar;
/* warn_variable_collision Not a pure module */
