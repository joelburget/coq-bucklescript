// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Printer$ReactTemplate = require("./printer.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Ppconstr$ReactTemplate = require("./ppconstr.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var Coq_config$ReactTemplate = require("../shims/coq_config.bs.js");
var Evardefine$ReactTemplate = require("./evardefine.bs.js");
var Typeclasses$ReactTemplate = require("./typeclasses.bs.js");
var Constrextern$ReactTemplate = require("./constrextern.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Constrexpr_ops$ReactTemplate = require("./constrexpr_ops.bs.js");

function contract(env, sigma, lc) {
  var l = [/* [] */0];
  var contract_context = function (decl, env) {
    var exit = 0;
    if (decl.tag) {
      var c$prime = decl[1];
      if (EConstr$ReactTemplate.isRel(sigma, c$prime)) {
        l[0] = /* :: */[
          EConstr$ReactTemplate.Vars[/* substl */3](l[0], c$prime),
          l[0]
        ];
        return env;
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var t = EConstr$ReactTemplate.Vars[/* substl */3](l[0], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl));
      var partial_arg = l[0];
      var partial_arg$1 = EConstr$ReactTemplate.Vars[/* substl */3];
      var decl$1 = Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* set_type */4], t, Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_value */11], (function (param) {
                  return partial_arg$1(partial_arg, param);
                }), Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_name */10], (function (param) {
                      return Namegen$ReactTemplate.named_hd(env, sigma, t, param);
                    }), decl)));
      var partial_arg$2 = EConstr$ReactTemplate.Vars[/* lift */0];
      l[0] = /* :: */[
        EConstr$ReactTemplate.mkRel(1),
        Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                return partial_arg$2(1, param);
              }), l[0])
      ];
      return EConstr$ReactTemplate.push_rel(decl$1, env);
    }
    
  };
  var env$1 = Termops$ReactTemplate.process_rel_context(contract_context, env);
  var partial_arg = l[0];
  var partial_arg$1 = EConstr$ReactTemplate.Vars[/* substl */3];
  return /* tuple */[
          env$1,
          Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return partial_arg$1(partial_arg, param);
                }), lc)
        ];
}

function contract2(env, sigma, a, b) {
  var match = contract(env, sigma, /* :: */[
        a,
        /* :: */[
          b,
          /* [] */0
        ]
      ]);
  var match$1 = match[1];
  var exit = 0;
  if (match$1) {
    var match$2 = match$1[1];
    if (match$2) {
      if (match$2[1]) {
        exit = 1;
      } else {
        return /* tuple */[
                match[0],
                match$1[0],
                match$2[0]
              ];
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "himsg.ml",
            52,
            33
          ]
        ];
  }
  
}

function contract3(env, sigma, a, b, c) {
  var match = contract(env, sigma, /* :: */[
        a,
        /* :: */[
          b,
          /* :: */[
            c,
            /* [] */0
          ]
        ]
      ]);
  var match$1 = match[1];
  var exit = 0;
  if (match$1) {
    var match$2 = match$1[1];
    if (match$2) {
      var match$3 = match$2[1];
      if (match$3) {
        if (match$3[1]) {
          exit = 1;
        } else {
          return /* tuple */[
                  match[0],
                  match$1[0],
                  match$2[0],
                  match$3[0]
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "himsg.ml",
            55,
            37
          ]
        ];
  }
  
}

function contract4(env, sigma, a, b, c, d) {
  var match = contract(env, sigma, /* :: */[
        a,
        /* :: */[
          b,
          /* :: */[
            c,
            /* :: */[
              d,
              /* [] */0
            ]
          ]
        ]
      ]);
  var match$1 = match[1];
  var exit = 0;
  if (match$1) {
    var match$2 = match$1[1];
    if (match$2) {
      var match$3 = match$2[1];
      if (match$3) {
        var match$4 = match$3[1];
        if (match$4) {
          if (match$4[1]) {
            exit = 1;
          } else {
            return /* tuple */[
                    /* tuple */[
                      match[0],
                      match$1[0],
                      match$2[0],
                      match$3[0]
                    ],
                    match$4[0]
                  ];
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "himsg.ml",
            58,
            43
          ]
        ];
  }
  
}

function contract1_vect(env, sigma, a, v) {
  var match = contract(env, sigma, /* :: */[
        a,
        Util$ReactTemplate.$$Array[/* to_list */9](v)
      ]);
  var match$1 = match[1];
  if (match$1) {
    return /* tuple */[
            match[0],
            match$1[0],
            Util$ReactTemplate.$$Array[/* of_list */10](match$1[1])
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "himsg.ml",
            63,
            9
          ]
        ];
  }
}

function contract3$prime(env, sigma, a, b, c, x) {
  var exit = 0;
  if (typeof x === "number") {
    exit = 1;
  } else {
    switch (x.tag | 0) {
      case 0 : 
          var match = contract4(env, sigma, a, b, c, x[1]);
          return /* tuple */[
                  match[0],
                  /* OccurCheck */Block.__(0, [
                      x[0],
                      match[1]
                    ])
                ];
      case 1 : 
          var match$1 = x[0];
          var match$2 = contract1_vect(x[1], sigma, x[2], match$1[1]);
          return /* tuple */[
                  contract3(env, sigma, a, b, c),
                  /* NotClean */Block.__(1, [
                      /* tuple */[
                        match$1[0],
                        match$2[2]
                      ],
                      match$2[0],
                      match$2[1]
                    ])
                ];
      case 2 : 
          var match$3 = contract2(x[0], sigma, x[1], x[2]);
          return /* tuple */[
                  contract3(env, sigma, a, b, c),
                  /* ConversionFailed */Block.__(2, [
                      match$3[0],
                      match$3[1],
                      match$3[2]
                    ])
                ];
      case 6 : 
          var match$4 = x[0];
          var t = EConstr$ReactTemplate.of_constr(match$4[2]);
          var u = EConstr$ReactTemplate.of_constr(match$4[3]);
          var match$5 = contract2(match$4[1], sigma, t, u);
          var t$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match$5[1]);
          var u$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match$5[2]);
          var match$6 = contract3$prime(env, sigma, a, b, c, x[1]);
          return /* tuple */[
                  match$6[0],
                  /* CannotSolveConstraint */Block.__(6, [
                      /* tuple */[
                        match$4[0],
                        match$5[0],
                        t$1,
                        u$1
                      ],
                      match$6[1]
                    ])
                ];
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    return /* tuple */[
            contract3(env, sigma, a, b, c),
            x
          ];
  }
  
}

function j_nf_betaiotaevar(env, sigma, j) {
  return /* record */[
          /* uj_val */j[/* uj_val */0],
          /* uj_type */Reductionops$ReactTemplate.nf_betaiota(env, sigma, j[/* uj_type */1])
        ];
}

function jv_nf_betaiotaevar(env, sigma, jl) {
  return Util$ReactTemplate.$$Array[/* map */12]((function (j) {
                return j_nf_betaiotaevar(env, sigma, j);
              }), jl);
}

function pr_lconstr_env(e, s, c) {
  return Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_lconstr_env(e, s, c));
}

function pr_leconstr_env(e, s, c) {
  return Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_leconstr_env(e, s, c));
}

function pr_ljudge_env(e, s, c) {
  var match = Printer$ReactTemplate.pr_ljudge_env(e, s, c);
  return /* tuple */[
          Pp$ReactTemplate.quote(match[0]),
          Pp$ReactTemplate.quote(match[1])
        ];
}

function canonize_constr(sigma, c) {
  var canonize_binders = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 6 : 
          return EConstr$ReactTemplate.mkProd(/* tuple */[
                      /* Anonymous */0,
                      match[1],
                      match[2]
                    ]);
      case 7 : 
          return EConstr$ReactTemplate.mkLambda(/* tuple */[
                      /* Anonymous */0,
                      match[1],
                      match[2]
                    ]);
      case 8 : 
          return EConstr$ReactTemplate.mkLetIn(/* tuple */[
                      /* Anonymous */0,
                      match[1],
                      match[2],
                      match[3]
                    ]);
      default:
        return EConstr$ReactTemplate.map(sigma, canonize_binders, c);
    }
  };
  return canonize_binders(c);
}

function display_eq(flags, env, sigma, t1, t2) {
  var t1$1 = canonize_constr(sigma, t1);
  var t2$1 = canonize_constr(sigma, t2);
  var ct1 = Flags$ReactTemplate.with_options(flags, (function () {
          return Constrextern$ReactTemplate.extern_constr(/* None */0, /* false */0, env, sigma, t1$1);
        }), /* () */0);
  var ct2 = Flags$ReactTemplate.with_options(flags, (function () {
          return Constrextern$ReactTemplate.extern_constr(/* None */0, /* false */0, env, sigma, t2$1);
        }), /* () */0);
  return Constrexpr_ops$ReactTemplate.constr_expr_eq(ct1, ct2);
}

var explicit_flags_001 = /* :: */[
  /* :: */[
    Constrextern$ReactTemplate.print_implicits,
    /* [] */0
  ],
  /* :: */[
    /* :: */[
      Constrextern$ReactTemplate.print_universes,
      /* [] */0
    ],
    /* :: */[
      /* :: */[
        Constrextern$ReactTemplate.print_universes,
        /* :: */[
          Constrextern$ReactTemplate.print_implicits,
          /* [] */0
        ]
      ],
      /* :: */[
        /* :: */[
          Constrextern$ReactTemplate.print_implicits,
          /* :: */[
            Constrextern$ReactTemplate.print_coercions,
            /* :: */[
              Constrextern$ReactTemplate.print_no_symbol,
              /* [] */0
            ]
          ]
        ],
        /* :: */[
          /* :: */[
            Constrextern$ReactTemplate.print_universes,
            /* :: */[
              Constrextern$ReactTemplate.print_implicits,
              /* :: */[
                Constrextern$ReactTemplate.print_coercions,
                /* :: */[
                  Constrextern$ReactTemplate.print_no_symbol,
                  /* [] */0
                ]
              ]
            ]
          ],
          /* [] */0
        ]
      ]
    ]
  ]
];

var explicit_flags = /* :: */[
  /* [] */0,
  explicit_flags_001
];

function pr_explicit(env, sigma, t1, t2) {
  var env$1 = env;
  var sigma$1 = sigma;
  var t1$1 = t1;
  var t2$1 = t2;
  var _param = explicit_flags;
  while(true) {
    var param = _param;
    if (param) {
      var flags = param[0];
      var equal = display_eq(flags, env$1, sigma$1, t1$1, t2$1);
      if (equal) {
        _param = param[1];
        continue ;
        
      } else {
        var ct1 = Flags$ReactTemplate.with_options(flags, (function () {
                return Constrextern$ReactTemplate.extern_constr(/* None */0, /* false */0, env$1, sigma$1, t1$1);
              }), /* () */0);
        var ct2 = Flags$ReactTemplate.with_options(flags, (function () {
                return Constrextern$ReactTemplate.extern_constr(/* None */0, /* false */0, env$1, sigma$1, t2$1);
              }), /* () */0);
        return /* tuple */[
                Pp$ReactTemplate.quote(Ppconstr$ReactTemplate.pr_lconstr_expr(ct1)),
                Pp$ReactTemplate.quote(Ppconstr$ReactTemplate.pr_lconstr_expr(ct2))
              ];
      }
    } else {
      return /* tuple */[
              Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_leconstr_env(env$1, sigma$1, t1$1)),
              Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_leconstr_env(env$1, sigma$1, t2$1))
            ];
    }
  };
}

function pr_db(env, i) {
  try {
    var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], Environ$ReactTemplate.lookup_rel(i, env));
    if (match) {
      return Names$ReactTemplate.Id[/* print */8](match[0]);
    } else {
      return Pp$ReactTemplate.str("<>");
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("UNBOUND_REL_"), Pp$ReactTemplate.$$int(i));
    } else {
      throw exn;
    }
  }
}

function pr_disjunction(pr, param) {
  if (param) {
    var l = param[1];
    var a = param[0];
    if (l) {
      if (l[1]) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(pr, a), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.spc(/* () */0)), pr_disjunction(pr, l));
      } else {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(pr, a), Pp$ReactTemplate.str(" or")), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pr, l[0]));
      }
    } else {
      return Curry._1(pr, a);
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "himsg.ml",
            199,
            10
          ]
        ];
  }
}

function pr_puniverses(f, env, param) {
  var u = param[1];
  return Pp$ReactTemplate.$plus$plus(Curry._2(f, env, param[0]), Flags$ReactTemplate.is_universe_polymorphism(/* () */0) && !Univ$ReactTemplate.Instance[/* is_empty */1](u) ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(*"), Univ$ReactTemplate.Instance[/* pr */11](Universes$ReactTemplate.pr_with_global_universes, /* None */0)(u)), Pp$ReactTemplate.str("*)")) : Pp$ReactTemplate.mt(/* () */0));
}

function explain_unification_error(env, sigma, p1, p2, param) {
  if (param) {
    var aux = function (p1, p2, param) {
      if (typeof param === "number") {
        return /* [] */0;
      } else {
        switch (param.tag | 0) {
          case 0 : 
              return /* :: */[
                      Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("cannot define "), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_existential_key(sigma, param[0]))), Pp$ReactTemplate.strbrk(" with term ")), pr_leconstr_env(env, sigma, param[1])), Pp$ReactTemplate.strbrk(" that would depend on itself")),
                      /* [] */0
                    ];
          case 1 : 
              var env$1 = param[1];
              var match = param[0];
              var args = match[1];
              return /* :: */[
                      Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("cannot instantiate "), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_existential_key(sigma, match[0]))), Pp$ReactTemplate.strbrk(" because ")), pr_leconstr_env(env$1, sigma, param[2])), Pp$ReactTemplate.strbrk(" is not in its scope")), Util$ReactTemplate.$$Array[/* is_empty */23](args) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk(": available arguments are "), Pp$ReactTemplate.pr_sequence((function (param) {
                                        return pr_leconstr_env(env$1, sigma, param);
                                      }), Curry._1(Util$ReactTemplate.List[/* rev */4], Util$ReactTemplate.$$Array[/* to_list */9](args))))),
                      /* [] */0
                    ];
          case 2 : 
              var env$2 = param[0];
              var t1 = Reductionops$ReactTemplate.nf_betaiota(env$2, sigma, param[1]);
              var t2 = Reductionops$ReactTemplate.nf_betaiota(env$2, sigma, param[2]);
              if (EConstr$ReactTemplate.eq_constr(sigma, t1, p1) && EConstr$ReactTemplate.eq_constr(sigma, t2, p2)) {
                return /* [] */0;
              } else {
                var env$3 = Namegen$ReactTemplate.make_all_name_different(env$2, sigma);
                if (!EConstr$ReactTemplate.eq_constr(sigma, t1, p1) || !EConstr$ReactTemplate.eq_constr(sigma, t2, p2)) {
                  var match$1 = pr_explicit(env$3, sigma, t1, t2);
                  return /* :: */[
                          Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("cannot unify "), match$1[0]), Pp$ReactTemplate.strbrk(" and ")), match$1[1]),
                          /* [] */0
                        ];
                } else {
                  return /* [] */0;
                }
              }
              break;
          case 3 : 
              return /* :: */[
                      Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("instance for "), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_existential_key(sigma, param[0]))), Pp$ReactTemplate.strbrk(" refers to a metavariable - please report your example")), Pp$ReactTemplate.strbrk("at ")), Pp$ReactTemplate.str(Coq_config$ReactTemplate.wwwbugtracker)), Pp$ReactTemplate.str(".")),
                      /* [] */0
                    ];
          case 4 : 
              var match$2 = pr_explicit(param[1], sigma, param[2], param[3]);
              return /* :: */[
                      Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("unable to find a well-typed instantiation for "), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_existential_key(sigma, param[0]))), Pp$ReactTemplate.strbrk(": cannot ensure that ")), match$2[0]), Pp$ReactTemplate.strbrk(" is a subtype of ")), match$2[1]),
                      /* [] */0
                    ];
          case 5 : 
              if (Constrextern$ReactTemplate.print_universes[0]) {
                return /* :: */[
                        Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("universe inconsistency: "), Univ$ReactTemplate.explain_universe_inconsistency(Universes$ReactTemplate.pr_with_global_universes, param[0])),
                        /* [] */0
                      ];
              } else {
                return /* :: */[
                        Pp$ReactTemplate.str("universe inconsistency"),
                        /* [] */0
                      ];
              }
          case 6 : 
              var match$3 = param[0];
              var t = EConstr$ReactTemplate.of_constr(match$3[2]);
              var u = EConstr$ReactTemplate.of_constr(match$3[3]);
              var env$4 = Namegen$ReactTemplate.make_all_name_different(match$3[1], sigma);
              return /* :: */[
                      Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("cannot satisfy constraint "), pr_leconstr_env(env$4, sigma, t)), Pp$ReactTemplate.str(" == ")), pr_leconstr_env(env$4, sigma, u)),
                      aux(t, u, param[1])
                    ];
          
        }
      }
    };
    var l = aux(p1, p2, param[0]);
    if (l) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("(")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_semicolon, (function (x) {
                            return x;
                          }), l)), Pp$ReactTemplate.str(")"));
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function explain_actual_type(env, sigma, j, t, reason) {
  var env$1 = Namegen$ReactTemplate.make_all_name_different(env, sigma);
  var j$1 = j_nf_betaiotaevar(env$1, sigma, j);
  var t$1 = Reductionops$ReactTemplate.nf_betaiota(env$1, sigma, t);
  var pe = Printer$ReactTemplate.pr_ne_context_of(Pp$ReactTemplate.str("In environment"), env$1, sigma);
  var pc = pr_leconstr_env(env$1, sigma, Environ$ReactTemplate.j_val(j$1));
  var match = pr_explicit(env$1, sigma, t$1, Environ$ReactTemplate.j_type(j$1));
  var ppreason = explain_unification_error(env$1, sigma, j$1[/* uj_type */1], t$1, reason);
  return Pp$ReactTemplate.$plus$plus(pe, Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The term"), Pp$ReactTemplate.brk(/* tuple */[
                                                                      1,
                                                                      1
                                                                    ])), pc), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("has type")), Pp$ReactTemplate.brk(/* tuple */[
                                                      1,
                                                      1
                                                    ])), match[1]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("while it is expected to have type")), Pp$ReactTemplate.brk(/* tuple */[
                                      1,
                                      1
                                    ])), match[0]), ppreason), Pp$ReactTemplate.str("."))));
}

function pr_trailing_ne_context_of(env, sigma) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], Environ$ReactTemplate.rel_context(env)) && Curry._1(Util$ReactTemplate.List[/* is_empty */45], Environ$ReactTemplate.named_context(env))) {
    return Pp$ReactTemplate.str(".");
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" in environment:"), Printer$ReactTemplate.pr_context_unlimited(env, sigma));
  }
}

function explain_evar_kind(env, sigma, evk, ty, param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("an internal placeholder of type "), ty);
      case 1 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("an existential variable of type "), ty);
      case 2 : 
          return Pp$ReactTemplate.strbrk("the type of an impossible pattern-matching clause");
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var id = Option$ReactTemplate.get(param[1][1]);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("the implicit parameter "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of")), Pp$ReactTemplate.spc(/* () */0)), Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], param[0])), Pp$ReactTemplate.strbrk(" whose type is ")), ty);
      case 1 : 
          var match = param[0];
          if (match) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("the type of "), Names$ReactTemplate.Id[/* print */8](match[0]));
          } else {
            return Pp$ReactTemplate.strbrk("the type of this anonymous binder");
          }
      case 2 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("the existential variable named "), Names$ReactTemplate.Id[/* print */8](param[0]));
      case 3 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("this placeholder of type "), ty);
      case 4 : 
          if (param[0] !== 0) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("a subterm of type "), ty), Pp$ReactTemplate.strbrk(" in the type of this pattern-matching problem"));
          } else {
            return Pp$ReactTemplate.strbrk("the type of this pattern-matching problem");
          }
      case 5 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("the "), Pp$ReactTemplate.pr_nth(param[1])), Pp$ReactTemplate.strbrk(" argument of the inductive type (")), Printer$ReactTemplate.pr_inductive(env, param[0])), Pp$ReactTemplate.strbrk(") of this term"));
      case 6 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "himsg.ml",
                  558,
                  6
                ]
              ];
      case 7 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("an instance of type "), ty), Pp$ReactTemplate.str(" for the variable ")), Names$ReactTemplate.Id[/* print */8](param[0]));
      case 8 : 
          var evk$prime = param[0];
          var evi = Evd$ReactTemplate.find(sigma, evk$prime);
          var match$1 = evi[/* evar_body */2];
          var pc;
          if (match$1) {
            pc = pr_leconstr_env(env, sigma, EConstr$ReactTemplate.of_constr(match$1[0]));
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "himsg.ml",
                    566,
                    22
                  ]
                ];
          }
          var ty$prime = EConstr$ReactTemplate.of_constr(evi[/* evar_concl */0]);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_existential_key(sigma, evk), Pp$ReactTemplate.str(" of type ")), ty), Pp$ReactTemplate.str(" in the partial instance ")), pc), Pp$ReactTemplate.str(" found for ")), explain_evar_kind(env, sigma, evk$prime, pr_leconstr_env(env, sigma, ty$prime), evi[/* evar_source */4][1]));
      
    }
  }
}

function explain_typeclass_resolution(_, sigma, evi, _$1) {
  var match = Typeclasses$ReactTemplate.class_of_constr(sigma, EConstr$ReactTemplate.of_constr(evi[/* evar_concl */0]));
  if (match) {
    var env = Evd$ReactTemplate.evar_filtered_env(evi);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str("Could not find an instance for ")), pr_lconstr_env(env, sigma, evi[/* evar_concl */0])), pr_trailing_ne_context_of(env, sigma));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function explain_placeholder_kind(_, sigma, c, e) {
  if (e) {
    return Pp$ReactTemplate.strbrk(" (several distinct possible type class instances found)");
  } else {
    var match = Typeclasses$ReactTemplate.class_of_constr(sigma, EConstr$ReactTemplate.of_constr(c));
    if (match) {
      return Pp$ReactTemplate.strbrk(" (no type class instance found)");
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  }
}

function explain_type_error(env, sigma, err) {
  var env$1 = Namegen$ReactTemplate.make_all_name_different(env, sigma);
  switch (err.tag | 0) {
    case 0 : 
        var env$2 = env$1;
        var sigma$1 = sigma;
        var n = err[0];
        var pe = Printer$ReactTemplate.pr_ne_context_of(Pp$ReactTemplate.str("In environment"), env$2, sigma$1);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unbound reference: "), pe), Pp$ReactTemplate.str("The reference ")), Pp$ReactTemplate.$$int(n)), Pp$ReactTemplate.str(" is free."));
    case 1 : 
        var v = err[0];
        var $$var = Names$ReactTemplate.Id[/* print */8](v);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such section variable or assumption: "), $$var), Pp$ReactTemplate.str("."));
    case 2 : 
        var env$3 = env$1;
        var sigma$2 = sigma;
        var j = err[0];
        var pe$1 = Printer$ReactTemplate.pr_ne_context_of(Pp$ReactTemplate.str("In environment"), env$3, sigma$2);
        var match = pr_ljudge_env(env$3, sigma$2, j);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pe$1, Pp$ReactTemplate.str("The term")), Pp$ReactTemplate.brk(/* tuple */[
                                                    1,
                                                    1
                                                  ])), match[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("has type")), Pp$ReactTemplate.spc(/* () */0)), match[1]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("which should be Set, Prop or Type."));
    case 3 : 
        var env$4 = env$1;
        var sigma$3 = sigma;
        var j$1 = err[0];
        var pe$2 = Printer$ReactTemplate.pr_ne_context_of(Pp$ReactTemplate.str("In environment"), env$4, sigma$3);
        var match$1 = pr_ljudge_env(env$4, sigma$3, j$1);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pe$2, Pp$ReactTemplate.str("Cannot declare a variable or hypothesis over the term")), Pp$ReactTemplate.brk(/* tuple */[
                                                    1,
                                                    1
                                                  ])), match$1[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of type")), Pp$ReactTemplate.spc(/* () */0)), match$1[1]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("because this term is not a type."));
    case 4 : 
        var sigma$4 = sigma;
        var id = err[0];
        var c = err[1];
        var pc = Printer$ReactTemplate.pr_global(Termops$ReactTemplate.global_of_constr(sigma$4, c)[0]);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pc, Pp$ReactTemplate.strbrk(" depends on the variable ")), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.strbrk(" which is not declared in the context."));
    case 5 : 
        var env$5 = env$1;
        var sigma$5 = sigma;
        var ind = err[0];
        var sorts = err[1];
        var c$1 = err[2];
        var pj = err[3];
        var okinds = err[4];
        var env$6 = Namegen$ReactTemplate.make_all_name_different(env$5, sigma$5);
        var pi = Printer$ReactTemplate.pr_inductive(env$6, ind[0]);
        var pc$1 = pr_leconstr_env(env$6, sigma$5, c$1);
        var msg;
        if (okinds) {
          var match$2 = okinds[0];
          var pki = Termops$ReactTemplate.pr_sort_family(match$2[1]);
          var pkp = Termops$ReactTemplate.pr_sort_family(match$2[0]);
          var explanation;
          switch (match$2[2]) {
            case 0 : 
                explanation = "proofs can be eliminated only to build proofs";
                break;
            case 1 : 
                explanation = "strong elimination on non-small inductive types leads to paradoxes";
                break;
            case 2 : 
                explanation = "wrong arity";
                break;
            
          }
          var ppar = pr_disjunction((function (s) {
                  return Pp$ReactTemplate.quote(Termops$ReactTemplate.pr_sort_family(s));
                }), sorts);
          var ppt = pr_leconstr_env(env$6, sigma$5, EConstr$ReactTemplate.decompose_prod_assum(sigma$5, pj[/* uj_type */1])[1]);
          msg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("the return type has sort"), Pp$ReactTemplate.spc(/* () */0)), ppt), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("while it")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("should be ")), ppar), Pp$ReactTemplate.str("."))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Elimination of an inductive object of sort "), pki), Pp$ReactTemplate.brk(/* tuple */[
                                                        1,
                                                        0
                                                      ])), Pp$ReactTemplate.str("is not allowed on a predicate in sort ")), pkp), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("because")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(explanation)), Pp$ReactTemplate.str("."))));
        } else {
          msg = Pp$ReactTemplate.str("ill-formed elimination predicate.");
        }
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incorrect elimination of"), Pp$ReactTemplate.spc(/* () */0)), pc$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("in the inductive type")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.quote(pi)), Pp$ReactTemplate.str(":"))), Pp$ReactTemplate.fnl(/* () */0)), msg);
    case 6 : 
        var env$7 = env$1;
        var sigma$6 = sigma;
        var cj = err[0];
        var env$8 = Namegen$ReactTemplate.make_all_name_different(env$7, sigma$6);
        var pc$2 = pr_leconstr_env(env$8, sigma$6, cj[/* uj_val */0]);
        var pct = pr_leconstr_env(env$8, sigma$6, cj[/* uj_type */1]);
        var match$3 = EConstr$ReactTemplate.kind(sigma$6, cj[/* uj_type */1]);
        if (match$3.tag === 3) {
          return Pp$ReactTemplate.str("Cannot infer a type for this expression.");
        } else {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The term"), Pp$ReactTemplate.brk(/* tuple */[
                                                      1,
                                                      1
                                                    ])), pc$2), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("has type")), Pp$ReactTemplate.brk(/* tuple */[
                                      1,
                                      1
                                    ])), pct), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("which is not a (co-)inductive type."));
        }
    case 7 : 
        var param = err[0];
        var ci = err[1];
        var ind$1 = param[0];
        var pi$1 = Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), ind$1);
        if (Names$ReactTemplate.eq_ind(ci[/* ci_ind */0], ind$1)) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Pattern-matching expression on an object of inductive type"), Pp$ReactTemplate.spc(/* () */0)), pi$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("has invalid information."));
        } else {
          var pc$3 = Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), ci[/* ci_ind */0]);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("A term of inductive type"), Pp$ReactTemplate.spc(/* () */0)), pi$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("was given to a pattern-matching expression on the inductive type")), Pp$ReactTemplate.spc(/* () */0)), pc$3), Pp$ReactTemplate.str("."));
        }
    case 8 : 
        var env$9 = env$1;
        var sigma$7 = sigma;
        var cj$1 = err[0];
        var expn = err[1];
        var env$10 = Namegen$ReactTemplate.make_all_name_different(env$9, sigma$7);
        var pc$4 = pr_leconstr_env(env$10, sigma$7, cj$1[/* uj_val */0]);
        var pct$1 = pr_leconstr_env(env$10, sigma$7, cj$1[/* uj_type */1]);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Matching on term"), Pp$ReactTemplate.brk(/* tuple */[
                                                            1,
                                                            1
                                                          ])), pc$4), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of type")), Pp$ReactTemplate.brk(/* tuple */[
                                            1,
                                            1
                                          ])), pct$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("expects ")), Pp$ReactTemplate.$$int(expn)), Pp$ReactTemplate.str(" branches."));
    case 9 : 
        var env$11 = env$1;
        var sigma$8 = sigma;
        var c$2 = err[0];
        var ci$1 = err[1];
        var actty = err[2];
        var expty = err[3];
        var env$12 = Namegen$ReactTemplate.make_all_name_different(env$11, sigma$8);
        var pc$5 = pr_leconstr_env(env$12, sigma$8, c$2);
        var match$4 = pr_explicit(env$12, sigma$8, Reductionops$ReactTemplate.nf_betaiota(env$11, sigma$8, actty), Reductionops$ReactTemplate.nf_betaiota(env$11, sigma$8, expty));
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("In pattern-matching on term"), Pp$ReactTemplate.brk(/* tuple */[
                                                                                1,
                                                                                1
                                                                              ])), pc$5), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.strbrk("the branch for constructor")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.quote(pr_puniverses(Printer$ReactTemplate.pr_constructor, env$12, ci$1))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("has type")), Pp$ReactTemplate.brk(/* tuple */[
                                                1,
                                                1
                                              ])), match$4[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("which should be")), Pp$ReactTemplate.brk(/* tuple */[
                                1,
                                1
                              ])), match$4[1]), Pp$ReactTemplate.str("."));
    case 10 : 
        var env$13 = env$1;
        var sigma$9 = sigma;
        var param$1 = err[0];
        var j$2 = err[1];
        var $$var$1 = param$1[1];
        var pe$3 = Printer$ReactTemplate.pr_ne_context_of(Pp$ReactTemplate.str("In environment"), env$13, sigma$9);
        var pv = Printer$ReactTemplate.pr_letype_env(env$13, sigma$9, $$var$1);
        var match$5 = pr_ljudge_env(Termops$ReactTemplate.push_rel_assum(/* tuple */[
                  param$1[0],
                  $$var$1
                ], env$13), sigma$9, j$2);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pe$3, Pp$ReactTemplate.str("Cannot generalize")), Pp$ReactTemplate.brk(/* tuple */[
                                                                        1,
                                                                        1
                                                                      ])), pv), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("over")), Pp$ReactTemplate.brk(/* tuple */[
                                                        1,
                                                        1
                                                      ])), match$5[0]), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("it has type")), Pp$ReactTemplate.spc(/* () */0)), match$5[1]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("which should be Set, Prop or Type."));
    case 11 : 
        return explain_actual_type(env$1, sigma, err[0], err[1], /* None */0);
    case 12 : 
        var env$14 = env$1;
        var sigma$10 = sigma;
        var param$2 = err[0];
        var rator = err[1];
        var randl = err[2];
        var randl$1 = jv_nf_betaiotaevar(env$14, sigma$10, randl);
        var actualtyp = Reductionops$ReactTemplate.nf_betaiota(env$14, sigma$10, param$2[2]);
        var env$15 = Namegen$ReactTemplate.make_all_name_different(env$14, sigma$10);
        var match$6 = pr_explicit(env$15, sigma$10, actualtyp, param$2[1]);
        var nargs = randl$1.length;
        var match$7 = pr_ljudge_env(env$15, sigma$10, rator);
        var term_string1 = Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], nargs, "term"));
        var term_string2 = nargs > 1 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The "), Pp$ReactTemplate.pr_nth(param$2[0])), Pp$ReactTemplate.str(" term")) : Pp$ReactTemplate.str("This term");
        var appl = Pp$ReactTemplate.prvect_with_sep(Pp$ReactTemplate.fnl, (function (c) {
                var match = pr_ljudge_env(env$15, sigma$10, c);
                return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(match[0], Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(": ")), match[1]));
              }), randl$1);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Illegal application: "), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("The term")), Pp$ReactTemplate.brk(/* tuple */[
                                                                                                            1,
                                                                                                            1
                                                                                                          ])), match$7[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of type")), Pp$ReactTemplate.brk(/* tuple */[
                                                                                            1,
                                                                                            1
                                                                                          ])), match$7[1]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("cannot be applied to the ")), term_string1), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str(" ")), Pp$ReactTemplate.v(0, appl)), Pp$ReactTemplate.fnl(/* () */0)), term_string2), Pp$ReactTemplate.str(" has type")), Pp$ReactTemplate.brk(/* tuple */[
                                                1,
                                                1
                                              ])), match$6[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("which should be coercible to")), Pp$ReactTemplate.brk(/* tuple */[
                                1,
                                1
                              ])), match$6[1]), Pp$ReactTemplate.str("."));
    case 13 : 
        var env$16 = env$1;
        var sigma$11 = sigma;
        var rator$1 = err[0];
        var randl$2 = err[1];
        var env$17 = Namegen$ReactTemplate.make_all_name_different(env$16, sigma$11);
        var nargs$1 = randl$2.length;
        var pr = pr_leconstr_env(env$17, sigma$11, rator$1[/* uj_val */0]);
        var prt = pr_leconstr_env(env$17, sigma$11, rator$1[/* uj_type */1]);
        var appl$1 = Pp$ReactTemplate.prvect_with_sep(Pp$ReactTemplate.fnl, (function (c) {
                var pc = pr_leconstr_env(env$17, sigma$11, c[/* uj_val */0]);
                var pct = pr_leconstr_env(env$17, sigma$11, c[/* uj_type */1]);
                return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pc, Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(": ")), pct));
              }), randl$2);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Illegal application (Non-functional construction): "), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("The expression")), Pp$ReactTemplate.brk(/* tuple */[
                                                                    1,
                                                                    1
                                                                  ])), pr), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of type")), Pp$ReactTemplate.brk(/* tuple */[
                                                    1,
                                                    1
                                                  ])), prt), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("cannot be applied to the ")), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], nargs$1, "term"))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str(" ")), Pp$ReactTemplate.v(0, appl$1));
    case 14 : 
        var env$18 = env$1;
        var sigma$12 = sigma;
        var err$1 = err[0];
        var names = err[1];
        var i = err[2];
        var fixenv = err[3];
        var vdefj = err[4];
        var prt_name = function (i) {
          var match = Caml_array.caml_array_get(names, i);
          if (match) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Recursive definition of "), Names$ReactTemplate.Id[/* print */8](match[0]));
          } else {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The "), Pp$ReactTemplate.pr_nth(i)), Pp$ReactTemplate.str(" definition"));
          }
        };
        var st;
        if (typeof err$1 === "number") {
          st = err$1 ? Pp$ReactTemplate.str("Nested recursive occurrences") : Pp$ReactTemplate.str("Not enough abstractions in the definition");
        } else {
          switch (err$1.tag | 0) {
            case 0 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Recursive definition on"), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("which should be a recursive inductive type"));
                break;
            case 1 : 
                var lt = err$1[3];
                var le = err$1[2];
                var match$8 = err$1[1];
                var arg_env = Namegen$ReactTemplate.make_all_name_different(match$8[0], sigma$12);
                var match$9 = Caml_array.caml_array_get(names, err$1[0]);
                var called = match$9 ? Names$ReactTemplate.Id[/* print */8](match$9[0]) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("the "), Pp$ReactTemplate.pr_nth(i)), Pp$ReactTemplate.str(" definition"));
                var pr_db$1 = function (x) {
                  return Pp$ReactTemplate.quote(pr_db(env$18, x));
                };
                var vars;
                if (lt) {
                  vars = lt[1] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("one of the following variables: "), Pp$ReactTemplate.pr_sequence(pr_db$1, lt)) : Pp$ReactTemplate.quote(pr_db(env$18, lt[0]));
                } else if (le) {
                  vars = le[1] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("a subterm of the following variables: "), Pp$ReactTemplate.pr_sequence(pr_db$1, le)) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("a subterm of "), Pp$ReactTemplate.quote(pr_db(env$18, le[0])));
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "himsg.ml",
                          438,
                          23
                        ]
                      ];
                }
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Recursive call to "), called), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.strbrk("has principal argument equal to")), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(arg_env, sigma$12, match$8[1])), Pp$ReactTemplate.strbrk(" instead of ")), vars);
                break;
            case 2 : 
                var match$10 = Caml_array.caml_array_get(names, err$1[0]);
                var called$1 = match$10 ? Names$ReactTemplate.Id[/* print */8](match$10[0]) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("the "), Pp$ReactTemplate.pr_nth(i)), Pp$ReactTemplate.str(" definition"));
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Recursive call to "), called$1), Pp$ReactTemplate.str(" has not enough arguments"));
                break;
            case 3 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The codomain is"), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("which should be a coinductive type"));
                break;
            case 4 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unguarded recursive call in"), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0]));
                break;
            case 5 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Recursive call forbidden in the domain of an abstraction:"), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0]));
                break;
            case 6 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Recursive call on a non-recursive argument of constructor"), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0]));
                break;
            case 7 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Recursive call forbidden in the type of a recursive definition"), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0]));
                break;
            case 8 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Invalid recursive call in a branch of"), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0]));
                break;
            case 9 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Invalid recursive call in the argument of \"match\" in"), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0]));
                break;
            case 10 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Invalid recursive call in the \"return\" clause of \"match\" in"), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0]));
                break;
            case 11 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Sub-expression "), pr_leconstr_env(env$18, sigma$12, err$1[0])), Pp$ReactTemplate.strbrk(" not in guarded form (should be a constructor,")), Pp$ReactTemplate.strbrk(" an abstraction, a match, a cofix or a recursive call)"));
                break;
            case 12 : 
                st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The return clause of the following pattern matching should be"), Pp$ReactTemplate.strbrk(" a coinductive type:")), Pp$ReactTemplate.spc(/* () */0)), pr_leconstr_env(env$18, sigma$12, err$1[0]));
                break;
            
          }
        }
        var tmp;
        try {
          var fixenv$1 = Namegen$ReactTemplate.make_all_name_different(fixenv, sigma$12);
          var pvd = pr_leconstr_env(fixenv$1, sigma$12, Caml_array.caml_array_get(vdefj, i)[/* uj_val */0]);
          tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Recursive definition is:"), Pp$ReactTemplate.spc(/* () */0)), pvd), Pp$ReactTemplate.str("."));
        }
        catch (raw_e){
          var e = Js_exn.internalToOCamlException(raw_e);
          if (CErrors$ReactTemplate.noncritical(e)) {
            tmp = Pp$ReactTemplate.mt(/* () */0);
          } else {
            throw e;
          }
        }
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(prt_name(i), Pp$ReactTemplate.str(" is ill-formed.")), Pp$ReactTemplate.fnl(/* () */0)), Printer$ReactTemplate.pr_ne_context_of(Pp$ReactTemplate.str("In environment"), env$18, sigma$12)), st), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)), tmp);
    case 15 : 
        var env$19 = env$1;
        var sigma$13 = sigma;
        var i$1 = err[0];
        var vdefj$1 = err[2];
        var vargs = err[3];
        var env$20 = Namegen$ReactTemplate.make_all_name_different(env$19, sigma$13);
        var pvd$1 = pr_leconstr_env(env$20, sigma$13, Caml_array.caml_array_get(vdefj$1, i$1)[/* uj_val */0]);
        var match$11 = pr_explicit(env$20, sigma$13, Caml_array.caml_array_get(vdefj$1, i$1)[/* uj_type */1], Caml_array.caml_array_get(vargs, i$1));
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The "), vdefj$1.length !== 1 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_nth(i$1 + 1 | 0), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.str("recursive definition")), Pp$ReactTemplate.spc(/* () */0)), pvd$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("has type")), Pp$ReactTemplate.spc(/* () */0)), match$11[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("while it should be")), Pp$ReactTemplate.spc(/* () */0)), match$11[1]), Pp$ReactTemplate.str("."));
    case 16 : 
        var sigma$14 = sigma;
        var cst = err[0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Unsatisfied constraints: "), Univ$ReactTemplate.pr_constraints(Termops$ReactTemplate.pr_evd_level(sigma$14))(cst)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("(maybe a bugged tactic)."));
    
  }
}

function pr_position(param) {
  var cl = param[0];
  var clpos;
  if (cl) {
    var match = cl[0];
    var id = match[0];
    switch (match[1]) {
      case 0 : 
          clpos = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" of hypothesis "), Names$ReactTemplate.Id[/* print */8](id));
          break;
      case 1 : 
          clpos = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" of the type of hypothesis "), Names$ReactTemplate.Id[/* print */8](id));
          break;
      case 2 : 
          clpos = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" of the body of hypothesis "), Names$ReactTemplate.Id[/* print */8](id));
          break;
      
    }
  } else {
    clpos = Pp$ReactTemplate.str(" of the goal");
  }
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(param[1]), clpos);
}

function pr_constraints(printenv, env, sigma, evars, cstrs) {
  var match = Curry._1(Evar$ReactTemplate.$$Map[/* choose */19], evars);
  var evi = match[1];
  if (Curry._2(Evar$ReactTemplate.$$Map[/* for_all */11], (function (_, evi$prime) {
            return Environ$ReactTemplate.eq_named_context_val(evi[/* evar_hyps */1], evi$prime[/* evar_hyps */1]);
          }), evars)) {
    var l = Curry._1(Evar$ReactTemplate.$$Map[/* bindings */16], evars);
    var env$prime = Environ$ReactTemplate.reset_with_named_context(evi[/* evar_hyps */1], env);
    var pe = printenv ? Printer$ReactTemplate.pr_ne_context_of(Pp$ReactTemplate.str("In environment:"), env$prime, sigma) : Pp$ReactTemplate.mt(/* () */0);
    var evs = Pp$ReactTemplate.prlist((function (param) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Printer$ReactTemplate.pr_existential_key(sigma, param[0])), Pp$ReactTemplate.str(" : ")), pr_lconstr_env(env$prime, sigma, param[1][/* evar_concl */0])), Pp$ReactTemplate.fnl(/* () */0));
          }), l);
    return Pp$ReactTemplate.h(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pe, evs), Termops$ReactTemplate.pr_evar_constraints(sigma, cstrs)));
  } else {
    var filter = function (evk, _) {
      return Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], evk, evars);
    };
    return Termops$ReactTemplate.pr_evar_map_filter(/* Some */[/* false */0], filter, sigma);
  }
}

function explain_pretype_error(env, sigma, err) {
  var env$1 = Evardefine$ReactTemplate.env_nf_betaiotaevar(sigma, env);
  var env$2 = Namegen$ReactTemplate.make_all_name_different(env$1, sigma);
  switch (err.tag | 0) {
    case 0 : 
        var env$3 = env$2;
        var sigma$1 = sigma;
        var c = err[0];
        var env$4 = Namegen$ReactTemplate.make_all_name_different(env$3, sigma$1);
        var pe = pr_leconstr_env(env$4, sigma$1, c);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot infer the return type of pattern-matching on"), Pp$ReactTemplate.ws(1)), pe), Pp$ReactTemplate.str("."));
    case 1 : 
        var j = err[0];
        var match = contract3$prime(env$2, sigma, j[/* uj_val */0], j[/* uj_type */1], err[1], err[2]);
        var match$1 = match[0];
        var j_000 = /* uj_val */match$1[1];
        var j_001 = /* uj_type */match$1[2];
        var j$1 = /* record */[
          j_000,
          j_001
        ];
        return explain_actual_type(match$1[0], sigma, j$1, match$1[3], /* Some */[match[1]]);
    case 2 : 
        var env$5 = env$2;
        var sigma$2 = sigma;
        var ev = err[0];
        var rhs = err[1];
        var env$6 = Namegen$ReactTemplate.make_all_name_different(env$5, sigma$2);
        var pt = pr_leconstr_env(env$6, sigma$2, rhs);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot define "), Printer$ReactTemplate.pr_existential_key(sigma$2, ev)), Pp$ReactTemplate.str(" with term")), Pp$ReactTemplate.brk(/* tuple */[
                                    1,
                                    1
                                  ])), pt), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("that would depend on itself."));
    case 3 : 
        var sigma$3 = sigma;
        var evk = err[0];
        var explain = err[1];
        var evi = Evarutil$ReactTemplate.nf_evar_info(sigma$3, Evd$ReactTemplate.find_undefined(sigma$3, evk));
        var env$7 = Evd$ReactTemplate.evar_filtered_env(evi);
        var type_of_hole = pr_lconstr_env(env$7, sigma$3, evi[/* evar_concl */0]);
        var pe$1 = pr_trailing_ne_context_of(env$7, sigma$3);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Cannot infer "), explain_evar_kind(env$7, sigma$3, evk, type_of_hole, evi[/* evar_source */4][1])), explain_placeholder_kind(env$7, sigma$3, evi[/* evar_concl */0], explain)), pe$1);
    case 4 : 
        var match$2 = contract2(env$2, sigma, err[0], err[1]);
        var env$8 = match$2[0];
        var sigma$4 = sigma;
        var m = match$2[1];
        var n = match$2[2];
        var e = err[2];
        var env$9 = Namegen$ReactTemplate.make_all_name_different(env$8, sigma$4);
        var match$3 = pr_explicit(env$9, sigma$4, m, n);
        var ppreason = explain_unification_error(env$9, sigma$4, m, n, e);
        var pe$2 = Printer$ReactTemplate.pr_ne_context_of(Pp$ReactTemplate.str("In environment"), env$9, sigma$4);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pe$2, Pp$ReactTemplate.str("Unable to unify")), Pp$ReactTemplate.brk(/* tuple */[
                                                    1,
                                                    1
                                                  ])), match$3[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.brk(/* tuple */[
                                    1,
                                    1
                                  ])), match$3[1]), ppreason), Pp$ReactTemplate.str("."));
    case 5 : 
        var env$10 = env$2;
        var sigma$5 = sigma;
        var m$1 = err[0];
        var n$1 = err[1];
        var subn = err[2];
        var pm = pr_leconstr_env(env$10, sigma$5, m$1);
        var pn = pr_leconstr_env(env$10, sigma$5, n$1);
        var psubn = pr_leconstr_env(env$10, sigma$5, subn);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unable to unify"), Pp$ReactTemplate.brk(/* tuple */[
                                                                1,
                                                                1
                                                              ])), pm), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.brk(/* tuple */[
                                                1,
                                                1
                                              ])), pn), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("as")), Pp$ReactTemplate.brk(/* tuple */[
                                1,
                                1
                              ])), psubn), Pp$ReactTemplate.str(" contains local variables."));
    case 6 : 
        var env$11 = env$2;
        var sigma$6 = sigma;
        var m$2 = err[0];
        var n$2 = err[1];
        var pm$1 = pr_leconstr_env(env$11, sigma$6, m$2);
        var pn$1 = pr_leconstr_env(env$11, sigma$6, n$2);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("This binding has type"), Pp$ReactTemplate.brk(/* tuple */[
                                                1,
                                                1
                                              ])), pm$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("which should be unifiable with")), Pp$ReactTemplate.brk(/* tuple */[
                                1,
                                1
                              ])), pn$1), Pp$ReactTemplate.str("."));
    case 7 : 
        var env$12 = env$2;
        var sigma$7 = sigma;
        var ty = err[0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot find a well-typed generalisation of the goal with type: "), pr_leconstr_env(env$12, sigma$7, ty)), Pp$ReactTemplate.str("."));
    case 8 : 
        var env$13 = env$2;
        var sigma$8 = sigma;
        var c$1 = err[0];
        var id = err[1];
        var c$2 = EConstr$ReactTemplate.to_constr(sigma$8, c$1);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Found no subterm matching "), pr_lconstr_env(env$13, sigma$8, c$2)), Pp$ReactTemplate.str(" in ")), id ? Names$ReactTemplate.Id[/* print */8](id[0]) : Pp$ReactTemplate.str("the current goal")), Pp$ReactTemplate.str("."));
    case 9 : 
        var env$14 = env$2;
        var sigma$9 = sigma;
        var p = err[0];
        var l = err[1];
        var e$1 = Option$ReactTemplate.map((function (param) {
                return explain_type_error(param[0], sigma, param[1]);
              }), err[2]);
        var p$1 = EConstr$ReactTemplate.to_constr(sigma$9, p);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Abstracting over the "), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], Curry._1(Util$ReactTemplate.List[/* length */0], l), "term"))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.pr_enum((function (c) {
                                                          return pr_lconstr_env(env$14, sigma$9, EConstr$ReactTemplate.to_constr(sigma$9, c));
                                                        }), l))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("leads to a term")), Pp$ReactTemplate.spc(/* () */0)), Printer$ReactTemplate.pr_lconstr_goal_style_env(env$14, sigma$9, p$1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("which is ill-typed.")), e$1 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str("Reason is: ")), e$1[0]) : Pp$ReactTemplate.mt(/* () */0));
    case 10 : 
        var env$15 = env$2;
        var sigma$10 = sigma;
        var na = err[0];
        var abs = err[1];
        var expected = err[2];
        var result = err[3];
        var abs$1 = EConstr$ReactTemplate.to_constr(sigma$10, abs);
        var expected$1 = EConstr$ReactTemplate.to_constr(sigma$10, expected);
        var result$1 = EConstr$ReactTemplate.to_constr(sigma$10, result);
        var ppname = na ? Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](na[0]), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.mt(/* () */0);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot instantiate metavariable "), ppname), Pp$ReactTemplate.strbrk("of type ")), pr_lconstr_env(env$15, sigma$10, expected$1)), Pp$ReactTemplate.strbrk(" with abstraction ")), pr_lconstr_env(env$15, sigma$10, abs$1)), Pp$ReactTemplate.strbrk(" of incompatible type ")), pr_lconstr_env(env$15, sigma$10, result$1)), Pp$ReactTemplate.str("."));
    case 11 : 
        var m$3 = err[0];
        var n$3 = err[1];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Too complex unification problem: cannot find a solution for both "), Curry._1(Nameops$ReactTemplate.Name[/* print */7], m$3)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("and ")), Curry._1(Nameops$ReactTemplate.Name[/* print */7], n$3)), Pp$ReactTemplate.str("."));
    case 12 : 
        var env$16 = env$2;
        var sigma$11 = sigma;
        var m$4 = err[0];
        var t = err[1];
        var t$1 = EConstr$ReactTemplate.to_constr(sigma$11, t);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Cannot unambiguously instantiate "), Curry._1(Nameops$ReactTemplate.Name[/* print */7], m$4)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.strbrk(" which would require to abstract twice on ")), pr_lconstr_env(env$16, sigma$11, t$1)), Pp$ReactTemplate.str("."));
    case 13 : 
        var id$1 = err[0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The variable"), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](id$1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("was not found")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("in the current")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("environment")), Pp$ReactTemplate.str("."));
    case 14 : 
        var match$4 = contract2(env$2, sigma, err[0], err[1]);
        var env$17 = match$4[0];
        var sigma$12 = sigma;
        var actual_type = match$4[1];
        var expected_type = match$4[2];
        var match$5 = pr_explicit(env$17, sigma$12, actual_type, expected_type);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Found type"), Pp$ReactTemplate.spc(/* () */0)), match$5[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("where")), Pp$ReactTemplate.spc(/* () */0)), match$5[1]), Pp$ReactTemplate.str(" was expected."));
    case 15 : 
        var env$18 = env$2;
        var sigma$13 = sigma;
        var c$3 = err[0];
        var c$4 = EConstr$ReactTemplate.to_constr(sigma$13, c$3);
        var pr = pr_lconstr_env(env$18, sigma$13, c$4);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The type of this term is a product"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("while it is expected to be")), Constr$ReactTemplate.is_Type(c$4) ? Pp$ReactTemplate.str(" a sort") : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.brk(/* tuple */[
                                  1,
                                  1
                                ]), pr)), Pp$ReactTemplate.str("."));
    case 16 : 
        return explain_type_error(env$2, sigma, err[0]);
    case 17 : 
        var match$6 = err[0];
        var env$19 = env$2;
        var sigma$14 = sigma;
        var nested = match$6[0];
        var param = match$6[1];
        var param$1 = match$6[2];
        var e$2 = match$6[3];
        var match$7 = param$1[0];
        var pos1 = match$7[1];
        var match$8 = param[0];
        var pos2 = match$8[1];
        var cl2 = match$8[0];
        if (nested) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Found nested occurrences of the pattern at positions "), Pp$ReactTemplate.$$int(pos1)), Pp$ReactTemplate.strbrk(" and ")), pr_position(/* tuple */[
                              cl2,
                              pos2
                            ])), Pp$ReactTemplate.str("."));
        } else {
          var ppreason$1;
          if (e$2) {
            var match$9 = e$2[0];
            ppreason$1 = explain_unification_error(env$19, sigma$14, match$9[0], match$9[1], /* Some */[match$9[2]]);
          } else {
            ppreason$1 = Pp$ReactTemplate.mt(/* () */0);
          }
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Found incompatible occurrences of the pattern"), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("Matched term ")), pr_lconstr_env(env$19, sigma$14, EConstr$ReactTemplate.to_constr(sigma$14, param[1]))), Pp$ReactTemplate.strbrk(" at position ")), pr_position(/* tuple */[
                                                  cl2,
                                                  pos2
                                                ])), Pp$ReactTemplate.strbrk(" is not compatible with matched term ")), pr_lconstr_env(env$19, sigma$14, EConstr$ReactTemplate.to_constr(sigma$14, param$1[1]))), Pp$ReactTemplate.strbrk(" at position ")), pr_position(/* tuple */[
                                  match$7[0],
                                  pos1
                                ])), ppreason$1), Pp$ReactTemplate.str("."));
        }
    case 18 : 
        var env$20 = env$2;
        var sigma$15 = sigma;
        var constr = err[0];
        var comp = err[1];
        var match$10 = Evd$ReactTemplate.extract_all_conv_pbs(sigma$15);
        var constraints = match$10[1];
        var undef = Evd$ReactTemplate.undefined_map(sigma$15);
        var is_kept = function (evk, evi) {
          if (comp) {
            if (Typeclasses$ReactTemplate.is_resolvable(evi)) {
              return Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], evk, comp[0]);
            } else {
              return /* false */0;
            }
          } else {
            return Typeclasses$ReactTemplate.is_resolvable(evi);
          }
        };
        var m$5 = Curry._2(Evar$ReactTemplate.$$Map[/* filter */13], is_kept, undef);
        var undef$1 = Curry._1(Evar$ReactTemplate.$$Map[/* is_empty */1], m$5) ? undef : m$5;
        if (constr) {
          var match$11 = constr[0];
          var ev$1 = match$11[0];
          var remaining = Curry._2(Evar$ReactTemplate.$$Map[/* remove */5], ev$1, undef$1);
          var cstr = Curry._1(Evar$ReactTemplate.$$Map[/* is_empty */1], remaining) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("With the following constraints:"), Pp$ReactTemplate.fnl(/* () */0)), pr_constraints(/* false */0, env$20, sigma$15, remaining, constraints));
          var info = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], ev$1, undef$1);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(explain_typeclass_resolution(env$20, sigma$15, info, match$11[1]), Pp$ReactTemplate.fnl(/* () */0)), cstr);
        } else {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unable to satisfy the following constraints:"), Pp$ReactTemplate.fnl(/* () */0)), pr_constraints(/* true */1, env$20, sigma$15, undef$1, constraints));
        }
    
  }
}

function explain_not_match_error(param) {
  var exit = 0;
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return Pp$ReactTemplate.strbrk("a definition is expected");
      case 1 : 
          return Pp$ReactTemplate.strbrk("a module is expected");
      case 2 : 
          return Pp$ReactTemplate.strbrk("a module type is expected");
      case 3 : 
          return Pp$ReactTemplate.str("the body of definitions differs");
      case 4 : 
          return Pp$ReactTemplate.str("constructor names differ");
      case 5 : 
          return Pp$ReactTemplate.str("inductive types names differ");
      case 6 : 
          return Pp$ReactTemplate.str("Aliases to inductive types do not match");
      case 7 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("a definition whose type is constrained can only be subtype "), Pp$ReactTemplate.strbrk("of a definition whose type is itself constrained"));
      case 8 : 
          return Pp$ReactTemplate.str("polymorphic universe instances do not match");
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Pp$ReactTemplate.strbrk("an inductive definition is expected");
      case 1 : 
      case 2 : 
          exit = 1;
          break;
      case 3 : 
          var env = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("expected type"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.quote(Printer$ReactTemplate.safe_pr_lconstr_env(env, Evd$ReactTemplate.empty, param[2]))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("but found type")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.quote(Printer$ReactTemplate.safe_pr_lconstr_env(env, Evd$ReactTemplate.empty, param[1])));
      case 4 : 
          var b = param[0];
          var status = function (b) {
            if (b) {
              return Pp$ReactTemplate.str("cumulative");
            } else {
              return Pp$ReactTemplate.str("non-cumulative");
            }
          };
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("a "), status(b)), Pp$ReactTemplate.str(" declaration was expected, but a ")), status(1 - b)), Pp$ReactTemplate.str(" declaration was found"));
      case 5 : 
          var b$1 = param[0];
          var status$1 = function (b) {
            if (b) {
              return Pp$ReactTemplate.str("polymorphic");
            } else {
              return Pp$ReactTemplate.str("monomorphic");
            }
          };
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("a "), status$1(b$1)), Pp$ReactTemplate.str(" declaration was expected, but a ")), status$1(1 - b$1)), Pp$ReactTemplate.str(" declaration was found"));
      case 6 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("type is expected to be "), Pp$ReactTemplate.str(param[0] ? "coinductive" : "inductive"));
      case 7 : 
          return Pp$ReactTemplate.str("number of inductive types differs");
      case 8 : 
          return Pp$ReactTemplate.str("inductive type has not the right number of parameters");
      case 9 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("type is expected "), Pp$ReactTemplate.str(param[0] ? "" : "not ")), Pp$ReactTemplate.str("to be a record"));
      case 10 : 
          var nal = param[0];
          return Pp$ReactTemplate.$plus$plus(Curry._1(Util$ReactTemplate.List[/* length */0], nal) >= 2 ? Pp$ReactTemplate.str("expected projection names are ") : Pp$ReactTemplate.str("expected projection name is "), Pp$ReactTemplate.pr_enum((function (param) {
                            if (param) {
                              return Names$ReactTemplate.Id[/* print */8](param[0]);
                            } else {
                              return Pp$ReactTemplate.str("_");
                            }
                          }), nal));
      case 11 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("the universe constraints are inconsistent: "), Univ$ReactTemplate.explain_universe_inconsistency(Universes$ReactTemplate.pr_with_global_universes, param[0]));
      case 12 : 
          var env$1 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("conversion of polymorphic values generates additional constraints: "), Pp$ReactTemplate.quote(Printer$ReactTemplate.safe_pr_lconstr_env(env$1, Evd$ReactTemplate.empty, param[1]))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("compared to ")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.quote(Printer$ReactTemplate.safe_pr_lconstr_env(env$1, Evd$ReactTemplate.empty, param[2])));
      case 13 : 
          var cst = param[0];
          var cst$1 = Univ$ReactTemplate.AUContext[/* instantiate */6](Univ$ReactTemplate.AUContext[/* instance */3](cst), cst);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" the expected (polymorphic) constraints do not imply "), Pp$ReactTemplate.quote(Univ$ReactTemplate.pr_constraints(Termops$ReactTemplate.pr_evd_level(Evd$ReactTemplate.empty))(cst$1)));
      
    }
  }
  if (exit === 1) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("types given to "), Names$ReactTemplate.Id[/* print */8](param[0])), Pp$ReactTemplate.str(" differ"));
  }
  
}

function explain_module_error(param) {
  if (typeof param === "number") {
    if (param) {
      return Pp$ReactTemplate.str("Illegal use of a functor.");
    } else {
      return Pp$ReactTemplate.str("Application of a non-functor.");
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var l = param[0];
          var why = param[2];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Signature components for label "), Names$ReactTemplate.Label[/* print */7](l)), Pp$ReactTemplate.str(" do not match:")), Pp$ReactTemplate.spc(/* () */0)), explain_not_match_error(why)), Pp$ReactTemplate.str("."));
      case 1 : 
          var l$1 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The label "), Names$ReactTemplate.Label[/* print */7](l$1)), Pp$ReactTemplate.str(" is already declared."));
      case 2 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("A module cannot be applied to another module application or "), Pp$ReactTemplate.strbrk("with-expression; you must give a name to the intermediate result ")), Pp$ReactTemplate.strbrk("module first."));
      case 3 : 
          var mexpr1 = param[0];
          var mexpr2 = param[1];
          var get_arg = function (param) {
            if (param.tag) {
              return get_arg(param[2]) + 1 | 0;
            } else {
              return 0;
            }
          };
          var len1 = get_arg(mexpr1[/* mod_type */2]);
          var len2 = get_arg(mexpr2[/* mod_type */2]);
          if (len1 !== len2) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incompatible module types: module expects "), Pp$ReactTemplate.$$int(len2)), Pp$ReactTemplate.str(" arguments, found ")), Pp$ReactTemplate.$$int(len1)), Pp$ReactTemplate.str("."));
          } else {
            return Pp$ReactTemplate.str("Incompatible module types.");
          }
      case 4 : 
          return Pp$ReactTemplate.str("Non equal modules.");
      case 5 : 
          var l$2 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such label "), Names$ReactTemplate.Label[/* print */7](l$2)), Pp$ReactTemplate.str("."));
      case 6 : 
          var l$3 = param[0];
          var l$prime = param[1];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Opening and closing labels are not the same: "), Names$ReactTemplate.Label[/* print */7](l$3)), Pp$ReactTemplate.str(" <> ")), Names$ReactTemplate.Label[/* print */7](l$prime)), Pp$ReactTemplate.str("!"));
      case 7 : 
          var s = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.quote(Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str(" is not a module."));
      case 8 : 
          var s$1 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.quote(Pp$ReactTemplate.str(s$1)), Pp$ReactTemplate.str(" is not a module type."));
      case 9 : 
          var l$4 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.quote(Names$ReactTemplate.Label[/* print */7](l$4)), Pp$ReactTemplate.str(" is not a constant."));
      case 10 : 
          var l$5 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incorrect constraint for label "), Pp$ReactTemplate.quote(Names$ReactTemplate.Label[/* print */7](l$5))), Pp$ReactTemplate.str("."));
      case 11 : 
          var l$6 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The module "), Names$ReactTemplate.Label[/* print */7](l$6)), Pp$ReactTemplate.str(" is not generative.")), Pp$ReactTemplate.strbrk(" Only components of generative modules can be changed")), Pp$ReactTemplate.strbrk(" using the \"with\" construct."));
      case 12 : 
          var l$7 = param[0];
          var s$2 = param[1];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The field "), Names$ReactTemplate.Label[/* print */7](l$7)), Pp$ReactTemplate.str(" is missing in ")), Pp$ReactTemplate.str(s$2)), Pp$ReactTemplate.str("."));
      case 13 : 
          var mp = param[0];
          var q = Nametab$ReactTemplate.shortest_qualid_of_module(mp);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot include the functor "), Libnames$ReactTemplate.pr_qualid(q)), Pp$ReactTemplate.strbrk(" since it has a restricted signature. ")), Pp$ReactTemplate.strbrk("You may name first an instance of this functor, and include it."));
      
    }
  }
}

function explain_module_internalization_error(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return Pp$ReactTemplate.str("Illegal application to a module type.");
    } else {
      return Pp$ReactTemplate.str("The syntax \"with\" is not allowed for modules.");
    }
  } else {
    var s = param[0];
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.quote(Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str(" is not a module or module type."));
  }
}

function pr_constr_exprs(exprs) {
  return Pp$ReactTemplate.hv(0, Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (d, pps) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.ws(2), Ppconstr$ReactTemplate.pr_constr_expr(d)), pps);
                  }), exprs, Pp$ReactTemplate.mt(/* () */0)));
}

function explain_typeclass_error(env, param) {
  switch (param.tag | 0) {
    case 0 : 
        var env$1 = env;
        var c = param[0];
        var c$1 = EConstr$ReactTemplate.to_constr(Evd$ReactTemplate.empty, c);
        return Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_constr_env(env$1, Evd$ReactTemplate.empty, c$1), Pp$ReactTemplate.str(" is not a declared type class."));
    case 1 : 
        var cid = param[0];
        var param$1 = param[1];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unbound method name "), Names$ReactTemplate.Id[/* print */8](param$1[/* v */0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of class")), Pp$ReactTemplate.spc(/* () */0)), Printer$ReactTemplate.pr_global(cid)), Pp$ReactTemplate.str("."));
    case 2 : 
        var env$2 = env;
        var i = param[1];
        var j = param[2];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Mismatched contexts while declaring instance: "), Pp$ReactTemplate.brk(/* tuple */[
                                        1,
                                        1
                                      ])), Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Expected:"), Pp$ReactTemplate.brk(/* tuple */[
                                                1,
                                                1
                                              ])), Printer$ReactTemplate.pr_rel_context(env$2, Evd$ReactTemplate.empty, j)))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.brk(/* tuple */[
                            1,
                            1
                          ])), Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Found:"), Pp$ReactTemplate.brk(/* tuple */[
                                    1,
                                    1
                                  ])), pr_constr_exprs(i))));
    
  }
}

function explain_refiner_error(env, sigma, param) {
  if (typeof param === "number") {
    return Pp$ReactTemplate.str("Introduction tactics needs products.");
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var env$1 = env;
          var sigma$1 = sigma;
          var arg = param[0];
          var ty = param[1];
          var conclty = param[2];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Refiner was given an argument"), Pp$ReactTemplate.brk(/* tuple */[
                                                                  1,
                                                                  1
                                                                ])), pr_lconstr_env(env$1, sigma$1, arg)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of type")), Pp$ReactTemplate.brk(/* tuple */[
                                                  1,
                                                  1
                                                ])), pr_lconstr_env(env$1, sigma$1, ty)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("instead of")), Pp$ReactTemplate.brk(/* tuple */[
                                  1,
                                  1
                                ])), pr_lconstr_env(env$1, sigma$1, conclty)), Pp$ReactTemplate.str("."));
      case 1 : 
          var l = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unable to find an instance for the "), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], Curry._1(Util$ReactTemplate.List[/* length */0], l), "variable"))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Nameops$ReactTemplate.Name[/* print */7], l)), Pp$ReactTemplate.str("."));
      case 2 : 
          var env$2 = env;
          var sigma$2 = sigma;
          var t = param[0];
          var harg = param[1];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("In refiner, a term of type"), Pp$ReactTemplate.brk(/* tuple */[
                                                  1,
                                                  1
                                                ])), pr_lconstr_env(env$2, sigma$2, t)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("could not be applied to")), Pp$ReactTemplate.brk(/* tuple */[
                                  1,
                                  1
                                ])), pr_lconstr_env(env$2, sigma$2, harg)), Pp$ReactTemplate.str("."));
      case 3 : 
          var env$3 = env;
          var sigma$3 = sigma;
          var c = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The term "), pr_lconstr_env(env$3, sigma$3, c)), Pp$ReactTemplate.str(" is not well-typed."));
      case 4 : 
          var env$4 = env;
          var sigma$4 = sigma;
          var c$1 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot refine with term"), Pp$ReactTemplate.brk(/* tuple */[
                                      1,
                                      1
                                    ])), pr_lconstr_env(env$4, sigma$4, c$1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("because a metavariable has several occurrences."));
      case 5 : 
          var env$5 = env;
          var sigma$5 = sigma;
          var c$2 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("In refiner, a meta appears in the type "), Pp$ReactTemplate.brk(/* tuple */[
                                  1,
                                  1
                                ])), pr_leconstr_env(env$5, sigma$5, c$2)), Pp$ReactTemplate.str(" of another meta"));
      case 6 : 
          var env$6 = env;
          var sigma$6 = sigma;
          var c$3 = param[0];
          var hyp = param[1];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The term"), Pp$ReactTemplate.spc(/* () */0)), pr_lconstr_env(env$6, sigma$6, c$3)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("does not occur in")), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](hyp)), Pp$ReactTemplate.str("."));
      case 7 : 
          var id = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such hypothesis: "), Names$ReactTemplate.Id[/* print */8](id));
      
    }
  }
}

function pr_ltype_using_barendregt_convention_env(env, c) {
  return Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_goal_concl_style_env(env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(c)));
}

function explain_inductive_error(param) {
  if (typeof param === "number") {
    if (param) {
      return Pp$ReactTemplate.str("Large non-propositional inductive types must be in Type.");
    } else {
      return Pp$ReactTemplate.str("Bad inductive definition.");
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var env = param[0];
          var c = param[1];
          var v = param[2];
          var pc = pr_lconstr_env(env, Evd$ReactTemplate.empty, c);
          var pv = pr_lconstr_env(env, Evd$ReactTemplate.empty, v);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Non strictly positive occurrence of "), pv), Pp$ReactTemplate.str(" in")), Pp$ReactTemplate.brk(/* tuple */[
                                  1,
                                  1
                                ])), pc), Pp$ReactTemplate.str("."));
      case 1 : 
          var env$1 = param[0];
          var c$1 = param[1];
          var v$1 = param[2];
          var pc$1 = pr_lconstr_env(env$1, Evd$ReactTemplate.empty, c$1);
          var pv$1 = pr_lconstr_env(env$1, Evd$ReactTemplate.empty, v$1);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Not enough arguments applied to the "), pv$1), Pp$ReactTemplate.str(" in")), Pp$ReactTemplate.brk(/* tuple */[
                                  1,
                                  1
                                ])), pc$1), Pp$ReactTemplate.str("."));
      case 2 : 
          var env$2 = param[0];
          var id = param[1];
          var c$2 = param[2];
          var v$2 = param[3];
          var nparams = param[4];
          var nargs = param[5];
          var pv$2 = pr_lconstr_env(env$2, Evd$ReactTemplate.empty, v$2);
          var atomic = +(Termops$ReactTemplate.nb_prod(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(c$2)) === 0);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The type of constructor"), Pp$ReactTemplate.brk(/* tuple */[
                                                              1,
                                                              1
                                                            ])), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.brk(/* tuple */[
                                                      1,
                                                      1
                                                    ])), Pp$ReactTemplate.str("is not valid;")), Pp$ReactTemplate.brk(/* tuple */[
                                              1,
                                              1
                                            ])), Pp$ReactTemplate.strbrk(atomic ? "it must be " : "its conclusion must be ")), pv$2), nparams !== 0 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk(" applied to its "), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], nparams, "parameter"))) : Pp$ReactTemplate.mt(/* () */0)), nargs !== 0 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(nparams !== 0 ? " and" : " applied"), Pp$ReactTemplate.strbrk(" to some ")), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], nargs, "argument"))) : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.str("."));
      case 3 : 
          var env$3 = param[0];
          var c$3 = param[1];
          var n = param[2];
          var v1 = param[3];
          var v2 = param[4];
          var pc$2 = pr_ltype_using_barendregt_convention_env(env$3, c$3);
          var pv1 = pr_lconstr_env(env$3, Evd$ReactTemplate.empty, v1);
          var pv2 = pr_lconstr_env(env$3, Evd$ReactTemplate.empty, v2);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Last occurrence of "), pv2), Pp$ReactTemplate.str(" must have ")), pv1), Pp$ReactTemplate.str(" as ")), Pp$ReactTemplate.pr_nth(n)), Pp$ReactTemplate.str(" argument in")), Pp$ReactTemplate.brk(/* tuple */[
                                  1,
                                  1
                                ])), pc$2), Pp$ReactTemplate.str("."));
      case 4 : 
          var id$1 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The name"), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](id$1)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is used more than once."));
      case 5 : 
          var id$2 = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The constructor name"), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](id$2)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is used more than once."));
      case 6 : 
          var idl = param[0];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("The following names are used both as type names and constructor "), Pp$ReactTemplate.str("names:")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Names$ReactTemplate.Id[/* print */8], idl)), Pp$ReactTemplate.str("."));
      case 7 : 
          var env$4 = param[0];
          var c$4 = param[1];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The type"), Pp$ReactTemplate.spc(/* () */0)), pr_lconstr_env(env$4, Evd$ReactTemplate.empty, c$4)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is not an arity."));
      
    }
  }
}

function explain_recursion_scheme_error(param) {
  switch (param.tag | 0) {
    case 0 : 
        var isrec = param[0];
        var kind = param[1];
        var i = param[2];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(isrec ? "Induction" : "Case analysis"), Pp$ReactTemplate.strbrk(" on sort ")), Printer$ReactTemplate.pr_sort(Evd$ReactTemplate.empty, kind)), Pp$ReactTemplate.strbrk(" is not allowed for inductive definition ")), Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), i[0])), Pp$ReactTemplate.str("."));
    case 1 : 
        var ind = param[0];
        var ind$prime = param[1];
        if (Names$ReactTemplate.eq_ind(ind, ind$prime)) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The inductive type "), Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), ind)), Pp$ReactTemplate.str(" occurs twice."));
        } else {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The inductive types "), Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), ind)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("and")), Pp$ReactTemplate.spc(/* () */0)), Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), ind$prime)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("are not mutually defined."));
        }
    case 2 : 
        var isrec$1 = param[0];
        var i$1 = param[1];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Dependent "), Pp$ReactTemplate.str(isrec$1 ? "induction" : "case analysis")), Pp$ReactTemplate.strbrk(" is not allowed for inductive definition ")), Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), i$1)), Pp$ReactTemplate.str("."));
    
  }
}

function decline_string(n, s) {
  if (n) {
    if (n === 1) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("1 "), Pp$ReactTemplate.str(s));
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(n), Pp$ReactTemplate.str(" ")), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str("s"));
    }
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("no "), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str("s"));
  }
}

function explain_pattern_matching_error(env, sigma, param) {
  switch (param.tag | 0) {
    case 0 : 
        var env$1 = env;
        var sigma$1 = sigma;
        var cstr = param[0];
        var ty = param[1];
        var ty$1 = EConstr$ReactTemplate.to_constr(sigma$1, ty);
        var env$2 = Namegen$ReactTemplate.make_all_name_different(env$1, sigma$1);
        var pt = pr_lconstr_env(env$2, sigma$1, ty$1);
        var pc = Printer$ReactTemplate.pr_constructor(env$2, cstr);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Found the constructor "), pc), Pp$ReactTemplate.brk(/* tuple */[
                                        1,
                                        1
                                      ])), Pp$ReactTemplate.str("while matching a term of type ")), pt), Pp$ReactTemplate.brk(/* tuple */[
                            1,
                            1
                          ])), Pp$ReactTemplate.str("which is not an inductive type."));
    case 1 : 
        var env$3 = env;
        var cstr$1 = param[0];
        var ind = param[1];
        var pi = Printer$ReactTemplate.pr_inductive(env$3, ind);
        var pt$1 = Printer$ReactTemplate.pr_inductive(env$3, Names$ReactTemplate.inductive_of_constructor(cstr$1));
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Found a constructor of inductive type "), pt$1), Pp$ReactTemplate.brk(/* tuple */[
                                        1,
                                        1
                                      ])), Pp$ReactTemplate.str("while a constructor of ")), pi), Pp$ReactTemplate.brk(/* tuple */[
                            1,
                            1
                          ])), Pp$ReactTemplate.str("is expected."));
    case 2 : 
        var env$4 = env;
        var cstr$2 = param[0];
        var n = param[1];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The constructor "), Printer$ReactTemplate.pr_constructor(env$4, cstr$2)), Pp$ReactTemplate.str(" (in type ")), Printer$ReactTemplate.pr_inductive(env$4, Names$ReactTemplate.inductive_of_constructor(cstr$2))), Pp$ReactTemplate.str(") expects ")), decline_string(n, "argument")), Pp$ReactTemplate.str("."));
    case 3 : 
        var env$5 = env;
        var ind$1 = param[0];
        var n$1 = param[1];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The inductive type "), Printer$ReactTemplate.pr_inductive(env$5, ind$1)), Pp$ReactTemplate.str(" expects ")), decline_string(n$1, "argument")), Pp$ReactTemplate.str("."));
    case 4 : 
        return Pp$ReactTemplate.str("This clause is redundant.");
    case 5 : 
        var pats = param[0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Non exhaustive pattern-matching: no clause found for "), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], Curry._1(Util$ReactTemplate.List[/* length */0], pats), "pattern"))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Printer$ReactTemplate.pr_cases_pattern, pats)));
    case 6 : 
        var env$6 = env;
        var sigma$2 = sigma;
        var typs = param[0];
        var typs$1 = Util$ReactTemplate.$$Array[/* map_to_list */44]((function (param) {
                return /* tuple */[
                        EConstr$ReactTemplate.to_constr(sigma$2, param[0]),
                        EConstr$ReactTemplate.to_constr(sigma$2, param[1])
                      ];
              }), typs);
        var env$7 = Namegen$ReactTemplate.make_all_name_different(env$6, sigma$2);
        var pr_branch = function (param) {
          var match = Constr$ReactTemplate.decompose_app(param[0]);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("For "), pr_lconstr_env(env$7, sigma$2, match[0])), Pp$ReactTemplate.str(": ")), pr_lconstr_env(env$7, sigma$2, param[1]));
        };
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unable to unify the types found in the branches:"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, pr_branch, typs$1)));
    
  }
}

function map_pguard_error(f, param) {
  if (typeof param === "number") {
    if (param) {
      return /* NestedRecursiveOccurrences */1;
    } else {
      return /* NotEnoughAbstractionInFixBody */0;
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return /* RecursionNotOnInductiveType */Block.__(0, [Curry._1(f, param[0])]);
      case 1 : 
          var match = param[1];
          return /* RecursionOnIllegalTerm */Block.__(1, [
                    param[0],
                    /* tuple */[
                      match[0],
                      Curry._1(f, match[1])
                    ],
                    param[2],
                    param[3]
                  ]);
      case 2 : 
          return /* NotEnoughArgumentsForFixCall */Block.__(2, [param[0]]);
      case 3 : 
          return /* CodomainNotInductiveType */Block.__(3, [Curry._1(f, param[0])]);
      case 4 : 
          return /* UnguardedRecursiveCall */Block.__(4, [Curry._1(f, param[0])]);
      case 5 : 
          return /* RecCallInTypeOfAbstraction */Block.__(5, [Curry._1(f, param[0])]);
      case 6 : 
          return /* RecCallInNonRecArgOfConstructor */Block.__(6, [Curry._1(f, param[0])]);
      case 7 : 
          return /* RecCallInTypeOfDef */Block.__(7, [Curry._1(f, param[0])]);
      case 8 : 
          return /* RecCallInCaseFun */Block.__(8, [Curry._1(f, param[0])]);
      case 9 : 
          return /* RecCallInCaseArg */Block.__(9, [Curry._1(f, param[0])]);
      case 10 : 
          return /* RecCallInCasePred */Block.__(10, [Curry._1(f, param[0])]);
      case 11 : 
          return /* NotGuardedForm */Block.__(11, [Curry._1(f, param[0])]);
      case 12 : 
          return /* ReturnPredicateNotCoInductive */Block.__(12, [Curry._1(f, param[0])]);
      
    }
  }
}

function map_ptype_error(f, param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* UnboundRel */Block.__(0, [param[0]]);
    case 1 : 
        return /* UnboundVar */Block.__(1, [param[0]]);
    case 2 : 
        return /* NotAType */Block.__(2, [Termops$ReactTemplate.on_judgment(f, param[0])]);
    case 3 : 
        return /* BadAssumption */Block.__(3, [Termops$ReactTemplate.on_judgment(f, param[0])]);
    case 4 : 
        return /* ReferenceVariables */Block.__(4, [
                  param[0],
                  Curry._1(f, param[1])
                ]);
    case 5 : 
        return /* ElimArity */Block.__(5, [
                  param[0],
                  param[1],
                  Curry._1(f, param[2]),
                  Termops$ReactTemplate.on_judgment(f, param[3]),
                  param[4]
                ]);
    case 6 : 
        return /* CaseNotInductive */Block.__(6, [Termops$ReactTemplate.on_judgment(f, param[0])]);
    case 7 : 
        return /* WrongCaseInfo */Block.__(7, [
                  param[0],
                  param[1]
                ]);
    case 8 : 
        return /* NumberBranches */Block.__(8, [
                  Termops$ReactTemplate.on_judgment(f, param[0]),
                  param[1]
                ]);
    case 9 : 
        return /* IllFormedBranch */Block.__(9, [
                  Curry._1(f, param[0]),
                  param[1],
                  Curry._1(f, param[2]),
                  Curry._1(f, param[3])
                ]);
    case 10 : 
        var match = param[0];
        return /* Generalization */Block.__(10, [
                  /* tuple */[
                    match[0],
                    Curry._1(f, match[1])
                  ],
                  Termops$ReactTemplate.on_judgment(f, param[1])
                ]);
    case 11 : 
        return /* ActualType */Block.__(11, [
                  Termops$ReactTemplate.on_judgment(f, param[0]),
                  Curry._1(f, param[1])
                ]);
    case 12 : 
        var match$1 = param[0];
        return /* CantApplyBadType */Block.__(12, [
                  /* tuple */[
                    match$1[0],
                    Curry._1(f, match$1[1]),
                    Curry._1(f, match$1[2])
                  ],
                  Termops$ReactTemplate.on_judgment(f, param[1]),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return Termops$ReactTemplate.on_judgment(f, param);
                        }), param[2])
                ]);
    case 13 : 
        return /* CantApplyNonFunctional */Block.__(13, [
                  Termops$ReactTemplate.on_judgment(f, param[0]),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return Termops$ReactTemplate.on_judgment(f, param);
                        }), param[1])
                ]);
    case 14 : 
        return /* IllFormedRecBody */Block.__(14, [
                  map_pguard_error(f, param[0]),
                  param[1],
                  param[2],
                  param[3],
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return Termops$ReactTemplate.on_judgment(f, param);
                        }), param[4])
                ]);
    case 15 : 
        return /* IllTypedRecBody */Block.__(15, [
                  param[0],
                  param[1],
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return Termops$ReactTemplate.on_judgment(f, param);
                        }), param[2]),
                  Util$ReactTemplate.$$Array[/* map */12](f, param[3])
                ]);
    case 16 : 
        return /* UnsatisfiedConstraints */Block.__(16, [param[0]]);
    
  }
}

function explain_reduction_tactic_error(param) {
  var match = param[3];
  var e = map_ptype_error(EConstr$ReactTemplate.of_constr, match[1]);
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The abstracted term"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_goal_concl_style_env(param[0], param[1], param[2]))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is not well typed.")), Pp$ReactTemplate.fnl(/* () */0)), explain_type_error(match[0], Evd$ReactTemplate.empty, e));
}

exports.explain_type_error = explain_type_error;
exports.explain_pretype_error = explain_pretype_error;
exports.explain_inductive_error = explain_inductive_error;
exports.explain_typeclass_error = explain_typeclass_error;
exports.explain_recursion_scheme_error = explain_recursion_scheme_error;
exports.explain_refiner_error = explain_refiner_error;
exports.explain_pattern_matching_error = explain_pattern_matching_error;
exports.explain_reduction_tactic_error = explain_reduction_tactic_error;
exports.explain_module_error = explain_module_error;
exports.explain_module_internalization_error = explain_module_internalization_error;
exports.map_pguard_error = map_pguard_error;
exports.map_ptype_error = map_ptype_error;
/* Pp-ReactTemplate Not a pure module */
