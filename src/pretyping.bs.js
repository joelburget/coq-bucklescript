// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Cases$ReactTemplate = require("./cases.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Genarg$ReactTemplate = require("./genarg.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Typing$ReactTemplate = require("./typing.bs.js");
var UGraph$ReactTemplate = require("./uGraph.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Coercion$ReactTemplate = require("./coercion.bs.js");
var Evarconv$ReactTemplate = require("./evarconv.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Evarsolve$ReactTemplate = require("./evarsolve.bs.js");
var Geninterp$ReactTemplate = require("./geninterp.bs.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var Evardefine$ReactTemplate = require("./evardefine.bs.js");
var Type_errors$ReactTemplate = require("./type_errors.bs.js");
var Typeclasses$ReactTemplate = require("./typeclasses.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("./pretype_errors.bs.js");

function make_env(env, sigma) {
  return /* record */[
          /* env */env,
          /* extra */Block.__(246, [(function () {
                  var env$1 = env;
                  var sigma$1 = sigma;
                  var ids = Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], EConstr$ReactTemplate.named_context(env$1));
                  var avoid = Curry._3(Util$ReactTemplate.List[/* fold_right */14], Names$ReactTemplate.Id[/* Set */9][/* add */3], ids, Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
                  return Context$ReactTemplate.Rel[/* fold_outside */10]((function (d, acc) {
                                return Evarutil$ReactTemplate.push_rel_decl_to_named_context(sigma$1, d, acc);
                              }), EConstr$ReactTemplate.rel_context(env$1), /* tuple */[
                              Evarutil$ReactTemplate.empty_csubst,
                              avoid,
                              EConstr$ReactTemplate.named_context(env$1)
                            ]);
                })])
        ];
}

function push_rel(sigma, d, env) {
  return /* record */[
          /* env */EConstr$ReactTemplate.push_rel(d, env[/* env */0]),
          /* extra */Block.__(246, [(function () {
                  var lzarg = env[/* extra */1];
                  var tag = lzarg.tag | 0;
                  return Evarutil$ReactTemplate.push_rel_decl_to_named_context(sigma, d, tag === 250 ? lzarg[0] : (
                                tag === 246 ? CamlinternalLazy.force_lazy_block(lzarg) : lzarg
                              ));
                })])
        ];
}

function pop_rel_context(n, env, sigma) {
  return make_env(Environ$ReactTemplate.pop_rel_context(n, env[/* env */0]), sigma);
}

function push_rel_context(sigma, ctx, env) {
  return /* record */[
          /* env */EConstr$ReactTemplate.push_rel_context(ctx, env[/* env */0]),
          /* extra */Block.__(246, [(function () {
                  var lzarg = env[/* extra */1];
                  var tag = lzarg.tag | 0;
                  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (d, acc) {
                                return Evarutil$ReactTemplate.push_rel_decl_to_named_context(sigma, d, acc);
                              }), ctx, tag === 250 ? lzarg[0] : (
                                tag === 246 ? CamlinternalLazy.force_lazy_block(lzarg) : lzarg
                              ));
                })])
        ];
}

function e_new_evar(env, evdref, src, naming, typ) {
  var partial_arg = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
  var inst_vars = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return Util$ReactTemplate.$percent$great(partial_arg, EConstr$ReactTemplate.mkVar, param);
        }), EConstr$ReactTemplate.named_context(env[/* env */0]));
  var inst_rels = Curry._1(Util$ReactTemplate.List[/* rev */4], Termops$ReactTemplate.rel_list(0, Environ$ReactTemplate.nb_rel(env[/* env */0])));
  var lzarg = env[/* extra */1];
  var tag = lzarg.tag | 0;
  var match = tag === 250 ? lzarg[0] : (
      tag === 246 ? CamlinternalLazy.force_lazy_block(lzarg) : lzarg
    );
  var typ$prime = Evarutil$ReactTemplate.csubst_subst(match[0], typ);
  var instance = Util$ReactTemplate.$at(inst_rels, inst_vars);
  var sign = EConstr$ReactTemplate.val_of_named_context(match[2]);
  var sigma = evdref[0];
  var match$1 = Evarutil$ReactTemplate.new_evar_instance(sign, sigma, typ$prime, src, /* None */0, /* None */0, /* None */0, naming, /* None */0, instance);
  evdref[0] = match$1[0];
  return match$1[1];
}

function push_rec_types(sigma, param, env) {
  var ctxt = Util$ReactTemplate.$$Array[/* map2_i */50]((function (i, na, t) {
          return /* LocalAssum */Block.__(0, [
                    na,
                    EConstr$ReactTemplate.Vars[/* lift */0](i, t)
                  ]);
        }), param[0], param[1]);
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (e, assum) {
                return push_rel(sigma, assum, e);
              }), env, ctxt);
}

var Found = Caml_exceptions.create("Pretyping-ReactTemplate.Found");

function nf_fix(sigma, param) {
  var inj = function (c) {
    return EConstr$ReactTemplate.to_constr(sigma, c);
  };
  return /* tuple */[
          param[0],
          Util$ReactTemplate.$$Array[/* map */12](inj, param[1]),
          Util$ReactTemplate.$$Array[/* map */12](inj, param[2])
        ];
}

function search_guard(loc, env, possible_indexes, fixdefs) {
  var is_singleton = function (param) {
    if (param && !param[1]) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  };
  if (Curry._2(Util$ReactTemplate.List[/* for_all */20], is_singleton, possible_indexes)) {
    var indexes = Util$ReactTemplate.$$Array[/* of_list */10](Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.List[/* hd */1], possible_indexes));
    var fix_000 = /* tuple */[
      indexes,
      0
    ];
    var fix = /* tuple */[
      fix_000,
      fixdefs
    ];
    try {
      Inductive$ReactTemplate.check_fix(env, fix);
    }
    catch (raw_reraise){
      var reraise = Js_exn.internalToOCamlException(raw_reraise);
      var match = CErrors$ReactTemplate.push(reraise);
      var info = match[1];
      var info$1 = Option$ReactTemplate.cata((function (loc) {
              return Loc$ReactTemplate.add_loc(info, loc);
            }), info, loc);
      Util$ReactTemplate.iraise(/* tuple */[
            match[0],
            info$1
          ]);
    }
    return indexes;
  } else {
    try {
      Curry._2(Util$ReactTemplate.List[/* iter */9], (function (l) {
              var indexes = Util$ReactTemplate.$$Array[/* of_list */10](l);
              var fix_000 = /* tuple */[
                indexes,
                0
              ];
              var fix = /* tuple */[
                fix_000,
                fixdefs
              ];
              try {
                var init = Environ$ReactTemplate.typing_flags(env);
                var flags_001 = /* check_universes */init[/* check_universes */1];
                var flags_002 = /* conv_oracle */init[/* conv_oracle */2];
                var flags = /* record */[
                  /* check_guarded : true */1,
                  flags_001,
                  flags_002
                ];
                var env$1 = Environ$ReactTemplate.set_typing_flags(flags, env);
                Inductive$ReactTemplate.check_fix(env$1, fix);
                throw [
                      Found,
                      indexes
                    ];
              }
              catch (raw_exn){
                var exn = Js_exn.internalToOCamlException(raw_exn);
                if (exn[0] === Type_errors$ReactTemplate.TypeError) {
                  return /* () */0;
                } else {
                  throw exn;
                }
              }
            }), Curry._1(Util$ReactTemplate.List[/* combinations */130], possible_indexes));
      return CErrors$ReactTemplate.user_err(loc, /* Some */["search_guard"], Pp$ReactTemplate.str("Cannot guess decreasing argument of fix."));
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Found) {
        return exn[1];
      } else {
        throw exn;
      }
    }
  }
}

var strict_universe_declarations = [/* true */1];

function is_strict_universe_declarations() {
  return strict_universe_declarations[0];
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"strict universe declaration",
      /* optkey : :: */[
        "Strict",
        /* :: */[
          "Universe",
          /* :: */[
            "Declaration",
            /* [] */0
          ]
        ]
      ],
      /* optread */is_strict_universe_declarations,
      /* optwrite */(function (param) {
          strict_universe_declarations[0] = param;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"minimization to Set",
      /* optkey : :: */[
        "Universe",
        /* :: */[
          "Minimization",
          /* :: */[
            "ToSet",
            /* [] */0
          ]
        ]
      ],
      /* optread */Universes$ReactTemplate.is_set_minimization,
      /* optwrite */(function (param) {
          Universes$ReactTemplate.set_minimization[0] = param;
          return /* () */0;
        })
    ]);

function interp_known_universe_level(evd, r) {
  var qid = Libnames$ReactTemplate.qualid_of_reference(r);
  try {
    var match = r[/* v */0];
    if (match.tag) {
      return Evd$ReactTemplate.universe_of_name(evd, match[0]);
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var match$1 = Nametab$ReactTemplate.locate_universe(qid[/* v */0]);
      return Univ$ReactTemplate.Level[/* make */8](match$1[0], match$1[1]);
    } else {
      throw exn;
    }
  }
}

function interp_universe_level_name(_, evd, r) {
  try {
    return /* tuple */[
            evd,
            interp_known_universe_level(evd, r)
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var match = r[/* v */0];
      if (match.tag) {
        var loc = r[/* loc */1];
        var id = match[0];
        if (strict_universe_declarations[0]) {
          return CErrors$ReactTemplate.user_err(loc, /* Some */["interp_universe_level_name"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Undeclared universe: "), Names$ReactTemplate.Id[/* print */8](id)));
        } else {
          return Evd$ReactTemplate.new_univ_level_variable(loc, /* Some */[id], Evd$ReactTemplate.univ_rigid, evd);
        }
      } else {
        var match$1 = Libnames$ReactTemplate.repr_qualid(match[0]);
        var num;
        try {
          num = Caml_format.caml_int_of_string(Names$ReactTemplate.Id[/* to_string */7](match$1[1]));
        }
        catch (raw_exn){
          var exn$1 = Js_exn.internalToOCamlException(raw_exn);
          if (exn$1[0] === Caml_builtin_exceptions.failure) {
            num = CErrors$ReactTemplate.user_err(r[/* loc */1], /* Some */["interp_universe_level_name"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Undeclared global universe: "), Libnames$ReactTemplate.pr_reference(r)));
          } else {
            throw exn$1;
          }
        }
        var level = Univ$ReactTemplate.Level[/* make */8](match$1[0], num);
        var evd$1;
        try {
          evd$1 = Evd$ReactTemplate.add_global_univ(evd, level);
        }
        catch (exn$2){
          if (exn$2 === UGraph$ReactTemplate.AlreadyDeclared) {
            evd$1 = evd;
          } else {
            throw exn$2;
          }
        }
        return /* tuple */[
                evd$1,
                level
              ];
      }
    } else {
      throw exn;
    }
  }
}

function interp_universe(loc, evd, l) {
  if (l) {
    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, l) {
                  var evd = param[0];
                  var match;
                  if (l) {
                    var match$1 = l[0];
                    var n = match$1[1];
                    var match$2 = interp_universe_level_name(Evd$ReactTemplate.univ_flexible, evd, match$1[0]);
                    var evd$prime = match$2[0];
                    var u$prime = Univ$ReactTemplate.Universe[/* make */3](match$2[1]);
                    match = n !== 0 ? (
                        n !== 1 ? CErrors$ReactTemplate.user_err(loc, /* Some */["interp_universe"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot interpret universe increment +"), Pp$ReactTemplate.$$int(n))) : /* tuple */[
                            evd$prime,
                            Univ$ReactTemplate.Universe[/* super */10](u$prime)
                          ]
                      ) : /* tuple */[
                        evd$prime,
                        u$prime
                      ];
                  } else {
                    var match$3 = Evd$ReactTemplate.new_univ_level_variable(loc, /* None */0, Evd$ReactTemplate.univ_flexible, evd);
                    match = /* tuple */[
                      match$3[0],
                      Univ$ReactTemplate.Universe[/* make */3](match$3[1])
                    ];
                  }
                  return /* tuple */[
                          match[0],
                          Univ$ReactTemplate.sup(param[1], match[1])
                        ];
                }), /* tuple */[
                evd,
                Univ$ReactTemplate.Universe[/* type0m */12]
              ], l);
  } else {
    var match = Evd$ReactTemplate.new_univ_level_variable(loc, /* None */0, Evd$ReactTemplate.univ_rigid, evd);
    return /* tuple */[
            match[0],
            Univ$ReactTemplate.Universe[/* make */3](match[1])
          ];
  }
}

function frozen_and_pending_holes(param) {
  var sigma$prime = param[1];
  var undefined0 = Evd$ReactTemplate.undefined_map(param[0]);
  if (undefined0 === Evd$ReactTemplate.undefined_map(sigma$prime)) {
    return /* FrozenId */Block.__(0, [undefined0]);
  } else {
    var data = Block.__(246, [(function () {
            var add_derivative_of = function (evk, _, acc) {
              var match = Evarutil$ReactTemplate.advance(sigma$prime, evk);
              if (match) {
                return Curry._2(Evar$ReactTemplate.$$Set[/* add */3], match[0], acc);
              } else {
                return acc;
              }
            };
            var frozen = Curry._3(Evar$ReactTemplate.$$Map[/* fold */10], add_derivative_of, undefined0, Evar$ReactTemplate.$$Set[/* empty */0]);
            var fold = function (evk, _, accu) {
              if (Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], evk, frozen)) {
                return accu;
              } else {
                return Curry._2(Evar$ReactTemplate.$$Set[/* add */3], evk, accu);
              }
            };
            var pending = Evd$ReactTemplate.fold_undefined(fold, sigma$prime, Evar$ReactTemplate.$$Set[/* empty */0]);
            return /* tuple */[
                    frozen,
                    pending
                  ];
          })]);
    return /* FrozenProgress */Block.__(1, [data]);
  }
}

function apply_typeclasses(env, evdref, frozen, fail_evar) {
  var filter_frozen;
  if (frozen.tag) {
    var match = frozen[0];
    var tag = match.tag | 0;
    var match$1 = tag === 250 ? match[0] : (
        tag === 246 ? CamlinternalLazy.force_lazy_block(match) : match
      );
    var frozen$1 = match$1[0];
    filter_frozen = (function (evk) {
        return Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], evk, frozen$1);
      });
  } else {
    var map = frozen[0];
    filter_frozen = (function (evk) {
        return Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], evk, map);
      });
  }
  evdref[0] = Typeclasses$ReactTemplate.resolve_typeclasses(/* None */0, /* Some */[Flags$ReactTemplate.is_program_mode(/* () */0) ? (function (evk, evi) {
              if (Typeclasses$ReactTemplate.no_goals_or_obligations(evk, evi)) {
                return 1 - Curry._1(filter_frozen, evk);
              } else {
                return /* false */0;
              }
            }) : (function (evk, evi) {
              if (Typeclasses$ReactTemplate.no_goals(evk, evi)) {
                return 1 - Curry._1(filter_frozen, evk);
              } else {
                return /* false */0;
              }
            })], /* None */0, /* Some */[/* true */1], /* Some */[fail_evar], env, evdref[0]);
  if (Flags$ReactTemplate.is_program_mode(/* () */0)) {
    evdref[0] = Typeclasses$ReactTemplate.resolve_typeclasses(/* None */0, /* Some */[(function (evk, evi) {
              if (Typeclasses$ReactTemplate.all_evars(evk, evi)) {
                return 1 - Curry._1(filter_frozen, evk);
              } else {
                return /* false */0;
              }
            })], /* None */0, /* Some */[/* true */1], /* Some */[/* false */0], env, evdref[0]);
    return /* () */0;
  } else {
    return 0;
  }
}

function apply_inference_hook(hook, evdref, frozen) {
  if (frozen.tag) {
    var match = frozen[0];
    var tag = match.tag | 0;
    var match$1 = tag === 250 ? match[0] : (
        tag === 246 ? CamlinternalLazy.force_lazy_block(match) : match
      );
    evdref[0] = Curry._3(Evar$ReactTemplate.$$Set[/* fold */13], (function (evk, sigma) {
            if (Evd$ReactTemplate.is_undefined(sigma, evk)) {
              try {
                var match = Curry._2(hook, sigma, evk);
                return Evd$ReactTemplate.define(evk, EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[1]), match[0]);
              }
              catch (exn){
                if (exn === Pervasives.Exit) {
                  return sigma;
                } else {
                  throw exn;
                }
              }
            } else {
              return sigma;
            }
          }), match$1[1], evdref[0]);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function apply_heuristics(env, evdref, fail_evar) {
  try {
    evdref[0] = Evarconv$ReactTemplate.solve_unif_constraints_with_heuristics(env, /* Some */[Typeclasses$ReactTemplate.classes_transparent_state(/* () */0)], evdref[0]);
    return /* () */0;
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      var e$1 = CErrors$ReactTemplate.push(e);
      if (fail_evar) {
        return Util$ReactTemplate.iraise(e$1);
      } else {
        return 0;
      }
    } else {
      throw e;
    }
  }
}

function check_typeclasses_instances_are_solved(env, current_sigma, frozen) {
  return apply_typeclasses(env, [current_sigma], frozen, /* true */1);
}

function check_evars(env, initial_sigma, sigma, c) {
  var proc_rec = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 3) {
      var evk = match[0][0];
      if (Evd$ReactTemplate.mem(initial_sigma, evk)) {
        return 0;
      } else {
        var match$1 = Evd$ReactTemplate.evar_source(evk, sigma);
        var k = match$1[1];
        var exit = 0;
        if (typeof k === "number") {
          exit = 1;
        } else if (k.tag) {
          exit = 1;
        } else if (k[2] !== 0) {
          exit = 1;
        } else {
          return /* () */0;
        }
        if (exit === 1) {
          return Pretype_errors$ReactTemplate.error_unsolvable_implicit(match$1[0], env, sigma, evk, /* None */0);
        }
        
      }
    } else {
      return EConstr$ReactTemplate.iter(sigma, proc_rec, c);
    }
  };
  return proc_rec(c);
}

function check_evars_are_solved(env, current_sigma, frozen) {
  check_typeclasses_instances_are_solved(env, current_sigma, frozen);
  Evarconv$ReactTemplate.check_problems_are_solved(env, current_sigma);
  var env$1 = env;
  var current_sigma$1 = current_sigma;
  var frozen$1 = frozen;
  if (frozen$1.tag) {
    var match = frozen$1[0];
    var tag = match.tag | 0;
    var match$1 = tag === 250 ? match[0] : (
        tag === 246 ? CamlinternalLazy.force_lazy_block(match) : match
      );
    return Curry._2(Evar$ReactTemplate.$$Set[/* iter */12], (function (evk) {
                  if (Evd$ReactTemplate.is_defined(current_sigma$1, evk)) {
                    return 0;
                  } else {
                    var match = Evd$ReactTemplate.evar_source(evk, current_sigma$1);
                    var k = match[1];
                    var exit = 0;
                    if (typeof k === "number") {
                      exit = 1;
                    } else if (k.tag) {
                      exit = 1;
                    } else if (k[2] !== 0) {
                      exit = 1;
                    } else {
                      return /* () */0;
                    }
                    if (exit === 1) {
                      return Pretype_errors$ReactTemplate.error_unsolvable_implicit(match[0], env$1, current_sigma$1, evk, /* None */0);
                    }
                    
                  }
                }), match$1[1]);
  } else {
    return /* () */0;
  }
}

function solve_remaining_evars(flags, env, current_sigma, init_sigma) {
  var frozen = frozen_and_pending_holes(/* tuple */[
        init_sigma,
        current_sigma
      ]);
  var evdref = [current_sigma];
  if (flags[/* use_typeclasses */0]) {
    apply_typeclasses(env, evdref, frozen, /* false */0);
  }
  if (Option$ReactTemplate.has_some(flags[/* use_hook */2])) {
    apply_inference_hook(Curry._1(Option$ReactTemplate.get(flags[/* use_hook */2]), env), evdref, frozen);
  }
  if (flags[/* solve_unification_constraints */1]) {
    apply_heuristics(env, evdref, /* false */0);
  }
  if (flags[/* fail_evar */3]) {
    check_evars_are_solved(env, evdref[0], frozen);
  }
  return evdref[0];
}

function check_evars_are_solved$1(env, current_sigma, init_sigma) {
  var frozen = frozen_and_pending_holes(/* tuple */[
        init_sigma,
        current_sigma
      ]);
  return check_evars_are_solved(env, current_sigma, frozen);
}

function adjust_evar_source(evdref, na, c) {
  var match = EConstr$ReactTemplate.kind(evdref[0], c);
  if (na) {
    if (match.tag === 3) {
      var match$1 = match[0];
      var evk = match$1[0];
      var evi = Evd$ReactTemplate.find(evdref[0], evk);
      var match$2 = evi[/* evar_source */4];
      var match$3 = match$2[1];
      if (typeof match$3 === "number") {
        return c;
      } else if (match$3.tag === 3) {
        if (match$3[1]) {
          return c;
        } else {
          var src_000 = match$2[0];
          var src_001 = /* QuestionMark */Block.__(3, [
              match$3[0],
              na
            ]);
          var src = /* tuple */[
            src_000,
            src_001
          ];
          var match$4 = Evarutil$ReactTemplate.restrict_evar(evdref[0], evk, Evd$ReactTemplate.evar_filter(evi), /* Some */[src], /* None */0);
          evdref[0] = match$4[0];
          return EConstr$ReactTemplate.mkEvar(/* tuple */[
                      match$4[1],
                      match$1[1]
                    ]);
        }
      } else {
        return c;
      }
    } else {
      return c;
    }
  } else {
    return c;
  }
}

function inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, j, param) {
  if (param) {
    var partial_arg = env[/* env */0];
    var partial_arg$1 = Coercion$ReactTemplate.inh_conv_coerce_to(loc, resolve_tc);
    return Evarutil$ReactTemplate.evd_comb2((function (param, param$1, param$2) {
                  return partial_arg$1(partial_arg, param, param$1, param$2);
                }), evdref, j, param[0]);
  } else {
    return j;
  }
}

function check_instance(loc, subst, param) {
  if (param) {
    var id = param[0][0];
    if (Curry._2(Util$ReactTemplate.List[/* mem_assoc */32], id, subst)) {
      return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str("appears more than once.")));
    } else {
      return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such variable in the signature of the existential variable: "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(".")));
    }
  } else {
    return /* () */0;
  }
}

function orelse_name(name, name$prime) {
  if (name) {
    return name;
  } else {
    return name$prime;
  }
}

function ltac_interp_name_env(k0, lvar, env, sigma) {
  var n = Curry._1(Context$ReactTemplate.Rel[/* length */3], EConstr$ReactTemplate.rel_context(env[/* env */0])) - k0 | 0;
  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], n, EConstr$ReactTemplate.rel_context(env[/* env */0]));
  var ctxt = match[0];
  var ctxt$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* map_name */10], (function (param) {
              return Glob_ops$ReactTemplate.ltac_interp_name(lvar, param);
            })), ctxt);
  if (Curry._3(Util$ReactTemplate.List[/* equal */44], (function (d1, d2) {
            return Curry._2(Nameops$ReactTemplate.Name[/* equal */4], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], d1), Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], d2));
          }), ctxt, ctxt$prime)) {
    return env;
  } else {
    return push_rel_context(sigma, ctxt$prime, pop_rel_context(n, env, sigma));
  }
}

function protected_get_type_of(env, sigma, c) {
  try {
    return Retyping$ReactTemplate.get_type_of(/* None */0, /* Some */[/* true */1], env[/* env */0], sigma, c);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Retyping$ReactTemplate.RetypeError) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot reinterpret "), Pp$ReactTemplate.quote(Termops$ReactTemplate.print_constr(c))), Pp$ReactTemplate.str(" in the current environment.")));
    } else {
      throw exn;
    }
  }
}

function pretype_id(pretype, k0, loc, env, evdref, lvar, id) {
  var sigma = evdref[0];
  try {
    var match = Termops$ReactTemplate.lookup_rel_id(id, EConstr$ReactTemplate.rel_context(env[/* env */0]));
    var n = match[0];
    return /* record */[
            /* uj_val */EConstr$ReactTemplate.mkRel(n),
            /* uj_type */EConstr$ReactTemplate.Vars[/* lift */0](n, match[2])
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var env$1 = ltac_interp_name_env(k0, lvar, env, evdref[0]);
      try {
        var match$1 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, lvar[/* ltac_constrs */0]);
        var subst = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                var lvar$1 = lvar;
                var env$2 = env$1;
                var id0 = id;
                var id$1 = param;
                var id$prime = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$1, lvar$1[/* ltac_idents */2]);
                try {
                  return EConstr$ReactTemplate.mkRel(Util$ReactTemplate.pi1(Termops$ReactTemplate.lookup_rel_id(id$prime, EConstr$ReactTemplate.rel_context(env$2[/* env */0]))));
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Ltac variable "), Names$ReactTemplate.Id[/* print */8](id0)), Pp$ReactTemplate.str(" depends on pattern variable name ")), Names$ReactTemplate.Id[/* print */8](id$1)), Pp$ReactTemplate.str(" which is not bound in current context.")));
                  } else {
                    throw exn;
                  }
                }
              }), match$1[0]);
        var c = EConstr$ReactTemplate.Vars[/* substl */3](subst, match$1[1]);
        return /* record */[
                /* uj_val */c,
                /* uj_type */protected_get_type_of(env$1, sigma, c)
              ];
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          try {
            var match$2 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, lvar[/* ltac_uconstrs */1]);
            var closure = match$2[/* closure */0];
            var lvar_000 = /* ltac_constrs */closure[/* typed */1];
            var lvar_001 = /* ltac_uconstrs */closure[/* untyped */2];
            var lvar_002 = /* ltac_idents */closure[/* idents */0];
            var lvar_003 = /* ltac_genargs */Names$ReactTemplate.Id[/* Map */10][/* empty */0];
            var lvar$1 = /* record */[
              lvar_000,
              lvar_001,
              lvar_002,
              lvar_003
            ];
            return Curry._4(pretype, env$1, evdref, lvar$1, match$2[/* term */1]);
          }
          catch (exn$2){
            if (exn$2 === Caml_builtin_exceptions.not_found) {
              if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id, lvar[/* ltac_genargs */3])) {
                var match$3 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, lvar[/* ltac_genargs */3]);
                CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Variable "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(" should be bound to a term but is bound to a ")), Geninterp$ReactTemplate.Val[/* pr */3](match$3[0])), Pp$ReactTemplate.str(".")));
              }
              try {
                return /* record */[
                        /* uj_val */EConstr$ReactTemplate.mkVar(id),
                        /* uj_type */Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], EConstr$ReactTemplate.lookup_named(id, env$1[/* env */0]))
                      ];
              }
              catch (exn$3){
                if (exn$3 === Caml_builtin_exceptions.not_found) {
                  return Pretype_errors$ReactTemplate.error_var_not_found(loc, id);
                } else {
                  throw exn$3;
                }
              }
            } else {
              throw exn$2;
            }
          }
        } else {
          throw exn$1;
        }
      }
    } else {
      throw exn;
    }
  }
}

function interp_known_glob_level(loc, evd, param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return Univ$ReactTemplate.Level[/* set */0];
    } else {
      return Univ$ReactTemplate.Level[/* prop */1];
    }
  } else {
    var loc$1 = loc;
    var evd$1 = evd;
    var param$1 = param[0];
    if (typeof param$1 === "number") {
      return CErrors$ReactTemplate.user_err(loc$1, /* Some */["interp_known_level_info"], Pp$ReactTemplate.str("Anonymous universes not allowed here."));
    } else {
      var ref = param$1[0];
      try {
        return interp_known_universe_level(evd$1, ref);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return CErrors$ReactTemplate.user_err(loc$1, /* Some */["interp_known_level_info"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Undeclared universe "), Libnames$ReactTemplate.pr_reference(ref)));
        } else {
          throw exn;
        }
      }
    }
  }
}

function interp_glob_level(loc, evd, param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return /* tuple */[
              evd,
              Univ$ReactTemplate.Level[/* set */0]
            ];
    } else {
      return /* tuple */[
              evd,
              Univ$ReactTemplate.Level[/* prop */1]
            ];
    }
  } else {
    var loc$1 = loc;
    var evd$1 = evd;
    var param$1 = param[0];
    if (typeof param$1 === "number") {
      if (param$1 !== 0) {
        return Evd$ReactTemplate.new_univ_level_variable(loc$1, /* None */0, Evd$ReactTemplate.univ_rigid, evd$1);
      } else {
        return Evd$ReactTemplate.new_univ_level_variable(loc$1, /* None */0, Evd$ReactTemplate.univ_flexible, evd$1);
      }
    } else {
      return interp_universe_level_name(Evd$ReactTemplate.univ_flexible, evd$1, param$1[0]);
    }
  }
}

function interp_instance(loc, evd, len, l) {
  if (len !== Curry._1(Util$ReactTemplate.List[/* length */0], l)) {
    return CErrors$ReactTemplate.user_err(loc, /* Some */["pretype"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Universe instance should have length "), Pp$ReactTemplate.$$int(len)));
  } else {
    var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, l) {
            var match = interp_glob_level(loc, param[0], l);
            return /* tuple */[
                    match[0],
                    /* :: */[
                      match[1],
                      param[1]
                    ]
                  ];
          }), /* tuple */[
          evd,
          /* [] */0
        ], l);
    var l$prime = match[1];
    if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (l) {
              return Univ$ReactTemplate.Level[/* is_prop */3](l);
            }), l$prime)) {
      CErrors$ReactTemplate.user_err(loc, /* Some */["pretype"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Universe instances cannot contain Prop, polymorphic"), Pp$ReactTemplate.str(" universe instances must be greater or equal to Set.")));
    }
    return /* tuple */[
            match[0],
            /* Some */[Univ$ReactTemplate.Instance[/* of_array */2](Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(Util$ReactTemplate.List[/* rev */4], l$prime)))]
          ];
  }
}

function pretype_global(loc, rigid, env, evd, gr, us) {
  var match;
  if (us) {
    var match$1 = Global$ReactTemplate.constr_of_global_in_context(env[/* env */0], gr);
    var len = Univ$ReactTemplate.AUContext[/* size */4](match$1[1]);
    match = interp_instance(loc, evd, len, us[0]);
  } else {
    match = /* tuple */[
      evd,
      /* None */0
    ];
  }
  var match$2 = Evd$ReactTemplate.fresh_global(loc, /* Some */[rigid], match[1], env[/* env */0], match[0], gr);
  return /* tuple */[
          match$2[0],
          EConstr$ReactTemplate.of_constr(match$2[1])
        ];
}

function pretype_ref(loc, evdref, env, ref, us) {
  if (ref.tag) {
    var match = pretype_global(loc, Evd$ReactTemplate.univ_flexible, env, evdref[0], ref, us);
    var c = match[1];
    var evd = match[0];
    evdref[0] = evd;
    var ty = Typing$ReactTemplate.unsafe_type_of(env[/* env */0], evd, c);
    return Environ$ReactTemplate.make_judge(c, ty);
  } else {
    var id = ref[0];
    try {
      return Environ$ReactTemplate.make_judge(EConstr$ReactTemplate.mkVar(id), Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], EConstr$ReactTemplate.lookup_named(id, env[/* env */0])));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Pretype_errors$ReactTemplate.error_var_not_found(loc, id);
      } else {
        throw exn;
      }
    }
  }
}

function pretype_sort(loc, evdref, param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return Typing$ReactTemplate.judge_of_set;
    } else {
      return Typing$ReactTemplate.judge_of_prop;
    }
  } else {
    return Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                  var loc$1 = loc;
                  var evd = param;
                  var s = param$1;
                  var match = interp_universe(loc$1, evd, s);
                  var s$1 = match[1];
                  var judge_000 = /* uj_val */EConstr$ReactTemplate.mkSort(/* Type */Block.__(1, [s$1]));
                  var judge_001 = /* uj_type */EConstr$ReactTemplate.mkSort(/* Type */Block.__(1, [Univ$ReactTemplate.$$super(s$1)]));
                  var judge = /* record */[
                    judge_000,
                    judge_001
                  ];
                  return /* tuple */[
                          match[0],
                          judge
                        ];
                }), evdref, param[0]);
  }
}

function new_type_evar(env, evdref, loc) {
  var sigma = evdref[0];
  var match = Evarutil$ReactTemplate.new_type_evar(env[/* env */0], sigma, /* Some */[/* tuple */[
          loc,
          /* InternalHole */0
        ]], /* None */0, /* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg);
  evdref[0] = match[0];
  return match[1][0];
}

function $$default() {
  return /* None */0;
}

var ConstrInterpObj = /* module */[
  /* name */"constr_interp",
  /* default */$$default
];

var ConstrInterp = Genarg$ReactTemplate.Register(ConstrInterpObj);

var register_constr_interp0 = ConstrInterp[/* register0 */0];

function pretype(k0, resolve_tc, tycon, env, evdref, lvar, t) {
  var pretype_type$1 = function (param, param$1, param$2, param$3, param$4) {
    return pretype_type(k0, resolve_tc, param, param$1, param$2, param$3, param$4);
  };
  var pretype$1 = function (param, param$1, param$2, param$3, param$4) {
    return pretype(k0, resolve_tc, param, param$1, param$2, param$3, param$4);
  };
  var loc = t[/* loc */1];
  var match = DAst$ReactTemplate.get(t);
  switch (match.tag | 0) {
    case 0 : 
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, pretype_ref(loc, evdref, env, match[0], match[1]), tycon);
    case 1 : 
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, pretype_id((function (e, r, l, t) {
                          return pretype$1(tycon, e, r, l, t);
                        }), k0, loc, env, evdref, lvar, match[0]), tycon);
    case 2 : 
        var evk;
        try {
          evk = Evd$ReactTemplate.evar_key(match[0], evdref[0]);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            evk = CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("Unknown existential variable."));
          } else {
            throw exn;
          }
        }
        var hyps = Evd$ReactTemplate.evar_filtered_context(Evd$ReactTemplate.find(evdref[0], evk));
        var args = pretype_instance(k0, resolve_tc, env, evdref, lvar, loc, hyps, evk, match[1]);
        var c = EConstr$ReactTemplate.mkEvar(/* tuple */[
              evk,
              args
            ]);
        var j = Retyping$ReactTemplate.get_judgment_of(env[/* env */0], evdref[0], c);
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, j, tycon);
    case 3 : 
        var env$1 = ltac_interp_name_env(k0, lvar, env, evdref[0]);
        var ty = tycon ? tycon[0] : new_type_evar(env$1, evdref, loc);
        var k = /* MatchingVar */Block.__(6, [match[0]]);
        return /* record */[
                /* uj_val */e_new_evar(env$1, evdref, /* Some */[/* tuple */[
                        loc,
                        k
                      ]], /* None */0, ty),
                /* uj_type */ty
              ];
    case 4 : 
        var args$1 = match[1];
        var f = match[0];
        var fj = pretype$1(Evardefine$ReactTemplate.empty_tycon, env, evdref, lvar, f);
        var floc = Glob_ops$ReactTemplate.loc_of_glob_constr(f);
        var length = Curry._1(Util$ReactTemplate.List[/* length */0], args$1);
        var candargs;
        if (Flags$ReactTemplate.is_program_mode(/* () */0) && length > 0 && EConstr$ReactTemplate.isConstruct(evdref[0], fj[/* uj_val */0])) {
          if (tycon) {
            var match$1 = EConstr$ReactTemplate.destConstruct(evdref[0], fj[/* uj_val */0]);
            var ind = match$1[0][0];
            var npars = Inductiveops$ReactTemplate.inductive_nparams(ind);
            if (npars) {
              try {
                var match$2 = Inductiveops$ReactTemplate.find_rectype(env[/* env */0], evdref[0], tycon[0]);
                var match$3 = Inductiveops$ReactTemplate.dest_ind_family(match$2[0]);
                candargs = Names$ReactTemplate.eq_ind(ind, match$3[0][0]) ? Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, match$3[1]) : /* [] */0;
              }
              catch (exn$1){
                if (exn$1 === Caml_builtin_exceptions.not_found) {
                  candargs = /* [] */0;
                } else {
                  throw exn$1;
                }
              }
            } else {
              candargs = /* [] */0;
            }
          } else {
            candargs = /* [] */0;
          }
        } else {
          candargs = /* [] */0;
        }
        var match$4 = EConstr$ReactTemplate.kind(evdref[0], fj[/* uj_val */0]);
        var app_f;
        var exit = 0;
        if (match$4.tag === 10) {
          var p = match$4[0][0];
          if (Environ$ReactTemplate.is_projection(p, env[/* env */0])) {
            var p$1 = Names$ReactTemplate.Projection[/* make */0](p, /* false */0);
            var pb = Environ$ReactTemplate.lookup_projection(p$1, env[/* env */0]);
            var npars$1 = pb[/* proj_npars */1];
            app_f = (function (n) {
                if (n === (npars$1 + 1 | 0)) {
                  return (function (_, v) {
                      return EConstr$ReactTemplate.mkProj(/* tuple */[
                                  p$1,
                                  v
                                ]);
                    });
                } else {
                  return (function (f, v) {
                      return EConstr$ReactTemplate.applist(/* tuple */[
                                  f,
                                  /* :: */[
                                    v,
                                    /* [] */0
                                  ]
                                ]);
                    });
                }
              });
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          app_f = (function (_, f, v) {
              return EConstr$ReactTemplate.applist(/* tuple */[
                          f,
                          /* :: */[
                            v,
                            /* [] */0
                          ]
                        ]);
            });
        }
        var apply_rec = function (env, _n, _resj, _candargs, _param) {
          while(true) {
            var param = _param;
            var candargs = _candargs;
            var resj = _resj;
            var n = _n;
            if (param) {
              var c = param[0];
              var argloc = Glob_ops$ReactTemplate.loc_of_glob_constr(c);
              var partial_arg = env[/* env */0];
              var resj$1 = Evarutil$ReactTemplate.evd_comb1((function(partial_arg){
                  return function (param, param$1) {
                    return Coercion$ReactTemplate.inh_app_fun(resolve_tc, partial_arg, param, param$1);
                  }
                  }(partial_arg)), evdref, resj);
              var resty = Reductionops$ReactTemplate.whd_all(env[/* env */0])(evdref[0], resj$1[/* uj_type */1]);
              var match = EConstr$ReactTemplate.kind(evdref[0], resty);
              if (match.tag === 6) {
                var tycon = /* Some */[match[1]];
                var hj = pretype$1(tycon, env, evdref, lvar, c);
                var match$1 = candargs ? (
                    Evarconv$ReactTemplate.e_conv(env[/* env */0], /* None */0, evdref, Environ$ReactTemplate.j_val(hj), candargs[0]) ? /* tuple */[
                        candargs[1],
                        Evarutil$ReactTemplate.nf_evar(evdref[0], Environ$ReactTemplate.j_val(hj))
                      ] : /* tuple */[
                        /* [] */0,
                        Environ$ReactTemplate.j_val(hj)
                      ]
                  ) : /* tuple */[
                    /* [] */0,
                    Environ$ReactTemplate.j_val(hj)
                  ];
                var ujval = adjust_evar_source(evdref, match[0], match$1[1]);
                var value = Curry._3(app_f, n, Environ$ReactTemplate.j_val(resj$1), ujval);
                var typ = EConstr$ReactTemplate.Vars[/* subst1 */4](ujval, match[2]);
                var j = /* record */[
                  /* uj_val */value,
                  /* uj_type */typ
                ];
                _param = param[1];
                _candargs = match$1[0];
                _resj = j;
                _n = n + 1 | 0;
                continue ;
                
              } else {
                var hj$1 = pretype$1(Evardefine$ReactTemplate.empty_tycon, env, evdref, lvar, c);
                return Pretype_errors$ReactTemplate.error_cant_apply_not_functional(Loc$ReactTemplate.merge_opt(floc, argloc), env[/* env */0], evdref[0], resj$1, /* array */[hj$1]);
              }
            } else {
              return resj;
            }
          };
        };
        var resj = apply_rec(env, 1, fj, candargs, args$1);
        var match$5 = EConstr$ReactTemplate.kind(evdref[0], resj[/* uj_val */0]);
        var resj$1;
        if (match$5.tag === 9) {
          var f$1 = match$5[0];
          if (Termops$ReactTemplate.is_template_polymorphic(env[/* env */0], evdref[0], f$1)) {
            var c$1 = EConstr$ReactTemplate.mkApp(/* tuple */[
                  f$1,
                  match$5[1]
                ]);
            var partial_arg = env[/* env */0];
            var partial_arg$1 = /* Some */[/* true */1];
            var c$2 = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                    return Evarsolve$ReactTemplate.refresh_universes(/* None */0, /* None */0, /* None */0, partial_arg$1, partial_arg, param, param$1);
                  }), evdref, c$1);
            var t$1 = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env[/* env */0], evdref[0], c$2);
            resj$1 = Environ$ReactTemplate.make_judge(c$2, t$1);
          } else {
            resj$1 = resj;
          }
        } else {
          resj$1 = resj;
        }
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, resj$1, tycon);
    case 5 : 
        var name = match[0];
        var tycon$prime = Evarutil$ReactTemplate.evd_comb1((function (evd, tycon) {
                if (tycon) {
                  var match = Coercion$ReactTemplate.inh_coerce_to_prod(loc, env[/* env */0], evd, tycon[0]);
                  return /* tuple */[
                          match[0],
                          /* Some */[match[1]]
                        ];
                } else {
                  return /* tuple */[
                          evd,
                          tycon
                        ];
                }
              }), evdref, tycon);
        var partial_arg$2 = env[/* env */0];
        var match$6 = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                return Evardefine$ReactTemplate.split_tycon(loc, partial_arg$2, param, param$1);
              }), evdref, tycon$prime);
        var dom_valcon = Evardefine$ReactTemplate.valcon_of_tycon(match$6[1]);
        var j$1 = pretype_type$1(dom_valcon, env, evdref, lvar, match[2]);
        var var_001 = j$1[/* utj_val */0];
        var $$var = /* LocalAssum */Block.__(0, [
            name,
            var_001
          ]);
        var j$prime = pretype$1(match$6[2], push_rel(evdref[0], $$var, env), evdref, lvar, match[3]);
        var name$1 = Glob_ops$ReactTemplate.ltac_interp_name(lvar, name);
        var resj$2 = Typing$ReactTemplate.judge_of_abstraction(env[/* env */0], orelse_name(name$1, match$6[0]), j$1, j$prime);
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, resj$2, tycon);
    case 6 : 
        var c2 = match[3];
        var name$2 = match[0];
        var j$2 = pretype_type$1(Evardefine$ReactTemplate.empty_valcon, env, evdref, lvar, match[2]);
        var j$prime$1;
        if (name$2) {
          var var_001$1 = j$2[/* utj_val */0];
          var $$var$1 = /* LocalAssum */Block.__(0, [
              name$2,
              var_001$1
            ]);
          var env$prime = push_rel(evdref[0], $$var$1, env);
          j$prime$1 = pretype_type$1(Evardefine$ReactTemplate.empty_valcon, env$prime, evdref, lvar, c2);
        } else {
          var j$3 = pretype_type$1(Evardefine$ReactTemplate.empty_valcon, env, evdref, lvar, c2);
          j$prime$1 = /* record */[
            /* utj_val */EConstr$ReactTemplate.Vars[/* lift */0](1, j$3[/* utj_val */0]),
            /* utj_type */j$3[/* utj_type */1]
          ];
        }
        var name$3 = Glob_ops$ReactTemplate.ltac_interp_name(lvar, name$2);
        var resj$3;
        try {
          resj$3 = Typing$ReactTemplate.judge_of_product(env[/* env */0], name$3, j$2, j$prime$1);
        }
        catch (raw_e){
          var e = Js_exn.internalToOCamlException(raw_e);
          if (e[0] === Type_errors$ReactTemplate.TypeError) {
            var match$7 = CErrors$ReactTemplate.push(e);
            var info = match$7[1];
            var info$1 = Option$ReactTemplate.cata((function (param) {
                    return Loc$ReactTemplate.add_loc(info, param);
                  }), info, loc);
            resj$3 = Util$ReactTemplate.iraise(/* tuple */[
                  match$7[0],
                  info$1
                ]);
          } else {
            throw e;
          }
        }
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, resj$3, tycon);
    case 7 : 
        var t$2 = match[2];
        var name$4 = match[0];
        var tycon1 = t$2 ? Evardefine$ReactTemplate.mk_tycon(pretype_type$1(Evardefine$ReactTemplate.empty_valcon, env, evdref, lvar, t$2[0])[/* utj_val */0]) : Evardefine$ReactTemplate.empty_tycon;
        var j$4 = pretype$1(tycon1, env, evdref, lvar, match[1]);
        var partial_arg$3 = env[/* env */0];
        var partial_arg$4 = /* Some */[/* false */0];
        var partial_arg$5 = /* Some */[/* true */1];
        var partial_arg$6 = /* Some */[Evd$ReactTemplate.univ_flexible];
        var t$3 = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                return Evarsolve$ReactTemplate.refresh_universes(partial_arg$6, partial_arg$5, /* None */0, partial_arg$4, partial_arg$3, param, param$1);
              }), evdref, j$4[/* uj_type */1]);
        var var_001$2 = j$4[/* uj_val */0];
        var $$var$2 = /* LocalDef */Block.__(1, [
            name$4,
            var_001$2,
            t$3
          ]);
        var tycon$1 = Evardefine$ReactTemplate.lift_tycon(1)(tycon);
        var j$prime$2 = pretype$1(tycon$1, push_rel(evdref[0], $$var$2, env), evdref, lvar, match[3]);
        var name$5 = Glob_ops$ReactTemplate.ltac_interp_name(lvar, name$4);
        return /* record */[
                /* uj_val */EConstr$ReactTemplate.mkLetIn(/* tuple */[
                      name$5,
                      j$4[/* uj_val */0],
                      t$3,
                      j$prime$2[/* uj_val */0]
                    ]),
                /* uj_type */EConstr$ReactTemplate.Vars[/* subst1 */4](j$4[/* uj_val */0], j$prime$2[/* uj_type */1])
              ];
    case 8 : 
        return Cases$ReactTemplate.compile_cases(loc, match[0], /* tuple */[
                    (function (vtyc, env, evdref) {
                        var partial_arg = make_env(env, evdref[0]);
                        return (function (param, param$1) {
                            return pretype$1(vtyc, partial_arg, evdref, param, param$1);
                          });
                      }),
                    evdref
                  ], tycon, env[/* env */0], lvar, /* tuple */[
                    match[1],
                    match[2],
                    match[3]
                  ]);
    case 9 : 
        var d = match[3];
        var c$3 = match[2];
        var match$8 = match[1];
        var po = match$8[1];
        var na = match$8[0];
        var nal = match[0];
        var cj = pretype$1(Evardefine$ReactTemplate.empty_tycon, env, evdref, lvar, c$3);
        var match$9;
        try {
          match$9 = Inductiveops$ReactTemplate.find_rectype(env[/* env */0], evdref[0], cj[/* uj_type */1]);
        }
        catch (exn$2){
          if (exn$2 === Caml_builtin_exceptions.not_found) {
            var cloc = Glob_ops$ReactTemplate.loc_of_glob_constr(c$3);
            match$9 = Pretype_errors$ReactTemplate.error_case_not_inductive(cloc, env[/* env */0], evdref[0], cj);
          } else {
            throw exn$2;
          }
        }
        var indf = match$9[0];
        var cstrs = Inductiveops$ReactTemplate.get_constructors(env[/* env */0], indf);
        if (cstrs.length !== 1) {
          CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Destructing let is only for inductive types"), Pp$ReactTemplate.str(" with one constructor.")));
        }
        var cs = Caml_array.caml_array_get(cstrs, 0);
        if (Curry._1(Util$ReactTemplate.List[/* length */0], nal) !== cs[/* cs_nargs */2]) {
          CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Destructing let on this type expects "), Pp$ReactTemplate.$$int(cs[/* cs_nargs */2])), Pp$ReactTemplate.str(" variables.")));
        }
        var set_name = function (na, d) {
          return Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], na, Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d));
        };
        var match$10 = Inductiveops$ReactTemplate.get_projections(env[/* env */0], indf);
        var match$11;
        if (match$10) {
          var ps = match$10[0];
          var aux = function (n, k, names, l) {
            if (names) {
              if (l) {
                var decl = l[0];
                var names$1 = names[1];
                var na = names[0];
                if (decl.tag) {
                  return /* :: */[
                          set_name(na, decl),
                          aux(n + 1 | 0, k, names$1, l[1])
                        ];
                } else {
                  var t = EConstr$ReactTemplate.of_constr(decl[1]);
                  var proj = Names$ReactTemplate.Projection[/* make */0](Caml_array.caml_array_get(ps, cs[/* cs_nargs */2] - k | 0), /* true */1);
                  return /* :: */[
                          /* LocalDef */Block.__(1, [
                              na,
                              EConstr$ReactTemplate.Vars[/* lift */0](cs[/* cs_nargs */2] - n | 0, EConstr$ReactTemplate.mkProj(/* tuple */[
                                        proj,
                                        cj[/* uj_val */0]
                                      ])),
                              t
                            ]),
                          aux(n + 1 | 0, k + 1 | 0, names$1, l[1])
                        ];
                }
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "pretyping.ml",
                        926,
                        10
                      ]
                    ];
              }
            } else if (l) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "pretyping.ml",
                      926,
                      10
                    ]
                  ];
            } else {
              return /* [] */0;
            }
          };
          match$11 = /* tuple */[
            aux(1, 1, Curry._1(Util$ReactTemplate.List[/* rev */4], nal), cs[/* cs_args */3]),
            /* true */1
          ];
        } else {
          match$11 = /* tuple */[
            Curry._3(Util$ReactTemplate.List[/* map2 */16], set_name, Curry._1(Util$ReactTemplate.List[/* rev */4], nal), cs[/* cs_args */3]),
            /* false */0
          ];
        }
        var record = match$11[1];
        var fsign = match$11[0];
        var fsign$1;
        if (Flags$ReactTemplate.version_strictly_greater(/* V8_6 */0)) {
          var partial_arg$7 = evdref[0];
          fsign$1 = Curry._1(Context$ReactTemplate.Rel[/* map */7]((function (param) {
                      return Reductionops$ReactTemplate.whd_betaiota(partial_arg$7, param);
                    })), fsign);
        } else {
          fsign$1 = fsign;
        }
        var obj = function (ind, p, _, f) {
          if (record) {
            return EConstr$ReactTemplate.it_mkLambda_or_LetIn(f, fsign$1);
          } else {
            var nal$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (na) {
                    return Glob_ops$ReactTemplate.ltac_interp_name(lvar, na);
                  }), nal);
            var nal$2 = Curry._1(Util$ReactTemplate.List[/* rev */4], nal$1);
            var fsign$2 = Curry._3(Util$ReactTemplate.List[/* map2 */16], Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], nal$2, fsign$1);
            var f$1 = EConstr$ReactTemplate.it_mkLambda_or_LetIn(f, fsign$2);
            var ci = Inductiveops$ReactTemplate.make_case_info(env[/* env */0], ind[0], /* LetStyle */0);
            return EConstr$ReactTemplate.mkCase(/* tuple */[
                        ci,
                        p,
                        cj[/* uj_val */0],
                        /* array */[f$1]
                      ]);
          }
        };
        var env_f = push_rel_context(evdref[0], fsign$1, env);
        var match$12 = Inductiveops$ReactTemplate.get_arity(env[/* env */0], indf);
        var arsgn = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], /* Anonymous */0), match$12[0]);
        var indt = Inductiveops$ReactTemplate.build_dependent_inductive(env[/* env */0], indf);
        var psign_000 = /* LocalAssum */Block.__(0, [
            na,
            indt
          ]);
        var psign = /* :: */[
          psign_000,
          arsgn
        ];
        var predlvar = Cases$ReactTemplate.make_return_predicate_ltac_lvar(evdref[0], na, c$3, cj[/* uj_val */0], lvar);
        var psign$prime_000 = /* LocalAssum */Block.__(0, [
            Glob_ops$ReactTemplate.ltac_interp_name(predlvar, na),
            indt
          ]);
        var psign$prime = /* :: */[
          psign$prime_000,
          arsgn
        ];
        var psign$prime$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
                return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
              }), psign$prime);
        var psign$prime$2 = Namegen$ReactTemplate.name_context(env[/* env */0], evdref[0], psign$prime$1);
        var psign$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
                return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
              }), psign);
        var nar = Curry._1(Util$ReactTemplate.List[/* length */0], arsgn);
        if (po) {
          var env_p = push_rel_context(evdref[0], psign$1, env);
          var pj = pretype_type$1(Evardefine$ReactTemplate.empty_valcon, env_p, evdref, predlvar, po[0]);
          var ccl = Evarutil$ReactTemplate.nf_evar(evdref[0], pj[/* utj_val */0]);
          var p$2 = EConstr$ReactTemplate.it_mkLambda_or_LetIn(ccl, psign$prime$2);
          var inst = Util$ReactTemplate.$at(Util$ReactTemplate.$$Array[/* map_to_list */44](EConstr$ReactTemplate.of_constr, cs[/* cs_concl_realargs */4]), /* :: */[
                EConstr$ReactTemplate.of_constr(Inductiveops$ReactTemplate.build_dependent_constructor(cs)),
                /* [] */0
              ]);
          var lp = EConstr$ReactTemplate.Vars[/* lift */0](cs[/* cs_nargs */2], p$2);
          var fty = Reductionops$ReactTemplate.hnf_lam_applist(env[/* env */0], evdref[0], lp, inst);
          var fj$1 = pretype$1(Evardefine$ReactTemplate.mk_tycon(fty), env_f, evdref, lvar, d);
          var match$13 = Inductiveops$ReactTemplate.dest_ind_family(indf);
          var ind$1 = match$13[0];
          Typing$ReactTemplate.check_allowed_sort(env[/* env */0], evdref[0], ind$1, cj[/* uj_val */0], p$2);
          var v = obj(ind$1, p$2, cj[/* uj_val */0], fj$1[/* uj_val */0]);
          return /* record */[
                  /* uj_val */v,
                  /* uj_type */EConstr$ReactTemplate.Vars[/* substl */3](Util$ReactTemplate.$at(match$9[1], /* :: */[
                            cj[/* uj_val */0],
                            /* [] */0
                          ]), ccl)
                ];
        } else {
          var tycon$2 = Evardefine$ReactTemplate.lift_tycon(cs[/* cs_nargs */2])(tycon);
          var fj$2 = pretype$1(tycon$2, env_f, evdref, predlvar, d);
          var ccl$1 = Evarutil$ReactTemplate.nf_evar(evdref[0], fj$2[/* uj_type */1]);
          var ccl$2 = EConstr$ReactTemplate.Vars[/* noccur_between */13](evdref[0], 1, cs[/* cs_nargs */2], ccl$1) ? EConstr$ReactTemplate.Vars[/* lift */0](-cs[/* cs_nargs */2] | 0, ccl$1) : Pretype_errors$ReactTemplate.error_cant_find_case_type(loc, env[/* env */0], evdref[0], cj[/* uj_val */0]);
          var p$3 = EConstr$ReactTemplate.it_mkLambda_or_LetIn(EConstr$ReactTemplate.Vars[/* lift */0](nar + 1 | 0, ccl$2), psign$prime$2);
          var match$14 = Inductiveops$ReactTemplate.dest_ind_family(indf);
          var ind$2 = match$14[0];
          Typing$ReactTemplate.check_allowed_sort(env[/* env */0], evdref[0], ind$2, cj[/* uj_val */0], p$3);
          var v$1 = obj(ind$2, p$3, cj[/* uj_val */0], fj$2[/* uj_val */0]);
          return /* record */[
                  /* uj_val */v$1,
                  /* uj_type */ccl$2
                ];
        }
        break;
    case 10 : 
        var match$15 = match[1];
        var po$1 = match$15[1];
        var na$1 = match$15[0];
        var c$4 = match[0];
        var cj$1 = pretype$1(Evardefine$ReactTemplate.empty_tycon, env, evdref, lvar, c$4);
        var match$16;
        try {
          match$16 = Inductiveops$ReactTemplate.find_rectype(env[/* env */0], evdref[0], cj$1[/* uj_type */1]);
        }
        catch (exn$3){
          if (exn$3 === Caml_builtin_exceptions.not_found) {
            var cloc$1 = Glob_ops$ReactTemplate.loc_of_glob_constr(c$4);
            match$16 = Pretype_errors$ReactTemplate.error_case_not_inductive(cloc$1, env[/* env */0], evdref[0], cj$1);
          } else {
            throw exn$3;
          }
        }
        var indf$1 = match$16[0];
        var cstrs$1 = Inductiveops$ReactTemplate.get_constructors(env[/* env */0], indf$1);
        if (cstrs$1.length !== 2) {
          CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("If is only for inductive types with two constructors."));
        }
        var match$17 = Inductiveops$ReactTemplate.get_arity(env[/* env */0], indf$1);
        var arsgn$1 = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], /* Anonymous */0), match$17[0]);
        var nar$1 = Curry._1(Util$ReactTemplate.List[/* length */0], arsgn$1);
        var indt$1 = Inductiveops$ReactTemplate.build_dependent_inductive(env[/* env */0], indf$1);
        var psign_000$1 = /* LocalAssum */Block.__(0, [
            na$1,
            indt$1
          ]);
        var psign$2 = /* :: */[
          psign_000$1,
          arsgn$1
        ];
        var predlvar$1 = Cases$ReactTemplate.make_return_predicate_ltac_lvar(evdref[0], na$1, c$4, cj$1[/* uj_val */0], lvar);
        var psign$prime_000$1 = /* LocalAssum */Block.__(0, [
            Glob_ops$ReactTemplate.ltac_interp_name(predlvar$1, na$1),
            indt$1
          ]);
        var psign$prime$3 = /* :: */[
          psign$prime_000$1,
          arsgn$1
        ];
        var psign$prime$4 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
                return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
              }), psign$prime$3);
        var psign$prime$5 = Namegen$ReactTemplate.name_context(env[/* env */0], evdref[0], psign$prime$4);
        var psign$3 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
                return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
              }), psign$2);
        var match$18;
        if (po$1) {
          var env_p$1 = push_rel_context(evdref[0], psign$3, env);
          var pj$1 = pretype_type$1(Evardefine$ReactTemplate.empty_valcon, env_p$1, evdref, predlvar$1, po$1[0]);
          var ccl$3 = Evarutil$ReactTemplate.nf_evar(evdref[0], pj$1[/* utj_val */0]);
          var pred = EConstr$ReactTemplate.it_mkLambda_or_LetIn(ccl$3, psign$prime$5);
          var typ = EConstr$ReactTemplate.Vars[/* lift */0](-nar$1 | 0, Reductionops$ReactTemplate.beta_applist(evdref[0], /* tuple */[
                    pred,
                    /* :: */[
                      cj$1[/* uj_val */0],
                      /* [] */0
                    ]
                  ]));
          match$18 = /* tuple */[
            pred,
            typ
          ];
        } else {
          var p$4;
          if (tycon) {
            p$4 = tycon[0];
          } else {
            var env$2 = ltac_interp_name_env(k0, lvar, env, evdref[0]);
            p$4 = new_type_evar(env$2, evdref, loc);
          }
          match$18 = /* tuple */[
            EConstr$ReactTemplate.it_mkLambda_or_LetIn(EConstr$ReactTemplate.Vars[/* lift */0](nar$1 + 1 | 0, p$4), psign$prime$5),
            p$4
          ];
        }
        var pred$1 = Evarutil$ReactTemplate.nf_evar(evdref[0], match$18[0]);
        var p$5 = Evarutil$ReactTemplate.nf_evar(evdref[0], match$18[1]);
        var f$2 = function (cs, b) {
          var n = Curry._1(Context$ReactTemplate.Rel[/* length */3], cs[/* cs_args */3]);
          var pi = EConstr$ReactTemplate.Vars[/* lift */0](n, pred$1);
          var pi$1 = Reductionops$ReactTemplate.beta_applist(evdref[0], /* tuple */[
                pi,
                /* :: */[
                  EConstr$ReactTemplate.of_constr(Inductiveops$ReactTemplate.build_dependent_constructor(cs)),
                  /* [] */0
                ]
              ]);
          var cs_args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
                  return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
                }), cs[/* cs_args */3]);
          var cs_args$1;
          if (Flags$ReactTemplate.version_strictly_greater(/* V8_6 */0)) {
            var partial_arg = evdref[0];
            cs_args$1 = Curry._1(Context$ReactTemplate.Rel[/* map */7]((function (param) {
                        return Reductionops$ReactTemplate.whd_betaiota(partial_arg, param);
                      })), cs_args);
          } else {
            cs_args$1 = cs_args;
          }
          var csgn = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], /* Anonymous */0), cs_args$1);
          var env_c = push_rel_context(evdref[0], csgn, env);
          var bj = pretype$1(Evardefine$ReactTemplate.mk_tycon(pi$1), env_c, evdref, lvar, b);
          return EConstr$ReactTemplate.it_mkLambda_or_LetIn(bj[/* uj_val */0], cs_args$1);
        };
        var b1 = f$2(Caml_array.caml_array_get(cstrs$1, 0), match[2]);
        var b2 = f$2(Caml_array.caml_array_get(cstrs$1, 1), match[3]);
        var match$19 = Inductiveops$ReactTemplate.dest_ind_family(indf$1);
        var ind$3 = match$19[0];
        var ci = Inductiveops$ReactTemplate.make_case_info(env[/* env */0], ind$3[0], /* IfStyle */1);
        var pred$2 = Evarutil$ReactTemplate.nf_evar(evdref[0], pred$1);
        Typing$ReactTemplate.check_allowed_sort(env[/* env */0], evdref[0], ind$3, cj$1[/* uj_val */0], pred$2);
        var v$2 = EConstr$ReactTemplate.mkCase(/* tuple */[
              ci,
              pred$2,
              cj$1[/* uj_val */0],
              /* array */[
                b1,
                b2
              ]
            ]);
        var cj$2 = /* record */[
          /* uj_val */v$2,
          /* uj_type */p$5
        ];
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, cj$2, tycon);
    case 11 : 
        var lar = match[3];
        var fixkind = match[0];
        var partial_arg$8 = Context$ReactTemplate.Rel[/* empty */1];
        var ctxtv = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                var _env = env;
                var _ctxt = partial_arg$8;
                var _param = param;
                while(true) {
                  var param$1 = _param;
                  var ctxt = _ctxt;
                  var env$3 = _env;
                  if (param$1) {
                    var match = param$1[0];
                    var match$1 = match[2];
                    var na = match[0];
                    if (match$1) {
                      var ty$prime = pretype_type$1(Evardefine$ReactTemplate.empty_valcon, env$3, evdref, lvar, match[3]);
                      var bd$prime = pretype$1(Evardefine$ReactTemplate.mk_tycon(ty$prime[/* utj_val */0]), env$3, evdref, lvar, match$1[0]);
                      var dcl_001 = bd$prime[/* uj_val */0];
                      var dcl_002 = ty$prime[/* utj_val */0];
                      var dcl = /* LocalDef */Block.__(1, [
                          na,
                          dcl_001,
                          dcl_002
                        ]);
                      var dcl$prime_000 = Glob_ops$ReactTemplate.ltac_interp_name(lvar, na);
                      var dcl$prime_001 = bd$prime[/* uj_val */0];
                      var dcl$prime_002 = ty$prime[/* utj_val */0];
                      var dcl$prime = /* LocalDef */Block.__(1, [
                          dcl$prime_000,
                          dcl$prime_001,
                          dcl$prime_002
                        ]);
                      _param = param$1[1];
                      _ctxt = Context$ReactTemplate.Rel[/* add */2](dcl$prime, ctxt);
                      _env = push_rel(evdref[0], dcl, env$3);
                      continue ;
                      
                    } else {
                      var ty$prime$1 = pretype_type$1(Evardefine$ReactTemplate.empty_valcon, env$3, evdref, lvar, match[3]);
                      var dcl_001$1 = ty$prime$1[/* utj_val */0];
                      var dcl$1 = /* LocalAssum */Block.__(0, [
                          na,
                          dcl_001$1
                        ]);
                      var dcl$prime_000$1 = Glob_ops$ReactTemplate.ltac_interp_name(lvar, na);
                      var dcl$prime_001$1 = ty$prime$1[/* utj_val */0];
                      var dcl$prime$1 = /* LocalAssum */Block.__(0, [
                          dcl$prime_000$1,
                          dcl$prime_001$1
                        ]);
                      _param = param$1[1];
                      _ctxt = Context$ReactTemplate.Rel[/* add */2](dcl$prime$1, ctxt);
                      _env = push_rel(evdref[0], dcl$1, env$3);
                      continue ;
                      
                    }
                  } else {
                    return ctxt;
                  }
                };
              }), match[2]);
        var larj = Util$ReactTemplate.$$Array[/* map2 */49]((function (e, ar) {
                return pretype_type$1(Evardefine$ReactTemplate.empty_valcon, push_rel_context(evdref[0], e, env), evdref, lvar, ar);
              }), ctxtv, lar);
        var lara = Util$ReactTemplate.$$Array[/* map */12]((function (a) {
                return a[/* utj_val */0];
              }), larj);
        var ftys = Util$ReactTemplate.$$Array[/* map2 */49]((function (e, a) {
                return EConstr$ReactTemplate.it_mkProd_or_LetIn(a, e);
              }), ctxtv, lara);
        var nbfix = lar.length;
        var names = Util$ReactTemplate.$$Array[/* map */12]((function (id) {
                return /* Name */[id];
              }), match[1]);
        if (tycon) {
          var fixi;
          fixi = fixkind.tag ? fixkind[0] : fixkind[0][1];
          Evarconv$ReactTemplate.e_conv(env[/* env */0], /* None */0, evdref, Caml_array.caml_array_get(ftys, fixi), tycon[0]);
        }
        var newenv = push_rec_types(evdref[0], /* tuple */[
              names,
              ftys,
              /* array */[]
            ], env);
        var vdefj = Util$ReactTemplate.$$Array[/* map2_i */50]((function (i, ctxt, def) {
                var match = EConstr$ReactTemplate.decompose_prod_n_assum(evdref[0], Curry._1(Context$ReactTemplate.Rel[/* length */3], ctxt), EConstr$ReactTemplate.Vars[/* lift */0](nbfix, Caml_array.caml_array_get(ftys, i)));
                var ctxt$1 = match[0];
                var nenv = push_rel_context(evdref[0], ctxt$1, newenv);
                var j = pretype$1(Evardefine$ReactTemplate.mk_tycon(match[1]), nenv, evdref, lvar, def);
                return /* record */[
                        /* uj_val */EConstr$ReactTemplate.it_mkLambda_or_LetIn(j[/* uj_val */0], ctxt$1),
                        /* uj_type */EConstr$ReactTemplate.it_mkProd_or_LetIn(j[/* uj_type */1], ctxt$1)
                      ];
              }), ctxtv, match[4]);
        Typing$ReactTemplate.check_type_fixpoint(loc, env[/* env */0], evdref, names, ftys, vdefj);
        var nf = function (c) {
          return Evarutil$ReactTemplate.nf_evar(evdref[0], c);
        };
        var ftys$1 = Util$ReactTemplate.$$Array[/* map */12](nf, ftys);
        var fdefs = Util$ReactTemplate.$$Array[/* map */12]((function (x) {
                var c = Environ$ReactTemplate.j_val(x);
                return Evarutil$ReactTemplate.nf_evar(evdref[0], c);
              }), vdefj);
        var fixj;
        if (fixkind.tag) {
          var i = fixkind[0];
          var fixdecls = /* tuple */[
            names,
            ftys$1,
            fdefs
          ];
          var cofix = /* tuple */[
            i,
            fixdecls
          ];
          try {
            Inductive$ReactTemplate.check_cofix(env[/* env */0], /* tuple */[
                  i,
                  nf_fix(evdref[0], fixdecls)
                ]);
          }
          catch (raw_reraise){
            var reraise = Js_exn.internalToOCamlException(raw_reraise);
            var match$20 = CErrors$ReactTemplate.push(reraise);
            var info$2 = match$20[1];
            var info$3 = Option$ReactTemplate.cata((function (param) {
                    return Loc$ReactTemplate.add_loc(info$2, param);
                  }), info$2, loc);
            Util$ReactTemplate.iraise(/* tuple */[
                  match$20[0],
                  info$3
                ]);
          }
          fixj = Environ$ReactTemplate.make_judge(EConstr$ReactTemplate.mkCoFix(cofix), Caml_array.caml_array_get(ftys$1, i));
        } else {
          var match$21 = fixkind[0];
          var i$1 = match$21[1];
          var possible_indexes = Util$ReactTemplate.$$Array[/* to_list */9](Util$ReactTemplate.$$Array[/* mapi */14]((function (i, param) {
                      var n = param[0];
                      if (n) {
                        return /* :: */[
                                n[0],
                                /* [] */0
                              ];
                      } else {
                        return Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, _) {
                                      return i;
                                    }), 0, Caml_array.caml_array_get(ctxtv, i));
                      }
                    }), match$21[0]));
          var fixdecls$1 = /* tuple */[
            names,
            ftys$1,
            fdefs
          ];
          var indexes = search_guard(loc, env[/* env */0], possible_indexes, nf_fix(evdref[0], fixdecls$1));
          fixj = Environ$ReactTemplate.make_judge(EConstr$ReactTemplate.mkFix(/* tuple */[
                    /* tuple */[
                      indexes,
                      i$1
                    ],
                    fixdecls$1
                  ]), Caml_array.caml_array_get(ftys$1, i$1));
        }
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, fixj, tycon);
    case 12 : 
        var j$5 = pretype_sort(loc, evdref, match[0]);
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, j$5, tycon);
    case 13 : 
        var match$22 = match[2];
        if (match$22) {
          var arg = match$22[0];
          var env$3 = ltac_interp_name_env(k0, lvar, env, evdref[0]);
          var ty$1 = tycon ? tycon[0] : new_type_evar(env$3, evdref, loc);
          var ist = lvar[/* ltac_genargs */3];
          var interp = Curry._1(ConstrInterp[/* obj */1], arg[0][0]);
          var match$23 = Curry._5(interp, ist, env$3[/* env */0], evdref[0], ty$1, arg[1]);
          evdref[0] = match$23[1];
          return /* record */[
                  /* uj_val */match$23[0],
                  /* uj_type */ty$1
                ];
        } else {
          var env$4 = ltac_interp_name_env(k0, lvar, env, evdref[0]);
          var ty$2 = tycon ? tycon[0] : new_type_evar(env$4, evdref, loc);
          return /* record */[
                  /* uj_val */e_new_evar(env$4, evdref, /* Some */[/* tuple */[
                          loc,
                          match[0]
                        ]], /* Some */[match[1]], ty$2),
                  /* uj_type */ty$2
                ];
        }
        break;
    case 14 : 
        var k$1 = match[1];
        var c$5 = match[0];
        var cj$3;
        if (typeof k$1 === "number") {
          var cj$4 = pretype$1(Evardefine$ReactTemplate.empty_tycon, env, evdref, lvar, c$5);
          var partial_arg$9 = env[/* env */0];
          cj$3 = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                  return Coercion$ReactTemplate.inh_coerce_to_base(loc, partial_arg$9, param, param$1);
                }), evdref, cj$4);
        } else {
          var k$2;
          k$2 = typeof k$1 === "number" || !k$1.tag ? /* DEFAULTcast */2 : /* VMcast */0;
          var tj = pretype_type$1(Evardefine$ReactTemplate.empty_valcon, env, evdref, lvar, k$1[0]);
          var partial_arg$10 = env[/* env */0];
          var partial_arg$11 = /* Some */[/* false */0];
          var partial_arg$12 = /* Some */[/* true */1];
          var partial_arg$13 = /* Some */[Evd$ReactTemplate.univ_flexible];
          var tval = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                  return Evarsolve$ReactTemplate.refresh_universes(partial_arg$13, partial_arg$12, /* None */0, partial_arg$11, partial_arg$10, param, param$1);
                }), evdref, tj[/* utj_val */0]);
          var tval$1 = Evarutil$ReactTemplate.nf_evar(evdref[0], tval);
          var match$24;
          if (k$2 !== 0) {
            match$24 = /* tuple */[
              pretype$1(Evardefine$ReactTemplate.mk_tycon(tval$1), env, evdref, lvar, c$5),
              tval$1
            ];
          } else {
            var cj$5 = pretype$1(Evardefine$ReactTemplate.empty_tycon, env, evdref, lvar, c$5);
            var cty = Evarutil$ReactTemplate.nf_evar(evdref[0], cj$5[/* uj_type */1]);
            var tval$2 = Evarutil$ReactTemplate.nf_evar(evdref[0], tval$1);
            if (Termops$ReactTemplate.occur_existential(evdref[0], cty) || Termops$ReactTemplate.occur_existential(evdref[0], tval$2)) {
              match$24 = CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot check cast with vm: "), Pp$ReactTemplate.str("unresolved arguments remain.")));
            } else {
              var match$25 = Curry._1(Reductionops$ReactTemplate.vm_infer_conv(/* None */0, env[/* env */0], evdref[0], cty), tval$2);
              if (match$25[1]) {
                evdref[0] = match$25[0];
                match$24 = /* tuple */[
                  cj$5,
                  tval$2
                ];
              } else {
                match$24 = Pretype_errors$ReactTemplate.error_actual_type(loc, env[/* env */0], evdref[0], cj$5, tval$2, /* ConversionFailed */Block.__(2, [
                        env[/* env */0],
                        cty,
                        tval$2
                      ]));
              }
            }
          }
          var tval$3 = match$24[1];
          var v$3 = EConstr$ReactTemplate.mkCast(/* tuple */[
                match$24[0][/* uj_val */0],
                k$2,
                tval$3
              ]);
          cj$3 = /* record */[
            /* uj_val */v$3,
            /* uj_type */tval$3
          ];
        }
        return inh_conv_coerce_to_tycon(loc, resolve_tc, env, evdref, cj$3, tycon);
    case 15 : 
        var cj$6 = pretype$1(Evardefine$ReactTemplate.empty_tycon, env, evdref, lvar, match[1]);
        return Typing$ReactTemplate.judge_of_projection(env[/* env */0], evdref[0], match[0], cj$6);
    
  }
}

function pretype_instance(k0, resolve_tc, env, evdref, lvar, loc, hyps, evk, update) {
  var f = function (decl, param) {
    var update = param[1];
    var subst = param[0];
    var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl);
    var t = EConstr$ReactTemplate.Vars[/* replace_vars */8](subst, EConstr$ReactTemplate.of_constr(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl)));
    var match;
    try {
      var c = Curry._2(Util$ReactTemplate.List[/* assoc */30], id, update);
      var c$1 = pretype(k0, resolve_tc, Evardefine$ReactTemplate.mk_tycon(t), env, evdref, lvar, c);
      match = /* tuple */[
        c$1[/* uj_val */0],
        Curry._2(Util$ReactTemplate.List[/* remove_assoc */34], id, update)
      ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        try {
          var match$1 = Termops$ReactTemplate.lookup_rel_id(id, EConstr$ReactTemplate.rel_context(env[/* env */0]));
          if (Reductionops$ReactTemplate.is_conv(/* None */0, env[/* env */0], evdref[0])(t, match$1[2])) {
            match = /* tuple */[
              EConstr$ReactTemplate.mkRel(match$1[0]),
              update
            ];
          } else {
            throw Caml_builtin_exceptions.not_found;
          }
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            try {
              var t$prime = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], EConstr$ReactTemplate.lookup_named(id, env[/* env */0]));
              if (Reductionops$ReactTemplate.is_conv(/* None */0, env[/* env */0], evdref[0])(t, t$prime)) {
                match = /* tuple */[
                  EConstr$ReactTemplate.mkVar(id),
                  update
                ];
              } else {
                throw Caml_builtin_exceptions.not_found;
              }
            }
            catch (exn$2){
              if (exn$2 === Caml_builtin_exceptions.not_found) {
                match = CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot interpret "), Termops$ReactTemplate.pr_existential_key(evdref[0], evk)), Pp$ReactTemplate.str(" in current context: no binding for ")), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(".")));
              } else {
                throw exn$2;
              }
            }
          } else {
            throw exn$1;
          }
        }
      } else {
        throw exn;
      }
    }
    return /* tuple */[
            /* :: */[
              /* tuple */[
                id,
                match[0]
              ],
              subst
            ],
            match[1]
          ];
  };
  var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], f, hyps, /* tuple */[
        /* [] */0,
        update
      ]);
  var subst = match[0];
  check_instance(loc, subst, match[1]);
  return Util$ReactTemplate.$$Array[/* map_of_list */45]((function (prim) {
                return prim[1];
              }), subst);
}

function pretype_type(k0, resolve_tc, valcon, env, evdref, lvar, c) {
  var match = DAst$ReactTemplate.get(c);
  var exit = 0;
  if (match.tag === 13) {
    if (match[2]) {
      exit = 1;
    } else {
      var naming = match[1];
      var knd = match[0];
      var loc = Glob_ops$ReactTemplate.loc_of_glob_constr(c);
      if (valcon) {
        var v = valcon[0];
        var sigma = evdref[0];
        var t = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env[/* env */0], sigma, v);
        var match$1 = EConstr$ReactTemplate.kind(sigma, Reductionops$ReactTemplate.whd_all(env[/* env */0])(sigma, t));
        var s;
        switch (match$1.tag | 0) {
          case 3 : 
              var ev = match$1[0];
              if (Termops$ReactTemplate.is_Type(sigma, EConstr$ReactTemplate.existential_type(sigma, ev))) {
                var partial_arg = env[/* env */0];
                s = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                        return Evardefine$ReactTemplate.define_evar_as_sort(partial_arg, param, param$1);
                      }), evdref, ev);
              } else {
                s = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Found a type constraint which is not a type."));
              }
              break;
          case 4 : 
              s = EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match$1[0]);
              break;
          default:
            s = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Found a type constraint which is not a type."));
        }
        var evkt = e_new_evar(env, evdref, /* Some */[/* tuple */[
                loc,
                knd
              ]], /* Some */[naming], EConstr$ReactTemplate.mkSort(s));
        var match$2 = EConstr$ReactTemplate.destEvar(evdref[0], evkt);
        evdref[0] = Evd$ReactTemplate.define(match$2[0], EConstr$ReactTemplate.to_constr(evdref[0], v), evdref[0]);
        return /* record */[
                /* utj_val */v,
                /* utj_type */s
              ];
      } else {
        var env$1 = ltac_interp_name_env(k0, lvar, env, evdref[0]);
        var s$1 = Evarutil$ReactTemplate.evd_comb0((function (param) {
                return Evd$ReactTemplate.new_sort_variable(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg, param);
              }), evdref);
        return /* record */[
                /* utj_val */e_new_evar(env$1, evdref, /* Some */[/* tuple */[
                        loc,
                        knd
                      ]], /* Some */[naming], EConstr$ReactTemplate.mkSort(s$1)),
                /* utj_type */s$1
              ];
      }
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var j = pretype(k0, resolve_tc, Evardefine$ReactTemplate.empty_tycon, env, evdref, lvar, c);
    var loc$1 = Glob_ops$ReactTemplate.loc_of_glob_constr(c);
    var partial_arg$1 = env[/* env */0];
    var tj = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
            return Coercion$ReactTemplate.inh_coerce_to_sort(loc$1, partial_arg$1, param, param$1);
          }), evdref, j);
    if (valcon) {
      var v$1 = valcon[0];
      if (Evarconv$ReactTemplate.e_cumul(env[/* env */0], /* None */0, evdref, v$1, tj[/* utj_val */0])) {
        return tj;
      } else {
        return Pretype_errors$ReactTemplate.error_unexpected_type(Glob_ops$ReactTemplate.loc_of_glob_constr(c), env[/* env */0], evdref[0], tj[/* utj_val */0], v$1);
      }
    } else {
      return tj;
    }
  }
  
}

function ise_pretype_gen(flags, env, sigma, lvar, kind, c) {
  var env$1 = make_env(env, sigma);
  var evdref = [sigma];
  var k0 = Curry._1(Context$ReactTemplate.Rel[/* length */3], EConstr$ReactTemplate.rel_context(env$1[/* env */0]));
  var match;
  if (typeof kind === "number") {
    if (kind !== 0) {
      var j = pretype(k0, flags[/* use_typeclasses */0], Evardefine$ReactTemplate.empty_tycon, env$1, evdref, lvar, c);
      match = /* tuple */[
        j[/* uj_val */0],
        j[/* uj_type */1]
      ];
    } else {
      var tj = pretype_type(k0, flags[/* use_typeclasses */0], Evardefine$ReactTemplate.empty_valcon, env$1, evdref, lvar, c);
      match = /* tuple */[
        tj[/* utj_val */0],
        EConstr$ReactTemplate.mkSort(tj[/* utj_type */1])
      ];
    }
  } else {
    var j$1 = pretype(k0, flags[/* use_typeclasses */0], Evardefine$ReactTemplate.mk_tycon(kind[0]), env$1, evdref, lvar, c);
    match = /* tuple */[
      j$1[/* uj_val */0],
      j$1[/* uj_type */1]
    ];
  }
  var flags$1 = flags;
  var env$2 = env$1[/* env */0];
  var initial_sigma = sigma;
  var param = /* tuple */[
    evdref[0],
    match[0],
    match[1]
  ];
  var c$1 = param[1];
  var sigma$1 = solve_remaining_evars(flags$1, env$2, param[0], initial_sigma);
  var c$2 = flags$1[/* expand_evars */4] ? Evarutil$ReactTemplate.nf_evar(sigma$1, c$1) : c$1;
  return /* tuple */[
          sigma$1,
          c$2,
          param[2]
        ];
}

function default_inference_flags(fail) {
  return /* record */[
          /* use_typeclasses : true */1,
          /* solve_unification_constraints : true */1,
          /* use_hook : None */0,
          /* fail_evar */fail,
          /* expand_evars : true */1
        ];
}

var all_and_fail_flags = /* record */[
  /* use_typeclasses : true */1,
  /* solve_unification_constraints : true */1,
  /* use_hook : None */0,
  /* fail_evar : true */1,
  /* expand_evars : true */1
];

var all_no_fail_flags = /* record */[
  /* use_typeclasses : true */1,
  /* solve_unification_constraints : true */1,
  /* use_hook : None */0,
  /* fail_evar : false */0,
  /* expand_evars : true */1
];

function understand($staropt$star, $staropt$star$1, env, sigma, c) {
  var flags = $staropt$star ? $staropt$star[0] : all_and_fail_flags;
  var expected_type = $staropt$star$1 ? $staropt$star$1[0] : /* WithoutTypeConstraint */1;
  var flags$1 = flags;
  var env$1 = env;
  var sigma$1 = sigma;
  var lvar = Glob_ops$ReactTemplate.empty_lvar;
  var kind = expected_type;
  var c$1 = c;
  var match = ise_pretype_gen(flags$1, env$1, sigma$1, lvar, kind, c$1);
  return /* tuple */[
          match[1],
          Evd$ReactTemplate.evar_universe_context(match[0])
        ];
}

function understand_tcc_ty($staropt$star, env, sigma, $staropt$star$1, c) {
  var flags = $staropt$star ? $staropt$star[0] : all_no_fail_flags;
  var expected_type = $staropt$star$1 ? $staropt$star$1[0] : /* WithoutTypeConstraint */1;
  return ise_pretype_gen(flags, env, sigma, Glob_ops$ReactTemplate.empty_lvar, expected_type, c);
}

function understand_tcc(flags, env, sigma, expected_type, c) {
  var match = understand_tcc_ty(flags, env, sigma, expected_type, c);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function understand_ltac(flags, env, sigma, lvar, kind, c) {
  var match = ise_pretype_gen(flags, env, sigma, lvar, kind, c);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function pretype$1(k0, resolve_tc, typcon, env, evdref, lvar, t) {
  return pretype(k0, resolve_tc, typcon, make_env(env, evdref[0]), evdref, lvar, t);
}

function pretype_type$1(k0, resolve_tc, valcon, env, evdref, lvar, t) {
  return pretype_type(k0, resolve_tc, valcon, make_env(env, evdref[0]), evdref, lvar, t);
}

var no_classes_no_fail_inference_flags = /* record */[
  /* use_typeclasses : false */0,
  /* solve_unification_constraints : true */1,
  /* use_hook : None */0,
  /* fail_evar : false */0,
  /* expand_evars : true */1
];

exports.interp_known_glob_level = interp_known_glob_level;
exports.search_guard = search_guard;
exports.default_inference_flags = default_inference_flags;
exports.no_classes_no_fail_inference_flags = no_classes_no_fail_inference_flags;
exports.all_no_fail_flags = all_no_fail_flags;
exports.all_and_fail_flags = all_and_fail_flags;
exports.understand_tcc = understand_tcc;
exports.understand_tcc_ty = understand_tcc_ty;
exports.understand_ltac = understand_ltac;
exports.understand = understand;
exports.solve_remaining_evars = solve_remaining_evars;
exports.check_evars_are_solved = check_evars_are_solved$1;
exports.check_evars = check_evars;
exports.pretype = pretype$1;
exports.pretype_type = pretype_type$1;
exports.ise_pretype_gen = ise_pretype_gen;
exports.register_constr_interp0 = register_constr_interp0;
/*  Not a pure module */
