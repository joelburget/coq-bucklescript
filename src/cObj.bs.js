// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Obj = require("bs-platform/lib/js/obj.js");
var Sys = require("bs-platform/lib/js/sys.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_gc = require("bs-platform/lib/js/caml_gc.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var c = [0];

var s = [0];

var b = [0];

var m = [0];

function obj_stats(d, t) {
  if (typeof t === "number") {
    m[0] = Caml_primitive.caml_int_max(d, m[0]);
    return /* () */0;
  } else if ((t.tag | 0) >= Obj.no_scan_tag) {
    if ((t.tag | 0) === Obj.string_tag) {
      c[0] = c[0] + t.length | 0;
      b[0] = b[0] + 1 | 0;
      m[0] = Caml_primitive.caml_int_max(d, m[0]);
      return /* () */0;
    } else if ((t.tag | 0) === Obj.double_tag) {
      s[0] = s[0] + 2 | 0;
      b[0] = b[0] + 1 | 0;
      m[0] = Caml_primitive.caml_int_max(d, m[0]);
      return /* () */0;
    } else if ((t.tag | 0) === Obj.double_array_tag) {
      s[0] = s[0] + (t.length << 1) | 0;
      b[0] = b[0] + 1 | 0;
      m[0] = Caml_primitive.caml_int_max(d, m[0]);
      return /* () */0;
    } else {
      b[0] = b[0] + 1 | 0;
      m[0] = Caml_primitive.caml_int_max(d, m[0]);
      return /* () */0;
    }
  } else {
    var n = t.length;
    s[0] = s[0] + n | 0;
    b[0] = b[0] + 1 | 0;
    var d$1 = d + 1 | 0;
    var _i = n - 1 | 0;
    var t$1 = t;
    while(true) {
      var i = _i;
      if (i >= 0) {
        obj_stats(d$1, t$1[i]);
        _i = i - 1 | 0;
        continue ;
        
      } else {
        return 0;
      }
    };
  }
}

function obj_stats$1(a) {
  c[0] = 0;
  s[0] = 0;
  b[0] = 0;
  m[0] = 0;
  obj_stats(0, a);
  return /* tuple */[
          c[0],
          s[0] + b[0] | 0,
          m[0]
        ];
}

function equal(prim, prim$1) {
  return +(prim === prim$1);
}

var H = Hashtbl.Make(/* module */[
      /* equal */equal,
      /* hash */Hashtbl.hash
    ]);

var node_table = Curry._1(H[/* create */0], 257);

function in_table(o) {
  try {
    Curry._2(H[/* find */6], node_table, o);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function add_in_table(o) {
  return Curry._3(H[/* add */4], node_table, o, /* () */0);
}

var size_of_double = (1.0).length;

var count = [0];

function traverse(t) {
  if (!in_table(t) && t.length !== undefined) {
    add_in_table(t);
    var n = t.length;
    var tag = t.tag | 0;
    if (tag < Obj.no_scan_tag) {
      count[0] = (count[0] + 1 | 0) + n | 0;
      for(var i = 0 ,i_finish = n - 1 | 0; i <= i_finish; ++i){
        traverse(t[i]);
      }
      return /* () */0;
    } else if (tag === Obj.string_tag) {
      count[0] = (count[0] + 1 | 0) + n | 0;
      return /* () */0;
    } else if (tag === Obj.double_tag) {
      count[0] = count[0] + size_of_double | 0;
      return /* () */0;
    } else if (tag === Obj.double_array_tag) {
      count[0] = (count[0] + 1 | 0) + Caml_int32.imul(size_of_double, n) | 0;
      return /* () */0;
    } else {
      count[0] = count[0] + 1 | 0;
      return /* () */0;
    }
  } else {
    return 0;
  }
}

function size(o) {
  Curry._1(H[/* clear */1], node_table);
  count[0] = 0;
  traverse(o);
  return count[0];
}

function size_b(o) {
  return Caml_int32.imul(size(o), Sys.word_size / 8 | 0);
}

function size_kb(o) {
  return Caml_int32.div(size(o), Caml_int32.div(8192, Sys.word_size));
}

var node_sizes = Curry._1(H[/* create */0], 257);

function add_size(o, n, pos) {
  return Curry._3(H[/* replace */8], node_sizes, o, /* tuple */[
              n,
              pos
            ]);
}

var global_object = [0];

function sum(n, f) {
  var _k = 0;
  var _acc = 0;
  while(true) {
    var acc = _acc;
    var k = _k;
    if (k >= n) {
      return acc;
    } else {
      _acc = acc + Curry._1(f, k) | 0;
      _k = k + 1 | 0;
      continue ;
      
    }
  };
}

function compute_size(o, pos) {
  if (o.length === undefined) {
    return 0;
  } else {
    try {
      Curry._2(H[/* find */6], node_sizes, o);
      return 0;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var n = o.length;
        add_size(o, -1, pos);
        var tag = o.tag | 0;
        var size = tag < Obj.no_scan_tag ? (1 + n | 0) + sum(n, (function (i) {
                  return compute_size(o[i], /* :: */[
                              i,
                              pos
                            ]);
                })) | 0 : (
            tag === Obj.string_tag ? 1 + n | 0 : (
                tag === Obj.double_tag ? size_of_double : (
                    tag === Obj.double_array_tag ? Caml_int32.imul(size_of_double, n) : 1
                  )
              )
          );
        add_size(o, size, pos);
        return size;
      } else {
        throw exn;
      }
    }
  }
}

function register_shared_size(t) {
  Curry._1(H[/* clear */1], node_sizes);
  global_object[0] = t;
  compute_size(t, /* [] */0);
  return /* () */0;
}

function shared_size(pos, o) {
  if (o.length === undefined) {
    return 0;
  } else {
    var match;
    try {
      match = Curry._2(H[/* find */6], node_sizes, o);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        match = Pervasives.failwith("shared_size: unregistered structure ?");
      } else {
        throw exn;
      }
    }
    var size = match[0];
    if (pos && Caml_obj.caml_notequal(pos[0], match[1])) {
      return 0;
    } else {
      return size;
    }
  }
}

function shared_size_of_obj(t) {
  return shared_size(/* None */0, t);
}

function shared_size_of_pos(pos) {
  var obj_of_pos = function (o, param) {
    if (param) {
      var n = param[0];
      var o$prime = obj_of_pos(o, param[1]);
      if (!(o$prime.length !== undefined && n < o$prime.length)) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cObj.ml",
                191,
                6
              ]
            ];
      }
      return o$prime[n];
    } else {
      return o;
    }
  };
  return shared_size(/* Some */[pos], obj_of_pos(global_object[0], pos));
}

function heap_size() {
  var stat = Caml_gc.caml_gc_stat(/* () */0);
  var control = Caml_gc.caml_gc_get(/* () */0);
  var max_words_total = stat[/* heap_words */5] + control[/* minor_heap_size */0] | 0;
  return Caml_int32.imul(max_words_total, Sys.word_size / 8 | 0);
}

function heap_size_kb() {
  return (heap_size(/* () */0) + 1023 | 0) / 1024 | 0;
}

exports.size = size;
exports.size_b = size_b;
exports.size_kb = size_kb;
exports.register_shared_size = register_shared_size;
exports.shared_size_of_obj = shared_size_of_obj;
exports.shared_size_of_pos = shared_size_of_pos;
exports.obj_stats = obj_stats$1;
exports.heap_size = heap_size;
exports.heap_size_kb = heap_size_kb;
/* H Not a pure module */
