// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var Bad_tokenize = Caml_exceptions.create("Sexp-ReactTemplate.Bad_tokenize");

var Unexpected_end = Caml_exceptions.create("Sexp-ReactTemplate.Unexpected_end");

var Tokens_remaining = Caml_exceptions.create("Sexp-ReactTemplate.Tokens_remaining");

var CoqExn = Caml_exceptions.create("Sexp-ReactTemplate.CoqExn");

function tokenize(input) {
  var range_start = [0];
  var range_end = [0];
  var tokens = [/* [] */0];
  var in_string = [/* false */0];
  var delimiter_reached = function (delimiter_token) {
    if (in_string[0]) {
      range_end[0] = range_end[0] + 1 | 0;
      return /* () */0;
    } else {
      if (range_end[0] > range_start[0]) {
        var text = $$String.sub(input, range_start[0], range_end[0] - range_start[0] | 0);
        tokens[0] = /* :: */[
          /* SymbolToken */Block.__(0, [text]),
          tokens[0]
        ];
      }
      if (delimiter_token) {
        tokens[0] = /* :: */[
          delimiter_token[0],
          tokens[0]
        ];
      }
      range_start[0] = range_end[0] + 1 | 0;
      range_end[0] = range_end[0] + 1 | 0;
      return /* () */0;
    }
  };
  var quote_reached = function () {
    if (in_string[0]) {
      var text = $$String.sub(input, range_start[0], range_end[0] - range_start[0] | 0);
      tokens[0] = /* :: */[
        /* StringToken */Block.__(1, [text]),
        tokens[0]
      ];
    }
    range_start[0] = range_end[0] + 1 | 0;
    range_end[0] = range_end[0] + 1 | 0;
    in_string[0] = 1 - in_string[0];
    return /* () */0;
  };
  var input_length = input.length;
  while(range_end[0] < input_length) {
    var current_char = Caml_string.get(input, range_end[0]);
    var exit = 0;
    if (current_char >= 42) {
      if (current_char !== 92) {
        exit = 1;
      } else {
        range_end[0] = range_end[0] + 2 | 0;
      }
    } else if (current_char >= 9) {
      switch (current_char - 9 | 0) {
        case 0 : 
        case 1 : 
        case 4 : 
        case 23 : 
            delimiter_reached(/* None */0);
            break;
        case 25 : 
            quote_reached(/* () */0);
            break;
        case 2 : 
        case 3 : 
        case 5 : 
        case 6 : 
        case 7 : 
        case 8 : 
        case 9 : 
        case 10 : 
        case 11 : 
        case 12 : 
        case 13 : 
        case 14 : 
        case 15 : 
        case 16 : 
        case 17 : 
        case 18 : 
        case 19 : 
        case 20 : 
        case 21 : 
        case 22 : 
        case 24 : 
        case 26 : 
        case 27 : 
        case 28 : 
        case 29 : 
            exit = 1;
            break;
        case 30 : 
            throw Bad_tokenize;
        case 31 : 
            delimiter_reached(/* Some */[/* LParenToken */0]);
            break;
        case 32 : 
            delimiter_reached(/* Some */[/* RParenToken */1]);
            break;
        
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      range_end[0] = range_end[0] + 1 | 0;
    }
    
  };
  return List.rev(tokens[0]);
}

function sexp_from_tokens(remaining_tokens) {
  var match = remaining_tokens[0];
  if (match) {
    var match$1 = match[0];
    if (typeof match$1 === "number") {
      if (match$1) {
        throw Unexpected_end;
      } else {
        remaining_tokens[0] = match[1];
        return sexp_list_from_tokens(remaining_tokens, /* [] */0);
      }
    } else if (match$1.tag) {
      remaining_tokens[0] = match[1];
      return /* String */Block.__(3, [match$1[0]]);
    } else {
      var text = match$1[0];
      remaining_tokens[0] = match[1];
      if (isNaN(Number(text))) {
        return /* Symbol */Block.__(1, [text]);
      } else {
        return /* Number */Block.__(0, [Caml_format.caml_int_of_string(text)]);
      }
    }
  } else {
    throw Unexpected_end;
  }
}

function sexp_list_from_tokens(remaining_tokens, _values_list) {
  while(true) {
    var values_list = _values_list;
    var match = remaining_tokens[0];
    var exit = 0;
    if (match) {
      var match$1 = match[0];
      if (typeof match$1 === "number") {
        if (match$1 !== 0) {
          remaining_tokens[0] = match[1];
          return /* List */Block.__(2, [List.rev(values_list)]);
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      throw Unexpected_end;
    }
    if (exit === 1) {
      var value = sexp_from_tokens(remaining_tokens);
      _values_list = /* :: */[
        value,
        values_list
      ];
      continue ;
      
    }
    
  };
}

function parse(program) {
  var tokens = [tokenize(program)];
  var value = sexp_from_tokens(tokens);
  if (tokens[0] !== /* [] */0) {
    throw [
          Tokens_remaining,
          tokens[0]
        ];
  }
  return value;
}

exports.Bad_tokenize = Bad_tokenize;
exports.Unexpected_end = Unexpected_end;
exports.Tokens_remaining = Tokens_remaining;
exports.CoqExn = CoqExn;
exports.tokenize = tokenize;
exports.sexp_from_tokens = sexp_from_tokens;
exports.sexp_list_from_tokens = sexp_list_from_tokens;
exports.parse = parse;
/* No side effect */
