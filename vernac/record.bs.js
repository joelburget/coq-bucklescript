// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Loc$ReactTemplate = require("../src/loc.bs.js");
var CAst$ReactTemplate = require("../src/cAst.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Vars$ReactTemplate = require("../src/vars.bs.js");
var Class$ReactTemplate = require("./class.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Sorts$ReactTemplate = require("../src/sorts.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Future$ReactTemplate = require("../src/future.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var States$ReactTemplate = require("../src/states.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Classes$ReactTemplate = require("./classes.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var Declare$ReactTemplate = require("../src/declare.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Impargs$ReactTemplate = require("../src/impargs.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Printer$ReactTemplate = require("../src/printer.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Unicode$ReactTemplate = require("../src/unicode.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Retyping$ReactTemplate = require("../src/retyping.bs.js");
var CWarnings$ReactTemplate = require("../src/cWarnings.bs.js");
var Globnames$ReactTemplate = require("../src/globnames.bs.js");
var Inductive$ReactTemplate = require("../src/inductive.bs.js");
var Pretyping$ReactTemplate = require("../src/pretyping.bs.js");
var Recordops$ReactTemplate = require("../src/recordops.bs.js");
var Univdecls$ReactTemplate = require("../src/univdecls.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Declareops$ReactTemplate = require("../src/declareops.bs.js");
var Metasyntax$ReactTemplate = require("./metasyntax.bs.js");
var Safe_typing$ReactTemplate = require("../src/safe_typing.bs.js");
var Type_errors$ReactTemplate = require("../src/type_errors.bs.js");
var Typeclasses$ReactTemplate = require("../src/typeclasses.bs.js");
var ComInductive$ReactTemplate = require("./comInductive.bs.js");
var Constrintern$ReactTemplate = require("../src/constrintern.bs.js");
var Inductiveops$ReactTemplate = require("../src/inductiveops.bs.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");
var Constrexpr_ops$ReactTemplate = require("../src/constrexpr_ops.bs.js");
var InferCumulativity$ReactTemplate = require("../src/inferCumulativity.bs.js");

var primitive_flag = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"use of primitive projections",
      /* optkey : :: */[
        "Primitive",
        /* :: */[
          "Projections",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return primitive_flag[0];
        }),
      /* optwrite */(function (b) {
          primitive_flag[0] = b;
          return /* () */0;
        })
    ]);

var typeclasses_strict = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"strict typeclass resolution",
      /* optkey : :: */[
        "Typeclasses",
        /* :: */[
          "Strict",
          /* :: */[
            "Resolution",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return typeclasses_strict[0];
        }),
      /* optwrite */(function (b) {
          typeclasses_strict[0] = b;
          return /* () */0;
        })
    ]);

var typeclasses_unique = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"unique typeclass instances",
      /* optkey : :: */[
        "Typeclasses",
        /* :: */[
          "Unique",
          /* :: */[
            "Instances",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return typeclasses_unique[0];
        }),
      /* optwrite */(function (b) {
          typeclasses_unique[0] = b;
          return /* () */0;
        })
    ]);

function interp_fields_evars(env, sigma, impls_env, nots, l) {
  return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, no, param$1) {
                var i = param$1[0][/* v */0];
                var impls = param[4];
                var env = param[0];
                var match = Constrintern$ReactTemplate.interp_type_evars_impls(env, param[1], /* Some */[impls], param$1[2]);
                var match$1 = match[1];
                var impl = match$1[1];
                var t$prime = match$1[0];
                var sigma = match[0];
                var match$2 = Option$ReactTemplate.cata((function (x) {
                        return Util$ReactTemplate.on_snd((function (x) {
                                      return /* Some */[x[0]];
                                    }), Constrintern$ReactTemplate.interp_casted_constr_evars_impls(env, sigma, /* Some */[impls], x, t$prime));
                      }), /* tuple */[
                      sigma,
                      /* None */0
                    ], param$1[1]);
                var b$prime = match$2[1];
                var sigma$1 = match$2[0];
                var impls$1 = i ? Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], i[0], Constrintern$ReactTemplate.compute_internalization_data(env, sigma$1, /* Method */1, t$prime, impl), impls) : impls;
                var d = b$prime ? /* LocalDef */Block.__(1, [
                      i,
                      b$prime[0],
                      t$prime
                    ]) : /* LocalAssum */Block.__(0, [
                      i,
                      t$prime
                    ]);
                Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                        return Metasyntax$ReactTemplate.set_notation_for_interpretation(env, impls$1, param);
                      }), no);
                return /* tuple */[
                        EConstr$ReactTemplate.push_rel(d, env),
                        sigma$1,
                        /* :: */[
                          impl,
                          param[2]
                        ],
                        /* :: */[
                          d,
                          param[3]
                        ],
                        impls$1
                      ];
              }), /* tuple */[
              env,
              sigma,
              /* [] */0,
              /* [] */0,
              impls_env
            ], nots, l);
}

function compute_constructor_level(evars, env, l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (d, param) {
                var univ = param[1];
                var env = param[0];
                var univ$1;
                if (Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], d)) {
                  var s = Retyping$ReactTemplate.get_sort_of(/* None */0, env, evars, Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], d));
                  univ$1 = Univ$ReactTemplate.sup(Sorts$ReactTemplate.univ_of_sort(s), univ);
                } else {
                  univ$1 = univ;
                }
                return /* tuple */[
                        EConstr$ReactTemplate.push_rel(d, env),
                        univ$1
                      ];
              }), l, /* tuple */[
              env,
              Univ$ReactTemplate.type0m_univ
            ]);
}

function binder_of_decl(param) {
  if (param.tag) {
    var t = param[2];
    var n = param[0];
    return /* tuple */[
            n,
            /* Some */[param[1]],
            t ? t[0] : CAst$ReactTemplate.make(n[/* loc */1], /* CHole */Block.__(12, [
                      /* None */0,
                      /* IntroAnonymous */0,
                      /* None */0
                    ]))
          ];
  } else {
    return /* tuple */[
            param[0],
            /* None */0,
            param[1]
          ];
  }
}

var binders_of_decls = Curry._1(Util$ReactTemplate.List[/* map */10], binder_of_decl);

function degenerate_decl(decl) {
  var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
  var id = match ? match[0] : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unnamed record variable."));
  if (decl.tag) {
    return /* tuple */[
            id,
            /* LocalDefEntry */Block.__(0, [decl[1]])
          ];
  } else {
    return /* tuple */[
            id,
            /* LocalAssumEntry */Block.__(1, [decl[1]])
          ];
  }
}

var warn_cannot_define_projection = CWarnings$ReactTemplate.create("cannot-define-projection", "records", /* None */0, (function (msg) {
        return Pp$ReactTemplate.hov(0, msg);
      }));

function warning_or_error(coe, indsp, err) {
  var st;
  if (err.tag) {
    var te = err[2];
    var fi = err[0];
    var exit = 0;
    if (te.tag === 5) {
      var match = te[4];
      if (match) {
        switch (match[0][2]) {
          case 0 : 
              st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](fi), Pp$ReactTemplate.strbrk(" cannot be defined because it is informative and ")), Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), indsp)), Pp$ReactTemplate.strbrk(" is not."));
              break;
          case 1 : 
              st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](fi), Pp$ReactTemplate.strbrk(" cannot be defined because it is large and ")), Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), indsp)), Pp$ReactTemplate.strbrk(" is not."));
              break;
          case 2 : 
              exit = 1;
              break;
          
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      st = Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](fi), Pp$ReactTemplate.strbrk(" cannot be defined because it is not typable."));
    }
    
  } else {
    var projs = err[1];
    var match$1 = Curry._1(Util$ReactTemplate.List[/* length */0], projs) > 1 ? /* tuple */[
        "s",
        "were"
      ] : /* tuple */[
        "",
        "was"
      ];
    st = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](err[0]), Pp$ReactTemplate.strbrk(" cannot be defined because the projection")), Pp$ReactTemplate.str(match$1[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Names$ReactTemplate.Id[/* print */8], projs)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(match$1[1])), Pp$ReactTemplate.strbrk(" not defined."));
  }
  if (coe) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["structure"], st);
  }
  return Curry._2(warn_cannot_define_projection, /* None */0, Pp$ReactTemplate.hov(0, st));
}

var NotDefinable = Caml_exceptions.create("Record-ReactTemplate.NotDefinable");

function subst_projection(fid, l, c) {
  var lv = Curry._1(Util$ReactTemplate.List[/* length */0], l);
  var bad_projs = [/* [] */0];
  var substrec = function (depth, c) {
    var match = Constr$ReactTemplate.kind(c);
    if (match.tag) {
      return Constr$ReactTemplate.map_with_binders((function (prim) {
                    return prim + 1 | 0;
                  }), substrec, depth, c);
    } else {
      var k = match[0];
      if (k <= (depth + 1 | 0)) {
        return c;
      } else if (((k - depth | 0) - 1 | 0) <= lv) {
        var match$1 = Curry._2(Util$ReactTemplate.List[/* nth */3], l, (k - depth | 0) - 2 | 0);
        if (match$1.tag) {
          return Vars$ReactTemplate.lift(depth)(match$1[0]);
        } else {
          var match$2 = match$1[0];
          if (match$2) {
            bad_projs[0] = /* :: */[
              match$2[0],
              bad_projs[0]
            ];
            return Constr$ReactTemplate.mkRel(k);
          } else {
            return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Field "), Names$ReactTemplate.Id[/* print */8](fid)), Pp$ReactTemplate.str(" depends on the ")), Pp$ReactTemplate.pr_nth((k - depth | 0) - 1 | 0)), Pp$ReactTemplate.str(" field which has no name.")));
          }
        }
      } else {
        return Constr$ReactTemplate.mkRel(k - lv | 0);
      }
    }
  };
  var c$prime = Vars$ReactTemplate.lift(1)(c);
  var c$prime$prime = substrec(0, c$prime);
  if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], bad_projs[0])) {
    throw [
          NotDefinable,
          /* MissingProj */Block.__(0, [
              fid,
              Curry._1(Util$ReactTemplate.List[/* rev */4], bad_projs[0])
            ])
        ];
  }
  return c$prime$prime;
}

function instantiate_possibly_recursive_type(indu, paramdecls, fields) {
  var subst = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, _) {
          return Constr$ReactTemplate.mkRel(i);
        }), 1, paramdecls);
  return Termops$ReactTemplate.substl_rel_context(Util$ReactTemplate.$at(subst, /* :: */[
                    Constr$ReactTemplate.mkIndU(indu),
                    /* [] */0
                  ]))(fields);
}

var warn_non_primitive_record = CWarnings$ReactTemplate.create("non-primitive-record", "record", /* None */0, (function (param) {
        return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The record "), Printer$ReactTemplate.pr_inductive(param[0], param[1])), Pp$ReactTemplate.strbrk(" could not be defined as a primitive record")));
      }));

function declare_projections(indsp, ctx, $staropt$star, binder_name, coers, ubinders, fieldimpls, fields) {
  var kind = $staropt$star ? $staropt$star[0] : /* StructureComponent */8;
  var env = Global$ReactTemplate.env(/* () */0);
  var match = Global$ReactTemplate.lookup_inductive(indsp);
  var mib = match[0];
  var poly = Declareops$ReactTemplate.inductive_is_polymorphic(mib);
  var u;
  u = ctx.tag ? Univ$ReactTemplate.UContext[/* instance */3](ctx[0]) : Univ$ReactTemplate.Instance[/* empty */0];
  var paramdecls = Inductive$ReactTemplate.inductive_paramdecls(/* tuple */[
        mib,
        u
      ]);
  var indu = /* tuple */[
    indsp,
    u
  ];
  var r = Constr$ReactTemplate.mkIndU(/* tuple */[
        indsp,
        u
      ]);
  var rp = Term$ReactTemplate.applist(/* tuple */[
        r,
        Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, paramdecls)
      ]);
  var paramargs = Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 1, paramdecls);
  var x = /* Name */[binder_name];
  var fields$1 = instantiate_possibly_recursive_type(indu, paramdecls, fields);
  var lifted_fields = Termops$ReactTemplate.lift_rel_context(1)(fields$1);
  var primitive;
  if (primitive_flag[0]) {
    var match$1 = mib[/* mind_record */1];
    var is_primitive = match$1 && match$1[0] ? /* true */1 : /* false */0;
    if (!is_primitive) {
      Curry._2(warn_non_primitive_record, /* None */0, /* tuple */[
            env,
            indsp
          ]);
    }
    primitive = is_primitive;
  } else {
    primitive = /* false */0;
  }
  var match$2 = Curry._5(Util$ReactTemplate.List[/* fold_left3 */84], (function (param, coe, decl, impls) {
          var subst = param[4];
          var sp_projs = param[3];
          var i = param[1];
          var nfi = param[0];
          var fi = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
          var ti = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl);
          var match;
          if (fi) {
            var fid = fi[0];
            try {
              var match$1;
              if (Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], decl) && primitive) {
                var gr = Nametab$ReactTemplate.locate(Libnames$ReactTemplate.qualid_of_ident(fid));
                var kn = Globnames$ReactTemplate.destConstRef(gr);
                Declare$ReactTemplate.definition_message(fid);
                Universes$ReactTemplate.register_universe_binders(gr, ubinders);
                match$1 = /* tuple */[
                  kn,
                  Constr$ReactTemplate.mkProj(/* tuple */[
                        Names$ReactTemplate.Projection[/* make */0](kn, /* false */0),
                        Constr$ReactTemplate.mkRel(1)
                      ])
                ];
              } else {
                var ccl = subst_projection(fid, subst, ti);
                var body;
                if (decl.tag) {
                  body = subst_projection(fid, subst, decl[1]);
                } else {
                  var ccl$prime = Vars$ReactTemplate.liftn(1, 2, ccl);
                  var p = Constr$ReactTemplate.mkLambda(/* tuple */[
                        x,
                        Vars$ReactTemplate.lift(1)(rp),
                        ccl$prime
                      ]);
                  var branch = Curry._2(Term$ReactTemplate.it_mkLambda_or_LetIn, Constr$ReactTemplate.mkRel(nfi), lifted_fields);
                  var ci = Inductiveops$ReactTemplate.make_case_info(env, indsp, /* LetStyle */0);
                  body = Constr$ReactTemplate.mkCase(/* tuple */[
                        ci,
                        p,
                        Constr$ReactTemplate.mkRel(1),
                        /* array */[branch]
                      ]);
                }
                var proj = Curry._2(Term$ReactTemplate.it_mkLambda_or_LetIn, Constr$ReactTemplate.mkLambda(/* tuple */[
                          x,
                          rp,
                          body
                        ]), paramdecls);
                var projtyp = Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, Constr$ReactTemplate.mkProd(/* tuple */[
                          x,
                          rp,
                          ccl
                        ]), paramdecls);
                try {
                  var entry_000 = /* const_entry_body */Future$ReactTemplate.from_val(/* None */0, Safe_typing$ReactTemplate.mk_pure_proof(proj));
                  var entry_003 = /* const_entry_type : Some */[projtyp];
                  var entry = /* record */[
                    entry_000,
                    /* const_entry_secctx : None */0,
                    /* const_entry_feedback : None */0,
                    entry_003,
                    /* const_entry_universes */ctx,
                    /* const_entry_opaque : false */0,
                    /* const_entry_inline_code : false */0
                  ];
                  var k_000 = /* DefinitionEntry */Block.__(0, [entry]);
                  var k_001 = /* IsDefinition */Block.__(1, [kind]);
                  var k = /* tuple */[
                    k_000,
                    k_001
                  ];
                  var kn$1 = Declare$ReactTemplate.declare_constant(/* Some */[/* InternalTacticRequest */1], /* None */0, fid, /* None */0, k);
                  var proj_args = Util$ReactTemplate.$at(paramargs, /* :: */[
                        Constr$ReactTemplate.mkRel(1),
                        /* [] */0
                      ]);
                  var constr_fip = Term$ReactTemplate.applist(/* tuple */[
                        Constr$ReactTemplate.mkConstU(/* tuple */[
                              kn$1,
                              u
                            ]),
                        proj_args
                      ]);
                  Declare$ReactTemplate.definition_message(fid);
                  Universes$ReactTemplate.register_universe_binders(/* ConstRef */Block.__(1, [kn$1]), ubinders);
                  match$1 = /* tuple */[
                    kn$1,
                    constr_fip
                  ];
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === Type_errors$ReactTemplate.TypeError) {
                    throw [
                          NotDefinable,
                          /* BadTypedProj */Block.__(1, [
                              fid,
                              exn[1],
                              exn[2]
                            ])
                        ];
                  } else {
                    throw exn;
                  }
                }
              }
              var kn$2 = match$1[0];
              var refi = /* ConstRef */Block.__(1, [kn$2]);
              Impargs$ReactTemplate.maybe_declare_manual_implicits(/* false */0, refi, /* None */0, impls);
              if (coe) {
                var cl = Class$ReactTemplate.class_of_global(/* IndRef */Block.__(2, [indsp]));
                Class$ReactTemplate.try_add_new_coercion_with_source(refi, /* false */0, poly, cl);
              }
              var i$1 = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], decl) ? i + 1 | 0 : i;
              match = /* tuple */[
                /* :: */[
                  /* Some */[kn$2],
                  sp_projs
                ],
                i$1,
                /* :: */[
                  /* Projection */Block.__(1, [match$1[1]]),
                  subst
                ]
              ];
            }
            catch (raw_exn$1){
              var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
              if (exn$1[0] === NotDefinable) {
                warning_or_error(coe, indsp, exn$1[1]);
                match = /* tuple */[
                  /* :: */[
                    /* None */0,
                    sp_projs
                  ],
                  i,
                  /* :: */[
                    /* NoProjection */Block.__(0, [fi]),
                    subst
                  ]
                ];
              } else {
                throw exn$1;
              }
            }
          } else {
            match = /* tuple */[
              /* :: */[
                /* None */0,
                sp_projs
              ],
              i,
              /* :: */[
                /* NoProjection */Block.__(0, [fi]),
                subst
              ]
            ];
          }
          return /* tuple */[
                  nfi - 1 | 0,
                  match[1],
                  /* :: */[
                    /* tuple */[
                      fi,
                      Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], decl)
                    ],
                    param[2]
                  ],
                  match[0],
                  match[2]
                ];
        }), /* tuple */[
        Curry._1(Util$ReactTemplate.List[/* length */0], fields$1),
        0,
        /* [] */0,
        /* [] */0,
        /* [] */0
      ], coers, Curry._1(Util$ReactTemplate.List[/* rev */4], fields$1), Curry._1(Util$ReactTemplate.List[/* rev */4], fieldimpls));
  return /* tuple */[
          match$2[2],
          match$2[3]
        ];
}

function declare_structure(finite, ubinders, univs, id, idbuild, paramimpls, params, arity, template, fieldimpls, fields, $staropt$star, name, is_coe, coers) {
  var kind = $staropt$star ? $staropt$star[0] : /* StructureComponent */8;
  var nparams = Curry._1(Util$ReactTemplate.List[/* length */0], params);
  var nfields = Curry._1(Util$ReactTemplate.List[/* length */0], fields);
  var args = Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, nfields, params);
  var ind = Term$ReactTemplate.applist(/* tuple */[
        Constr$ReactTemplate.mkRel((1 + nparams | 0) + nfields | 0),
        args
      ]);
  var type_constructor = Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, ind, fields);
  var match;
  switch (univs.tag | 0) {
    case 0 : 
        match = /* tuple */[
          template,
          /* Monomorphic_const_entry */Block.__(0, [Univ$ReactTemplate.ContextSet[/* empty */0]])
        ];
        break;
    case 1 : 
        match = /* tuple */[
          /* false */0,
          /* Polymorphic_const_entry */Block.__(1, [univs[0]])
        ];
        break;
    case 2 : 
        match = /* tuple */[
          /* false */0,
          /* Polymorphic_const_entry */Block.__(1, [Univ$ReactTemplate.CumulativityInfo[/* univ_context */3](univs[0])])
        ];
        break;
    
  }
  var ctx = match[1];
  var binder_name = name ? name[0] : Names$ReactTemplate.Id[/* of_string */5](Unicode$ReactTemplate.lowercase_first_char(Names$ReactTemplate.Id[/* to_string */7](id)));
  var mie_ind_002 = /* mind_entry_template */match[0];
  var mie_ind_003 = /* mind_entry_consnames : :: */[
    idbuild,
    /* [] */0
  ];
  var mie_ind_004 = /* mind_entry_lc : :: */[
    type_constructor,
    /* [] */0
  ];
  var mie_ind = /* record */[
    /* mind_entry_typename */id,
    /* mind_entry_arity */arity,
    mie_ind_002,
    mie_ind_003,
    mie_ind_004
  ];
  var mie_000 = /* mind_entry_record : Some */[primitive_flag[0] ? /* Some */[binder_name] : /* None */0];
  var mie_002 = /* mind_entry_params */Curry._2(Util$ReactTemplate.List[/* map */10], degenerate_decl, params);
  var mie_003 = /* mind_entry_inds : :: */[
    mie_ind,
    /* [] */0
  ];
  var mie = /* record */[
    mie_000,
    /* mind_entry_finite */finite,
    mie_002,
    mie_003,
    /* mind_entry_universes */univs,
    /* mind_entry_private : None */0
  ];
  var mie$1 = InferCumulativity$ReactTemplate.infer_inductive(Global$ReactTemplate.env(/* () */0), mie);
  var kn = ComInductive$ReactTemplate.declare_mutual_inductive_with_eliminations(mie$1, ubinders, /* :: */[
        /* tuple */[
          paramimpls,
          /* [] */0
        ],
        /* [] */0
      ]);
  var rsp = /* tuple */[
    kn,
    0
  ];
  var cstr = /* tuple */[
    rsp,
    1
  ];
  var match$1 = declare_projections(rsp, ctx, /* Some */[kind], binder_name, coers, ubinders, fieldimpls, fields);
  var build = /* ConstructRef */Block.__(3, [cstr]);
  var poly;
  poly = ctx.tag ? /* true */1 : /* false */0;
  if (is_coe) {
    Class$ReactTemplate.try_add_new_coercion(build, /* false */0, poly);
  }
  Recordops$ReactTemplate.declare_structure(/* tuple */[
        rsp,
        cstr,
        Curry._1(Util$ReactTemplate.List[/* rev */4], match$1[0]),
        Curry._1(Util$ReactTemplate.List[/* rev */4], match$1[1])
      ]);
  return rsp;
}

function implicits_of_context(ctx) {
  return Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, name) {
                var explname = name ? /* Some */[name[0]] : /* None */0;
                return /* tuple */[
                        /* ExplByPos */Block.__(0, [
                            i,
                            explname
                          ]),
                        /* tuple */[
                          /* true */1,
                          /* true */1,
                          /* true */1
                        ]
                      ];
              }), 1, Curry._1(Util$ReactTemplate.List[/* rev */4], /* :: */[
                  /* Anonymous */0,
                  Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], ctx)
                ]));
}

function declare_existing_class(g) {
  switch (g.tag | 0) {
    case 1 : 
        var cst = g[0];
        var match = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), /* ConstRef */Block.__(1, [cst]));
        var match$1 = Term$ReactTemplate.decompose_prod_assum(match[0]);
        var ctx = match$1[0];
        var tc_000 = /* cl_univs */match[1];
        var tc_001 = /* cl_impl : ConstRef */Block.__(1, [cst]);
        var tc_002 = /* cl_context : tuple */[
          Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return Util$ReactTemplate.$$const(/* None */0, param);
                }), ctx),
          ctx
        ];
        var tc_003 = /* cl_props : :: */[
          /* LocalAssum */Block.__(0, [
              /* Anonymous */0,
              match$1[1]
            ]),
          /* [] */0
        ];
        var tc_005 = /* cl_strict */typeclasses_strict[0];
        var tc_006 = /* cl_unique */typeclasses_unique[0];
        var tc = /* record */[
          tc_000,
          tc_001,
          tc_002,
          tc_003,
          /* cl_projs : [] */0,
          tc_005,
          tc_006
        ];
        Typeclasses$ReactTemplate.add_class(tc);
        return Typeclasses$ReactTemplate.set_typeclass_transparency(/* EvalConstRef */Block.__(1, [cst]), /* false */0, /* false */0);
    case 2 : 
        var ind = g[0];
        var match$2 = Global$ReactTemplate.lookup_inductive(ind);
        var oneind = match$2[1];
        var mind = match$2[0];
        var ctx$1 = oneind[/* mind_arity_ctxt */1];
        var univs = Declareops$ReactTemplate.inductive_polymorphic_context(mind);
        var env = Environ$ReactTemplate.push_context(/* Some */[/* false */0], Univ$ReactTemplate.AUContext[/* repr */0](univs), Global$ReactTemplate.env(/* () */0));
        var env$1 = Environ$ReactTemplate.push_rel_context(ctx$1, env);
        var inst = Univ$ReactTemplate.make_abstract_instance(univs);
        var ty = Inductive$ReactTemplate.type_of_inductive(env$1, /* tuple */[
              /* tuple */[
                mind,
                oneind
              ],
              inst
            ]);
        return Typeclasses$ReactTemplate.add_class(/* record */[
                    /* cl_univs */univs,
                    /* cl_impl : IndRef */Block.__(2, [ind]),
                    /* cl_context : tuple */[
                      Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                              return Util$ReactTemplate.$$const(/* None */0, param);
                            }), ctx$1),
                      ctx$1
                    ],
                    /* cl_props : :: */[
                      /* LocalAssum */Block.__(0, [
                          /* Anonymous */0,
                          ty
                        ]),
                      /* [] */0
                    ],
                    /* cl_projs : [] */0,
                    /* cl_strict */typeclasses_strict[0],
                    /* cl_unique */typeclasses_unique[0]
                  ]);
    case 0 : 
    case 3 : 
        return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["declare_existing_class"], Pp$ReactTemplate.str("Unsupported class type, only constants and inductives are allowed"));
    
  }
}

function definition_structure(param) {
  var s = param[8];
  var idbuild = param[7];
  var ps = param[5];
  var match = param[4];
  var match$1 = match[1];
  var pl = match$1[1];
  var match$2 = match$1[0];
  var idstruc = match$2[/* v */0];
  var is_coe = match[0];
  var finite = param[3];
  var poly = param[2];
  var cum = param[1];
  var kind = param[0];
  var match$3 = Curry._1(Util$ReactTemplate.List[/* split */36], param[6]);
  var notations = match$3[1];
  var match$4 = Curry._1(Util$ReactTemplate.List[/* split */36], match$3[0]);
  var priorities = match$4[1];
  var match$5 = Curry._1(Util$ReactTemplate.List[/* split */36], match$4[0]);
  var fs = match$5[1];
  var coers = match$5[0];
  var extract_name = function (acc, param) {
    var match = param[0][/* v */0];
    if (match) {
      return /* :: */[
              match[0],
              acc
            ];
    } else {
      return acc;
    }
  };
  var allnames_001 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], extract_name, /* [] */0, fs);
  var allnames = /* :: */[
    idstruc,
    allnames_001
  ];
  var match$6 = Curry._2(Util$ReactTemplate.List[/* duplicates */60], Names$ReactTemplate.Id[/* equal */0], allnames);
  if (match$6) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Two objects have the same name"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.quote(Names$ReactTemplate.Id[/* print */8](match$6[0]))));
  }
  var isnot_class = typeof kind === "number" || kind[0] !== 0 ? /* true */1 : /* false */0;
  if (isnot_class && Curry._2(Util$ReactTemplate.List[/* exists */21], (function (opt) {
            return 1 - Option$ReactTemplate.is_empty(opt);
          }), priorities)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Priorities only allowed for type class substructures"));
  }
  var match$7 = States$ReactTemplate.with_state_protection((function () {
          var finite$1 = finite;
          var def = Caml_obj.caml_equal(kind, /* Class */[/* true */1]);
          var id = idstruc;
          var poly$1 = poly;
          var pl$1 = pl;
          var t = s;
          var ps$1 = ps;
          var nots = notations;
          var fs$1 = fs;
          var env0 = Global$ReactTemplate.env(/* () */0);
          var match = Univdecls$ReactTemplate.interp_univ_decl_opt(env0, pl$1);
          var error = function (bk, param) {
            if (!bk.tag && !param[/* v */0]) {
              return CErrors$ReactTemplate.user_err(param[/* loc */1], /* Some */["record"], Pp$ReactTemplate.str("Record parameters must be named"));
            } else {
              return /* () */0;
            }
          };
          Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                  switch (param.tag | 0) {
                    case 0 : 
                        var bk = param[1];
                        return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                                      return error(bk, param);
                                    }), param[0]);
                    case 1 : 
                        return error(Constrexpr_ops$ReactTemplate.default_binder_kind, param[0]);
                    case 2 : 
                        return Loc$ReactTemplate.raise(param[0][/* loc */1], [
                                    Stream.$$Error,
                                    "pattern with quote not allowed in record parameters."
                                  ]);
                    
                  }
                }), ps$1);
          var match$1 = Constrintern$ReactTemplate.interp_context_evars(/* None */0, /* None */0, /* None */0, env0, match[0], ps$1);
          var match$2 = match$1[1];
          var match$3 = match$2[1];
          var imps = match$3[1];
          var newps = match$3[0][1];
          var sigma = match$1[0];
          var match$4;
          if (t) {
            var t$1 = t[0];
            var env = EConstr$ReactTemplate.push_rel_context(newps, env0);
            var match$5 = t$1[/* v */0];
            var poly$2;
            if (match$5.tag === 15) {
              var match$6 = match$5[0];
              poly$2 = typeof match$6 === "number" || match$6[0] ? /* false */0 : /* true */1;
            } else {
              poly$2 = /* false */0;
            }
            var match$7 = Constrintern$ReactTemplate.interp_type_evars(env, sigma, /* Some */[Constrintern$ReactTemplate.empty_internalization_env], t$1);
            var s$1 = match$7[1];
            var sigma$1 = match$7[0];
            var sred = Reductionops$ReactTemplate.whd_allnolet(env)(sigma$1, s$1);
            var match$8 = EConstr$ReactTemplate.kind(sigma$1, sred);
            if (match$8.tag === 4) {
              var s$prime = EConstr$ReactTemplate.ESorts[/* kind */1](sigma$1, match$8[0]);
              if (poly$2) {
                var match$9 = Evd$ReactTemplate.is_sort_variable(sigma$1, s$prime);
                if (match$9) {
                  var sigma$2 = Evd$ReactTemplate.make_flexible_variable(sigma$1, /* true */1, match$9[0]);
                  match$4 = /* tuple */[
                    sigma$2,
                    s$1,
                    s$prime,
                    /* true */1
                  ];
                } else {
                  match$4 = /* tuple */[
                    sigma$1,
                    s$1,
                    s$prime,
                    /* false */0
                  ];
                }
              } else {
                match$4 = /* tuple */[
                  sigma$1,
                  s$1,
                  s$prime,
                  /* false */0
                ];
              }
            } else {
              match$4 = CErrors$ReactTemplate.user_err(Constrexpr_ops$ReactTemplate.constr_loc(t$1), /* None */0, Pp$ReactTemplate.str("Sort expected."));
            }
          } else {
            var match$10 = Evd$ReactTemplate.new_sort_variable(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg, sigma);
            var s$2 = match$10[1];
            match$4 = /* tuple */[
              match$10[0],
              EConstr$ReactTemplate.mkSort(s$2),
              s$2,
              /* true */1
            ];
          }
          var sort = match$4[2];
          var typ = match$4[1];
          var sigma$3 = match$4[0];
          var arity = EConstr$ReactTemplate.it_mkProd_or_LetIn(typ, newps);
          var env_ar = EConstr$ReactTemplate.push_rel_context(newps, EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      /* Name */[id],
                      arity
                    ]), env0));
          var assums = Curry._2(Util$ReactTemplate.List[/* filter */27], Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], newps);
          var partial_arg = Nameops$ReactTemplate.Name[/* get_id */15];
          var partial_arg$1 = Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0];
          var params = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return Util$ReactTemplate.$percent$great(partial_arg$1, partial_arg, param);
                }), assums);
          var ty_001 = +(finite$1 !== /* BiFinite */2);
          var ty = /* Inductive */[
            params,
            ty_001
          ];
          var impls_env = Curry._3(Constrintern$ReactTemplate.compute_internalization_env(env0, sigma$3, /* Some */[match$2[0]], ty), /* :: */[
                id,
                /* [] */0
              ], /* :: */[
                arity,
                /* [] */0
              ], /* :: */[
                imps,
                /* [] */0
              ]);
          var match$11 = interp_fields_evars(env_ar, sigma$3, impls_env, nots, Curry._1(binders_of_decls, fs$1));
          var newfs = match$11[3];
          var sigma$4 = Pretyping$ReactTemplate.solve_remaining_evars(Pretyping$ReactTemplate.all_and_fail_flags, env_ar, match$11[1], Evd$ReactTemplate.empty);
          var match$12 = compute_constructor_level(sigma$4, env_ar, newfs);
          var univ = match$12[1];
          var match$13;
          if (!def && (Sorts$ReactTemplate.is_prop(sort) || Sorts$ReactTemplate.is_set(sort) && Environ$ReactTemplate.is_impredicative_set(env0))) {
            match$13 = /* tuple */[
              sigma$4,
              typ
            ];
          } else {
            var sigma$5 = Evd$ReactTemplate.set_leq_sort(env_ar, sigma$4, /* Type */Block.__(1, [univ]), sort);
            match$13 = Univ$ReactTemplate.is_small_univ(univ) && Option$ReactTemplate.cata((function (param) {
                    return Evd$ReactTemplate.is_flexible_level(sigma$5, param);
                  }), /* false */0, Evd$ReactTemplate.is_sort_variable(sigma$5, sort)) ? /* tuple */[
                Evd$ReactTemplate.set_eq_sort(env_ar, sigma$5, /* Prop */Block.__(0, [/* Pos */0]), sort),
                EConstr$ReactTemplate.mkSort(Sorts$ReactTemplate.sort_of_univ(univ))
              ] : /* tuple */[
                sigma$5,
                typ
              ];
          }
          var match$14 = Evarutil$ReactTemplate.nf_evars_and_universes(match$13[0]);
          var sigma$6 = match$14[0];
          var newfs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return EConstr$ReactTemplate.to_rel_decl(sigma$6, param);
                }), newfs);
          var newps$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return EConstr$ReactTemplate.to_rel_decl(sigma$6, param);
                }), newps);
          var typ$1 = EConstr$ReactTemplate.to_constr(sigma$6, match$13[1]);
          var ce = function (t) {
            return Pretyping$ReactTemplate.check_evars(env0, Evd$ReactTemplate.empty, sigma$6, EConstr$ReactTemplate.of_constr(t));
          };
          var univs = Evd$ReactTemplate.check_univ_decl(poly$1, sigma$6, match[1]);
          var ubinders = Evd$ReactTemplate.universe_binders(sigma$6);
          Curry._2(Util$ReactTemplate.List[/* iter */9], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* iter_constr */14], ce), Curry._1(Util$ReactTemplate.List[/* rev */4], newps$1));
          Curry._2(Util$ReactTemplate.List[/* iter */9], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* iter_constr */14], ce), Curry._1(Util$ReactTemplate.List[/* rev */4], newfs$1));
          return /* tuple */[
                  ubinders,
                  univs,
                  typ$1,
                  match$4[3],
                  imps,
                  newps$1,
                  match$11[2],
                  newfs$1
                ];
        }), /* () */0);
  var fields = match$7[7];
  var implfs = match$7[6];
  var params = match$7[5];
  var implpars = match$7[4];
  var template = match$7[3];
  var arity = match$7[2];
  var univs = match$7[1];
  var pl$1 = match$7[0];
  if (typeof kind === "number") {
    var implfs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (impls) {
            return Util$ReactTemplate.$at(implpars, Curry._1(Impargs$ReactTemplate.lift_implicits(Curry._1(Util$ReactTemplate.List[/* length */0], params) + 1 | 0), impls));
          }), implfs);
    var univs$1;
    if (univs.tag) {
      var univs$2 = univs[0];
      univs$1 = cum ? /* Cumulative_ind_entry */Block.__(2, [Univ$ReactTemplate.CumulativityInfo[/* from_universe_context */5](univs$2)]) : /* Polymorphic_ind_entry */Block.__(1, [univs$2]);
    } else {
      univs$1 = /* Monomorphic_ind_entry */Block.__(0, [univs[0]]);
    }
    var ind = declare_structure(finite, pl$1, univs$1, idstruc, idbuild, implpars, params, arity, template, implfs$1, fields, /* None */0, /* None */0, is_coe, Curry._2(Util$ReactTemplate.List[/* map */10], (function (coe) {
                return 1 - Option$ReactTemplate.is_empty(coe);
              }), coers));
    return /* IndRef */Block.__(2, [ind]);
  } else {
    var priorities$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
            return /* record */[
                    /* hint_priority */id,
                    /* hint_pattern : None */0
                  ];
          }), priorities);
    var def = kind[0];
    var cum$1 = cum;
    var ubinders = pl$1;
    var univs$3 = univs;
    var id = /* tuple */[
      match$2[/* loc */1],
      idstruc
    ];
    var idbuild$1 = idbuild;
    var paramimpls = implpars;
    var params$1 = params;
    var arity$1 = arity;
    var template$1 = template;
    var fieldimpls = implfs;
    var fields$1 = fields;
    var coers$1 = coers;
    var priorities$2 = priorities$1;
    var len = Curry._1(Util$ReactTemplate.List[/* length */0], params$1);
    var impls = implicits_of_context(params$1);
    var fieldimpls$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
            return Util$ReactTemplate.$at(impls, Curry._1(Impargs$ReactTemplate.lift_implicits(len + 1 | 0), x));
          }), fieldimpls);
    var binder_name = Namegen$ReactTemplate.next_ident_away(id[1], Termops$ReactTemplate.vars_of_env(Global$ReactTemplate.env(/* () */0)));
    var match$8;
    var exit = 0;
    if (fields$1) {
      var match$9 = fields$1[0];
      var exit$1 = 0;
      var proj_name;
      var field;
      if (match$9.tag) {
        var match$10 = match$9[0];
        if (match$10) {
          proj_name = match$10[0];
          field = match$9[2];
          exit$1 = 2;
        } else {
          exit = 1;
        }
      } else {
        var match$11 = match$9[0];
        if (match$11) {
          proj_name = match$11[0];
          field = match$9[1];
          exit$1 = 2;
        } else {
          exit = 1;
        }
      }
      if (exit$1 === 2) {
        if (fields$1[1]) {
          exit = 1;
        } else if (def) {
          var class_body = Curry._2(Term$ReactTemplate.it_mkLambda_or_LetIn, field, params$1);
          var class_type = Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, arity$1, params$1);
          var class_entry = Declare$ReactTemplate.definition_entry(/* None */0, /* None */0, /* None */0, /* Some */[class_type], /* Some */[univs$3], /* None */0, class_body);
          var cst = Declare$ReactTemplate.declare_constant(/* None */0, /* None */0, id[1], /* None */0, /* tuple */[
                /* DefinitionEntry */Block.__(0, [class_entry]),
                /* IsDefinition */Block.__(1, [/* Definition */0])
              ]);
          var tmp;
          tmp = univs$3.tag ? Univ$ReactTemplate.UContext[/* instance */3](univs$3[0]) : Univ$ReactTemplate.Instance[/* empty */0];
          var cstu = /* tuple */[
            cst,
            tmp
          ];
          var inst_type = Term$ReactTemplate.appvectc(Constr$ReactTemplate.mkConstU(cstu), Termops$ReactTemplate.rel_vect(0, Curry._1(Util$ReactTemplate.List[/* length */0], params$1)));
          var proj_type = Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, Constr$ReactTemplate.mkProd(/* tuple */[
                    /* Name */[binder_name],
                    inst_type,
                    Vars$ReactTemplate.lift(1)(field)
                  ]), params$1);
          var proj_body = Curry._2(Term$ReactTemplate.it_mkLambda_or_LetIn, Constr$ReactTemplate.mkLambda(/* tuple */[
                    /* Name */[binder_name],
                    inst_type,
                    Constr$ReactTemplate.mkRel(1)
                  ]), params$1);
          var proj_entry = Declare$ReactTemplate.definition_entry(/* None */0, /* None */0, /* None */0, /* Some */[proj_type], /* Some */[univs$3], /* None */0, proj_body);
          var proj_cst = Declare$ReactTemplate.declare_constant(/* None */0, /* None */0, proj_name, /* None */0, /* tuple */[
                /* DefinitionEntry */Block.__(0, [proj_entry]),
                /* IsDefinition */Block.__(1, [/* Definition */0])
              ]);
          var cref = /* ConstRef */Block.__(1, [cst]);
          Impargs$ReactTemplate.declare_manual_implicits(/* false */0, cref, /* None */0, /* :: */[
                paramimpls,
                /* [] */0
              ]);
          Universes$ReactTemplate.register_universe_binders(cref, ubinders);
          Impargs$ReactTemplate.declare_manual_implicits(/* false */0, /* ConstRef */Block.__(1, [proj_cst]), /* None */0, /* :: */[
                Curry._1(Util$ReactTemplate.List[/* hd */1], fieldimpls$1),
                /* [] */0
              ]);
          Universes$ReactTemplate.register_universe_binders(/* ConstRef */Block.__(1, [proj_cst]), ubinders);
          Classes$ReactTemplate.set_typeclass_transparency(/* EvalConstRef */Block.__(1, [cst]), /* false */0, /* false */0);
          var match$12 = Curry._1(Util$ReactTemplate.List[/* hd */1], coers$1);
          var sub = match$12 ? /* Some */[/* tuple */[
                match$12[0] ? /* Backward */1 : /* Forward */0,
                Curry._1(Util$ReactTemplate.List[/* hd */1], priorities$2)
              ]] : /* None */0;
          match$8 = /* tuple */[
            cref,
            /* :: */[
              /* tuple */[
                /* Name */[proj_name],
                sub,
                /* Some */[proj_cst]
              ],
              /* [] */0
            ]
          ];
        } else {
          exit = 1;
        }
      }
      
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var univs$4;
      if (univs$3.tag) {
        var univs$5 = univs$3[0];
        univs$4 = cum$1 ? /* Cumulative_ind_entry */Block.__(2, [Univ$ReactTemplate.CumulativityInfo[/* from_universe_context */5](univs$5)]) : /* Polymorphic_ind_entry */Block.__(1, [univs$5]);
      } else {
        univs$4 = /* Monomorphic_ind_entry */Block.__(0, [univs$3[0]]);
      }
      var ind$1 = declare_structure(/* BiFinite */2, ubinders, univs$4, id[1], idbuild$1, paramimpls, params$1, arity$1, template$1, fieldimpls$1, fields$1, /* Some */[/* Method */11], /* Some */[binder_name], /* false */0, Curry._2(Util$ReactTemplate.List[/* map */10], (function () {
                  return /* false */0;
                }), fields$1));
      var coers$2 = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (coe, pri) {
              return Option$ReactTemplate.map((function (b) {
                            if (b) {
                              return /* tuple */[
                                      /* Backward */1,
                                      pri
                                    ];
                            } else {
                              return /* tuple */[
                                      /* Forward */0,
                                      pri
                                    ];
                            }
                          }), coe);
            }), coers$1, priorities$2);
      var l = Curry._4(Util$ReactTemplate.List[/* map3 */69], (function (decl, b, y) {
              return /* tuple */[
                      Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl),
                      b,
                      y
                    ];
            }), Curry._1(Util$ReactTemplate.List[/* rev */4], fields$1), coers$2, Recordops$ReactTemplate.lookup_projections(ind$1));
      match$8 = /* tuple */[
        /* IndRef */Block.__(2, [ind$1]),
        l
      ];
    }
    var impl = match$8[0];
    var ctx_context_000 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (decl) {
            var match = Typeclasses$ReactTemplate.class_of_constr(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl)));
            if (match) {
              return /* Some */[match[0][1][0][0][/* cl_impl */1]];
            } else {
              return /* None */0;
            }
          }), params$1);
    var ctx_context = /* tuple */[
      ctx_context_000,
      params$1
    ];
    var match$13;
    if (univs$3.tag) {
      var match$14 = Univ$ReactTemplate.abstract_universes(univs$3[0]);
      var usubst = Univ$ReactTemplate.make_instance_subst(match$14[0]);
      var map = function (c) {
        return Vars$ReactTemplate.subst_univs_level_constr(usubst, c);
      };
      var fields$2 = Curry._1(Context$ReactTemplate.Rel[/* map */7](map), fields$1);
      var ctx_context$1 = Util$ReactTemplate.on_snd((function (d) {
              return Curry._1(Context$ReactTemplate.Rel[/* map */7](map), d);
            }), ctx_context);
      match$13 = /* tuple */[
        match$14[1],
        ctx_context$1,
        fields$2
      ];
    } else {
      match$13 = /* tuple */[
        Univ$ReactTemplate.AUContext[/* empty */1],
        ctx_context,
        fields$1
      ];
    }
    var k_000 = /* cl_univs */match$13[0];
    var k_002 = /* cl_context */match$13[1];
    var k_003 = /* cl_props */match$13[2];
    var k_004 = /* cl_projs */match$8[1];
    var k_005 = /* cl_strict */typeclasses_strict[0];
    var k_006 = /* cl_unique */typeclasses_unique[0];
    var k = /* record */[
      k_000,
      /* cl_impl */impl,
      k_002,
      k_003,
      k_004,
      k_005,
      k_006
    ];
    Typeclasses$ReactTemplate.add_class(k);
    return impl;
  }
}

exports.primitive_flag = primitive_flag;
exports.declare_projections = declare_projections;
exports.definition_structure = definition_structure;
exports.declare_existing_class = declare_existing_class;
/*  Not a pure module */
