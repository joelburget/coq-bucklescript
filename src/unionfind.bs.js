// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function Make(funarg) {
  var $$let = function (M) {
    var create = function () {
      return [M[/* empty */0]];
    };
    var fresh = function (x, p) {
      var node = [/* Canon */Block.__(0, [Curry._1(funarg[/* singleton */0], x)])];
      p[0] = Curry._3(M[/* add */2], x, node, p[0]);
      return /* tuple */[
              x,
              node
            ];
    };
    var lookup = function (x, p) {
      var node = Curry._2(M[/* find */1], x, p[0]);
      var match = node[0];
      if (match.tag) {
        var y = match[0];
        var res = lookup(y, p);
        var z = res[0];
        if (z !== y) {
          node[0] = /* Equiv */Block.__(1, [z]);
        }
        return res;
      } else {
        return /* tuple */[
                x,
                node
              ];
      }
    };
    var add = function (x, p) {
      if (Curry._2(M[/* mem */3], x, p[0])) {
        return 0;
      } else {
        fresh(x, p);
        return /* () */0;
      }
    };
    var find = function (x, p) {
      return lookup(x, p)[0];
    };
    var canonical = function (x, p) {
      try {
        return lookup(x, p);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return fresh(x, p);
        } else {
          throw exn;
        }
      }
    };
    var union = function (x, y, p) {
      var xcan = canonical(x, p);
      var x$1 = xcan[0];
      var ycan = canonical(y, p);
      var y$1 = ycan[0];
      if (Caml_obj.caml_equal(x$1, y$1)) {
        return /* () */0;
      } else {
        var match = Caml_obj.caml_lessthan(x$1, y$1) ? /* tuple */[
            xcan,
            ycan
          ] : /* tuple */[
            ycan,
            xcan
          ];
        var ynode = match[1][1];
        var xcan$1 = match[0];
        var xnode = xcan$1[1];
        var match$1 = xnode[0];
        var match$2 = ynode[0];
        if (match$1.tag) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "unionfind.ml",
                  123,
                  8
                ]
              ];
        } else if (match$2.tag) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "unionfind.ml",
                  123,
                  8
                ]
              ];
        } else {
          xnode[0] = /* Canon */Block.__(0, [Curry._2(funarg[/* union */1], match$1[0], match$2[0])]);
          ynode[0] = /* Equiv */Block.__(1, [xcan$1[0]]);
          return /* () */0;
        }
      }
    };
    var union_set = function (s, p) {
      try {
        var x = Curry._1(funarg[/* choose */2], s);
        return Curry._2(funarg[/* iter */3], (function (y) {
                      return union(x, y, p);
                    }), s);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* () */0;
        } else {
          throw exn;
        }
      }
    };
    var partition = function (p) {
      return List.rev(Curry._3(M[/* fold */4], (function (_, node, acc) {
                        var match = node[0];
                        if (match.tag) {
                          return acc;
                        } else {
                          return /* :: */[
                                  match[0],
                                  acc
                                ];
                        }
                      }), p[0], /* [] */0));
    };
    return /* module */[
            /* create */create,
            /* fresh */fresh,
            /* lookup */lookup,
            /* add */add,
            /* find */find,
            /* canonical */canonical,
            /* union */union,
            /* union_set */union_set,
            /* partition */partition
          ];
  };
  return (function (funarg) {
      var $$let$1 = $$let(funarg);
      return [
              $$let$1[0],
              $$let$1[3],
              $$let$1[4],
              $$let$1[6],
              $$let$1[7],
              $$let$1[8]
            ];
    });
}

exports.Make = Make;
/* No side effect */
