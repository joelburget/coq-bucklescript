// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Range$ReactTemplate = require("./range.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Esubst$ReactTemplate = require("./esubst.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Hashset$ReactTemplate = require("./hashset.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var stats = [/* false */0];

var share = [/* true */1];

var beta = [0];

var delta = [0];

var eta = [0];

var zeta = [0];

var evar = [0];

var nb_match = [0];

var fix = [0];

var cofix = [0];

var prune = [0];

function reset() {
  beta[0] = 0;
  delta[0] = 0;
  zeta[0] = 0;
  evar[0] = 0;
  nb_match[0] = 0;
  fix[0] = 0;
  cofix[0] = 0;
  evar[0] = 0;
  prune[0] = 0;
  return /* () */0;
}

function stop() {
  return Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("[Reds: beta="), Pp$ReactTemplate.$$int(beta[0])), Pp$ReactTemplate.str(" delta=")), Pp$ReactTemplate.$$int(delta[0])), Pp$ReactTemplate.str(" eta=")), Pp$ReactTemplate.$$int(eta[0])), Pp$ReactTemplate.str(" zeta=")), Pp$ReactTemplate.$$int(zeta[0])), Pp$ReactTemplate.str(" evar=")), Pp$ReactTemplate.$$int(evar[0])), Pp$ReactTemplate.str(" match=")), Pp$ReactTemplate.$$int(nb_match[0])), Pp$ReactTemplate.str(" fix=")), Pp$ReactTemplate.$$int(fix[0])), Pp$ReactTemplate.str(" cofix=")), Pp$ReactTemplate.$$int(cofix[0])), Pp$ReactTemplate.str(" prune=")), Pp$ReactTemplate.$$int(prune[0])), Pp$ReactTemplate.str("]")));
}

function incr_cnt(red, cnt) {
  if (red) {
    if (stats[0]) {
      cnt[0] = cnt[0] + 1 | 0;
    }
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function with_stats(c) {
  if (stats[0]) {
    reset(/* () */0);
    var tag = c.tag | 0;
    var r = tag === 250 ? c[0] : (
        tag === 246 ? CamlinternalLazy.force_lazy_block(c) : c
      );
    stop(/* () */0);
    return r;
  } else {
    var tag$1 = c.tag | 0;
    if (tag$1 === 250) {
      return c[0];
    } else if (tag$1 === 246) {
      return CamlinternalLazy.force_lazy_block(c);
    } else {
      return c;
    }
  }
}

var all_opaque_000 = Names$ReactTemplate.Id[/* Pred */11][/* empty */0];

var all_opaque_001 = Names$ReactTemplate.Cpred[/* empty */0];

var all_opaque = /* tuple */[
  all_opaque_000,
  all_opaque_001
];

var all_transparent_000 = Names$ReactTemplate.Id[/* Pred */11][/* full */1];

var all_transparent_001 = Names$ReactTemplate.Cpred[/* full */1];

var all_transparent = /* tuple */[
  all_transparent_000,
  all_transparent_001
];

function is_transparent_variable(param, id) {
  return Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], id, param[0]);
}

function is_transparent_constant(param, cst) {
  return Curry._2(Names$ReactTemplate.Cpred[/* mem */4], cst, param[1]);
}

function fCONST(kn) {
  return /* CONST */Block.__(0, [kn]);
}

function fVAR(id) {
  return /* VAR */Block.__(1, [id]);
}

var no_red = /* record */[
  /* r_beta : false */0,
  /* r_delta : false */0,
  /* r_eta : false */0,
  /* r_const */all_opaque,
  /* r_zeta : false */0,
  /* r_match : false */0,
  /* r_fix : false */0,
  /* r_cofix : false */0
];

function red_add(red, param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          var newrecord = red.slice();
          newrecord[/* r_beta */0] = /* true */1;
          return newrecord;
      case 1 : 
          var newrecord$1 = red.slice();
          newrecord$1[/* r_delta */1] = /* true */1;
          newrecord$1[/* r_const */3] = all_transparent;
          return newrecord$1;
      case 2 : 
          var newrecord$2 = red.slice();
          newrecord$2[/* r_eta */2] = /* true */1;
          return newrecord$2;
      case 3 : 
          var newrecord$3 = red.slice();
          newrecord$3[/* r_match */5] = /* true */1;
          return newrecord$3;
      case 4 : 
          var newrecord$4 = red.slice();
          newrecord$4[/* r_fix */6] = /* true */1;
          return newrecord$4;
      case 5 : 
          var newrecord$5 = red.slice();
          newrecord$5[/* r_cofix */7] = /* true */1;
          return newrecord$5;
      case 6 : 
          var newrecord$6 = red.slice();
          newrecord$6[/* r_zeta */4] = /* true */1;
          return newrecord$6;
      
    }
  } else if (param.tag) {
    var match = red[/* r_const */3];
    var newrecord$7 = red.slice();
    newrecord$7[/* r_const */3] = /* tuple */[
      Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* add */6], param[0], match[0]),
      match[1]
    ];
    return newrecord$7;
  } else {
    var match$1 = red[/* r_const */3];
    var newrecord$8 = red.slice();
    newrecord$8[/* r_const */3] = /* tuple */[
      match$1[0],
      Curry._2(Names$ReactTemplate.Cpred[/* add */6], param[0], match$1[1])
    ];
    return newrecord$8;
  }
}

function red_sub(red, param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          var newrecord = red.slice();
          newrecord[/* r_beta */0] = /* false */0;
          return newrecord;
      case 1 : 
          var newrecord$1 = red.slice();
          newrecord$1[/* r_delta */1] = /* false */0;
          return newrecord$1;
      case 2 : 
          var newrecord$2 = red.slice();
          newrecord$2[/* r_eta */2] = /* false */0;
          return newrecord$2;
      case 3 : 
          var newrecord$3 = red.slice();
          newrecord$3[/* r_match */5] = /* false */0;
          return newrecord$3;
      case 4 : 
          var newrecord$4 = red.slice();
          newrecord$4[/* r_fix */6] = /* false */0;
          return newrecord$4;
      case 5 : 
          var newrecord$5 = red.slice();
          newrecord$5[/* r_cofix */7] = /* false */0;
          return newrecord$5;
      case 6 : 
          var newrecord$6 = red.slice();
          newrecord$6[/* r_zeta */4] = /* false */0;
          return newrecord$6;
      
    }
  } else if (param.tag) {
    var match = red[/* r_const */3];
    var newrecord$7 = red.slice();
    newrecord$7[/* r_const */3] = /* tuple */[
      Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* remove */7], param[0], match[0]),
      match[1]
    ];
    return newrecord$7;
  } else {
    var match$1 = red[/* r_const */3];
    var newrecord$8 = red.slice();
    newrecord$8[/* r_const */3] = /* tuple */[
      match$1[0],
      Curry._2(Names$ReactTemplate.Cpred[/* remove */7], param[0], match$1[1])
    ];
    return newrecord$8;
  }
}

function red_transparent(red) {
  return red[/* r_const */3];
}

function red_add_transparent(red, tr) {
  var newrecord = red.slice();
  newrecord[/* r_const */3] = tr;
  return newrecord;
}

var mkflags = Curry._2(Util$ReactTemplate.List[/* fold_left */13], red_add, no_red);

function red_set(red, param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return incr_cnt(red[/* r_beta */0], beta);
      case 1 : 
          return incr_cnt(red[/* r_delta */1], delta);
      case 2 : 
          return incr_cnt(red[/* r_eta */2], eta);
      case 3 : 
          return incr_cnt(red[/* r_match */5], nb_match);
      case 4 : 
          return incr_cnt(red[/* r_fix */6], fix);
      case 5 : 
          return incr_cnt(red[/* r_cofix */7], cofix);
      case 6 : 
          return incr_cnt(red[/* r_zeta */4], zeta);
      
    }
  } else if (param.tag) {
    var match = red[/* r_const */3];
    var c = Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], param[0], match[0]);
    return incr_cnt(c, delta);
  } else {
    var match$1 = red[/* r_const */3];
    var c$1 = Curry._2(Names$ReactTemplate.Cpred[/* mem */4], param[0], match$1[1]);
    return incr_cnt(c$1, delta);
  }
}

function red_projection(red, p) {
  if (Names$ReactTemplate.Projection[/* unfolded */3](p)) {
    return /* true */1;
  } else {
    return red_set(red, /* CONST */Block.__(0, [Names$ReactTemplate.Projection[/* constant */2](p)]));
  }
}

var RedFlags = /* module */[
  /* fBETA : BETA */0,
  /* fDELTA : DELTA */1,
  /* fETA : ETA */2,
  /* fMATCH : MATCH */3,
  /* fFIX : FIX */4,
  /* fCOFIX : COFIX */5,
  /* fZETA : ZETA */6,
  /* fCONST */fCONST,
  /* fVAR */fVAR,
  /* no_red */no_red,
  /* red_add */red_add,
  /* red_sub */red_sub,
  /* red_add_transparent */red_add_transparent,
  /* red_transparent */red_transparent,
  /* mkflags */mkflags,
  /* red_set */red_set,
  /* red_projection */red_projection
];

var all = Curry._1(mkflags, /* :: */[
      /* BETA */0,
      /* :: */[
        /* DELTA */1,
        /* :: */[
          /* ZETA */6,
          /* :: */[
            /* MATCH */3,
            /* :: */[
              /* FIX */4,
              /* :: */[
                /* COFIX */5,
                /* [] */0
              ]
            ]
          ]
        ]
      ]
    ]);

var allnolet = Curry._1(mkflags, /* :: */[
      /* BETA */0,
      /* :: */[
        /* DELTA */1,
        /* :: */[
          /* MATCH */3,
          /* :: */[
            /* FIX */4,
            /* :: */[
              /* COFIX */5,
              /* [] */0
            ]
          ]
        ]
      ]
    ]);

var beta$1 = Curry._1(mkflags, /* :: */[
      /* BETA */0,
      /* [] */0
    ]);

var betadeltazeta = Curry._1(mkflags, /* :: */[
      /* BETA */0,
      /* :: */[
        /* DELTA */1,
        /* :: */[
          /* ZETA */6,
          /* [] */0
        ]
      ]
    ]);

var betaiota = Curry._1(mkflags, /* :: */[
      /* BETA */0,
      /* :: */[
        /* MATCH */3,
        /* :: */[
          /* FIX */4,
          /* :: */[
            /* COFIX */5,
            /* [] */0
          ]
        ]
      ]
    ]);

var betaiotazeta = Curry._1(mkflags, /* :: */[
      /* BETA */0,
      /* :: */[
        /* MATCH */3,
        /* :: */[
          /* FIX */4,
          /* :: */[
            /* COFIX */5,
            /* :: */[
              /* ZETA */6,
              /* [] */0
            ]
          ]
        ]
      ]
    ]);

var betazeta = Curry._1(mkflags, /* :: */[
      /* BETA */0,
      /* :: */[
        /* ZETA */6,
        /* [] */0
      ]
    ]);

var delta$1 = Curry._1(mkflags, /* :: */[
      /* DELTA */1,
      /* [] */0
    ]);

var zeta$1 = Curry._1(mkflags, /* :: */[
      /* ZETA */6,
      /* [] */0
    ]);

var unfold_side_flags_001 = /* :: */[
  /* MATCH */3,
  /* :: */[
    /* FIX */4,
    /* :: */[
      /* COFIX */5,
      /* :: */[
        /* ZETA */6,
        /* [] */0
      ]
    ]
  ]
];

var unfold_side_flags = /* :: */[
  /* BETA */0,
  unfold_side_flags_001
];

var unfold_side_red = Curry._1(mkflags, /* :: */[
      /* BETA */0,
      /* :: */[
        /* MATCH */3,
        /* :: */[
          /* FIX */4,
          /* :: */[
            /* COFIX */5,
            /* :: */[
              /* ZETA */6,
              /* [] */0
            ]
          ]
        ]
      ]
    ]);

function unfold_red(kn) {
  var flag;
  flag = kn.tag ? /* CONST */Block.__(0, [kn[0]]) : /* VAR */Block.__(1, [kn[0]]);
  return Curry._1(mkflags, /* :: */[
              flag,
              unfold_side_flags
            ]);
}

function eq_pconstant_key(param, param$1) {
  if (Names$ReactTemplate.eq_constant_key(param[0], param$1[0])) {
    return Univ$ReactTemplate.Instance[/* equal */5](param[1], param$1[1]);
  } else {
    return /* false */0;
  }
}

function equal(param, param$1) {
  return Names$ReactTemplate.eq_table_key(eq_pconstant_key, param, param$1);
}

function hash(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, Curry._1(Names$ReactTemplate.Constant[/* UserOrd */10][/* hash */2], param[0][0]));
    case 1 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](2, Curry._1(Names$ReactTemplate.Id[/* hash */2], param[0]));
    case 2 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](3, Int$ReactTemplate.hash(param[0]));
    
  }
}

var IdKeyHash = /* module */[
  /* equal */equal,
  /* hash */hash
];

var KeyTable = Hashtbl.Make(IdKeyHash);

function info_flags(info) {
  return info[/* i_flags */0];
}

function info_env(info) {
  return info[/* i_cache */1][/* i_env */1];
}

function assoc_defined(id, env) {
  var match = Environ$ReactTemplate.lookup_named(id, env);
  if (match.tag) {
    return match[1];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function ref_value_cache(infos, tab, ref) {
  var cache = infos[/* i_cache */1];
  try {
    return /* Some */[Curry._2(KeyTable[/* find */6], tab, ref)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      try {
        var body;
        switch (ref.tag | 0) {
          case 0 : 
              body = Environ$ReactTemplate.constant_value_in(cache[/* i_env */1], ref[0]);
              break;
          case 1 : 
              body = assoc_defined(ref[0], cache[/* i_env */1]);
              break;
          case 2 : 
              var n = ref[0];
              var i = n - 1 | 0;
              var match;
              try {
                match = Range$ReactTemplate.get(cache[/* i_rels */3], i);
              }
              catch (raw_exn){
                var exn$1 = Js_exn.internalToOCamlException(raw_exn);
                if (exn$1[0] === Caml_builtin_exceptions.invalid_argument) {
                  throw Caml_builtin_exceptions.not_found;
                } else {
                  throw exn$1;
                }
              }
              var d = match[0];
              if (d.tag) {
                body = Vars$ReactTemplate.lift(n)(d[1]);
              } else {
                throw Caml_builtin_exceptions.not_found;
              }
              break;
          
        }
        var v = Curry._3(cache[/* i_repr */0], infos, tab, body);
        Curry._3(KeyTable[/* add */4], tab, ref, v);
        return /* Some */[v];
      }
      catch (raw_exn$1){
        var exn$2 = Js_exn.internalToOCamlException(raw_exn$1);
        if (exn$2 === Caml_builtin_exceptions.not_found) {
          return /* None */0;
        } else if (exn$2[0] === Environ$ReactTemplate.NotEvaluableConst) {
          return /* None */0;
        } else {
          throw exn$2;
        }
      }
    } else {
      throw exn;
    }
  }
}

function evar_value(cache, ev) {
  return Curry._1(cache[/* i_sigma */2], ev);
}

function create(mk_cl, flgs, env, evars) {
  var cache_003 = /* i_rels */Environ$ReactTemplate.pre_env(env)[/* env_rel_context */2][/* env_rel_map */1];
  var cache = /* record */[
    /* i_repr */mk_cl,
    /* i_env */env,
    /* i_sigma */evars,
    cache_003
  ];
  return /* record */[
          /* i_flags */flgs,
          /* i_cache */cache
        ];
}

function neutr(param) {
  if (param !== 1 && param < 3) {
    return /* Whnf */2;
  } else {
    return /* Red */3;
  }
}

function fterm_of(v) {
  return v[/* term */1];
}

function is_val(v) {
  var match = v[/* norm */0];
  if (match !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function mk_atom(c) {
  return /* record */[
          /* norm : Norm */0,
          /* term : FAtom */Block.__(1, [c])
        ];
}

function mk_red(f) {
  return /* record */[
          /* norm : Red */3,
          /* term */f
        ];
}

function update(v1, no, t) {
  if (share[0]) {
    v1[/* norm */0] = no;
    v1[/* term */1] = t;
    return v1;
  } else {
    return /* record */[
            /* norm */no,
            /* term */t
          ];
  }
}

function append_stack(v, s) {
  if (v.length) {
    if (s) {
      var match = s[0];
      if (match.tag) {
        return /* :: */[
                /* Zapp */Block.__(0, [v]),
                s
              ];
      } else {
        return /* :: */[
                /* Zapp */Block.__(0, [Util$ReactTemplate.$$Array[/* append */3](v, match[0])]),
                s[1]
              ];
      }
    } else {
      return /* :: */[
              /* Zapp */Block.__(0, [v]),
              s
            ];
    }
  } else {
    return s;
  }
}

function zshift(n, s) {
  if (n !== 0) {
    if (s) {
      var match = s[0];
      if (match.tag === 4) {
        return /* :: */[
                /* Zshift */Block.__(4, [n + match[0] | 0]),
                s[1]
              ];
      } else {
        return /* :: */[
                /* Zshift */Block.__(4, [n]),
                s
              ];
      }
    } else {
      return /* :: */[
              /* Zshift */Block.__(4, [n]),
              s
            ];
    }
  } else {
    return s;
  }
}

function stack_args_size(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      switch (match.tag | 0) {
        case 0 : 
            return match[0].length + stack_args_size(param[1]) | 0;
        case 4 : 
        case 5 : 
            _param = param[1];
            continue ;
            default:
          return 0;
      }
    } else {
      return 0;
    }
  };
}

function decomp_stack(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (match.tag) {
        return /* None */0;
      } else {
        var s = param[1];
        var v = match[0];
        var match$1 = v.length;
        if (match$1 !== 0) {
          if (match$1 !== 1) {
            return /* Some */[/* tuple */[
                      Caml_array.caml_array_get(v, 0),
                      /* :: */[
                        /* Zapp */Block.__(0, [Util$ReactTemplate.$$Array[/* sub */5](v, 1, v.length - 1 | 0)]),
                        s
                      ]
                    ]];
          } else {
            return /* Some */[/* tuple */[
                      Caml_array.caml_array_get(v, 0),
                      s
                    ]];
          }
        } else {
          _param = s;
          continue ;
          
        }
      }
    } else {
      return /* None */0;
    }
  };
}

function array_of_stack(s) {
  var stackrec = function (param) {
    if (param) {
      var match = param[0];
      if (match.tag) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cClosure.ml",
                441,
                9
              ]
            ];
      } else {
        return /* :: */[
                match[0],
                stackrec(param[1])
              ];
      }
    } else {
      return /* [] */0;
    }
  };
  return Util$ReactTemplate.$$Array[/* concat */4](stackrec(s));
}

function stack_assign(s, p, c) {
  if (s) {
    var match = s[0];
    if (match.tag) {
      return s;
    } else {
      var s$1 = s[1];
      var args = match[0];
      var q = args.length;
      if (p >= q) {
        return /* :: */[
                /* Zapp */Block.__(0, [args]),
                stack_assign(s$1, p - q | 0, c)
              ];
      } else {
        var nargs = Util$ReactTemplate.$$Array[/* copy */6](args);
        Caml_array.caml_array_set(nargs, p, c);
        return /* :: */[
                /* Zapp */Block.__(0, [nargs]),
                s$1
              ];
      }
    }
  } else {
    return s;
  }
}

function stack_tail(_p, _s) {
  while(true) {
    var s = _s;
    var p = _p;
    if (p) {
      if (s) {
        var match = s[0];
        if (match.tag) {
          return Pervasives.failwith("stack_tail");
        } else {
          var s$1 = s[1];
          var args = match[0];
          var q = args.length;
          if (p >= q) {
            _s = s$1;
            _p = p - q | 0;
            continue ;
            
          } else {
            return /* :: */[
                    /* Zapp */Block.__(0, [Util$ReactTemplate.$$Array[/* sub */5](args, p, q - p | 0)]),
                    s$1
                  ];
          }
        }
      } else {
        return Pervasives.failwith("stack_tail");
      }
    } else {
      return s;
    }
  };
}

function stack_nth(_s, _p) {
  while(true) {
    var p = _p;
    var s = _s;
    if (s) {
      var match = s[0];
      if (match.tag) {
        throw Caml_builtin_exceptions.not_found;
      } else {
        var args = match[0];
        var q = args.length;
        if (p >= q) {
          _p = p - q | 0;
          _s = s[1];
          continue ;
          
        } else {
          return Caml_array.caml_array_get(args, p);
        }
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function lft_fconstr(_n, _ft) {
  while(true) {
    var ft = _ft;
    var n = _n;
    var match = ft[/* term */1];
    if (typeof match === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cClosure.ml",
              479,
              17
            ]
          ];
    } else {
      switch (match.tag | 0) {
        case 0 : 
            return /* record */[
                    /* norm : Norm */0,
                    /* term : FRel */Block.__(0, [match[0] + n | 0])
                  ];
        case 3 : 
            switch (match[0].tag | 0) {
              case 0 : 
              case 1 : 
                  return ft;
              case 2 : 
                  return /* record */[
                          /* norm */ft[/* norm */0],
                          /* term : FLIFT */Block.__(15, [
                              n,
                              ft
                            ])
                        ];
              
            }
            break;
        case 4 : 
        case 5 : 
            return ft;
        case 8 : 
            return /* record */[
                    /* norm : Cstr */1,
                    /* term : FFix */Block.__(8, [
                        match[0],
                        Esubst$ReactTemplate.subs_shft(/* tuple */[
                              n,
                              match[1]
                            ])
                      ])
                  ];
        case 9 : 
            return /* record */[
                    /* norm : Cstr */1,
                    /* term : FCoFix */Block.__(9, [
                        match[0],
                        Esubst$ReactTemplate.subs_shft(/* tuple */[
                              n,
                              match[1]
                            ])
                      ])
                  ];
        case 11 : 
            return /* record */[
                    /* norm : Cstr */1,
                    /* term : FLambda */Block.__(11, [
                        match[0],
                        match[1],
                        match[2],
                        Esubst$ReactTemplate.subs_shft(/* tuple */[
                              n,
                              match[3]
                            ])
                      ])
                  ];
        case 15 : 
            _ft = match[1];
            _n = n + match[0] | 0;
            continue ;
            default:
          return /* record */[
                  /* norm */ft[/* norm */0],
                  /* term : FLIFT */Block.__(15, [
                      n,
                      ft
                    ])
                ];
      }
    }
  };
}

function lift_fconstr(k, f) {
  if (k) {
    return lft_fconstr(k, f);
  } else {
    return f;
  }
}

function lift_fconstr_vect(k, v) {
  if (k) {
    return CArray$ReactTemplate.Fun1[/* map */0](lft_fconstr, k, v);
  } else {
    return v;
  }
}

function clos_rel(e, i) {
  var match = Esubst$ReactTemplate.expand_rel(i, e);
  if (match.tag) {
    var match$1 = match[0];
    var match$2 = match$1[1];
    var k = match$1[0];
    if (match$2) {
      var p = match$2[0];
      return lift_fconstr(k - p | 0, /* record */[
                  /* norm : Red */3,
                  /* term : FFlex */Block.__(3, [/* RelKey */Block.__(2, [p])])
                ]);
    } else {
      return /* record */[
              /* norm : Norm */0,
              /* term : FRel */Block.__(0, [k])
            ];
    }
  } else {
    var match$3 = match[0];
    return lift_fconstr(match$3[0], match$3[1]);
  }
}

function compact_stack(head, stk) {
  var _depth = 0;
  var _stk = stk;
  while(true) {
    var stk$1 = _stk;
    var depth = _depth;
    if (stk$1) {
      var match = stk$1[0];
      switch (match.tag | 0) {
        case 4 : 
            _stk = stk$1[1];
            _depth = depth + match[0] | 0;
            continue ;
            case 5 : 
            var h$prime = lft_fconstr(depth, head);
            update(match[0], h$prime[/* norm */0], h$prime[/* term */1]);
            _stk = stk$1[1];
            continue ;
            default:
          return zshift(depth, stk$1);
      }
    } else {
      return zshift(depth, stk$1);
    }
  };
}

function zupdate(m, s) {
  var match = m[/* norm */0];
  if (share[0] && (
      match >= 3 ? /* true */1 : /* false */0
    )) {
    var s$prime = compact_stack(m, s);
    m[/* term */1] = /* FLOCKED */0;
    return /* :: */[
            /* Zupdate */Block.__(5, [m]),
            s$prime
          ];
  } else {
    return s;
  }
}

function mk_lambda(env, t) {
  var match = Term$ReactTemplate.decompose_lam(t);
  var rvars = match[0];
  return /* FLambda */Block.__(11, [
            Curry._1(Util$ReactTemplate.List[/* length */0], rvars),
            Curry._1(Util$ReactTemplate.List[/* rev */4], rvars),
            match[1],
            env
          ]);
}

function destFLambda(clos_fun, t) {
  var match = t[/* term */1];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else if (match.tag === 11) {
    var match$1 = match[1];
    if (match$1) {
      var tys = match$1[1];
      var match$2 = match$1[0];
      var ty = match$2[1];
      var na = match$2[0];
      if (tys) {
        var e = match[3];
        return /* tuple */[
                na,
                Curry._2(clos_fun, e, ty),
                /* record */[
                  /* norm : Cstr */1,
                  /* term : FLambda */Block.__(11, [
                      match[0] - 1 | 0,
                      tys,
                      match[2],
                      Esubst$ReactTemplate.subs_lift(e)
                    ])
                ]
              ];
      } else {
        var e$1 = match[3];
        return /* tuple */[
                na,
                Curry._2(clos_fun, e$1, ty),
                Curry._2(clos_fun, Esubst$ReactTemplate.subs_lift(e$1), match[2])
              ];
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "cClosure.ml",
            525,
            11
          ]
        ];
  }
  
}

function mk_clos(e, t) {
  var match = Constr$ReactTemplate.kind(t);
  switch (match.tag | 0) {
    case 0 : 
        return clos_rel(e, match[0]);
    case 1 : 
        return /* record */[
                /* norm : Red */3,
                /* term : FFlex */Block.__(3, [/* VarKey */Block.__(1, [match[0]])])
              ];
    case 2 : 
    case 4 : 
        return /* record */[
                /* norm : Norm */0,
                /* term : FAtom */Block.__(1, [t])
              ];
    case 10 : 
        return /* record */[
                /* norm : Red */3,
                /* term : FFlex */Block.__(3, [/* ConstKey */Block.__(0, [match[0]])])
              ];
    case 11 : 
        return /* record */[
                /* norm : Norm */0,
                /* term : FInd */Block.__(4, [match[0]])
              ];
    case 12 : 
        return /* record */[
                /* norm : Cstr */1,
                /* term : FConstruct */Block.__(5, [match[0]])
              ];
    default:
      return /* record */[
              /* norm : Red */3,
              /* term : FCLOS */Block.__(16, [
                  t,
                  e
                ])
            ];
  }
}

function mk_clos_vect(env, v) {
  var len = v.length;
  if (len >= 5) {
    return CArray$ReactTemplate.Fun1[/* map */0](mk_clos, env, v);
  } else {
    switch (len) {
      case 0 : 
          return /* array */[];
      case 1 : 
          var v0 = v[0];
          return /* array */[mk_clos(env, v0)];
      case 2 : 
          var v0$1 = v[0];
          var v1 = v[1];
          return /* array */[
                  mk_clos(env, v0$1),
                  mk_clos(env, v1)
                ];
      case 3 : 
          var v0$2 = v[0];
          var v1$1 = v[1];
          var v2 = v[2];
          return /* array */[
                  mk_clos(env, v0$2),
                  mk_clos(env, v1$1),
                  mk_clos(env, v2)
                ];
      case 4 : 
          var v0$3 = v[0];
          var v1$2 = v[1];
          var v2$1 = v[2];
          var v3 = v[3];
          return /* array */[
                  mk_clos(env, v0$3),
                  mk_clos(env, v1$2),
                  mk_clos(env, v2$1),
                  mk_clos(env, v3)
                ];
      
    }
  }
}

function mk_clos_deep(clos_fun, env, t) {
  var match = Constr$ReactTemplate.kind(t);
  switch (match.tag | 0) {
    case 3 : 
        return /* record */[
                /* norm : Red */3,
                /* term : FEvar */Block.__(14, [
                    match[0],
                    env
                  ])
              ];
    case 5 : 
        return /* record */[
                /* norm : Red */3,
                /* term : FCast */Block.__(2, [
                    Curry._2(clos_fun, env, match[0]),
                    match[1],
                    Curry._2(clos_fun, env, match[2])
                  ])
              ];
    case 6 : 
        return /* record */[
                /* norm : Whnf */2,
                /* term : FProd */Block.__(12, [
                    match[0],
                    Curry._2(clos_fun, env, match[1]),
                    Curry._2(clos_fun, Esubst$ReactTemplate.subs_lift(env), match[2])
                  ])
              ];
    case 7 : 
        return /* record */[
                /* norm : Cstr */1,
                /* term */mk_lambda(env, t)
              ];
    case 8 : 
        return /* record */[
                /* norm : Red */3,
                /* term : FLetIn */Block.__(13, [
                    match[0],
                    Curry._2(clos_fun, env, match[1]),
                    Curry._2(clos_fun, env, match[2]),
                    match[3],
                    env
                  ])
              ];
    case 9 : 
        return /* record */[
                /* norm : Red */3,
                /* term : FApp */Block.__(6, [
                    Curry._2(clos_fun, env, match[0]),
                    CArray$ReactTemplate.Fun1[/* map */0](clos_fun, env, match[1])
                  ])
              ];
    case 13 : 
        return /* record */[
                /* norm : Red */3,
                /* term : FCaseT */Block.__(10, [
                    match[0],
                    match[1],
                    Curry._2(clos_fun, env, match[2]),
                    match[3],
                    env
                  ])
              ];
    case 14 : 
        return /* record */[
                /* norm : Cstr */1,
                /* term : FFix */Block.__(8, [
                    match[0],
                    env
                  ])
              ];
    case 15 : 
        return /* record */[
                /* norm : Cstr */1,
                /* term : FCoFix */Block.__(9, [
                    match[0],
                    env
                  ])
              ];
    case 16 : 
        return /* record */[
                /* norm : Red */3,
                /* term : FProj */Block.__(7, [
                    match[0],
                    Curry._2(clos_fun, env, match[1])
                  ])
              ];
    default:
      return mk_clos(env, t);
  }
}

function mk_clos2(param, param$1) {
  return mk_clos_deep(mk_clos, param, param$1);
}

function to_constr(constr_fun, _lfts, _v) {
  while(true) {
    var v = _v;
    var lfts = _lfts;
    var match = v[/* term */1];
    if (typeof match === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cClosure.ml",
              645,
              17
            ]
          ];
    } else {
      switch (match.tag | 0) {
        case 0 : 
            return Constr$ReactTemplate.mkRel(Esubst$ReactTemplate.reloc_rel(match[0], lfts));
        case 1 : 
            return Vars$ReactTemplate.exliftn(lfts, match[0]);
        case 2 : 
            return Constr$ReactTemplate.mkCast(/* tuple */[
                        Curry._2(constr_fun, lfts, match[0]),
                        match[1],
                        Curry._2(constr_fun, lfts, match[2])
                      ]);
        case 3 : 
            var match$1 = match[0];
            switch (match$1.tag | 0) {
              case 0 : 
                  return Constr$ReactTemplate.mkConstU(match$1[0]);
              case 1 : 
                  return Constr$ReactTemplate.mkVar(match$1[0]);
              case 2 : 
                  return Constr$ReactTemplate.mkRel(Esubst$ReactTemplate.reloc_rel(match$1[0], lfts));
              
            }
            break;
        case 4 : 
            return Constr$ReactTemplate.mkIndU(match[0]);
        case 5 : 
            return Constr$ReactTemplate.mkConstructU(match[0]);
        case 6 : 
            return Constr$ReactTemplate.mkApp(/* tuple */[
                        Curry._2(constr_fun, lfts, match[0]),
                        CArray$ReactTemplate.Fun1[/* map */0](constr_fun, lfts, match[1])
                      ]);
        case 7 : 
            return Constr$ReactTemplate.mkProj(/* tuple */[
                        match[0],
                        Curry._2(constr_fun, lfts, match[1])
                      ]);
        case 8 : 
            var e = match[1];
            var match$2 = match[0];
            var match$3 = match$2[1];
            var bds = match$3[2];
            var n = bds.length;
            var ftys = CArray$ReactTemplate.Fun1[/* map */0](mk_clos, e, match$3[1]);
            var fbds = CArray$ReactTemplate.Fun1[/* map */0](mk_clos, Esubst$ReactTemplate.subs_liftn(n, e), bds);
            var lfts$prime = Esubst$ReactTemplate.el_liftn(n, lfts);
            return Constr$ReactTemplate.mkFix(/* tuple */[
                        match$2[0],
                        /* tuple */[
                          match$3[0],
                          CArray$ReactTemplate.Fun1[/* map */0](constr_fun, lfts, ftys),
                          CArray$ReactTemplate.Fun1[/* map */0](constr_fun, lfts$prime, fbds)
                        ]
                      ]);
        case 9 : 
            var e$1 = match[1];
            var match$4 = match[0];
            var match$5 = match$4[1];
            var bds$1 = match$5[2];
            var n$1 = bds$1.length;
            var ftys$1 = CArray$ReactTemplate.Fun1[/* map */0](mk_clos, e$1, match$5[1]);
            var fbds$1 = CArray$ReactTemplate.Fun1[/* map */0](mk_clos, Esubst$ReactTemplate.subs_liftn(n$1, e$1), bds$1);
            var lfts$prime$1 = Esubst$ReactTemplate.el_liftn(bds$1.length, lfts);
            return Constr$ReactTemplate.mkCoFix(/* tuple */[
                        match$4[0],
                        /* tuple */[
                          match$5[0],
                          CArray$ReactTemplate.Fun1[/* map */0](constr_fun, lfts, ftys$1),
                          CArray$ReactTemplate.Fun1[/* map */0](constr_fun, lfts$prime$1, fbds$1)
                        ]
                      ]);
        case 10 : 
            var env = match[4];
            return Constr$ReactTemplate.mkCase(/* tuple */[
                        match[0],
                        Curry._2(constr_fun, lfts, mk_clos(env, match[1])),
                        Curry._2(constr_fun, lfts, match[2]),
                        Util$ReactTemplate.$$Array[/* map */12]((function(lfts,env){
                            return function (b) {
                              return Curry._2(constr_fun, lfts, mk_clos(env, b));
                            }
                            }(lfts,env)), match[3])
                      ]);
        case 11 : 
            var match$6 = destFLambda(mk_clos2, v);
            return Constr$ReactTemplate.mkLambda(/* tuple */[
                        match$6[0],
                        Curry._2(constr_fun, lfts, match$6[1]),
                        Curry._2(constr_fun, Esubst$ReactTemplate.el_lift(lfts), match$6[2])
                      ]);
        case 12 : 
            return Constr$ReactTemplate.mkProd(/* tuple */[
                        match[0],
                        Curry._2(constr_fun, lfts, match[1]),
                        Curry._2(constr_fun, Esubst$ReactTemplate.el_lift(lfts), match[2])
                      ]);
        case 13 : 
            var fc = mk_clos_deep(mk_clos, Esubst$ReactTemplate.subs_lift(match[4]), match[3]);
            return Constr$ReactTemplate.mkLetIn(/* tuple */[
                        match[0],
                        Curry._2(constr_fun, lfts, match[1]),
                        Curry._2(constr_fun, lfts, match[2]),
                        Curry._2(constr_fun, Esubst$ReactTemplate.el_lift(lfts), fc)
                      ]);
        case 14 : 
            var env$1 = match[1];
            var match$7 = match[0];
            return Constr$ReactTemplate.mkEvar(/* tuple */[
                        match$7[0],
                        Util$ReactTemplate.$$Array[/* map */12]((function(lfts,env$1){
                            return function (a) {
                              return Curry._2(constr_fun, lfts, mk_clos_deep(mk_clos, env$1, a));
                            }
                            }(lfts,env$1)), match$7[1])
                      ]);
        case 15 : 
            _v = match[1];
            _lfts = Esubst$ReactTemplate.el_shft(match[0], lfts);
            continue ;
            case 16 : 
            var fr = mk_clos_deep(mk_clos, match[1], match[0]);
            var unfv = update(v, fr[/* norm */0], fr[/* term */1]);
            _v = unfv;
            continue ;
            
      }
    }
  };
}

function term_of_fconstr_lift(lfts, v) {
  var match = v[/* term */1];
  if (typeof match === "number") {
    return to_constr(term_of_fconstr_lift, lfts, v);
  } else {
    switch (match.tag | 0) {
      case 8 : 
          if (Esubst$ReactTemplate.is_subs_id(match[1]) && Esubst$ReactTemplate.is_lift_id(lfts)) {
            return Constr$ReactTemplate.mkFix(match[0]);
          } else {
            return to_constr(term_of_fconstr_lift, lfts, v);
          }
      case 9 : 
          if (Esubst$ReactTemplate.is_subs_id(match[1]) && Esubst$ReactTemplate.is_lift_id(lfts)) {
            return Constr$ReactTemplate.mkCoFix(match[0]);
          } else {
            return to_constr(term_of_fconstr_lift, lfts, v);
          }
      case 11 : 
          if (Esubst$ReactTemplate.is_subs_id(match[3]) && Esubst$ReactTemplate.is_lift_id(lfts)) {
            return Term$ReactTemplate.compose_lam(Curry._1(Util$ReactTemplate.List[/* rev */4], match[1]), match[2]);
          } else {
            return to_constr(term_of_fconstr_lift, lfts, v);
          }
      case 16 : 
          if (Esubst$ReactTemplate.is_subs_id(match[1]) && Esubst$ReactTemplate.is_lift_id(lfts)) {
            return match[0];
          } else {
            return to_constr(term_of_fconstr_lift, lfts, v);
          }
      default:
        return to_constr(term_of_fconstr_lift, lfts, v);
    }
  }
}

function term_of_fconstr(param) {
  return term_of_fconstr_lift(Esubst$ReactTemplate.el_id, param);
}

function fapp_stack(param) {
  var _m = param[0];
  var _stk = param[1];
  while(true) {
    var stk = _stk;
    var m = _m;
    if (stk) {
      var match = stk[0];
      switch (match.tag | 0) {
        case 0 : 
            _stk = stk[1];
            _m = /* record */[
              /* norm */neutr(m[/* norm */0]),
              /* term : FApp */Block.__(6, [
                  m,
                  match[0]
                ])
            ];
            continue ;
            case 1 : 
            var t_000 = match[0];
            var t_001 = match[1];
            var t_003 = match[2];
            var t_004 = match[3];
            var t = /* FCaseT */Block.__(10, [
                t_000,
                t_001,
                m,
                t_003,
                t_004
              ]);
            _stk = stk[1];
            _m = /* record */[
              /* norm */neutr(m[/* norm */0]),
              /* term */t
            ];
            continue ;
            case 2 : 
            _stk = stk[1];
            _m = /* record */[
              /* norm */neutr(m[/* norm */0]),
              /* term : FProj */Block.__(7, [
                  Names$ReactTemplate.Projection[/* make */0](match[2], /* true */1),
                  m
                ])
            ];
            continue ;
            case 3 : 
            _stk = Util$ReactTemplate.$at(match[1], append_stack(/* array */[m], stk[1]));
            _m = match[0];
            continue ;
            case 4 : 
            _stk = stk[1];
            _m = lift_fconstr(match[0], m);
            continue ;
            case 5 : 
            _stk = stk[1];
            _m = update(match[0], m[/* norm */0], m[/* term */1]);
            continue ;
            
      }
    } else {
      return m;
    }
  };
}

function strip_update_shift_app(head, stack) {
  var match = head[/* norm */0];
  if (!(
      match >= 3 ? /* false */0 : /* true */1
    )) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "cClosure.ml",
            710,
            2
          ]
        ];
  }
  var head$1 = head;
  var stk = stack;
  var _rstk = /* [] */0;
  var _h = head$1;
  var _depth = 0;
  var _stk = stk;
  while(true) {
    var stk$1 = _stk;
    var depth = _depth;
    var h = _h;
    var rstk = _rstk;
    if (stk$1) {
      var e = stk$1[0];
      switch (e.tag | 0) {
        case 0 : 
            var args = e[0];
            _stk = stk$1[1];
            _h = /* record */[
              /* norm */h[/* norm */0],
              /* term : FApp */Block.__(6, [
                  h,
                  args
                ])
            ];
            _rstk = /* :: */[
              /* Zapp */Block.__(0, [args]),
              rstk
            ];
            continue ;
            case 4 : 
            var k = e[0];
            _stk = stk$1[1];
            _depth = depth + k | 0;
            _h = lift_fconstr(k, h);
            _rstk = /* :: */[
              e,
              rstk
            ];
            continue ;
            case 5 : 
            _stk = stk$1[1];
            _h = update(e[0], h[/* norm */0], h[/* term */1]);
            continue ;
            default:
          return /* tuple */[
                  depth,
                  Curry._1(Util$ReactTemplate.List[/* rev */4], rstk),
                  stk$1
                ];
      }
    } else {
      return /* tuple */[
              depth,
              Curry._1(Util$ReactTemplate.List[/* rev */4], rstk),
              stk$1
            ];
    }
  };
}

function get_nth_arg(head, n, stk) {
  var match = head[/* norm */0];
  if (!(
      match >= 3 ? /* false */0 : /* true */1
    )) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "cClosure.ml",
            714,
            2
          ]
        ];
  }
  var _rstk = /* [] */0;
  var _h = head;
  var _n = n;
  var _s = stk;
  while(true) {
    var s = _s;
    var n$1 = _n;
    var h = _h;
    var rstk = _rstk;
    var exit = 0;
    if (s) {
      var e = s[0];
      switch (e.tag | 0) {
        case 0 : 
            var s$prime = s[1];
            var args = e[0];
            var q = args.length;
            if (n$1 >= q) {
              _s = s$prime;
              _n = n$1 - q | 0;
              _h = /* record */[
                /* norm */h[/* norm */0],
                /* term : FApp */Block.__(6, [
                    h,
                    args
                  ])
              ];
              _rstk = /* :: */[
                /* Zapp */Block.__(0, [args]),
                rstk
              ];
              continue ;
              
            } else {
              var bef = Util$ReactTemplate.$$Array[/* sub */5](args, 0, n$1);
              var aft = Util$ReactTemplate.$$Array[/* sub */5](args, n$1 + 1 | 0, (q - n$1 | 0) - 1 | 0);
              var stk$prime = Curry._1(Util$ReactTemplate.List[/* rev */4], n$1 ? /* :: */[
                      /* Zapp */Block.__(0, [bef]),
                      rstk
                    ] : rstk);
              return /* tuple */[
                      /* Some */[/* tuple */[
                          stk$prime,
                          Caml_array.caml_array_get(args, n$1)
                        ]],
                      append_stack(aft, s$prime)
                    ];
            }
            break;
        case 4 : 
            _s = s[1];
            _h = lift_fconstr(e[0], h);
            _rstk = /* :: */[
              e,
              rstk
            ];
            continue ;
            case 5 : 
            _s = s[1];
            _h = update(e[0], h[/* norm */0], h[/* term */1]);
            continue ;
            default:
          exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* tuple */[
              /* None */0,
              Util$ReactTemplate.$at(Curry._1(Util$ReactTemplate.List[/* rev */4], rstk), s)
            ];
    }
    
  };
}

function get_args(_n, _tys, f, _e, _stk) {
  while(true) {
    var stk = _stk;
    var e = _e;
    var tys = _tys;
    var n = _n;
    var exit = 0;
    if (stk) {
      var match = stk[0];
      switch (match.tag | 0) {
        case 0 : 
            var s = stk[1];
            var l = match[0];
            var na = l.length;
            if (n === na) {
              return /* tuple */[
                      /* Inl */Block.__(0, [Esubst$ReactTemplate.subs_cons(/* tuple */[
                                l,
                                e
                              ])]),
                      s
                    ];
            } else if (n < na) {
              var args = Util$ReactTemplate.$$Array[/* sub */5](l, 0, n);
              var eargs = Util$ReactTemplate.$$Array[/* sub */5](l, n, na - n | 0);
              return /* tuple */[
                      /* Inl */Block.__(0, [Esubst$ReactTemplate.subs_cons(/* tuple */[
                                args,
                                e
                              ])]),
                      /* :: */[
                        /* Zapp */Block.__(0, [eargs]),
                        s
                      ]
                    ];
            } else {
              var etys = Curry._2(Util$ReactTemplate.List[/* skipn */107], na, tys);
              _stk = s;
              _e = Esubst$ReactTemplate.subs_cons(/* tuple */[
                    l,
                    e
                  ]);
              _tys = etys;
              _n = n - na | 0;
              continue ;
              
            }
            break;
        case 4 : 
            _stk = stk[1];
            _e = Esubst$ReactTemplate.subs_shft(/* tuple */[
                  match[0],
                  e
                ]);
            continue ;
            case 5 : 
            update(match[0], /* Cstr */1, /* FLambda */Block.__(11, [
                    n,
                    tys,
                    f,
                    e
                  ]));
            _stk = stk[1];
            continue ;
            default:
          exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* tuple */[
              /* Inr */Block.__(1, [/* record */[
                    /* norm : Cstr */1,
                    /* term : FLambda */Block.__(11, [
                        n,
                        tys,
                        f,
                        e
                      ])
                  ]]),
              stk
            ];
    }
    
  };
}

function eta_expand_stack(param) {
  if (param) {
    return /* :: */[
            param[0],
            eta_expand_stack(param[1])
          ];
  } else {
    return /* :: */[
            /* Zshift */Block.__(4, [1]),
            /* :: */[
              /* Zapp */Block.__(0, [/* array */[/* record */[
                      /* norm : Norm */0,
                      /* term : FRel */Block.__(0, [1])
                    ]]]),
              /* [] */0
            ]
          ];
  }
}

function reloc_rargs_rec(_depth, _stk) {
  while(true) {
    var stk = _stk;
    var depth = _depth;
    if (stk) {
      var match = stk[0];
      switch (match.tag | 0) {
        case 0 : 
            return /* :: */[
                    /* Zapp */Block.__(0, [lift_fconstr_vect(depth, match[0])]),
                    reloc_rargs_rec(depth, stk[1])
                  ];
        case 4 : 
            var s = stk[1];
            var k = match[0];
            if (k === depth) {
              return s;
            } else {
              _stk = s;
              _depth = depth - k | 0;
              continue ;
              
            }
            break;
        default:
          return stk;
      }
    } else {
      return stk;
    }
  };
}

function reloc_rargs(depth, stk) {
  if (depth) {
    return reloc_rargs_rec(depth, stk);
  } else {
    return stk;
  }
}

function try_drop_parameters(_depth, _n, _argstk) {
  while(true) {
    var argstk = _argstk;
    var n = _n;
    var depth = _depth;
    if (argstk) {
      var match = argstk[0];
      switch (match.tag | 0) {
        case 0 : 
            var s = argstk[1];
            var args = match[0];
            var q = args.length;
            if (n > q) {
              _argstk = s;
              _n = n - q | 0;
              continue ;
              
            } else if (n === q) {
              return reloc_rargs(depth, s);
            } else {
              var aft = Util$ReactTemplate.$$Array[/* sub */5](args, n, q - n | 0);
              return reloc_rargs(depth, append_stack(aft, s));
            }
            break;
        case 4 : 
            _argstk = argstk[1];
            _depth = depth - match[0] | 0;
            continue ;
            default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "cClosure.ml",
                  788,
                  11
                ]
              ];
      }
    } else if (n) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      return /* [] */0;
    }
  };
}

function drop_parameters(depth, n, argstk) {
  try {
    return try_drop_parameters(depth, n, argstk);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("ill-typed term: found a match on a partially applied constructor."));
    } else {
      throw exn;
    }
  }
}

function eta_expand_ind_stack(env, ind, m, s, param) {
  var mib = Environ$ReactTemplate.lookup_mind(ind[0], env);
  var match = mib[/* mind_record */1];
  if (match) {
    var match$1 = match[0];
    if (match$1) {
      if (mib[/* mind_finite */2] === /* BiFinite */2) {
        var pars = mib[/* mind_nparams */5];
        var right = fapp_stack(/* tuple */[
              param[0],
              param[1]
            ]);
        var match$2 = strip_update_shift_app(m, s);
        var argss = try_drop_parameters(match$2[0], pars, match$2[1]);
        var hstack = Util$ReactTemplate.$$Array[/* map */12]((function (p) {
                return /* record */[
                        /* norm : Red */3,
                        /* term : FProj */Block.__(7, [
                            Names$ReactTemplate.Projection[/* make */0](p, /* true */1),
                            right
                          ])
                      ];
              }), match$1[0][1]);
        return /* tuple */[
                argss,
                /* :: */[
                  /* Zapp */Block.__(0, [hstack]),
                  /* [] */0
                ]
              ];
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function project_nth_arg(_n, _argstk) {
  while(true) {
    var argstk = _argstk;
    var n = _n;
    if (argstk) {
      var match = argstk[0];
      if (match.tag) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cClosure.ml",
                829,
                9
              ]
            ];
      } else {
        var args = match[0];
        var q = args.length;
        if (n >= q) {
          _argstk = argstk[1];
          _n = n - q | 0;
          continue ;
          
        } else {
          return Caml_array.caml_array_get(args, n);
        }
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cClosure.ml",
              829,
              9
            ]
          ];
    }
  };
}

function contract_fix_vect(fix) {
  var match;
  if (typeof fix === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "cClosure.ml",
            853,
            13
          ]
        ];
  } else {
    switch (fix.tag | 0) {
      case 8 : 
          var env = fix[1];
          var match$1 = fix[0];
          var rdcl = match$1[1];
          var bds = rdcl[2];
          var match$2 = match$1[0];
          var reci = match$2[0];
          match = /* tuple */[
            Caml_array.caml_array_get(bds, match$2[1]),
            (function (j) {
                return /* record */[
                        /* norm : Cstr */1,
                        /* term : FFix */Block.__(8, [
                            /* tuple */[
                              /* tuple */[
                                reci,
                                j
                              ],
                              rdcl
                            ],
                            env
                          ])
                      ];
              }),
            env,
            bds.length
          ];
          break;
      case 9 : 
          var env$1 = fix[1];
          var match$3 = fix[0];
          var rdcl$1 = match$3[1];
          var bds$1 = rdcl$1[2];
          match = /* tuple */[
            Caml_array.caml_array_get(bds$1, match$3[0]),
            (function (j) {
                return /* record */[
                        /* norm : Cstr */1,
                        /* term : FCoFix */Block.__(9, [
                            /* tuple */[
                              j,
                              rdcl$1
                            ],
                            env$1
                          ])
                      ];
              }),
            env$1,
            bds$1.length
          ];
          break;
      default:
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cClosure.ml",
                853,
                13
              ]
            ];
    }
  }
  return /* tuple */[
          Esubst$ReactTemplate.subs_cons(/* tuple */[
                Util$ReactTemplate.$$Array[/* init */0](match[3], match[1]),
                match[2]
              ]),
          match[0]
        ];
}

function unfold_projection(info, p) {
  if (red_projection(info[/* i_flags */0], p)) {
    var pb = Environ$ReactTemplate.lookup_projection(p, info[/* i_cache */1][/* i_env */1]);
    return /* Some */[/* Zproj */Block.__(2, [
                pb[/* proj_npars */1],
                pb[/* proj_arg */2],
                Names$ReactTemplate.Projection[/* constant */2](p)
              ])];
  } else {
    return /* None */0;
  }
}

function knh(info, _m, _stk) {
  while(true) {
    var stk = _stk;
    var m = _m;
    var match = m[/* term */1];
    if (typeof match === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cClosure.ml",
              874,
              17
            ]
          ];
    } else {
      switch (match.tag | 0) {
        case 2 : 
            _m = match[0];
            continue ;
            case 6 : 
            _stk = append_stack(match[1], zupdate(m, stk));
            _m = match[0];
            continue ;
            case 7 : 
            var match$1 = unfold_projection(info, match[0]);
            if (match$1) {
              _stk = /* :: */[
                match$1[0],
                zupdate(m, stk)
              ];
              _m = match[1];
              continue ;
              
            } else {
              return /* tuple */[
                      m,
                      stk
                    ];
            }
            break;
        case 8 : 
            var match$2 = match[0][0];
            var match$3 = get_nth_arg(m, Caml_array.caml_array_get(match$2[0], match$2[1]), stk);
            var match$4 = match$3[0];
            if (match$4) {
              var match$5 = match$4[0];
              _stk = /* :: */[
                /* Zfix */Block.__(3, [
                    m,
                    match$5[0]
                  ]),
                match$3[1]
              ];
              _m = match$5[1];
              continue ;
              
            } else {
              return /* tuple */[
                      m,
                      match$3[1]
                    ];
            }
            break;
        case 10 : 
            _stk = /* :: */[
              /* ZcaseT */Block.__(1, [
                  match[0],
                  match[1],
                  match[3],
                  match[4]
                ]),
              zupdate(m, stk)
            ];
            _m = match[2];
            continue ;
            case 15 : 
            _stk = zshift(match[0], stk);
            _m = match[1];
            continue ;
            case 16 : 
            return knht(info, match[1], match[0], zupdate(m, stk));
        default:
          return /* tuple */[
                  m,
                  stk
                ];
      }
    }
  };
}

function knht(info, e, _t, _stk) {
  while(true) {
    var stk = _stk;
    var t = _t;
    var match = Constr$ReactTemplate.kind(t);
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          return knh(info, clos_rel(e, match[0]), stk);
      case 5 : 
          _t = match[0];
          continue ;
          case 9 : 
          _stk = append_stack(mk_clos_vect(e, match[1]), stk);
          _t = match[0];
          continue ;
          case 13 : 
          _stk = /* :: */[
            /* ZcaseT */Block.__(1, [
                match[0],
                match[1],
                match[3],
                e
              ]),
            stk
          ];
          _t = match[2];
          continue ;
          case 14 : 
      case 16 : 
          exit = 1;
          break;
      default:
        return /* tuple */[
                mk_clos_deep(mk_clos, e, t),
                stk
              ];
    }
    if (exit === 1) {
      return knh(info, mk_clos_deep(mk_clos, e, t), stk);
    }
    
  };
}

function knr(info, tab, m, stk) {
  var match = m[/* term */1];
  if (typeof match === "number") {
    return /* tuple */[
            m,
            stk
          ];
  } else {
    switch (match.tag | 0) {
      case 3 : 
          var match$1 = match[0];
          switch (match$1.tag | 0) {
            case 0 : 
                var c = match$1[0];
                if (red_set(info[/* i_flags */0], /* CONST */Block.__(0, [c[0]]))) {
                  var match$2 = ref_value_cache(info, tab, /* ConstKey */Block.__(0, [c]));
                  if (match$2) {
                    return kni(info, tab, match$2[0], stk);
                  } else {
                    m[/* norm */0] = /* Norm */0;
                    return /* tuple */[
                            m,
                            stk
                          ];
                  }
                } else {
                  return /* tuple */[
                          m,
                          stk
                        ];
                }
                break;
            case 1 : 
                var id = match$1[0];
                if (red_set(info[/* i_flags */0], /* VAR */Block.__(1, [id]))) {
                  var match$3 = ref_value_cache(info, tab, /* VarKey */Block.__(1, [id]));
                  if (match$3) {
                    return kni(info, tab, match$3[0], stk);
                  } else {
                    m[/* norm */0] = /* Norm */0;
                    return /* tuple */[
                            m,
                            stk
                          ];
                  }
                } else {
                  return /* tuple */[
                          m,
                          stk
                        ];
                }
                break;
            case 2 : 
                if (red_set(info[/* i_flags */0], /* DELTA */1)) {
                  var match$4 = ref_value_cache(info, tab, /* RelKey */Block.__(2, [match$1[0]]));
                  if (match$4) {
                    return kni(info, tab, match$4[0], stk);
                  } else {
                    m[/* norm */0] = /* Norm */0;
                    return /* tuple */[
                            m,
                            stk
                          ];
                  }
                } else {
                  return /* tuple */[
                          m,
                          stk
                        ];
                }
                break;
            
          }
          break;
      case 5 : 
          var use_match = red_set(info[/* i_flags */0], /* MATCH */3);
          var use_fix = red_set(info[/* i_flags */0], /* FIX */4);
          if (use_match || use_fix) {
            var match$5 = strip_update_shift_app(m, stk);
            var s = match$5[2];
            var args = match$5[1];
            var depth = match$5[0];
            var exit = 0;
            if (s) {
              var match$6 = s[0];
              switch (match$6.tag | 0) {
                case 1 : 
                    if (use_match) {
                      var ci = match$6[0];
                      if (ci[/* ci_npar */1] < 0) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "cClosure.ml",
                                935,
                                12
                              ]
                            ];
                      }
                      var rargs = drop_parameters(depth, ci[/* ci_npar */1], args);
                      return knit(info, tab, match$6[3], Caml_array.caml_array_get(match$6[2], match[0][0][1] - 1 | 0), Util$ReactTemplate.$at(rargs, s[1]));
                    } else {
                      exit = 1;
                    }
                    break;
                case 2 : 
                    if (use_match) {
                      var rargs$1 = drop_parameters(depth, match$6[0], args);
                      var rarg = project_nth_arg(match$6[1], rargs$1);
                      return kni(info, tab, rarg, s[1]);
                    } else {
                      exit = 1;
                    }
                    break;
                case 3 : 
                    if (use_fix) {
                      var rarg$1 = fapp_stack(/* tuple */[
                            m,
                            args
                          ]);
                      var stk$prime = Util$ReactTemplate.$at(match$6[1], append_stack(/* array */[rarg$1], s[1]));
                      var match$7 = contract_fix_vect(match$6[0][/* term */1]);
                      return knit(info, tab, match$7[0], match$7[1], stk$prime);
                    } else {
                      exit = 1;
                    }
                    break;
                default:
                  exit = 1;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              return /* tuple */[
                      m,
                      Util$ReactTemplate.$at(args, s)
                    ];
            }
            
          } else {
            return /* tuple */[
                    m,
                    stk
                  ];
          }
          break;
      case 9 : 
          if (red_set(info[/* i_flags */0], /* COFIX */5)) {
            var match$8 = strip_update_shift_app(m, stk);
            var stk$prime$1 = match$8[2];
            var args$1 = match$8[1];
            if (stk$prime$1) {
              var exit$1 = 0;
              switch (stk$prime$1[0].tag | 0) {
                case 1 : 
                case 2 : 
                    exit$1 = 1;
                    break;
                default:
                  return /* tuple */[
                          m,
                          Util$ReactTemplate.$at(args$1, stk$prime$1)
                        ];
              }
              if (exit$1 === 1) {
                var match$9 = contract_fix_vect(m[/* term */1]);
                return knit(info, tab, match$9[0], match$9[1], Util$ReactTemplate.$at(args$1, stk$prime$1));
              }
              
            } else {
              return /* tuple */[
                      m,
                      Util$ReactTemplate.$at(args$1, stk$prime$1)
                    ];
            }
          } else {
            return /* tuple */[
                    m,
                    stk
                  ];
          }
          break;
      case 11 : 
          var f = match[2];
          if (red_set(info[/* i_flags */0], /* BETA */0)) {
            var match$10 = get_args(match[0], match[1], f, match[3], stk);
            var match$11 = match$10[0];
            if (match$11.tag) {
              return /* tuple */[
                      match$11[0],
                      match$10[1]
                    ];
            } else {
              return knit(info, tab, match$11[0], f, match$10[1]);
            }
          } else {
            return /* tuple */[
                    m,
                    stk
                  ];
          }
          break;
      case 13 : 
          if (red_set(info[/* i_flags */0], /* ZETA */6)) {
            return knit(info, tab, Esubst$ReactTemplate.subs_cons(/* tuple */[
                            /* array */[match[1]],
                            match[4]
                          ]), match[3], stk);
          } else {
            return /* tuple */[
                    m,
                    stk
                  ];
          }
      case 14 : 
          var match$12 = Curry._1(info[/* i_cache */1][/* i_sigma */2], match[0]);
          if (match$12) {
            return knit(info, tab, match[1], match$12[0], stk);
          } else {
            return /* tuple */[
                    m,
                    stk
                  ];
          }
      default:
        return /* tuple */[
                m,
                stk
              ];
    }
  }
}

function kni(info, tab, m, stk) {
  var match = knh(info, m, stk);
  return knr(info, tab, match[0], match[1]);
}

function knit(info, tab, e, t, stk) {
  var match = knht(info, e, t, stk);
  return knr(info, tab, match[0], match[1]);
}

function kh(info, tab, v, stk) {
  return fapp_stack(kni(info, tab, v, stk));
}

function zip_term(zfun, _m, _stk) {
  while(true) {
    var stk = _stk;
    var m = _m;
    if (stk) {
      var match = stk[0];
      switch (match.tag | 0) {
        case 0 : 
            _stk = stk[1];
            _m = Constr$ReactTemplate.mkApp(/* tuple */[
                  m,
                  Util$ReactTemplate.$$Array[/* map */12](zfun, match[0])
                ]);
            continue ;
            case 1 : 
            var e = match[3];
            var t = Constr$ReactTemplate.mkCase(/* tuple */[
                  match[0],
                  Curry._1(zfun, mk_clos(e, match[1])),
                  m,
                  Util$ReactTemplate.$$Array[/* map */12]((function(e){
                      return function (b) {
                        return Curry._1(zfun, mk_clos(e, b));
                      }
                      }(e)), match[2])
                ]);
            _stk = stk[1];
            _m = t;
            continue ;
            case 2 : 
            var t$1 = Constr$ReactTemplate.mkProj(/* tuple */[
                  Names$ReactTemplate.Projection[/* make */0](match[2], /* true */1),
                  m
                ]);
            _stk = stk[1];
            _m = t$1;
            continue ;
            case 3 : 
            var h = Constr$ReactTemplate.mkApp(/* tuple */[
                  zip_term(zfun, Curry._1(zfun, match[0]), match[1]),
                  /* array */[m]
                ]);
            _stk = stk[1];
            _m = h;
            continue ;
            case 4 : 
            _stk = stk[1];
            _m = Vars$ReactTemplate.lift(match[0])(m);
            continue ;
            case 5 : 
            _stk = stk[1];
            continue ;
            
      }
    } else {
      return m;
    }
  };
}

function kl(info, tab, m) {
  if (is_val(m)) {
    prune[0] = prune[0] + 1 | 0;
    return term_of_fconstr(m);
  } else {
    var match = kni(info, tab, m, /* [] */0);
    var s = match[1];
    var nm = match[0];
    if (share[0]) {
      fapp_stack(/* tuple */[
            nm,
            s
          ]);
    }
    return zip_term((function (param) {
                  return kl(info, tab, param);
                }), norm_head(info, tab, nm), s);
  }
}

function norm_head(info, tab, m) {
  if (is_val(m)) {
    prune[0] = prune[0] + 1 | 0;
    return term_of_fconstr(m);
  } else {
    var match = m[/* term */1];
    if (typeof match === "number") {
      return term_of_fconstr(m);
    } else {
      switch (match.tag | 0) {
        case 7 : 
            return Constr$ReactTemplate.mkProj(/* tuple */[
                        match[0],
                        kl(info, tab, match[1])
                      ]);
        case 8 : 
            var e = match[1];
            var match$1 = match[0];
            var match$2 = match$1[1];
            var na = match$2[0];
            var ftys = CArray$ReactTemplate.Fun1[/* map */0](mk_clos, e, match$2[1]);
            var fbds = CArray$ReactTemplate.Fun1[/* map */0](mk_clos, Esubst$ReactTemplate.subs_liftn(na.length, e), match$2[2]);
            return Constr$ReactTemplate.mkFix(/* tuple */[
                        match$1[0],
                        /* tuple */[
                          na,
                          CArray$ReactTemplate.map((function (param) {
                                  return kl(info, tab, param);
                                }), ftys),
                          CArray$ReactTemplate.map((function (param) {
                                  return kl(info, tab, param);
                                }), fbds)
                        ]
                      ]);
        case 9 : 
            var e$1 = match[1];
            var match$3 = match[0];
            var match$4 = match$3[1];
            var na$1 = match$4[0];
            var ftys$1 = CArray$ReactTemplate.Fun1[/* map */0](mk_clos, e$1, match$4[1]);
            var fbds$1 = CArray$ReactTemplate.Fun1[/* map */0](mk_clos, Esubst$ReactTemplate.subs_liftn(na$1.length, e$1), match$4[2]);
            return Constr$ReactTemplate.mkCoFix(/* tuple */[
                        match$3[0],
                        /* tuple */[
                          na$1,
                          CArray$ReactTemplate.map((function (param) {
                                  return kl(info, tab, param);
                                }), ftys$1),
                          CArray$ReactTemplate.map((function (param) {
                                  return kl(info, tab, param);
                                }), fbds$1)
                        ]
                      ]);
        case 11 : 
            var match$5 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                    var e = param[0];
                    return /* tuple */[
                            Esubst$ReactTemplate.subs_lift(e),
                            /* :: */[
                              /* tuple */[
                                param$1[0],
                                kl(info, tab, mk_clos(e, param$1[1]))
                              ],
                              param[1]
                            ]
                          ];
                  }), /* tuple */[
                  match[3],
                  /* [] */0
                ], match[1]);
            var bd = kl(info, tab, mk_clos(match$5[0], match[2]));
            return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (b, param) {
                          return Constr$ReactTemplate.mkLambda(/* tuple */[
                                      param[0],
                                      param[1],
                                      b
                                    ]);
                        }), bd, match$5[1]);
        case 12 : 
            return Constr$ReactTemplate.mkProd(/* tuple */[
                        match[0],
                        kl(info, tab, match[1]),
                        kl(info, tab, match[2])
                      ]);
        case 13 : 
            var c = mk_clos(Esubst$ReactTemplate.subs_lift(match[4]), match[3]);
            return Constr$ReactTemplate.mkLetIn(/* tuple */[
                        match[0],
                        kl(info, tab, match[1]),
                        kl(info, tab, match[2]),
                        kl(info, tab, c)
                      ]);
        case 14 : 
            var env = match[1];
            var match$6 = match[0];
            return Constr$ReactTemplate.mkEvar(/* tuple */[
                        match$6[0],
                        Util$ReactTemplate.$$Array[/* map */12]((function (a) {
                                return kl(info, tab, mk_clos(env, a));
                              }), match$6[1])
                      ]);
        default:
          return term_of_fconstr(m);
      }
    }
  }
}

function whd_val(info, tab, v) {
  return with_stats(Block.__(246, [(function () {
                    return term_of_fconstr(kh(info, tab, v, /* [] */0));
                  })]));
}

function norm_val(info, tab, v) {
  return with_stats(Block.__(246, [(function () {
                    return kl(info, tab, v);
                  })]));
}

function inject(c) {
  return mk_clos(Esubst$ReactTemplate.subs_id(0), c);
}

function whd_stack(infos, tab, m, stk) {
  var k = kni(infos, tab, m, stk);
  if (share[0]) {
    fapp_stack(k);
  }
  return k;
}

function create_clos_infos($staropt$star, flgs, env) {
  var evars = $staropt$star ? $staropt$star[0] : (function () {
        return /* None */0;
      });
  return create((function (_, _$1, c) {
                return mk_clos(Esubst$ReactTemplate.subs_id(0), c);
              }), flgs, env, evars);
}

function create_tab() {
  return Curry._1(KeyTable[/* create */0], 17);
}

function oracle_of_infos(infos) {
  return Environ$ReactTemplate.oracle(infos[/* i_cache */1][/* i_env */1]);
}

function env_of_infos(infos) {
  return infos[/* i_cache */1][/* i_env */1];
}

function infos_with_reds(infos, reds) {
  return /* record */[
          /* i_flags */reds,
          /* i_cache */infos[/* i_cache */1]
        ];
}

function unfold_reference(info, tab, key) {
  switch (key.tag | 0) {
    case 0 : 
        if (red_set(info[/* i_flags */0], /* CONST */Block.__(0, [key[0][0]]))) {
          return ref_value_cache(info, tab, key);
        } else {
          return /* None */0;
        }
    case 1 : 
        if (red_set(info[/* i_flags */0], /* VAR */Block.__(1, [key[0]]))) {
          return ref_value_cache(info, tab, key);
        } else {
          return /* None */0;
        }
    case 2 : 
        return ref_value_cache(info, tab, key);
    
  }
}

var nored = no_red;

var empty_stack = /* [] */0;

var eq_table_key = equal;

exports.stats = stats;
exports.share = share;
exports.with_stats = with_stats;
exports.all_opaque = all_opaque;
exports.all_transparent = all_transparent;
exports.is_transparent_variable = is_transparent_variable;
exports.is_transparent_constant = is_transparent_constant;
exports.RedFlags = RedFlags;
exports.all = all;
exports.allnolet = allnolet;
exports.beta = beta$1;
exports.betadeltazeta = betadeltazeta;
exports.betaiota = betaiota;
exports.betaiotazeta = betaiotazeta;
exports.betazeta = betazeta;
exports.delta = delta$1;
exports.zeta = zeta$1;
exports.nored = nored;
exports.unfold_side_red = unfold_side_red;
exports.unfold_red = unfold_red;
exports.ref_value_cache = ref_value_cache;
exports.create = create;
exports.create_tab = create_tab;
exports.evar_value = evar_value;
exports.info_env = info_env;
exports.info_flags = info_flags;
exports.empty_stack = empty_stack;
exports.append_stack = append_stack;
exports.decomp_stack = decomp_stack;
exports.array_of_stack = array_of_stack;
exports.stack_assign = stack_assign;
exports.stack_args_size = stack_args_size;
exports.stack_tail = stack_tail;
exports.stack_nth = stack_nth;
exports.zip_term = zip_term;
exports.eta_expand_stack = eta_expand_stack;
exports.unfold_projection = unfold_projection;
exports.inject = inject;
exports.mk_atom = mk_atom;
exports.mk_red = mk_red;
exports.fterm_of = fterm_of;
exports.term_of_fconstr = term_of_fconstr;
exports.destFLambda = destFLambda;
exports.create_clos_infos = create_clos_infos;
exports.oracle_of_infos = oracle_of_infos;
exports.env_of_infos = env_of_infos;
exports.infos_with_reds = infos_with_reds;
exports.norm_val = norm_val;
exports.whd_val = whd_val;
exports.whd_stack = whd_stack;
exports.eta_expand_ind_stack = eta_expand_ind_stack;
exports.unfold_reference = unfold_reference;
exports.eq_table_key = eq_table_key;
exports.lift_fconstr = lift_fconstr;
exports.lift_fconstr_vect = lift_fconstr_vect;
exports.mk_clos = mk_clos;
exports.mk_clos_vect = mk_clos_vect;
exports.mk_clos_deep = mk_clos_deep;
exports.kni = kni;
exports.knr = knr;
exports.kl = kl;
exports.to_constr = to_constr;
/* mkflags Not a pure module */
