// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Set = require("bs-platform/lib/js/set.js");
var Sys = require("bs-platform/lib/js/sys.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var CMap$ReactTemplate = require("./cMap.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function hash(i) {
  return i & 1073741823;
}

var compare = Caml_primitive.caml_int_compare;

var Self = /* module */[/* compare */compare];

var $$Set$1 = $$Set.Make(Self);

var include = CMap$ReactTemplate.Make(Self);

var empty = include[0];

var bind = include[28];

function find(i, _s) {
  while(true) {
    var s = _s;
    if (s) {
      var k = s[1];
      if (i < k) {
        _s = s[0];
        continue ;
        
      } else if (i === k) {
        return s[2];
      } else {
        _s = s[3];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

var List$1 = /* module */[
  /* mem */List.memq,
  /* assoc */List.assq,
  /* mem_assoc */List.mem_assq,
  /* remove_assoc */List.remove_assq
];

function min(i, j) {
  if (i < j) {
    return i;
  } else {
    return j;
  }
}

function next(_from, upto) {
  while(true) {
    var from = _from;
    if (from < upto) {
      _from = (from << 1) + 1 | 0;
      continue ;
      
    } else {
      return from;
    }
  };
}

function empty$1(n) {
  return [/* Root */Block.__(0, [Caml_array.caml_make_vect(n, /* None */0)])];
}

function rerootk(_t, _k) {
  while(true) {
    var k = _k;
    var t = _t;
    var match = t[0];
    if (match.tag) {
      var t$prime = match[2];
      var v = match[1];
      var i = match[0];
      var next = (function(t,k,i,v,t$prime){
      return function next() {
        var n = t$prime[0];
        if (n.tag) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "int.ml",
                  81,
                  16
                ]
              ];
        } else {
          var a = n[0];
          var v$prime = a[i];
          a[i] = v;
          t[0] = n;
          t$prime[0] = /* DSet */Block.__(1, [
              i,
              v$prime,
              t
            ]);
          return Curry._1(k, /* () */0);
        }
      }
      }(t,k,i,v,t$prime));
      _k = next;
      _t = t$prime;
      continue ;
      
    } else {
      return Curry._1(k, /* () */0);
    }
  };
}

function get(t, i) {
  if (0 > i) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "int.ml",
            88,
            11
          ]
        ];
  }
  var match = t[0];
  if (match.tag) {
    rerootk(t, (function () {
            return /* () */0;
          }));
    var match$1 = t[0];
    if (match$1.tag) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "int.ml",
              99,
              16
            ]
          ];
    } else {
      var a = match$1[0];
      if (a.length <= i) {
        return /* None */0;
      } else {
        return a[i];
      }
    }
  } else {
    var a$1 = match[0];
    if (a$1.length <= i) {
      return /* None */0;
    } else {
      return a$1[i];
    }
  }
}

function set(t, i, v) {
  if (0 > i) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "int.ml",
            102,
            13
          ]
        ];
  }
  rerootk(t, (function () {
          return /* () */0;
        }));
  var n = t[0];
  if (n.tag) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "int.ml",
            105,
            16
          ]
        ];
  } else {
    var a = n[0];
    var len = a.length;
    if (i < len) {
      var old = a[i];
      if (old === v) {
        return t;
      } else {
        a[i] = v;
        var res = [n];
        t[0] = /* DSet */Block.__(1, [
            i,
            old,
            res
          ]);
        return res;
      }
    } else if (v) {
      var nlen = next(len, i + 1 | 0);
      var nlen$1 = min(nlen, Sys.max_array_length);
      if (i >= nlen$1) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "int.ml",
                121,
                17
              ]
            ];
      }
      var a$prime = Caml_array.caml_make_vect(nlen$1, /* None */0);
      $$Array.blit(a, 0, a$prime, 0, len);
      a$prime[i] = v;
      var res$1 = [/* Root */Block.__(0, [a$prime])];
      t[0] = /* DSet */Block.__(1, [
          i,
          /* None */0,
          res$1
        ]);
      return res$1;
    } else {
      return t;
    }
  }
}

function is_empty(param) {
  if (param) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function singleton(k, x) {
  var len = next(19, k + 1 | 0);
  var len$1 = min(Sys.max_array_length, len);
  var v = empty$1(len$1);
  var v$1 = set(v, k, /* Some */[x]);
  var s = Curry._1($$Set$1[/* singleton */4], k);
  return /* Map */[
          s,
          v$1
        ];
}

function add(k, x, param) {
  if (param) {
    var v = param[1];
    var s = param[0];
    var match = get(v, k);
    var s$1 = match ? s : Curry._2($$Set$1[/* add */3], k, s);
    var v$1 = set(v, k, /* Some */[x]);
    return /* Map */[
            s$1,
            v$1
          ];
  } else {
    return singleton(k, x);
  }
}

function remove(k, param) {
  if (param) {
    var s = Curry._2($$Set$1[/* remove */5], k, param[0]);
    if (Curry._1($$Set$1[/* is_empty */1], s)) {
      return /* Empty */0;
    } else {
      var v = set(param[1], k, /* None */0);
      return /* Map */[
              s,
              v
            ];
    }
  } else {
    return /* Empty */0;
  }
}

function mem(k, param) {
  if (param) {
    var match = get(param[1], k);
    if (match) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function find$1(k, param) {
  if (param) {
    var match = get(param[1], k);
    if (match) {
      return match[0];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function iter(f, param) {
  if (param) {
    var v = param[1];
    var iter$1 = function (k) {
      var match = get(v, k);
      if (match) {
        return Curry._2(f, k, match[0]);
      } else {
        return /* () */0;
      }
    };
    return Curry._2($$Set$1[/* iter */12], iter$1, param[0]);
  } else {
    return /* () */0;
  }
}

function fold(f, m, accu) {
  if (m) {
    var v = m[1];
    var fold$1 = function (k, accu) {
      var match = get(v, k);
      if (match) {
        return Curry._3(f, k, match[0], accu);
      } else {
        return accu;
      }
    };
    return Curry._3($$Set$1[/* fold */13], fold$1, m[0], accu);
  } else {
    return accu;
  }
}

function exists(f, m) {
  if (m) {
    var v = m[1];
    var exists$1 = function (k) {
      var match = get(v, k);
      if (match) {
        return Curry._2(f, k, match[0]);
      } else {
        return /* false */0;
      }
    };
    return Curry._2($$Set$1[/* exists */15], exists$1, m[0]);
  } else {
    return /* false */0;
  }
}

function for_all(f, m) {
  if (m) {
    var v = m[1];
    var for_all$1 = function (k) {
      var match = get(v, k);
      if (match) {
        return Curry._2(f, k, match[0]);
      } else {
        return /* true */1;
      }
    };
    return Curry._2($$Set$1[/* for_all */14], for_all$1, m[0]);
  } else {
    return /* true */1;
  }
}

function cast(param) {
  if (param) {
    var v = param[1];
    var bind$1 = function (k) {
      var match = get(v, k);
      if (match) {
        return match[0];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "int.ml",
                230,
                14
              ]
            ];
      }
    };
    return Curry._2(bind, bind$1, param[0]);
  } else {
    return empty;
  }
}

function domain(param) {
  if (param) {
    return param[0];
  } else {
    return $$Set$1[/* empty */0];
  }
}

var Map_001 = include[1];

var Map_002 = include[2];

var Map_003 = include[3];

var Map_004 = include[4];

var Map_005 = include[5];

var Map_006 = include[6];

var Map_007 = include[7];

var Map_008 = include[8];

var Map_009 = include[9];

var Map_010 = include[10];

var Map_011 = include[11];

var Map_012 = include[12];

var Map_013 = include[13];

var Map_014 = include[14];

var Map_015 = include[15];

var Map_016 = include[16];

var Map_017 = include[17];

var Map_018 = include[18];

var Map_019 = include[19];

var Map_020 = include[20];

var Map_022 = include[22];

var Map_023 = include[23];

var Map_024 = include[24];

var Map_025 = include[25];

var Map_026 = include[26];

var Map_027 = include[27];

var Map_029 = include[29];

var Map_030 = include[30];

var Map_031 = include[31];

var Map_032 = include[32];

var Map_033 = include[33];

var Map_034 = include[34];

var Map_035 = include[35];

var $$Map = [
  empty,
  Map_001,
  Map_002,
  Map_003,
  Map_004,
  Map_005,
  Map_006,
  Map_007,
  Map_008,
  Map_009,
  Map_010,
  Map_011,
  Map_012,
  Map_013,
  Map_014,
  Map_015,
  Map_016,
  Map_017,
  Map_018,
  Map_019,
  Map_020,
  find,
  Map_022,
  Map_023,
  Map_024,
  Map_025,
  Map_026,
  Map_027,
  bind,
  Map_029,
  Map_030,
  Map_031,
  Map_032,
  Map_033,
  Map_034,
  Map_035
];

var PArray = [
  empty$1,
  get,
  set
];

var PMap = [
  /* Empty */0,
  is_empty,
  mem,
  add,
  singleton,
  remove,
  iter,
  fold,
  for_all,
  exists,
  find$1,
  domain,
  cast
];

exports.hash = hash;
exports.$$Set = $$Set$1;
exports.$$Map = $$Map;
exports.List = List$1;
exports.PArray = PArray;
exports.PMap = PMap;
/* Set Not a pure module */
