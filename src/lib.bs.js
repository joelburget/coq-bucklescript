// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");

function iter_objects(f, i, prefix) {
  return Curry._1(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return Curry._2(f, i, /* tuple */[
                            Libnames$ReactTemplate.make_oname(prefix, param[0]),
                            param[1]
                          ]);
              }));
}

function load_objects(i, pr) {
  return iter_objects(Libobject$ReactTemplate.load_object, i, pr);
}

function open_objects(i, pr) {
  return iter_objects(Libobject$ReactTemplate.open_object, i, pr);
}

function subst_objects(subst, seg) {
  var subst_one = function (node) {
    var obj = node[1];
    var obj$prime = Libobject$ReactTemplate.subst_object(/* tuple */[
          subst,
          obj
        ]);
    if (obj$prime === obj) {
      return node;
    } else {
      return /* tuple */[
              node[0],
              obj$prime
            ];
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* smartmap */65], subst_one, seg);
}

function classify_segment(seg) {
  var _acc = /* tuple */[
    /* [] */0,
    /* [] */0,
    /* [] */0
  ];
  var _param = Curry._1(Util$ReactTemplate.List[/* rev */4], seg);
  while(true) {
    var param = _param;
    var acc = _acc;
    var anticipl = acc[2];
    var keepl = acc[1];
    var substl = acc[0];
    if (param) {
      var match = param[0];
      var match$1 = match[1];
      switch (match$1.tag | 0) {
        case 0 : 
            var stk = param[1];
            var id = Names$ReactTemplate.Label[/* to_id */6](Names$ReactTemplate.KerName[/* label */4](match[0][1]));
            var match$2 = Libobject$ReactTemplate.classify_object(match$1[0]);
            if (typeof match$2 === "number") {
              _param = stk;
              continue ;
              
            } else {
              switch (match$2.tag | 0) {
                case 0 : 
                    _param = stk;
                    _acc = /* tuple */[
                      /* :: */[
                        /* tuple */[
                          id,
                          match$2[0]
                        ],
                        substl
                      ],
                      keepl,
                      anticipl
                    ];
                    continue ;
                    case 1 : 
                    _param = stk;
                    _acc = /* tuple */[
                      substl,
                      /* :: */[
                        /* tuple */[
                          id,
                          match$2[0]
                        ],
                        keepl
                      ],
                      anticipl
                    ];
                    continue ;
                    case 2 : 
                    _param = stk;
                    _acc = /* tuple */[
                      substl,
                      keepl,
                      /* :: */[
                        match$2[0],
                        anticipl
                      ]
                    ];
                    continue ;
                    
              }
            }
            break;
        case 1 : 
            return acc;
        case 2 : 
            return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Lib.classify_segment"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("there are still opened "), Pp$ReactTemplate.str(match$1[0] ? "module type" : "module")), Pp$ReactTemplate.str("s")));
        case 4 : 
            return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("there are still opened sections"));
        case 3 : 
        case 5 : 
            _param = param[1];
            continue ;
            
      }
    } else {
      return acc;
    }
  };
}

function segment_of_objects(prefix) {
  return Curry._1(Util$ReactTemplate.List[/* map */10], (function (param) {
                return /* tuple */[
                        Libnames$ReactTemplate.make_oname(prefix, param[0]),
                        /* Leaf */Block.__(0, [param[1]])
                      ];
              }));
}

var initial_prefix_001 = /* obj_mp */Names$ReactTemplate.ModPath[/* initial */6];

var initial_prefix_002 = /* obj_sec */Names$ReactTemplate.DirPath[/* empty */5];

var initial_prefix = /* record */[
  /* obj_dir */Libnames$ReactTemplate.default_library,
  initial_prefix_001,
  initial_prefix_002
];

var initial_lib_state = /* record */[
  /* comp_name : None */0,
  /* lib_stk : [] */0,
  /* path_prefix */initial_prefix
];

var lib_state = [initial_lib_state];

function library_dp() {
  var match = lib_state[0][/* comp_name */0];
  if (match) {
    return match[0];
  } else {
    return Libnames$ReactTemplate.default_library;
  }
}

function cwd() {
  return lib_state[0][/* path_prefix */2][/* obj_dir */0];
}

function current_mp() {
  return lib_state[0][/* path_prefix */2][/* obj_mp */1];
}

function sections_depth() {
  return Curry._1(Util$ReactTemplate.List[/* length */0], Names$ReactTemplate.DirPath[/* repr */4](lib_state[0][/* path_prefix */2][/* obj_sec */2]));
}

function sections_are_opened() {
  return 1 - Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], lib_state[0][/* path_prefix */2][/* obj_sec */2]);
}

function cwd_except_section() {
  return Libnames$ReactTemplate.pop_dirpath_n(sections_depth(/* () */0), cwd(/* () */0));
}

function current_dirpath(sec) {
  return Libnames$ReactTemplate.drop_dirpath_prefix(library_dp(/* () */0), sec ? cwd(/* () */0) : cwd_except_section(/* () */0));
}

function make_path(id) {
  return Libnames$ReactTemplate.make_path(cwd(/* () */0), id);
}

function make_path_except_section(id) {
  return Libnames$ReactTemplate.make_path(cwd_except_section(/* () */0), id);
}

function make_kn(id) {
  var mp = current_mp(/* () */0);
  var dir = lib_state[0][/* path_prefix */2][/* obj_sec */2];
  return Names$ReactTemplate.KerName[/* make */0](mp, dir, Names$ReactTemplate.Label[/* of_id */5](id));
}

function make_oname(id) {
  return Libnames$ReactTemplate.make_oname(lib_state[0][/* path_prefix */2], id);
}

function recalc_path_prefix() {
  var recalc = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0][1];
        switch (match.tag | 0) {
          case 2 : 
              return match[2];
          case 1 : 
          case 4 : 
              return match[0];
          default:
            _param = param[1];
            continue ;
            
        }
      } else {
        return initial_prefix;
      }
    };
  };
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name */init[/* comp_name */0],
    /* lib_stk */init[/* lib_stk */1],
    /* path_prefix */recalc(lib_state[0][/* lib_stk */1])
  ];
  return /* () */0;
}

function pop_path_prefix() {
  var op = lib_state[0][/* path_prefix */2];
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name */init[/* comp_name */0],
    /* lib_stk */init[/* lib_stk */1],
    /* path_prefix : record */[
      /* obj_dir */Libnames$ReactTemplate.pop_dirpath(op[/* obj_dir */0]),
      /* obj_mp */op[/* obj_mp */1],
      /* obj_sec */Libnames$ReactTemplate.pop_dirpath(op[/* obj_sec */2])
    ]
  ];
  return /* () */0;
}

function find_entry_p(p) {
  var _param = lib_state[0][/* lib_stk */1];
  while(true) {
    var param = _param;
    if (param) {
      var ent = param[0];
      if (Curry._1(p, ent)) {
        return ent;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_entries_p(p) {
  var find = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[1];
        var ent = param[0];
        if (Curry._1(p, ent)) {
          return /* :: */[
                  ent,
                  find(l)
                ];
        } else {
          _param = l;
          continue ;
          
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return find(lib_state[0][/* lib_stk */1]);
}

function split_lib_gen(test) {
  var collect = function (after, _equal, _before) {
    while(true) {
      var before = _before;
      var equal = _equal;
      if (before) {
        var hd = before[0];
        if (Curry._1(test, hd)) {
          _before = before[1];
          _equal = /* :: */[
            hd,
            equal
          ];
          continue ;
          
        } else {
          return /* tuple */[
                  after,
                  equal,
                  before
                ];
        }
      } else {
        return /* tuple */[
                after,
                equal,
                before
              ];
      }
    };
  };
  var findeq = function (_after, _param) {
    while(true) {
      var param = _param;
      var after = _after;
      if (param) {
        var before = param[1];
        var hd = param[0];
        if (Curry._1(test, hd)) {
          return /* Some */[collect(after, /* :: */[
                        hd,
                        /* [] */0
                      ], before)];
        } else {
          var match = hd[1];
          var exit = 0;
          switch (match.tag | 0) {
            case 3 : 
            case 5 : 
                exit = 1;
                break;
            default:
              _param = before;
              _after = /* :: */[
                hd,
                after
              ];
              continue ;
              
          }
          if (exit === 1) {
            var match$1 = findeq(after, match[0]);
            if (match$1) {
              var match$2 = match$1[0];
              return /* Some */[/* tuple */[
                        match$2[0],
                        match$2[1],
                        Curry._2(Util$ReactTemplate.List[/* append */5], match$2[2], before)
                      ]];
            } else {
              _param = before;
              _after = /* :: */[
                hd,
                after
              ];
              continue ;
              
            }
          }
          
        }
      } else {
        return /* None */0;
      }
    };
  };
  var match = findeq(/* [] */0, lib_state[0][/* lib_stk */1]);
  if (match) {
    return match[0];
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("no such entry"));
  }
}

function eq_object_name(param, param$1) {
  if (Libnames$ReactTemplate.eq_full_path(param[0], param$1[0])) {
    return Names$ReactTemplate.KerName[/* equal */9](param[1], param$1[1]);
  } else {
    return /* false */0;
  }
}

function split_lib(sp) {
  return split_lib_gen((function (param) {
                return eq_object_name(sp, param[0]);
              }));
}

function split_lib_at_opening(sp) {
  var is_sp = function (param) {
    switch (param[1].tag | 0) {
      case 0 : 
      case 3 : 
      case 5 : 
          return /* false */0;
      default:
        return eq_object_name(param[0], sp);
    }
  };
  var match = split_lib_gen(is_sp);
  var s = match[1];
  if (s) {
    if (s[1]) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "lib.ml",
              219,
              9
            ]
          ];
    } else {
      return /* tuple */[
              match[0],
              s[0],
              match[2]
            ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "lib.ml",
            219,
            9
          ]
        ];
  }
}

function add_entry(sp, node) {
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name */init[/* comp_name */0],
    /* lib_stk : :: */[
      /* tuple */[
        sp,
        node
      ],
      lib_state[0][/* lib_stk */1]
    ],
    /* path_prefix */init[/* path_prefix */2]
  ];
  return /* () */0;
}

function pull_to_head(oname) {
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name */init[/* comp_name */0],
    /* lib_stk : :: */[
      /* tuple */[
        oname,
        Curry._2(Util$ReactTemplate.List[/* assoc */30], oname, lib_state[0][/* lib_stk */1])
      ],
      Curry._2(Util$ReactTemplate.List[/* remove_assoc */34], oname, lib_state[0][/* lib_stk */1])
    ],
    /* path_prefix */init[/* path_prefix */2]
  ];
  return /* () */0;
}

var n = [0];

function anonymous_id() {
  n[0] = n[0] + 1 | 0;
  return Names$ReactTemplate.Id[/* of_string */5]("_" + Pervasives.string_of_int(n[0]));
}

function add_anonymous_entry(node) {
  return add_entry(make_oname(anonymous_id(/* () */0)), node);
}

function add_leaf(id, obj) {
  if (Names$ReactTemplate.ModPath[/* equal */1](current_mp(/* () */0), Names$ReactTemplate.ModPath[/* initial */6])) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No session module started (use -top dir)"));
  }
  var oname = make_oname(id);
  Libobject$ReactTemplate.cache_object(/* tuple */[
        oname,
        obj
      ]);
  add_entry(oname, /* Leaf */Block.__(0, [obj]));
  return oname;
}

function add_leaves(id, objs) {
  var oname = make_oname(id);
  var add_obj = function (obj) {
    add_entry(oname, /* Leaf */Block.__(0, [obj]));
    return Libobject$ReactTemplate.load_object(1, /* tuple */[
                oname,
                obj
              ]);
  };
  Curry._2(Util$ReactTemplate.List[/* iter */9], add_obj, objs);
  return oname;
}

function add_anonymous_leaf($staropt$star, obj) {
  var cache_first = $staropt$star ? $staropt$star[0] : /* true */1;
  var id = anonymous_id(/* () */0);
  var oname = make_oname(id);
  if (cache_first) {
    Libobject$ReactTemplate.cache_object(/* tuple */[
          oname,
          obj
        ]);
    return add_entry(oname, /* Leaf */Block.__(0, [obj]));
  } else {
    add_entry(oname, /* Leaf */Block.__(0, [obj]));
    return Libobject$ReactTemplate.cache_object(/* tuple */[
                oname,
                obj
              ]);
  }
}

function is_opening_node(param) {
  switch (param[1].tag | 0) {
    case 2 : 
    case 4 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function is_opening_node_or_lib(param) {
  switch (param[1].tag | 0) {
    case 0 : 
    case 3 : 
    case 5 : 
        return /* false */0;
    default:
      return /* true */1;
  }
}

function current_mod_id() {
  try {
    var match = find_entry_p(is_opening_node_or_lib);
    switch (match[1].tag | 0) {
      case 1 : 
      case 2 : 
          return Libnames$ReactTemplate.basename(match[0][0]);
      default:
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("you are not in a module"));
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("no opened modules"));
    } else {
      throw exn;
    }
  }
}

function start_mod(is_type, $$export, id, mp, fs) {
  var dir = Libnames$ReactTemplate.add_dirpath_suffix(lib_state[0][/* path_prefix */2][/* obj_dir */0], id);
  var prefix_002 = /* obj_sec */Names$ReactTemplate.DirPath[/* empty */5];
  var prefix = /* record */[
    /* obj_dir */dir,
    /* obj_mp */mp,
    prefix_002
  ];
  var exists = is_type ? Nametab$ReactTemplate.exists_cci(Libnames$ReactTemplate.make_path(cwd(/* () */0), id)) : Nametab$ReactTemplate.exists_module(dir);
  if (exists) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["open_module"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" already exists")));
  }
  add_entry(make_oname(id), /* OpenedModule */Block.__(2, [
          is_type,
          $$export,
          prefix,
          fs
        ]));
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name */init[/* comp_name */0],
    /* lib_stk */init[/* lib_stk */1],
    /* path_prefix */prefix
  ];
  return prefix;
}

function start_module(param, param$1, param$2, param$3) {
  return start_mod(/* false */0, param, param$1, param$2, param$3);
}

function start_modtype(param, param$1, param$2) {
  return start_mod(/* true */1, /* None */0, param, param$1, param$2);
}

function error_still_opened(string, oname) {
  var id = Libnames$ReactTemplate.basename(oname[0]);
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The "), Pp$ReactTemplate.str(string)), Pp$ReactTemplate.str(" ")), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(" is still opened.")));
}

function end_mod(is_type) {
  var match;
  try {
    var match$1 = find_entry_p(is_opening_node);
    var match$2 = match$1[1];
    var oname = match$1[0];
    switch (match$2.tag | 0) {
      case 2 : 
          var ty = match$2[0];
          match = ty === is_type ? /* tuple */[
              oname,
              match$2[3]
            ] : error_still_opened(ty ? "module type" : "module", oname);
          break;
      case 4 : 
          match = error_still_opened("section", oname);
          break;
      default:
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "lib.ml",
                316,
                13
              ]
            ];
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      match = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No opened modules."));
    } else {
      throw exn;
    }
  }
  var oname$1 = match[0];
  var match$3 = split_lib_at_opening(oname$1);
  var after = match$3[0];
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name */init[/* comp_name */0],
    /* lib_stk */match$3[2],
    /* path_prefix */init[/* path_prefix */2]
  ];
  add_entry(oname$1, /* ClosedModule */Block.__(3, [Curry._1(Util$ReactTemplate.List[/* rev */4], /* :: */[
                match$3[1],
                after
              ])]));
  var prefix = lib_state[0][/* path_prefix */2];
  recalc_path_prefix(/* () */0);
  return /* tuple */[
          oname$1,
          prefix,
          match[1],
          after
        ];
}

function end_module() {
  return end_mod(/* false */0);
}

function end_modtype() {
  return end_mod(/* true */1);
}

function contents() {
  return lib_state[0][/* lib_stk */1];
}

function contents_after(sp) {
  return split_lib(sp)[0];
}

function start_compilation(s, mp) {
  if (lib_state[0][/* comp_name */0] !== /* None */0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("compilation unit is already started"));
  }
  if (!Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], lib_state[0][/* path_prefix */2][/* obj_sec */2])) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("some sections are already opened"));
  }
  var prefix_002 = /* obj_sec */Names$ReactTemplate.DirPath[/* empty */5];
  var prefix = /* record */[
    /* obj_dir */s,
    /* obj_mp */mp,
    prefix_002
  ];
  add_anonymous_entry(/* CompilingLibrary */Block.__(1, [prefix]));
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name : Some */[s],
    /* lib_stk */init[/* lib_stk */1],
    /* path_prefix */prefix
  ];
  return /* () */0;
}

function open_blocks_message(es) {
  var open_block_name = function (param) {
    var match = param[1];
    var oname = param[0];
    switch (match.tag | 0) {
      case 2 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(match[0] ? "module type" : "module"), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](Libnames$ReactTemplate.basename(oname[0])));
      case 4 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("section "), Names$ReactTemplate.Id[/* print */8](Libnames$ReactTemplate.basename(oname[0])));
      default:
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "lib.ml",
                350,
                13
              ]
            ];
    }
  };
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The "), Pp$ReactTemplate.pr_enum(open_block_name, es)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("need")), Pp$ReactTemplate.str(Curry._1(Util$ReactTemplate.List[/* length */0], es) === 1 ? "s" : "")), Pp$ReactTemplate.str(" to be closed."));
}

function end_compilation_checks(dir) {
  var es = find_entries_p(is_opening_node);
  if (es) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Lib.end_compilation_checks"], open_blocks_message(es));
  }
  var is_opening_lib = function (param) {
    if (param[1].tag === 1) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  };
  var oname;
  try {
    var match = find_entry_p(is_opening_lib);
    if (match[1].tag === 1) {
      oname = match[0];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "lib.ml",
              363,
              13
            ]
          ];
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      oname = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("No module declared."));
    } else {
      throw exn;
    }
  }
  var match$1 = lib_state[0][/* comp_name */0];
  if (match$1) {
    var m = match$1[0];
    if (!Curry._2(Names$ReactTemplate.DirPath[/* equal */0], m, dir)) {
      CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The current open module has name"), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.DirPath[/* print */10](m)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("and not")), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.DirPath[/* print */10](m)), Pp$ReactTemplate.str(".")));
    }
    
  } else {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("There should be a module name..."));
  }
  return oname;
}

function end_compilation(oname) {
  var match = split_lib_at_opening(oname);
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name : None */0,
    /* lib_stk */init[/* lib_stk */1],
    /* path_prefix */init[/* path_prefix */2]
  ];
  return /* tuple */[
          lib_state[0][/* path_prefix */2],
          match[0]
        ];
}

function is_module_gen(which, check) {
  var test = function (param) {
    var match = param[1];
    if (match.tag === 2) {
      return Curry._1(which, match[0]);
    } else {
      return /* false */0;
    }
  };
  try {
    var match = find_entry_p(test);
    var match$1 = match[1];
    if (match$1.tag === 2) {
      return Curry._1(check, match$1[0]);
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "lib.ml",
              391,
              11
            ]
          ];
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_module_or_modtype() {
  return is_module_gen((function () {
                return /* true */1;
              }), (function () {
                return /* true */1;
              }));
}

function is_modtype() {
  return is_module_gen((function (b) {
                return b;
              }), (function () {
                return /* true */1;
              }));
}

function is_modtype_strict() {
  return is_module_gen((function () {
                return /* true */1;
              }), (function (b) {
                return b;
              }));
}

function is_module() {
  return is_module_gen((function (b) {
                return 1 - b;
              }), (function () {
                return /* true */1;
              }));
}

function find_opening_node(id) {
  try {
    var match = find_entry_p(is_opening_node);
    var id$prime = Libnames$ReactTemplate.basename(match[0][0]);
    if (!Names$ReactTemplate.Id[/* equal */0](id, id$prime)) {
      CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Lib.find_opening_node"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Last block to end has name "), Names$ReactTemplate.Id[/* print */8](id$prime)), Pp$ReactTemplate.str(".")));
    }
    return match[1];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("There is nothing to end."));
    } else {
      throw exn;
    }
  }
}

var sectab = Summary$ReactTemplate.ref(/* None */0, "section-context", /* [] */0);

function check_same_poly(p, vars) {
  var pred = function (param) {
    if (param.tag) {
      return +(p === /* false */0);
    } else {
      return +(p !== param[0][2]);
    }
  };
  if (Curry._2(Util$ReactTemplate.List[/* exists */21], pred, vars)) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot mix universe polymorphic and monomorphic declarations in sections."));
  } else {
    return 0;
  }
}

function add_section_variable(id, impl, poly, ctx) {
  var match = sectab[0];
  if (match) {
    var match$1 = match[0];
    Curry._2(Util$ReactTemplate.List[/* iter */9], (function (tab) {
            return check_same_poly(poly, Util$ReactTemplate.pi1(tab));
          }), sectab[0]);
    sectab[0] = /* :: */[
      /* tuple */[
        /* :: */[
          /* Variable */Block.__(0, [/* tuple */[
                id,
                impl,
                poly,
                ctx
              ]]),
          match$1[0]
        ],
        match$1[1],
        match$1[2]
      ],
      match[1]
    ];
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function add_section_context(ctx) {
  var match = sectab[0];
  if (match) {
    var match$1 = match[0];
    var vars = match$1[0];
    check_same_poly(/* true */1, vars);
    sectab[0] = /* :: */[
      /* tuple */[
        /* :: */[
          /* Context */Block.__(1, [ctx]),
          vars
        ],
        match$1[1],
        match$1[2]
      ],
      match[1]
    ];
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function extract_hyps(param) {
  var aux = function (param) {
    var match = param[0];
    if (match) {
      var match$1 = match[0];
      if (match$1.tag) {
        var match$2 = aux(/* tuple */[
              match[1],
              param[1]
            ]);
        return /* tuple */[
                match$2[0],
                Univ$ReactTemplate.ContextSet[/* union */6](match$2[1], match$1[0])
              ];
      } else {
        var hyps = param[1];
        var idl = match[1];
        var match$3 = match$1[0];
        var ctx = match$3[3];
        var poly = match$3[2];
        var exit = 0;
        if (hyps) {
          var decl = hyps[0];
          if (Names$ReactTemplate.Id[/* equal */0](match$3[0], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl))) {
            var match$4 = aux(/* tuple */[
                  idl,
                  hyps[1]
                ]);
            var r = match$4[1];
            return /* tuple */[
                    /* :: */[
                      /* tuple */[
                        decl,
                        match$3[1]
                      ],
                      match$4[0]
                    ],
                    poly ? Univ$ReactTemplate.ContextSet[/* union */6](r, ctx) : r
                  ];
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          var match$5 = aux(/* tuple */[
                idl,
                hyps
              ]);
          var r$1 = match$5[1];
          return /* tuple */[
                  match$5[0],
                  poly ? Univ$ReactTemplate.ContextSet[/* union */6](r$1, ctx) : r$1
                ];
        }
        
      }
    } else {
      return /* tuple */[
              /* [] */0,
              Univ$ReactTemplate.ContextSet[/* empty */0]
            ];
    }
  };
  return aux(/* tuple */[
              param[0],
              param[1]
            ]);
}

var partial_arg = Util$ReactTemplate.$$Array[/* of_list */10];

var partial_arg$1 = Curry._1(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0]);

var partial_arg$2 = Curry._1(Util$ReactTemplate.List[/* filter */27], Context$ReactTemplate.Named[/* Declaration */0][/* is_local_assum */5]);

var partial_arg$3 = Curry._1(Util$ReactTemplate.List[/* map */10], (function (prim) {
        return prim[0];
      }));

function partial_arg$4(param) {
  return Util$ReactTemplate.$percent$great(partial_arg$3, partial_arg$2, param);
}

function partial_arg$5(param) {
  return Util$ReactTemplate.$percent$great(partial_arg$4, partial_arg$1, param);
}

function instance_from_variable_context(param) {
  return Util$ReactTemplate.$percent$great(partial_arg$5, partial_arg, param);
}

var named_of_variable_context = Curry._1(Util$ReactTemplate.List[/* map */10], (function (prim) {
        return prim[0];
      }));

function add_section_replacement(f, g, poly, hyps) {
  var match = sectab[0];
  if (match) {
    var match$1 = match[0];
    var vars = match$1[0];
    check_same_poly(poly, vars);
    var match$2 = extract_hyps(/* tuple */[
          vars,
          hyps
        ]);
    var sechyps = match$2[0];
    var ctx = Univ$ReactTemplate.ContextSet[/* to_context */13](match$2[1]);
    var inst = Univ$ReactTemplate.UContext[/* instance */3](ctx);
    var match$3 = Univ$ReactTemplate.abstract_universes(ctx);
    var args = instance_from_variable_context(Curry._1(Util$ReactTemplate.List[/* rev */4], sechyps));
    var info_001 = /* abstr_subst */match$3[0];
    var info_002 = /* abstr_uctx */match$3[1];
    var info = /* record */[
      /* abstr_ctx */sechyps,
      info_001,
      info_002
    ];
    sectab[0] = /* :: */[
      /* tuple */[
        vars,
        Curry._2(f, /* tuple */[
              inst,
              args
            ], match$1[1]),
        Curry._2(g, info, match$1[2])
      ],
      match[1]
    ];
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function add_section_kn(poly, kn) {
  var f = function (x, param) {
    return /* tuple */[
            param[0],
            Curry._3(Names$ReactTemplate.Mindmap[/* add */3], kn, x, param[1])
          ];
  };
  return (function (param) {
      return add_section_replacement(f, f, poly, param);
    });
}

function add_section_constant(poly, kn) {
  var f = function (x, param) {
    return /* tuple */[
            Curry._3(Names$ReactTemplate.Cmap[/* add */3], kn, x, param[0]),
            param[1]
          ];
  };
  return (function (param) {
      return add_section_replacement(f, f, poly, param);
    });
}

function replacement_context() {
  return Util$ReactTemplate.pi2(Curry._1(Util$ReactTemplate.List[/* hd */1], sectab[0]));
}

function section_segment_of_constant(con) {
  return Curry._2(Names$ReactTemplate.Cmap[/* find */21], con, Util$ReactTemplate.pi3(Curry._1(Util$ReactTemplate.List[/* hd */1], sectab[0]))[0]);
}

function section_segment_of_mutual_inductive(kn) {
  return Curry._2(Names$ReactTemplate.Mindmap[/* find */21], kn, Util$ReactTemplate.pi3(Curry._1(Util$ReactTemplate.List[/* hd */1], sectab[0]))[1]);
}

var empty_segment_001 = /* abstr_subst */Univ$ReactTemplate.Instance[/* empty */0];

var empty_segment_002 = /* abstr_uctx */Univ$ReactTemplate.AUContext[/* empty */1];

var empty_segment = /* record */[
  /* abstr_ctx : [] */0,
  empty_segment_001,
  empty_segment_002
];

function section_segment_of_reference(param) {
  switch (param.tag | 0) {
    case 0 : 
        return empty_segment;
    case 1 : 
        return section_segment_of_constant(param[0]);
    case 2 : 
        return section_segment_of_mutual_inductive(param[0][0]);
    case 3 : 
        return section_segment_of_mutual_inductive(param[0][0][0]);
    
  }
}

function variable_section_segment_of_reference(gr) {
  return section_segment_of_reference(gr)[/* abstr_ctx */0];
}

function section_instance(param) {
  var exit = 0;
  var kn;
  switch (param.tag | 0) {
    case 0 : 
        var id = param[0];
        var eq = function (param) {
          if (param.tag) {
            return /* false */0;
          } else {
            return Names$ReactTemplate.Id[/* equal */0](id, param[0][0]);
          }
        };
        if (Curry._2(Util$ReactTemplate.List[/* exists */21], eq, Util$ReactTemplate.pi1(Curry._1(Util$ReactTemplate.List[/* hd */1], sectab[0])))) {
          return /* tuple */[
                  Univ$ReactTemplate.Instance[/* empty */0],
                  /* array */[]
                ];
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
        break;
    case 1 : 
        return Curry._2(Names$ReactTemplate.Cmap[/* find */21], param[0], Util$ReactTemplate.pi2(Curry._1(Util$ReactTemplate.List[/* hd */1], sectab[0]))[0]);
    case 2 : 
        kn = param[0][0];
        exit = 1;
        break;
    case 3 : 
        kn = param[0][0][0];
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    return Curry._2(Names$ReactTemplate.Mindmap[/* find */21], kn, Util$ReactTemplate.pi2(Curry._1(Util$ReactTemplate.List[/* hd */1], sectab[0]))[1]);
  }
  
}

function is_in_section(ref) {
  try {
    section_instance(ref);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function open_section(id) {
  var opp = lib_state[0][/* path_prefix */2];
  var obj_dir = Libnames$ReactTemplate.add_dirpath_suffix(opp[/* obj_dir */0], id);
  var prefix_001 = /* obj_mp */opp[/* obj_mp */1];
  var prefix_002 = /* obj_sec */Libnames$ReactTemplate.add_dirpath_suffix(opp[/* obj_sec */2], id);
  var prefix = /* record */[
    /* obj_dir */obj_dir,
    prefix_001,
    prefix_002
  ];
  if (Nametab$ReactTemplate.exists_section(obj_dir)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["open_section"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" already exists.")));
  }
  var fs = Summary$ReactTemplate.freeze_summaries(/* No */17505);
  add_entry(make_oname(id), /* OpenedSection */Block.__(4, [
          prefix,
          fs
        ]));
  Nametab$ReactTemplate.push_dir(/* Until */Block.__(0, [1]), obj_dir, /* DirOpenSection */Block.__(2, [prefix]));
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name */init[/* comp_name */0],
    /* lib_stk */init[/* lib_stk */1],
    /* path_prefix */prefix
  ];
  sectab[0] = /* :: */[
    /* tuple */[
      /* [] */0,
      /* tuple */[
        Names$ReactTemplate.Cmap[/* empty */0],
        Names$ReactTemplate.Mindmap[/* empty */0]
      ],
      /* tuple */[
        Names$ReactTemplate.Cmap[/* empty */0],
        Names$ReactTemplate.Mindmap[/* empty */0]
      ]
    ],
    sectab[0]
  ];
  return /* () */0;
}

function discharge_item(param) {
  var e = param[1];
  var oname = param[0];
  var sp = oname[0];
  switch (e.tag | 0) {
    case 0 : 
        return Option$ReactTemplate.map((function (o) {
                      return /* tuple */[
                              Libnames$ReactTemplate.basename(sp),
                              o
                            ];
                    }), Libobject$ReactTemplate.discharge_object(/* tuple */[
                        oname,
                        e[0]
                      ]));
    case 3 : 
    case 5 : 
        return /* None */0;
    default:
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("discharge_item."));
  }
}

function close_section() {
  var match;
  try {
    var match$1 = find_entry_p(is_opening_node);
    var match$2 = match$1[1];
    if (match$2.tag === 4) {
      match = /* tuple */[
        match$1[0],
        match$2[1]
      ];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "lib.ml",
              577,
              13
            ]
          ];
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      match = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No opened section."));
    } else {
      throw exn;
    }
  }
  var oname = match[0];
  var match$3 = split_lib_at_opening(oname);
  var secdecls = match$3[0];
  var init = lib_state[0];
  lib_state[0] = /* record */[
    /* comp_name */init[/* comp_name */0],
    /* lib_stk */match$3[2],
    /* path_prefix */init[/* path_prefix */2]
  ];
  var full_olddir = lib_state[0][/* path_prefix */2][/* obj_dir */0];
  pop_path_prefix(/* () */0);
  add_entry(oname, /* ClosedSection */Block.__(5, [Curry._1(Util$ReactTemplate.List[/* rev */4], /* :: */[
                match$3[1],
                secdecls
              ])]));
  var newdecls = Curry._2(Util$ReactTemplate.List[/* map */10], discharge_item, secdecls);
  Summary$ReactTemplate.unfreeze_summaries(/* None */0, match[1]);
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
          return Option$ReactTemplate.iter((function (param) {
                        var id = param[0];
                        var obj = param[1];
                        var oname = make_oname(id);
                        var newobj = Libobject$ReactTemplate.rebuild_object(obj);
                        Libobject$ReactTemplate.cache_object(/* tuple */[
                              oname,
                              newobj
                            ]);
                        return add_entry(oname, /* Leaf */Block.__(0, [newobj]));
                      }), param);
        }), newdecls);
  return Nametab$ReactTemplate.push_dir(/* Until */Block.__(0, [1]), full_olddir, /* DirClosedSection */Block.__(4, [full_olddir]));
}

function freeze(marshallable) {
  if (marshallable !== 841395124) {
    return lib_state[0];
  } else {
    var lib_stk = CList$ReactTemplate.map_filter((function (param) {
            var x = param[1];
            var n = param[0];
            switch (x.tag | 0) {
              case 0 : 
                  return /* None */0;
              case 1 : 
                  return /* Some */[/* tuple */[
                            n,
                            x
                          ]];
              case 2 : 
                  return /* Some */[/* tuple */[
                            n,
                            /* OpenedModule */Block.__(2, [
                                x[0],
                                x[1],
                                x[2],
                                Summary$ReactTemplate.empty_frozen
                              ])
                          ]];
              case 3 : 
                  return /* Some */[/* tuple */[
                            n,
                            /* ClosedModule */Block.__(3, [/* [] */0])
                          ]];
              case 4 : 
                  return /* Some */[/* tuple */[
                            n,
                            /* OpenedSection */Block.__(4, [
                                x[0],
                                Summary$ReactTemplate.empty_frozen
                              ])
                          ]];
              case 5 : 
                  return /* Some */[/* tuple */[
                            n,
                            /* ClosedSection */Block.__(5, [/* [] */0])
                          ]];
              
            }
          }), lib_state[0][/* lib_stk */1]);
    var init = lib_state[0];
    return /* record */[
            /* comp_name */init[/* comp_name */0],
            /* lib_stk */lib_stk,
            /* path_prefix */init[/* path_prefix */2]
          ];
  }
}

function unfreeze(st) {
  lib_state[0] = st;
  return /* () */0;
}

function init() {
  unfreeze(initial_lib_state);
  return Summary$ReactTemplate.init_summaries(/* () */0);
}

function mp_of_global(param) {
  switch (param.tag | 0) {
    case 0 : 
        return lib_state[0][/* path_prefix */2][/* obj_mp */1];
    case 1 : 
        return Names$ReactTemplate.Constant[/* modpath */7](param[0]);
    case 2 : 
        return Names$ReactTemplate.ind_modpath(param[0]);
    case 3 : 
        return Names$ReactTemplate.constr_modpath(param[0]);
    
  }
}

function dp_of_mp(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return param[0];
      case 1 : 
          return library_dp(/* () */0);
      case 2 : 
          _param = param[0];
          continue ;
          
    }
  };
}

function split_modpath(param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* tuple */[
                param[0],
                /* [] */0
              ];
    case 1 : 
        return /* tuple */[
                library_dp(/* () */0),
                /* :: */[
                  Names$ReactTemplate.MBId[/* to_id */5](param[0]),
                  /* [] */0
                ]
              ];
    case 2 : 
        var match = split_modpath(param[0]);
        return /* tuple */[
                match[0],
                /* :: */[
                  Names$ReactTemplate.Label[/* to_id */6](param[1]),
                  match[1]
                ]
              ];
    
  }
}

function library_part(ref) {
  if (ref.tag) {
    return dp_of_mp(mp_of_global(ref));
  } else {
    return library_dp(/* () */0);
  }
}

function con_defined_in_sec(kn) {
  var match = Names$ReactTemplate.Constant[/* repr3 */6](kn);
  var dir = match[1];
  if (Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], dir)) {
    return /* false */0;
  } else {
    return Curry._2(Names$ReactTemplate.DirPath[/* equal */0], Libnames$ReactTemplate.pop_dirpath(dir), lib_state[0][/* path_prefix */2][/* obj_sec */2]);
  }
}

function defined_in_sec(kn) {
  var match = Names$ReactTemplate.MutInd[/* repr3 */6](kn);
  var dir = match[1];
  if (Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], dir)) {
    return /* false */0;
  } else {
    return Curry._2(Names$ReactTemplate.DirPath[/* equal */0], Libnames$ReactTemplate.pop_dirpath(dir), lib_state[0][/* path_prefix */2][/* obj_sec */2]);
  }
}

function discharge_global(r) {
  switch (r.tag | 0) {
    case 0 : 
        return r;
    case 1 : 
        var kn = r[0];
        if (con_defined_in_sec(kn)) {
          return /* ConstRef */Block.__(1, [Globnames$ReactTemplate.pop_con(kn)]);
        } else {
          return r;
        }
    case 2 : 
        var match = r[0];
        var kn$1 = match[0];
        if (defined_in_sec(kn$1)) {
          return /* IndRef */Block.__(2, [/* tuple */[
                      Globnames$ReactTemplate.pop_kn(kn$1),
                      match[1]
                    ]]);
        } else {
          return r;
        }
    case 3 : 
        var match$1 = r[0];
        var match$2 = match$1[0];
        var kn$2 = match$2[0];
        if (defined_in_sec(kn$2)) {
          return /* ConstructRef */Block.__(3, [/* tuple */[
                      /* tuple */[
                        Globnames$ReactTemplate.pop_kn(kn$2),
                        match$2[1]
                      ],
                      match$1[1]
                    ]]);
        } else {
          return r;
        }
    
  }
}

function discharge_kn(kn) {
  if (defined_in_sec(kn)) {
    return Globnames$ReactTemplate.pop_kn(kn);
  } else {
    return kn;
  }
}

function discharge_con(cst) {
  if (con_defined_in_sec(cst)) {
    return Globnames$ReactTemplate.pop_con(cst);
  } else {
    return cst;
  }
}

function discharge_inductive(param) {
  return /* tuple */[
          discharge_kn(param[0]),
          param[1]
        ];
}

function discharge_abstract_universe_context(param, auctx) {
  var ainst = Univ$ReactTemplate.make_abstract_instance(auctx);
  var subst = Univ$ReactTemplate.Instance[/* append */4](param[/* abstr_subst */1], ainst);
  var subst$1 = Univ$ReactTemplate.make_instance_subst(subst);
  var auctx$1 = Univ$ReactTemplate.subst_univs_level_abstract_universe_context(subst$1, auctx);
  return /* tuple */[
          subst$1,
          Univ$ReactTemplate.AUContext[/* union */5](param[/* abstr_uctx */2], auctx$1)
        ];
}

exports.open_objects = open_objects;
exports.load_objects = load_objects;
exports.subst_objects = subst_objects;
exports.classify_segment = classify_segment;
exports.segment_of_objects = segment_of_objects;
exports.add_leaf = add_leaf;
exports.add_anonymous_leaf = add_anonymous_leaf;
exports.pull_to_head = pull_to_head;
exports.add_leaves = add_leaves;
exports.contents = contents;
exports.contents_after = contents_after;
exports.cwd = cwd;
exports.cwd_except_section = cwd_except_section;
exports.current_dirpath = current_dirpath;
exports.make_path = make_path;
exports.make_path_except_section = make_path_except_section;
exports.current_mp = current_mp;
exports.make_kn = make_kn;
exports.sections_are_opened = sections_are_opened;
exports.sections_depth = sections_depth;
exports.is_module_or_modtype = is_module_or_modtype;
exports.is_modtype = is_modtype;
exports.is_modtype_strict = is_modtype_strict;
exports.is_module = is_module;
exports.current_mod_id = current_mod_id;
exports.find_opening_node = find_opening_node;
exports.start_module = start_module;
exports.start_modtype = start_modtype;
exports.end_module = end_module;
exports.end_modtype = end_modtype;
exports.start_compilation = start_compilation;
exports.end_compilation_checks = end_compilation_checks;
exports.end_compilation = end_compilation;
exports.library_dp = library_dp;
exports.dp_of_mp = dp_of_mp;
exports.split_modpath = split_modpath;
exports.library_part = library_part;
exports.open_section = open_section;
exports.close_section = close_section;
exports.freeze = freeze;
exports.unfreeze = unfreeze;
exports.init = init;
exports.instance_from_variable_context = instance_from_variable_context;
exports.named_of_variable_context = named_of_variable_context;
exports.section_segment_of_constant = section_segment_of_constant;
exports.section_segment_of_mutual_inductive = section_segment_of_mutual_inductive;
exports.section_segment_of_reference = section_segment_of_reference;
exports.variable_section_segment_of_reference = variable_section_segment_of_reference;
exports.section_instance = section_instance;
exports.is_in_section = is_in_section;
exports.add_section_variable = add_section_variable;
exports.add_section_context = add_section_context;
exports.add_section_constant = add_section_constant;
exports.add_section_kn = add_section_kn;
exports.replacement_context = replacement_context;
exports.discharge_kn = discharge_kn;
exports.discharge_con = discharge_con;
exports.discharge_global = discharge_global;
exports.discharge_inductive = discharge_inductive;
exports.discharge_abstract_universe_context = discharge_abstract_universe_context;
/* sectab Not a pure module */
