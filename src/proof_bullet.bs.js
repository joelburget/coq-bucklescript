// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var $$String = require("bs-platform/lib/js/string.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Proof$ReactTemplate = require("./proof.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function bullet_eq(b1, b2) {
  switch (b1.tag | 0) {
    case 0 : 
        switch (b2.tag | 0) {
          case 0 : 
              return +(b1[0] === b2[0]);
          case 1 : 
          case 2 : 
              return /* false */0;
          
        }
        break;
    case 1 : 
        switch (b2.tag | 0) {
          case 1 : 
              return +(b1[0] === b2[0]);
          case 0 : 
          case 2 : 
              return /* false */0;
          
        }
        break;
    case 2 : 
        switch (b2.tag | 0) {
          case 0 : 
          case 1 : 
              return /* false */0;
          case 2 : 
              return +(b1[0] === b2[0]);
          
        }
        break;
    
  }
}

function pr_bullet(b) {
  switch (b.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.str($$String.make(b[0], /* "-" */45));
    case 1 : 
        return Pp$ReactTemplate.str($$String.make(b[0], /* "*" */42));
    case 2 : 
        return Pp$ReactTemplate.str($$String.make(b[0], /* "+" */43));
    
  }
}

var behaviors = Hashtbl.create(/* None */0, 4);

function register_behavior(b) {
  return Hashtbl.add(behaviors, b[/* name */0], b);
}

function none_001(x, _) {
  return x;
}

function none_002() {
  return Pp$ReactTemplate.mt(/* () */0);
}

var none = /* record */[
  /* name */"None",
  none_001,
  none_002
];

register_behavior(none);

function suggest_on_error(sugg) {
  if (typeof sugg === "number") {
    switch (sugg) {
      case 0 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "proof_bullet.ml",
                  67,
                  23
                ]
              ];
      case 1 : 
          return Pp$ReactTemplate.str("Try unfocusing with \"}\".");
      case 2 : 
          return Pp$ReactTemplate.str("No more subgoals.");
      
    }
  } else if (sugg.tag) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Current bullet "), pr_bullet(sugg[0])), Pp$ReactTemplate.str(" is not finished."));
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Expecting "), pr_bullet(sugg[0])), Pp$ReactTemplate.str("."));
  }
}

var FailedBullet = Caml_exceptions.create("Proof_bullet-ReactTemplate.Strict.FailedBullet");

CErrors$ReactTemplate.register_handler((function (param) {
        if (param[0] === FailedBullet) {
          var prefix = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Wrong bullet "), pr_bullet(param[1])), Pp$ReactTemplate.str(": "));
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Focus"], Pp$ReactTemplate.$plus$plus(prefix, suggest_on_error(param[2])));
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

var bullet_kind = Proof$ReactTemplate.new_focus_kind(/* () */0);

var bullet_cond = Proof$ReactTemplate.done_cond(/* Some */[/* true */1], bullet_kind);

function get_bullets(pr) {
  if (Proof$ReactTemplate.is_last_focus(bullet_kind, pr)) {
    return Proof$ReactTemplate.get_at_focus(bullet_kind, pr);
  } else {
    return /* [] */0;
  }
}

function has_bullet(bul, pr) {
  var _param = get_bullets(pr);
  while(true) {
    var param = _param;
    if (param) {
      if (bullet_eq(bul, param[0])) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function pop(pr) {
  var match = get_bullets(pr);
  if (match) {
    return /* tuple */[
            Proof$ReactTemplate.unfocus(bullet_kind, pr, /* () */0),
            match[0]
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "proof_bullet.ml",
            110,
            11
          ]
        ];
  }
}

function push(b, pr) {
  return Proof$ReactTemplate.focus(bullet_cond, /* :: */[
              b,
              get_bullets(pr)
            ], 1, pr);
}

function suggest_bullet(prf) {
  if (Proof$ReactTemplate.is_done(prf)) {
    return /* ProofFinished */2;
  } else if (Proof$ReactTemplate.no_focused_goal(prf)) {
    var _prf = prf;
    while(true) {
      var prf$1 = _prf;
      var exit = 0;
      var val;
      try {
        val = pop(prf$1);
        exit = 1;
      }
      catch (exn){
        return /* NeedClosingBrace */1;
      }
      if (exit === 1) {
        var b = val[1];
        var prf$2 = val[0];
        try {
          push(b, prf$2);
          return /* Suggest */Block.__(0, [b]);
        }
        catch (exn$1){
          _prf = prf$2;
          continue ;
          
        }
      }
      
    };
  } else {
    var match = get_bullets(prf);
    if (match) {
      return /* Unfinished */Block.__(1, [match[0]]);
    } else {
      return /* NoBulletInUse */0;
    }
  }
}

function pop_until(_prf, bul) {
  while(true) {
    var prf = _prf;
    var match = pop(prf);
    var prf$prime = match[0];
    if (bullet_eq(bul, match[1])) {
      return prf$prime;
    } else {
      _prf = prf$prime;
      continue ;
      
    }
  };
}

function put(p, bul) {
  try {
    if (has_bullet(bul, p)) {
      var sugg = suggest_bullet(p);
      if (typeof sugg === "number") {
        throw [
              FailedBullet,
              bul,
              sugg
            ];
      } else if (sugg.tag) {
        throw [
              FailedBullet,
              bul,
              sugg
            ];
      } else if (bullet_eq(bul, sugg[0])) {
        var p$prime = pop_until(p, bul);
        return push(bul, p$prime);
      } else {
        throw [
              FailedBullet,
              bul,
              sugg
            ];
      }
    } else {
      return push(bul, p);
    }
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Proof$ReactTemplate.NoSuchGoals) {
      throw [
            FailedBullet,
            bul,
            suggest_bullet(p)
          ];
    } else {
      throw exn;
    }
  }
}

function strict_002(prf) {
  var sugg = suggest_bullet(prf);
  if (typeof sugg === "number") {
    switch (sugg) {
      case 1 : 
          return Pp$ReactTemplate.str("Try unfocusing with \"}\".");
      case 0 : 
      case 2 : 
          return Pp$ReactTemplate.mt(/* () */0);
      
    }
  } else if (sugg.tag) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The current bullet "), pr_bullet(sugg[0])), Pp$ReactTemplate.str(" is unfinished."));
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Focus next goal with bullet "), pr_bullet(sugg[0])), Pp$ReactTemplate.str("."));
  }
}

var strict = /* record */[
  /* name */"Strict Subproofs",
  /* put */put,
  strict_002
];

register_behavior(strict);

var current_behavior = [strict];

Goptions$ReactTemplate.declare_string_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"bullet behavior",
      /* optkey : :: */[
        "Bullet",
        /* :: */[
          "Behavior",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return current_behavior[0][/* name */0];
        }),
      /* optwrite */(function (n) {
          var tmp;
          try {
            tmp = Hashtbl.find(behaviors, n);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              tmp = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Unknown bullet behavior: \"" + (n + "\".")));
            } else {
              throw exn;
            }
          }
          current_behavior[0] = tmp;
          return /* () */0;
        })
    ]);

function put$1(p, b) {
  return Curry._2(current_behavior[0][/* put */1], p, b);
}

function suggest(p) {
  return Curry._1(current_behavior[0][/* suggest */2], p);
}

var default_goal_selector = [/* SelectNth */Block.__(0, [1])];

function get_default_goal_selector() {
  return default_goal_selector[0];
}

function pr_range_selector(param) {
  var j = param[1];
  var i = param[0];
  if (i === j) {
    return Pp$ReactTemplate.$$int(i);
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(i), Pp$ReactTemplate.str("-")), Pp$ReactTemplate.$$int(j));
  }
}

function pr_goal_selector(param) {
  if (typeof param === "number") {
    return Pp$ReactTemplate.str("all");
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Pp$ReactTemplate.$$int(param[0]);
      case 1 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, pr_range_selector, param[0])), Pp$ReactTemplate.str("]"));
      case 2 : 
          return Names$ReactTemplate.Id[/* print */8](param[0]);
      
    }
  }
}

function parse_goal_selector(i) {
  if (i === "all") {
    return /* SelectAll */0;
  } else {
    var err_msg = "The default selector must be \"all\" or a natural number.";
    try {
      var i$1 = Caml_format.caml_int_of_string(i);
      if (i$1 < 0) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(err_msg));
      }
      return /* SelectNth */Block.__(0, [i$1]);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(err_msg));
      } else {
        throw exn;
      }
    }
  }
}

Goptions$ReactTemplate.declare_string_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"default goal selector",
      /* optkey : :: */[
        "Default",
        /* :: */[
          "Goal",
          /* :: */[
            "Selector",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return Pp$ReactTemplate.string_of_ppcmds(pr_goal_selector(default_goal_selector[0]));
        }),
      /* optwrite */(function (n) {
          default_goal_selector[0] = parse_goal_selector(n);
          return /* () */0;
        })
    ]);

exports.register_behavior = register_behavior;
exports.put = put$1;
exports.suggest = suggest;
exports.pr_goal_selector = pr_goal_selector;
exports.get_default_goal_selector = get_default_goal_selector;
/* behaviors Not a pure module */
