// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Obj = require("bs-platform/lib/js/obj.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Caml_missing_polyfill = require("bs-platform/lib/js/caml_missing_polyfill.js");
var Hashset$ReactTemplate = require("./hashset.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Cbytecodes$ReactTemplate = require("./cbytecodes.bs.js");

Caml_missing_polyfill.not_implemented("init_coq_vm not implemented by bucklescript yet\n");

function fun_val(v) {
  return v;
}

function fix_val(v) {
  return v;
}

function cofix_upd_val(v) {
  return v;
}

function fun_env(v) {
  return v;
}

function fix_env(v) {
  return v;
}

function cofix_env(v) {
  return v;
}

function cofix_upd_env(v) {
  return v;
}

function fun_of_val(v) {
  return v;
}

function fun_code(v) {
  return v[0];
}

var fix_code = fun_code;

var cofix_upd_code = fun_code;

function eq_id_key(k1, k2) {
  switch (k1.tag | 0) {
    case 0 : 
        if (k2.tag) {
          return /* false */0;
        } else {
          return Names$ReactTemplate.Constant[/* equal */12](k1[0], k2[0]);
        }
        break;
    case 1 : 
        if (k2.tag === 1) {
          return Names$ReactTemplate.Id[/* equal */0](k1[0], k2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 2 : 
        if (k2.tag === 2) {
          return +(k1[0] === k2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 3 : 
        if (k2.tag === 3) {
          return Evar$ReactTemplate.equal(k1[0], k2[0]);
        } else {
          return /* false */0;
        }
        break;
    
  }
}

function nargs(args) {
  return args.length - 2 | 0;
}

function arg(args, i) {
  if (0 <= i && i < (args.length - 2 | 0)) {
    return args[i + 2 | 0];
  } else {
    return Pervasives.invalid_arg("Vm.arg size = " + (Pervasives.string_of_int(args.length - 2 | 0) + (" acces " + Pervasives.string_of_int(i))));
  }
}

function uni_lvl_val(v) {
  if (v.tag === 7) {
    return v[0];
  } else {
    var pr;
    switch (v.tag | 0) {
      case 0 : 
          pr = Pp$ReactTemplate.str("Vprod");
          break;
      case 1 : 
          pr = Pp$ReactTemplate.str("Vfun");
          break;
      case 2 : 
          pr = Pp$ReactTemplate.str("Vfix");
          break;
      case 3 : 
          pr = Pp$ReactTemplate.str("Vcofix");
          break;
      case 4 : 
          pr = Pp$ReactTemplate.str("Vconstr_const");
          break;
      case 5 : 
          pr = Pp$ReactTemplate.str("Vconstr_block");
          break;
      case 6 : 
          pr = Pp$ReactTemplate.str("Vatom_stk");
          break;
      case 7 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "vmvalues.ml",
                  191,
                  15
                ]
              ];
      
    }
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Parsing virtual machine value expected universe level, got "), pr), Pp$ReactTemplate.str(".")));
  }
}

var accumulate = Caml_missing_polyfill.not_implemented("accumulate_code not implemented by bucklescript yet\n");

function whd_val(v) {
  if (typeof v === "number") {
    return /* Vconstr_const */Block.__(4, [v]);
  } else {
    var tag = v.tag | 0;
    if (tag === Cbytecodes$ReactTemplate.accu_tag) {
      if (Caml_missing_polyfill.not_implemented("coq_is_accumulate_code not implemented by bucklescript yet\n")) {
        var _a = v;
        var _stk = /* [] */0;
        while(true) {
          var stk = _stk;
          var a = _a;
          var stk$1 = a.length === 2 ? stk : /* :: */[
              /* Zapp */Block.__(0, [a]),
              stk
            ];
          var at = a[1];
          var i = at.tag | 0;
          if (i === Cbytecodes$ReactTemplate.type_atom_tag) {
            if (stk$1) {
              var match = stk$1[0];
              if (match.tag) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "vmvalues.ml",
                        216,
                        12
                      ]
                    ];
              } else if (stk$1[1]) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "vmvalues.ml",
                        216,
                        12
                      ]
                    ];
              } else {
                var args = match[0];
                var args$1 = $$Array.init(args.length - 2 | 0, (function(args){
                    return function (param) {
                      return arg(args, param);
                    }
                    }(args)));
                var s = at[0];
                if (s.tag) {
                  var inst = Univ$ReactTemplate.Instance[/* of_array */2]($$Array.map(uni_lvl_val, args$1));
                  var u = Univ$ReactTemplate.subst_instance_universe(inst, s[0]);
                  return /* Vatom_stk */Block.__(6, [
                            /* Asort */Block.__(2, [/* Type */Block.__(1, [u])]),
                            /* [] */0
                          ]);
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "vmvalues.ml",
                          214,
                          15
                        ]
                      ];
                }
              }
            } else {
              return /* Vatom_stk */Block.__(6, [
                        at,
                        stk$1
                      ]);
            }
          } else if (i <= Cbytecodes$ReactTemplate.max_atom_tag) {
            return /* Vatom_stk */Block.__(6, [
                      at,
                      stk$1
                    ]);
          } else if (i === Cbytecodes$ReactTemplate.proj_tag) {
            var zproj = /* Zproj */Block.__(3, [at[0]]);
            _stk = /* :: */[
              zproj,
              stk$1
            ];
            _a = at[1];
            continue ;
            
          } else if (i === Cbytecodes$ReactTemplate.fix_app_tag) {
            var fa = at[1];
            var zfix_000 = fa[1];
            var zfix = /* Zfix */Block.__(1, [
                zfix_000,
                fa
              ]);
            _stk = /* :: */[
              zfix,
              stk$1
            ];
            _a = at[0];
            continue ;
            
          } else if (i === Cbytecodes$ReactTemplate.switch_tag) {
            var zswitch = /* Zswitch */Block.__(2, [at[1]]);
            _stk = /* :: */[
              zswitch,
              stk$1
            ];
            _a = at[0];
            continue ;
            
          } else if (i === Cbytecodes$ReactTemplate.cofix_tag) {
            var vcfx = at[0];
            if (stk$1) {
              var match$1 = stk$1[0];
              if (match$1.tag) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "vmvalues.ml",
                        237,
                        23
                      ]
                    ];
              } else if (stk$1[1]) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "vmvalues.ml",
                        237,
                        23
                      ]
                    ];
              } else {
                return /* Vcofix */Block.__(3, [
                          vcfx,
                          a,
                          /* Some */[match$1[0]]
                        ]);
              }
            } else {
              return /* Vcofix */Block.__(3, [
                        vcfx,
                        a,
                        /* None */0
                      ]);
            }
          } else if (i === Cbytecodes$ReactTemplate.cofix_evaluated_tag) {
            var vcofix = at[0];
            if (stk$1) {
              var match$2 = stk$1[0];
              if (match$2.tag) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "vmvalues.ml",
                        245,
                        23
                      ]
                    ];
              } else if (stk$1[1]) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "vmvalues.ml",
                        245,
                        23
                      ]
                    ];
              } else {
                return /* Vcofix */Block.__(3, [
                          vcofix,
                          a,
                          /* Some */[match$2[0]]
                        ]);
              }
            } else {
              return /* Vcofix */Block.__(3, [
                        vcofix,
                        a,
                        /* None */0
                      ]);
            }
          } else {
            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Failed to parse VM value. Tag = "), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(".")));
          }
        };
      } else {
        return /* Vprod */Block.__(0, [v]);
      }
    } else if (tag === Obj.closure_tag || tag === Obj.infix_tag) {
      var match$3 = Caml_missing_polyfill.not_implemented("coq_kind_of_closure not implemented by bucklescript yet\n");
      if (match$3 > 3 || match$3 < 0) {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Vm.whd "], Pp$ReactTemplate.str("kind_of_closure does not work."));
      } else {
        switch (match$3) {
          case 0 : 
              return /* Vfun */Block.__(1, [v]);
          case 1 : 
              return /* Vfix */Block.__(2, [
                        v,
                        /* None */0
                      ]);
          case 2 : 
              return /* Vfix */Block.__(2, [
                        v[1],
                        /* Some */[v]
                      ]);
          case 3 : 
              return /* Vatom_stk */Block.__(6, [
                        /* Aid */Block.__(0, [/* RelKey */Block.__(2, [Caml_missing_polyfill.not_implemented("coq_int_tcode not implemented by bucklescript yet\n")])]),
                        /* [] */0
                      ]);
          
        }
      }
    } else {
      return /* Vconstr_block */Block.__(5, [v]);
    }
  }
}

function obj_of_atom(a) {
  var res = Block.__(Cbytecodes$ReactTemplate.accu_tag, [
      0,
      0
    ]);
  res[0] = accumulate;
  res[1] = a;
  return res;
}

function obj_of_str_const(str) {
  switch (str.tag | 0) {
    case 0 : 
        return obj_of_atom(/* Asort */Block.__(2, [str[0]]));
    case 1 : 
        return obj_of_atom(/* Aind */Block.__(1, [str[0]]));
    case 2 : 
    case 3 : 
        return str[0];
    case 4 : 
        var args = str[1];
        var len = args.length;
        var res = Caml_obj.caml_obj_block(str[0], len);
        for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
          res[i] = obj_of_str_const(Caml_array.caml_array_get(args, i));
        }
        return res;
    case 5 : 
        return /* Vuniv_level */Block.__(7, [str[0]]);
    
  }
}

var val_of_str_const = obj_of_str_const;

var val_of_atom = obj_of_atom;

function atom_of_proj(kn, v) {
  var r = Block.__(Cbytecodes$ReactTemplate.proj_tag, [
      0,
      0
    ]);
  r[0] = kn;
  r[1] = v;
  return r;
}

function val_of_proj(kn, v) {
  return val_of_atom(atom_of_proj(kn, v));
}

function hash(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, Names$ReactTemplate.Constant[/* hash */13](param[0]));
    case 1 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](2, Curry._1(Names$ReactTemplate.Id[/* hash */2], param[0]));
    case 2 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](3, Int$ReactTemplate.hash(param[0]));
    case 3 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](4, Evar$ReactTemplate.hash(param[0]));
    
  }
}

var IdKeyHash = /* module */[
  /* equal */eq_id_key,
  /* hash */hash
];

var KeyTable = Hashtbl.Make(IdKeyHash);

var idkey_tbl = Curry._1(KeyTable[/* create */0], 31);

function val_of_idkey(key) {
  try {
    return Curry._2(KeyTable[/* find */6], idkey_tbl, key);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var v = val_of_atom(/* Aid */Block.__(0, [key]));
      Curry._3(KeyTable[/* add */4], idkey_tbl, key, v);
      return v;
    } else {
      throw exn;
    }
  }
}

function val_of_rel(k) {
  return val_of_idkey(/* RelKey */Block.__(2, [k]));
}

function val_of_named(id) {
  return val_of_idkey(/* VarKey */Block.__(1, [id]));
}

function val_of_constant(c) {
  return val_of_idkey(/* ConstKey */Block.__(0, [c]));
}

function val_of_evar(evk) {
  return val_of_idkey(/* EvarKey */Block.__(3, [evk]));
}

function dom(p) {
  return p[0];
}

function codom(p) {
  return p[1];
}

function first_fix() {
  return Caml_missing_polyfill.not_implemented("coq_offset_closure not implemented by bucklescript yet\n");
}

function last(o) {
  return o[o.length - 1 | 0];
}

var fix_types = last;

var cofix_types = last;

function current_fix() {
  return -(Caml_missing_polyfill.not_implemented("coq_offset not implemented by bucklescript yet\n") / 2 | 0) | 0;
}

function unsafe_rec_arg(_, _$1) {
  return Caml_missing_polyfill.not_implemented("coq_int_tcode not implemented by bucklescript yet\n");
}

function rec_args() {
  var fb = Caml_missing_polyfill.not_implemented("coq_offset_closure not implemented by bucklescript yet\n");
  var size = last(fb).length;
  return $$Array.init(size, (function (param) {
                return unsafe_rec_arg(fb, param);
              }));
}

var FALSE = Caml_exceptions.create("Vmvalues-ReactTemplate.FALSE");

function check_fix(f1, f2) {
  var i1 = current_fix(f1);
  var i2 = current_fix(f2);
  if (i1 === i2) {
    var fb1 = Caml_missing_polyfill.not_implemented("coq_offset_closure not implemented by bucklescript yet\n");
    var fb2 = Caml_missing_polyfill.not_implemented("coq_offset_closure not implemented by bucklescript yet\n");
    var n = last(fb1).length;
    if (n === last(fb2).length) {
      try {
        for(var i = 0 ,i_finish = n - 1 | 0; i <= i_finish; ++i){
          if (unsafe_rec_arg(fb1, i) !== unsafe_rec_arg(fb2, i)) {
            throw FALSE;
          }
          
        }
        return /* true */1;
      }
      catch (exn){
        if (exn === FALSE) {
          return /* false */0;
        } else {
          throw exn;
        }
      }
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

var atom_rel = Caml_missing_polyfill.not_implemented("get_coq_atom_tbl not implemented by bucklescript yet\n");

var len = atom_rel.length;

for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
  Caml_array.caml_array_set(atom_rel, i, /* Aid */Block.__(0, [/* RelKey */Block.__(2, [i])]));
}

var relaccu_tbl = [$$Array.init(len, (function () {
          return Caml_missing_polyfill.not_implemented("coq_makeaccu not implemented by bucklescript yet\n");
        }))];

function relaccu_code(i) {
  var len = relaccu_tbl[0].length;
  if (i < len) {
    return Caml_array.caml_array_get(relaccu_tbl[0], i);
  } else {
    Caml_missing_polyfill.not_implemented("realloc_coq_atom_tbl not implemented by bucklescript yet\n");
    var atom_rel = Caml_missing_polyfill.not_implemented("get_coq_atom_tbl not implemented by bucklescript yet\n");
    var nl = atom_rel.length;
    for(var j = len ,j_finish = nl - 1 | 0; j <= j_finish; ++j){
      Caml_array.caml_array_set(atom_rel, j, /* Aid */Block.__(0, [/* RelKey */Block.__(2, [j])]));
    }
    relaccu_tbl[0] = $$Array.init(nl, (function (j) {
            if (j < len) {
              return Caml_array.caml_array_get(relaccu_tbl[0], j);
            } else {
              return Caml_missing_polyfill.not_implemented("coq_makeaccu not implemented by bucklescript yet\n");
            }
          }));
    return Caml_array.caml_array_get(relaccu_tbl[0], i);
  }
}

function mk_fix_body(k, ndef, fb) {
  var e = Caml_obj.caml_obj_dup(fb);
  for(var i = 0 ,i_finish = ndef - 1 | 0; i <= i_finish; ++i){
    e[(i << 1)] = relaccu_code(k + i | 0);
  }
  var fix_body = function () {
    var c = Caml_missing_polyfill.not_implemented("coq_offset_tcode not implemented by bucklescript yet\n");
    var res = Block.__(Obj.closure_tag, [
        0,
        0
      ]);
    res[0] = c;
    res[1] = Caml_missing_polyfill.not_implemented("coq_offset_closure not implemented by bucklescript yet\n");
    return res;
  };
  return $$Array.init(ndef, fix_body);
}

function get_fcofix(vcf, i) {
  var match = whd_val(vcf[i + 1 | 0]);
  if (match.tag === 3) {
    return match[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "vmvalues.ml",
            453,
            9
          ]
        ];
  }
}

function current_cofix(vcf) {
  var ndef = last(vcf).length;
  try {
    var _pos = 0;
    while(true) {
      var pos = _pos;
      if (pos < ndef) {
        if (get_fcofix(vcf, pos) === vcf) {
          return pos;
        } else {
          _pos = pos + 1 | 0;
          continue ;
          
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "vmvalues.ml",
              463,
              20
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function check_cofix(vcf1, vcf2) {
  if (current_cofix(vcf1) === current_cofix(vcf2)) {
    return +(last(vcf1).length === last(vcf2).length);
  } else {
    return /* false */0;
  }
}

function mk_cofix_body(apply_varray, k, ndef, vcf) {
  var e = Caml_obj.caml_obj_dup(vcf);
  for(var i = 0 ,i_finish = ndef - 1 | 0; i <= i_finish; ++i){
    e[i + 1 | 0] = val_of_rel(k + i | 0);
  }
  var cofix_body = function (i) {
    var vcfi = get_fcofix(vcf, i);
    var c = vcfi[0];
    e[0] = c;
    var atom = Block.__(Cbytecodes$ReactTemplate.cofix_tag, [0]);
    var self = Block.__(Cbytecodes$ReactTemplate.accu_tag, [
        0,
        0
      ]);
    self[0] = accumulate;
    self[1] = atom;
    return Curry._2(apply_varray, e, /* array */[self]);
  };
  return $$Array.init(ndef, cofix_body);
}

function btag(b) {
  return b.tag | 0;
}

function bsize(b) {
  return b.length;
}

function bfield(b, i) {
  if (0 <= i && i < b.length) {
    return b[i];
  } else {
    return Pervasives.invalid_arg("Vm.bfield");
  }
}

function check_switch(sw1, sw2) {
  return Caml_obj.caml_equal(sw1[/* sw_annot */2][/* rtbl */1], sw2[/* sw_annot */2][/* rtbl */1]);
}

function branch_arg(k, param) {
  var arity = param[1];
  var tag = param[0];
  if (arity) {
    var match;
    if (tag < Cbytecodes$ReactTemplate.last_variant_tag) {
      match = /* tuple */[
        Caml_obj.caml_obj_block(tag, arity),
        0
      ];
    } else {
      var b = Caml_obj.caml_obj_block(Cbytecodes$ReactTemplate.last_variant_tag, arity + 1 | 0);
      b[0] = tag - Cbytecodes$ReactTemplate.last_variant_tag | 0;
      match = /* tuple */[
        b,
        1
      ];
    }
    var ofs = match[1];
    var b$1 = match[0];
    for(var i = ofs ,i_finish = (ofs + arity | 0) - 1 | 0; i <= i_finish; ++i){
      b$1[i] = val_of_rel(k + i | 0);
    }
    return b$1;
  } else {
    return tag;
  }
}

function pr_stack(stk) {
  if (stk) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_zipper(stk[0]), Pp$ReactTemplate.str(" :: ")), pr_stack(stk[1]));
  } else {
    return Pp$ReactTemplate.str("[]");
  }
}

function pr_zipper(z) {
  switch (z.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Zapp(len = "), Pp$ReactTemplate.$$int(z[0].length - 2 | 0)), Pp$ReactTemplate.str(")"));
    case 1 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Zfix(..., len="), Pp$ReactTemplate.$$int(z[1].length - 2 | 0)), Pp$ReactTemplate.str(")"));
    case 2 : 
        return Pp$ReactTemplate.str("Zswitch(...)");
    case 3 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Zproj("), Names$ReactTemplate.Constant[/* print */16](z[0])), Pp$ReactTemplate.str(")"));
    
  }
}

function pr_atom(a) {
  switch (a.tag | 0) {
    case 0 : 
        var c = a[0];
        var tmp;
        switch (c.tag | 0) {
          case 0 : 
              tmp = Names$ReactTemplate.Constant[/* print */16](c[0]);
              break;
          case 2 : 
              tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("#"), Pp$ReactTemplate.$$int(c[0]));
              break;
          case 1 : 
          case 3 : 
              tmp = Pp$ReactTemplate.str("...");
              break;
          
        }
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Aid("), tmp), Pp$ReactTemplate.str(")"));
    case 1 : 
        var match = a[0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Aind("), Names$ReactTemplate.MutInd[/* print */15](match[0])), Pp$ReactTemplate.str("#")), Pp$ReactTemplate.$$int(match[1])), Pp$ReactTemplate.str(")"));
    case 2 : 
        return Pp$ReactTemplate.str("Asort(");
    
  }
}

function pr_whd(w) {
  switch (w.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.str("Vprod");
    case 1 : 
        return Pp$ReactTemplate.str("Vfun");
    case 2 : 
        return Pp$ReactTemplate.str("Vfix");
    case 3 : 
        return Pp$ReactTemplate.str("Vcofix");
    case 4 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Vconstr_const("), Pp$ReactTemplate.$$int(w[0])), Pp$ReactTemplate.str(")"));
    case 5 : 
        return Pp$ReactTemplate.str("Vconstr_block");
    case 6 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Vatom_stk("), pr_atom(w[0])), Pp$ReactTemplate.str(", ")), pr_stack(w[1])), Pp$ReactTemplate.str(")"));
    case 7 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "vmvalues.ml",
                532,
                21
              ]
            ];
    
  }
}

var crazy_val = 0;

exports.fun_val = fun_val;
exports.fix_val = fix_val;
exports.cofix_upd_val = cofix_upd_val;
exports.fun_env = fun_env;
exports.fix_env = fix_env;
exports.cofix_env = cofix_env;
exports.cofix_upd_env = cofix_upd_env;
exports.fun_of_val = fun_of_val;
exports.crazy_val = crazy_val;
exports.fun_code = fun_code;
exports.fix_code = fix_code;
exports.cofix_upd_code = cofix_upd_code;
exports.eq_id_key = eq_id_key;
exports.pr_atom = pr_atom;
exports.pr_whd = pr_whd;
exports.pr_stack = pr_stack;
exports.val_of_str_const = val_of_str_const;
exports.val_of_rel = val_of_rel;
exports.val_of_named = val_of_named;
exports.val_of_constant = val_of_constant;
exports.val_of_evar = val_of_evar;
exports.val_of_proj = val_of_proj;
exports.val_of_atom = val_of_atom;
exports.whd_val = whd_val;
exports.uni_lvl_val = uni_lvl_val;
exports.nargs = nargs;
exports.arg = arg;
exports.dom = dom;
exports.codom = codom;
exports.current_fix = current_fix;
exports.check_fix = check_fix;
exports.rec_args = rec_args;
exports.first_fix = first_fix;
exports.fix_types = fix_types;
exports.cofix_types = cofix_types;
exports.mk_fix_body = mk_fix_body;
exports.current_cofix = current_cofix;
exports.check_cofix = check_cofix;
exports.mk_cofix_body = mk_cofix_body;
exports.btag = btag;
exports.bsize = bsize;
exports.bfield = bfield;
exports.check_switch = check_switch;
exports.branch_arg = branch_arg;
/*  Not a pure module */
