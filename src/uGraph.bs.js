// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function error_inconsistency(o, u, v, p) {
  throw [
        Univ$ReactTemplate.UniverseInconsistency,
        /* tuple */[
          o,
          Univ$ReactTemplate.Universe[/* make */3](u),
          Univ$ReactTemplate.Universe[/* make */3](v),
          p
        ]
      ];
}

function cleanup_universes(g) {
  try {
    var g$1 = g;
    var iter = function (_, n) {
      if (n.tag) {
        return /* () */0;
      } else {
        n[0][/* status */6] = /* NoMark */0;
        return /* () */0;
      }
    };
    return Curry._2(Univ$ReactTemplate.LMap[/* iter */9], iter, g$1[/* entries */0]);
  }
  catch (e){
    cleanup_universes(g);
    throw e;
  }
}

function change_node(g, n) {
  return /* record */[
          /* entries */Curry._3(Univ$ReactTemplate.LMap[/* modify */26], n[/* univ */0], (function (_, a) {
                  if (a.tag) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "uGraph.ml",
                            128,
                            17
                          ]
                        ];
                  } else {
                    a[0][/* status */6] = /* NoMark */0;
                    return /* Canonical */Block.__(0, [n]);
                  }
                }), g[/* entries */0]),
          /* index */g[/* index */1],
          /* n_nodes */g[/* n_nodes */2],
          /* n_edges */g[/* n_edges */3]
        ];
}

function repr(g, _u) {
  while(true) {
    var u = _u;
    var a;
    try {
      a = Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, g[/* entries */0]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        a = CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Univ.repr"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Universe "), Univ$ReactTemplate.Level[/* pr */9](u)), Pp$ReactTemplate.str(" undefined.")));
      } else {
        throw exn;
      }
    }
    if (a.tag) {
      _u = a[0];
      continue ;
      
    } else {
      return a[0];
    }
  };
}

var AlreadyDeclared = Caml_exceptions.create("UGraph-ReactTemplate.AlreadyDeclared");

function use_index(g, u) {
  var u$1 = repr(g, u);
  var newrecord = u$1.slice();
  var g$1 = change_node(g, (newrecord[/* ilvl */5] = g[/* index */1], newrecord));
  if (g$1[/* index */1] <= Pervasives.min_int) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "uGraph.ml",
            153,
            2
          ]
        ];
  }
  return /* record */[
          /* entries */g$1[/* entries */0],
          /* index */g$1[/* index */1] - 1 | 0,
          /* n_nodes */g$1[/* n_nodes */2],
          /* n_edges */g$1[/* n_edges */3]
        ];
}

function safe_repr(g, u) {
  var safe_repr_rec = function (entries, _u) {
    while(true) {
      var u = _u;
      var match = Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, entries);
      if (match.tag) {
        _u = match[0];
        continue ;
        
      } else {
        return match[0];
      }
    };
  };
  try {
    return /* tuple */[
            g,
            safe_repr_rec(g[/* entries */0], u)
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var can = /* record */[
        /* univ */u,
        /* ltle */Univ$ReactTemplate.LMap[/* empty */0],
        /* gtge */Univ$ReactTemplate.LSet[/* empty */0],
        /* rank */Univ$ReactTemplate.Level[/* is_small */2](u) ? 1000000 : 0,
        /* klvl */0,
        /* ilvl */0,
        /* status : NoMark */0
      ];
      var g_000 = /* entries */Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, /* Canonical */Block.__(0, [can]), g[/* entries */0]);
      var g_001 = /* index */g[/* index */1];
      var g_002 = /* n_nodes */g[/* n_nodes */2] + 1 | 0;
      var g_003 = /* n_edges */g[/* n_edges */3];
      var g$1 = /* record */[
        g_000,
        g_001,
        g_002,
        g_003
      ];
      var g$2 = use_index(g$1, u);
      return /* tuple */[
              g$2,
              repr(g$2, u)
            ];
    } else {
      throw exn;
    }
  }
}

function topo_compare(u, v) {
  if (u[/* klvl */4] > v[/* klvl */4]) {
    return 1;
  } else if (u[/* klvl */4] < v[/* klvl */4]) {
    return -1;
  } else if (u[/* ilvl */5] > v[/* ilvl */5]) {
    return 1;
  } else if (u[/* ilvl */5] < v[/* ilvl */5]) {
    return -1;
  } else {
    if (u !== v) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "uGraph.ml",
              188,
              8
            ]
          ];
    }
    return 0;
  }
}

function check_universes_invariants(g) {
  var n_edges = [0];
  var n_nodes = [0];
  Curry._2(Univ$ReactTemplate.LMap[/* iter */9], (function (l, u) {
          if (u.tag) {
            if (Univ$ReactTemplate.Level[/* is_small */2](l)) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "uGraph.ml",
                      216,
                      17
                    ]
                  ];
            } else {
              return 0;
            }
          } else {
            var u$1 = u[0];
            Curry._2(Univ$ReactTemplate.LMap[/* iter */9], (function (v, _) {
                    n_edges[0] = n_edges[0] + 1 | 0;
                    var v$1 = repr(g, v);
                    if (topo_compare(u$1, v$1) !== -1) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "uGraph.ml",
                              200,
                              10
                            ]
                          ];
                    }
                    if (u$1[/* klvl */4] === v$1[/* klvl */4]) {
                      if (Curry._2(Univ$ReactTemplate.LSet[/* mem */2], u$1[/* univ */0], v$1[/* gtge */2]) || Curry._2(Univ$ReactTemplate.LSet[/* exists */15], (function (l) {
                                return +(u$1 === repr(g, l));
                              }), v$1[/* gtge */2])) {
                        return 0;
                      } else {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "uGraph.ml",
                                202,
                                12
                              ]
                            ];
                      }
                    } else {
                      return 0;
                    }
                  }), u$1[/* ltle */1]);
            Curry._2(Univ$ReactTemplate.LSet[/* iter */12], (function (v) {
                    var v$1 = repr(g, v);
                    if (v$1[/* klvl */4] === u$1[/* klvl */4] && (Curry._2(Univ$ReactTemplate.LMap[/* mem */2], u$1[/* univ */0], v$1[/* ltle */1]) || Curry._2(Univ$ReactTemplate.LMap[/* exists */12], (function (l, _) {
                                return +(u$1 === repr(g, l));
                              }), v$1[/* ltle */1]))) {
                      return 0;
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "uGraph.ml",
                              207,
                              8
                            ]
                          ];
                    }
                  }), u$1[/* gtge */2]);
            if (u$1[/* status */6] !== /* NoMark */0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "uGraph.ml",
                      211,
                      6
                    ]
                  ];
            }
            if (!Univ$ReactTemplate.Level[/* equal */6](l, u$1[/* univ */0])) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "uGraph.ml",
                      212,
                      6
                    ]
                  ];
            }
            if (u$1[/* ilvl */5] <= g[/* index */1]) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "uGraph.ml",
                      213,
                      6
                    ]
                  ];
            }
            if (Curry._2(Univ$ReactTemplate.LMap[/* mem */2], u$1[/* univ */0], u$1[/* ltle */1])) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "uGraph.ml",
                      214,
                      6
                    ]
                  ];
            }
            n_nodes[0] = n_nodes[0] + 1 | 0;
            return /* () */0;
          }
        }), g[/* entries */0]);
  if (n_edges[0] !== g[/* n_edges */3]) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "uGraph.ml",
            218,
            2
          ]
        ];
  }
  if (n_nodes[0] === g[/* n_nodes */2]) {
    return 0;
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "uGraph.ml",
            219,
            2
          ]
        ];
  }
}

function clean_ltle(g, ltle) {
  return Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (u, strict, acc) {
                var uu = repr(g, u)[/* univ */0];
                if (Univ$ReactTemplate.Level[/* equal */6](uu, u)) {
                  return acc;
                } else {
                  var acc$1 = Curry._2(Univ$ReactTemplate.LMap[/* remove */5], u, acc[0]);
                  if (!strict && Curry._2(Univ$ReactTemplate.LMap[/* mem */2], uu, acc$1)) {
                    return /* tuple */[
                            acc$1,
                            /* true */1
                          ];
                  } else {
                    return /* tuple */[
                            Curry._3(Univ$ReactTemplate.LMap[/* add */3], uu, strict, acc$1),
                            /* true */1
                          ];
                  }
                }
              }), ltle, /* tuple */[
              ltle,
              /* false */0
            ]);
}

function clean_gtge(g, gtge) {
  return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], (function (u, acc) {
                var uu = repr(g, u)[/* univ */0];
                if (Univ$ReactTemplate.Level[/* equal */6](uu, u)) {
                  return acc;
                } else {
                  return /* tuple */[
                          Curry._2(Univ$ReactTemplate.LSet[/* add */3], uu, Curry._2(Univ$ReactTemplate.LSet[/* remove */5], u, acc[0])),
                          /* true */1
                        ];
                }
              }), gtge, /* tuple */[
              gtge,
              /* false */0
            ]);
}

function get_ltle(g, u) {
  var match = clean_ltle(g, u[/* ltle */1]);
  if (match[1]) {
    var ltle = match[0];
    var sz = Curry._1(Univ$ReactTemplate.LMap[/* cardinal */15], u[/* ltle */1]);
    var sz2 = Curry._1(Univ$ReactTemplate.LMap[/* cardinal */15], ltle);
    var newrecord = u.slice();
    newrecord[/* ltle */1] = ltle;
    var g$1 = change_node(g, newrecord);
    var g_000 = /* entries */g$1[/* entries */0];
    var g_001 = /* index */g$1[/* index */1];
    var g_002 = /* n_nodes */g$1[/* n_nodes */2];
    var g_003 = /* n_edges */(g$1[/* n_edges */3] + sz2 | 0) - sz | 0;
    var g$2 = /* record */[
      g_000,
      g_001,
      g_002,
      g_003
    ];
    return /* tuple */[
            newrecord[/* ltle */1],
            newrecord,
            g$2
          ];
  } else {
    return /* tuple */[
            u[/* ltle */1],
            u,
            g
          ];
  }
}

function get_gtge(g, u) {
  var match = clean_gtge(g, u[/* gtge */2]);
  if (match[1]) {
    var newrecord = u.slice();
    newrecord[/* gtge */2] = match[0];
    var g$1 = change_node(g, newrecord);
    return /* tuple */[
            newrecord[/* gtge */2],
            newrecord,
            g$1
          ];
  } else {
    return /* tuple */[
            u[/* gtge */2],
            u,
            g
          ];
  }
}

function revert_graph(to_revert, g) {
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (t) {
                var match = Curry._2(Univ$ReactTemplate.LMap[/* find */21], t, g[/* entries */0]);
                if (match.tag) {
                  return /* () */0;
                } else {
                  match[0][/* status */6] = /* NoMark */0;
                  return /* () */0;
                }
              }), to_revert);
}

var AbortBackward = Caml_exceptions.create("UGraph-ReactTemplate.AbortBackward");

var CycleDetected = Caml_exceptions.create("UGraph-ReactTemplate.CycleDetected");

function get_delta(g) {
  return Caml_primitive.caml_float_min(Math.pow(g[/* n_edges */3], 0.5), Math.pow(g[/* n_nodes */2], 2 / 3)) | 0;
}

function backward_traverse(to_revert, b_traversed, count, g, x) {
  var x$1 = repr(g, x);
  var count$1 = count - 1 | 0;
  if (count$1 < 0) {
    revert_graph(to_revert, g);
    throw [
          AbortBackward,
          g
        ];
  }
  if (x$1[/* status */6]) {
    return /* tuple */[
            to_revert,
            b_traversed,
            count$1,
            g
          ];
  } else {
    x$1[/* status */6] = /* Visited */1;
    var to_revert_000 = x$1[/* univ */0];
    var to_revert$1 = /* :: */[
      to_revert_000,
      to_revert
    ];
    var match = get_gtge(g, x$1);
    var match$1 = Curry._3(Univ$ReactTemplate.LSet[/* fold */13], (function (y, param) {
            return backward_traverse(param[0], param[1], param[2], param[3], y);
          }), match[0], /* tuple */[
          to_revert$1,
          b_traversed,
          count$1,
          match[2]
        ]);
    return /* tuple */[
            match$1[0],
            /* :: */[
              match[1][/* univ */0],
              match$1[1]
            ],
            match$1[2],
            match$1[3]
          ];
  }
}

function forward_traverse(f_traversed, g, v_klvl, x, y) {
  var y$1 = repr(g, y);
  if (y$1[/* klvl */4] < v_klvl) {
    var y_000 = /* univ */y$1[/* univ */0];
    var y_001 = /* ltle */y$1[/* ltle */1];
    var y_002 = /* gtge */x === y$1 ? Univ$ReactTemplate.LSet[/* empty */0] : Curry._1(Univ$ReactTemplate.LSet[/* singleton */4], x[/* univ */0]);
    var y_003 = /* rank */y$1[/* rank */3];
    var y_005 = /* ilvl */y$1[/* ilvl */5];
    var y_006 = /* status */y$1[/* status */6];
    var y$2 = /* record */[
      y_000,
      y_001,
      y_002,
      y_003,
      /* klvl */v_klvl,
      y_005,
      y_006
    ];
    var g$1 = change_node(g, y$2);
    var match = get_ltle(g$1, y$2);
    var y$3 = match[1];
    var match$1 = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (z, _, param) {
            return forward_traverse(param[0], param[1], v_klvl, y$3, z);
          }), match[0], /* tuple */[
          f_traversed,
          match[2]
        ]);
    return /* tuple */[
            /* :: */[
              y$3[/* univ */0],
              match$1[0]
            ],
            match$1[1]
          ];
  } else if (y$1[/* klvl */4] === v_klvl && x !== y$1) {
    var newrecord = y$1.slice();
    var g$2 = change_node(g, (newrecord[/* gtge */2] = Curry._2(Univ$ReactTemplate.LSet[/* add */3], x[/* univ */0], y$1[/* gtge */2]), newrecord));
    return /* tuple */[
            f_traversed,
            g$2
          ];
  } else {
    return /* tuple */[
            f_traversed,
            g
          ];
  }
}

function find_to_merge(to_revert, g, x, v) {
  var x$1 = repr(g, x);
  var match = x$1[/* status */6];
  switch (match) {
    case 0 : 
        var to_revert$1 = /* :: */[
          x$1,
          to_revert
        ];
        if (Univ$ReactTemplate.Level[/* equal */6](x$1[/* univ */0], v)) {
          x$1[/* status */6] = /* ToMerge */3;
          return /* tuple */[
                  /* true */1,
                  to_revert$1
                ];
        } else {
          var match$1 = Curry._3(Univ$ReactTemplate.LSet[/* fold */13], (function (y, param) {
                  var match = find_to_merge(param[1], g, y, v);
                  return /* tuple */[
                          match[0] || param[0],
                          match[1]
                        ];
                }), x$1[/* gtge */2], /* tuple */[
                /* false */0,
                to_revert$1
              ]);
          var merge = match$1[0];
          x$1[/* status */6] = merge ? /* ToMerge */3 : /* Visited */1;
          return /* tuple */[
                  merge,
                  match$1[1]
                ];
        }
        break;
    case 1 : 
        return /* tuple */[
                /* false */0,
                to_revert
              ];
    case 2 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "uGraph.ml",
                350,
                9
              ]
            ];
    case 3 : 
        return /* tuple */[
                /* true */1,
                to_revert
              ];
    
  }
}

function get_new_edges(g, to_merge) {
  var to_merge_lvl = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, u) {
          return Curry._3(Univ$ReactTemplate.LMap[/* add */3], u[/* univ */0], u, acc);
        }), Univ$ReactTemplate.LMap[/* empty */0], to_merge);
  var fold = function (_, n, acc) {
    var fold$1 = function (u, strict, acc) {
      if (strict) {
        return Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, strict, acc);
      } else if (Curry._2(Univ$ReactTemplate.LMap[/* mem */2], u, acc)) {
        return acc;
      } else {
        return Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, /* false */0, acc);
      }
    };
    return Curry._3(Univ$ReactTemplate.LMap[/* fold */10], fold$1, n[/* ltle */1], acc);
  };
  var ltle = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], fold, to_merge_lvl, Univ$ReactTemplate.LMap[/* empty */0]);
  var match = clean_ltle(g, ltle);
  var ltle$1 = Curry._3(Univ$ReactTemplate.LMap[/* merge */6], (function (_, a, strict) {
          if (a) {
            if (strict) {
              if (strict[0] !== 0) {
                throw CycleDetected;
              } else {
                return /* None */0;
              }
            } else {
              return strict;
            }
          } else {
            return strict;
          }
        }), to_merge_lvl, match[0]);
  var gtge = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (_, n, acc) {
          return Curry._2(Univ$ReactTemplate.LSet[/* union */6], acc, n[/* gtge */2]);
        }), to_merge_lvl, Univ$ReactTemplate.LSet[/* empty */0]);
  var match$1 = clean_gtge(g, gtge);
  var gtge$1 = Curry._2(Univ$ReactTemplate.LSet[/* diff */8], match$1[0], Curry._1(Univ$ReactTemplate.LMap[/* domain */27], to_merge_lvl));
  return /* tuple */[
          ltle$1,
          gtge$1
        ];
}

function reorder(g, u, v) {
  var delta = get_delta(g);
  var match;
  try {
    var match$1 = backward_traverse(/* [] */0, /* [] */0, delta, g, u);
    var g$1 = match$1[3];
    revert_graph(match$1[0], g$1);
    var v_klvl = repr(g$1, u)[/* klvl */4];
    match = /* tuple */[
      match$1[1],
      v_klvl,
      g$1
    ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === AbortBackward) {
      var g$2 = exn[1];
      var v_klvl$1 = repr(g$2, u)[/* klvl */4] + 1 | 0;
      match = /* tuple */[
        /* [] */0,
        v_klvl$1,
        g$2
      ];
    } else {
      throw exn;
    }
  }
  var g$3 = match[2];
  var v_klvl$2 = match[1];
  var b_traversed = match[0];
  var match$2 = forward_traverse(/* [] */0, g$3, v_klvl$2, repr(g$3, v), v);
  var g$4 = match$2[1];
  var f_traversed = match$2[0];
  var match$3;
  if (repr(g$4, u)[/* klvl */4] === v_klvl$2) {
    var match$4 = find_to_merge(/* [] */0, g$4, u, v);
    var to_revert = match$4[1];
    var r = match$4[0] ? /* tuple */[
        Curry._2(Util$ReactTemplate.List[/* filter */27], (function (u) {
                return +(u[/* status */6] === /* ToMerge */3);
              }), to_revert),
        Curry._2(Util$ReactTemplate.List[/* filter */27], (function (u) {
                return +(repr(g$4, u)[/* status */6] !== /* ToMerge */3);
              }), b_traversed),
        Curry._2(Util$ReactTemplate.List[/* filter */27], (function (u) {
                return +(repr(g$4, u)[/* status */6] !== /* ToMerge */3);
              }), f_traversed)
      ] : /* tuple */[
        /* [] */0,
        b_traversed,
        f_traversed
      ];
    Curry._2(Util$ReactTemplate.List[/* iter */9], (function (u) {
            u[/* status */6] = /* NoMark */0;
            return /* () */0;
          }), to_revert);
    match$3 = r;
  } else {
    match$3 = /* tuple */[
      /* [] */0,
      b_traversed,
      f_traversed
    ];
  }
  var f_reindex = match$3[2];
  var b_reindex = match$3[1];
  var to_merge = match$3[0];
  var match$5;
  if (to_merge) {
    var match$6 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, n) {
            var best = acc[0];
            if (n[/* rank */3] >= best[/* rank */3]) {
              return /* tuple */[
                      n,
                      best[/* rank */3]
                    ];
            } else {
              return acc;
            }
          }), /* tuple */[
          to_merge[0],
          Pervasives.min_int
        ], to_merge[1]);
    var root = match$6[0];
    var match$7 = get_new_edges(g$4, to_merge);
    var ltle = match$7[0];
    var g$5 = change_node(g$4, /* record */[
          /* univ */root[/* univ */0],
          /* ltle */ltle,
          /* gtge */match$7[1],
          /* rank */Caml_primitive.caml_int_max(root[/* rank */3], match$6[1] + 1 | 0),
          /* klvl */root[/* klvl */4],
          /* ilvl */root[/* ilvl */5],
          /* status */root[/* status */6]
        ]);
    var g$6 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (g, n) {
            if (Univ$ReactTemplate.Level[/* equal */6](n[/* univ */0], root[/* univ */0])) {
              return g;
            } else {
              var g$1 = g;
              var u = n[/* univ */0];
              var v = root[/* univ */0];
              return /* record */[
                      /* entries */Curry._3(Univ$ReactTemplate.LMap[/* modify */26], u, (function (_, a) {
                              if (a.tag) {
                                throw [
                                      Caml_builtin_exceptions.assert_failure,
                                      [
                                        "uGraph.ml",
                                        111,
                                        15
                                      ]
                                    ];
                              } else {
                                a[0][/* status */6] = /* NoMark */0;
                                return /* Equiv */Block.__(1, [v]);
                              }
                            }), g$1[/* entries */0]),
                      /* index */g$1[/* index */1],
                      /* n_nodes */g$1[/* n_nodes */2] - 1 | 0,
                      /* n_edges */g$1[/* n_edges */3]
                    ];
            }
          }), g$5, to_merge);
    var oldsz = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (sz, u) {
            return sz + Curry._1(Univ$ReactTemplate.LMap[/* cardinal */15], u[/* ltle */1]) | 0;
          }), 0, to_merge);
    var sz = Curry._1(Univ$ReactTemplate.LMap[/* cardinal */15], ltle);
    var g_000 = /* entries */g$6[/* entries */0];
    var g_001 = /* index */g$6[/* index */1];
    var g_002 = /* n_nodes */g$6[/* n_nodes */2];
    var g_003 = /* n_edges */(g$6[/* n_edges */3] + sz | 0) - oldsz | 0;
    var g$7 = /* record */[
      g_000,
      g_001,
      g_002,
      g_003
    ];
    match$5 = /* tuple */[
      Curry._2(Util$ReactTemplate.List[/* rev_append */6], f_reindex, /* :: */[
            root[/* univ */0],
            b_reindex
          ]),
      g$7
    ];
  } else {
    match$5 = /* tuple */[
      Curry._2(Util$ReactTemplate.List[/* rev_append */6], f_reindex, b_reindex),
      g$4
    ];
  }
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], use_index, match$5[1], match$5[0]);
}

function insert_edge(strict, ucan, vcan, g) {
  try {
    var u = ucan[/* univ */0];
    var v = vcan[/* univ */0];
    var g$1 = topo_compare(ucan, vcan) <= 0 ? g : reorder(g, u, v);
    var u$1 = repr(g$1, u);
    var v$1 = repr(g$1, v);
    if (u$1 === v$1) {
      if (strict) {
        throw CycleDetected;
      } else {
        return g$1;
      }
    } else {
      var g$2;
      try {
        var oldstrict = Curry._2(Univ$ReactTemplate.LMap[/* find */21], v$1[/* univ */0], u$1[/* ltle */1]);
        if (strict && !oldstrict) {
          var newrecord = u$1.slice();
          g$2 = change_node(g$1, (newrecord[/* ltle */1] = Curry._3(Univ$ReactTemplate.LMap[/* add */3], v$1[/* univ */0], /* true */1, u$1[/* ltle */1]), newrecord));
        } else {
          g$2 = g$1;
        }
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var newrecord$1 = u$1.slice();
          var init = change_node(g$1, (newrecord$1[/* ltle */1] = Curry._3(Univ$ReactTemplate.LMap[/* add */3], v$1[/* univ */0], strict, u$1[/* ltle */1]), newrecord$1));
          g$2 = /* record */[
            /* entries */init[/* entries */0],
            /* index */init[/* index */1],
            /* n_nodes */init[/* n_nodes */2],
            /* n_edges */g$1[/* n_edges */3] + 1 | 0
          ];
        } else {
          throw exn;
        }
      }
      if (u$1[/* klvl */4] !== v$1[/* klvl */4] || Curry._2(Univ$ReactTemplate.LSet[/* mem */2], u$1[/* univ */0], v$1[/* gtge */2])) {
        return g$2;
      } else {
        var newrecord$2 = v$1.slice();
        newrecord$2[/* gtge */2] = Curry._2(Univ$ReactTemplate.LSet[/* add */3], u$1[/* univ */0], v$1[/* gtge */2]);
        return change_node(g$2, newrecord$2);
      }
    }
  }
  catch (e){
    if (e === CycleDetected) {
      throw e;
    } else {
      cleanup_universes(g);
      throw e;
    }
  }
}

function add_universe(vlev, strict, g) {
  try {
    Curry._2(Univ$ReactTemplate.LMap[/* find */21], vlev, g[/* entries */0]);
    throw AlreadyDeclared;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (g[/* index */1] <= Pervasives.min_int) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "uGraph.ml",
                511,
                4
              ]
            ];
      }
      var v = /* record */[
        /* univ */vlev,
        /* ltle */Univ$ReactTemplate.LMap[/* empty */0],
        /* gtge */Univ$ReactTemplate.LSet[/* empty */0],
        /* rank */0,
        /* klvl */0,
        /* ilvl */g[/* index */1],
        /* status : NoMark */0
      ];
      var entries = Curry._3(Univ$ReactTemplate.LMap[/* add */3], vlev, /* Canonical */Block.__(0, [v]), g[/* entries */0]);
      var g_001 = /* index */g[/* index */1] - 1 | 0;
      var g_002 = /* n_nodes */g[/* n_nodes */2] + 1 | 0;
      var g_003 = /* n_edges */g[/* n_edges */3];
      var g$1 = /* record */[
        /* entries */entries,
        g_001,
        g_002,
        g_003
      ];
      return insert_edge(strict, repr(g$1, Univ$ReactTemplate.Level[/* set */0]), v, g$1);
    } else {
      throw exn;
    }
  }
}

var Found_explanation = Caml_exceptions.create("UGraph-ReactTemplate.Found_explanation");

function get_explanation(strict, u, v, g) {
  var v$1 = repr(g, v);
  var visited_strict = [Univ$ReactTemplate.LMap[/* empty */0]];
  var traverse = function (strict, u) {
    if (u === v$1) {
      if (strict) {
        return /* None */0;
      } else {
        return /* Some */[/* [] */0];
      }
    } else if (topo_compare(u, v$1) === 1) {
      return /* None */0;
    } else {
      var visited;
      try {
        visited = 1 - Curry._2(Univ$ReactTemplate.LMap[/* find */21], u[/* univ */0], visited_strict[0]) || strict;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          visited = /* false */0;
        } else {
          throw exn;
        }
      }
      if (visited) {
        return /* None */0;
      } else {
        visited_strict[0] = Curry._3(Univ$ReactTemplate.LMap[/* add */3], u[/* univ */0], strict, visited_strict[0]);
        try {
          Curry._2(Univ$ReactTemplate.LMap[/* iter */9], (function (u$prime, strictu$prime) {
                  var match = traverse(strict && 1 - strictu$prime, repr(g, u$prime));
                  if (match) {
                    var typ = strictu$prime ? /* Lt */0 : /* Le */1;
                    throw [
                          Found_explanation,
                          /* :: */[
                            /* tuple */[
                              typ,
                              Univ$ReactTemplate.Universe[/* make */3](u$prime)
                            ],
                            match[0]
                          ]
                        ];
                  } else {
                    return /* () */0;
                  }
                }), u[/* ltle */1]);
          return /* None */0;
        }
        catch (raw_exn){
          var exn$1 = Js_exn.internalToOCamlException(raw_exn);
          if (exn$1[0] === Found_explanation) {
            return /* Some */[exn$1[1]];
          } else {
            throw exn$1;
          }
        }
      }
    }
  };
  var u$1 = repr(g, u);
  if (u$1 === v$1) {
    return /* :: */[
            /* tuple */[
              /* Eq */2,
              Univ$ReactTemplate.Universe[/* make */3](v$1[/* univ */0])
            ],
            /* [] */0
          ];
  } else {
    var match = traverse(strict, u$1);
    if (match) {
      return match[0];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "uGraph.ml",
              557,
              62
            ]
          ];
    }
  }
}

function get_explanation$1(strict, u, v, g) {
  if (Flags$ReactTemplate.univ_print[0]) {
    return /* Some */[get_explanation(strict, u, v, g)];
  } else {
    return /* None */0;
  }
}

var Found = Caml_exceptions.create("UGraph-ReactTemplate.Found");

function search_path(strict, u, v, g) {
  var loop = function (_to_revert, _todo, _next_todo) {
    while(true) {
      var next_todo = _next_todo;
      var todo = _todo;
      var to_revert = _to_revert;
      if (todo) {
        var todo$1 = todo[1];
        var match = todo[0];
        var strict = match[1];
        var u = match[0];
        if (u[/* status */6] === /* Visited */1 || u[/* status */6] === /* WeakVisited */2 && strict) {
          _todo = todo$1;
          continue ;
          
        } else {
          var to_revert$1 = u[/* status */6] ? to_revert : /* :: */[
              u,
              to_revert
            ];
          u[/* status */6] = strict ? /* WeakVisited */2 : /* Visited */1;
          var tmp;
          try {
            tmp = Curry._2(Univ$ReactTemplate.LMap[/* find */21], v[/* univ */0], u[/* ltle */1]) || 1 - strict;
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              tmp = /* false */0;
            } else {
              throw exn;
            }
          }
          if (tmp) {
            throw [
                  Found,
                  to_revert$1
                ];
          } else {
            var next_todo$1 = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function(strict,to_revert$1){
                return function (u, strictu, next_todo) {
                  var strict$1 = 1 - strictu && strict;
                  var u$1 = repr(g, u);
                  if (u$1 === v && !strict$1) {
                    throw [
                          Found,
                          to_revert$1
                        ];
                  } else if (topo_compare(u$1, v) === 1) {
                    return next_todo;
                  } else {
                    return /* :: */[
                            /* tuple */[
                              u$1,
                              strict$1
                            ],
                            next_todo
                          ];
                  }
                }
                }(strict,to_revert$1)), u[/* ltle */1], next_todo);
            _next_todo = next_todo$1;
            _todo = todo$1;
            _to_revert = to_revert$1;
            continue ;
            
          }
        }
      } else if (next_todo) {
        _next_todo = /* [] */0;
        _todo = next_todo;
        continue ;
        
      } else {
        return to_revert;
      }
    };
  };
  if (u === v) {
    return 1 - strict;
  } else {
    try {
      var match;
      try {
        match = /* tuple */[
          /* false */0,
          loop(/* [] */0, /* :: */[
                /* tuple */[
                  u,
                  strict
                ],
                /* [] */0
              ], /* [] */0)
        ];
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Found) {
          match = /* tuple */[
            /* true */1,
            exn[1]
          ];
        } else {
          throw exn;
        }
      }
      Curry._2(Util$ReactTemplate.List[/* iter */9], (function (u) {
              u[/* status */6] = /* NoMark */0;
              return /* () */0;
            }), match[1]);
      return match[0];
    }
    catch (e){
      cleanup_universes(g);
      throw e;
    }
  }
}

function check_equal(g, u, v) {
  var arcu = repr(g, u);
  var arcv = repr(g, v);
  return +(arcu === arcv);
}

function check_eq_level(g, u, v) {
  if (u === v) {
    return /* true */1;
  } else {
    return check_equal(g, u, v);
  }
}

function check_smaller(g, strict, u, v) {
  var arcu = repr(g, u);
  var arcv = repr(g, v);
  if (strict) {
    return search_path(/* true */1, arcu, arcv, g);
  } else if (Univ$ReactTemplate.Level[/* is_prop */3](arcu[/* univ */0]) || Univ$ReactTemplate.Level[/* is_set */4](arcu[/* univ */0]) && !Univ$ReactTemplate.Level[/* is_prop */3](arcv[/* univ */0])) {
    return /* true */1;
  } else {
    return search_path(/* false */0, arcu, arcv, g);
  }
}

function real_check_leq(g, u, v) {
  return Curry._2(Univ$ReactTemplate.Universe[/* for_all */16], (function (ul) {
                var g$1 = g;
                var ul$1 = ul;
                var l = v;
                return Curry._2(Univ$ReactTemplate.Universe[/* exists */15], (function (ul$prime) {
                              var g$2 = g$1;
                              var param = ul$1;
                              var param$1 = ul$prime;
                              var v = param$1[0];
                              var u = param[0];
                              var diff = param[1] - param$1[1] | 0;
                              if (diff !== 0) {
                                if (diff !== 1) {
                                  if (diff < 0) {
                                    return check_smaller(g$2, /* false */0, u, v);
                                  } else {
                                    return /* false */0;
                                  }
                                } else {
                                  return check_smaller(g$2, /* true */1, u, v);
                                }
                              } else {
                                return check_smaller(g$2, /* false */0, u, v);
                              }
                            }), l);
              }), u);
}

function check_leq(g, u, v) {
  if (Univ$ReactTemplate.Universe[/* equal */1](u, v) || Univ$ReactTemplate.is_type0m_univ(u)) {
    return /* true */1;
  } else {
    return real_check_leq(g, u, v);
  }
}

function check_eq(g, u, v) {
  if (Univ$ReactTemplate.Universe[/* equal */1](u, v)) {
    return /* true */1;
  } else {
    var g$1 = g;
    var l1 = u;
    var l2 = v;
    if (real_check_leq(g$1, l1, l2)) {
      return real_check_leq(g$1, l2, l1);
    } else {
      return /* false */0;
    }
  }
}

function enforce_univ_eq(_u, _v, g) {
  while(true) {
    var v = _v;
    var u = _u;
    var ucan = repr(g, u);
    var vcan = repr(g, v);
    if (topo_compare(ucan, vcan) === 1) {
      _v = u;
      _u = v;
      continue ;
      
    } else {
      var g$1 = insert_edge(/* false */0, ucan, vcan, g);
      try {
        return insert_edge(/* false */0, vcan, ucan, g$1);
      }
      catch (exn){
        if (exn === CycleDetected) {
          return error_inconsistency(/* Eq */2, v, u, get_explanation$1(/* true */1, u, v, g$1));
        } else {
          throw exn;
        }
      }
    }
  };
}

function enforce_univ_lt(u, v, g) {
  var ucan = repr(g, u);
  var vcan = repr(g, v);
  try {
    return insert_edge(/* true */1, ucan, vcan, g);
  }
  catch (exn){
    if (exn === CycleDetected) {
      return error_inconsistency(/* Lt */0, u, v, get_explanation$1(/* false */0, v, u, g));
    } else {
      throw exn;
    }
  }
}

var set_arc = /* Canonical */Block.__(0, [/* record */[
      /* univ */Univ$ReactTemplate.Level[/* set */0],
      /* ltle */Univ$ReactTemplate.LMap[/* empty */0],
      /* gtge */Univ$ReactTemplate.LSet[/* empty */0],
      /* rank */1000000,
      /* klvl */0,
      /* ilvl */-1,
      /* status : NoMark */0
    ]]);

var prop_arc = /* Canonical */Block.__(0, [/* record */[
      /* univ */Univ$ReactTemplate.Level[/* prop */1],
      /* ltle */Univ$ReactTemplate.LMap[/* empty */0],
      /* gtge */Univ$ReactTemplate.LSet[/* empty */0],
      /* rank */1000000,
      /* klvl */0,
      /* ilvl */0,
      /* status : NoMark */0
    ]]);

var entries = Curry._3(Univ$ReactTemplate.LMap[/* add */3], Univ$ReactTemplate.Level[/* set */0], set_arc, Curry._2(Univ$ReactTemplate.LMap[/* singleton */4], Univ$ReactTemplate.Level[/* prop */1], prop_arc));

var empty = /* record */[
  /* entries */entries,
  /* index */-2,
  /* n_nodes */2,
  /* n_edges */0
];

var empty_universes = enforce_univ_lt(Univ$ReactTemplate.Level[/* prop */1], Univ$ReactTemplate.Level[/* set */0], empty);

function is_initial_universes(g) {
  return Curry._3(Univ$ReactTemplate.LMap[/* equal */8], (function (prim, prim$1) {
                return +(prim === prim$1);
              }), g[/* entries */0], empty_universes[/* entries */0]);
}

function enforce_constraint(cst, g) {
  var u = cst[0];
  switch (cst[1]) {
    case 0 : 
        return enforce_univ_lt(u, cst[2], g);
    case 1 : 
        var u$1 = u;
        var v = cst[2];
        var g$1 = g;
        var ucan = repr(g$1, u$1);
        var vcan = repr(g$1, v);
        try {
          return insert_edge(/* false */0, ucan, vcan, g$1);
        }
        catch (exn){
          if (exn === CycleDetected) {
            return error_inconsistency(/* Le */1, u$1, v, get_explanation$1(/* true */1, v, u$1, g$1));
          } else {
            throw exn;
          }
        }
    case 2 : 
        return enforce_univ_eq(u, cst[2], g);
    
  }
}

function merge_constraints(c, g) {
  return Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], enforce_constraint, c, g);
}

function check_constraint(g, param) {
  var r = param[2];
  var l = param[0];
  switch (param[1]) {
    case 0 : 
        return check_smaller(g, /* true */1, l, r);
    case 1 : 
        return check_smaller(g, /* false */0, l, r);
    case 2 : 
        return check_equal(g, l, r);
    
  }
}

function check_constraints(c, g) {
  return Curry._2(Univ$ReactTemplate.Constraint[/* for_all */14], (function (param) {
                return check_constraint(g, param);
              }), c);
}

function normalize_universes(g) {
  var g_000 = /* entries */Curry._2(Univ$ReactTemplate.LMap[/* map */22], (function (entry) {
          if (entry.tag) {
            return /* Equiv */Block.__(1, [repr(g, entry[0])[/* univ */0]]);
          } else {
            var newrecord = entry[0].slice();
            return /* Canonical */Block.__(0, [(newrecord[/* rank */3] = 1, newrecord)]);
          }
        }), g[/* entries */0]);
  var g_001 = /* index */g[/* index */1];
  var g_002 = /* n_nodes */g[/* n_nodes */2];
  var g_003 = /* n_edges */g[/* n_edges */3];
  var g$1 = /* record */[
    g_000,
    g_001,
    g_002,
    g_003
  ];
  return Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (_, u, g) {
                if (u.tag) {
                  return g;
                } else {
                  var match = get_ltle(g, u[0]);
                  return get_gtge(match[2], match[1])[2];
                }
              }), g_000, g$1);
}

function constraints_of_universes(g) {
  var g$1 = normalize_universes(g);
  var constraints_of = function (u, v, acc) {
    if (v.tag) {
      return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                  u,
                  /* Eq */2,
                  v[0]
                ], acc);
    } else {
      var match = v[0];
      var u$1 = match[/* univ */0];
      return Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (v, strict, acc) {
                    var typ = strict ? /* Lt */0 : /* Le */1;
                    return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                                u$1,
                                typ,
                                v
                              ], acc);
                  }), match[/* ltle */1], acc);
    }
  };
  return Curry._3(Univ$ReactTemplate.LMap[/* fold */10], constraints_of, g$1[/* entries */0], Univ$ReactTemplate.Constraint[/* empty */0]);
}

function sort_universes(g) {
  var cans = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (_, u, l) {
          if (u.tag) {
            return l;
          } else {
            return /* :: */[
                    u[0],
                    l
                  ];
          }
        }), g[/* entries */0], /* [] */0);
  var cans$1 = Curry._2(Util$ReactTemplate.List[/* sort */38], topo_compare, cans);
  var lowest_levels = Curry._2(Univ$ReactTemplate.LMap[/* mapi */23], (function (u, _) {
          if (Univ$ReactTemplate.Level[/* is_small */2](u)) {
            return 0;
          } else {
            return 2;
          }
        }), Curry._2(Univ$ReactTemplate.LMap[/* filter */13], (function (_, u) {
              if (u.tag) {
                return /* false */0;
              } else {
                return /* true */1;
              }
            }), g[/* entries */0]));
  var lowest_levels$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (lowest_levels, can) {
          var lvl = Curry._2(Univ$ReactTemplate.LMap[/* find */21], can[/* univ */0], lowest_levels);
          return Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (u$prime, strict, lowest_levels) {
                        var cost = strict ? 1 : 0;
                        var u$prime$1 = repr(g, u$prime)[/* univ */0];
                        return Curry._3(Univ$ReactTemplate.LMap[/* modify */26], u$prime$1, (function (_, lvl0) {
                                      return Caml_primitive.caml_int_max(lvl0, lvl + cost | 0);
                                    }), lowest_levels);
                      }), can[/* ltle */1], lowest_levels);
        }), lowest_levels, cans$1);
  var max_lvl = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (_, a, b) {
          if (a > b) {
            return a;
          } else {
            return b;
          }
        }), lowest_levels$1, 0);
  var mp = Names$ReactTemplate.DirPath[/* make */3](/* :: */[
        Names$ReactTemplate.Id[/* of_string */5]("Type"),
        /* [] */0
      ]);
  var types = Util$ReactTemplate.$$Array[/* init */0](max_lvl + 1 | 0, (function (n) {
          if (n !== 0) {
            if (n !== 1) {
              return Univ$ReactTemplate.Level[/* make */8](mp, n - 2 | 0);
            } else {
              return Univ$ReactTemplate.Level[/* set */0];
            }
          } else {
            return Univ$ReactTemplate.Level[/* prop */1];
          }
        }));
  var g$1 = Util$ReactTemplate.$$Array[/* fold_left */15]((function (g, u) {
          var match = safe_repr(g, u);
          var newrecord = match[1].slice();
          return change_node(match[0], (newrecord[/* rank */3] = 1000000, newrecord));
        }), g, types);
  var g$2 = max_lvl >= 2 ? enforce_univ_lt(Univ$ReactTemplate.Level[/* set */0], Caml_array.caml_array_get(types, 2), g$1) : g$1;
  return normalize_universes(Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (u, lvl, g) {
                    return enforce_univ_eq(u, Caml_array.caml_array_get(types, lvl), g);
                  }), lowest_levels$1, g$2));
}

function check_subtype(univs, ctxT, ctx) {
  if (Univ$ReactTemplate.AUContext[/* size */4](ctxT) === Univ$ReactTemplate.AUContext[/* size */4](ctx)) {
    var match = Univ$ReactTemplate.UContext[/* dest */5](Univ$ReactTemplate.AUContext[/* repr */0](ctx));
    var cstT = Univ$ReactTemplate.UContext[/* constraints */4](Univ$ReactTemplate.AUContext[/* repr */0](ctxT));
    var push = function (accu, v) {
      return add_universe(v, /* false */0, accu);
    };
    var univs$1 = Util$ReactTemplate.$$Array[/* fold_left */15](push, univs, Univ$ReactTemplate.Instance[/* to_array */3](match[0]));
    var univs$2 = merge_constraints(cstT, univs$1);
    return check_constraints(match[1], univs$2);
  } else {
    return /* false */0;
  }
}

function check_eq_instances(g, t1, t2) {
  var t1$1 = Univ$ReactTemplate.Instance[/* to_array */3](t1);
  var t2$1 = Univ$ReactTemplate.Instance[/* to_array */3](t2);
  if (t1$1 === t2$1) {
    return /* true */1;
  } else if (t1$1.length === t2$1.length) {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === t1$1.length) {
        return /* true */1;
      } else if (check_eq_level(g, Caml_array.caml_array_get(t1$1, i), Caml_array.caml_array_get(t2$1, i))) {
        _i = i + 1 | 0;
        continue ;
        
      } else {
        return /* false */0;
      }
    };
  } else {
    return /* false */0;
  }
}

function pr_universes(prl, g) {
  var graph = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (u, a, l) {
          return /* :: */[
                  /* tuple */[
                    u,
                    a
                  ],
                  l
                ];
        }), g[/* entries */0], /* [] */0);
  return Pp$ReactTemplate.prlist((function (param) {
                var prl$1 = prl;
                var param$1 = param;
                var match = param$1[1];
                if (match.tag) {
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(prl$1, param$1[0]), Pp$ReactTemplate.str(" = ")), Curry._1(prl$1, match[0])), Pp$ReactTemplate.fnl(/* () */0));
                } else {
                  var match$1 = match[0];
                  var ltle = match$1[/* ltle */1];
                  if (Curry._1(Univ$ReactTemplate.LMap[/* is_empty */1], ltle)) {
                    return Pp$ReactTemplate.mt(/* () */0);
                  } else {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(prl$1, match$1[/* univ */0]), Pp$ReactTemplate.str(" ")), Pp$ReactTemplate.v(0, Pp$ReactTemplate.pr_sequence((function (param) {
                                              return Pp$ReactTemplate.$plus$plus(param[1] ? Pp$ReactTemplate.str("< ") : Pp$ReactTemplate.str("<= "), Curry._1(prl$1, param[0]));
                                            }), Curry._1(Univ$ReactTemplate.LMap[/* bindings */16], ltle)))), Pp$ReactTemplate.fnl(/* () */0));
                  }
                }
              }), graph);
}

function dump_universes(output, g) {
  var dump_arc = function (u, param) {
    if (param.tag) {
      return Curry._3(output, /* Eq */2, Univ$ReactTemplate.Level[/* to_string */10](u), Univ$ReactTemplate.Level[/* to_string */10](param[0]));
    } else {
      var match = param[0];
      var u_str = Univ$ReactTemplate.Level[/* to_string */10](match[/* univ */0]);
      return Curry._2(Univ$ReactTemplate.LMap[/* iter */9], (function (v, strict) {
                    var typ = strict ? /* Lt */0 : /* Le */1;
                    return Curry._3(output, typ, u_str, Univ$ReactTemplate.Level[/* to_string */10](v));
                  }), match[/* ltle */1]);
    }
  };
  return Curry._2(Univ$ReactTemplate.LMap[/* iter */9], dump_arc, g[/* entries */0]);
}

var initial_universes = empty_universes;

exports.check_leq = check_leq;
exports.check_eq = check_eq;
exports.check_eq_level = check_eq_level;
exports.initial_universes = initial_universes;
exports.is_initial_universes = is_initial_universes;
exports.check_eq_instances = check_eq_instances;
exports.enforce_constraint = enforce_constraint;
exports.merge_constraints = merge_constraints;
exports.check_constraint = check_constraint;
exports.check_constraints = check_constraints;
exports.AlreadyDeclared = AlreadyDeclared;
exports.add_universe = add_universe;
exports.pr_universes = pr_universes;
exports.empty_universes = empty_universes;
exports.sort_universes = sort_universes;
exports.constraints_of_universes = constraints_of_universes;
exports.check_subtype = check_subtype;
exports.dump_universes = dump_universes;
exports.check_universes_invariants = check_universes_invariants;
/* entries Not a pure module */
