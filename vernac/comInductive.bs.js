// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Loc$ReactTemplate = require("../src/loc.bs.js");
var CAst$ReactTemplate = require("../src/cAst.bs.js");
var DAst$ReactTemplate = require("../src/dAst.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var CList$ReactTemplate = require("../src/cList.bs.js");
var Class$ReactTemplate = require("./class.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Sorts$ReactTemplate = require("../src/sorts.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var Declare$ReactTemplate = require("../src/declare.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Impargs$ReactTemplate = require("../src/impargs.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var Indtypes$ReactTemplate = require("../src/indtypes.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Retyping$ReactTemplate = require("../src/retyping.bs.js");
var Pretyping$ReactTemplate = require("../src/pretyping.bs.js");
var Reduction$ReactTemplate = require("../src/reduction.bs.js");
var Univdecls$ReactTemplate = require("../src/univdecls.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Indschemes$ReactTemplate = require("./indschemes.bs.js");
var Metasyntax$ReactTemplate = require("./metasyntax.bs.js");
var Constrintern$ReactTemplate = require("../src/constrintern.bs.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");
var Constrexpr_ops$ReactTemplate = require("../src/constrexpr_ops.bs.js");
var InferCumulativity$ReactTemplate = require("../src/inferCumulativity.bs.js");
var Implicit_quantifiers$ReactTemplate = require("../src/implicit_quantifiers.bs.js");

function complete_conclusion(a, cs) {
  return (function (param) {
      return CAst$ReactTemplate.map_with_loc((function (loc, c) {
                    switch (c.tag | 0) {
                      case 3 : 
                          return /* CProdN */Block.__(3, [
                                    c[0],
                                    complete_conclusion(a, cs)(c[1])
                                  ]);
                      case 5 : 
                          return /* CLetIn */Block.__(5, [
                                    c[0],
                                    c[1],
                                    c[2],
                                    complete_conclusion(a, cs)(c[3])
                                  ]);
                      case 12 : 
                          if (!a[0]) {
                            CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Cannot infer the non constant arguments of the conclusion of "), Names$ReactTemplate.Id[/* print */8](cs)), Pp$ReactTemplate.str(".")));
                          }
                          var args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
                                  return CAst$ReactTemplate.make(loc, /* CRef */Block.__(0, [
                                                CAst$ReactTemplate.make(loc, /* Ident */Block.__(1, [id])),
                                                /* None */0
                                              ]));
                                }), a[2]);
                          return /* CAppExpl */Block.__(6, [
                                    /* tuple */[
                                      /* None */0,
                                      CAst$ReactTemplate.make(loc, /* Ident */Block.__(1, [a[1]])),
                                      /* None */0
                                    ],
                                    Curry._1(Util$ReactTemplate.List[/* rev */4], args)
                                  ]);
                      default:
                        return c;
                    }
                  }), param);
    });
}

function push_types(env, idl, tl) {
  return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (env, id, t) {
                return EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                              /* Name */[id],
                              t
                            ]), env);
              }), env, idl, tl);
}

function minductive_message(warn, l) {
  if (l) {
    if (l[1]) {
      return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Names$ReactTemplate.Id[/* print */8], l), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("are defined")));
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](l[0]), Pp$ReactTemplate.str(" is defined")), warn ? Pp$ReactTemplate.str(" as a non-primitive record") : Pp$ReactTemplate.mt(/* () */0));
    }
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No inductive definition."));
  }
}

function check_all_names_different(indl) {
  var ind_names = Curry._2(Util$ReactTemplate.List[/* map */10], (function (ind) {
          return ind[/* ind_name */0];
        }), indl);
  var cstr_names = Curry._2(Util$ReactTemplate.List[/* map_append */113], (function (ind) {
          return Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                        return prim[0];
                      }), ind[/* ind_lc */3]);
        }), indl);
  var l = Curry._2(Util$ReactTemplate.List[/* duplicates */60], Names$ReactTemplate.Id[/* equal */0], ind_names);
  if (l) {
    throw [
          Indtypes$ReactTemplate.InductiveError,
          /* SameNamesTypes */Block.__(4, [l[0]])
        ];
  }
  var l$1 = Curry._2(Util$ReactTemplate.List[/* duplicates */60], Names$ReactTemplate.Id[/* equal */0], cstr_names);
  if (l$1) {
    throw [
          Indtypes$ReactTemplate.InductiveError,
          /* SameNamesConstructors */Block.__(5, [Curry._1(Util$ReactTemplate.List[/* hd */1], l$1)])
        ];
  }
  var l$2 = Curry._3(Util$ReactTemplate.List[/* intersect */50], Names$ReactTemplate.Id[/* equal */0], ind_names, cstr_names);
  if (l$2) {
    throw [
          Indtypes$ReactTemplate.InductiveError,
          /* SameNamesOverlap */Block.__(6, [l$2])
        ];
  } else {
    return /* () */0;
  }
}

function prepare_param(param) {
  if (param.tag) {
    return /* tuple */[
            Nameops$ReactTemplate.Name[/* get_id */15](param[0]),
            /* LocalDefEntry */Block.__(0, [param[1]])
          ];
  } else {
    return /* tuple */[
            Nameops$ReactTemplate.Name[/* get_id */15](param[0]),
            /* LocalAssumEntry */Block.__(1, [param[1]])
          ];
  }
}

function check_anonymous_type(_ind) {
  while(true) {
    var ind = _ind;
    var match = DAst$ReactTemplate.get(ind);
    switch (match.tag | 0) {
      case 5 : 
      case 6 : 
      case 7 : 
          _ind = match[3];
          continue ;
          case 12 : 
          var match$1 = match[0];
          if (typeof match$1 === "number" || match$1[0]) {
            return /* false */0;
          } else {
            return /* true */1;
          }
      case 4 : 
      case 14 : 
          _ind = match[0];
          continue ;
          default:
        return /* false */0;
    }
  };
}

function is_impredicative(env, u) {
  if (Caml_obj.caml_equal(u, /* Prop */Block.__(0, [/* Null */1]))) {
    return /* true */1;
  } else if (Environ$ReactTemplate.is_impredicative_set(env)) {
    return Caml_obj.caml_equal(u, /* Prop */Block.__(0, [/* Pos */0]));
  } else {
    return /* false */0;
  }
}

function sign_level(env, evd, sign) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (d, param) {
                  var env = param[1];
                  var lev = param[0];
                  if (d.tag) {
                    return /* tuple */[
                            lev,
                            Environ$ReactTemplate.push_rel(d, env)
                          ];
                  } else {
                    var s = Constr$ReactTemplate.destSort(Reduction$ReactTemplate.whd_all(env, EConstr$ReactTemplate.Unsafe[/* to_constr */0](Evarutil$ReactTemplate.nf_evar(evd, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, evd, EConstr$ReactTemplate.of_constr(Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], d)))))));
                    var u = Sorts$ReactTemplate.univ_of_sort(s);
                    return /* tuple */[
                            Univ$ReactTemplate.sup(u, lev),
                            Environ$ReactTemplate.push_rel(d, env)
                          ];
                  }
                }), sign, /* tuple */[
                Univ$ReactTemplate.type0m_univ,
                env
              ])[0];
}

function extract_level(env, evd, min, tys) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], Univ$ReactTemplate.sup, min, Curry._2(Util$ReactTemplate.List[/* map */10], (function (ty) {
                    var match = Reduction$ReactTemplate.dest_prod_assum(env)(ty);
                    return sign_level(env, evd, /* :: */[
                                /* LocalAssum */Block.__(0, [
                                    /* Anonymous */0,
                                    match[1]
                                  ]),
                                match[0]
                              ]);
                  }), tys));
}

function is_flexible_sort(evd, u) {
  var match = Univ$ReactTemplate.Universe[/* level */8](u);
  if (match) {
    return Evd$ReactTemplate.is_flexible_level(evd, match[0]);
  } else {
    return /* false */0;
  }
}

function inductive_levels(env, evd, _, arities, inds) {
  var destarities = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
          return /* tuple */[
                  x,
                  Reduction$ReactTemplate.dest_arity(env, x)
                ];
        }), arities);
  var levels = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var a = param[1][1];
          if (Caml_obj.caml_equal(a, /* Prop */Block.__(0, [/* Null */1]))) {
            return /* None */0;
          } else {
            return /* Some */[Sorts$ReactTemplate.univ_of_sort(a)];
          }
        }), destarities);
  var match = CList$ReactTemplate.split3(Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param, param$1) {
              var match = param$1[1];
              var du = match[1];
              var ctx = match[0];
              var tys = param[1];
              var len = Curry._1(Util$ReactTemplate.List[/* length */0], tys);
              var minlev = Sorts$ReactTemplate.univ_of_sort(du);
              var minlev$1 = len > 1 && !is_impredicative(env, du) ? Univ$ReactTemplate.sup(minlev, Univ$ReactTemplate.type0_univ) : minlev;
              var minlev$2;
              if (Indtypes$ReactTemplate.is_indices_matter(/* () */0) && Curry._1(Util$ReactTemplate.List[/* length */0], ctx) > 0) {
                var ilev = sign_level(env, evd, ctx);
                minlev$2 = Univ$ReactTemplate.sup(ilev, minlev$1);
              } else {
                minlev$2 = minlev$1;
              }
              var clev = extract_level(env, evd, minlev$2, tys);
              return /* tuple */[
                      clev,
                      minlev$2,
                      len
                    ];
            }), inds, destarities));
  var levels$prime = Universes$ReactTemplate.solve_constraints_system(Util$ReactTemplate.$$Array[/* of_list */10](levels), Util$ReactTemplate.$$Array[/* of_list */10](match[0]), Util$ReactTemplate.$$Array[/* of_list */10](match[1]));
  var match$1 = CList$ReactTemplate.fold_left3((function (param, cu, param$1, len) {
          var du = param$1[1][1];
          var arity = param$1[0];
          var arities = param[1];
          var evd = param[0];
          if (is_impredicative(env, du)) {
            return /* tuple */[
                    evd,
                    /* :: */[
                      arity,
                      arities
                    ]
                  ];
          } else {
            var evd$1;
            if (Sorts$ReactTemplate.is_set(du)) {
              if (Evd$ReactTemplate.check_leq(evd, cu, Univ$ReactTemplate.type0_univ)) {
                evd$1 = evd;
              } else {
                throw [
                      Indtypes$ReactTemplate.InductiveError,
                      /* LargeNonPropInductiveNotInType */1
                    ];
              }
            } else {
              evd$1 = evd;
            }
            var evd$2 = len >= 2 && Univ$ReactTemplate.is_type0m_univ(cu) ? Evd$ReactTemplate.set_leq_sort(env, evd$1, /* Prop */Block.__(0, [/* Pos */0]), du) : evd$1;
            var duu = Sorts$ReactTemplate.univ_of_sort(du);
            var evd$3 = !Univ$ReactTemplate.is_small_univ(duu) && Univ$ReactTemplate.Universe[/* equal */1](cu, duu) ? (
                is_flexible_sort(evd$2, duu) && !Evd$ReactTemplate.check_leq(evd$2, Univ$ReactTemplate.type0_univ, duu) ? Evd$ReactTemplate.set_eq_sort(env, evd$2, /* Prop */Block.__(0, [/* Null */1]), du) : evd$2
              ) : Evd$ReactTemplate.set_eq_sort(env, evd$2, /* Type */Block.__(1, [cu]), du);
            return /* tuple */[
                    evd$3,
                    /* :: */[
                      arity,
                      arities
                    ]
                  ];
          }
        }), /* tuple */[
        evd,
        /* [] */0
      ], Util$ReactTemplate.$$Array[/* to_list */9](levels$prime), destarities, match[2]);
  return /* tuple */[
          match$1[0],
          Curry._1(Util$ReactTemplate.List[/* rev */4], match$1[1])
        ];
}

function check_named(param) {
  if (param[/* v */0]) {
    return /* () */0;
  } else {
    var msg = Pp$ReactTemplate.str("Parameters must be named.");
    return CErrors$ReactTemplate.user_err(param[/* loc */1], /* None */0, msg);
  }
}

function check_param(param) {
  switch (param.tag | 0) {
    case 0 : 
        if (param[1].tag) {
          return /* () */0;
        } else {
          return Curry._2(Util$ReactTemplate.List[/* iter */9], check_named, param[0]);
        }
        break;
    case 1 : 
        return check_named(param[0]);
    case 2 : 
        return Loc$ReactTemplate.raise(param[0][/* loc */1], [
                    Stream.$$Error,
                    "pattern with quote not allowed here."
                  ]);
    
  }
}

function interp_mutual_inductive(param, notations, cum, poly, prv, finite) {
  var indl = param[1];
  var paramsl = param[0];
  check_all_names_different(indl);
  Curry._2(Util$ReactTemplate.List[/* iter */9], check_param, paramsl);
  var env0 = Global$ReactTemplate.env(/* () */0);
  var pl = Curry._1(Util$ReactTemplate.List[/* hd */1], indl)[/* ind_univs */1];
  var match = Univdecls$ReactTemplate.interp_univ_decl_opt(env0, pl);
  var match$1 = Constrintern$ReactTemplate.interp_context_evars(/* None */0, /* None */0, /* None */0, env0, match[0], paramsl);
  var match$2 = match$1[1];
  var match$3 = match$2[1];
  var userimpls = match$3[1];
  var match$4 = match$3[0];
  var ctx_params = match$4[1];
  var env_params = match$4[0];
  var indnames = Curry._2(Util$ReactTemplate.List[/* map */10], (function (ind) {
          return ind[/* ind_name */0];
        }), indl);
  var assums = Curry._2(Util$ReactTemplate.List[/* filter */27], Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], ctx_params);
  var partial_arg = Nameops$ReactTemplate.Name[/* get_id */15];
  var partial_arg$1 = Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0];
  var params = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return Util$ReactTemplate.$percent$great(partial_arg$1, partial_arg, param);
        }), assums);
  var match$5 = Curry._3(Util$ReactTemplate.List[/* fold_left_map */116], (function (sigma) {
          return (function (param) {
              var env = env_params;
              var sigma$1 = sigma;
              var ind = param;
              var c = Constrintern$ReactTemplate.intern_gen(/* IsType */0, env, sigma$1, /* None */0, /* None */0, /* None */0, ind[/* ind_arity */2]);
              var impls = Implicit_quantifiers$ReactTemplate.implicits_of_glob_constr(/* Some */[/* true */1], c);
              var match = Pretyping$ReactTemplate.understand_tcc(/* None */0, env, sigma$1, /* Some */[/* IsType */0], c);
              var t = match[1];
              var sigma$2 = match[0];
              var pseudo_poly = check_anonymous_type(c);
              if (!Reductionops$ReactTemplate.is_arity(env, sigma$2, t)) {
                CErrors$ReactTemplate.user_err(Constrexpr_ops$ReactTemplate.constr_loc(ind[/* ind_arity */2]), /* None */0, Pp$ReactTemplate.str("Not an arity"));
              }
              return /* tuple */[
                      sigma$2,
                      /* tuple */[
                        t,
                        pseudo_poly,
                        impls
                      ]
                    ];
            });
        }), match$1[0], indl);
  var arities = match$5[1];
  var sigma = match$5[0];
  var fullarities = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return EConstr$ReactTemplate.it_mkProd_or_LetIn(param[0], ctx_params);
        }), arities);
  var env_ar = push_types(env0, indnames, fullarities);
  var env_ar_params = EConstr$ReactTemplate.push_rel_context(ctx_params, env_ar);
  var indimpls = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return Util$ReactTemplate.$at(userimpls, Curry._1(Impargs$ReactTemplate.lift_implicits(Context$ReactTemplate.Rel[/* nhyps */5](ctx_params)), param[2]));
        }), arities);
  var arities$1 = Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi1, arities);
  var aritypoly = Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi2, arities);
  var impls = Curry._3(Constrintern$ReactTemplate.compute_internalization_env(env0, sigma, /* Some */[match$2[0]], /* Inductive */[
            params,
            /* true */1
          ]), indnames, fullarities, indimpls);
  var ntn_impls = Curry._3(Constrintern$ReactTemplate.compute_internalization_env(env0, sigma, /* None */0, /* Inductive */[
            params,
            /* true */1
          ]), indnames, fullarities, indimpls);
  var mldatas = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param, param$1) {
          var sigma$1 = sigma;
          var env = env_params;
          var assums = params;
          var arity = param;
          var indname = param$1;
          var is_ml_type = Reductionops$ReactTemplate.is_sort(env, sigma$1, arity);
          return /* tuple */[
                  is_ml_type,
                  indname,
                  assums
                ];
        }), arities$1, indnames);
  var match$6 = Metasyntax$ReactTemplate.with_syntax_protection((function () {
          Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                  return Metasyntax$ReactTemplate.set_notation_for_interpretation(env_params, ntn_impls, param);
                }), notations);
          return Curry._5(Util$ReactTemplate.List[/* fold_left3_map */120], (function (sigma) {
                        return (function (param, param$1, param$2) {
                            var env = env_ar_params;
                            var sigma$1 = sigma;
                            var impls$1 = impls;
                            var mldata = param;
                            var ind = param$2;
                            var match = Curry._1(Util$ReactTemplate.List[/* split */36], ind[/* ind_lc */3]);
                            var cnames = match[0];
                            var ctyps$prime = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param) {
                                    return complete_conclusion(mldata, param);
                                  }), cnames, match[1]);
                            var match$1 = Util$ReactTemplate.on_snd(Util$ReactTemplate.List[/* split */36], Curry._3(Util$ReactTemplate.List[/* fold_left_map */116], (function (sigma, l) {
                                        var partial_arg = EConstr$ReactTemplate.Unsafe[/* to_constr */0];
                                        return Util$ReactTemplate.on_snd((function (param) {
                                                      return Util$ReactTemplate.on_fst(partial_arg, param);
                                                    }), Constrintern$ReactTemplate.interp_type_evars_impls(env, sigma, /* Some */[impls$1], l));
                                      }), sigma$1, ctyps$prime));
                            var match$2 = match$1[1];
                            return /* tuple */[
                                    match$1[0],
                                    /* tuple */[
                                      cnames,
                                      match$2[0],
                                      match$2[1]
                                    ]
                                  ];
                          });
                      }), sigma, mldatas, arities$1, indl);
        }), /* () */0);
  var sigma$1 = Pretyping$ReactTemplate.solve_remaining_evars(Pretyping$ReactTemplate.all_and_fail_flags, env_params, match$6[0], Evd$ReactTemplate.empty);
  var match$7 = Evarutil$ReactTemplate.nf_evars_and_universes(sigma$1);
  var nf = match$7[1];
  var sigma$2 = match$7[0];
  var constructors = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[0],
                  Curry._2(Util$ReactTemplate.List[/* map */10], nf, param[1]),
                  param[2]
                ];
        }), match$6[1]);
  var arities$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return EConstr$ReactTemplate.to_constr(sigma$2, param);
        }), arities$1);
  var sigma$3 = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (sigma, ty, poly) {
          var sigma$1 = sigma;
          var ty$1 = ty;
          var poly$1 = poly;
          if (poly$1 && Term$ReactTemplate.isArity(ty$1)) {
            var match = Term$ReactTemplate.destArity(ty$1);
            var concl = match[1];
            if (concl.tag) {
              var match$1 = Univ$ReactTemplate.universe_level(concl[0]);
              if (match$1) {
                return Evd$ReactTemplate.make_flexible_variable(sigma$1, /* true */1, match$1[0]);
              } else {
                return sigma$1;
              }
            } else {
              return sigma$1;
            }
          } else {
            return sigma$1;
          }
        }), sigma$2, arities$2, aritypoly);
  var match$8 = inductive_levels(env_ar_params, sigma$3, poly, arities$2, constructors);
  var match$9 = Evarutil$ReactTemplate.nf_evars_and_universes(match$8[0]);
  var nf$prime = match$9[1];
  var sigma$4 = match$9[0];
  var arities$3 = Curry._2(Util$ReactTemplate.List[/* map */10], nf$prime, match$8[1]);
  var constructors$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[0],
                  Curry._2(Util$ReactTemplate.List[/* map */10], nf$prime, param[1]),
                  param[2]
                ];
        }), constructors);
  var ctx_params$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return Termops$ReactTemplate.map_rel_decl((function (param) {
                        return EConstr$ReactTemplate.to_constr(sigma$4, param);
                      }), param);
        }), ctx_params);
  var uctx = Evd$ReactTemplate.check_univ_decl(poly, sigma$4, match[1]);
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (c) {
          return Pretyping$ReactTemplate.check_evars(env_params, Evd$ReactTemplate.empty, sigma$4, EConstr$ReactTemplate.of_constr(c));
        }), arities$3);
  Curry._1(Context$ReactTemplate.Rel[/* iter */8]((function (c) {
              return Pretyping$ReactTemplate.check_evars(env0, Evd$ReactTemplate.empty, sigma$4, EConstr$ReactTemplate.of_constr(c));
            })), ctx_params$1);
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
          return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (c) {
                        return Pretyping$ReactTemplate.check_evars(env_ar_params, Evd$ReactTemplate.empty, sigma$4, EConstr$ReactTemplate.of_constr(c));
                      }), param[1]);
        }), constructors$1);
  var entries = Curry._5(Util$ReactTemplate.List[/* map4 */70], (function (ind, arity, template, param) {
          return /* record */[
                  /* mind_entry_typename */ind[/* ind_name */0],
                  /* mind_entry_arity */arity,
                  /* mind_entry_template */template,
                  /* mind_entry_consnames */param[0],
                  /* mind_entry_lc */param[1]
                ];
        }), indl, arities$3, aritypoly, constructors$1);
  var len = Context$ReactTemplate.Rel[/* nhyps */5](ctx_params$1);
  var impls$1 = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (indimpls, param) {
          return /* tuple */[
                  indimpls,
                  Curry._2(Util$ReactTemplate.List[/* map */10], (function (impls) {
                          return Util$ReactTemplate.$at(userimpls, Curry._1(Impargs$ReactTemplate.lift_implicits(len), impls));
                        }), param[2])
                ];
        }), indimpls, constructors$1);
  var univs;
  if (uctx.tag) {
    var uctx$1 = uctx[0];
    univs = cum ? /* Cumulative_ind_entry */Block.__(2, [Univ$ReactTemplate.CumulativityInfo[/* from_universe_context */5](uctx$1)]) : /* Polymorphic_ind_entry */Block.__(1, [uctx$1]);
  } else {
    univs = /* Monomorphic_ind_entry */Block.__(0, [uctx[0]]);
  }
  var mind_ent_002 = /* mind_entry_params */Curry._2(Util$ReactTemplate.List[/* map */10], prepare_param, ctx_params$1);
  var mind_ent_005 = /* mind_entry_private */prv ? /* Some */[/* false */0] : /* None */0;
  var mind_ent = /* record */[
    /* mind_entry_record : None */0,
    /* mind_entry_finite */finite,
    mind_ent_002,
    /* mind_entry_inds */entries,
    /* mind_entry_universes */univs,
    mind_ent_005
  ];
  return /* tuple */[
          poly && cum ? InferCumulativity$ReactTemplate.infer_inductive(env_ar, mind_ent) : mind_ent,
          Evd$ReactTemplate.universe_binders(sigma$4),
          impls$1
        ];
}

function extract_coercions(indl) {
  var mkqid = function (param) {
    return Libnames$ReactTemplate.qualid_of_ident(param[1][0][/* v */0]);
  };
  return Curry._2(Util$ReactTemplate.List[/* map */10], mkqid, Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                        var lc = param[3];
                        return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                                      return param[0];
                                    }), lc);
                      }), indl)));
}

function extract_params(indl) {
  var paramsl = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return param[1];
        }), indl);
  if (paramsl) {
    var params = paramsl[0];
    if (!Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
              var bl1 = params;
              var bl2 = param;
              return Curry._3(Util$ReactTemplate.List[/* equal */44], Constrexpr_ops$ReactTemplate.local_binder_eq, bl1, bl2);
            }), paramsl[1])) {
      CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Parameters should be syntactically the same for each inductive type."));
    }
    return params;
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("empty list of inductive types."));
  }
}

function extract_inductive(indl) {
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                var match = param[0];
                return /* record */[
                        /* ind_name */match[0][/* v */0],
                        /* ind_univs */match[1],
                        /* ind_arity */Option$ReactTemplate.cata((function (x) {
                                return x;
                              }), CAst$ReactTemplate.make(/* None */0, /* CSort */Block.__(15, [/* GType */[/* [] */0]])), param[2]),
                        /* ind_lc */Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                var match = param[1];
                                return /* tuple */[
                                        match[0][/* v */0],
                                        match[1]
                                      ];
                              }), param[3])
                      ];
              }), indl);
}

function extract_mutual_inductive_declaration_components(indl) {
  var match = Curry._1(Util$ReactTemplate.List[/* split */36], indl);
  var indl$1 = match[0];
  var params = extract_params(indl$1);
  var coes = extract_coercions(indl$1);
  var indl$2 = extract_inductive(indl$1);
  return /* tuple */[
          /* tuple */[
            params,
            indl$2
          ],
          coes,
          Curry._1(Util$ReactTemplate.List[/* flatten */8], match[1])
        ];
}

function is_recursive(mie) {
  var match = mie[/* mind_entry_inds */3];
  if (match) {
    if (match[1]) {
      return /* false */0;
    } else {
      var nparams = Curry._1(Util$ReactTemplate.List[/* length */0], mie[/* mind_entry_params */2]);
      return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (t) {
                    var _lift = nparams + 1 | 0;
                    var _typ = t;
                    while(true) {
                      var typ = _typ;
                      var lift = _lift;
                      var match = Constr$ReactTemplate.kind(typ);
                      switch (match.tag | 0) {
                        case 6 : 
                            if (EConstr$ReactTemplate.Vars[/* noccurn */12](Evd$ReactTemplate.empty, lift, EConstr$ReactTemplate.of_constr(match[1]))) {
                              _typ = match[2];
                              _lift = lift + 1 | 0;
                              continue ;
                              
                            } else {
                              return /* true */1;
                            }
                            break;
                        case 8 : 
                            _typ = match[3];
                            _lift = lift + 1 | 0;
                            continue ;
                            default:
                          return /* false */0;
                      }
                    };
                  }), match[0][/* mind_entry_lc */4]);
    }
  } else {
    return /* false */0;
  }
}

function declare_mutual_inductive_with_eliminations(mie, pl, impls) {
  var match = mie[/* mind_entry_finite */1];
  if (match >= 2) {
    if (is_recursive(mie)) {
      if (Option$ReactTemplate.has_some(mie[/* mind_entry_record */0])) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Records declared with the keywords Record or Structure cannot be recursive. You can, however, define recursive records using the Inductive or CoInductive command."));
      } else {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Types declared with the keyword Variant cannot be recursive. Recursive types are defined with the Inductive and CoInductive command."));
      }
    }
    
  }
  var names = Curry._2(Util$ReactTemplate.List[/* map */10], (function (e) {
          return e[/* mind_entry_typename */0];
        }), mie[/* mind_entry_inds */3]);
  var match$1 = Declare$ReactTemplate.declare_mind(mie);
  var mind = Global$ReactTemplate.mind_of_delta_kn(match$1[0][1]);
  Curry._2(Util$ReactTemplate.List[/* iteri */79], (function (i, param) {
          var ind = /* tuple */[
            mind,
            i
          ];
          var gr = /* IndRef */Block.__(2, [ind]);
          Impargs$ReactTemplate.maybe_declare_manual_implicits(/* false */0, gr, /* None */0, param[0]);
          Declare$ReactTemplate.declare_univ_binders(gr, pl);
          return Curry._2(Util$ReactTemplate.List[/* iteri */79], (function (j, impls) {
                        return Impargs$ReactTemplate.maybe_declare_manual_implicits(/* false */0, /* ConstructRef */Block.__(3, [/* tuple */[
                                        ind,
                                        j + 1 | 0
                                      ]]), /* None */0, impls);
                      }), param[1]);
        }), impls);
  var match$2 = mie[/* mind_entry_record */0];
  var warn_prim = match$2 && match$2[0] ? 1 - match$1[1] : /* false */0;
  Flags$ReactTemplate.if_verbose((function (eta) {
          return Feedback$ReactTemplate.msg_info(/* None */0, eta);
        }), minductive_message(warn_prim, names));
  if (!mie[/* mind_entry_private */5]) {
    Indschemes$ReactTemplate.declare_default_schemes(mind);
  }
  return mind;
}

function do_mutual_inductive(indl, cum, poly, prv, finite) {
  var match = extract_mutual_inductive_declaration_components(indl);
  var ntns = match[2];
  var match$1 = interp_mutual_inductive(match[0], ntns, cum, poly, prv, finite);
  declare_mutual_inductive_with_eliminations(match$1[0], match$1[1], match$1[2]);
  var partial_arg = Global$ReactTemplate.env(/* () */0);
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
          return Metasyntax$ReactTemplate.add_notation_interpretation(partial_arg, param);
        }), ntns);
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (qid) {
          return Class$ReactTemplate.try_add_new_coercion(Nametab$ReactTemplate.locate(qid), /* false */0, poly);
        }), match[1]);
  if (Environ$ReactTemplate.deactivated_guard(Global$ReactTemplate.env(/* () */0))) {
    return Feedback$ReactTemplate.feedback(/* None */0, /* None */0, /* None */0, /* AddedAxiom */3);
  } else {
    return /* () */0;
  }
}

exports.do_mutual_inductive = do_mutual_inductive;
exports.declare_mutual_inductive_with_eliminations = declare_mutual_inductive_with_eliminations;
exports.extract_mutual_inductive_declaration_components = extract_mutual_inductive_declaration_components;
exports.interp_mutual_inductive = interp_mutual_inductive;
/* Pp-ReactTemplate Not a pure module */
