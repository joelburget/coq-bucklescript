// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("bs-platform/lib/js/sys.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Int32 = require("bs-platform/lib/js/int32.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_int64 = require("bs-platform/lib/js/caml_int64.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var maxuint31 = Caml_format.caml_int32_of_string("0x7FFFFFFF");

function select(f32, f64) {
  if (Sys.word_size === 64) {
    return f64;
  } else {
    return f32;
  }
}

function to_int(i) {
  return i;
}

function of_int_32(i) {
  return i;
}

function of_int_64(i) {
  return i & 2147483647;
}

var of_int = select(of_int_32, of_int_64);

function of_uint(i) {
  return i;
}

function to_string_32(i) {
  return Int32.to_string(i & maxuint31);
}

var to_string = select(to_string_32, Pervasives.string_of_int);

function of_string(s) {
  var i32 = Caml_format.caml_int32_of_string(s);
  if (Int32.compare(Int32.zero, i32) <= 0 && Int32.compare(i32, maxuint31) <= 0) {
    return i32;
  } else {
    throw [
          Caml_builtin_exceptions.failure,
          "int_of_string"
        ];
  }
}

function l_sl(x, y) {
  return Curry._1(of_int, 0 <= y && y < 31 ? (x << y) : 0);
}

function l_sr(x, y) {
  if (0 <= y && y < 31) {
    return (x >>> y) | 0;
  } else {
    return 0;
  }
}

function l_and(x, y) {
  return x & y;
}

function l_or(x, y) {
  return x | y;
}

function l_xor(x, y) {
  return x ^ y;
}

function add(x, y) {
  return Curry._1(of_int, x + y | 0);
}

function sub(x, y) {
  return Curry._1(of_int, x - y | 0);
}

function mul(x, y) {
  return Curry._1(of_int, Caml_int32.imul(x, y));
}

function mulc_32(x, y) {
  var x$1 = Caml_int64.of_int32(x & maxuint31);
  var y$1 = Caml_int64.of_int32(y & maxuint31);
  var m = Caml_int64.mul(x$1, y$1);
  var l = m[1] | 0;
  var h = Caml_int64.lsr_(m, 31)[1] | 0;
  return /* tuple */[
          h,
          l
        ];
}

function mulc_64(x, y) {
  var m = Caml_int32.imul(x, y);
  var l = m & 2147483647;
  var h = (m >>> 31) & 2147483647;
  return /* tuple */[
          h,
          l
        ];
}

var mulc = select(mulc_32, mulc_64);

function div_32(x, y) {
  if (y) {
    return Caml_int32.div(x & maxuint31, y & maxuint31);
  } else {
    return 0;
  }
}

function div_64(x, y) {
  if (y) {
    return Caml_int32.div(x, y);
  } else {
    return 0;
  }
}

var div = select(div_32, div_64);

function rem_32(x, y) {
  if (y) {
    return Caml_int32.mod_(x & maxuint31, y & maxuint31);
  } else {
    return 0;
  }
}

function rem_64(x, y) {
  if (y) {
    return Caml_int32.mod_(x, y);
  } else {
    return 0;
  }
}

var rem = select(rem_32, rem_64);

function div21_32(xh, xl, y) {
  if (y) {
    var x = Caml_int64.or_(Caml_int64.lsl_(Caml_int64.of_int32(xh & maxuint31), 31), Caml_int64.of_int32(xl & maxuint31));
    var y$1 = Caml_int64.of_int32(y & maxuint31);
    var q = Caml_int64.div(x, y$1);
    var r = Caml_int64.mod_(x, y$1);
    return /* tuple */[
            q[1] | 0,
            r[1] | 0
          ];
  } else {
    return /* tuple */[
            0,
            0
          ];
  }
}

function div21_64(xh, xl, y) {
  if (y) {
    var x = (xh << 31) | xl;
    var q = Caml_int32.div(x, y);
    var r = Caml_int32.mod_(x, y);
    return /* tuple */[
            q,
            r
          ];
  } else {
    return /* tuple */[
            0,
            0
          ];
  }
}

var div21 = select(div21_32, div21_64);

function lt_32(x, y) {
  return +((x ^ 1073741824) < (y ^ 1073741824));
}

function lt_64(x, y) {
  return +(x < y);
}

var lt = select(lt_32, lt_64);

function le_32(x, y) {
  return +((x ^ 1073741824) <= (y ^ 1073741824));
}

function le_64(x, y) {
  return +(x <= y);
}

var le = select(le_32, le_64);

function equal(x, y) {
  return +(x === y);
}

function cmp_32(x, y) {
  return Int32.compare(x & maxuint31, y & maxuint31);
}

var cmp_64 = Caml_primitive.caml_int_compare;

var compare = select(cmp_32, cmp_64);

function head0(x) {
  var r = 0;
  var x$1 = x;
  if (x$1 & 2147418112) {
    x$1 = (x$1 >>> 15);
  } else {
    r = r + 15 | 0;
  }
  if (!(x$1 & 65280)) {
    x$1 = (x$1 << 8);
    r = r + 8 | 0;
  }
  if (!(x$1 & 61440)) {
    x$1 = (x$1 << 4);
    r = r + 4 | 0;
  }
  if (!(x$1 & 49152)) {
    x$1 = (x$1 << 2);
    r = r + 2 | 0;
  }
  if (!(x$1 & 32768)) {
    x$1 = (x$1 << 1);
    r = r + 1 | 0;
  }
  if (!(x$1 & 32768)) {
    r = r + 1 | 0;
  }
  return r;
}

function tail0(x) {
  var r = 0;
  var x$1 = x;
  if (!(x$1 & 65535)) {
    x$1 = (x$1 >>> 16);
    r = r + 16 | 0;
  }
  if (!(x$1 & 255)) {
    x$1 = (x$1 >>> 8);
    r = r + 8 | 0;
  }
  if (!(x$1 & 15)) {
    x$1 = (x$1 >>> 4);
    r = r + 4 | 0;
  }
  if (!(x$1 & 3)) {
    x$1 = (x$1 >>> 2);
    r = r + 2 | 0;
  }
  if (!(x$1 & 1)) {
    r = r + 1 | 0;
  }
  return r;
}

function add_digit(x, d) {
  return (x << 1) | d;
}

exports.to_int = to_int;
exports.of_int = of_int;
exports.of_uint = of_uint;
exports.to_string = to_string;
exports.of_string = of_string;
exports.l_sl = l_sl;
exports.l_sr = l_sr;
exports.l_and = l_and;
exports.l_xor = l_xor;
exports.l_or = l_or;
exports.add = add;
exports.sub = sub;
exports.mul = mul;
exports.div = div;
exports.rem = rem;
exports.mulc = mulc;
exports.div21 = div21;
exports.lt = lt;
exports.equal = equal;
exports.le = le;
exports.compare = compare;
exports.head0 = head0;
exports.tail0 = tail0;
exports.add_digit = add_digit;
/* maxuint31 Not a pure module */
