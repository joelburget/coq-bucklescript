// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Dyn$ReactTemplate = require("./dyn.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var Ploc$ReactTemplate = require("../camlp5/ocaml_src/lib/ploc.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Store$ReactTemplate = require("./store.bs.js");
var CLexer$ReactTemplate = require("./cLexer.bs.js");
var Genarg$ReactTemplate = require("./genarg.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Stdarg$ReactTemplate = require("./stdarg.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Exninfo$ReactTemplate = require("./exninfo.bs.js");
var Gramext$ReactTemplate = require("../camlp5/ocaml_src/lib/gramext.bs.js");
var Grammar$ReactTemplate = require("../camlp5/ocaml_src/lib/grammar.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function uncurry(f, param) {
  return Curry._2(f, param[0], param[1]);
}

function coq_file_of_ploc_file(s) {
  if (s === "") {
    return /* ToplevelInput */0;
  } else {
    return /* InFile */[s];
  }
}

function to_coqloc(loc) {
  return /* record */[
          /* fname */coq_file_of_ploc_file(Ploc$ReactTemplate.file_name(loc)),
          /* line_nb */Ploc$ReactTemplate.line_nb(loc),
          /* bol_pos */Ploc$ReactTemplate.bol_pos(loc),
          /* line_nb_last */Ploc$ReactTemplate.line_nb_last(loc),
          /* bol_pos_last */Ploc$ReactTemplate.bol_pos_last(loc),
          /* bp */Ploc$ReactTemplate.first_pos(loc),
          /* ep */Ploc$ReactTemplate.last_pos(loc)
        ];
}

var include = Grammar$ReactTemplate.GMake([CLexer$ReactTemplate.lexer]);

var parsable = include[0];

var Entry = include[4];

var extend = include[6];

var delete_rule = include[7];

function parsable$1($staropt$star, c) {
  var file = $staropt$star ? $staropt$star[0] : /* ToplevelInput */0;
  var state = [CLexer$ReactTemplate.init_lexer_state(file)];
  CLexer$ReactTemplate.set_lexer_state(state[0]);
  var a = Curry._1(parsable, c);
  state[0] = CLexer$ReactTemplate.get_lexer_state(/* () */0);
  return /* tuple */[
          a,
          state
        ];
}

function action(prim) {
  return prim;
}

var entry_create = Entry[/* create */0];

function entry_parse(e, param) {
  var state = param[1];
  CLexer$ReactTemplate.set_lexer_state(state[0]);
  try {
    var c = Curry._2(Entry[/* parse */1], e, param[0]);
    state[0] = CLexer$ReactTemplate.get_lexer_state(/* () */0);
    return c;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Ploc$ReactTemplate.Exc) {
      var e$1 = exn[2];
      CLexer$ReactTemplate.drop_lexer_state(/* () */0);
      var loc$prime = Loc$ReactTemplate.get_loc(Exninfo$ReactTemplate.info(e$1));
      var loc = loc$prime ? loc$prime[0] : to_coqloc(exn[1]);
      return Loc$ReactTemplate.raise(/* Some */[loc], e$1);
    } else {
      throw exn;
    }
  }
}

function comment_state(param) {
  return CLexer$ReactTemplate.get_comment_state(param[1][0]);
}

function entry_print(ft, x) {
  return Curry._2(Entry[/* print */5], ft, x);
}

var parse_tokens_after_filter = Entry[/* parse_token */6];

function of_coq_assoc(param) {
  return param;
}

function of_coq_position(param) {
  if (typeof param === "number") {
    if (param) {
      return /* Last */1;
    } else {
      return /* First */0;
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return /* Before */Block.__(0, [param[0]]);
      case 1 : 
          return /* After */Block.__(1, [param[0]]);
      case 2 : 
          return /* Level */Block.__(3, [param[0]]);
      
    }
  }
}

function stoken(tok) {
  var pattern;
  if (typeof tok === "number") {
    pattern = tok ? /* tuple */[
        "EOI",
        ""
      ] : /* tuple */[
        "LEFTQMARK",
        ""
      ];
  } else {
    switch (tok.tag | 0) {
      case 0 : 
          pattern = /* tuple */[
            "",
            tok[0]
          ];
          break;
      case 1 : 
          pattern = /* tuple */[
            "PATTERNIDENT",
            tok[0]
          ];
          break;
      case 2 : 
          pattern = /* tuple */[
            "IDENT",
            tok[0]
          ];
          break;
      case 3 : 
          pattern = /* tuple */[
            "FIELD",
            tok[0]
          ];
          break;
      case 4 : 
          pattern = /* tuple */[
            "INT",
            tok[0]
          ];
          break;
      case 5 : 
          pattern = /* tuple */[
            "STRING",
            tok[0]
          ];
          break;
      case 6 : 
          pattern = /* tuple */[
            "BULLET",
            tok[0]
          ];
          break;
      
    }
  }
  return /* Stoken */Block.__(10, [pattern]);
}

function camlp5_verbosity(silent, f, x) {
  var a = Gramext$ReactTemplate.warning_verbose[0];
  Gramext$ReactTemplate.warning_verbose[0] = silent;
  Curry._1(f, x);
  Gramext$ReactTemplate.warning_verbose[0] = a;
  return /* () */0;
}

function of_coq_action(param) {
  if (param) {
    var r = param[0];
    return (function (f) {
        return (function (x) {
            return Curry._1(of_coq_action(r), Curry._1(f, x));
          });
      });
  } else {
    return (function (f) {
        return (function (loc) {
            return Curry._1(f, to_coqloc(loc));
          });
      });
  }
}

function symbol_of_prod_entry_key(param) {
  if (typeof param === "number") {
    if (param) {
      return /* Snext */1;
    } else {
      return /* Sself */0;
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return stoken(param[0]);
      case 1 : 
          return /* Slist1 */Block.__(6, [symbol_of_prod_entry_key(param[0])]);
      case 2 : 
          var param$1 = /* tuple */[
            symbol_of_prod_entry_key(param[0]),
            symbol_of_prod_entry_key(param[1])
          ];
          return /* Slist1sep */Block.__(7, [
                    param$1[0],
                    param$1[1],
                    /* false */0
                  ]);
      case 3 : 
          return /* Slist0 */Block.__(4, [symbol_of_prod_entry_key(param[0])]);
      case 4 : 
          var param$2 = /* tuple */[
            symbol_of_prod_entry_key(param[0]),
            symbol_of_prod_entry_key(param[1])
          ];
          return /* Slist0sep */Block.__(5, [
                    param$2[0],
                    param$2[1],
                    /* false */0
                  ]);
      case 5 : 
          return /* Sopt */Block.__(8, [symbol_of_prod_entry_key(param[0])]);
      case 6 : 
      case 7 : 
          throw [
                Caml_builtin_exceptions.match_failure,
                [
                  "pcoq.ml",
                  226,
                  8
                ]
              ];
      case 8 : 
          return Gramext$ReactTemplate.srules(Curry._2(Util$ReactTemplate.List[/* map */10], symbol_of_rules, param[0]));
      
    }
  }
}

function symbol_of_rule(param) {
  if (param) {
    var s = param[1];
    var r = param[0];
    return (function (accu) {
        return Curry._1(symbol_of_rule(r), /* :: */[
                    symbol_of_prod_entry_key(s),
                    accu
                  ]);
      });
  } else {
    return (function (accu) {
        return accu;
      });
  }
}

function symbol_of_rules(param) {
  var r = param[0];
  var symb = Curry._1(symbol_of_rule(r[/* norec_rule */0]), /* [] */0);
  var act = Curry._1(of_coq_action(r[/* norec_rule */0]), param[1]);
  return /* tuple */[
          symb,
          act
        ];
}

function of_coq_production_rule(param) {
  var toks = param[0];
  return /* tuple */[
          Curry._1(symbol_of_rule(toks), /* [] */0),
          Curry._1(of_coq_action(toks), param[1])
        ];
}

function of_coq_single_extend_statement(param) {
  return /* tuple */[
          param[0],
          Option$ReactTemplate.map(of_coq_assoc, param[1]),
          Curry._2(Util$ReactTemplate.List[/* map */10], of_coq_production_rule, param[2])
        ];
}

function of_coq_extend_statement(param) {
  return /* tuple */[
          Option$ReactTemplate.map(of_coq_position, param[0]),
          Curry._2(Util$ReactTemplate.List[/* map */10], of_coq_single_extend_statement, param[1])
        ];
}

var camlp5_state = [/* [] */0];

function grammar_delete(e, reinit, param) {
  var pos = param[0];
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
          return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                        return Curry._2(delete_rule, e, param[0]);
                      }), Curry._1(Util$ReactTemplate.List[/* rev */4], param[2]));
        }), Curry._1(Util$ReactTemplate.List[/* rev */4], param[1]));
  if (reinit) {
    var match = reinit[0];
    var ext = of_coq_position(match[1]);
    var lev;
    var exit = 0;
    if (pos) {
      var match$1 = pos[0];
      if (typeof match$1 === "number" || match$1.tag !== 3) {
        exit = 1;
      } else {
        lev = match$1[0];
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "pcoq.ml",
              292,
              11
            ]
          ];
    }
    return Curry._3(extend, e, /* Some */[ext], /* :: */[
                /* tuple */[
                  /* Some */[lev],
                  /* Some */[match[0]],
                  /* [] */0
                ],
                /* [] */0
              ]);
  } else {
    return /* () */0;
  }
}

function grammar_extend(e, reinit, ext) {
  var ext$1 = of_coq_extend_statement(ext);
  var undo = function () {
    return grammar_delete(e, reinit, ext$1);
  };
  var redo = function () {
    var partial_arg = Curry._1(extend, e);
    return camlp5_verbosity(/* false */0, (function (param) {
                  return uncurry(partial_arg, param);
                }), ext$1);
  };
  camlp5_state[0] = /* :: */[
    /* ByEXTEND */Block.__(1, [
        undo,
        redo
      ]),
    camlp5_state[0]
  ];
  return redo(/* () */0);
}

function extend$1(e) {
  return (function (param, param$1) {
      var ext = /* tuple */[
        param,
        param$1
      ];
      camlp5_state[0] = /* :: */[
        /* ByEXTEND */Block.__(1, [
            (function () {
                return grammar_delete(e, /* None */0, ext);
              }),
            (function () {
                return uncurry(Curry._1(extend, e), ext);
              })
          ]),
        camlp5_state[0]
      ];
      return uncurry(Curry._1(extend, e), ext);
    });
}

var delete_rule$1 = Curry.__2(delete_rule);

function remove_grammars(_n) {
  while(true) {
    var n = _n;
    if (n > 0) {
      var match = camlp5_state[0];
      if (match) {
        var match$1 = match[0];
        if (match$1.tag) {
          var redo = match$1[1];
          var undo = match$1[0];
          Curry._1(undo, /* () */0);
          camlp5_state[0] = match[1];
          remove_grammars(n);
          Curry._1(redo, /* () */0);
          camlp5_state[0] = /* :: */[
            /* ByEXTEND */Block.__(1, [
                undo,
                redo
              ]),
            camlp5_state[0]
          ];
          return /* () */0;
        } else {
          var match$2 = match$1[0];
          grammar_delete(match$2[0], match$2[1], of_coq_extend_statement(match$2[2]));
          camlp5_state[0] = match[1];
          _n = n - 1 | 0;
          continue ;
          
        }
      } else {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Pcoq.remove_grammars"], Pp$ReactTemplate.str("too many rules to remove."));
      }
    } else {
      return 0;
    }
  };
}

function make_rule(r) {
  return /* :: */[
          /* tuple */[
            /* None */0,
            /* None */0,
            r
          ],
          /* [] */0
        ];
}

function eoi_entry(en) {
  var e = Curry._1(entry_create, Curry._1(Entry[/* name */2], en) + "_eoi");
  var symbs_000 = /* Snterm */Block.__(2, [en]);
  var symbs_001 = /* :: */[
    stoken(/* EOI */1),
    /* [] */0
  ];
  var symbs = /* :: */[
    symbs_000,
    symbs_001
  ];
  var act = function (_, x, _$1) {
    return x;
  };
  uncurry(extend$1(e), /* tuple */[
        /* None */0,
        make_rule(/* :: */[
              /* tuple */[
                symbs,
                act
              ],
              /* [] */0
            ])
      ]);
  return e;
}

function map_entry(f, en) {
  var e = Curry._1(entry_create, Curry._1(Entry[/* name */2], en) + "_map");
  var symbs_000 = /* Snterm */Block.__(2, [en]);
  var symbs = /* :: */[
    symbs_000,
    /* [] */0
  ];
  var act = function (x, _) {
    return Curry._1(f, x);
  };
  uncurry(extend$1(e), /* tuple */[
        /* None */0,
        make_rule(/* :: */[
              /* tuple */[
                symbs,
                act
              ],
              /* [] */0
            ])
      ]);
  return e;
}

function parse_string(f, x) {
  var strm = Stream.of_string(x);
  return entry_parse(f, parsable$1(/* None */0, strm));
}

var utables = Hashtbl.create(/* None */0, 97);

function create_universe(u) {
  Hashtbl.add(utables, u, /* () */0);
  return u;
}

var uprim = create_universe("prim");

var uconstr = create_universe("constr");

var utactic = create_universe("tactic");

var uvernac = create_universe("vernac");

function get_univ(u) {
  if (Hashtbl.mem(utables, u)) {
    return u;
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function new_entry(u, s) {
  return Curry._1(entry_create, u + (":" + s));
}

function $$default() {
  return /* None */0;
}

var GrammarObj = /* module */[
  /* name */"grammar",
  /* default */$$default
];

var Grammar = Genarg$ReactTemplate.Register(GrammarObj);

var register_grammar = Grammar[/* register0 */0];

var genarg_grammar = Grammar[/* obj */1];

function create_generic_entry(u, s, etyp) {
  var e = new_entry(u, s);
  Curry._2(Grammar[/* register0 */0], etyp[0], e);
  return e;
}

var preident = new_entry(uprim, "preident");

var ident = new_entry(uprim, "ident");

var natural = new_entry(uprim, "natural");

var integer = new_entry(uprim, "integer");

var bigint = Curry._1(entry_create, "Prim.bigint");

var string = new_entry(uprim, "string");

var lstring = Curry._1(entry_create, "Prim.lstring");

var reference = new_entry(uprim, "reference");

var by_notation = Curry._1(entry_create, "by_notation");

var smart_global = Curry._1(entry_create, "smart_global");

var $$var = new_entry(uprim, "var");

var name = Curry._1(entry_create, "Prim.name");

var identref = Curry._1(entry_create, "Prim.identref");

var univ_decl = Curry._1(entry_create, "Prim.univ_decl");

var ident_decl = Curry._1(entry_create, "Prim.ident_decl");

var pattern_ident = Curry._1(entry_create, "pattern_ident");

var pattern_identref = Curry._1(entry_create, "pattern_identref");

var base_ident = Curry._1(entry_create, "Prim.base_ident");

var qualid = Curry._1(entry_create, "Prim.qualid");

var fullyqualid = Curry._1(entry_create, "Prim.fullyqualid");

var dirpath = Curry._1(entry_create, "Prim.dirpath");

var ne_string = Curry._1(entry_create, "Prim.ne_string");

var ne_lstring = Curry._1(entry_create, "Prim.ne_lstring");

var constr = new_entry(uconstr, "constr");

var operconstr = new_entry(uconstr, "operconstr");

var constr_eoi = eoi_entry(constr);

var lconstr = new_entry(uconstr, "lconstr");

var binder_constr = new_entry(uconstr, "binder_constr");

var ident$1 = new_entry(uconstr, "ident");

var $$global = new_entry(uconstr, "global");

var universe_level = new_entry(uconstr, "universe_level");

var sort = new_entry(uconstr, "sort");

var sort_family = new_entry(uconstr, "sort_family");

var pattern = Curry._1(entry_create, "constr:pattern");

var constr_pattern = new_entry(uconstr, "constr_pattern");

var lconstr_pattern = new_entry(uconstr, "lconstr_pattern");

var closed_binder = Curry._1(entry_create, "constr:closed_binder");

var binder = Curry._1(entry_create, "constr:binder");

var binders = Curry._1(entry_create, "constr:binders");

var open_binders = Curry._1(entry_create, "constr:open_binders");

var binders_fixannot = Curry._1(entry_create, "constr:binders_fixannot");

var typeclass_constraint = Curry._1(entry_create, "constr:typeclass_constraint");

var record_declaration = Curry._1(entry_create, "constr:record_declaration");

var appl_arg = Curry._1(entry_create, "constr:appl_arg");

var module_expr = Curry._1(entry_create, "module_expr");

var module_type = Curry._1(entry_create, "module_type");

var Module = /* module */[
  /* module_expr */module_expr,
  /* module_type */module_type
];

function gec_vernac(s) {
  return Curry._1(entry_create, "vernac:" + s);
}

var gallina = gec_vernac("gallina");

var gallina_ext = gec_vernac("gallina_ext");

var command = gec_vernac("command");

var syntax = gec_vernac("syntax_command");

var vernac_control = gec_vernac("Vernac.vernac_control");

var rec_definition = gec_vernac("Vernac.rec_definition");

var red_expr = new_entry(utactic, "red_expr");

var hint_info = gec_vernac("hint_info");

var main_entry = Curry._1(entry_create, "vernac");

var noedit_mode = gec_vernac("noedit_command");

function act_vernac(v, loc) {
  return /* Some */[/* tuple */[
            to_coqloc(loc),
            v
          ]];
}

function act_eoi(_, _$1) {
  return /* None */0;
}

var rule_000 = /* tuple */[
  /* :: */[
    stoken(/* EOI */1),
    /* [] */0
  ],
  act_eoi
];

var rule_001 = /* :: */[
  /* tuple */[
    /* :: */[
      /* Snterm */Block.__(2, [vernac_control]),
      /* [] */0
    ],
    act_vernac
  ],
  /* [] */0
];

var rule = /* :: */[
  rule_000,
  rule_001
];

uncurry(extend$1(main_entry), /* tuple */[
      /* None */0,
      make_rule(rule)
    ]);

var command_entry_ref = [noedit_mode];

var command_entry = Curry._2(Entry[/* of_parser */3], "command_entry", (function (strm) {
        return Curry._2(parse_tokens_after_filter, command_entry_ref[0], strm);
      }));

function set_command_entry(e) {
  command_entry_ref[0] = e;
  return /* () */0;
}

function get_command_entry() {
  return command_entry_ref[0];
}

function epsilon_value(f, e) {
  var r_000 = /* Next */[
    /* Stop */0,
    e
  ];
  var r_001 = function (x, _) {
    return Curry._1(f, x);
  };
  var r = /* Rule */[
    r_000,
    r_001
  ];
  var ext = of_coq_extend_statement(/* tuple */[
        /* None */0,
        /* :: */[
          /* tuple */[
            /* None */0,
            /* None */0,
            /* :: */[
              r,
              /* [] */0
            ]
          ],
          /* [] */0
        ]
      ]);
  var entry = Curry._1(entry_create, "epsilon");
  uncurry(Curry._1(extend, entry), ext);
  try {
    return /* Some */[parse_string(entry, "")];
  }
  catch (exn){
    return /* None */0;
  }
}

var GramState = Store$ReactTemplate.Make(/* module */[]);

var GrammarCommand = Dyn$ReactTemplate.Make(/* module */[]);

var GrammarInterp = /* module */[];

var GrammarInterpMap = Curry._1(GrammarCommand[/* Map */4], GrammarInterp);

var grammar_interp = [GrammarInterpMap[/* empty */0]];

var grammar_stack = [/* [] */0];

function create_grammar_command(name, interp) {
  var obj = Curry._1(GrammarCommand[/* create */0], name);
  grammar_interp[0] = Curry._3(GrammarInterpMap[/* add */1], obj, interp, grammar_interp[0]);
  return obj;
}

function extend_grammar_command(tag, g) {
  var modify = Curry._2(GrammarInterpMap[/* find */3], tag, grammar_interp[0]);
  var match = grammar_stack[0];
  var grammar_state = match ? match[0][2] : GramState[/* empty */0];
  var match$1 = Curry._2(modify, g, grammar_state);
  var rules = match$1[0];
  var iter = function (param) {
    var e = param[0];
    var reinit = param[1];
    var ext = param[2];
    camlp5_state[0] = /* :: */[
      /* ByGrammar */Block.__(0, [/* ExtendRule */[
            e,
            reinit,
            ext
          ]]),
      camlp5_state[0]
    ];
    var partial_arg = Curry._1(extend, e);
    return camlp5_verbosity(/* false */0, (function (param) {
                  return uncurry(partial_arg, param);
                }), of_coq_extend_statement(ext));
  };
  Curry._2(Util$ReactTemplate.List[/* iter */9], iter, rules);
  var nb = Curry._1(Util$ReactTemplate.List[/* length */0], rules);
  grammar_stack[0] = /* :: */[
    /* tuple */[
      nb,
      /* Dyn */[
        tag,
        g
      ],
      match$1[1]
    ],
    grammar_stack[0]
  ];
  return /* () */0;
}

function recover_grammar_command(tag) {
  var filter = function (param) {
    var match = param[1];
    var match$1 = Curry._2(GrammarCommand[/* eq */1], tag, match[0]);
    if (match$1) {
      return /* Some */[match[1]];
    } else {
      return /* None */0;
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* map_filter */62], filter, grammar_stack[0]);
}

function extend_dyn_grammar(param) {
  return extend_grammar_command(param[0], param[1]);
}

function freeze() {
  return /* tuple */[
          grammar_stack[0],
          CLexer$ReactTemplate.get_keyword_state(/* () */0)
        ];
}

function factorize_grams(l1, l2) {
  if (l1 === l2) {
    return /* tuple */[
            /* [] */0,
            /* [] */0,
            l1
          ];
  } else {
    return Curry._2(Util$ReactTemplate.List[/* share_tails */115], l1, l2);
  }
}

function number_of_entries(gcl) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (n, param) {
                return n + param[0] | 0;
              }), 0, gcl);
}

function unfreeze(param) {
  var match = factorize_grams(grammar_stack[0], param[0]);
  var n = number_of_entries(match[0]);
  remove_grammars(n);
  grammar_stack[0] = match[2];
  CLexer$ReactTemplate.set_keyword_state(param[1]);
  return Curry._2(Util$ReactTemplate.List[/* iter */9], extend_dyn_grammar, Curry._2(Util$ReactTemplate.List[/* rev_map */12], Util$ReactTemplate.pi2, match[1]));
}

var parser_summary_tag = Summary$ReactTemplate.declare_summary_tag("GRAMMAR_LEXER", /* record */[
      /* freeze_function */freeze,
      /* unfreeze_function */unfreeze,
      /* init_function */Summary$ReactTemplate.nop
    ]);

function with_grammar_rule_protection(f, x) {
  var fs = freeze(/* false */0);
  try {
    var a = Curry._1(f, x);
    unfreeze(fs);
    return a;
  }
  catch (raw_reraise){
    var reraise = Js_exn.internalToOCamlException(raw_reraise);
    var reraise$1 = CErrors$ReactTemplate.push(reraise);
    unfreeze(fs);
    return Util$ReactTemplate.iraise(reraise$1);
  }
}

Curry._2(Grammar[/* register0 */0], Stdarg$ReactTemplate.wit_int, integer);

Curry._2(Grammar[/* register0 */0], Stdarg$ReactTemplate.wit_string, string);

Curry._2(Grammar[/* register0 */0], Stdarg$ReactTemplate.wit_pre_ident, preident);

Curry._2(Grammar[/* register0 */0], Stdarg$ReactTemplate.wit_ident, ident);

Curry._2(Grammar[/* register0 */0], Stdarg$ReactTemplate.wit_var, $$var);

Curry._2(Grammar[/* register0 */0], Stdarg$ReactTemplate.wit_ref, reference);

Curry._2(Grammar[/* register0 */0], Stdarg$ReactTemplate.wit_sort_family, sort_family);

Curry._2(Grammar[/* register0 */0], Stdarg$ReactTemplate.wit_constr, constr);

Curry._2(Grammar[/* register0 */0], Stdarg$ReactTemplate.wit_red_expr, red_expr);

var grammar_names = [Util$ReactTemplate.$$String[/* Map */39][/* empty */0]];

function register_grammars_by_name(name, grams) {
  grammar_names[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], name, grams, grammar_names[0]);
  return /* () */0;
}

function find_grammars_by_name(name) {
  return Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], name, grammar_names[0]);
}

var Gram_000 = include[1];

var Gram_001 = include[2];

var Gram_002 = include[3];

var Gram_004 = include[5];

var Gram = [
  Gram_000,
  Gram_001,
  Gram_002,
  Entry,
  Gram_004,
  extend$1,
  delete_rule$1,
  parsable$1,
  action,
  entry_create,
  entry_parse,
  entry_print,
  comment_state,
  Gramext$ReactTemplate.srules,
  parse_tokens_after_filter
];

var Prim = [
  preident,
  ident,
  name,
  identref,
  univ_decl,
  ident_decl,
  pattern_ident,
  pattern_identref,
  base_ident,
  natural,
  bigint,
  integer,
  string,
  lstring,
  qualid,
  fullyqualid,
  reference,
  by_notation,
  smart_global,
  dirpath,
  ne_string,
  ne_lstring,
  $$var
];

var Constr = [
  constr,
  constr_eoi,
  lconstr,
  binder_constr,
  operconstr,
  ident$1,
  $$global,
  universe_level,
  sort,
  sort_family,
  pattern,
  constr_pattern,
  lconstr_pattern,
  closed_binder,
  binder,
  binders,
  open_binders,
  binders_fixannot,
  typeclass_constraint,
  record_declaration,
  appl_arg
];

var Vernac_ = [
  gallina,
  gallina_ext,
  command,
  syntax,
  vernac_control,
  rec_definition,
  noedit_mode,
  command_entry,
  red_expr,
  hint_info
];

var $bang$at = to_coqloc;

exports.Gram = Gram;
exports.camlp5_verbosity = camlp5_verbosity;
exports.parse_string = parse_string;
exports.eoi_entry = eoi_entry;
exports.map_entry = map_entry;
exports.get_univ = get_univ;
exports.uprim = uprim;
exports.uconstr = uconstr;
exports.utactic = utactic;
exports.uvernac = uvernac;
exports.register_grammar = register_grammar;
exports.genarg_grammar = genarg_grammar;
exports.create_generic_entry = create_generic_entry;
exports.Prim = Prim;
exports.Constr = Constr;
exports.Module = Module;
exports.Vernac_ = Vernac_;
exports.main_entry = main_entry;
exports.get_command_entry = get_command_entry;
exports.set_command_entry = set_command_entry;
exports.epsilon_value = epsilon_value;
exports.grammar_extend = grammar_extend;
exports.GramState = GramState;
exports.create_grammar_command = create_grammar_command;
exports.extend_grammar_command = extend_grammar_command;
exports.recover_grammar_command = recover_grammar_command;
exports.with_grammar_rule_protection = with_grammar_rule_protection;
exports.to_coqloc = to_coqloc;
exports.$bang$at = $bang$at;
exports.parser_summary_tag = parser_summary_tag;
exports.register_grammars_by_name = register_grammars_by_name;
exports.find_grammars_by_name = find_grammars_by_name;
/* include Not a pure module */
