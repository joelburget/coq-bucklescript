// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Hook$ReactTemplate = require("./hook.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Clenv$ReactTemplate = require("../proofs/clenv.bs.js");
var Logic$ReactTemplate = require("./logic.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Coqlib$ReactTemplate = require("../library/coqlib.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Indrec$ReactTemplate = require("./indrec.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Pfedit$ReactTemplate = require("./pfedit.bs.js");
var Refine$ReactTemplate = require("./refine.bs.js");
var Tacred$ReactTemplate = require("./tacred.bs.js");
var Typing$ReactTemplate = require("./typing.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Declare$ReactTemplate = require("./declare.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Impargs$ReactTemplate = require("./impargs.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Pputils$ReactTemplate = require("./pputils.bs.js");
var Printer$ReactTemplate = require("./printer.bs.js");
var Redexpr$ReactTemplate = require("../proofs/redexpr.bs.js");
var Refiner$ReactTemplate = require("./refiner.bs.js");
var Tacmach$ReactTemplate = require("../proofs/tacmach.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Clenvtac$ReactTemplate = require("../proofs/clenvtac.bs.js");
var Detyping$ReactTemplate = require("./detyping.bs.js");
var Evarconv$ReactTemplate = require("./evarconv.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Locusops$ReactTemplate = require("./locusops.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Evarsolve$ReactTemplate = require("./evarsolve.bs.js");
var Hipattern$ReactTemplate = require("../tactics/hipattern.bs.js");
var Miscprint$ReactTemplate = require("./miscprint.bs.js");
var Proofview$ReactTemplate = require("./proofview.bs.js");
var Recordops$ReactTemplate = require("./recordops.bs.js");
var Tacticals$ReactTemplate = require("../tactics/tacticals.bs.js");
var Logic_monad$ReactTemplate = require("./logic_monad.bs.js");
var Safe_typing$ReactTemplate = require("./safe_typing.bs.js");
var Typeclasses$ReactTemplate = require("./typeclasses.bs.js");
var Unification$ReactTemplate = require("../pretyping/unification.bs.js");
var Constrintern$ReactTemplate = require("./constrintern.bs.js");
var Find_subterm$ReactTemplate = require("./find_subterm.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Proof_global$ReactTemplate = require("./proof_global.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("./pretype_errors.bs.js");
var Constr_matching$ReactTemplate = require("./constr_matching.bs.js");

function inj_with_occurrences(e) {
  return /* tuple */[
          /* AllOccurrences */0,
          e
        ];
}

function typ_of(env, sigma, c) {
  try {
    return Retyping$ReactTemplate.get_type_of(/* None */0, /* Some */[/* true */1], env, sigma, c);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Retyping$ReactTemplate.RetypeError) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Retyping$ReactTemplate.print_retype_error(exn[1]));
    } else {
      throw exn;
    }
  }
}

var clear_hyp_by_default = [/* false */0];

function use_clear_hyp_by_default() {
  return clear_hyp_by_default[0];
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"default clearing of hypotheses after use",
      /* optkey : :: */[
        "Default",
        /* :: */[
          "Clearing",
          /* :: */[
            "Used",
            /* :: */[
              "Hypotheses",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */(function () {
          return clear_hyp_by_default[0];
        }),
      /* optwrite */(function (b) {
          clear_hyp_by_default[0] = b;
          return /* () */0;
        })
    ]);

var universal_lemma_under_conjunctions = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"trivial unification in tactics applying under conjunctions",
      /* optkey : :: */[
        "Universal",
        /* :: */[
          "Lemma",
          /* :: */[
            "Under",
            /* :: */[
              "Conjunction",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */(function () {
          return universal_lemma_under_conjunctions[0];
        }),
      /* optwrite */(function (b) {
          universal_lemma_under_conjunctions[0] = b;
          return /* () */0;
        })
    ]);

var bracketing_last_or_and_intro_pattern = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"bracketing last or-and introduction pattern",
      /* optkey : :: */[
        "Bracketing",
        /* :: */[
          "Last",
          /* :: */[
            "Introduction",
            /* :: */[
              "Pattern",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */(function () {
          return bracketing_last_or_and_intro_pattern[0];
        }),
      /* optwrite */(function (b) {
          bracketing_last_or_and_intro_pattern[0] = b;
          return /* () */0;
        })
    ]);

function unsafe_intro(env, store, decl, b) {
  return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                var ctx = Environ$ReactTemplate.named_context_val(env);
                var nctx = EConstr$ReactTemplate.push_named_context_val(decl, ctx);
                var partial_arg = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
                var inst = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                        return Util$ReactTemplate.$percent$great(partial_arg, EConstr$ReactTemplate.mkVar, param);
                      }), EConstr$ReactTemplate.named_context(env));
                var ninst_000 = EConstr$ReactTemplate.mkRel(1);
                var ninst = /* :: */[
                  ninst_000,
                  inst
                ];
                var nb = EConstr$ReactTemplate.Vars[/* subst1 */4](EConstr$ReactTemplate.mkVar(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl)), b);
                var match = Evarutil$ReactTemplate.new_evar_instance(nctx, sigma, nb, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], ninst);
                return /* tuple */[
                        match[0],
                        EConstr$ReactTemplate.mkNamedLambda_or_LetIn(decl, match[1])
                      ];
              }));
}

function introduction($staropt$star, id) {
  var check = $staropt$star ? $staropt$star[0] : /* true */1;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var hyps = Environ$ReactTemplate.named_context_val(Proofview$ReactTemplate.Goal[/* env */4](gl));
                var store = Proofview$ReactTemplate.Goal[/* extra */6](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                if (check && Termops$ReactTemplate.mem_named_context_val(id, hyps)) {
                  CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Tactics.introduction"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Variable "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(" is already declared.")));
                }
                var match = EConstr$ReactTemplate.kind(sigma, concl);
                switch (match.tag | 0) {
                  case 6 : 
                      return unsafe_intro(env, store, /* LocalAssum */Block.__(0, [
                                    id,
                                    match[1]
                                  ]), match[2]);
                  case 8 : 
                      return unsafe_intro(env, store, /* LocalDef */Block.__(1, [
                                    id,
                                    match[1],
                                    match[2]
                                  ]), match[3]);
                  default:
                    throw [
                          Logic$ReactTemplate.RefinerError,
                          env,
                          sigma,
                          /* IntroNeedsProduct */0
                        ];
                }
              }));
}

function error(msg) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(msg));
}

function convert_concl($staropt$star, ty, k) {
  var check = $staropt$star ? $staropt$star[0] : /* true */1;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var store = Proofview$ReactTemplate.Goal[/* extra */6](gl);
                var conclty = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                              var sigma$1;
                              if (check) {
                                Typing$ReactTemplate.unsafe_type_of(env, sigma, ty);
                                var match = Reductionops$ReactTemplate.infer_conv(/* None */0, /* None */0, /* None */0, env, sigma, ty, conclty);
                                if (!match[1]) {
                                  error("Not convertible.");
                                }
                                sigma$1 = match[0];
                              } else {
                                sigma$1 = sigma;
                              }
                              var match$1 = Evarutil$ReactTemplate.new_evar(env, sigma$1, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], ty);
                              var x = match$1[1];
                              var ans = k === /* DEFAULTcast */2 ? x : EConstr$ReactTemplate.mkCast(/* tuple */[
                                      x,
                                      k,
                                      conclty
                                    ]);
                              return /* tuple */[
                                      match$1[0],
                                      ans
                                    ];
                            }));
              }));
}

function convert_hyp($staropt$star, d) {
  var check = $staropt$star ? $staropt$star[0] : /* true */1;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var ty = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var store = Proofview$ReactTemplate.Goal[/* extra */6](gl);
                var sign = Logic$ReactTemplate.convert_hyp(check, Environ$ReactTemplate.named_context_val(env), sigma, d);
                var env$1 = Environ$ReactTemplate.reset_with_named_context(sign, env);
                return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                              return Evarutil$ReactTemplate.new_evar(env$1, sigma, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], ty);
                            }));
              }));
}

var partial_arg = /* Some */[/* false */0];

function convert_concl_no_check(param, param$1) {
  return convert_concl(partial_arg, param, param$1);
}

var partial_arg$1 = /* Some */[/* false */0];

function convert_hyp_no_check(param) {
  return convert_hyp(partial_arg$1, param);
}

function convert_gen(pb, x, y) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                try {
                  var match = Curry._2(Tacmach$ReactTemplate.New[/* pf_apply */0]((function (eta) {
                              var arg = /* Some */[pb];
                              return Curry._2((function (param) {
                                              return (function (param$1, param$2, param$3, param$4, param$5) {
                                                  return Reductionops$ReactTemplate.infer_conv(param, arg, param$1, param$2, param$3, param$4, param$5);
                                                });
                                            })(/* None */0), /* None */0, eta);
                            }), gl), x, y);
                  if (match[1]) {
                    return Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]);
                  } else {
                    return Tacticals$ReactTemplate.New[/* tclFAIL */3](0, Pp$ReactTemplate.str("Not convertible"));
                  }
                }
                catch (exn){
                  return Tacticals$ReactTemplate.New[/* tclFAIL */3](0, Pp$ReactTemplate.str("Not convertible"));
                }
              }));
}

function convert(x, y) {
  return convert_gen(/* CONV */0, x, y);
}

function convert_leq(x, y) {
  return convert_gen(/* CUMUL */1, x, y);
}

function clear_dependency_msg(env, sigma, id, param) {
  if (param.tag) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot remove "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.strbrk(" without breaking the typing of ")), Printer$ReactTemplate.pr_existential(env, sigma, param[0])), Pp$ReactTemplate.str("."));
  } else {
    var match = param[0];
    if (match) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.strbrk(" is used in hypothesis ")), Names$ReactTemplate.Id[/* print */8](match[0])), Pp$ReactTemplate.str("."));
    } else {
      return Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is used in conclusion."));
    }
  }
}

function error_clear_dependency(env, sigma, id, err) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, clear_dependency_msg(env, sigma, id, err));
}

function replacing_dependency_msg(env, sigma, id, param) {
  if (param.tag) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot change "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.strbrk(" without breaking the typing of ")), Printer$ReactTemplate.pr_existential(env, sigma, param[0])), Pp$ReactTemplate.str("."));
  } else {
    var match = param[0];
    if (match) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot change "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.strbrk(", it is used in hypothesis ")), Names$ReactTemplate.Id[/* print */8](match[0])), Pp$ReactTemplate.str("."));
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot change "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(", it is used in conclusion."));
    }
  }
}

function error_replacing_dependency(env, sigma, id, err) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, replacing_dependency_msg(env, sigma, id, err));
}

function clear_gen(fail, ids) {
  if (ids) {
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var ids$1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], Names$ReactTemplate.Id[/* Set */9][/* add */3], ids, Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
                  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                  var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                  var evdref = [sigma];
                  var match;
                  try {
                    match = Evarutil$ReactTemplate.clear_hyps_in_evi(env, evdref, Environ$ReactTemplate.named_context_val(env), concl, ids$1);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === Evarutil$ReactTemplate.ClearDependencyError) {
                      match = Curry._4(fail, env, sigma, exn[1], exn[2]);
                    } else {
                      throw exn;
                    }
                  }
                  var concl$1 = match[1];
                  var env$1 = Environ$ReactTemplate.reset_with_named_context(match[0], env);
                  return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](evdref[0]), Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                    return Evarutil$ReactTemplate.new_evar(env$1, sigma, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* true */1], concl$1);
                                  })));
                }));
  } else {
    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
  }
}

function clear(ids) {
  return clear_gen(error_clear_dependency, ids);
}

function apply_clear_request(clear_flag, dft, c) {
  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                var check_isvar = function (c) {
                  if (EConstr$ReactTemplate.isVar(sigma, c)) {
                    return 0;
                  } else {
                    return error("keep/clear modifiers apply only to hypothesis names.");
                  }
                };
                var doclear = clear_flag ? (
                    clear_flag[0] !== 0 ? (check_isvar(c), /* true */1) : /* false */0
                  ) : dft && EConstr$ReactTemplate.isVar(sigma, c);
                if (doclear) {
                  return clear(/* :: */[
                              EConstr$ReactTemplate.destVar(sigma, c),
                              /* [] */0
                            ]);
                } else {
                  return Tacticals$ReactTemplate.New[/* tclIDTAC */1];
                }
              }));
}

function move_hyp(id, dest) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var ty = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var store = Proofview$ReactTemplate.Goal[/* extra */6](gl);
                var sign = Environ$ReactTemplate.named_context_val(env);
                var sign$prime = Logic$ReactTemplate.move_hyp_in_named_context(env, sigma, id, dest, sign);
                var env$1 = Environ$ReactTemplate.reset_with_named_context(sign$prime, env);
                return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                              return Evarutil$ReactTemplate.new_evar(env$1, sigma, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], ty);
                            }));
              }));
}

function rename_hyp(repl) {
  var fold = function (accu, param) {
    if (accu) {
      var match = accu[0];
      var dsts = match[1];
      var srcs = match[0];
      var dst = param[1];
      var src = param[0];
      if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], src, srcs)) {
        return /* None */0;
      } else if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], dst, dsts)) {
        return /* None */0;
      } else {
        var srcs$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], src, srcs);
        var dsts$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], dst, dsts);
        return /* Some */[/* tuple */[
                  srcs$1,
                  dsts$1
                ]];
      }
    } else {
      return /* None */0;
    }
  };
  var init = /* Some */[/* tuple */[
      Names$ReactTemplate.Id[/* Set */9][/* empty */0],
      Names$ReactTemplate.Id[/* Set */9][/* empty */0]
    ]];
  var dom = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, init, repl);
  if (dom) {
    var match = dom[0];
    var dst = match[1];
    var src = match[0];
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                  var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                  var store = Proofview$ReactTemplate.Goal[/* extra */6](gl);
                  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                  var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                  var fold = function (accu, decl) {
                    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), accu);
                  };
                  var vars = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, Names$ReactTemplate.Id[/* Set */9][/* empty */0], hyps);
                  if (!Curry._2(Names$ReactTemplate.Id[/* Set */9][/* subset */11], src, vars)) {
                    var hyp = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* choose */22], Curry._2(Names$ReactTemplate.Id[/* Set */9][/* diff */8], src, vars));
                    throw [
                          Logic$ReactTemplate.RefinerError,
                          env,
                          sigma,
                          /* NoSuchHyp */Block.__(7, [hyp])
                        ];
                  }
                  var mods = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* diff */8], vars, src);
                  try {
                    var elt = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* choose */22], Curry._2(Names$ReactTemplate.Id[/* Set */9][/* inter */7], dst, mods));
                    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](elt), Pp$ReactTemplate.str(" is already used")));
                  }
                  catch (exn){
                    if (exn !== Caml_builtin_exceptions.not_found) {
                      throw exn;
                    }
                    
                  }
                  var make_subst = function (param) {
                    return /* tuple */[
                            param[0],
                            EConstr$ReactTemplate.mkVar(param[1])
                          ];
                  };
                  var subst = Curry._2(Util$ReactTemplate.List[/* map */10], make_subst, repl);
                  var subst$1 = function (c) {
                    return EConstr$ReactTemplate.Vars[/* replace_vars */8](subst, c);
                  };
                  var map = function (decl) {
                    return Curry._2(Context$ReactTemplate.Named[/* Declaration */0][/* map_constr */13], subst$1, Curry._2(Context$ReactTemplate.Named[/* Declaration */0][/* map_id */10], (function (id) {
                                      try {
                                        return Curry._3(Util$ReactTemplate.List[/* assoc_f */125], Names$ReactTemplate.Id[/* equal */0], id, repl);
                                      }
                                      catch (exn){
                                        if (exn === Caml_builtin_exceptions.not_found) {
                                          return id;
                                        } else {
                                          throw exn;
                                        }
                                      }
                                    }), decl));
                  };
                  var nhyps = Curry._2(Util$ReactTemplate.List[/* map */10], map, hyps);
                  var nconcl = EConstr$ReactTemplate.Vars[/* replace_vars */8](subst, concl);
                  var nctx = EConstr$ReactTemplate.val_of_named_context(nhyps);
                  var partial_arg = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
                  var instance = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                          return Util$ReactTemplate.$percent$great(partial_arg, EConstr$ReactTemplate.mkVar, param);
                        }), hyps);
                  return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                return Evarutil$ReactTemplate.new_evar_instance(nctx, sigma, nconcl, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], instance);
                              }));
                }));
  } else {
    return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Not a one-to-one name mapping"));
  }
}

function fresh_id_in_env(avoid, id, env) {
  var avoid$prime = Environ$ReactTemplate.ids_of_named_context_val(Environ$ReactTemplate.named_context_val(env));
  var avoid$1 = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* is_empty */1], avoid) ? avoid$prime : Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], avoid$prime, avoid);
  return Namegen$ReactTemplate.next_ident_away_in_goal(id, avoid$1);
}

function fresh_id(avoid, id, gl) {
  return fresh_id_in_env(avoid, id, Refiner$ReactTemplate.pf_env(gl));
}

function new_fresh_id(avoid, id, gl) {
  return fresh_id_in_env(avoid, id, Proofview$ReactTemplate.Goal[/* env */4](gl));
}

function default_id_of_sort(s) {
  if (Sorts$ReactTemplate.is_small(s)) {
    return Namegen$ReactTemplate.default_small_ident;
  } else {
    return Namegen$ReactTemplate.default_type_ident;
  }
}

function default_id(env, sigma, decl) {
  if (decl.tag) {
    return Namegen$ReactTemplate.id_of_name_using_hdchar(env, sigma, decl[1], decl[0]);
  } else {
    var dft = default_id_of_sort(Retyping$ReactTemplate.get_sort_of(/* None */0, env, sigma, decl[1]));
    var id = dft;
    var param = decl[0];
    if (param) {
      return param[0];
    } else {
      return id;
    }
  }
}

function naming_of_name(param) {
  if (param) {
    return /* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(/* None */0, param[0])]);
  } else {
    return /* NamingAvoid */Block.__(0, [Names$ReactTemplate.Id[/* Set */9][/* empty */0]]);
  }
}

function find_name(mayrepl, decl, naming, gl) {
  switch (naming.tag | 0) {
    case 0 : 
        var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
        var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
        return new_fresh_id(naming[0], default_id(env, sigma, decl), gl);
    case 1 : 
        return new_fresh_id(naming[1], naming[0], gl);
    case 2 : 
        var match = naming[0];
        var id = match[/* v */0];
        var ids_of_hyps = Tacmach$ReactTemplate.New[/* pf_ids_set_of_hyps */12](gl);
        if (!mayrepl && Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, ids_of_hyps)) {
          CErrors$ReactTemplate.user_err(match[/* loc */1], /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is already used.")));
        }
        return id;
    
  }
}

function get_next_hyp_position(env, sigma, id) {
  var aux = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var right = param[1];
        if (Names$ReactTemplate.Id[/* equal */0](Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], param[0]), id)) {
          if (right) {
            return /* MoveBefore */Block.__(1, [Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], right[0])]);
          } else {
            return /* MoveFirst */0;
          }
        } else {
          _param = right;
          continue ;
          
        }
      } else {
        return Logic$ReactTemplate.error_no_such_hypothesis(env, sigma, id);
      }
    };
  };
  return aux;
}

function get_previous_hyp_position(env, sigma, id) {
  return (function (param) {
      var _dest = /* MoveLast */1;
      var _param = param;
      while(true) {
        var param$1 = _param;
        var dest = _dest;
        if (param$1) {
          var hyp = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], param$1[0]);
          if (Names$ReactTemplate.Id[/* equal */0](hyp, id)) {
            return dest;
          } else {
            _param = param$1[1];
            _dest = /* MoveAfter */Block.__(0, [hyp]);
            continue ;
            
          }
        } else {
          return Logic$ReactTemplate.error_no_such_hypothesis(env, sigma, id);
        }
      };
    });
}

function clear_hyps2(env, sigma, ids, sign, t, cl) {
  try {
    var evdref = [Evd$ReactTemplate.clear_metas(sigma)];
    var match = Evarutil$ReactTemplate.clear_hyps2_in_evi(env, evdref, sign, t, cl, ids);
    return /* tuple */[
            match[0],
            match[1],
            match[2],
            evdref[0]
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Evarutil$ReactTemplate.ClearDependencyError) {
      return error_replacing_dependency(env, sigma, exn[1], exn[2]);
    } else {
      throw exn;
    }
  }
}

function internal_cut_gen($staropt$star, dir, replace, id, t) {
  var check = $staropt$star ? $staropt$star[0] : /* true */1;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var store = Proofview$ReactTemplate.Goal[/* extra */6](gl);
                var sign = Environ$ReactTemplate.named_context_val(env);
                var match;
                if (replace) {
                  var nexthyp = get_next_hyp_position(env, sigma, id)(EConstr$ReactTemplate.named_context_of_val(sign));
                  var match$1 = clear_hyps2(env, sigma, Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], id), sign, t, concl);
                  var sigma$1 = match$1[3];
                  var t$1 = match$1[1];
                  var sign$prime = Logic$ReactTemplate.insert_decl_in_named_context(sigma$1, /* LocalAssum */Block.__(0, [
                          id,
                          t$1
                        ]), nexthyp, match$1[0]);
                  match = /* tuple */[
                    sign$prime,
                    t$1,
                    match$1[2],
                    sigma$1
                  ];
                } else {
                  if (check && Termops$ReactTemplate.mem_named_context_val(id, sign)) {
                    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Variable "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(" is already declared.")));
                  }
                  match = /* tuple */[
                    EConstr$ReactTemplate.push_named_context_val(/* LocalAssum */Block.__(0, [
                            id,
                            t
                          ]), sign),
                    t,
                    concl,
                    sigma
                  ];
                }
                var sigma$2 = match[3];
                var concl$1 = match[2];
                var t$2 = match[1];
                var sign$prime$1 = match[0];
                var nf_t = Reductionops$ReactTemplate.nf_betaiota(env, sigma$2, t$2);
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](sigma$2), Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                  var match;
                                  if (dir) {
                                    var match$1 = Evarutil$ReactTemplate.new_evar_from_context(sign, sigma, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, nf_t);
                                    var match$2 = Evarutil$ReactTemplate.new_evar_from_context(sign$prime$1, match$1[0], /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], concl$1);
                                    match = /* tuple */[
                                      match$2[0],
                                      match$1[1],
                                      match$2[1]
                                    ];
                                  } else {
                                    var match$3 = Evarutil$ReactTemplate.new_evar_from_context(sign$prime$1, sigma, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], concl$1);
                                    var match$4 = Evarutil$ReactTemplate.new_evar_from_context(sign, match$3[0], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, nf_t);
                                    match = /* tuple */[
                                      match$4[0],
                                      match$4[1],
                                      match$3[1]
                                    ];
                                  }
                                  var term = EConstr$ReactTemplate.mkLetIn(/* tuple */[
                                        /* Name */[id],
                                        match[1],
                                        t$2,
                                        EConstr$ReactTemplate.Vars[/* subst_var */11](id, match[2])
                                      ]);
                                  return /* tuple */[
                                          match[0],
                                          term
                                        ];
                                })));
              }));
}

function internal_cut($staropt$star) {
  var check = $staropt$star ? $staropt$star[0] : /* true */1;
  var partial_arg = /* Some */[check];
  return (function (param, param$1, param$2) {
      return internal_cut_gen(partial_arg, /* true */1, param, param$1, param$2);
    });
}

function internal_cut_rev($staropt$star) {
  var check = $staropt$star ? $staropt$star[0] : /* true */1;
  var partial_arg = /* Some */[check];
  return (function (param, param$1, param$2) {
      return internal_cut_gen(partial_arg, /* false */0, param, param$1, param$2);
    });
}

function assert_before_then_gen(b, naming, t, tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var id = find_name(b, /* LocalAssum */Block.__(0, [
                        /* Anonymous */0,
                        t
                      ]), naming, gl);
                return Tacticals$ReactTemplate.New[/* tclTHENLAST */17](internal_cut(/* None */0)(b, id, t), Curry._1(tac, id));
              }));
}

function assert_before_gen(b, naming, t) {
  return assert_before_then_gen(b, naming, t, (function () {
                return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
              }));
}

function assert_before(na) {
  var partial_arg = naming_of_name(na);
  return (function (param) {
      return assert_before_gen(/* false */0, partial_arg, param);
    });
}

function assert_before_replacing(id) {
  var partial_arg = /* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(/* None */0, id)]);
  return (function (param) {
      return assert_before_gen(/* true */1, partial_arg, param);
    });
}

function assert_after_then_gen(b, naming, t, tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var id = find_name(b, /* LocalAssum */Block.__(0, [
                        /* Anonymous */0,
                        t
                      ]), naming, gl);
                return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](internal_cut_rev(/* None */0)(b, id, t), Curry._1(tac, id));
              }));
}

function assert_after_gen(b, naming, t) {
  return assert_after_then_gen(b, naming, t, (function () {
                return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
              }));
}

function assert_after(na) {
  var partial_arg = naming_of_name(na);
  return (function (param) {
      return assert_after_gen(/* false */0, partial_arg, param);
    });
}

function assert_after_replacing(id) {
  var partial_arg = /* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(/* None */0, id)]);
  return (function (param) {
      return assert_after_gen(/* true */1, partial_arg, param);
    });
}

function mk_holes(env, sigma, param) {
  if (param) {
    var match = Evarutil$ReactTemplate.new_evar(env, sigma, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, param[0]);
    var match$1 = mk_holes(env, match[0], param[1]);
    return /* tuple */[
            match$1[0],
            /* :: */[
              match[1],
              match$1[1]
            ]
          ];
  } else {
    return /* tuple */[
            sigma,
            /* [] */0
          ];
  }
}

function check_mutind(_env, sigma, _k, _cl) {
  while(true) {
    var cl = _cl;
    var k = _k;
    var env = _env;
    var match = EConstr$ReactTemplate.kind(sigma, Termops$ReactTemplate.strip_outer_cast(sigma, cl));
    switch (match.tag | 0) {
      case 6 : 
          var c1 = match[1];
          if (k === 1) {
            try {
              var match$1 = Inductiveops$ReactTemplate.find_inductive(env, sigma, c1);
              var match$2 = match$1[0];
              return /* tuple */[
                      match$2[0][0],
                      match$2[1]
                    ];
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return error("Cannot do a fixpoint on a non inductive type.");
              } else {
                throw exn;
              }
            }
          } else {
            _cl = match[2];
            _k = k - 1 | 0;
            _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                    match[0],
                    c1
                  ]), env);
            continue ;
            
          }
          break;
      case 8 : 
          _cl = match[3];
          _env = EConstr$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                  match[0],
                  match[1],
                  match[2]
                ]), env);
          continue ;
          default:
        return error("Not enough products.");
    }
  };
}

function mutual_fix(f, n, rest, j) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var match = check_mutind(env, sigma, n, concl);
                var sp = match[0];
                var match$1 = Curry._2(Util$ReactTemplate.List[/* chop */99], j, rest);
                var all = Util$ReactTemplate.$at(match$1[0], /* :: */[
                      /* tuple */[
                        f,
                        n,
                        concl
                      ],
                      match$1[1]
                    ]);
                var mk_sign = function (_sign, _param) {
                  while(true) {
                    var param = _param;
                    var sign = _sign;
                    if (param) {
                      var match = param[0];
                      var ar = match[2];
                      var f = match[0];
                      var match$1 = check_mutind(env, sigma, match[1], ar);
                      if (!Names$ReactTemplate.MutInd[/* equal */12](sp, match$1[0])) {
                        error("Fixpoints should be on the same mutual inductive declaration.");
                      }
                      if (Termops$ReactTemplate.mem_named_context_val(f, sign)) {
                        CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Logic.prim_refiner"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Name "), Names$ReactTemplate.Id[/* print */8](f)), Pp$ReactTemplate.str(" already used in the environment")));
                      }
                      _param = param[1];
                      _sign = EConstr$ReactTemplate.push_named_context_val(/* LocalAssum */Block.__(0, [
                              f,
                              ar
                            ]), sign);
                      continue ;
                      
                    } else {
                      return sign;
                    }
                  };
                };
                var nenv = Environ$ReactTemplate.reset_with_named_context(mk_sign(Environ$ReactTemplate.named_context_val(env), all), env);
                return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                              var match = mk_holes(nenv, sigma, Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi3, all));
                              var ids = Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi1, all);
                              var partial_arg = Curry._1(Util$ReactTemplate.List[/* rev */4], ids);
                              var partial_arg$1 = EConstr$ReactTemplate.Vars[/* subst_vars */10];
                              var evs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      return partial_arg$1(partial_arg, param);
                                    }), match[1]);
                              var indxs = Util$ReactTemplate.$$Array[/* of_list */10](Curry._2(Util$ReactTemplate.List[/* map */10], (function (n) {
                                          return n - 1 | 0;
                                        }), Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi2, all)));
                              var funnames = Util$ReactTemplate.$$Array[/* of_list */10](Curry._2(Util$ReactTemplate.List[/* map */10], (function (i) {
                                          return /* Name */[i];
                                        }), ids));
                              var typarray = Util$ReactTemplate.$$Array[/* of_list */10](Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi3, all));
                              var bodies = Util$ReactTemplate.$$Array[/* of_list */10](evs);
                              var oterm = EConstr$ReactTemplate.mkFix(/* tuple */[
                                    /* tuple */[
                                      indxs,
                                      0
                                    ],
                                    /* tuple */[
                                      funnames,
                                      typarray,
                                      bodies
                                    ]
                                  ]);
                              return /* tuple */[
                                      match[0],
                                      oterm
                                    ];
                            }));
              }));
}

function fix(ido, n) {
  if (ido) {
    return mutual_fix(ido[0], n, /* [] */0, 0);
  } else {
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var name = Proof_global$ReactTemplate.get_current_proof_name(/* () */0);
                  var id = new_fresh_id(Names$ReactTemplate.Id[/* Set */9][/* empty */0], name, gl);
                  return mutual_fix(id, n, /* [] */0, 0);
                }));
  }
}

function mutual_cofix(f, others, j) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var match = Curry._2(Util$ReactTemplate.List[/* chop */99], j, others);
                var all = Util$ReactTemplate.$at(match[0], /* :: */[
                      /* tuple */[
                        f,
                        concl
                      ],
                      match[1]
                    ]);
                Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                        var _env = env;
                        var sigma$1 = sigma;
                        var _cl = param[1];
                        while(true) {
                          var cl = _cl;
                          var env$1 = _env;
                          var b = Reductionops$ReactTemplate.whd_all(env$1)(sigma$1, cl);
                          var match = EConstr$ReactTemplate.kind(sigma$1, b);
                          if (match.tag === 6) {
                            _cl = match[2];
                            _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                    match[0],
                                    match[1]
                                  ]), env$1);
                            continue ;
                            
                          } else {
                            try {
                              Inductiveops$ReactTemplate.find_coinductive(env$1, sigma$1, b);
                              return /* () */0;
                            }
                            catch (exn){
                              if (exn === Caml_builtin_exceptions.not_found) {
                                return error("All methods must construct elements in coinductive types.");
                              } else {
                                throw exn;
                              }
                            }
                          }
                        };
                      }), all);
                var mk_sign = function (_sign, _param) {
                  while(true) {
                    var param = _param;
                    var sign = _sign;
                    if (param) {
                      var match = param[0];
                      var f = match[0];
                      if (Termops$ReactTemplate.mem_named_context_val(f, sign)) {
                        error("Name already used in the environment.");
                      }
                      _param = param[1];
                      _sign = EConstr$ReactTemplate.push_named_context_val(/* LocalAssum */Block.__(0, [
                              f,
                              match[1]
                            ]), sign);
                      continue ;
                      
                    } else {
                      return sign;
                    }
                  };
                };
                var nenv = Environ$ReactTemplate.reset_with_named_context(mk_sign(Environ$ReactTemplate.named_context_val(env), all), env);
                return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                              var match = Curry._1(Util$ReactTemplate.List[/* split */36], all);
                              var types = match[1];
                              var ids = match[0];
                              var match$1 = mk_holes(nenv, sigma, types);
                              var partial_arg = Curry._1(Util$ReactTemplate.List[/* rev */4], ids);
                              var partial_arg$1 = EConstr$ReactTemplate.Vars[/* subst_vars */10];
                              var evs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      return partial_arg$1(partial_arg, param);
                                    }), match$1[1]);
                              var funnames = Util$ReactTemplate.$$Array[/* of_list */10](Curry._2(Util$ReactTemplate.List[/* map */10], (function (i) {
                                          return /* Name */[i];
                                        }), ids));
                              var typarray = Util$ReactTemplate.$$Array[/* of_list */10](types);
                              var bodies = Util$ReactTemplate.$$Array[/* of_list */10](evs);
                              var oterm = EConstr$ReactTemplate.mkCoFix(/* tuple */[
                                    0,
                                    /* tuple */[
                                      funnames,
                                      typarray,
                                      bodies
                                    ]
                                  ]);
                              return /* tuple */[
                                      match$1[0],
                                      oterm
                                    ];
                            }));
              }));
}

function cofix(ido) {
  if (ido) {
    return mutual_cofix(ido[0], /* [] */0, 0);
  } else {
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var name = Proof_global$ReactTemplate.get_current_proof_name(/* () */0);
                  var id = new_fresh_id(Names$ReactTemplate.Id[/* Set */9][/* empty */0], name, gl);
                  return mutual_cofix(id, /* [] */0, 0);
                }));
  }
}

function pf_reduce_decl(redfun, where, decl, gl) {
  var redfun$prime = function (c) {
    return Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0](redfun, gl), c);
  };
  if (decl.tag) {
    var ty = decl[2];
    var b = decl[1];
    var b$prime = where !== /* InHypTypeOnly */1 ? redfun$prime(b) : b;
    var ty$prime = where !== /* InHypValueOnly */2 ? redfun$prime(ty) : ty;
    return /* LocalDef */Block.__(1, [
              decl[0],
              b$prime,
              ty$prime
            ]);
  } else {
    var id = decl[0];
    if (where === /* InHypValueOnly */2) {
      CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" has no value.")));
    }
    return /* LocalAssum */Block.__(0, [
              id,
              redfun$prime(decl[1])
            ]);
  }
}

function bind_change_occurrences(occs, param) {
  if (param) {
    return /* Some */[Redexpr$ReactTemplate.out_with_occurrences(/* tuple */[
                  occs,
                  param[0]
                ])];
  } else {
    return /* None */0;
  }
}

function bind_red_expr_occurrences(occs, nbcl, redexp) {
  var has_at_clause = function (param) {
    if (typeof param === "number") {
      return /* false */0;
    } else {
      switch (param.tag | 0) {
        case 1 : 
            var match = param[1];
            if (match) {
              return +(match[0][0] !== /* AllOccurrences */0);
            } else {
              return /* false */0;
            }
        case 5 : 
            return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                          return +(param[0] !== /* AllOccurrences */0);
                        }), param[0]);
        case 7 : 
            return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                          return +(param[0] !== /* AllOccurrences */0);
                        }), param[0]);
        default:
          return /* false */0;
      }
    }
  };
  if (occs) {
    if (typeof redexp === "number") {
      return error("Occurrences not supported for this reduction tactic.");
    } else {
      switch (redexp.tag | 0) {
        case 1 : 
            var match = redexp[1];
            if (match) {
              var match$1 = match[0];
              if (match$1[0] !== /* AllOccurrences */0) {
                return error("\"at\" clause not supported in presence of an occurrence clause.");
              } else {
                return /* Simpl */Block.__(1, [
                          redexp[0],
                          /* Some */[/* tuple */[
                              occs,
                              match$1[1]
                            ]]
                        ]);
              }
            } else {
              return error("Occurrences not supported for this reduction tactic.");
            }
            break;
        case 5 : 
            var match$2 = redexp[0];
            if (match$2) {
              var match$3 = match$2[0];
              if (match$2[1] || match$3[0] !== /* AllOccurrences */0) {
                return error("\"at\" clause not supported in presence of an occurrence clause.");
              } else {
                return /* Unfold */Block.__(5, [/* :: */[
                            /* tuple */[
                              occs,
                              match$3[1]
                            ],
                            /* [] */0
                          ]]);
              }
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "tactics.ml",
                      703,
                      1
                    ]
                  ];
            }
            break;
        case 7 : 
            var match$4 = redexp[0];
            if (match$4) {
              var match$5 = match$4[0];
              if (match$4[1] || match$5[0] !== /* AllOccurrences */0) {
                return error("\"at\" clause not supported in presence of an occurrence clause.");
              } else {
                return /* Pattern */Block.__(7, [/* :: */[
                            /* tuple */[
                              occs,
                              match$5[1]
                            ],
                            /* [] */0
                          ]]);
              }
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "tactics.ml",
                      703,
                      1
                    ]
                  ];
            }
            break;
        case 9 : 
            var match$6 = redexp[0];
            if (match$6) {
              var match$7 = match$6[0];
              if (match$7[0] !== /* AllOccurrences */0) {
                return error("\"at\" clause not supported in presence of an occurrence clause.");
              } else {
                return /* CbvVm */Block.__(9, [/* Some */[/* tuple */[
                              occs,
                              match$7[1]
                            ]]]);
              }
            } else {
              return error("Occurrences not supported for this reduction tactic.");
            }
            break;
        default:
          return error("Occurrences not supported for this reduction tactic.");
      }
    }
  } else if (nbcl > 1 && has_at_clause(redexp)) {
    return error("\"at\" clause not supported in presence of a non atomic \"in\" clause.");
  } else {
    return redexp;
  }
}

function reduct_in_concl(param) {
  var sty = param[1];
  var redfun = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return convert_concl_no_check(Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0](redfun, gl), Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl)), sty);
              }));
}

function reduct_in_hyp($staropt$star, redfun, param) {
  var where = param[1];
  var id = param[0];
  var check = $staropt$star ? $staropt$star[0] : /* false */0;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return convert_hyp(/* Some */[check], pf_reduce_decl(redfun, where, Tacmach$ReactTemplate.New[/* pf_get_hyp */14](id, gl), gl));
              }));
}

function revert_cast(r) {
  if (r[1] === /* DEFAULTcast */2) {
    return /* tuple */[
            r[0],
            /* REVERTcast */3
          ];
  } else {
    return r;
  }
}

function reduct_option($staropt$star, redfun, param) {
  var check = $staropt$star ? $staropt$star[0] : /* false */0;
  if (param) {
    return reduct_in_hyp(/* Some */[check], redfun[0], param[0]);
  } else {
    return reduct_in_concl(revert_cast(redfun));
  }
}

function pf_e_reduce_decl(redfun, where, decl, gl) {
  var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
  var redfun$1 = function (sigma, c) {
    return Curry._3(redfun, Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), sigma, c);
  };
  if (decl.tag) {
    var ty = decl[2];
    var b = decl[1];
    var match = where !== /* InHypTypeOnly */1 ? redfun$1(sigma, b) : /* tuple */[
        sigma,
        b
      ];
    var sigma$1 = match[0];
    var match$1 = where !== /* InHypValueOnly */2 ? redfun$1(sigma$1, ty) : /* tuple */[
        sigma$1,
        ty
      ];
    return /* tuple */[
            match$1[0],
            /* LocalDef */Block.__(1, [
                decl[0],
                match[1],
                match$1[1]
              ])
          ];
  } else {
    var id = decl[0];
    if (where === /* InHypValueOnly */2) {
      CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" has no value.")));
    }
    var match$2 = redfun$1(sigma, decl[1]);
    return /* tuple */[
            match$2[0],
            /* LocalAssum */Block.__(0, [
                id,
                match$2[1]
              ])
          ];
  }
}

function e_reduct_in_concl(check, param) {
  var sty = param[1];
  var redfun = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var match = Curry._3(redfun, Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), sigma, Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl));
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]), convert_concl(/* Some */[check], match[1], sty));
              }));
}

function e_reduct_option($staropt$star, redfun, param) {
  var check = $staropt$star ? $staropt$star[0] : /* false */0;
  if (param) {
    var $staropt$star$1 = /* Some */[check];
    var redfun$1 = redfun[0];
    var param$1 = param[0];
    var where = param$1[1];
    var id = param$1[0];
    var check$1 = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var match = pf_e_reduce_decl(redfun$1, where, Tacmach$ReactTemplate.New[/* pf_get_hyp */14](id, gl), gl);
                  return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]), convert_hyp(/* Some */[check$1], match[1]));
                }));
  } else {
    return e_reduct_in_concl(check, revert_cast(redfun));
  }
}

function e_pf_change_decl(redfun, where, decl, env, sigma) {
  if (decl.tag) {
    var ty = decl[2];
    var b = decl[1];
    var match = where !== /* InHypTypeOnly */1 ? Curry._4(redfun, /* true */1, env, sigma, b) : /* tuple */[
        sigma,
        b
      ];
    var sigma$1 = match[0];
    var match$1 = where !== /* InHypValueOnly */2 ? Curry._4(redfun, /* false */0, env, sigma$1, ty) : /* tuple */[
        sigma$1,
        ty
      ];
    return /* tuple */[
            match$1[0],
            /* LocalDef */Block.__(1, [
                decl[0],
                match[1],
                match$1[1]
              ])
          ];
  } else {
    var id = decl[0];
    if (where === /* InHypValueOnly */2) {
      CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" has no value.")));
    }
    var match$2 = Curry._4(redfun, /* false */0, env, sigma, decl[1]);
    return /* tuple */[
            match$2[0],
            /* LocalAssum */Block.__(0, [
                id,
                match$2[1]
              ])
          ];
  }
}

function make_change_arg(c, pats, sigma) {
  return /* tuple */[
          sigma,
          EConstr$ReactTemplate.Vars[/* replace_vars */8](Curry._1(Names$ReactTemplate.Id[/* Map */10][/* bindings */16], pats), c)
        ];
}

function check_types(env, sigma, mayneedglobalcheck, deep, newc, origc) {
  var t1 = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, newc);
  if (deep) {
    var t2 = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, origc);
    var match = Evarsolve$ReactTemplate.refresh_universes(/* None */0, /* Some */[/* true */1], /* None */0, /* Some */[/* false */0], env, sigma, t2);
    var t2$1 = match[1];
    var match$1 = Reductionops$ReactTemplate.infer_conv(/* None */0, /* Some */[/* CUMUL */1], /* None */0, env, match[0], t1, t2$1);
    var sigma$1 = match$1[0];
    if (match$1[1]) {
      return sigma$1;
    } else if (EConstr$ReactTemplate.isSort(sigma$1, Reductionops$ReactTemplate.whd_all(env)(sigma$1, t1)) && EConstr$ReactTemplate.isSort(sigma$1, Reductionops$ReactTemplate.whd_all(env)(sigma$1, t2$1))) {
      mayneedglobalcheck[0] = /* true */1;
      return sigma$1;
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["convert-check-hyp"], Pp$ReactTemplate.str("Types are incompatible."));
    }
  } else if (EConstr$ReactTemplate.isSort(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, t1))) {
    return sigma;
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["convert-check-hyp"], Pp$ReactTemplate.str("Not a type."));
  }
}

function change_and_check(cv_pb, mayneedglobalcheck, deep, t, env, sigma, c) {
  var match = Curry._1(t, sigma);
  var t$prime = match[1];
  var sigma$1 = check_types(env, match[0], mayneedglobalcheck, deep, t$prime, c);
  var match$1 = Reductionops$ReactTemplate.infer_conv(/* None */0, /* Some */[cv_pb], /* None */0, env, sigma$1, t$prime, c);
  if (!match$1[1]) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["convert-check-hyp"], Pp$ReactTemplate.str("Not convertible."));
  }
  return /* tuple */[
          match$1[0],
          t$prime
        ];
}

function change_on_subterm(cv_pb, deep, t, where, env, sigma, c) {
  var mayneedglobalcheck = [/* false */0];
  var match = where ? Tacred$ReactTemplate.e_contextually(/* false */0, where[0], (function (subst) {
            var partial_arg = Curry._1(t, subst);
            return (function (param, param$1, param$2) {
                return change_and_check(/* CONV */0, mayneedglobalcheck, /* true */1, partial_arg, param, param$1, param$2);
              });
          }), env, sigma, c) : change_and_check(cv_pb, mayneedglobalcheck, deep, Curry._1(t, Names$ReactTemplate.Id[/* Map */10][/* empty */0]), env, sigma, c);
  var c$1 = match[1];
  var sigma$1 = match[0];
  if (mayneedglobalcheck[0]) {
    try {
      Typing$ReactTemplate.unsafe_type_of(env, sigma$1, c$1);
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (Logic$ReactTemplate.catchable_exception(e)) {
        error("Replacement would lead to an ill-typed term.");
      } else {
        throw e;
      }
    }
  }
  return /* tuple */[
          sigma$1,
          c$1
        ];
}

function change_in_concl(occl, t) {
  var param = /* tuple */[
    (function (param, param$1, param$2) {
        return change_on_subterm(/* CUMUL */1, /* false */0, t, occl, param, param$1, param$2);
      }),
    /* DEFAULTcast */2
  ];
  var sty = param[1];
  var redfun = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var match = Curry._3(redfun, Proofview$ReactTemplate.Goal[/* env */4](gl), sigma, Proofview$ReactTemplate.Goal[/* concl */2](gl));
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]), convert_concl_no_check(match[1], sty));
              }));
}

function change_in_hyp(occl, t, id) {
  var redfun = function (x) {
    return (function (param, param$1, param$2) {
        return change_on_subterm(/* CONV */0, x, t, occl, param, param$1, param$2);
      });
  };
  var param = id;
  var where = param[1];
  var id$1 = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var hyp = Tacmach$ReactTemplate.New[/* pf_get_hyp */14](id$1, gl);
                var match = e_pf_change_decl(redfun, where, hyp, Proofview$ReactTemplate.Goal[/* env */4](gl), sigma);
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]), convert_hyp(/* None */0, match[1]));
              }));
}

function change(chg, c, cls) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var cls$1 = Locusops$ReactTemplate.concrete_clause_of((function () {
                        return Tacmach$ReactTemplate.New[/* pf_ids_of_hyps */11](gl);
                      }), cls);
                return Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                              if (param.tag) {
                                var occl = bind_change_occurrences(param[0], chg);
                                return change_in_concl(occl, c);
                              } else {
                                var occl$1 = bind_change_occurrences(param[1], chg);
                                var t = c;
                                var param$1 = /* Some */[/* tuple */[
                                    param[0],
                                    param[2]
                                  ]];
                                if (param$1) {
                                  return change_in_hyp(occl$1, t, param$1[0]);
                                } else {
                                  return change_in_concl(occl$1, t);
                                }
                              }
                            }), cls$1);
              }));
}

function change_concl(t) {
  return change_in_concl(/* None */0, (function (param, param$1) {
                return make_change_arg(t, param, param$1);
              }));
}

var red_in_concl = reduct_in_concl(/* tuple */[
      Tacred$ReactTemplate.red_product,
      /* REVERTcast */3
    ]);

function red_in_hyp(param) {
  return reduct_in_hyp(/* None */0, Tacred$ReactTemplate.red_product, param);
}

var partial_arg$2 = /* tuple */[
  Tacred$ReactTemplate.red_product,
  /* REVERTcast */3
];

function red_option(param) {
  return reduct_option(/* None */0, partial_arg$2, param);
}

var hnf_in_concl = reduct_in_concl(/* tuple */[
      Tacred$ReactTemplate.hnf_constr,
      /* REVERTcast */3
    ]);

function hnf_in_hyp(param) {
  return reduct_in_hyp(/* None */0, Tacred$ReactTemplate.hnf_constr, param);
}

var partial_arg$3 = /* tuple */[
  Tacred$ReactTemplate.hnf_constr,
  /* REVERTcast */3
];

function hnf_option(param) {
  return reduct_option(/* None */0, partial_arg$3, param);
}

var simpl_in_concl = reduct_in_concl(/* tuple */[
      Tacred$ReactTemplate.simpl,
      /* REVERTcast */3
    ]);

function simpl_in_hyp(param) {
  return reduct_in_hyp(/* None */0, Tacred$ReactTemplate.simpl, param);
}

var partial_arg$4 = /* tuple */[
  Tacred$ReactTemplate.simpl,
  /* REVERTcast */3
];

function simpl_option(param) {
  return reduct_option(/* None */0, partial_arg$4, param);
}

var normalise_in_concl = reduct_in_concl(/* tuple */[
      Tacred$ReactTemplate.compute,
      /* REVERTcast */3
    ]);

function normalise_in_hyp(param) {
  return reduct_in_hyp(/* None */0, Tacred$ReactTemplate.compute, param);
}

var partial_arg$5 = /* tuple */[
  Tacred$ReactTemplate.compute,
  /* REVERTcast */3
];

function normalise_option(param) {
  return reduct_option(/* None */0, partial_arg$5, param);
}

var normalise_vm_in_concl = reduct_in_concl(/* tuple */[
      Redexpr$ReactTemplate.cbv_vm,
      /* VMcast */0
    ]);

function unfold_in_concl(loccname) {
  return reduct_in_concl(/* tuple */[
              (function (param, param$1, param$2) {
                  return Tacred$ReactTemplate.unfoldn(loccname, param, param$1, param$2);
                }),
              /* REVERTcast */3
            ]);
}

function unfold_in_hyp(loccname) {
  return (function (param) {
      return reduct_in_hyp(/* None */0, (function (param, param$1, param$2) {
                    return Tacred$ReactTemplate.unfoldn(loccname, param, param$1, param$2);
                  }), param);
    });
}

function unfold_option(loccname) {
  var partial_arg_000 = function (param, param$1, param$2) {
    return Tacred$ReactTemplate.unfoldn(loccname, param, param$1, param$2);
  };
  var partial_arg = /* tuple */[
    partial_arg_000,
    /* DEFAULTcast */2
  ];
  return (function (param) {
      return reduct_option(/* None */0, partial_arg, param);
    });
}

function pattern_option(l) {
  var partial_arg_000 = function (param, param$1, param$2) {
    return Tacred$ReactTemplate.pattern_occs(l, param, param$1, param$2);
  };
  var partial_arg = /* tuple */[
    partial_arg_000,
    /* DEFAULTcast */2
  ];
  return (function (param) {
      return e_reduct_option(/* None */0, partial_arg, param);
    });
}

function reduction_clause(redexp, cl) {
  var nbcl = Curry._1(Util$ReactTemplate.List[/* length */0], cl);
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                if (param.tag) {
                  return /* tuple */[
                          /* None */0,
                          bind_red_expr_occurrences(param[0], nbcl, redexp)
                        ];
                } else {
                  return /* tuple */[
                          /* Some */[/* tuple */[
                              param[0],
                              param[2]
                            ]],
                          bind_red_expr_occurrences(param[1], nbcl, redexp)
                        ];
                }
              }), cl);
}

function reduce(redexp, cl) {
  var trace = function () {
    var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
    var env = match[1];
    var sigma = match[0];
    var pr = /* tuple */[
      Printer$ReactTemplate.pr_econstr_env,
      Printer$ReactTemplate.pr_leconstr_env,
      Printer$ReactTemplate.pr_evaluable_reference,
      Printer$ReactTemplate.pr_constr_pattern_env
    ];
    return Pp$ReactTemplate.hov(2, Pputils$ReactTemplate.pr_red_expr_env(env, sigma, pr)(Pp$ReactTemplate.str, redexp));
  };
  return Proofview$ReactTemplate.Trace[/* name_tactic */2](trace, Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                    var cl$prime = Locusops$ReactTemplate.concrete_clause_of((function () {
                            return Tacmach$ReactTemplate.New[/* pf_ids_of_hyps */11](gl);
                          }), cl);
                    var redexps = reduction_clause(redexp, cl$prime);
                    var check;
                    if (typeof redexp === "number") {
                      check = /* false */0;
                    } else {
                      switch (redexp.tag | 0) {
                        case 6 : 
                        case 7 : 
                            check = /* true */1;
                            break;
                        default:
                          check = /* false */0;
                      }
                    }
                    return Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                                  return e_reduct_option(/* Some */[check], Redexpr$ReactTemplate.reduction_of_red_expr(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl))(param[1]), param[0]);
                                }), redexps);
                  })));
}

function unfold_constr(param) {
  switch (param.tag | 0) {
    case 0 : 
        return unfold_in_concl(/* :: */[
                    /* tuple */[
                      /* AllOccurrences */0,
                      /* EvalVarRef */Block.__(0, [param[0]])
                    ],
                    /* [] */0
                  ]);
    case 1 : 
        return unfold_in_concl(/* :: */[
                    /* tuple */[
                      /* AllOccurrences */0,
                      /* EvalConstRef */Block.__(1, [param[0]])
                    ],
                    /* [] */0
                  ]);
    case 2 : 
    case 3 : 
        return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["unfold_constr"], Pp$ReactTemplate.str("Cannot unfold a non-constant."));
    
  }
}

function find_intro_names(ctxt, gl) {
  var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, acc) {
          var avoid = acc[2];
          var env = acc[0];
          var name = fresh_id(avoid, default_id(env, gl[/* sigma */1], decl), gl);
          var newenv = EConstr$ReactTemplate.push_rel(decl, env);
          return /* tuple */[
                  newenv,
                  /* :: */[
                    name,
                    acc[1]
                  ],
                  Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], name, avoid)
                ];
        }), ctxt, /* tuple */[
        Refiner$ReactTemplate.pf_env(gl),
        /* [] */0,
        Names$ReactTemplate.Id[/* Set */9][/* empty */0]
      ]);
  return Curry._1(Util$ReactTemplate.List[/* rev */4], match[1]);
}

function build_intro_tac(id, dest, tac) {
  var exit = 0;
  if (typeof dest === "number") {
    if (dest !== 0) {
      return Tacticals$ReactTemplate.New[/* tclTHEN */2](introduction(/* None */0, id), Curry._1(tac, id));
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                introduction(/* None */0, id),
                /* :: */[
                  move_hyp(id, dest),
                  /* :: */[
                    Curry._1(tac, id),
                    /* [] */0
                  ]
                ]
              ]);
  }
  
}

function intro_then_gen(name_flag, move_flag, force_flag, dep_flag, tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var env = Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var match = EConstr$ReactTemplate.kind(sigma, concl);
                var exit = 0;
                switch (match.tag | 0) {
                  case 6 : 
                      if (!dep_flag || !EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, match[2])) {
                        var name = find_name(/* false */0, /* LocalAssum */Block.__(0, [
                                match[0],
                                match[1]
                              ]), name_flag, gl);
                        return build_intro_tac(name, move_flag, tac);
                      } else {
                        exit = 1;
                      }
                      break;
                  case 8 : 
                      if (!dep_flag || !EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, match[3])) {
                        var name$1 = find_name(/* false */0, /* LocalDef */Block.__(1, [
                                match[0],
                                match[1],
                                match[2]
                              ]), name_flag, gl);
                        return build_intro_tac(name$1, move_flag, tac);
                      } else {
                        exit = 1;
                      }
                      break;
                  default:
                    exit = 1;
                }
                if (exit === 1) {
                  return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], force_flag ? Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0) : Proofview$ReactTemplate.tclZERO(/* None */0, [
                                    Logic$ReactTemplate.RefinerError,
                                    env,
                                    sigma,
                                    /* IntroNeedsProduct */0
                                  ]), Proofview$ReactTemplate.tclORELSE(Tacticals$ReactTemplate.New[/* tclTHEN */2](hnf_in_concl, intro_then_gen(name_flag, move_flag, /* false */0, dep_flag, tac)), (function (param) {
                                    var info = param[1];
                                    var e = param[0];
                                    if (e[0] === Logic$ReactTemplate.RefinerError) {
                                      if (typeof e[3] === "number") {
                                        return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("No product even after head-reduction."));
                                      } else {
                                        return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                                      }
                                    } else {
                                      return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                                    }
                                  })));
                }
                
              }));
}

function intro_gen(n, m, f, d) {
  return intro_then_gen(n, m, f, d, (function () {
                return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
              }));
}

function intro_mustbe_force(id) {
  return intro_gen(/* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(/* None */0, id)]), /* MoveLast */1, /* true */1, /* false */0);
}

function intro_using(id) {
  return intro_gen(/* NamingBasedOn */Block.__(1, [
                id,
                Names$ReactTemplate.Id[/* Set */9][/* empty */0]
              ]), /* MoveLast */1, /* false */0, /* false */0);
}

var partial_arg$6 = /* NamingAvoid */Block.__(0, [Names$ReactTemplate.Id[/* Set */9][/* empty */0]]);

function intro_then(param) {
  return intro_then_gen(partial_arg$6, /* MoveLast */1, /* false */0, /* false */0, param);
}

var intro = intro_gen(/* NamingAvoid */Block.__(0, [Names$ReactTemplate.Id[/* Set */9][/* empty */0]]), /* MoveLast */1, /* false */0, /* false */0);

var introf = intro_gen(/* NamingAvoid */Block.__(0, [Names$ReactTemplate.Id[/* Set */9][/* empty */0]]), /* MoveLast */1, /* true */1, /* false */0);

function intro_avoiding(l) {
  return intro_gen(/* NamingAvoid */Block.__(0, [l]), /* MoveLast */1, /* false */0, /* false */0);
}

function intro_move_avoid(idopt, avoid, hto) {
  if (idopt) {
    return intro_gen(/* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(/* None */0, idopt[0])]), hto, /* true */1, /* false */0);
  } else {
    return intro_gen(/* NamingAvoid */Block.__(0, [avoid]), hto, /* true */1, /* false */0);
  }
}

function intro_move(idopt, hto) {
  return intro_move_avoid(idopt, Names$ReactTemplate.Id[/* Set */9][/* empty */0], hto);
}

function intros_using(param) {
  if (param) {
    return Tacticals$ReactTemplate.New[/* tclTHEN */2](intro_using(param[0]), intros_using(param[1]));
  } else {
    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
  }
}

var intros = Tacticals$ReactTemplate.New[/* tclREPEAT */29](intro);

function intro_replacing(id) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                var next_hyp = get_next_hyp_position(env, sigma, id)(hyps);
                return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                            clear_gen(error_replacing_dependency, /* :: */[
                                  id,
                                  /* [] */0
                                ]),
                            /* :: */[
                              introduction(/* None */0, id),
                              /* :: */[
                                move_hyp(id, next_hyp),
                                /* [] */0
                              ]
                            ]
                          ]);
              }));
}

function intros_possibly_replacing(ids) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                var posl = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
                        return /* tuple */[
                                id,
                                get_next_hyp_position(env, sigma, id)(hyps)
                              ];
                      }), ids);
                return Tacticals$ReactTemplate.New[/* tclTHEN */2](Tacticals$ReactTemplate.New[/* tclMAP */20]((function (id) {
                                  return Tacticals$ReactTemplate.New[/* tclTRY */21](clear_gen(error_replacing_dependency, /* :: */[
                                                  id,
                                                  /* [] */0
                                                ]));
                                }), ids), Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                                  var id = param[0];
                                  return Tacticals$ReactTemplate.New[/* tclORELSE */11](intro_move(/* Some */[id], param[1]), intro_using(id));
                                }), posl));
              }));
}

function intros_replacing(ids) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var posl = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
                        return /* tuple */[
                                id,
                                get_next_hyp_position(env, sigma, id)(hyps)
                              ];
                      }), ids);
                return Tacticals$ReactTemplate.New[/* tclTHEN */2](clear_gen(error_replacing_dependency, ids), Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                                  return intro_move(/* Some */[param[0]], param[1]);
                                }), posl));
              }));
}

function lookup_hypothesis_as_renamed(env, sigma, ccl, param) {
  if (param.tag) {
    return Detyping$ReactTemplate.lookup_name_as_displayed(env, sigma, ccl, param[0]);
  } else {
    return Detyping$ReactTemplate.lookup_index_as_renamed(env, sigma, ccl, param[0]);
  }
}

function lookup_hypothesis_as_renamed_gen(red, h, gl) {
  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
  try {
    var _ccl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
    while(true) {
      var ccl = _ccl;
      var x = lookup_hypothesis_as_renamed(env, Tacmach$ReactTemplate.New[/* project */3](gl), ccl, h);
      if (x) {
        return x;
      } else if (red) {
        var match = Redexpr$ReactTemplate.reduction_of_red_expr(env)(/* Red */Block.__(0, [/* true */1]));
        var match$1 = Curry._3(match[0], env, Proofview$ReactTemplate.Goal[/* sigma */5](gl), ccl);
        _ccl = match$1[1];
        continue ;
        
      } else {
        return x;
      }
    };
  }
  catch (exn){
    if (exn === Tacred$ReactTemplate.Redelimination) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function is_quantified_hypothesis(id, gl) {
  var match = lookup_hypothesis_as_renamed_gen(/* false */0, /* NamedHyp */Block.__(1, [id]), gl);
  if (match) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function msg_quantified_hypothesis(param) {
  if (param.tag) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("quantified hypothesis named "), Names$ReactTemplate.Id[/* print */8](param[0]));
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_nth(param[0]), Pp$ReactTemplate.str(" non dependent hypothesis"));
  }
}

function depth_of_quantified_hypothesis(red, h, gl) {
  var match = lookup_hypothesis_as_renamed_gen(red, h, gl);
  if (match) {
    return match[0];
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["lookup_quantified_hypothesis"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No "), msg_quantified_hypothesis(h)), Pp$ReactTemplate.strbrk(" in current goal")), red ? Pp$ReactTemplate.strbrk(" even after head-reduction") : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.str(".")));
  }
}

function intros_until_gen(red, h) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var n = depth_of_quantified_hypothesis(red, h, gl);
                return Tacticals$ReactTemplate.New[/* tclDO */28](n, red ? introf : intro);
              }));
}

function intros_until(param) {
  return intros_until_gen(/* true */1, param);
}

function tclCHECKVAR(id) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                Tacmach$ReactTemplate.New[/* pf_get_hyp */14](id, gl);
                return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
              }));
}

function try_intros_until_id_check(id) {
  return Tacticals$ReactTemplate.New[/* tclORELSE */11](intros_until_gen(/* false */0, /* NamedHyp */Block.__(1, [id])), tclCHECKVAR(id));
}

function try_intros_until(tac, param) {
  if (param.tag) {
    var id = param[0];
    return Tacticals$ReactTemplate.New[/* tclTHEN */2](try_intros_until_id_check(id), Curry._1(tac, id));
  } else {
    return Tacticals$ReactTemplate.New[/* tclTHEN */2](intros_until_gen(/* true */1, /* AnonHyp */Block.__(0, [param[0]])), Tacticals$ReactTemplate.New[/* onLastHypId */42](tac));
  }
}

function intros_move(param) {
  if (param) {
    var match = param[0];
    return Tacticals$ReactTemplate.New[/* tclTHEN */2](intro_gen(/* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(/* None */0, match[0])]), match[1], /* false */0, /* false */0), intros_move(param[1]));
  } else {
    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
  }
}

function tactic_infer_flags(with_evar) {
  return /* record */[
          /* use_typeclasses : true */1,
          /* solve_unification_constraints : true */1,
          /* use_hook */Pfedit$ReactTemplate.solve_by_implicit_tactic(/* () */0),
          /* fail_evar */1 - with_evar,
          /* expand_evars : true */1
        ];
}

function onOpenInductionArg(env, sigma, tac, param) {
  var match = param[1];
  var clear_flag = param[0];
  switch (match.tag | 0) {
    case 0 : 
        var match$1 = Curry._2(match[0], env, sigma);
        return Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$1[0]), Curry._2(tac, clear_flag, /* tuple */[
                        sigma,
                        match$1[1]
                      ]));
    case 1 : 
        var id = match[0][/* v */0];
        return Tacticals$ReactTemplate.New[/* tclTHEN */2](try_intros_until_id_check(id), Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                          var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                          return Curry._2(tac, clear_flag, /* tuple */[
                                      sigma,
                                      /* tuple */[
                                        EConstr$ReactTemplate.mkVar(id),
                                        /* NoBindings */0
                                      ]
                                    ]);
                        })));
    case 2 : 
        return Tacticals$ReactTemplate.New[/* tclTHEN */2](intros_until_gen(/* true */1, /* AnonHyp */Block.__(0, [match[0]])), Tacticals$ReactTemplate.New[/* onLastHyp */43]((function (c) {
                          return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                        var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                                        return Curry._2(tac, clear_flag, /* tuple */[
                                                    sigma,
                                                    /* tuple */[
                                                      c,
                                                      /* NoBindings */0
                                                    ]
                                                  ]);
                                      }));
                        })));
    
  }
}

function onInductionArg(tac, param) {
  var match = param[1];
  var clear_flag = param[0];
  switch (match.tag | 0) {
    case 0 : 
        return Curry._2(tac, clear_flag, match[0]);
    case 1 : 
        var id = match[0][/* v */0];
        return Tacticals$ReactTemplate.New[/* tclTHEN */2](try_intros_until_id_check(id), Curry._2(tac, clear_flag, /* tuple */[
                        EConstr$ReactTemplate.mkVar(id),
                        /* NoBindings */0
                      ]));
    case 2 : 
        return Tacticals$ReactTemplate.New[/* tclTHEN */2](intros_until_gen(/* true */1, /* AnonHyp */Block.__(0, [match[0]])), Tacticals$ReactTemplate.New[/* onLastHyp */43]((function (c) {
                          return Curry._2(tac, clear_flag, /* tuple */[
                                      c,
                                      /* NoBindings */0
                                    ]);
                        })));
    
  }
}

function finish_delayed_evar_resolution(with_evars, env, sigma, f) {
  var match = Curry._2(f, env, sigma);
  var match$1 = match[1];
  var flags = tactic_infer_flags(with_evars);
  var match$2 = Unification$ReactTemplate.finish_evar_resolution(/* Some */[flags], env, match[0], /* tuple */[
        sigma,
        match$1[0]
      ]);
  return /* tuple */[
          match$2[0],
          /* tuple */[
            match$2[1],
            match$1[1]
          ]
        ];
}

function with_no_bindings(param) {
  if (param[1] !== /* NoBindings */0) {
    error("'with' clause not supported here.");
  }
  return param[0];
}

function force_destruction_arg(with_evars, env, sigma, c) {
  var f = function (param, param$1) {
    return finish_delayed_evar_resolution(with_evars, env, param, param$1);
  };
  var sigma$1 = sigma;
  var x = c;
  var match = x[1];
  switch (match.tag | 0) {
    case 0 : 
        var match$1 = Curry._2(f, sigma$1, match[0]);
        return /* tuple */[
                match$1[0],
                /* tuple */[
                  x[0],
                  /* ElimOnConstr */Block.__(0, [match$1[1]])
                ]
              ];
    case 1 : 
    case 2 : 
        return /* tuple */[
                sigma$1,
                x
              ];
    
  }
}

function cut(c) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var is_sort;
                try {
                  var typ = Typing$ReactTemplate.unsafe_type_of(env, sigma, c);
                  var typ$1 = Reductionops$ReactTemplate.whd_all(env)(sigma, typ);
                  var match = EConstr$ReactTemplate.kind(sigma, typ$1);
                  is_sort = match.tag === 4 ? /* true */1 : /* false */0;
                }
                catch (raw_e){
                  var e = Js_exn.internalToOCamlException(raw_e);
                  if (Pretype_errors$ReactTemplate.precatchable_exception(e)) {
                    is_sort = /* false */0;
                  } else {
                    throw e;
                  }
                }
                if (is_sort) {
                  var id = Namegen$ReactTemplate.next_name_away_with_default("H", /* Anonymous */0, Tacmach$ReactTemplate.New[/* pf_ids_set_of_hyps */12](gl));
                  var c$1 = c;
                  return Refine$ReactTemplate.refine(/* false */0, (function (h) {
                                var match = Evarutil$ReactTemplate.new_evar(env, h, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* true */1], EConstr$ReactTemplate.mkArrow(c$1, EConstr$ReactTemplate.Vars[/* lift */0](1, concl)));
                                var match$1 = Evarutil$ReactTemplate.new_evar(env, match[0], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, c$1);
                                var f = EConstr$ReactTemplate.mkLetIn(/* tuple */[
                                      /* Name */[id],
                                      match$1[1],
                                      c$1,
                                      EConstr$ReactTemplate.mkApp(/* tuple */[
                                            EConstr$ReactTemplate.Vars[/* lift */0](1, match[1]),
                                            /* array */[EConstr$ReactTemplate.mkRel(1)]
                                          ])
                                    ]);
                                return /* tuple */[
                                        match$1[0],
                                        f
                                      ];
                              }));
                } else {
                  return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Not a proposition or a type."));
                }
              }));
}

function error_uninstantiated_metas(t, clenv) {
  var t$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](t);
  var na = Evd$ReactTemplate.meta_name(clenv[/* evd */1], Curry._1(Util$ReactTemplate.List[/* hd */1], Curry._1(Evd$ReactTemplate.Metaset[/* elements */19], Evd$ReactTemplate.metavars_of(t$1))));
  var id = na ? na[0] : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("unnamed dependent meta."));
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot find an instance for "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(".")));
}

function check_unresolved_evars_of_metas(sigma, clenv) {
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                var b = param[1];
                if (b.tag) {
                  var match = Constr$ReactTemplate.kind(b[1][0][/* rebus */0]);
                  if (match.tag === 3) {
                    var evk = match[0][0];
                    if (Evd$ReactTemplate.is_undefined(clenv[/* evd */1], evk) && !Evd$ReactTemplate.mem(sigma, evk)) {
                      return error_uninstantiated_metas(EConstr$ReactTemplate.mkMeta(param[0]), clenv);
                    } else {
                      return /* () */0;
                    }
                  } else {
                    return /* () */0;
                  }
                } else {
                  return /* () */0;
                }
              }), Evd$ReactTemplate.meta_list(clenv[/* evd */1]));
}

function do_replace(id, param) {
  switch (param.tag | 0) {
    case 0 : 
    case 1 : 
        return /* false */0;
    case 2 : 
        if (Option$ReactTemplate.equal(Names$ReactTemplate.Id[/* equal */0], id, /* Some */[param[0][/* v */0]])) {
          return /* true */1;
        } else {
          return /* false */0;
        }
    
  }
}

function clenv_refine_in($staropt$star, with_evars, $staropt$star$1, targetid, id, sigma0, clenv, tac) {
  var sidecond_first = $staropt$star ? $staropt$star[0] : /* false */0;
  var with_classes = $staropt$star$1 ? $staropt$star$1[0] : /* true */1;
  var clenv$1 = Clenvtac$ReactTemplate.clenv_pose_dependent_evars(with_evars, clenv);
  var clenv$2 = with_classes ? /* record */[
      /* env */clenv$1[/* env */0],
      /* evd */Typeclasses$ReactTemplate.resolve_typeclasses(/* None */0, /* None */0, /* None */0, /* None */0, /* Some */[1 - with_evars], clenv$1[/* env */0], clenv$1[/* evd */1]),
      /* templval */clenv$1[/* templval */2],
      /* templtyp */clenv$1[/* templtyp */3]
    ] : clenv$1;
  var new_hyp_typ = Clenv$ReactTemplate.clenv_type(clenv$2);
  if (!with_evars) {
    check_unresolved_evars_of_metas(sigma0, clenv$2);
  }
  if (!with_evars && Termops$ReactTemplate.occur_meta(clenv$2[/* evd */1], new_hyp_typ)) {
    error_uninstantiated_metas(new_hyp_typ, clenv$2);
  }
  var new_hyp_prf = Clenv$ReactTemplate.clenv_value(clenv$2);
  var exact_tac = Proofview$ReactTemplate.V82[/* tactic */0](/* None */0, (function (param) {
          return Tacmach$ReactTemplate.refine_no_check(new_hyp_prf, param);
        }));
  var naming = /* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(/* None */0, targetid)]);
  var with_clear = do_replace(/* Some */[id], naming);
  return Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](Evd$ReactTemplate.clear_metas(clenv$2[/* evd */1])), sidecond_first ? Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](assert_before_then_gen(with_clear, naming, new_hyp_typ, tac), exact_tac) : Tacticals$ReactTemplate.New[/* tclTHENLAST */17](assert_after_then_gen(with_clear, naming, new_hyp_typ, tac), exact_tac));
}

function last_arg(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 9) {
    return Util$ReactTemplate.$$Array[/* last */34](match[1]);
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("last_arg."));
  }
}

function nth_arg(sigma, i, c) {
  if (i === -1) {
    return last_arg(sigma, c);
  } else {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 9) {
      return Caml_array.caml_array_get(match[1], i);
    } else {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("nth_arg."));
    }
  }
}

function index_of_ind_arg(sigma, t) {
  var _i = /* None */0;
  var _j = 0;
  var _t = t;
  while(true) {
    var t$1 = _t;
    var j = _j;
    var i = _i;
    var match = EConstr$ReactTemplate.kind(sigma, t$1);
    if (match.tag === 6) {
      var u = match[2];
      if (EConstr$ReactTemplate.isInd(sigma, EConstr$ReactTemplate.decompose_app(sigma, match[1])[0])) {
        _t = u;
        _j = j + 1 | 0;
        _i = /* Some */[j];
        continue ;
        
      } else {
        _t = u;
        _j = j + 1 | 0;
        continue ;
        
      }
    } else if (i) {
      return i[0];
    } else {
      return error("Could not find inductive argument of elimination scheme.");
    }
  };
}

function contract_letin_in_lam_header(sigma, _c) {
  while(true) {
    var c = _c;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 7 : 
          return EConstr$ReactTemplate.mkLambda(/* tuple */[
                      match[0],
                      match[1],
                      contract_letin_in_lam_header(sigma, match[2])
                    ]);
      case 8 : 
          _c = EConstr$ReactTemplate.Vars[/* subst1 */4](match[1], match[3]);
          continue ;
          default:
        return c;
    }
  };
}

function elimination_clause_scheme(with_evars, $staropt$star, $staropt$star$1, _, i, param, indclause) {
  var bindings = param[2];
  var elimty = param[1];
  var elim = param[0];
  var with_classes = $staropt$star ? $staropt$star[0] : /* true */1;
  var flags = $staropt$star$1 ? $staropt$star$1[0] : Unification$ReactTemplate.elim_flags(/* () */0);
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var elim$1 = contract_letin_in_lam_header(sigma, elim);
                var elimclause = Clenv$ReactTemplate.make_clenv_binding(env, sigma)(/* tuple */[
                      elim$1,
                      elimty
                    ], bindings);
                var match = EConstr$ReactTemplate.kind(sigma, nth_arg(sigma, i, elimclause[/* templval */2][/* rebus */0]));
                var indmv;
                indmv = match.tag === 2 ? match[0] : CErrors$ReactTemplate.user_err(/* None */0, /* Some */["elimination_clause"], Pp$ReactTemplate.str("The type of elimination clause is not well-formed."));
                var elimclause$prime = Clenv$ReactTemplate.clenv_fchain(/* None */0, /* Some */[flags], indmv, elimclause, indclause);
                return Clenvtac$ReactTemplate.res_pf(/* Some */[with_evars], /* Some */[with_classes], /* Some */[flags], elimclause$prime);
              }));
}

function general_elim_clause_gen(elimtac, indclause, elim) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var match = elim[/* elimbody */2];
                var elimc = match[0];
                var elimt = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, elimc);
                var match$1 = elim[/* elimindex */0];
                var i = match$1 ? match$1[0] : index_of_ind_arg(sigma, elimt);
                return Curry._4(elimtac, elim[/* elimrename */1], i, /* tuple */[
                            elimc,
                            elimt,
                            match[1]
                          ], indclause);
              }));
}

function general_elim(with_evars, clear_flag, param, elim) {
  var lbindc = param[1];
  var c = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var ct = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c);
                var t;
                try {
                  t = Tacred$ReactTemplate.reduce_to_quantified_ind(env, sigma, ct)[1];
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === CErrors$ReactTemplate.UserError) {
                    t = ct;
                  } else {
                    throw exn;
                  }
                }
                var indclause = Clenv$ReactTemplate.make_clenv_binding(env, sigma)(/* tuple */[
                      c,
                      t
                    ], lbindc);
                var sigma$1 = Evd$ReactTemplate.meta_merge(/* None */0, sigma, Evd$ReactTemplate.clear_metas(indclause[/* evd */1]));
                return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](sigma$1), Tacticals$ReactTemplate.New[/* tclTHEN */2](general_elim_clause_gen((function (eta) {
                                      return (function (param, param$1, param$2) {
                                          var param$3 = /* None */0;
                                          var param$4 = /* None */0;
                                          var param$5 = eta;
                                          var param$6 = param;
                                          var param$7 = param$1;
                                          var param$8 = param$2;
                                          return elimination_clause_scheme(with_evars, param$3, param$4, param$5, param$6, param$7, param$8);
                                        });
                                    }), indclause, elim), apply_clear_request(clear_flag, use_clear_hyp_by_default(/* () */0), c)));
              }));
}

function general_case_analysis_in_context(with_evars, clear_flag, param) {
  var lbindc = param[1];
  var c = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var t = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c);
                var match = Tacred$ReactTemplate.reduce_to_quantified_ind(env, sigma, t);
                var sort = Tacticals$ReactTemplate.New[/* elimination_sort_of_goal */50](gl);
                var mind = Util$ReactTemplate.on_snd((function (u) {
                        return EConstr$ReactTemplate.EInstance[/* kind */1](sigma, u);
                      }), match[0]);
                var match$1 = Termops$ReactTemplate.dependent(sigma, c, concl) ? Indrec$ReactTemplate.build_case_analysis_scheme(env, sigma, mind, /* true */1, sort) : Indrec$ReactTemplate.build_case_analysis_scheme_default(env, sigma, mind, sort);
                var elim = EConstr$ReactTemplate.of_constr(match$1[1]);
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$1[0]), general_elim(with_evars, clear_flag, /* tuple */[
                                c,
                                lbindc
                              ], /* record */[
                                /* elimindex : None */0,
                                /* elimrename : Some */[/* tuple */[
                                    /* false */0,
                                    Inductiveops$ReactTemplate.constructors_nrealdecls(mind[0])
                                  ]],
                                /* elimbody : tuple */[
                                  elim,
                                  /* NoBindings */0
                                ]
                              ]));
              }));
}

function general_case_analysis(with_evars, clear_flag, cx) {
  var lbindc = cx[1];
  var c = cx[0];
  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                var match = EConstr$ReactTemplate.kind(sigma, c);
                if (match.tag === 1 && !lbindc) {
                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](try_intros_until_id_check(match[0]), general_case_analysis_in_context(with_evars, clear_flag, cx));
                } else {
                  return general_case_analysis_in_context(with_evars, clear_flag, cx);
                }
              }));
}

function simplest_case(c) {
  return general_case_analysis(/* false */0, /* None */0, /* tuple */[
              c,
              /* NoBindings */0
            ]);
}

function simplest_ecase(c) {
  return general_case_analysis(/* true */1, /* None */0, /* tuple */[
              c,
              /* NoBindings */0
            ]);
}

var IsNonrec = Caml_exceptions.create("Tactics-ReactTemplate.IsNonrec");

function is_nonrec(mind) {
  return +(Global$ReactTemplate.lookup_mind(mind[0])[/* mind_finite */2] === /* BiFinite */2);
}

function find_ind_eliminator(ind, s, gl) {
  var gr = Indrec$ReactTemplate.lookup_eliminator(ind, s);
  var match = Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0]((function (eta) {
              return (function (param, param$1) {
                  return Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, eta, param, param$1);
                });
            }), gl), gr);
  var c = EConstr$ReactTemplate.of_constr(match[1]);
  return /* tuple */[
          match[0],
          c
        ];
}

function find_eliminator(c, gl) {
  var match = Tacmach$ReactTemplate.New[/* pf_reduce_to_quantified_ind */18](gl, Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, c));
  var ind = match[0][0];
  if (is_nonrec(ind)) {
    throw IsNonrec;
  }
  var match$1 = find_ind_eliminator(ind, Tacticals$ReactTemplate.New[/* elimination_sort_of_goal */50](gl), gl);
  return /* tuple */[
          match$1[0],
          /* record */[
            /* elimindex : None */0,
            /* elimrename : Some */[/* tuple */[
                /* true */1,
                Inductiveops$ReactTemplate.constructors_nrealdecls(ind)
              ]],
            /* elimbody : tuple */[
              match$1[1],
              /* NoBindings */0
            ]
          ]
        ];
}

function default_elim(with_evars, clear_flag, cx) {
  var c = cx[0];
  return Proofview$ReactTemplate.tclORELSE(Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                    var match = find_eliminator(c, gl);
                    return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]), general_elim(with_evars, clear_flag, cx, match[1]));
                  })), (function (param) {
                var e = param[0];
                if (e === IsNonrec) {
                  return general_case_analysis(with_evars, clear_flag, cx);
                } else {
                  return Proofview$ReactTemplate.tclZERO(/* Some */[param[1]], e);
                }
              }));
}

function elim_in_context(with_evars, clear_flag, c, param) {
  if (param) {
    return general_elim(with_evars, clear_flag, c, /* record */[
                /* elimindex : Some */[-1],
                /* elimrename : None */0,
                /* elimbody */param[0]
              ]);
  } else {
    return default_elim(with_evars, clear_flag, c);
  }
}

function elim(with_evars, clear_flag, cx, elim$1) {
  var lbindc = cx[1];
  var c = cx[0];
  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                var match = EConstr$ReactTemplate.kind(sigma, c);
                if (match.tag === 1 && !lbindc) {
                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](try_intros_until_id_check(match[0]), elim_in_context(with_evars, clear_flag, cx, elim$1));
                } else {
                  return elim_in_context(with_evars, clear_flag, cx, elim$1);
                }
              }));
}

function simplest_elim(c) {
  return default_elim(/* false */0, /* None */0, /* tuple */[
              c,
              /* NoBindings */0
            ]);
}

function clenv_fchain_in(id, $staropt$star, mv, elimclause, hypclause) {
  var flags = $staropt$star ? $staropt$star[0] : Unification$ReactTemplate.elim_flags(/* () */0);
  try {
    return Clenv$ReactTemplate.clenv_fchain(/* Some */[/* false */0], /* Some */[flags], mv, elimclause, hypclause);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Pretype_errors$ReactTemplate.PretypeError) {
      var match = exn[3];
      if (match.tag === 8) {
        throw [
              Pretype_errors$ReactTemplate.PretypeError,
              exn[1],
              exn[2],
              /* NoOccurrenceFound */Block.__(8, [
                  match[0],
                  /* Some */[id]
                ])
            ];
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
}

function general_elim_clause(with_evars, flags, id, c, e) {
  var elim;
  if (id) {
    var id$1 = id[0];
    var partial_arg = /* Some */[flags];
    elim = (function (param, param$1, param$2, param$3) {
        var with_evars$1 = with_evars;
        var $staropt$star = partial_arg;
        var id$2 = id$1;
        var i = param$1;
        var param$4 = param$2;
        var indclause = param$3;
        var bindings = param$4[2];
        var elimty = param$4[1];
        var elim = param$4[0];
        var flags = $staropt$star ? $staropt$star[0] : Unification$ReactTemplate.elim_flags(/* () */0);
        return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                      var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                      var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                      var elim$1 = contract_letin_in_lam_header(sigma, elim);
                      var elimclause = Clenv$ReactTemplate.make_clenv_binding(env, sigma)(/* tuple */[
                            elim$1,
                            elimty
                          ], bindings);
                      var indmv = EConstr$ReactTemplate.destMeta(sigma, nth_arg(sigma, i, elimclause[/* templval */2][/* rebus */0]));
                      var match = Curry._3(Util$ReactTemplate.List[/* remove */88], (function (prim, prim$1) {
                              return +(prim === prim$1);
                            }), indmv, Clenv$ReactTemplate.clenv_independent(elimclause));
                      var hypmv = match ? (
                          match[1] ? CErrors$ReactTemplate.user_err(/* None */0, /* Some */["elimination_clause"], Pp$ReactTemplate.str("The type of elimination clause is not well-formed.")) : match[0]
                        ) : CErrors$ReactTemplate.user_err(/* None */0, /* Some */["elimination_clause"], Pp$ReactTemplate.str("The type of elimination clause is not well-formed."));
                      var elimclause$prime = Clenv$ReactTemplate.clenv_fchain(/* None */0, /* Some */[flags], indmv, elimclause, indclause);
                      var hyp = EConstr$ReactTemplate.mkVar(id$2);
                      var hyp_typ = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, hyp);
                      var hypclause = Clenv$ReactTemplate.mk_clenv_from_env(env, sigma, /* Some */[0], /* tuple */[
                            hyp,
                            hyp_typ
                          ]);
                      var elimclause$prime$prime = clenv_fchain_in(id$2, /* Some */[flags], hypmv, elimclause$prime, hypclause);
                      var new_hyp_typ = Clenv$ReactTemplate.clenv_type(elimclause$prime$prime);
                      if (EConstr$ReactTemplate.eq_constr(sigma, hyp_typ, new_hyp_typ)) {
                        CErrors$ReactTemplate.user_err(/* None */0, /* Some */["general_rewrite_in"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Nothing to rewrite in "), Names$ReactTemplate.Id[/* print */8](id$2)), Pp$ReactTemplate.str(".")));
                      }
                      return clenv_refine_in(/* None */0, with_evars$1, /* None */0, id$2, id$2, sigma, elimclause$prime$prime, (function () {
                                    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                                  }));
                    }));
      });
  } else {
    var partial_arg$1 = /* Some */[flags];
    var partial_arg$2 = /* Some */[/* true */1];
    elim = (function (param, param$1, param$2, param$3) {
        return elimination_clause_scheme(with_evars, partial_arg$2, partial_arg$1, param, param$1, param$2, param$3);
      });
  }
  return general_elim_clause_gen(elim, c, e);
}

function make_projection(env, sigma, params, cstr, sign, elim, i, n, c, u) {
  if (elim.tag) {
    var cs_args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
            return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
          }), cstr[/* cs_args */3]);
    var decl = Curry._2(Util$ReactTemplate.List[/* nth */3], cs_args, i);
    var t = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl);
    var b;
    b = decl.tag ? decl[1] : EConstr$ReactTemplate.mkRel(i + 1 | 0);
    var branch = EConstr$ReactTemplate.it_mkLambda_or_LetIn(b, cs_args);
    if (EConstr$ReactTemplate.Vars[/* noccur_between */13](sigma, 1, (n - i | 0) - 1 | 0, t) && !EConstr$ReactTemplate.isEvar(sigma, Reductionops$ReactTemplate.whd_betaiota_stack(sigma, t)[0]) && (universal_lemma_under_conjunctions[0] || !EConstr$ReactTemplate.isRel(sigma, t))) {
      var t$1 = EConstr$ReactTemplate.Vars[/* lift */0]((i + 1 | 0) - n | 0, t);
      var abselim = Reductionops$ReactTemplate.beta_applist(sigma, /* tuple */[
            elim[0],
            Util$ReactTemplate.$at(params, /* :: */[
                  t$1,
                  /* :: */[
                    branch,
                    /* [] */0
                  ]
                ])
          ]);
      var args = Context$ReactTemplate.Rel[/* to_extended_vect */13](EConstr$ReactTemplate.mkRel, 0, sign);
      var c$1 = Reductionops$ReactTemplate.beta_applist(sigma, /* tuple */[
            abselim,
            /* :: */[
              EConstr$ReactTemplate.mkApp(/* tuple */[
                    c,
                    args
                  ]),
              /* [] */0
            ]
          ]);
      return /* Some */[/* tuple */[
                EConstr$ReactTemplate.it_mkLambda_or_LetIn(c$1, sign),
                EConstr$ReactTemplate.it_mkProd_or_LetIn(t$1, sign)
              ]];
    } else {
      return /* None */0;
    }
  } else {
    var match = Curry._2(Util$ReactTemplate.List[/* nth */3], elim[0], i);
    if (match) {
      var proj = match[0];
      var args$1 = Context$ReactTemplate.Rel[/* to_extended_vect */13](EConstr$ReactTemplate.mkRel, 0, sign);
      var proj$1 = Environ$ReactTemplate.is_projection(proj, env) ? EConstr$ReactTemplate.mkProj(/* tuple */[
              Names$ReactTemplate.Projection[/* make */0](proj, /* false */0),
              EConstr$ReactTemplate.mkApp(/* tuple */[
                    c,
                    args$1
                  ])
            ]) : EConstr$ReactTemplate.mkApp(/* tuple */[
              EConstr$ReactTemplate.mkConstU(/* tuple */[
                    proj,
                    u
                  ]),
              Util$ReactTemplate.$$Array[/* append */3](Util$ReactTemplate.$$Array[/* of_list */10](params), /* array */[EConstr$ReactTemplate.mkApp(/* tuple */[
                          c,
                          args$1
                        ])])
            ]);
      var app = EConstr$ReactTemplate.it_mkLambda_or_LetIn(proj$1, sign);
      var t$2 = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, app);
      return /* Some */[/* tuple */[
                app,
                t$2
              ]];
    } else {
      return /* None */0;
    }
  }
}

function descend_in_conjunctions(avoid, tac, param, c) {
  var info = param[1];
  var err = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                try {
                  var t = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c);
                  var match = Tacred$ReactTemplate.reduce_to_quantified_ind(env, sigma, t);
                  var match$1 = match[0];
                  var u = match$1[1];
                  var ind = match$1[0];
                  var match$2 = EConstr$ReactTemplate.decompose_prod_assum(sigma, match[1]);
                  var ccl = match$2[1];
                  var sign = match$2[0];
                  var match$3 = Hipattern$ReactTemplate.match_with_tuple(sigma, ccl);
                  if (match$3) {
                    var isrec = match$3[0][2];
                    var n = Caml_array.caml_array_get(Inductiveops$ReactTemplate.constructors_nrealargs(ind), 0);
                    var sort = Tacticals$ReactTemplate.New[/* elimination_sort_of_goal */50](gl);
                    var match$4 = Inductiveops$ReactTemplate.find_rectype(env, sigma, ccl);
                    var indf = match$4[0];
                    var match$5 = Inductiveops$ReactTemplate.dest_ind_family(indf);
                    var params = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, match$5[1]);
                    var cstr = Caml_array.caml_array_get(Inductiveops$ReactTemplate.get_constructors(env, indf), 0);
                    var elim;
                    try {
                      elim = /* DefinedRecord */Block.__(0, [Recordops$ReactTemplate.lookup_projections(ind)]);
                    }
                    catch (exn){
                      if (exn === Caml_builtin_exceptions.not_found) {
                        var u$1 = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, u);
                        var match$6 = Indrec$ReactTemplate.build_case_analysis_scheme(env, sigma, /* tuple */[
                              ind,
                              u$1
                            ], /* false */0, sort);
                        var elim$1 = EConstr$ReactTemplate.of_constr(match$6[1]);
                        elim = /* NotADefinedRecordUseScheme */Block.__(1, [elim$1]);
                      } else {
                        throw exn;
                      }
                    }
                    return Tacticals$ReactTemplate.New[/* tclORELSE0 */10](Tacticals$ReactTemplate.New[/* tclFIRST */23](Curry._2(Util$ReactTemplate.List[/* init */46], n, (function (i) {
                                          return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                                        var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                                                        var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                                                        var match = make_projection(env, sigma, params, cstr, sign, elim, i, n, c, u);
                                                        if (match) {
                                                          var match$1 = match[0];
                                                          return Tacticals$ReactTemplate.New[/* tclTHENS */18](assert_before_gen(/* false */0, /* NamingAvoid */Block.__(0, [avoid]), match$1[1]), /* :: */[
                                                                      Proofview$ReactTemplate.V82[/* tactic */0](/* None */0, Tacmach$ReactTemplate.refine(match$1[0])),
                                                                      /* :: */[
                                                                        Tacticals$ReactTemplate.New[/* onLastHypId */42](Curry._1(tac, 1 - isrec)),
                                                                        /* [] */0
                                                                      ]
                                                                    ]);
                                                        } else {
                                                          return Tacticals$ReactTemplate.New[/* tclFAIL */3](0, Pp$ReactTemplate.mt(/* () */0));
                                                        }
                                                      }));
                                        }))), Proofview$ReactTemplate.tclZERO(/* Some */[info], err));
                  } else {
                    return Proofview$ReactTemplate.tclZERO(/* Some */[info], err);
                  }
                }
                catch (raw_exn){
                  var exn$1 = Js_exn.internalToOCamlException(raw_exn);
                  if (exn$1[0] === Logic$ReactTemplate.RefinerError) {
                    return Proofview$ReactTemplate.tclZERO(/* Some */[info], err);
                  } else if (exn$1[0] === CErrors$ReactTemplate.UserError) {
                    return Proofview$ReactTemplate.tclZERO(/* Some */[info], err);
                  } else {
                    throw exn$1;
                  }
                }
              }));
}

function tclORELSEOPT(t, k) {
  return Proofview$ReactTemplate.tclORELSE(t, (function (e) {
                var match = Curry._1(k, e);
                if (match) {
                  return match[0];
                } else {
                  return Proofview$ReactTemplate.tclZERO(/* Some */[e[1]], e[0]);
                }
              }));
}

function general_apply(with_delta, with_destruct, with_evars, clear_flag, param) {
  var loc = param[/* loc */1];
  var match = param[/* v */0];
  var lbind = match[1];
  var c = match[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var flags = with_delta ? Unification$ReactTemplate.default_unify_flags(/* () */0) : Unification$ReactTemplate.default_no_delta_unify_flags(/* () */0);
                var concl_nprod = Termops$ReactTemplate.nb_prod_modulo_zeta(sigma, concl);
                var try_main_apply = function (with_destruct, c) {
                  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                                var thm_ty0 = Reductionops$ReactTemplate.nf_betaiota(env, sigma, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c));
                                var try_apply = function (thm_ty, nprod) {
                                  try {
                                    var n = Termops$ReactTemplate.nb_prod_modulo_zeta(sigma, thm_ty) - nprod | 0;
                                    if (n < 0) {
                                      error("Applied theorem does not have enough premises.");
                                    }
                                    var clause = Clenv$ReactTemplate.make_clenv_binding_apply(env, sigma, /* Some */[n])(/* tuple */[
                                          c,
                                          thm_ty
                                        ], lbind);
                                    return Clenvtac$ReactTemplate.res_pf(/* Some */[with_evars], /* None */0, /* Some */[flags], clause);
                                  }
                                  catch (raw_exn){
                                    var exn = Js_exn.internalToOCamlException(raw_exn);
                                    if (Logic$ReactTemplate.catchable_exception(exn)) {
                                      return Proofview$ReactTemplate.tclZERO(/* None */0, exn);
                                    } else {
                                      throw exn;
                                    }
                                  }
                                };
                                var try_red_apply = function (thm_ty, param) {
                                  var info = param[1];
                                  var exn0 = param[0];
                                  try {
                                    var red_thm = Tacred$ReactTemplate.try_red_product(env, sigma, thm_ty);
                                    return tclORELSEOPT(try_apply(red_thm, concl_nprod), (function (param) {
                                                  var e = param[0];
                                                  var exit = 0;
                                                  if (e[0] === Pretype_errors$ReactTemplate.PretypeError) {
                                                    exit = 1;
                                                  } else if (e[0] === Logic$ReactTemplate.RefinerError) {
                                                    exit = 1;
                                                  } else if (e[0] === CErrors$ReactTemplate.UserError) {
                                                    exit = 1;
                                                  } else if (e[0] === Caml_builtin_exceptions.failure) {
                                                    exit = 1;
                                                  } else {
                                                    return /* None */0;
                                                  }
                                                  if (exit === 1) {
                                                    return /* Some */[try_red_apply(red_thm, /* tuple */[
                                                                  exn0,
                                                                  param[1]
                                                                ])];
                                                  }
                                                  
                                                }));
                                  }
                                  catch (exn){
                                    if (exn === Tacred$ReactTemplate.Redelimination) {
                                      var info$1 = Option$ReactTemplate.cata((function (loc) {
                                              return Loc$ReactTemplate.add_loc(info, loc);
                                            }), info, loc);
                                      var tac = with_destruct ? descend_in_conjunctions(Names$ReactTemplate.Id[/* Set */9][/* empty */0], (function (b, id) {
                                                return Tacticals$ReactTemplate.New[/* tclTHEN */2](try_main_apply(b, EConstr$ReactTemplate.mkVar(id)), clear(/* :: */[
                                                                id,
                                                                /* [] */0
                                                              ]));
                                              }), /* tuple */[
                                              exn0,
                                              info$1
                                            ], c) : Proofview$ReactTemplate.tclZERO(/* Some */[info$1], exn0);
                                      if (concl_nprod !== 0) {
                                        return tclORELSEOPT(try_apply(thm_ty, 0), (function (param) {
                                                      var e = param[0];
                                                      if (e[0] === Pretype_errors$ReactTemplate.PretypeError) {
                                                        return /* Some */[tac];
                                                      } else if (e[0] === Logic$ReactTemplate.RefinerError) {
                                                        return /* Some */[tac];
                                                      } else if (e[0] === CErrors$ReactTemplate.UserError) {
                                                        return /* Some */[tac];
                                                      } else if (e[0] === Caml_builtin_exceptions.failure) {
                                                        return /* Some */[tac];
                                                      } else {
                                                        return /* None */0;
                                                      }
                                                    }));
                                      } else {
                                        return tac;
                                      }
                                    } else {
                                      throw exn;
                                    }
                                  }
                                };
                                return tclORELSEOPT(try_apply(thm_ty0, concl_nprod), (function (param) {
                                              var e = param[0];
                                              var exit = 0;
                                              if (e[0] === Pretype_errors$ReactTemplate.PretypeError) {
                                                exit = 1;
                                              } else if (e[0] === Logic$ReactTemplate.RefinerError) {
                                                exit = 1;
                                              } else if (e[0] === CErrors$ReactTemplate.UserError) {
                                                exit = 1;
                                              } else if (e[0] === Caml_builtin_exceptions.failure) {
                                                exit = 1;
                                              } else {
                                                return /* None */0;
                                              }
                                              if (exit === 1) {
                                                return /* Some */[try_red_apply(thm_ty0, /* tuple */[
                                                              e,
                                                              param[1]
                                                            ])];
                                              }
                                              
                                            }));
                              }));
                };
                return Tacticals$ReactTemplate.New[/* tclTHEN */2](try_main_apply(with_destruct, c), apply_clear_request(clear_flag, use_clear_hyp_by_default(/* () */0), c));
              }));
}

function apply_with_bindings_gen(b, e, param) {
  if (param) {
    var cbl = param[1];
    var match = param[0];
    var cb = match[1];
    var k = match[0];
    if (cbl) {
      return Tacticals$ReactTemplate.New[/* tclTHENLAST */17](general_apply(b, b, e, k, cb), apply_with_bindings_gen(b, e, cbl));
    } else {
      return general_apply(b, b, e, k, cb);
    }
  } else {
    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
  }
}

function apply_with_delayed_bindings_gen(b, e, l) {
  var one = function (k, param) {
    var loc = param[/* loc */1];
    var f = param[/* v */0];
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                  var match = Curry._2(f, env, sigma);
                  return Tacticals$ReactTemplate.New[/* tclWITHHOLES */35](e, general_apply(b, b, e, k, CAst$ReactTemplate.make(loc, match[1])), match[0]);
                }));
  };
  var aux = function (param) {
    if (param) {
      var cbl = param[1];
      var match = param[0];
      var f = match[1];
      var k = match[0];
      if (cbl) {
        return Tacticals$ReactTemplate.New[/* tclTHENLAST */17](one(k, f), aux(cbl));
      } else {
        return one(k, f);
      }
    } else {
      return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
    }
  };
  return aux(l);
}

function apply_with_bindings(cb) {
  return apply_with_bindings_gen(/* false */0, /* false */0, /* :: */[
              /* tuple */[
                /* None */0,
                CAst$ReactTemplate.make(/* None */0, cb)
              ],
              /* [] */0
            ]);
}

function eapply_with_bindings(cb) {
  return apply_with_bindings_gen(/* false */0, /* true */1, /* :: */[
              /* tuple */[
                /* None */0,
                CAst$ReactTemplate.make(/* None */0, cb)
              ],
              /* [] */0
            ]);
}

function apply(c) {
  return apply_with_bindings_gen(/* false */0, /* false */0, /* :: */[
              /* tuple */[
                /* None */0,
                CAst$ReactTemplate.make(/* None */0, /* tuple */[
                      c,
                      /* NoBindings */0
                    ])
              ],
              /* [] */0
            ]);
}

function eapply(c) {
  return apply_with_bindings_gen(/* false */0, /* true */1, /* :: */[
              /* tuple */[
                /* None */0,
                CAst$ReactTemplate.make(/* None */0, /* tuple */[
                      c,
                      /* NoBindings */0
                    ])
              ],
              /* [] */0
            ]);
}

function find_matching_clause(unifier, clause) {
  var find = function (clause) {
    try {
      return Curry._1(unifier, clause);
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (Logic$ReactTemplate.catchable_exception(e)) {
        try {
          return find(Clenv$ReactTemplate.clenv_push_prod(clause));
        }
        catch (exn){
          if (exn === Clenv$ReactTemplate.NotExtensibleClause) {
            return Pervasives.failwith("Cannot apply");
          } else {
            throw exn;
          }
        }
      } else {
        throw e;
      }
    }
  };
  return find(clause);
}

var UnableToApply = Caml_exceptions.create("Tactics-ReactTemplate.UnableToApply");

function apply_in_once_main(flags, innerclause, env, sigma, param) {
  var d = param[1];
  var loc = param[0];
  var thm = Reductionops$ReactTemplate.nf_betaiota(env, sigma, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, d));
  var aux = function (clause) {
    try {
      var flags$1 = flags;
      var innerclause$1 = innerclause;
      var clause$1 = clause;
      var ordered_metas = Curry._1(Util$ReactTemplate.List[/* rev */4], Clenv$ReactTemplate.clenv_independent(clause$1));
      if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], ordered_metas)) {
        throw UnableToApply;
      }
      var f = function (mv) {
        try {
          var partial_arg = /* Some */[flags$1];
          var partial_arg$1 = /* Some */[/* false */0];
          return /* Some */[find_matching_clause((function (param) {
                          return Clenv$ReactTemplate.clenv_fchain(partial_arg$1, partial_arg, mv, clause$1, param);
                        }), innerclause$1)];
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn[0] === Caml_builtin_exceptions.failure) {
            return /* None */0;
          } else {
            throw exn;
          }
        }
      };
      try {
        return Curry._2(Util$ReactTemplate.List[/* find_map */94], f, ordered_metas);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          throw UnableToApply;
        } else {
          throw exn;
        }
      }
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (CErrors$ReactTemplate.noncritical(e)) {
        var e$prime = CErrors$ReactTemplate.push(e);
        try {
          return aux(Clenv$ReactTemplate.clenv_push_prod(clause));
        }
        catch (exn$1){
          if (exn$1 === Clenv$ReactTemplate.NotExtensibleClause) {
            if (e === UnableToApply) {
              var loc$1 = loc;
              var env$1 = env;
              var sigma$1 = sigma;
              var thm$1 = thm;
              var innerclause$2 = innerclause;
              return CErrors$ReactTemplate.user_err(loc$1, /* None */0, Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unable to apply lemma of type"), Pp$ReactTemplate.brk(/* tuple */[
                                                              1,
                                                              1
                                                            ])), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_leconstr_env(env$1, sigma$1, thm$1))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("on hypothesis of type")), Pp$ReactTemplate.brk(/* tuple */[
                                              1,
                                              1
                                            ])), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_leconstr_env(innerclause$2[/* env */0], innerclause$2[/* evd */1], Clenv$ReactTemplate.clenv_type(innerclause$2)))), Pp$ReactTemplate.str("."))));
            } else {
              return Util$ReactTemplate.iraise(e$prime);
            }
          } else {
            throw exn$1;
          }
        }
      } else {
        throw e;
      }
    }
  };
  return aux(Clenv$ReactTemplate.make_clenv_binding(env, sigma)(/* tuple */[
                  d,
                  thm
                ], param[2]));
}

function apply_in_once(sidecond_first, with_delta, with_destruct, with_evars, naming, id, param, tac) {
  var match = param[1];
  var loc = match[/* loc */1];
  var match$1 = match[/* v */0];
  var lbind = match$1[1];
  var d = match$1[0];
  var clear_flag = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var flags = with_delta ? Unification$ReactTemplate.default_unify_flags(/* () */0) : Unification$ReactTemplate.default_no_delta_unify_flags(/* () */0);
                var t$prime = Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](id, gl);
                var innerclause = Clenv$ReactTemplate.mk_clenv_from_env(env, sigma, /* Some */[0], /* tuple */[
                      EConstr$ReactTemplate.mkVar(id),
                      t$prime
                    ]);
                var targetid = find_name(/* true */1, /* LocalAssum */Block.__(0, [
                        /* Anonymous */0,
                        t$prime
                      ]), naming, gl);
                var aux = function (idstoclear, with_destruct, c) {
                  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                                try {
                                  var clause = apply_in_once_main(flags, innerclause, env, sigma, /* tuple */[
                                        loc,
                                        c,
                                        lbind
                                      ]);
                                  return clenv_refine_in(/* Some */[sidecond_first], with_evars, /* None */0, targetid, id, sigma, clause, (function (id) {
                                                return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                                            apply_clear_request(clear_flag, /* false */0, c),
                                                            /* :: */[
                                                              clear(idstoclear),
                                                              /* :: */[
                                                                Curry._1(tac, id),
                                                                /* [] */0
                                                              ]
                                                            ]
                                                          ]);
                                              }));
                                }
                                catch (raw_e){
                                  var e = Js_exn.internalToOCamlException(raw_e);
                                  if (with_destruct && CErrors$ReactTemplate.noncritical(e)) {
                                    var match = CErrors$ReactTemplate.push(e);
                                    return descend_in_conjunctions(Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], targetid), (function (b, id) {
                                                  return aux(/* :: */[
                                                              id,
                                                              idstoclear
                                                            ], b, EConstr$ReactTemplate.mkVar(id));
                                                }), /* tuple */[
                                                match[0],
                                                match[1]
                                              ], c);
                                  } else {
                                    throw e;
                                  }
                                }
                              }));
                };
                return aux(/* [] */0, with_destruct, d);
              }));
}

function apply_in_delayed_once(sidecond_first, with_delta, with_destruct, with_evars, naming, id, param, tac) {
  var match = param[1];
  var loc = match[/* loc */1];
  var f = match[/* v */0];
  var clear_flag = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var match = Curry._2(f, env, sigma);
                return Tacticals$ReactTemplate.New[/* tclWITHHOLES */35](with_evars, apply_in_once(sidecond_first, with_delta, with_destruct, with_evars, naming, id, /* tuple */[
                                clear_flag,
                                CAst$ReactTemplate.make(loc, match[1])
                              ], tac), match[0]);
              }));
}

function cut_and_apply(c) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var match = EConstr$ReactTemplate.kind(sigma, Tacmach$ReactTemplate.New[/* pf_hnf_constr */19](gl, Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, c)));
                if (match.tag === 6) {
                  var c2 = match[2];
                  var c1 = match[1];
                  if (EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, c2)) {
                    var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                    var env = Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl);
                    return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                  var typ = EConstr$ReactTemplate.mkProd(/* tuple */[
                                        /* Anonymous */0,
                                        c2,
                                        concl
                                      ]);
                                  var match = Evarutil$ReactTemplate.new_evar(env, sigma, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, typ);
                                  var match$1 = Evarutil$ReactTemplate.new_evar(env, match[0], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, c1);
                                  return /* tuple */[
                                          match$1[0],
                                          EConstr$ReactTemplate.mkApp(/* tuple */[
                                                match[1],
                                                /* array */[EConstr$ReactTemplate.mkApp(/* tuple */[
                                                        c,
                                                        /* array */[match$1[1]]
                                                      ])]
                                              ])
                                        ];
                                }));
                  } else {
                    return error("lapply needs a non-dependent product.");
                  }
                } else {
                  return error("lapply needs a non-dependent product.");
                }
              }));
}

function exact_no_check(c) {
  return Refine$ReactTemplate.refine(/* false */0, (function (h) {
                return /* tuple */[
                        h,
                        c
                      ];
              }));
}

function exact_check(c) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var match = Typing$ReactTemplate.type_of(/* None */0, env, sigma, c);
                return Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]), Tacticals$ReactTemplate.New[/* tclTHEN */2](convert_leq(match[1], concl), exact_no_check(c)));
              }));
}

function vm_cast_no_check(c) {
  var cast = /* VMcast */0;
  var c$1 = c;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                return exact_no_check(EConstr$ReactTemplate.mkCast(/* tuple */[
                                c$1,
                                cast,
                                concl
                              ]));
              }));
}

function exact_proof(c) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                              var match = Constrintern$ReactTemplate.interp_casted_constr(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), sigma, /* None */0, c, Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl));
                              var sigma$1 = Evd$ReactTemplate.merge_universe_context(sigma, match[1]);
                              return /* tuple */[
                                      sigma$1,
                                      match[0]
                                    ];
                            }));
              }));
}

function assumption_tac(gl) {
  var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
  var gl$1 = gl;
  var _only_eq = /* true */1;
  var _param = hyps;
  while(true) {
    var param = _param;
    var only_eq = _only_eq;
    if (param) {
      var decl = param[0];
      var t = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl);
      var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl$1);
      var sigma = Tacmach$ReactTemplate.New[/* project */3](gl$1);
      var match;
      if (only_eq) {
        match = /* tuple */[
          sigma,
          EConstr$ReactTemplate.eq_constr(sigma, t, concl)
        ];
      } else {
        var env = Proofview$ReactTemplate.Goal[/* env */4](gl$1);
        match = Reductionops$ReactTemplate.infer_conv(/* None */0, /* None */0, /* None */0, env, sigma, t, concl);
      }
      if (match[1]) {
        return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]), exact_no_check(EConstr$ReactTemplate.mkVar(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl))));
      } else {
        _param = param[1];
        continue ;
        
      }
    } else if (only_eq) {
      var hyps$1 = Proofview$ReactTemplate.Goal[/* hyps */3](gl$1);
      _param = hyps$1;
      _only_eq = /* false */0;
      continue ;
      
    } else {
      return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("No such assumption."));
    }
  };
}

var assumption = Proofview$ReactTemplate.Goal[/* enter */9](assumption_tac);

function on_the_bodies(l) {
  if (l) {
    if (l[1]) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" depends on the bodies of "), Pp$ReactTemplate.pr_sequence(Names$ReactTemplate.Id[/* print */8], l));
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" depends on the body of "), Names$ReactTemplate.Id[/* print */8](l[0]));
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "tactics.ml",
            1954,
            8
          ]
        ];
  }
}

var DependsOnBody = Caml_exceptions.create("Tactics-ReactTemplate.DependsOnBody");

function check_is_type(env, sigma, ty) {
  var evdref = [sigma];
  try {
    Typing$ReactTemplate.e_sort_of(env, evdref, ty);
    return evdref[0];
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      throw [
            DependsOnBody,
            /* None */0
          ];
    } else {
      throw e;
    }
  }
}

function check_decl(env, sigma, decl) {
  var ty = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl);
  var evdref = [sigma];
  try {
    Typing$ReactTemplate.e_sort_of(env, evdref, ty);
    if (decl.tag) {
      Typing$ReactTemplate.e_check(env, evdref, decl[1], ty);
    }
    return evdref[0];
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl);
      throw [
            DependsOnBody,
            /* Some */[id]
          ];
    } else {
      throw e;
    }
  }
}

function clear_body(ids) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var ctx = EConstr$ReactTemplate.named_context(env);
                var map = function (decl) {
                  if (decl.tag) {
                    var id = decl[0];
                    if (Curry._3(Util$ReactTemplate.List[/* mem_f */47], Names$ReactTemplate.Id[/* equal */0], id, ids)) {
                      return /* LocalAssum */Block.__(0, [
                                id,
                                decl[2]
                              ]);
                    } else {
                      return decl;
                    }
                  } else {
                    var id$1 = decl[0];
                    if (Curry._3(Util$ReactTemplate.List[/* mem_f */47], Names$ReactTemplate.Id[/* equal */0], id$1, ids)) {
                      CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Hypothesis "), Names$ReactTemplate.Id[/* print */8](id$1)), Pp$ReactTemplate.str(" is not a local definition")));
                    }
                    return decl;
                  }
                };
                var ctx$1 = Curry._2(Util$ReactTemplate.List[/* map */10], map, ctx);
                var base_env = Environ$ReactTemplate.reset_context(env);
                var env$1 = EConstr$ReactTemplate.push_named_context(ctx$1, base_env);
                var check;
                try {
                  var check$1 = function (param, decl) {
                    var seen = param[2];
                    var sigma = param[1];
                    var env = param[0];
                    var sigma$1 = !seen || !Curry._2(Util$ReactTemplate.List[/* exists */21], (function (id) {
                            return Termops$ReactTemplate.occur_var_in_decl(env, sigma, id, decl);
                          }), ids) ? sigma : check_decl(env, sigma, decl);
                    var seen$1 = seen || Curry._3(Util$ReactTemplate.List[/* mem_f */47], Names$ReactTemplate.Id[/* equal */0], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), ids);
                    return /* tuple */[
                            EConstr$ReactTemplate.push_named(decl, env),
                            sigma$1,
                            seen$1
                          ];
                  };
                  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], check$1, /* tuple */[
                        base_env,
                        sigma,
                        /* false */0
                      ], Curry._1(Util$ReactTemplate.List[/* rev */4], ctx$1));
                  var sigma$1 = match[1];
                  var env$2 = match[0];
                  check = Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](Curry._2(Util$ReactTemplate.List[/* exists */21], (function (id) {
                              return Termops$ReactTemplate.occur_var(env$2, sigma$1, id, concl);
                            }), ids) ? check_is_type(env$2, sigma$1, concl) : sigma$1);
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === DependsOnBody) {
                    var where = exn[1];
                    var msg = where ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Hypothesis "), Names$ReactTemplate.Id[/* print */8](where[0])), on_the_bodies(ids)) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Conclusion"), on_the_bodies(ids));
                    check = Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, msg);
                  } else {
                    throw exn;
                  }
                }
                return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], check, Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                  return Evarutil$ReactTemplate.new_evar(env$1, sigma, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* true */1], concl);
                                })));
              }));
}

function clear_wildcards(ids) {
  return Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                return clear(/* :: */[
                            param[/* v */0],
                            /* [] */0
                          ]);
              }), ids);
}

function intros_clearing(param) {
  if (param) {
    if (param[0] !== 0) {
      return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                  intro,
                  /* :: */[
                    Tacticals$ReactTemplate.New[/* onLastHypId */42]((function (id) {
                            return clear(/* :: */[
                                        id,
                                        /* [] */0
                                      ]);
                          })),
                    /* :: */[
                      intros_clearing(param[1]),
                      /* [] */0
                    ]
                  ]
                ]);
    } else {
      return Tacticals$ReactTemplate.New[/* tclTHEN */2](intro, intros_clearing(param[1]));
    }
  } else {
    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
  }
}

function keep(hyps) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclENV, (function (env) {
                              var ccl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                              var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                              var match = Environ$ReactTemplate.fold_named_context_reverse((function (param, decl) {
                                      var keep = param[1];
                                      var clear = param[0];
                                      var decl$1 = Termops$ReactTemplate.map_named_decl(EConstr$ReactTemplate.of_constr, decl);
                                      var hyp = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl$1);
                                      if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], hyp, hyps) || Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                                                return Termops$ReactTemplate.occur_var_in_decl(env, sigma, hyp, param);
                                              }), keep) || Termops$ReactTemplate.occur_var(env, sigma, hyp, ccl)) {
                                        return /* tuple */[
                                                clear,
                                                /* :: */[
                                                  decl$1,
                                                  keep
                                                ]
                                              ];
                                      } else {
                                        return /* tuple */[
                                                /* :: */[
                                                  hyp,
                                                  clear
                                                ],
                                                keep
                                              ];
                                      }
                                    }), /* tuple */[
                                    /* [] */0,
                                    /* [] */0
                                  ], Proofview$ReactTemplate.Goal[/* env */4](gl));
                              return clear(match[0]);
                            }));
              }));
}

function apply_type(typecheck, newcl, args) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var store = Proofview$ReactTemplate.Goal[/* extra */6](gl);
                return Refine$ReactTemplate.refine(typecheck, (function (sigma) {
                              var newcl$1 = Reductionops$ReactTemplate.nf_betaiota(env, sigma, newcl);
                              var match = Evarutil$ReactTemplate.new_evar(env, sigma, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], newcl$1);
                              return /* tuple */[
                                      match[0],
                                      EConstr$ReactTemplate.applist(/* tuple */[
                                            match[1],
                                            args
                                          ])
                                    ];
                            }));
              }));
}

function bring_hyps(hyps) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], hyps)) {
    return Tacticals$ReactTemplate.New[/* tclIDTAC */1];
  } else {
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                  var store = Proofview$ReactTemplate.Goal[/* extra */6](gl);
                  var concl = Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
                  var newcl = Curry._3(Util$ReactTemplate.List[/* fold_right */14], EConstr$ReactTemplate.mkNamedProd_or_LetIn, hyps, concl);
                  var args = Util$ReactTemplate.$$Array[/* of_list */10](Context$ReactTemplate.Named[/* to_instance */11](EConstr$ReactTemplate.mkVar, hyps));
                  return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                var match = Evarutil$ReactTemplate.new_evar(env, sigma, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], newcl);
                                return /* tuple */[
                                        match[0],
                                        EConstr$ReactTemplate.mkApp(/* tuple */[
                                              match[1],
                                              args
                                            ])
                                      ];
                              }));
                }));
  }
}

function revert(hyps) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var ctx = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
                        return Tacmach$ReactTemplate.New[/* pf_get_hyp */14](id, gl);
                      }), hyps);
                return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], bring_hyps(ctx), clear(hyps));
              }));
}

function check_number_of_constructors(expctdnumopt, i, nconstr) {
  if (!i) {
    error("The constructors are numbered starting from 1.");
  }
  if (expctdnumopt) {
    var n = expctdnumopt[0];
    if (n !== nconstr) {
      CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Tactics.check_number_of_constructors"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Not an inductive goal with "), Pp$ReactTemplate.$$int(n)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], n, " constructor"))), Pp$ReactTemplate.str(".")));
    }
    
  }
  if (i > nconstr) {
    return error("Not enough constructors.");
  } else {
    return 0;
  }
}

function constructor_core(with_evars, cstr, lbind) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var match = Evd$ReactTemplate.fresh_constructor_instance(/* None */0, env, sigma, cstr);
                var match$1 = match[1];
                var cons = EConstr$ReactTemplate.mkConstructU(/* tuple */[
                      match$1[0],
                      EConstr$ReactTemplate.EInstance[/* make */0](match$1[1])
                    ]);
                var apply_tac = general_apply(/* true */1, /* false */0, with_evars, /* None */0, CAst$ReactTemplate.make(/* None */0, /* tuple */[
                          cons,
                          lbind
                        ]));
                return Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]), apply_tac);
              }));
}

function constructor_tac(with_evars, expctdnumopt, i, lbind) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var cl = Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
                var match = Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0](Tacred$ReactTemplate.reduce_to_quantified_ind, gl), cl);
                var ind = match[0][0];
                var nconstr = Global$ReactTemplate.lookup_inductive(ind)[1][/* mind_consnames */3].length;
                check_number_of_constructors(expctdnumopt, i, nconstr);
                return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                            convert_concl_no_check(match[1], /* DEFAULTcast */2),
                            /* :: */[
                              intros,
                              /* :: */[
                                constructor_core(with_evars, /* tuple */[
                                      ind,
                                      i
                                    ], lbind),
                                /* [] */0
                              ]
                            ]
                          ]);
              }));
}

function one_constructor(i, lbind) {
  return constructor_tac(/* false */0, /* None */0, i, lbind);
}

function any_constructor(with_evars, tacopt) {
  var tac = function (cstr) {
    return constructor_core(with_evars, cstr, /* NoBindings */0);
  };
  var one_constr;
  if (tacopt) {
    var t = tacopt[0];
    one_constr = (function (cstr) {
        return Tacticals$ReactTemplate.New[/* tclTHEN */2](constructor_core(with_evars, cstr, /* NoBindings */0), t);
      });
  } else {
    one_constr = tac;
  }
  var any_constr = function (ind, n, i, _) {
    if (i === n) {
      return Curry._1(one_constr, /* tuple */[
                  ind,
                  i
                ]);
    } else {
      var partial_arg = i + 1 | 0;
      return Tacticals$ReactTemplate.New[/* tclORD */6](Curry._1(one_constr, /* tuple */[
                      ind,
                      i
                    ]), (function (param) {
                    return any_constr(ind, n, partial_arg, param);
                  }));
    }
  };
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var cl = Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
                var match = Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0](Tacred$ReactTemplate.reduce_to_quantified_ind, gl), cl);
                var ind = match[0][0];
                var nconstr = Global$ReactTemplate.lookup_inductive(ind)[1][/* mind_consnames */3].length;
                if (!nconstr) {
                  error("The type has no constructors.");
                }
                return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                            convert_concl_no_check(match[1], /* DEFAULTcast */2),
                            /* :: */[
                              intros,
                              /* :: */[
                                any_constr(ind, nconstr, 1, /* () */0),
                                /* [] */0
                              ]
                            ]
                          ]);
              }));
}

function left_with_bindings(with_evars) {
  var partial_arg = /* Some */[2];
  return (function (param) {
      return constructor_tac(with_evars, partial_arg, 1, param);
    });
}

function right_with_bindings(with_evars) {
  var partial_arg = /* Some */[2];
  return (function (param) {
      return constructor_tac(with_evars, partial_arg, 2, param);
    });
}

function split_with_bindings(with_evars, l) {
  var partial_arg = /* Some */[1];
  return Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                return constructor_tac(with_evars, partial_arg, 1, param);
              }), l);
}

var partial_arg$7 = /* Some */[2];

function left(param) {
  return constructor_tac(/* false */0, partial_arg$7, 1, param);
}

var simplest_left = left(/* NoBindings */0);

var partial_arg$8 = /* Some */[2];

function right(param) {
  return constructor_tac(/* false */0, partial_arg$8, 2, param);
}

var simplest_right = right(/* NoBindings */0);

var partial_arg$9 = /* Some */[1];

function split(param) {
  return constructor_tac(/* false */0, partial_arg$9, 1, param);
}

var simplest_split = split(/* NoBindings */0);

var match = Hook$ReactTemplate.make(/* None */0, /* () */0);

var forward_general_rewrite_clause = match[0];

var match$1 = Hook$ReactTemplate.make(/* None */0, /* () */0);

var forward_subst_one = match$1[0];

var intro_decomp_eq_function = [(function () {
      return Pervasives.failwith("Not implemented");
    })];

function declare_intro_decomp_eq(f) {
  intro_decomp_eq_function[0] = f;
  return /* () */0;
}

function my_find_eq_data_decompose(gl, t) {
  try {
    return /* Some */[Hipattern$ReactTemplate.find_eq_data_decompose(gl, t)];
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.is_anomaly(e)) {
      return /* None */0;
    } else if (e === Constr_matching$ReactTemplate.PatternMatchingFailure) {
      return /* None */0;
    } else {
      throw e;
    }
  }
}

function prepare_naming(loc, param) {
  if (typeof param === "number") {
    return /* NamingAvoid */Block.__(0, [Names$ReactTemplate.Id[/* Set */9][/* empty */0]]);
  } else if (param.tag) {
    return /* NamingBasedOn */Block.__(1, [
              param[0],
              Names$ReactTemplate.Id[/* Set */9][/* empty */0]
            ]);
  } else {
    return /* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(loc, param[0])]);
  }
}

function explicit_intro_names(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0][/* v */0];
      switch (match.tag | 0) {
        case 0 : 
            _param = param[1];
            continue ;
            case 1 : 
            var match$1 = match[0];
            if (typeof match$1 === "number") {
              _param = param[1];
              continue ;
              
            } else if (match$1.tag) {
              _param = param[1];
              continue ;
              
            } else {
              return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], match$1[0], explicit_intro_names(param[1]));
            }
            break;
        case 2 : 
            var match$2 = match[0];
            if (typeof match$2 === "number") {
              _param = param[1];
              continue ;
              
            } else {
              switch (match$2.tag | 0) {
                case 0 : 
                    var l$prime = param[1];
                    var l = match$2[0];
                    var ll;
                    ll = l.tag ? /* :: */[
                        l[0],
                        /* [] */0
                      ] : l[0];
                    var fold = (function(l$prime){
                    return function fold(accu, l) {
                      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], accu, explicit_intro_names(Util$ReactTemplate.$at(l, l$prime)));
                    }
                    }(l$prime));
                    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, Names$ReactTemplate.Id[/* Set */9][/* empty */0], ll);
                case 1 : 
                    _param = Util$ReactTemplate.$at(match$2[0], param[1]);
                    continue ;
                    case 2 : 
                    _param = /* :: */[
                      match$2[1],
                      param[1]
                    ];
                    continue ;
                    case 3 : 
                    _param = param[1];
                    continue ;
                    
              }
            }
            break;
        
      }
    } else {
      return Names$ReactTemplate.Id[/* Set */9][/* empty */0];
    }
  };
}

function check_name_unicity(env, ok, _seen, _param) {
  while(true) {
    var param = _param;
    var seen = _seen;
    if (param) {
      var match = param[0];
      var match$1 = match[/* v */0];
      switch (match$1.tag | 0) {
        case 0 : 
            _param = param[1];
            continue ;
            case 1 : 
            var match$2 = match$1[0];
            if (typeof match$2 === "number") {
              _param = param[1];
              continue ;
              
            } else if (match$2.tag) {
              _param = param[1];
              continue ;
              
            } else {
              var loc = match[/* loc */1];
              var id = match$2[0];
              try {
                if (Curry._3(Util$ReactTemplate.List[/* mem_f */47], Names$ReactTemplate.Id[/* equal */0], id, ok)) {
                  throw Caml_builtin_exceptions.not_found;
                } else {
                  EConstr$ReactTemplate.lookup_named(id, env);
                }
                return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is already used.")));
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  if (Curry._3(Util$ReactTemplate.List[/* mem_f */47], Names$ReactTemplate.Id[/* equal */0], id, seen)) {
                    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is used twice.")));
                  } else {
                    _param = param[1];
                    _seen = /* :: */[
                      id,
                      seen
                    ];
                    continue ;
                    
                  }
                } else {
                  throw exn;
                }
              }
            }
            break;
        case 2 : 
            var match$3 = match$1[0];
            if (typeof match$3 === "number") {
              _param = param[1];
              continue ;
              
            } else {
              switch (match$3.tag | 0) {
                case 0 : 
                    var l$prime = param[1];
                    var l = match$3[0];
                    var ll;
                    ll = l.tag ? /* :: */[
                        l[0],
                        /* [] */0
                      ] : l[0];
                    return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(seen,l$prime){
                              return function (l) {
                                return check_name_unicity(env, ok, seen, Util$ReactTemplate.$at(l, l$prime));
                              }
                              }(seen,l$prime)), ll);
                case 1 : 
                    _param = Util$ReactTemplate.$at(match$3[0], param[1]);
                    continue ;
                    case 2 : 
                    _param = /* :: */[
                      match$3[1],
                      param[1]
                    ];
                    continue ;
                    case 3 : 
                    _param = param[1];
                    continue ;
                    
              }
            }
            break;
        
      }
    } else {
      return /* () */0;
    }
  };
}

var wild_id = Names$ReactTemplate.Id[/* of_string */5]("_tmp");

function list_mem_assoc_right(id, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Names$ReactTemplate.Id[/* equal */0](id, param[0][/* v */0])) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function make_tmp_naming(avoid, l, pat) {
  if (typeof pat === "number") {
    return /* NamingBasedOn */Block.__(1, [
              wild_id,
              Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], avoid, explicit_intro_names(l))
            ]);
  } else {
    var eta = /* IntroAction */Block.__(2, [pat]);
    return /* NamingAvoid */Block.__(0, [Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], avoid, explicit_intro_names(/* :: */[
                        CAst$ReactTemplate.make(/* None */0, eta),
                        l
                      ]))]);
  }
}

function fit_bound(n, param) {
  if (param) {
    var match = param[0];
    if (match[0]) {
      return Caml_obj.caml_equal(n, match[1]);
    } else {
      return /* true */1;
    }
  } else {
    return /* true */1;
  }
}

function exceed_bound(n, param) {
  if (param) {
    var match = param[0];
    if (match[0]) {
      return Caml_obj.caml_greaterequal(n, match[1]);
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function intro_patterns_core(with_evars, b, avoid, ids, thin, destopt, bound, n, tac$1, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      var match = param[0];
      var loc = match[/* loc */1];
      var pat = match[/* v */0];
      if (exceed_bound(n, bound)) {
        var loc$1 = loc;
        var bound$1 = bound;
        var pat$1 = pat;
        var match$1 = Option$ReactTemplate.get(bound$1);
        var nb = match$1[1];
        var match$2;
        switch (pat$1.tag | 0) {
          case 1 : 
              var tmp = pat$1[0];
              match$2 = typeof tmp === "number" ? /* tuple */[
                  "introduction pattern",
                  "",
                  "none"
                ] : (
                  tmp.tag ? /* tuple */[
                      "introduction pattern",
                      "",
                      "none"
                    ] : /* tuple */[
                      "name",
                      Curry._2(Util$ReactTemplate.$$String[/* plural */33], nb, " introduction pattern"),
                      "no"
                    ]
                );
              break;
          case 0 : 
          case 2 : 
              match$2 = /* tuple */[
                "introduction pattern",
                "",
                "none"
              ];
              break;
          
        }
        var s2 = match$2[1];
        return CErrors$ReactTemplate.user_err(loc$1, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unexpected "), Pp$ReactTemplate.str(match$2[0])), Pp$ReactTemplate.str(" (")), nb ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("at most "), Pp$ReactTemplate.$$int(nb)), Pp$ReactTemplate.str(s2)) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(match$2[2]), Pp$ReactTemplate.str(s2))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(nb === 1 ? "was" : "were")), Pp$ReactTemplate.strbrk(" expected in the branch).")));
      } else {
        switch (pat.tag | 0) {
          case 0 : 
              var name_flag = /* NamingAvoid */Block.__(0, [Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], avoid, explicit_intro_names(l))]);
              var move_flag = destopt;
              var dep_flag = pat[0];
              var n$1 = n;
              var bound$2 = bound;
              var tac$2 = (function(l){
              return function tac$2(ids) {
                return intro_patterns_core(with_evars, b, avoid, ids, thin, destopt, bound, n + Curry._1(Util$ReactTemplate.List[/* length */0], ids) | 0, tac$1, l);
              }
              }(l));
              var aux = (function(name_flag,move_flag,dep_flag,bound$2,tac$2){
              return function aux(n, ids) {
                if (bound$2 ? +(n < bound$2[0][1]) : /* true */1) {
                  return Proofview$ReactTemplate.tclORELSE(intro_then_gen(name_flag, move_flag, /* false */0, dep_flag, (function (id) {
                                    return aux(n + 1 | 0, /* :: */[
                                                id,
                                                ids
                                              ]);
                                  })), (function (param) {
                                var info = param[1];
                                var e = param[0];
                                if (e[0] === Logic$ReactTemplate.RefinerError) {
                                  if (typeof e[3] === "number") {
                                    return Curry._1(tac$2, ids);
                                  } else {
                                    return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                                  }
                                } else {
                                  return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                                }
                              }));
                } else {
                  return Curry._1(tac$2, ids);
                }
              }
              }(name_flag,move_flag,dep_flag,bound$2,tac$2));
              return aux(n$1, /* [] */0);
          case 1 : 
              var loc$2 = loc;
              var with_evars$1 = with_evars;
              var b$1 = b;
              var avoid$1 = avoid;
              var ids$1 = ids;
              var pat$2 = pat[0];
              var thin$1 = thin;
              var destopt$1 = destopt;
              var bound$3 = bound;
              var n$2 = n + 1 | 0;
              var tac$3 = tac$1;
              var l$1 = l;
              if (typeof pat$2 === "number") {
                return intro_then_gen(/* NamingAvoid */Block.__(0, [Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], avoid$1, explicit_intro_names(l$1))]), destopt$1, /* true */1, /* false */0, (function(with_evars$1,b$1,avoid$1,ids$1,thin$1,destopt$1,bound$3,n$2,tac$3,l$1){
                          return function (id) {
                            return intro_patterns_core(with_evars$1, b$1, avoid$1, /* :: */[
                                        id,
                                        ids$1
                                      ], thin$1, destopt$1, bound$3, n$2, tac$3, l$1);
                          }
                          }(with_evars$1,b$1,avoid$1,ids$1,thin$1,destopt$1,bound$3,n$2,tac$3,l$1)));
              } else if (pat$2.tag) {
                return intro_then_gen(/* NamingBasedOn */Block.__(1, [
                              pat$2[0],
                              Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], avoid$1, explicit_intro_names(l$1))
                            ]), destopt$1, /* true */1, /* false */0, (function(with_evars$1,b$1,avoid$1,ids$1,thin$1,destopt$1,bound$3,n$2,tac$3,l$1){
                          return function (id) {
                            return intro_patterns_core(with_evars$1, b$1, avoid$1, /* :: */[
                                        id,
                                        ids$1
                                      ], thin$1, destopt$1, bound$3, n$2, tac$3, l$1);
                          }
                          }(with_evars$1,b$1,avoid$1,ids$1,thin$1,destopt$1,bound$3,n$2,tac$3,l$1)));
              } else {
                var id = pat$2[0];
                var id$1 = id;
                var thin$2 = thin$1;
                var avoid$2 = avoid$1;
                ((function(loc$2,with_evars$1,b$1,avoid$1,ids$1,destopt$1,bound$3,n$2,tac$3,l$1,id){
                  return function (thin) {
                    return intro_then_gen(/* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(loc$2, id)]), destopt$1, /* true */1, /* false */0, (function (id) {
                                  return intro_patterns_core(with_evars$1, b$1, avoid$1, /* :: */[
                                              id,
                                              ids$1
                                            ], thin, destopt$1, bound$3, n$2, tac$3, l$1);
                                }));
                  }
                  }(loc$2,with_evars$1,b$1,avoid$1,ids$1,destopt$1,bound$3,n$2,tac$3,l$1,id)));
                if (list_mem_assoc_right(id$1, thin$2)) {
                  var newid = Namegen$ReactTemplate.next_ident_away(Nameops$ReactTemplate.add_suffix(id$1, "'"), avoid$2);
                  var thin$3 = Curry._2(Util$ReactTemplate.List[/* map */10], (function(id$1,newid){
                      return function (param) {
                        return CAst$ReactTemplate.map((function (id$prime) {
                                      if (Names$ReactTemplate.Id[/* equal */0](id$1, id$prime)) {
                                        return newid;
                                      } else {
                                        return id$prime;
                                      }
                                    }), param);
                      }
                      }(id$1,newid)), thin$2);
                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](rename_hyp(/* :: */[
                                  /* tuple */[
                                    id$1,
                                    newid
                                  ],
                                  /* [] */0
                                ]), Curry._1(tac, thin$3));
                } else {
                  return Curry._1(tac, thin$2);
                }
              }
          case 2 : 
              var pat$3 = pat[0];
              var partial_arg = b || 1 - Curry._1(Util$ReactTemplate.List[/* is_empty */45], l);
              return intro_then_gen(make_tmp_naming(avoid, l, pat$3), destopt, /* true */1, /* false */0, (function(loc,l,pat$3,partial_arg){
                        return function (param) {
                          return intro_pattern_action(loc, with_evars, partial_arg, /* false */0, pat$3, thin, destopt, (function (thin, bound$prime) {
                                        return (function (param) {
                                            return intro_patterns_core(with_evars, b, avoid, ids, thin, destopt, bound$prime, 0, (function (ids, thin) {
                                                          return intro_patterns_core(with_evars, b, avoid, ids, thin, destopt, bound, n + 1 | 0, tac$1, l);
                                                        }), param);
                                          });
                                      }), param);
                        }
                        }(loc,l,pat$3,partial_arg)));
          
        }
      }
    } else if (fit_bound(n, bound)) {
      return Curry._2(tac$1, ids, thin);
    } else {
      _param = /* :: */[
        CAst$ReactTemplate.make(/* None */0, /* IntroNaming */Block.__(1, [/* IntroAnonymous */0])),
        /* [] */0
      ];
      continue ;
      
    }
  };
}

function intro_pattern_action(loc, with_evars, b, style, pat, thin, destopt, tac, id) {
  if (typeof pat === "number") {
    return Curry._3(tac, /* :: */[
                CAst$ReactTemplate.make(loc, id),
                thin
              ], /* None */0, /* [] */0);
  } else {
    switch (pat.tag | 0) {
      case 0 : 
          var loc$1 = loc;
          var bracketed = b;
          var ll = pat[0];
          var thin$1 = thin;
          var tac$1 = tac;
          var id$1 = id;
          return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                        var c = EConstr$ReactTemplate.mkVar(id$1);
                        var t = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, c);
                        var match = Tacmach$ReactTemplate.New[/* pf_reduce_to_quantified_ind */18](gl, t);
                        var branchsigns = Tacticals$ReactTemplate.compute_constructor_signatures(/* false */0, match[0]);
                        var nv_with_let = Util$ReactTemplate.$$Array[/* map */12](Util$ReactTemplate.List[/* length */0], branchsigns);
                        var ll$1 = Tacticals$ReactTemplate.fix_empty_or_and_pattern(branchsigns.length, ll);
                        var ll$2 = Tacticals$ReactTemplate.get_and_check_or_and_pattern(loc$1)(ll$1, branchsigns);
                        return Tacticals$ReactTemplate.New[/* tclTHENLASTn */16](Tacticals$ReactTemplate.New[/* tclTHEN */2](simplest_ecase(c), clear(/* :: */[
                                            id$1,
                                            /* [] */0
                                          ])), Util$ReactTemplate.$$Array[/* map2 */49]((function (n, l) {
                                          return Curry._3(tac$1, thin$1, /* Some */[/* tuple */[
                                                        bracketed,
                                                        n
                                                      ]], l);
                                        }), nv_with_let, ll$2));
                      }));
      case 1 : 
          var l = pat[0];
          var thin$2 = thin;
          var tac$2 = tac;
          var id$2 = id;
          return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                        var c = EConstr$ReactTemplate.mkVar(id$2);
                        var t = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, c);
                        var match = Tacmach$ReactTemplate.New[/* pf_reduce_to_quantified_ind */18](gl, t);
                        var t$1 = match[1];
                        var match$1 = my_find_eq_data_decompose(gl, t$1);
                        if (match$1) {
                          var match$2 = match$1[0];
                          return Curry._3(intro_decomp_eq_function[0], (function (n) {
                                        return Curry._3(tac$2, /* :: */[
                                                    CAst$ReactTemplate.make(/* None */0, id$2),
                                                    thin$2
                                                  ], /* Some */[/* tuple */[
                                                      /* true */1,
                                                      n
                                                    ]], l);
                                      }), /* tuple */[
                                      match$2[0],
                                      t$1,
                                      match$2[2]
                                    ], /* tuple */[
                                      c,
                                      t$1
                                    ]);
                        } else {
                          return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Not a primitive equality here."));
                        }
                      }));
      case 2 : 
          var match = pat[1];
          var loc$2 = match[/* loc */1];
          var match$1 = pat[0];
          var f = match$1[/* v */0];
          var match$2 = prepare_intros(loc$2, with_evars, /* IntroIdentifier */Block.__(0, [id]), destopt, match[/* v */0]);
          var tac_ipat = match$2[1];
          var naming = match$2[0];
          var doclear = Caml_obj.caml_equal(naming, /* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(loc$2, id)])) ? Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0) : clear(/* :: */[
                  id,
                  /* [] */0
                ]);
          var f$1 = function (env, sigma) {
            var match = Curry._2(f, env, sigma);
            return /* tuple */[
                    match[0],
                    /* tuple */[
                      match[1],
                      /* NoBindings */0
                    ]
                  ];
          };
          return apply_in_delayed_once(/* false */0, /* true */1, /* true */1, with_evars, naming, id, /* tuple */[
                      /* None */0,
                      CAst$ReactTemplate.make(match$1[/* loc */1], f$1)
                    ], (function (id) {
                        return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                    doclear,
                                    /* :: */[
                                      Curry._1(tac_ipat, id),
                                      /* :: */[
                                        Curry._3(tac, thin, /* None */0, /* [] */0),
                                        /* [] */0
                                      ]
                                    ]
                                  ]);
                      }));
      case 3 : 
          var with_evars$1 = with_evars;
          var thin$3 = thin;
          var l2r = pat[0];
          var id$3 = id;
          var tac$3 = function (thin) {
            return Curry._3(tac, thin, /* None */0, /* [] */0);
          };
          var rew_on = function (l2r) {
            return Curry._3(Hook$ReactTemplate.get(forward_general_rewrite_clause), l2r, with_evars$1, /* tuple */[
                        EConstr$ReactTemplate.mkVar(id$3),
                        /* NoBindings */0
                      ]);
          };
          var subst_on = function (l2r, x, rhs) {
            return Curry._3(Hook$ReactTemplate.get(forward_subst_one), /* true */1, x, /* tuple */[
                        id$3,
                        rhs,
                        l2r
                      ]);
          };
          var clear_var_and_eq = function (id$prime) {
            return clear(/* :: */[
                        id$prime,
                        /* :: */[
                          id$3,
                          /* [] */0
                        ]
                      ]);
          };
          var early_clear = function (id$prime, thin) {
            return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                          return 1 - Names$ReactTemplate.Id[/* equal */0](param[/* v */0], id$prime);
                        }), thin);
          };
          return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                        var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                        var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                        var partial_arg = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6];
                        var type_of = function (param) {
                          return partial_arg(gl, param);
                        };
                        var whd_all = Tacmach$ReactTemplate.New[/* pf_apply */0](Reductionops$ReactTemplate.whd_all, gl);
                        var t = Curry._1(whd_all, Curry._1(type_of, EConstr$ReactTemplate.mkVar(id$3)));
                        var match = Hipattern$ReactTemplate.match_with_equality_type(sigma, t);
                        var match$1;
                        var exit = 0;
                        if (match) {
                          var match$2 = match[0][1];
                          if (match$2) {
                            var match$3 = match$2[1];
                            var c = match$2[0];
                            if (match$3) {
                              var match$4 = match$3[1];
                              if (match$4) {
                                if (match$4[1]) {
                                  exit = 1;
                                } else {
                                  var rhs = match$4[0];
                                  var lhs = match$3[0];
                                  if (l2r && EConstr$ReactTemplate.isVar(sigma, lhs) && !Termops$ReactTemplate.occur_var(env, sigma, EConstr$ReactTemplate.destVar(sigma, lhs), rhs)) {
                                    var id$prime = EConstr$ReactTemplate.destVar(sigma, lhs);
                                    match$1 = /* tuple */[
                                      subst_on(l2r, id$prime, rhs),
                                      early_clear(id$prime, thin$3)
                                    ];
                                  } else if (!l2r && EConstr$ReactTemplate.isVar(sigma, rhs) && !Termops$ReactTemplate.occur_var(env, sigma, EConstr$ReactTemplate.destVar(sigma, rhs), lhs)) {
                                    var id$prime$1 = EConstr$ReactTemplate.destVar(sigma, rhs);
                                    match$1 = /* tuple */[
                                      subst_on(l2r, id$prime$1, lhs),
                                      early_clear(id$prime$1, thin$3)
                                    ];
                                  } else {
                                    match$1 = /* tuple */[
                                      Tacticals$ReactTemplate.New[/* tclTHEN */2](Curry._1(rew_on(l2r), Locusops$ReactTemplate.onConcl), clear(/* :: */[
                                                id$3,
                                                /* [] */0
                                              ])),
                                      thin$3
                                    ];
                                  }
                                }
                              } else {
                                exit = 1;
                              }
                            } else {
                              var l2r$1 = 1 - l2r;
                              if (EConstr$ReactTemplate.isVar(sigma, c)) {
                                var id$prime$2 = EConstr$ReactTemplate.destVar(sigma, c);
                                match$1 = /* tuple */[
                                  Tacticals$ReactTemplate.New[/* tclTHEN */2](Curry._1(rew_on(l2r$1), Locusops$ReactTemplate.allHypsAndConcl), clear_var_and_eq(id$prime$2)),
                                  early_clear(id$prime$2, thin$3)
                                ];
                              } else {
                                match$1 = /* tuple */[
                                  Tacticals$ReactTemplate.New[/* tclTHEN */2](Curry._1(rew_on(l2r$1), Locusops$ReactTemplate.onConcl), clear(/* :: */[
                                            id$3,
                                            /* [] */0
                                          ])),
                                  thin$3
                                ];
                              }
                            }
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        if (exit === 1) {
                          match$1 = /* tuple */[
                            Tacticals$ReactTemplate.New[/* tclTHEN */2](Curry._1(rew_on(l2r), Locusops$ReactTemplate.onConcl), clear(/* :: */[
                                      id$3,
                                      /* [] */0
                                    ])),
                            thin$3
                          ];
                        }
                        return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](match$1[0], Curry._1(tac$3, match$1[1]));
                      }));
      
    }
  }
}

function prepare_intros(loc, with_evars, dft, destopt, param) {
  switch (param.tag | 0) {
    case 0 : 
        return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("Introduction pattern for one hypothesis expected."));
    case 1 : 
        return /* tuple */[
                prepare_naming(loc, param[0]),
                (function (id) {
                    return move_hyp(id, destopt);
                  })
              ];
    case 2 : 
        var ipat = param[0];
        var tac = function (thin, bound) {
          var partial_arg = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
          return (function (param) {
              return intro_patterns_core(with_evars, /* true */1, partial_arg, /* [] */0, thin, destopt, bound, 0, (function (_, l) {
                            return clear_wildcards(l);
                          }), param);
            });
        };
        return /* tuple */[
                prepare_naming(loc, dft),
                (function (id) {
                    return intro_pattern_action(loc, with_evars, /* true */1, /* true */1, ipat, /* [] */0, destopt, tac, id);
                  })
              ];
    
  }
}

function intro_patterns_head_core(with_evars, b, destopt, bound, pat) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                check_name_unicity(env, /* [] */0, /* [] */0, pat);
                return intro_patterns_core(with_evars, b, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* [] */0, /* [] */0, destopt, bound, 0, (function (_, l) {
                              return clear_wildcards(l);
                            }), pat);
              }));
}

function intro_patterns_bound_to(with_evars, n, destopt) {
  var partial_arg = /* Some */[/* tuple */[
      /* true */1,
      n
    ]];
  return (function (param) {
      return intro_patterns_head_core(with_evars, /* true */1, destopt, partial_arg, param);
    });
}

function intro_patterns_to(with_evars, destopt) {
  var partial_arg = bracketing_last_or_and_intro_pattern[0];
  return (function (param) {
      return intro_patterns_head_core(with_evars, partial_arg, destopt, /* None */0, param);
    });
}

function intro_pattern_to(with_evars, destopt, pat) {
  return intro_patterns_to(with_evars, destopt)(/* :: */[
              CAst$ReactTemplate.make(/* None */0, pat),
              /* [] */0
            ]);
}

function intro_patterns(with_evars) {
  return intro_patterns_to(with_evars, /* MoveLast */1);
}

function intros_patterns(with_evars, l) {
  if (l) {
    return intro_patterns_to(with_evars, /* MoveLast */1)(l);
  } else {
    return intros;
  }
}

function prepare_intros_opt(with_evars, dft, destopt, param) {
  if (param) {
    var match = param[0];
    return prepare_intros(match[/* loc */1], with_evars, dft, destopt, match[/* v */0]);
  } else {
    return /* tuple */[
            prepare_naming(/* None */0, dft),
            (function () {
                return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
              })
          ];
  }
}

function ipat_of_name(param) {
  if (param) {
    var eta = /* IntroNaming */Block.__(1, [/* IntroIdentifier */Block.__(0, [param[0]])]);
    return /* Some */[CAst$ReactTemplate.make(/* None */0, eta)];
  } else {
    return /* None */0;
  }
}

function head_ident(sigma, c) {
  var c$1 = EConstr$ReactTemplate.decompose_app(sigma, EConstr$ReactTemplate.decompose_lam_assum(sigma, c)[1])[0];
  if (EConstr$ReactTemplate.isVar(sigma, c$1)) {
    return /* Some */[EConstr$ReactTemplate.destVar(sigma, c$1)];
  } else {
    return /* None */0;
  }
}

function assert_as(first, hd, ipat, t) {
  var match = prepare_intros_opt(/* false */0, /* IntroAnonymous */0, /* MoveLast */1, ipat);
  var naming = match[0];
  var repl = do_replace(hd, naming);
  var tac = repl ? (function () {
        return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
      }) : match[1];
  if (first) {
    return assert_before_then_gen(repl, naming, t, tac);
  } else {
    return assert_after_then_gen(repl, naming, t, tac);
  }
}

function general_apply_in(sidecond_first, with_delta, with_destruct, with_evars, id, lemmas, ipat) {
  var tac = function (param, tac$1, id) {
    return apply_in_delayed_once(sidecond_first, with_delta, with_destruct, with_evars, param[0], id, param[1], tac$1);
  };
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var destopt;
                if (with_evars) {
                  destopt = /* MoveLast */1;
                } else {
                  var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                  var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                  destopt = get_previous_hyp_position(env, sigma, id)(Proofview$ReactTemplate.Goal[/* hyps */3](gl));
                }
                var match = prepare_intros_opt(with_evars, /* IntroIdentifier */Block.__(0, [id]), destopt, ipat);
                var ipat_tac = match[1];
                var match$1 = Curry._1(Util$ReactTemplate.List[/* sep_last */93], lemmas);
                var match_000 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (lem) {
                        return /* tuple */[
                                /* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(/* None */0, id)]),
                                lem
                              ];
                      }), match$1[1]);
                var match_001 = /* tuple */[
                  match[0],
                  match$1[0]
                ];
                var last_lemma_target = match_001;
                return Curry._4(Util$ReactTemplate.List[/* fold_right */14], tac, match_000, (function (param) {
                              return tac(last_lemma_target, ipat_tac, param);
                            }), id);
              }));
}

function apply_in(simple, with_evars, id, lemmas, ipat) {
  var lemmas$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var match = param[1];
          var l = match[/* v */0];
          return /* tuple */[
                  param[0],
                  CAst$ReactTemplate.make(match[/* loc */1], (function (_, sigma) {
                          return /* tuple */[
                                  sigma,
                                  l
                                ];
                        }))
                ];
        }), lemmas);
  return general_apply_in(/* false */0, simple, simple, with_evars, id, lemmas$1, ipat);
}

function apply_delayed_in(simple, with_evars, id, lemmas, ipat) {
  return general_apply_in(/* false */0, simple, simple, with_evars, id, lemmas, ipat);
}

function decode_hyp(param) {
  if (param) {
    return /* MoveAfter */Block.__(0, [param[0]]);
  } else {
    return /* MoveLast */1;
  }
}

function letin_tac_gen(with_eq, param, ty) {
  var c = param[4];
  var ccl = param[3];
  var lastlhyp = param[2];
  var depdecls = param[1];
  var id = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var match;
                if (ty) {
                  match = /* tuple */[
                    sigma,
                    ty[0]
                  ];
                } else {
                  var t = typ_of(env, sigma, c);
                  match = Evarsolve$ReactTemplate.refresh_universes(/* None */0, /* Some */[/* true */1], /* None */0, /* Some */[/* false */0], env, sigma, t);
                }
                var t$1 = match[1];
                var sigma$1 = match[0];
                var match$1;
                if (with_eq) {
                  var match$2 = with_eq[0];
                  var match$3 = match$2[1];
                  var ido = match$3[/* v */0];
                  var heq;
                  heq = typeof ido === "number" ? new_fresh_id(Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], id), Nameops$ReactTemplate.add_prefix("Heq", id), gl) : (
                      ido.tag ? new_fresh_id(Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], id), ido[0], gl) : ido[0]
                    );
                  var eqdata = Coqlib$ReactTemplate.build_coq_eq_data(/* () */0);
                  var args = match$2[0] ? /* :: */[
                      t$1,
                      /* :: */[
                        EConstr$ReactTemplate.mkVar(id),
                        /* :: */[
                          c,
                          /* [] */0
                        ]
                      ]
                    ] : /* :: */[
                      t$1,
                      /* :: */[
                        c,
                        /* :: */[
                          EConstr$ReactTemplate.mkVar(id),
                          /* [] */0
                        ]
                      ]
                    ];
                  var match$4 = Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env, sigma$1, eqdata[/* eq */0]);
                  var eq = EConstr$ReactTemplate.of_constr(match$4[1]);
                  var match$5 = Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env, match$4[0], eqdata[/* refl */2]);
                  var refl = EConstr$ReactTemplate.of_constr(match$5[1]);
                  var eq$1 = EConstr$ReactTemplate.applist(/* tuple */[
                        eq,
                        args
                      ]);
                  var refl$1 = EConstr$ReactTemplate.applist(/* tuple */[
                        refl,
                        /* :: */[
                          t$1,
                          /* :: */[
                            EConstr$ReactTemplate.mkVar(id),
                            /* [] */0
                          ]
                        ]
                      ]);
                  var term = EConstr$ReactTemplate.mkNamedLetIn(id, c, t$1, EConstr$ReactTemplate.mkLetIn(/* tuple */[
                            /* Name */[heq],
                            refl$1,
                            eq$1,
                            ccl
                          ]));
                  var match$6 = Typing$ReactTemplate.type_of(/* None */0, env, match$5[0], term);
                  var ans_001 = Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                        intro_gen(/* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(match$3[/* loc */1], heq)]), decode_hyp(lastlhyp), /* true */1, /* false */0),
                        /* :: */[
                          clear_body(/* :: */[
                                heq,
                                /* :: */[
                                  id,
                                  /* [] */0
                                ]
                              ]),
                          /* [] */0
                        ]
                      ]);
                  var ans = /* tuple */[
                    term,
                    ans_001
                  ];
                  match$1 = /* tuple */[
                    match$6[0],
                    ans
                  ];
                } else {
                  match$1 = /* tuple */[
                    sigma$1,
                    /* tuple */[
                      EConstr$ReactTemplate.mkNamedLetIn(id, c, t$1, ccl),
                      Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0)
                    ]
                  ];
                }
                var match$7 = match$1[1];
                return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                            Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$1[0]),
                            /* :: */[
                              convert_concl_no_check(match$7[0], /* DEFAULTcast */2),
                              /* :: */[
                                intro_gen(/* NamingMustBe */Block.__(2, [CAst$ReactTemplate.make(/* None */0, id)]), decode_hyp(lastlhyp), /* true */1, /* false */0),
                                /* :: */[
                                  Tacticals$ReactTemplate.New[/* tclMAP */20](convert_hyp_no_check, depdecls),
                                  /* :: */[
                                    match$7[1],
                                    /* [] */0
                                  ]
                                ]
                              ]
                            ]
                          ]);
              }));
}

function insert_before(decls, lasthyp, env) {
  if (lasthyp) {
    var id = lasthyp[0];
    return Environ$ReactTemplate.fold_named_context((function (_, d, env) {
                  var d$1 = Termops$ReactTemplate.map_named_decl(EConstr$ReactTemplate.of_constr, d);
                  var env$1 = Names$ReactTemplate.Id[/* equal */0](id, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d$1)) ? EConstr$ReactTemplate.push_named_context(decls, env) : env;
                  return EConstr$ReactTemplate.push_named(d$1, env$1);
                }), env, Environ$ReactTemplate.reset_context(env));
  } else {
    return EConstr$ReactTemplate.push_named_context(decls, env);
  }
}

function mkletin_goal(env, sigma, store, with_eq, dep, param, ty) {
  var c = param[3];
  var ccl = param[2];
  var lastlhyp = param[1];
  var id = param[0];
  var t = ty ? ty[0] : typ_of(env, sigma, c);
  var decl = dep ? /* LocalDef */Block.__(1, [
        id,
        c,
        t
      ]) : /* LocalAssum */Block.__(0, [
        id,
        t
      ]);
  if (with_eq) {
    var match = with_eq[0];
    var match$1 = match[1];
    var ido = match$1[/* v */0];
    var heq;
    if (typeof ido === "number") {
      heq = fresh_id_in_env(Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], id), Nameops$ReactTemplate.add_prefix("Heq", id), env);
    } else if (ido.tag) {
      heq = fresh_id_in_env(Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], id), ido[0], env);
    } else {
      var id$1 = ido[0];
      if (Curry._2(Util$ReactTemplate.List[/* mem */24], id$1, Termops$ReactTemplate.ids_of_named_context(EConstr$ReactTemplate.named_context(env)))) {
        CErrors$ReactTemplate.user_err(match$1[/* loc */1], /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id$1), Pp$ReactTemplate.str(" is already used.")));
      }
      heq = id$1;
    }
    var eqdata = Coqlib$ReactTemplate.build_coq_eq_data(/* () */0);
    var args = match[0] ? /* :: */[
        t,
        /* :: */[
          EConstr$ReactTemplate.mkVar(id),
          /* :: */[
            c,
            /* [] */0
          ]
        ]
      ] : /* :: */[
        t,
        /* :: */[
          c,
          /* :: */[
            EConstr$ReactTemplate.mkVar(id),
            /* [] */0
          ]
        ]
      ];
    var match$2 = Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env, sigma, eqdata[/* eq */0]);
    var eq = EConstr$ReactTemplate.of_constr(match$2[1]);
    var match$3 = Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env, match$2[0], eqdata[/* refl */2]);
    var refl = EConstr$ReactTemplate.of_constr(match$3[1]);
    var eq$1 = EConstr$ReactTemplate.applist(/* tuple */[
          eq,
          args
        ]);
    var refl$1 = EConstr$ReactTemplate.applist(/* tuple */[
          refl,
          /* :: */[
            t,
            /* :: */[
              EConstr$ReactTemplate.mkVar(id),
              /* [] */0
            ]
          ]
        ]);
    var newenv = insert_before(/* :: */[
          /* LocalAssum */Block.__(0, [
              heq,
              eq$1
            ]),
          /* :: */[
            decl,
            /* [] */0
          ]
        ], lastlhyp, env);
    var match$4 = Evarutil$ReactTemplate.new_evar(newenv, match$3[0], /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], ccl);
    return /* tuple */[
            match$4[0],
            EConstr$ReactTemplate.mkNamedLetIn(id, c, t, EConstr$ReactTemplate.mkNamedLetIn(heq, refl$1, eq$1, match$4[1]))
          ];
  } else {
    var newenv$1 = insert_before(/* :: */[
          decl,
          /* [] */0
        ], lastlhyp, env);
    var match$5 = Evarutil$ReactTemplate.new_evar(newenv$1, sigma, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* Some */[/* true */1], ccl);
    return /* tuple */[
            match$5[0],
            EConstr$ReactTemplate.mkNamedLetIn(id, c, t, match$5[1])
          ];
  }
}

function letin_tac(with_eq, id, c, ty, occs) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var ccl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var abs = /* AbstractExact */Block.__(1, [
                    id,
                    c,
                    ty,
                    occs,
                    /* true */1
                  ]);
                var match = Unification$ReactTemplate.make_abstraction(env, sigma, ccl, abs);
                var res = match[5];
                var match$1 = res ? /* tuple */[
                    res[0][0],
                    c
                  ] : /* tuple */[
                    sigma,
                    c
                  ];
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$1[0]), letin_tac_gen(with_eq, /* tuple */[
                                match[0],
                                match[2],
                                match[3],
                                match[4],
                                match$1[1]
                              ], ty));
              }));
}

function letin_pat_tac(with_evars, with_eq, id, c, occs) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var ccl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var check = function () {
                  return /* true */1;
                };
                var abs = /* AbstractPattern */Block.__(0, [
                    /* false */0,
                    check,
                    id,
                    c,
                    occs,
                    /* false */0
                  ]);
                var match = Unification$ReactTemplate.make_abstraction(env, sigma, ccl, abs);
                var res = match[5];
                var match$1 = res ? res[0] : Unification$ReactTemplate.finish_evar_resolution(/* Some */[tactic_infer_flags(with_evars)], env, sigma, c);
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$1[0]), letin_tac_gen(with_eq, /* tuple */[
                                match[0],
                                match[2],
                                match[3],
                                match[4],
                                match$1[1]
                              ], /* None */0));
              }));
}

function forward(b, usetac, ipat, c) {
  if (usetac) {
    var tac = usetac[0];
    var tac$1 = tac ? Tacticals$ReactTemplate.New[/* tclCOMPLETE */31](tac[0]) : Tacticals$ReactTemplate.New[/* tclIDTAC */1];
    if (b) {
      return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](assert_as(b, /* None */0, ipat, c), tac$1);
    } else {
      return Tacticals$ReactTemplate.New[/* tclTHENS3PARTS */12](assert_as(b, /* None */0, ipat, c), /* array */[], tac$1, /* array */[Tacticals$ReactTemplate.New[/* tclIDTAC */1]]);
    }
  } else {
    return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                  var t = Tacmach$ReactTemplate.New[/* pf_get_type_of */7](gl, c);
                  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                  var hd = head_ident(sigma, c);
                  return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](assert_as(/* true */1, hd, ipat, t), exact_no_check(c));
                }));
  }
}

function pose_proof(na, c) {
  return forward(/* true */1, /* None */0, ipat_of_name(na), c);
}

function assert_by(na, t, tac) {
  return forward(/* true */1, /* Some */[/* Some */[tac]], ipat_of_name(na), t);
}

function enough_by(na, t, tac) {
  return forward(/* false */0, /* Some */[/* Some */[tac]], ipat_of_name(na), t);
}

function generalized_name(env, sigma, c, t, ids, cl, na) {
  if (na) {
    var id = na[0];
    if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], id, ids)) {
      CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is already used.")));
    }
    return na;
  } else {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 1) {
      return /* Name */[match[0]];
    } else if (EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, cl)) {
      return /* Anonymous */0;
    } else {
      return Namegen$ReactTemplate.named_hd(env, sigma, t, /* Anonymous */0);
    }
  }
}

function generalize_goal_gen(env, sigma, ids, i, param, t, cl) {
  var match = param[0];
  var b = match[2];
  var c = match[1];
  var match$1 = EConstr$ReactTemplate.decompose_prod_n_assum(sigma, i, cl);
  var dummy_prod = EConstr$ReactTemplate.it_mkProd_or_LetIn(EConstr$ReactTemplate.mkProp, match$1[0]);
  var match$2 = EConstr$ReactTemplate.decompose_prod_n_assum(sigma, i, Termops$ReactTemplate.subst_term_gen(sigma, EConstr$ReactTemplate.eq_constr_nounivs, c, dummy_prod));
  var match$3 = Find_subterm$ReactTemplate.subst_closed_term_occ(env, sigma, /* AtOccs */[match[0]], c, EConstr$ReactTemplate.it_mkProd_or_LetIn(match$1[1], match$2[0]));
  var cl$prime = match$3[0];
  var na = generalized_name(env, sigma, c, t, ids, cl$prime, param[1]);
  var decl = b ? /* LocalDef */Block.__(1, [
        na,
        b[0],
        t
      ]) : /* LocalAssum */Block.__(0, [
        na,
        t
      ]);
  return /* tuple */[
          EConstr$ReactTemplate.mkProd_or_LetIn(decl, cl$prime),
          match$3[1]
        ];
}

function generalize_goal(gl, i, o, param) {
  var env = Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl);
  var ids = Tacmach$ReactTemplate.New[/* pf_ids_of_hyps */11](gl);
  var match = Typing$ReactTemplate.type_of(/* None */0, env, param[1], o[0][1]);
  return generalize_goal_gen(env, match[0], ids, i, o, match[1], param[0]);
}

function generalize_dep($staropt$star, c) {
  var with_let = $staropt$star ? $staropt$star[0] : /* false */0;
  return Proofview$ReactTemplate.Goal[/* nf_enter */8]((function (gl) {
                var env = Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl);
                var sign = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var init_ids = Termops$ReactTemplate.ids_of_named_context(Global$ReactTemplate.named_context(/* () */0));
                var seek = function (d, toquant) {
                  if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (d$prime) {
                            return Termops$ReactTemplate.occur_var_in_decl(env, sigma, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d$prime), d);
                          }), toquant) || Termops$ReactTemplate.dependent_in_decl(sigma, c, d)) {
                    return /* :: */[
                            d,
                            toquant
                          ];
                  } else {
                    return toquant;
                  }
                };
                var to_quantify = Context$ReactTemplate.Named[/* fold_outside */9](seek, sign, /* [] */0);
                var to_quantify_rev = Curry._1(Util$ReactTemplate.List[/* rev */4], to_quantify);
                var qhyps = Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], to_quantify_rev);
                var tothin = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (id) {
                        return 1 - Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], id, init_ids);
                      }), qhyps);
                var match = EConstr$ReactTemplate.kind(sigma, c);
                var tothin$prime;
                if (match.tag === 1) {
                  var id = match[0];
                  tothin$prime = Termops$ReactTemplate.mem_named_context_val(id, EConstr$ReactTemplate.val_of_named_context(sign)) && !Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], id, init_ids) ? /* :: */[
                      id,
                      tothin
                    ] : tothin;
                } else {
                  tothin$prime = tothin;
                }
                var cl$prime = Curry._1(Termops$ReactTemplate.it_mkNamedProd_or_LetIn(Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl)), to_quantify);
                var body;
                if (with_let) {
                  var match$1 = EConstr$ReactTemplate.kind(sigma, c);
                  body = match$1.tag === 1 ? Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], Tacmach$ReactTemplate.New[/* pf_get_hyp */14](match$1[0], gl)) : /* None */0;
                } else {
                  body = /* None */0;
                }
                var match$2 = generalize_goal(gl, 0, /* tuple */[
                      /* tuple */[
                        /* AllOccurrences */0,
                        c,
                        body
                      ],
                      /* Anonymous */0
                    ], /* tuple */[
                      cl$prime,
                      Tacmach$ReactTemplate.New[/* project */3](gl)
                    ]);
                var cl$prime$prime = match$2[0];
                var match$3 = Typing$ReactTemplate.type_of(/* None */0, env, match$2[1], cl$prime$prime);
                var args = Context$ReactTemplate.Named[/* to_instance */11](EConstr$ReactTemplate.mkVar, to_quantify_rev);
                return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                            Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$3[0]),
                            /* :: */[
                              apply_type(/* false */0, cl$prime$prime, Option$ReactTemplate.is_empty(body) ? /* :: */[
                                      c,
                                      args
                                    ] : args),
                              /* :: */[
                                clear(Curry._1(Util$ReactTemplate.List[/* rev */4], tothin$prime)),
                                /* [] */0
                              ]
                            ]
                          ]);
              }));
}

function new_generalize_gen_let(lconstr) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var ids = Tacmach$ReactTemplate.New[/* pf_ids_of_hyps */11](gl);
                var match = Curry._4(Util$ReactTemplate.List[/* fold_right_i */81], (function (i, o, param) {
                        var args = param[2];
                        var match = o[0];
                        var c = match[1];
                        var match$1 = Typing$ReactTemplate.type_of(/* None */0, env, param[1], c);
                        var args$1 = Option$ReactTemplate.is_empty(match[2]) ? /* :: */[
                            c,
                            args
                          ] : args;
                        var match$2 = generalize_goal_gen(env, match$1[0], ids, i, o, match$1[1], param[0]);
                        return /* tuple */[
                                match$2[0],
                                match$2[1],
                                args$1
                              ];
                      }), 0, lconstr, /* tuple */[
                      concl,
                      sigma,
                      /* [] */0
                    ]);
                var args = match[2];
                var newcl = match[0];
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[1]), Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                  var match = Evarutil$ReactTemplate.new_evar(env, sigma, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* true */1], newcl);
                                  return /* tuple */[
                                          match[0],
                                          EConstr$ReactTemplate.applist(/* tuple */[
                                                match[1],
                                                args
                                              ])
                                        ];
                                })));
              }));
}

function generalize_gen(lconstr) {
  var lconstr$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var match = Redexpr$ReactTemplate.out_with_occurrences(param[0]);
          return /* tuple */[
                  /* tuple */[
                    match[0],
                    match[1],
                    /* None */0
                  ],
                  param[1]
                ];
        }), lconstr);
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var match = Curry._4(Util$ReactTemplate.List[/* fold_right_i */81], (function (param, param$1, param$2) {
                        return generalize_goal(gl, param, param$1, param$2);
                      }), 0, lconstr$1, /* tuple */[
                      Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl),
                      Tacmach$ReactTemplate.New[/* project */3](gl)
                    ]);
                var newcl = match[0];
                var match$1 = Typing$ReactTemplate.type_of(/* None */0, env, match[1], newcl);
                var map = function (param) {
                  var match = param[0];
                  if (Option$ReactTemplate.is_empty(match[2])) {
                    return /* Some */[match[1]];
                  } else {
                    return /* None */0;
                  }
                };
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$1[0]), apply_type(/* false */0, newcl, Curry._2(Util$ReactTemplate.List[/* map_filter */62], map, lconstr$1)));
              }));
}

function new_generalize_gen(lconstr) {
  return new_generalize_gen_let(Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    var match = param[0];
                    return /* tuple */[
                            /* tuple */[
                              match[0],
                              match[1],
                              /* None */0
                            ],
                            param[1]
                          ];
                  }), lconstr));
}

function generalize(l) {
  return new_generalize_gen_let(Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
                    return /* tuple */[
                            /* tuple */[
                              /* AllOccurrences */0,
                              c,
                              /* None */0
                            ],
                            /* Anonymous */0
                          ];
                  }), l));
}

function specialize(param, ipat) {
  var lbind = param[1];
  var c = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var match;
                if (lbind) {
                  var typ_of_c = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c);
                  var match$1 = EConstr$ReactTemplate.kind(sigma, c);
                  var c$1;
                  c$1 = match$1.tag === 7 ? EConstr$ReactTemplate.mkLetIn(/* tuple */[
                          /* Anonymous */0,
                          c,
                          typ_of_c,
                          EConstr$ReactTemplate.mkRel(1)
                        ]) : c;
                  var clause = Clenv$ReactTemplate.make_clenv_binding(env, sigma)(/* tuple */[
                        c$1,
                        typ_of_c
                      ], lbind);
                  var init = Unification$ReactTemplate.default_unify_flags(/* () */0);
                  var flags_000 = /* core_unify_flags */init[/* core_unify_flags */0];
                  var flags_001 = /* merge_unify_flags */init[/* merge_unify_flags */1];
                  var flags_002 = /* subterm_unify_flags */init[/* subterm_unify_flags */2];
                  var flags_003 = /* allow_K_in_toplevel_higher_order_unification */init[/* allow_K_in_toplevel_higher_order_unification */3];
                  var flags = /* record */[
                    flags_000,
                    flags_001,
                    flags_002,
                    flags_003,
                    /* resolve_evars : true */1
                  ];
                  var clause$1 = Clenv$ReactTemplate.clenv_unify_meta_types(/* Some */[flags], clause);
                  var sigma$1 = clause$1[/* evd */1];
                  var match$2 = Reductionops$ReactTemplate.whd_nored_stack(sigma$1, Clenv$ReactTemplate.clenv_value(clause$1));
                  var match$3 = EConstr$ReactTemplate.decompose_app(sigma$1, c$1);
                  var c_hd = match$3[0];
                  var liftrel = function (x) {
                    var match = EConstr$ReactTemplate.kind(sigma$1, x);
                    if (match.tag) {
                      return x;
                    } else {
                      return EConstr$ReactTemplate.mkRel(match[0] + 1 | 0);
                    }
                  };
                  var typ_of_c_hd = Tacmach$ReactTemplate.New[/* pf_get_type_of */7](gl, c_hd);
                  var match$4 = EConstr$ReactTemplate.decompose_prod_assum(sigma$1, typ_of_c_hd);
                  var rebuild_lambdas = function (sigma, lprd, args, hd, l) {
                    if (l) {
                      if (lprd) {
                        var match = lprd[0];
                        if (match.tag) {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                [
                                  "tactics.ml",
                                  2938,
                                  18
                                ]
                              ];
                        } else {
                          var l$prime = l[1];
                          var t = l[0];
                          var lp$prime = lprd[1];
                          if (Termops$ReactTemplate.occur_meta(sigma, t)) {
                            var match$1 = Typing$ReactTemplate.type_of(/* None */0, clause$1[/* env */0], sigma, t);
                            var liftedargs = Curry._2(Util$ReactTemplate.List[/* map */10], liftrel, args);
                            var match$2 = rebuild_lambdas(match$1[0], lp$prime, Util$ReactTemplate.$at(liftedargs, /* :: */[
                                      EConstr$ReactTemplate.mkRel(1),
                                      /* [] */0
                                    ]), hd, l$prime);
                            var sigma$1 = match$2[0];
                            var hd$prime$prime = Termops$ReactTemplate.subst_term(sigma$1, t, match$2[1]);
                            return /* tuple */[
                                    sigma$1,
                                    EConstr$ReactTemplate.mkLambda(/* tuple */[
                                          match[0],
                                          match$1[1],
                                          hd$prime$prime
                                        ])
                                  ];
                          } else {
                            var match$3 = rebuild_lambdas(sigma, lp$prime, Util$ReactTemplate.$at(args, /* :: */[
                                      t,
                                      /* [] */0
                                    ]), hd, l$prime);
                            return /* tuple */[
                                    match$3[0],
                                    match$3[1]
                                  ];
                          }
                        }
                      } else {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "tactics.ml",
                                2938,
                                18
                              ]
                            ];
                      }
                    } else {
                      return /* tuple */[
                              sigma,
                              EConstr$ReactTemplate.applist(/* tuple */[
                                    hd,
                                    Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                            return Evarutil$ReactTemplate.nf_evar(sigma, param);
                                          }), args)
                                  ])
                            ];
                    }
                  };
                  var match$5 = rebuild_lambdas(sigma$1, Curry._1(Util$ReactTemplate.List[/* rev */4], match$4[0]), /* [] */0, c_hd, match$2[1]);
                  match = /* tuple */[
                    Evd$ReactTemplate.clear_metas(match$5[0]),
                    match$5[1]
                  ];
                } else {
                  match = /* tuple */[
                    sigma,
                    c
                  ];
                }
                var term = match[1];
                var sigma$2 = match[0];
                var typ = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma$2, term);
                var match$6 = EConstr$ReactTemplate.kind(sigma$2, EConstr$ReactTemplate.decompose_app(sigma$2, EConstr$ReactTemplate.decompose_lam_assum(sigma$2, c)[1])[0]);
                var tac;
                var exit = 0;
                if (match$6.tag === 1) {
                  var id = match$6[0];
                  if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], id, Tacmach$ReactTemplate.New[/* pf_ids_of_hyps */11](gl))) {
                    var match$7 = prepare_intros_opt(/* false */0, /* IntroIdentifier */Block.__(0, [id]), /* MoveLast */1, ipat);
                    var naming = match$7[0];
                    var repl = do_replace(/* Some */[id], naming);
                    tac = Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](assert_before_then_gen(repl, naming, typ, match$7[1]), exact_no_check(term));
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                if (exit === 1) {
                  if (ipat) {
                    var match$8 = ipat[0];
                    var match$9 = prepare_intros(match$8[/* loc */1], /* false */0, /* IntroAnonymous */0, /* MoveLast */1, match$8[/* v */0]);
                    tac = Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](assert_before_then_gen(/* false */0, match$9[0], typ, match$9[1]), exact_no_check(term));
                  } else {
                    tac = Tacticals$ReactTemplate.New[/* tclTHENLAST */17](cut(typ), exact_no_check(term));
                  }
                }
                return Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](sigma$2), tac);
              }));
}

function unfold_body(x) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var match = Environ$ReactTemplate.lookup_named(x, env);
                var xval;
                xval = match.tag ? match[1] : CErrors$ReactTemplate.user_err(/* None */0, /* Some */["unfold_body"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](x), Pp$ReactTemplate.str(" is not a defined hypothesis.")));
                var xval$1 = EConstr$ReactTemplate.of_constr(xval);
                return Tacticals$ReactTemplate.New[/* afterHyp */46](x, (function (aft) {
                              var hl = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, cl) {
                                      return /* :: */[
                                              /* tuple */[
                                                Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl),
                                                /* InHyp */0
                                              ],
                                              cl
                                            ];
                                    }), aft, /* [] */0);
                              var rfun = function (_, _$1, c) {
                                return EConstr$ReactTemplate.Vars[/* replace_vars */8](/* :: */[
                                            /* tuple */[
                                              x,
                                              xval$1
                                            ],
                                            /* [] */0
                                          ], c);
                              };
                              var reducth = function (h) {
                                return reduct_in_hyp(/* None */0, rfun, h);
                              };
                              var reductc = reduct_in_concl(/* tuple */[
                                    rfun,
                                    /* DEFAULTcast */2
                                  ]);
                              return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                          Tacticals$ReactTemplate.New[/* tclMAP */20](reducth, hl),
                                          /* :: */[
                                            reductc,
                                            /* [] */0
                                          ]
                                        ]);
                            }));
              }));
}

function expand_hyp(id) {
  return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Tacticals$ReactTemplate.New[/* tclTRY */21](unfold_body(id)), clear(/* :: */[
                  id,
                  /* [] */0
                ]));
}

function warn_unused_intro_pattern(env, sigma) {
  return CWarnings$ReactTemplate.create("unused-intro-pattern", "tactics", /* None */0, (function (names) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Unused introduction "), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], Curry._1(Util$ReactTemplate.List[/* length */0], names), "pattern"))), Pp$ReactTemplate.str(": ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                                  return Miscprint$ReactTemplate.pr_intro_pattern((function (c) {
                                                return Printer$ReactTemplate.pr_econstr_env(env, sigma, Curry._2(c, env, sigma)[1]);
                                              }), param);
                                }), names));
              }));
}

function check_unused_names(env, sigma, names) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], names)) {
    return 0;
  } else {
    return warn_unused_intro_pattern(env, sigma)(/* None */0, names);
  }
}

function intropattern_of_name(gl, avoid, param) {
  if (param) {
    return /* IntroNaming */Block.__(1, [/* IntroIdentifier */Block.__(0, [new_fresh_id(avoid, param[0], gl)])]);
  } else {
    return /* IntroNaming */Block.__(1, [/* IntroAnonymous */0]);
  }
}

function consume_pattern(avoid, na, isdep, gl, _fullpat) {
  while(true) {
    var fullpat = _fullpat;
    if (fullpat) {
      var pat = fullpat[0];
      var match = pat[/* v */0];
      switch (match.tag | 0) {
        case 0 : 
            var exit = 0;
            if (match[0] !== 0) {
              if (isdep) {
                exit = 1;
              } else {
                _fullpat = fullpat[1];
                continue ;
                
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              var avoid$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], avoid, explicit_intro_names(fullpat[1]));
              return /* tuple */[
                      CAst$ReactTemplate.make(pat[/* loc */1], intropattern_of_name(gl, avoid$1, na)),
                      fullpat
                    ];
            }
            break;
        case 1 : 
            var match$1 = match[0];
            if (typeof match$1 === "number") {
              var names = fullpat[1];
              var avoid$2 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], avoid, explicit_intro_names(names));
              return /* tuple */[
                      CAst$ReactTemplate.make(pat[/* loc */1], intropattern_of_name(gl, avoid$2, na)),
                      names
                    ];
            } else if (match$1.tag) {
              var names$1 = fullpat[1];
              var avoid$3 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], avoid, explicit_intro_names(names$1));
              return /* tuple */[
                      CAst$ReactTemplate.make(pat[/* loc */1], /* IntroNaming */Block.__(1, [/* IntroIdentifier */Block.__(0, [new_fresh_id(avoid$3, match$1[0], gl)])])),
                      names$1
                    ];
            } else {
              return /* tuple */[
                      pat,
                      fullpat[1]
                    ];
            }
            break;
        case 2 : 
            return /* tuple */[
                    pat,
                    fullpat[1]
                  ];
        
      }
    } else {
      var eta = intropattern_of_name(gl, avoid, na);
      return /* tuple */[
              CAst$ReactTemplate.make(/* None */0, eta),
              /* [] */0
            ];
    }
  };
}

function re_intro_dependent_hypotheses(param, param$1) {
  var tophyp = param$1[1];
  var tophyp$1 = tophyp ? /* MoveAfter */Block.__(0, [tophyp[0]]) : /* MoveLast */1;
  var newlstatus = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
          var match = x[1];
          if (typeof match === "number" && match !== 0) {
            return /* tuple */[
                    x[0],
                    tophyp$1
                  ];
          } else {
            return x;
          }
        }), param[0]);
  return Tacticals$ReactTemplate.New[/* tclTHEN */2](intros_move(param[1]), intros_move(newlstatus));
}

function dest_intro_patterns(with_evars, avoid, thin, dest, pat, tac) {
  return intro_patterns_core(with_evars, /* true */1, avoid, /* [] */0, thin, dest, /* None */0, 0, tac, pat);
}

function update_dest(dests, param) {
  if (param) {
    var hyp = param[0];
    var tophyp = dests[1];
    var recargdests = dests[0];
    return /* tuple */[
            recargdests[0] ? recargdests : /* AfterFixedPosition */[/* Some */[hyp]],
            tophyp ? tophyp : /* Some */[hyp]
          ];
  } else {
    return dests;
  }
}

function get_recarg_dest(param) {
  var match = param[0][0];
  if (match) {
    return /* MoveAfter */Block.__(0, [match[0]]);
  } else {
    return /* MoveLast */1;
  }
}

function expand_projections(env, sigma, c) {
  var aux = function (env, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 16) {
      return Retyping$ReactTemplate.expand_projection(env, sigma, match[0], aux(env, match[1]), /* [] */0);
    } else {
      return Termops$ReactTemplate.map_constr_with_full_binders(sigma, EConstr$ReactTemplate.push_rel, aux, env, c);
    }
  };
  return aux(env, c);
}

var Shunt = Caml_exceptions.create("Tactics-ReactTemplate.Shunt");

function cook_sign(hyp0_opt, inhyps, indvars, env, sigma) {
  var toclear = [/* [] */0];
  var avoid = [Names$ReactTemplate.Id[/* Set */9][/* empty */0]];
  var decldeps = [/* [] */0];
  var ldeps = [/* [] */0];
  var rstatus = [/* [] */0];
  var lstatus = [/* [] */0];
  var before = [/* true */1];
  var maindep = [/* false */0];
  var seek_deps = function (env, decl, rhyp) {
    var decl$1 = Termops$ReactTemplate.map_named_decl(EConstr$ReactTemplate.of_constr, decl);
    var hyp = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl$1);
    if (hyp0_opt ? Names$ReactTemplate.Id[/* equal */0](hyp, hyp0_opt[0]) : /* false */0) {
      before[0] = /* false */0;
      toclear[0] = /* :: */[
        hyp,
        toclear[0]
      ];
      return /* MoveFirst */0;
    } else if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], hyp, indvars)) {
      toclear[0] = /* :: */[
        hyp,
        toclear[0]
      ];
      return rhyp;
    } else {
      var dephyp0 = Curry._1(Util$ReactTemplate.List[/* is_empty */45], inhyps) && Option$ReactTemplate.cata((function (id) {
              return Termops$ReactTemplate.occur_var_in_decl(env, sigma, id, decl$1);
            }), /* false */0, hyp0_opt);
      var depother = Curry._1(Util$ReactTemplate.List[/* is_empty */45], inhyps) && (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* exists */15], (function (id) {
                return Termops$ReactTemplate.occur_var_in_decl(env, sigma, id, decl$1);
              }), indvars) || Curry._2(Util$ReactTemplate.List[/* exists */21], (function (decl$prime) {
                return Termops$ReactTemplate.occur_var_in_decl(env, sigma, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl$prime), decl$1);
              }), decldeps[0]));
      if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], inhyps) && Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], hyp, inhyps) || dephyp0 || depother) {
        decldeps[0] = /* :: */[
          decl$1,
          decldeps[0]
        ];
        avoid[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], hyp, avoid[0]);
        maindep[0] = dephyp0 || maindep[0];
        if (before[0]) {
          toclear[0] = /* :: */[
            hyp,
            toclear[0]
          ];
          rstatus[0] = /* :: */[
            /* tuple */[
              hyp,
              rhyp
            ],
            rstatus[0]
          ];
        } else {
          toclear[0] = /* :: */[
            hyp,
            toclear[0]
          ];
          ldeps[0] = /* :: */[
            hyp,
            ldeps[0]
          ];
        }
        return /* MoveBefore */Block.__(1, [hyp]);
      } else {
        return /* MoveBefore */Block.__(1, [hyp]);
      }
    }
  };
  Environ$ReactTemplate.fold_named_context(seek_deps, env, /* MoveFirst */0);
  var compute_lstatus = function (lhyp, decl) {
    var hyp = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl);
    if (hyp0_opt ? Names$ReactTemplate.Id[/* equal */0](hyp, hyp0_opt[0]) : /* false */0) {
      throw [
            Shunt,
            lhyp
          ];
    }
    if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], hyp, ldeps[0])) {
      lstatus[0] = /* :: */[
        /* tuple */[
          hyp,
          lhyp
        ],
        lstatus[0]
      ];
      return lhyp;
    } else if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], hyp, toclear[0])) {
      return lhyp;
    } else {
      return /* MoveAfter */Block.__(0, [hyp]);
    }
  };
  try {
    Environ$ReactTemplate.fold_named_context_reverse(compute_lstatus, /* MoveLast */1, env);
    throw [
          Shunt,
          /* MoveLast */1
        ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Shunt) {
      var lhyp0 = exn[1];
      var lhyp0$1;
      if (typeof lhyp0 === "number") {
        if (lhyp0) {
          lhyp0$1 = /* None */0;
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "tactics.ml",
                  3383,
                  13
                ]
              ];
        }
      } else if (lhyp0.tag) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "tactics.ml",
                3383,
                13
              ]
            ];
      } else {
        lhyp0$1 = /* Some */[lhyp0[0]];
      }
      var statuslists_000 = lstatus[0];
      var statuslists_001 = Curry._1(Util$ReactTemplate.List[/* rev */4], rstatus[0]);
      var statuslists = /* tuple */[
        statuslists_000,
        statuslists_001
      ];
      var recargdests = /* AfterFixedPosition */[Option$ReactTemplate.is_empty(hyp0_opt) ? /* None */0 : lhyp0$1];
      return /* tuple */[
              statuslists,
              /* tuple */[
                recargdests,
                /* None */0
              ],
              toclear[0],
              decldeps[0],
              avoid[0],
              maindep[0]
            ];
    } else {
      throw exn;
    }
  }
}

function make_base(n, id) {
  if (n === 0 || n === 1) {
    return id;
  } else {
    return Names$ReactTemplate.Id[/* of_string */5](Nameops$ReactTemplate.atompart_of_id(Nameops$ReactTemplate.make_ident(Names$ReactTemplate.Id[/* to_string */7](id), /* Some */[0])));
  }
}

function make_up_names(n, ind_opt, cname) {
  var is_hyp = +(Nameops$ReactTemplate.atompart_of_id(cname) === "H");
  var base = Names$ReactTemplate.Id[/* to_string */7](make_base(n, cname));
  var ind_prefix = "IH";
  var base_ind = is_hyp ? (
      ind_opt ? Nameops$ReactTemplate.add_prefix(ind_prefix, Nametab$ReactTemplate.basename_of_global(ind_opt[0])) : Names$ReactTemplate.Id[/* of_string */5](ind_prefix)
    ) : Nameops$ReactTemplate.add_prefix(ind_prefix, cname);
  var hyprecname = make_base(n, base_ind);
  var avoid;
  if (n === 1 || n === 0) {
    avoid = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  } else {
    var avoid$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], Nameops$ReactTemplate.make_ident(Names$ReactTemplate.Id[/* to_string */7](hyprecname), /* None */0), Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], Nameops$ReactTemplate.make_ident(Names$ReactTemplate.Id[/* to_string */7](hyprecname), /* Some */[0])));
    avoid = Nameops$ReactTemplate.atompart_of_id(cname) !== "H" ? Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], Nameops$ReactTemplate.make_ident(base, /* Some */[0]), Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], Nameops$ReactTemplate.make_ident(base, /* None */0), avoid$1)) : avoid$1;
  }
  return /* tuple */[
          Names$ReactTemplate.Id[/* of_string */5](base),
          hyprecname,
          avoid
        ];
}

function error_ind_scheme(s) {
  var s$1 = Curry._1(Util$ReactTemplate.$$String[/* is_empty */26], s) ? s : s + " ";
  return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Tactics"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot recognize "), Pp$ReactTemplate.str(s$1)), Pp$ReactTemplate.str("an induction scheme.")));
}

var coq_heq_ref = Block.__(246, [(function () {
        return Coqlib$ReactTemplate.coq_reference("mkHEq", /* :: */[
                    "Logic",
                    /* :: */[
                      "JMeq",
                      /* [] */0
                    ]
                  ], "JMeq");
      })]);

function coq_heq(sigma) {
  var tag = coq_heq_ref.tag | 0;
  return Evarutil$ReactTemplate.new_global(sigma, tag === 250 ? coq_heq_ref[0] : (
                tag === 246 ? CamlinternalLazy.force_lazy_block(coq_heq_ref) : coq_heq_ref
              ));
}

function coq_heq_refl(sigma) {
  return Evarutil$ReactTemplate.new_global(sigma, Coqlib$ReactTemplate.coq_reference("mkHEq", /* :: */[
                  "Logic",
                  /* :: */[
                    "JMeq",
                    /* [] */0
                  ]
                ], "JMeq_refl"));
}

function mkEq(sigma, t, x, y) {
  var match = Evarutil$ReactTemplate.new_global(sigma, Coqlib$ReactTemplate.build_coq_eq(/* () */0));
  return /* tuple */[
          match[0],
          EConstr$ReactTemplate.mkApp(/* tuple */[
                match[1],
                /* array */[
                  t,
                  x,
                  y
                ]
              ])
        ];
}

function mkRefl(sigma, t, x) {
  var match = Evarutil$ReactTemplate.new_global(sigma, Coqlib$ReactTemplate.build_coq_eq_refl(/* () */0));
  return /* tuple */[
          match[0],
          EConstr$ReactTemplate.mkApp(/* tuple */[
                match[1],
                /* array */[
                  t,
                  x
                ]
              ])
        ];
}

function mkHEq(sigma, t, x, u, y) {
  var match = coq_heq(sigma);
  return /* tuple */[
          match[0],
          EConstr$ReactTemplate.mkApp(/* tuple */[
                match[1],
                /* array */[
                  t,
                  x,
                  u,
                  y
                ]
              ])
        ];
}

function mkHRefl(sigma, t, x) {
  var match = coq_heq_refl(sigma);
  return /* tuple */[
          match[0],
          EConstr$ReactTemplate.mkApp(/* tuple */[
                match[1],
                /* array */[
                  t,
                  x
                ]
              ])
        ];
}

function lift_togethern(n, l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (x, param) {
                  var n = param[1];
                  return /* tuple */[
                          /* :: */[
                            EConstr$ReactTemplate.Vars[/* lift */0](n, x),
                            param[0]
                          ],
                          n + 1 | 0
                        ];
                }), l, /* tuple */[
                /* [] */0,
                n
              ])[0];
}

function lift_list(l) {
  var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                return partial_arg(1, param);
              }), l);
}

function ids_of_constr(sigma, $staropt$star, vars, c) {
  var all = $staropt$star ? $staropt$star[0] : /* false */0;
  var aux = function (vars, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 1 : 
          return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], match[0], vars);
      case 9 : 
          var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
          var exit = 0;
          var ind;
          switch (match$1.tag | 0) {
            case 11 : 
                ind = match$1[0][0];
                exit = 1;
                break;
            case 12 : 
                ind = match$1[0][0][0];
                exit = 1;
                break;
            default:
              return EConstr$ReactTemplate.fold(sigma, aux, vars, c);
          }
          if (exit === 1) {
            var match$2 = Global$ReactTemplate.lookup_inductive(ind);
            return Util$ReactTemplate.$$Array[/* fold_left_from */43](all ? 0 : match$2[0][/* mind_nparams */5], aux, vars, match[1]);
          }
          break;
      default:
        return EConstr$ReactTemplate.fold(sigma, aux, vars, c);
    }
  };
  return aux(vars, c);
}

function decompose_indapp(sigma, f, args) {
  var match = EConstr$ReactTemplate.kind(sigma, f);
  var exit = 0;
  var ind;
  switch (match.tag | 0) {
    case 11 : 
        ind = match[0][0];
        exit = 1;
        break;
    case 12 : 
        ind = match[0][0][0];
        exit = 1;
        break;
    default:
      return /* tuple */[
              f,
              args
            ];
  }
  if (exit === 1) {
    var match$1 = Global$ReactTemplate.lookup_inductive(ind);
    var first = match$1[0][/* mind_nparams_rec */6];
    var match$2 = Util$ReactTemplate.$$Array[/* chop */46](first, args);
    return /* tuple */[
            EConstr$ReactTemplate.mkApp(/* tuple */[
                  f,
                  match$2[0]
                ]),
            match$2[1]
          ];
  }
  
}

function mk_term_eq(homogeneous, _, sigma, ty, t, ty$prime, t$prime) {
  if (homogeneous) {
    var match = mkEq(sigma, ty, t, t$prime);
    var match$1 = mkRefl(match[0], ty$prime, t$prime);
    return /* tuple */[
            match$1[0],
            /* tuple */[
              match[1],
              match$1[1]
            ]
          ];
  } else {
    var match$2 = mkHEq(sigma, ty, t, ty$prime, t$prime);
    var match$3 = mkHRefl(match$2[0], ty$prime, t$prime);
    return /* tuple */[
            match$3[0],
            /* tuple */[
              match$2[1],
              match$3[1]
            ]
          ];
  }
}

function make_abstract_generalize(env, id, typ, concl, dep, ctx, body, c, eqs, args, refls) {
  return Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                var eqslen = Curry._1(Util$ReactTemplate.List[/* length */0], eqs);
                var match;
                if (dep) {
                  var ty = EConstr$ReactTemplate.Vars[/* lift */0](1, c);
                  var homogeneous = Reductionops$ReactTemplate.is_conv(/* None */0, env, sigma)(ty, typ);
                  var match$1 = mk_term_eq(homogeneous, EConstr$ReactTemplate.push_rel_context(ctx, env), sigma, ty, EConstr$ReactTemplate.mkRel(1), typ, EConstr$ReactTemplate.mkVar(id));
                  var match$2 = match$1[1];
                  match = /* tuple */[
                    match$1[0],
                    EConstr$ReactTemplate.mkProd(/* tuple */[
                          /* Anonymous */0,
                          match$2[0],
                          EConstr$ReactTemplate.Vars[/* lift */0](1, concl)
                        ]),
                    /* array */[match$2[1]]
                  ];
                } else {
                  match = /* tuple */[
                    sigma,
                    concl,
                    /* array */[]
                  ];
                }
                var eqs$1 = lift_togethern(1, eqs);
                var abseqs = EConstr$ReactTemplate.it_mkProd_or_LetIn(EConstr$ReactTemplate.Vars[/* lift */0](eqslen, match[1]), Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                            return /* LocalAssum */Block.__(0, [
                                      /* Anonymous */0,
                                      x
                                    ]);
                          }), eqs$1));
                var decl = body ? /* LocalDef */Block.__(1, [
                      /* Name */[id],
                      body[0],
                      c
                    ]) : /* LocalAssum */Block.__(0, [
                      /* Name */[id],
                      c
                    ]);
                var genarg = EConstr$ReactTemplate.mkProd_or_LetIn(decl, abseqs);
                var genctyp = EConstr$ReactTemplate.it_mkProd_or_LetIn(genarg, ctx);
                var match$3 = Evarutil$ReactTemplate.new_evar(env, match[0], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* true */1], genctyp);
                var instc = EConstr$ReactTemplate.mkApp(/* tuple */[
                      match$3[1],
                      Util$ReactTemplate.$$Array[/* of_list */10](args)
                    ]);
                var instc$1 = Option$ReactTemplate.cata((function () {
                        return instc;
                      }), EConstr$ReactTemplate.mkApp(/* tuple */[
                          instc,
                          /* array */[EConstr$ReactTemplate.mkVar(id)]
                        ]), body);
                var appeqs = EConstr$ReactTemplate.mkApp(/* tuple */[
                      instc$1,
                      Util$ReactTemplate.$$Array[/* of_list */10](refls)
                    ]);
                return /* tuple */[
                        match$3[0],
                        EConstr$ReactTemplate.mkApp(/* tuple */[
                              appeqs,
                              match[2]
                            ])
                      ];
              }));
}

function hyps_of_vars(env, sigma, sign, nogen, hyps) {
  if (Curry._1(Names$ReactTemplate.Id[/* Set */9][/* is_empty */1], hyps)) {
    return /* [] */0;
  } else {
    return Curry._1(Context$ReactTemplate.Named[/* fold_inside */8]((function (param, d) {
                        var hl = param[1];
                        var hs = param[0];
                        var x = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
                        if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], x, nogen)) {
                          return /* tuple */[
                                  hs,
                                  hl
                                ];
                        } else if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], x, hs)) {
                          return /* tuple */[
                                  hs,
                                  /* :: */[
                                    x,
                                    hl
                                  ]
                                ];
                        } else {
                          var xvars = Termops$ReactTemplate.global_vars_set_of_decl(env, sigma, d);
                          if (Curry._1(Names$ReactTemplate.Id[/* Set */9][/* is_empty */1], Curry._2(Names$ReactTemplate.Id[/* Set */9][/* diff */8], xvars, hs))) {
                            return /* tuple */[
                                    hs,
                                    hl
                                  ];
                          } else {
                            return /* tuple */[
                                    Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], x, hs),
                                    /* :: */[
                                      x,
                                      hl
                                    ]
                                  ];
                          }
                        }
                      }), /* tuple */[
                      hyps,
                      /* [] */0
                    ]), sign)[1];
  }
}

var Seen = Caml_exceptions.create("Tactics-ReactTemplate.Seen");

function linear(sigma, vars, args) {
  var seen = [vars];
  try {
    Util$ReactTemplate.$$Array[/* iter */11]((function (i) {
            var rels = ids_of_constr(sigma, /* Some */[/* true */1], Names$ReactTemplate.Id[/* Set */9][/* empty */0], i);
            var seen$prime = Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], (function (id, acc) {
                    if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, acc)) {
                      throw Seen;
                    } else {
                      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, acc);
                    }
                  }), rels, seen[0]);
            seen[0] = seen$prime;
            return /* () */0;
          }), args);
    return /* true */1;
  }
  catch (exn){
    if (exn === Seen) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_defined_variable(env, id) {
  return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* is_local_def */6], EConstr$ReactTemplate.lookup_named(id, env));
}

function abstract_args(gl, generalize_vars, dep, id, defined, f, args) {
  var sigma = [Tacmach$ReactTemplate.New[/* project */3](gl)];
  var env = Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl);
  var concl = Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
  var dep$1 = dep || Termops$ReactTemplate.local_occur_var(sigma[0], id, concl);
  var avoid = [Names$ReactTemplate.Id[/* Set */9][/* empty */0]];
  var get_id = function (name) {
    var id = new_fresh_id(avoid[0], name ? name[0] : Names$ReactTemplate.Id[/* of_string */5]("gen_x"), gl);
    avoid[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid[0]);
    return id;
  };
  var aux = function (param, arg) {
    var env = param[9];
    var vars = param[8];
    var nongenvars = param[7];
    var refls = param[6];
    var eqs = param[5];
    var args = param[4];
    var c = param[3];
    var ctxenv = param[2];
    var ctx = param[1];
    var match = Reductionops$ReactTemplate.splay_prod_n(env, sigma[0], 1)(param[0]);
    var c$1 = match[1];
    var decl = Curry._1(Util$ReactTemplate.List[/* hd */1], match[0]);
    var match_000 = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
    var match_001 = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl);
    var argty = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, arg);
    var match$1 = Evarsolve$ReactTemplate.refresh_universes(/* None */0, /* None */0, /* None */0, /* Some */[/* true */1], env, sigma[0], match_001);
    var ty = match$1[1];
    sigma[0] = match$1[0];
    var lenctx = Curry._1(Util$ReactTemplate.List[/* length */0], ctx);
    var liftargty = EConstr$ReactTemplate.Vars[/* lift */0](lenctx, argty);
    var leq = Termops$ReactTemplate.constr_cmp(sigma[0], /* CUMUL */1, liftargty, ty);
    var match$2 = EConstr$ReactTemplate.kind(sigma[0], arg);
    var exit = 0;
    if (match$2.tag === 1) {
      var id = match$2[0];
      if (!is_defined_variable(env, id) && leq && !Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, nongenvars)) {
        return /* tuple */[
                EConstr$ReactTemplate.Vars[/* subst1 */4](arg, c$1),
                ctx,
                ctxenv,
                EConstr$ReactTemplate.mkApp(/* tuple */[
                      c,
                      /* array */[arg]
                    ]),
                args,
                eqs,
                refls,
                Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, nongenvars),
                Curry._2(Names$ReactTemplate.Id[/* Set */9][/* remove */5], id, vars),
                env
              ];
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var name = get_id(match_000);
      var decl_000 = /* Name */[name];
      var decl$1 = /* LocalAssum */Block.__(0, [
          decl_000,
          ty
        ]);
      var ctx$1 = /* :: */[
        decl$1,
        ctx
      ];
      var c$prime = EConstr$ReactTemplate.mkApp(/* tuple */[
            EConstr$ReactTemplate.Vars[/* lift */0](1, c),
            /* array */[EConstr$ReactTemplate.mkRel(1)]
          ]);
      var args$1 = /* :: */[
        arg,
        args
      ];
      var liftarg = EConstr$ReactTemplate.Vars[/* lift */0](Curry._1(Util$ReactTemplate.List[/* length */0], ctx$1), arg);
      var match$3;
      if (leq) {
        var match$4 = mkEq(sigma[0], EConstr$ReactTemplate.Vars[/* lift */0](1, ty), EConstr$ReactTemplate.mkRel(1), liftarg);
        var match$5 = mkRefl(match$4[0], EConstr$ReactTemplate.Vars[/* lift */0](-lenctx | 0, ty), arg);
        sigma[0] = match$5[0];
        match$3 = /* tuple */[
          match$4[1],
          match$5[1]
        ];
      } else {
        var match$6 = mkHEq(sigma[0], EConstr$ReactTemplate.Vars[/* lift */0](1, ty), EConstr$ReactTemplate.mkRel(1), liftargty, liftarg);
        var match$7 = mkHRefl(match$6[0], argty, arg);
        sigma[0] = match$7[0];
        match$3 = /* tuple */[
          match$6[1],
          match$7[1]
        ];
      }
      var eqs_000 = match$3[0];
      var eqs_001 = lift_list(eqs);
      var eqs$1 = /* :: */[
        eqs_000,
        eqs_001
      ];
      var refls_000 = match$3[1];
      var refls$1 = /* :: */[
        refls_000,
        refls
      ];
      var argvars = ids_of_constr(sigma[0], /* None */0, vars, arg);
      return /* tuple */[
              c$1,
              ctx$1,
              EConstr$ReactTemplate.push_rel(decl$1, ctxenv),
              c$prime,
              args$1,
              eqs$1,
              refls$1,
              nongenvars,
              Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], argvars, vars),
              env
            ];
    }
    
  };
  var match = decompose_indapp(sigma[0], f, args);
  var args$prime = match[1];
  var f$prime = match[0];
  var parvars = ids_of_constr(sigma[0], /* Some */[/* true */1], Names$ReactTemplate.Id[/* Set */9][/* empty */0], f$prime);
  var match$1;
  if (linear(sigma[0], parvars, args$prime)) {
    var match$2 = Util$ReactTemplate.$$Array[/* findi */31]((function (_, x) {
            if (EConstr$ReactTemplate.isVar(sigma[0], x)) {
              return is_defined_variable(env, EConstr$ReactTemplate.destVar(sigma[0], x));
            } else {
              return /* true */1;
            }
          }), args$prime);
    if (match$2) {
      var match$3 = Util$ReactTemplate.$$Array[/* chop */46](match$2[0], args$prime);
      match$1 = /* tuple */[
        /* true */1,
        EConstr$ReactTemplate.mkApp(/* tuple */[
              f$prime,
              match$3[0]
            ]),
        match$3[1]
      ];
    } else {
      match$1 = /* tuple */[
        /* false */0,
        f$prime,
        args$prime
      ];
    }
  } else {
    match$1 = /* tuple */[
      /* true */1,
      f,
      args
    ];
  }
  if (match$1[0]) {
    var f$prime$1 = match$1[1];
    var tyf$prime = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, f$prime$1);
    var match$4 = Util$ReactTemplate.$$Array[/* fold_left */15](aux, /* tuple */[
          tyf$prime,
          /* [] */0,
          env,
          f$prime$1,
          /* [] */0,
          /* [] */0,
          /* [] */0,
          Names$ReactTemplate.Id[/* Set */9][/* empty */0],
          Names$ReactTemplate.Id[/* Set */9][/* empty */0],
          env
        ], match$1[2]);
    var c$prime = match$4[3];
    var ctx = match$4[1];
    var args$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], match$4[4]);
    var refls = Curry._1(Util$ReactTemplate.List[/* rev */4], match$4[6]);
    var vars;
    if (generalize_vars) {
      var nogen = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, match$4[7]);
      vars = hyps_of_vars(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), Tacmach$ReactTemplate.New[/* project */3](gl), Proofview$ReactTemplate.Goal[/* hyps */3](gl), nogen, match$4[8]);
    } else {
      vars = /* [] */0;
    }
    var match$5 = defined ? /* tuple */[
        /* Some */[c$prime],
        Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, match$4[2], sigma[0], c$prime)
      ] : /* tuple */[
        /* None */0,
        c$prime
      ];
    var typ = Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](id, gl);
    var tac = make_abstract_generalize(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), id, typ, concl, dep$1, ctx, match$5[0], match$5[1], match$4[5], args$1, refls);
    var tac$1 = Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](sigma[0]), tac);
    return /* Some */[/* tuple */[
              tac$1,
              dep$1,
              Curry._1(Util$ReactTemplate.List[/* length */0], ctx) + 1 | 0,
              vars
            ]];
  } else {
    return /* None */0;
  }
}

function abstract_generalize($staropt$star, $staropt$star$1, id) {
  var generalize_vars = $staropt$star ? $staropt$star[0] : /* true */1;
  var force_dep = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                Coqlib$ReactTemplate.check_required_library(Coqlib$ReactTemplate.jmeq_module_name);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var oldid = Tacmach$ReactTemplate.New[/* pf_get_new_id */10](id, gl);
                var match = Tacmach$ReactTemplate.New[/* pf_get_hyp */14](id, gl);
                var match$1;
                if (match.tag) {
                  var match$2 = EConstr$ReactTemplate.decompose_app(sigma, match[1]);
                  match$1 = /* tuple */[
                    match$2[0],
                    match$2[1],
                    /* true */1,
                    id,
                    oldid
                  ];
                } else {
                  var match$3 = EConstr$ReactTemplate.decompose_app(sigma, match[1]);
                  match$1 = /* tuple */[
                    match$3[0],
                    match$3[1],
                    /* false */0,
                    id,
                    oldid
                  ];
                }
                var oldid$1 = match$1[4];
                var id$1 = match$1[3];
                var args = match$1[1];
                if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], args)) {
                  return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                } else {
                  var args$1 = Util$ReactTemplate.$$Array[/* of_list */10](args);
                  var newc = abstract_args(gl, generalize_vars, force_dep, id$1, match$1[2], match$1[0], args$1);
                  if (newc) {
                    var match$4 = newc[0];
                    var vars = match$4[3];
                    var n = match$4[2];
                    var tac = match$4[0];
                    var tac$1 = match$4[1] ? Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                            tac,
                            /* :: */[
                              rename_hyp(/* :: */[
                                    /* tuple */[
                                      id$1,
                                      oldid$1
                                    ],
                                    /* [] */0
                                  ]),
                              /* :: */[
                                Tacticals$ReactTemplate.New[/* tclDO */28](n, intro),
                                /* :: */[
                                  generalize_dep(/* Some */[/* true */1], EConstr$ReactTemplate.mkVar(oldid$1)),
                                  /* [] */0
                                ]
                              ]
                            ]
                          ]) : Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                            tac,
                            /* :: */[
                              clear(/* :: */[
                                    id$1,
                                    /* [] */0
                                  ]),
                              /* :: */[
                                Tacticals$ReactTemplate.New[/* tclDO */28](n, intro),
                                /* [] */0
                              ]
                            ]
                          ]);
                    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], vars)) {
                      return tac$1;
                    } else {
                      return Tacticals$ReactTemplate.New[/* tclTHEN */2](tac$1, Tacticals$ReactTemplate.New[/* tclFIRST */23](/* :: */[
                                      revert(vars),
                                      /* :: */[
                                        Tacticals$ReactTemplate.New[/* tclMAP */20]((function (id) {
                                                return Tacticals$ReactTemplate.New[/* tclTRY */21](generalize_dep(/* Some */[/* true */1], EConstr$ReactTemplate.mkVar(id)));
                                              }), vars),
                                        /* [] */0
                                      ]
                                    ]));
                    }
                  } else {
                    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                  }
                }
              }));
}

function compare_upto_variables(sigma, x, y) {
  var compare = function (x, y) {
    if ((EConstr$ReactTemplate.isVar(sigma, x) || EConstr$ReactTemplate.isRel(sigma, x)) && (EConstr$ReactTemplate.isVar(sigma, y) || EConstr$ReactTemplate.isRel(sigma, y))) {
      return /* true */1;
    } else {
      return EConstr$ReactTemplate.compare_constr(sigma, compare, x, y);
    }
  };
  return compare(x, y);
}

function specialize_eqs(id) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function () {
                var msg = Pp$ReactTemplate.str("Specialization not allowed on dependent hypotheses");
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Curry._2(Proofview$ReactTemplate.tclOR, clear(/* :: */[
                                    id,
                                    /* [] */0
                                  ]), (function () {
                                  return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, msg);
                                })), (function () {
                              var id$1 = id;
                              return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                            var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                                            var ty = Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](id$1, gl);
                                            var evars = [Proofview$ReactTemplate.Goal[/* sigma */5](gl)];
                                            var unif = function (env, evars, c1, c2) {
                                              if (compare_upto_variables(evars[0], c1, c2)) {
                                                return Evarconv$ReactTemplate.e_conv(env, /* None */0, evars, c1, c2);
                                              } else {
                                                return /* false */0;
                                              }
                                            };
                                            var aux = function (_in_eqs, _ctx, _acc, _ty) {
                                              while(true) {
                                                var ty = _ty;
                                                var acc = _acc;
                                                var ctx = _ctx;
                                                var in_eqs = _in_eqs;
                                                var t = EConstr$ReactTemplate.kind(evars[0], ty);
                                                if (t.tag === 6) {
                                                  var b = t[2];
                                                  var t$1 = t[1];
                                                  var match = EConstr$ReactTemplate.kind(evars[0], t$1);
                                                  var exit = 0;
                                                  if (match.tag === 9) {
                                                    var match$1 = match[1];
                                                    var len = match$1.length;
                                                    var eq = match[0];
                                                    if (len !== 3) {
                                                      if (len !== 4) {
                                                        exit = 1;
                                                      } else {
                                                        var eqty = match$1[0];
                                                        var x = match$1[1];
                                                        var eqty$prime = match$1[2];
                                                        var y = match$1[3];
                                                        var tag = coq_heq_ref.tag | 0;
                                                        if (EConstr$ReactTemplate.is_global(evars[0], tag === 250 ? coq_heq_ref[0] : (
                                                                  tag === 246 ? CamlinternalLazy.force_lazy_block(coq_heq_ref) : coq_heq_ref
                                                                ), eq)) {
                                                          var match$2 = EConstr$ReactTemplate.Vars[/* noccur_between */13](evars[0], 1, Curry._1(Util$ReactTemplate.List[/* length */0], ctx), x) ? /* tuple */[
                                                              eqty$prime,
                                                              y
                                                            ] : /* tuple */[
                                                              eqty,
                                                              x
                                                            ];
                                                          var c = match$2[1];
                                                          var eqt = match$2[0];
                                                          var pt = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                                eq,
                                                                /* array */[
                                                                  eqt,
                                                                  c,
                                                                  eqt,
                                                                  c
                                                                ]
                                                              ]);
                                                          var ind = EConstr$ReactTemplate.destInd(evars[0], eq);
                                                          var p = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                                EConstr$ReactTemplate.mkConstructUi(/* tuple */[
                                                                      ind,
                                                                      0
                                                                    ]),
                                                                /* array */[
                                                                  eqt,
                                                                  c
                                                                ]
                                                              ]);
                                                          if (unif(EConstr$ReactTemplate.push_rel_context(ctx, env), evars, pt, t$1)) {
                                                            _ty = EConstr$ReactTemplate.Vars[/* subst1 */4](p, b);
                                                            _acc = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                                  acc,
                                                                  /* array */[p]
                                                                ]);
                                                            _in_eqs = /* true */1;
                                                            continue ;
                                                            
                                                          } else {
                                                            return /* tuple */[
                                                                    acc,
                                                                    in_eqs,
                                                                    ctx,
                                                                    ty
                                                                  ];
                                                          }
                                                        } else {
                                                          exit = 1;
                                                        }
                                                      }
                                                    } else {
                                                      var eqty$1 = match$1[0];
                                                      var x$1 = match$1[1];
                                                      var y$1 = match$1[2];
                                                      var tag$1 = Coqlib$ReactTemplate.coq_eq_ref.tag | 0;
                                                      if (EConstr$ReactTemplate.is_global(evars[0], tag$1 === 250 ? Coqlib$ReactTemplate.coq_eq_ref[0] : (
                                                                tag$1 === 246 ? CamlinternalLazy.force_lazy_block(Coqlib$ReactTemplate.coq_eq_ref) : Coqlib$ReactTemplate.coq_eq_ref
                                                              ), eq)) {
                                                        var c$1 = EConstr$ReactTemplate.Vars[/* noccur_between */13](evars[0], 1, Curry._1(Util$ReactTemplate.List[/* length */0], ctx), x$1) ? y$1 : x$1;
                                                        var pt$1 = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                              eq,
                                                              /* array */[
                                                                eqty$1,
                                                                c$1,
                                                                c$1
                                                              ]
                                                            ]);
                                                        var ind$1 = EConstr$ReactTemplate.destInd(evars[0], eq);
                                                        var p$1 = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                              EConstr$ReactTemplate.mkConstructUi(/* tuple */[
                                                                    ind$1,
                                                                    0
                                                                  ]),
                                                              /* array */[
                                                                eqty$1,
                                                                c$1
                                                              ]
                                                            ]);
                                                        if (unif(EConstr$ReactTemplate.push_rel_context(ctx, env), evars, pt$1, t$1)) {
                                                          _ty = EConstr$ReactTemplate.Vars[/* subst1 */4](p$1, b);
                                                          _acc = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                                acc,
                                                                /* array */[p$1]
                                                              ]);
                                                          _in_eqs = /* true */1;
                                                          continue ;
                                                          
                                                        } else {
                                                          return /* tuple */[
                                                                  acc,
                                                                  in_eqs,
                                                                  ctx,
                                                                  ty
                                                                ];
                                                        }
                                                      } else {
                                                        exit = 1;
                                                      }
                                                    }
                                                  } else {
                                                    exit = 1;
                                                  }
                                                  if (exit === 1) {
                                                    if (in_eqs) {
                                                      return /* tuple */[
                                                              acc,
                                                              in_eqs,
                                                              ctx,
                                                              ty
                                                            ];
                                                    } else {
                                                      var e = Evarutil$ReactTemplate.e_new_evar(EConstr$ReactTemplate.push_rel_context(ctx, env), evars, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, t$1);
                                                      _ty = b;
                                                      _acc = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                            EConstr$ReactTemplate.Vars[/* lift */0](1, acc),
                                                            /* array */[EConstr$ReactTemplate.mkRel(1)]
                                                          ]);
                                                      _ctx = /* :: */[
                                                        /* LocalDef */Block.__(1, [
                                                            t[0],
                                                            e,
                                                            t$1
                                                          ]),
                                                        ctx
                                                      ];
                                                      _in_eqs = /* false */0;
                                                      continue ;
                                                      
                                                    }
                                                  }
                                                  
                                                } else {
                                                  return /* tuple */[
                                                          acc,
                                                          in_eqs,
                                                          ctx,
                                                          ty
                                                        ];
                                                }
                                              };
                                            };
                                            var match = aux(/* false */0, /* [] */0, EConstr$ReactTemplate.mkVar(id$1), ty);
                                            var ctx$prime = Evarutil$ReactTemplate.nf_rel_context_evar(evars[0], match[2]);
                                            var ctx$prime$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (decl) {
                                                    if (!decl.tag || !EConstr$ReactTemplate.isEvar(evars[0], decl[1])) {
                                                      return decl;
                                                    } else {
                                                      return /* LocalAssum */Block.__(0, [
                                                                decl[0],
                                                                decl[2]
                                                              ]);
                                                    }
                                                  }), ctx$prime);
                                            var ty$prime = EConstr$ReactTemplate.it_mkProd_or_LetIn(match[3], ctx$prime$prime);
                                            var acc$prime = EConstr$ReactTemplate.it_mkLambda_or_LetIn(match[0], ctx$prime$prime);
                                            var ty$prime$1 = Tacred$ReactTemplate.whd_simpl(env, evars[0], ty$prime);
                                            var acc$prime$1 = Tacred$ReactTemplate.whd_simpl(env, evars[0], acc$prime);
                                            var ty$prime$2 = Evarutil$ReactTemplate.nf_evar(evars[0], ty$prime$1);
                                            if (match[1]) {
                                              return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](internal_cut(/* None */0)(/* true */1, id$1, ty$prime$2), exact_no_check(acc$prime$1));
                                            } else {
                                              return Tacticals$ReactTemplate.New[/* tclFAIL */3](0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Nothing to do in hypothesis "), Names$ReactTemplate.Id[/* print */8](id$1)));
                                            }
                                          }));
                            }));
              }));
}

function occur_rel(sigma, n, c) {
  return 1 - EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, n, c);
}

function decompose_paramspred_branch_args(sigma, elimt) {
  var cut_noccur = function (_elimt, _acc2) {
    while(true) {
      var acc2 = _acc2;
      var elimt = _elimt;
      var match = EConstr$ReactTemplate.kind(sigma, elimt);
      switch (match.tag | 0) {
        case 6 : 
            var elimt$prime = match[2];
            var tpe = match[1];
            var match$1 = EConstr$ReactTemplate.decompose_app(sigma, EConstr$ReactTemplate.decompose_prod_assum(sigma, tpe)[1]);
            if (!occur_rel(sigma, 1, elimt$prime) && EConstr$ReactTemplate.isRel(sigma, match$1[0])) {
              _acc2 = /* :: */[
                /* LocalAssum */Block.__(0, [
                    match[0],
                    tpe
                  ]),
                acc2
              ];
              _elimt = elimt$prime;
              continue ;
              
            } else {
              var match$2 = EConstr$ReactTemplate.decompose_prod_assum(sigma, elimt);
              return /* tuple */[
                      acc2,
                      match$2[0],
                      match$2[1]
                    ];
            }
            break;
        case 0 : 
        case 9 : 
            return /* tuple */[
                    acc2,
                    /* [] */0,
                    elimt
                  ];
        default:
          return error_ind_scheme("");
      }
    };
  };
  var cut_occur = function (_elimt, _acc1) {
    while(true) {
      var acc1 = _acc1;
      var elimt = _elimt;
      var match = EConstr$ReactTemplate.kind(sigma, elimt);
      switch (match.tag | 0) {
        case 6 : 
            var c = match[2];
            if (occur_rel(sigma, 1, c)) {
              _acc1 = /* :: */[
                /* LocalAssum */Block.__(0, [
                    match[0],
                    match[1]
                  ]),
                acc1
              ];
              _elimt = c;
              continue ;
              
            } else {
              var match$1 = cut_noccur(elimt, /* [] */0);
              return /* tuple */[
                      acc1,
                      match$1[0],
                      match$1[1],
                      match$1[2]
                    ];
            }
            break;
        case 0 : 
        case 9 : 
            return /* tuple */[
                    acc1,
                    /* [] */0,
                    /* [] */0,
                    elimt
                  ];
        default:
          return error_ind_scheme("");
      }
    };
  };
  var match = cut_occur(elimt, /* [] */0);
  var acc2 = match[1];
  if (acc2) {
    return /* tuple */[
            match[0],
            acc2,
            match[2],
            match[3]
          ];
  } else {
    var match$1 = EConstr$ReactTemplate.decompose_prod_assum(sigma, elimt);
    var ccl = match$1[1];
    var match$2 = EConstr$ReactTemplate.decompose_app(sigma, ccl);
    var match$3 = EConstr$ReactTemplate.kind(sigma, match$2[0]);
    if (match$3.tag) {
      return error_ind_scheme("");
    } else {
      var match$4 = Curry._2(Util$ReactTemplate.List[/* chop */99], match$3[0] - 1 | 0, match$1[0]);
      return /* tuple */[
              match$4[1],
              /* [] */0,
              match$4[0],
              ccl
            ];
    }
  }
}

function exchange_hd_app(sigma, subst_hd, t) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  return EConstr$ReactTemplate.mkApp(/* tuple */[
              subst_hd,
              Util$ReactTemplate.$$Array[/* of_list */10](match[1])
            ]);
}

function compute_elim_sig(sigma, elimc, elimt) {
  var match = decompose_paramspred_branch_args(sigma, elimt);
  var conclusion = match[3];
  var args_indargs = match[2];
  var branches = match[1];
  var params_preds = match[0];
  var ccl = exchange_hd_app(sigma, EConstr$ReactTemplate.mkVar(Names$ReactTemplate.Id[/* of_string */5]("__QI_DUMMY__")), conclusion);
  var concl_with_args = EConstr$ReactTemplate.it_mkProd_or_LetIn(ccl, args_indargs);
  var nparams = Curry._1(Int$ReactTemplate.$$Set[/* cardinal */18], Termops$ReactTemplate.free_rels(sigma, concl_with_args));
  var match$1 = Curry._2(Util$ReactTemplate.List[/* chop */99], Curry._1(Util$ReactTemplate.List[/* length */0], params_preds) - nparams | 0, params_preds);
  var params = match$1[1];
  var preds = match$1[0];
  var res = /* record */[
    /* elimc */elimc,
    /* elimt */elimt,
    /* indref : None */0,
    /* params */params,
    /* nparams */nparams,
    /* predicates */preds,
    /* npredicates */Curry._1(Util$ReactTemplate.List[/* length */0], preds),
    /* branches */branches,
    /* nbranches */Curry._1(Util$ReactTemplate.List[/* length */0], branches),
    /* args */args_indargs,
    /* nargs */Curry._1(Util$ReactTemplate.List[/* length */0], args_indargs),
    /* indarg : None */0,
    /* concl */conclusion,
    /* indarg_in_concl : false */0,
    /* farg_in_concl */EConstr$ReactTemplate.isApp(sigma, ccl) && EConstr$ReactTemplate.isApp(sigma, last_arg(sigma, ccl))
  ];
  try {
    if (res[/* farg_in_concl */14]) {
      var newrecord = res.slice();
      newrecord[/* indarg */11] = /* None */0;
      newrecord[/* indarg_in_concl */13] = /* false */0;
      newrecord[/* farg_in_concl */14] = /* true */1;
      res = newrecord;
      throw Pervasives.Exit;
    }
    if (!res[/* nargs */10]) {
      throw Pervasives.Exit;
    }
    var match$2 = Curry._1(Util$ReactTemplate.List[/* hd */1], args_indargs);
    if (match$2.tag) {
      error_ind_scheme("");
    } else {
      var match$3 = EConstr$ReactTemplate.decompose_app(sigma, match$2[1]);
      var match$4 = EConstr$ReactTemplate.kind(sigma, match$3[0]);
      var hi_is_ind;
      switch (match$4.tag | 0) {
        case 1 : 
        case 10 : 
        case 11 : 
        case 12 : 
            hi_is_ind = /* true */1;
            break;
        default:
          hi_is_ind = /* false */0;
      }
      var hi_args_enough = +(Curry._1(Util$ReactTemplate.List[/* length */0], match$3[1]) === ((Curry._1(Util$ReactTemplate.List[/* length */0], params) + res[/* nargs */10] | 0) - 1 | 0));
      if (hi_is_ind && hi_args_enough) {
        var newrecord$1 = res.slice();
        newrecord$1[/* args */9] = Curry._1(Util$ReactTemplate.List[/* tl */2], res[/* args */9]);
        newrecord$1[/* nargs */10] = res[/* nargs */10] - 1 | 0;
        newrecord$1[/* indarg */11] = /* Some */[Curry._1(Util$ReactTemplate.List[/* hd */1], res[/* args */9])];
        newrecord$1[/* indarg_in_concl */13] = occur_rel(sigma, 1, ccl);
        res = newrecord$1;
      } else {
        throw Pervasives.Exit;
      }
      throw Pervasives.Exit;
    }
    throw Pervasives.Exit;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      var match$5 = res[/* indarg */11];
      if (match$5) {
        var match$6 = match$5[0];
        if (match$6.tag) {
          return error_ind_scheme("");
        } else {
          var match$7 = EConstr$ReactTemplate.decompose_app(sigma, match$6[1]);
          try {
            var newrecord$2 = res.slice();
            newrecord$2[/* indref */2] = /* Some */[Termops$ReactTemplate.global_of_constr(sigma, match$7[0])[0]];
            return newrecord$2;
          }
          catch (raw_e){
            var e = Js_exn.internalToOCamlException(raw_e);
            if (CErrors$ReactTemplate.noncritical(e)) {
              return error("Cannot find the inductive type of the inductive scheme.");
            } else {
              throw e;
            }
          }
        }
      } else {
        return res;
      }
    } else {
      throw exn;
    }
  }
}

function compute_scheme_signature(evd, scheme, names_info, ind_type_guess) {
  var match = EConstr$ReactTemplate.decompose_app(evd, scheme[/* concl */12]);
  var f = match[0];
  var match$1 = scheme[/* indarg */11];
  var match$2;
  if (match$1) {
    var match$3 = match$1[0];
    if (match$3.tag) {
      match$2 = error("Strange letin, cannot recognize an induction scheme.");
    } else {
      var match$4 = EConstr$ReactTemplate.decompose_app(evd, match$3[1]);
      var indargs = match$4[1];
      var indhd = match$4[0];
      var cond = function (hd) {
        return EConstr$ReactTemplate.eq_constr(evd, hd, indhd);
      };
      var check_concl = function (is_pred, p) {
        var ccl_arg_ok = +(Curry._2(is_pred, (p + scheme[/* nargs */10] | 0) + 1 | 0, f) === /* IndArg */1);
        var ind_is_ok = Curry._3(Util$ReactTemplate.List[/* equal */44], (function (c1, c2) {
                return EConstr$ReactTemplate.eq_constr(evd, c1, c2);
              }), Curry._2(Util$ReactTemplate.List[/* lastn */106], scheme[/* nargs */10], indargs), Context$ReactTemplate.Rel[/* to_extended_list */12](EConstr$ReactTemplate.mkRel, 0, scheme[/* args */9]));
        if (ccl_arg_ok && ind_is_ok) {
          return 0;
        } else {
          return error_ind_scheme("the conclusion of");
        }
      };
      match$2 = /* tuple */[
        cond,
        check_concl
      ];
    }
  } else {
    var cond$1 = function (hd) {
      if (EConstr$ReactTemplate.eq_constr(evd, hd, ind_type_guess)) {
        return 1 - scheme[/* farg_in_concl */14];
      } else {
        return /* false */0;
      }
    };
    match$2 = /* tuple */[
      cond$1,
      (function (_, _$1) {
          return /* () */0;
        })
    ];
  }
  var check_concl$1 = match$2[1];
  var cond$2 = match$2[0];
  var is_pred = function (n, c) {
    var hd = EConstr$ReactTemplate.decompose_app(evd, c)[0];
    var match = EConstr$ReactTemplate.kind(evd, hd);
    if (match.tag) {
      if (Curry._1(cond$2, hd)) {
        return /* RecArg */0;
      } else {
        return /* OtherArg */2;
      }
    } else {
      var q = match[0];
      if (n < q && q <= (n + scheme[/* npredicates */6] | 0)) {
        return /* IndArg */1;
      } else if (Curry._1(cond$2, hd)) {
        return /* RecArg */0;
      } else {
        return /* OtherArg */2;
      }
    }
  };
  var check_branch = function (p, c) {
    var match = EConstr$ReactTemplate.kind(evd, c);
    switch (match.tag | 0) {
      case 6 : 
          var c$1 = match[2];
          return /* :: */[
                  /* tuple */[
                    is_pred(p, match[1]),
                    /* true */1,
                    1 - EConstr$ReactTemplate.Vars[/* noccurn */12](evd, 1, c$1)
                  ],
                  check_branch(p + 1 | 0, c$1)
                ];
      case 8 : 
          var c$2 = match[3];
          return /* :: */[
                  /* tuple */[
                    /* OtherArg */2,
                    /* false */0,
                    1 - EConstr$ReactTemplate.Vars[/* noccurn */12](evd, 1, c$2)
                  ],
                  check_branch(p + 1 | 0, c$2)
                ];
      default:
        if (is_pred(p, c) === /* IndArg */1) {
          return /* [] */0;
        } else {
          throw Pervasives.Exit;
        }
    }
  };
  var find_branches = function (p, lbrch) {
    if (lbrch) {
      var match = lbrch[0];
      if (match.tag) {
        return error_ind_scheme("the branches of");
      } else {
        try {
          var lchck_brch = check_branch(p, match[1]);
          var n = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (n, param) {
                  if (param[0]) {
                    return n;
                  } else {
                    return n + 1 | 0;
                  }
                }), 0, lchck_brch);
          var match$1 = make_up_names(n, scheme[/* indref */2], names_info);
          var hyprecname = match$1[1];
          var recvarname = match$1[0];
          var namesign = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  var b = param[0];
                  return /* tuple */[
                          b,
                          param[1],
                          param[2],
                          b === /* IndArg */1 ? hyprecname : recvarname
                        ];
                }), lchck_brch);
          return /* :: */[
                  /* tuple */[
                    match$1[2],
                    namesign
                  ],
                  find_branches(p + 1 | 0, lbrch[1])
                ];
        }
        catch (exn){
          if (exn === Pervasives.Exit) {
            return error_ind_scheme("the branches of");
          } else {
            throw exn;
          }
        }
      }
    } else {
      Curry._2(check_concl$1, is_pred, p);
      return /* [] */0;
    }
  };
  return Util$ReactTemplate.$$Array[/* of_list */10](find_branches(0, Curry._1(Util$ReactTemplate.List[/* rev */4], scheme[/* branches */7])));
}

function compute_elim_signature(param, names_info) {
  var match = param[1];
  var evd = param[0];
  var scheme = compute_elim_sig(evd, /* Some */[match[0]], match[1]);
  return /* tuple */[
          evd,
          /* tuple */[
            compute_scheme_signature(evd, scheme, names_info, param[2]),
            scheme
          ]
        ];
}

function guess_elim(isrec, dep, s, hyp0, gl) {
  var tmptyp0 = Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](hyp0, gl);
  var match = Tacmach$ReactTemplate.New[/* pf_reduce_to_quantified_ind */18](gl, tmptyp0);
  var match$1 = match[0];
  var u = match$1[1];
  var mind = match$1[0];
  var match$2;
  if (isrec && !is_nonrec(mind)) {
    match$2 = find_ind_eliminator(mind, s, gl);
  } else {
    var env = Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl);
    var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
    var u$1 = EConstr$ReactTemplate.EInstance[/* kind */1](Tacmach$ReactTemplate.New[/* project */3](gl), u);
    if (dep) {
      var match$3 = Indrec$ReactTemplate.build_case_analysis_scheme(env, sigma, /* tuple */[
            mind,
            u$1
          ], /* true */1, s);
      var ind = EConstr$ReactTemplate.of_constr(match$3[1]);
      match$2 = /* tuple */[
        match$3[0],
        ind
      ];
    } else {
      var match$4 = Indrec$ReactTemplate.build_case_analysis_scheme_default(env, sigma, /* tuple */[
            mind,
            u$1
          ], s);
      var ind$1 = EConstr$ReactTemplate.of_constr(match$4[1]);
      match$2 = /* tuple */[
        match$4[0],
        ind$1
      ];
    }
  }
  var elimc = match$2[1];
  var elimt = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, elimc);
  return /* tuple */[
          match$2[0],
          /* tuple */[
            /* tuple */[
              elimc,
              /* NoBindings */0
            ],
            elimt
          ],
          EConstr$ReactTemplate.mkIndU(/* tuple */[
                mind,
                u
              ])
        ];
}

function given_elim(hyp0, e, gl) {
  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
  var tmptyp0 = Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](hyp0, gl);
  var match = EConstr$ReactTemplate.decompose_app(sigma, EConstr$ReactTemplate.decompose_prod(sigma, tmptyp0)[1]);
  var elimt = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, e[0]);
  return /* tuple */[
          Tacmach$ReactTemplate.New[/* project */3](gl),
          /* tuple */[
            e,
            elimt
          ],
          match[0]
        ];
}

function find_induction_type(isrec, elim, hyp0, gl) {
  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
  var match;
  if (elim) {
    var match$1 = given_elim(hyp0, elim[0], gl);
    var match$2 = match$1[1];
    var elimt = match$2[1];
    var elimc = match$2[0];
    var scheme = compute_elim_sig(sigma, /* Some */[elimc], elimt);
    if (Option$ReactTemplate.is_empty(scheme[/* indarg */11])) {
      error("Cannot find induction type");
    }
    var indsign = compute_scheme_signature(match$1[0], scheme, hyp0, match$1[2]);
    var elim_000 = /* record */[
      /* elimindex : Some */[-1],
      /* elimrename : None */0,
      /* elimbody */elimc
    ];
    var elim$1 = /* tuple */[
      elim_000,
      elimt
    ];
    match = /* tuple */[
      scheme,
      /* ElimUsing */Block.__(0, [
          elim$1,
          indsign
        ])
    ];
  } else {
    var sort = Tacticals$ReactTemplate.New[/* elimination_sort_of_goal */50](gl);
    var match$3 = guess_elim(isrec, /* false */0, sort, hyp0, gl);
    var match$4 = match$3[1];
    var scheme$1 = compute_elim_sig(sigma, /* Some */[match$4[0]], match$4[1]);
    match = /* tuple */[
      scheme$1,
      /* ElimOver */Block.__(1, [
          isrec,
          hyp0
        ])
    ];
  }
  var scheme$2 = match[0];
  var match$5 = scheme$2[/* indref */2];
  if (match$5) {
    return /* tuple */[
            match$5[0],
            scheme$2[/* nparams */4],
            match[1]
          ];
  } else {
    return error_ind_scheme("");
  }
}

function get_elim_signature(elim, hyp0, gl) {
  return compute_elim_signature(given_elim(hyp0, elim, gl), hyp0);
}

function is_functional_induction(elimc, gl) {
  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
  var scheme = compute_elim_sig(sigma, /* Some */[elimc], Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, elimc[0]));
  return Option$ReactTemplate.is_empty(scheme[/* indarg */11]);
}

function get_eliminator(elim, dep, s, gl) {
  if (elim.tag) {
    var id = elim[1];
    var isrec = elim[0];
    var elims = guess_elim(isrec, dep, s, id, gl);
    var match = elims[1];
    var match$1 = compute_elim_signature(elims, id);
    var match$2 = match$1[1];
    var branchlengthes = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
            if (!Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], d)) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "tactics.ml",
                      4114,
                      46
                    ]
                  ];
            }
            return Util$ReactTemplate.pi1(Termops$ReactTemplate.decompose_prod_letin(Tacmach$ReactTemplate.New[/* project */3](gl), Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], d)));
          }), Curry._1(Util$ReactTemplate.List[/* rev */4], match$2[1][/* branches */7]));
    return /* tuple */[
            elims[0],
            isrec,
            /* tuple */[
              /* record */[
                /* elimindex : None */0,
                /* elimrename : Some */[/* tuple */[
                    isrec,
                    Util$ReactTemplate.$$Array[/* of_list */10](branchlengthes)
                  ]],
                /* elimbody */match[0]
              ],
              match[1]
            ],
            match$2[0]
          ];
  } else {
    return /* tuple */[
            Tacmach$ReactTemplate.New[/* project */3](gl),
            /* true */1,
            elim[0],
            elim[1]
          ];
  }
}

function recolle_clenv(i, params, args, elimclause, gl) {
  var match = EConstr$ReactTemplate.destApp(elimclause[/* evd */1], elimclause[/* templval */2][/* rebus */0]);
  var lindmv = Util$ReactTemplate.$$Array[/* map */12]((function (x) {
          var match = EConstr$ReactTemplate.kind(elimclause[/* evd */1], x);
          if (match.tag === 2) {
            return match[0];
          } else {
            return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["elimination_clause"], Pp$ReactTemplate.str("The type of the elimination clause is not well-formed."));
          }
        }), match[1]);
  var k = i !== -1 ? i : lindmv.length - Curry._1(Util$ReactTemplate.List[/* length */0], args) | 0;
  var clauses_params = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, id) {
          return /* tuple */[
                  EConstr$ReactTemplate.mkVar(id),
                  Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](id, gl),
                  Caml_array.caml_array_get(lindmv, i)
                ];
        }), 0, params);
  var clauses_args = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, id) {
          return /* tuple */[
                  EConstr$ReactTemplate.mkVar(id),
                  Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](id, gl),
                  Caml_array.caml_array_get(lindmv, k + i | 0)
                ];
        }), 0, args);
  var clauses = Util$ReactTemplate.$at(clauses_params, clauses_args);
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (e, acc) {
                var indclause = Clenv$ReactTemplate.mk_clenv_from_n(gl, /* Some */[0], /* tuple */[
                      e[0],
                      e[1]
                    ]);
                return Clenv$ReactTemplate.clenv_fchain(/* Some */[/* false */0], /* None */0, e[2], acc, indclause);
              }), Curry._1(Util$ReactTemplate.List[/* rev */4], clauses), elimclause);
}

function induction_tac(with_evars, params, indvars, elim) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var elimt = elim[1];
                var match = elim[0];
                var match$1 = match[/* elimbody */2];
                var i = match[/* elimindex */0];
                var i$1 = i ? i[0] : index_of_ind_arg(sigma, elimt);
                var elimc = contract_letin_in_lam_header(sigma, match$1[0]);
                var elimc$1 = EConstr$ReactTemplate.mkCast(/* tuple */[
                      elimc,
                      /* DEFAULTcast */2,
                      elimt
                    ]);
                var elimclause = Curry._2(Tacmach$ReactTemplate.New[/* pf_apply */0](Clenv$ReactTemplate.make_clenv_binding, gl), /* tuple */[
                      elimc$1,
                      elimt
                    ], match$1[1]);
                var elimclause$prime = recolle_clenv(i$1, params, indvars, elimclause, gl);
                var resolved = Clenv$ReactTemplate.clenv_unique_resolver(/* Some */[Unification$ReactTemplate.elim_flags(/* () */0)], elimclause$prime, gl);
                return Clenvtac$ReactTemplate.clenv_refine(with_evars, /* None */0, resolved);
              }));
}

function apply_induction_in_context(with_evars, hyp0, inhyps, elim, indvars, names, induct_tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var concl = Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
                var match = cook_sign(hyp0, inhyps, indvars, env, sigma);
                var avoid = match[4];
                var deps = match[3];
                var toclear = match[2];
                var lhyp0 = match[1];
                var statuslists = match[0];
                var dep_in_concl = Option$ReactTemplate.cata((function (id) {
                        return Termops$ReactTemplate.occur_var(env, sigma, id, concl);
                      }), /* false */0, hyp0);
                var dep = match[5] || dep_in_concl;
                var tmpcl = Curry._1(Termops$ReactTemplate.it_mkNamedProd_or_LetIn(concl), deps);
                var s = Retyping$ReactTemplate.get_sort_family_of(/* None */0, /* None */0, env, sigma, tmpcl);
                var deps_cstr = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (a, decl) {
                        if (Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* is_local_assum */5], decl)) {
                          return /* :: */[
                                  EConstr$ReactTemplate.mkVar(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl)),
                                  a
                                ];
                        } else {
                          return a;
                        }
                      }), /* [] */0, deps);
                var match$1 = get_eliminator(elim, dep, s, gl);
                var indsign = match$1[3];
                var f = function (param) {
                  return param[1];
                };
                var branchletsigns = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                        return Curry._2(Util$ReactTemplate.List[/* map */10], f, param[1]);
                      }), indsign);
                var names$1 = Tacticals$ReactTemplate.compute_induction_names(branchletsigns, names);
                Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                        return check_name_unicity(env, toclear, /* [] */0, param);
                      }), names$1);
                var tac = Curry._2(match$1[1] ? Tacticals$ReactTemplate.New[/* tclTHENFIRSTn */14] : Tacticals$ReactTemplate.New[/* tclTHENLASTn */16], Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                          deps ? apply_type(/* false */0, tmpcl, deps_cstr) : Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0),
                          /* :: */[
                            Curry._1(induct_tac, match$1[2]),
                            /* :: */[
                              Tacticals$ReactTemplate.New[/* tclMAP */20](expand_hyp, toclear),
                              /* [] */0
                            ]
                          ]
                        ]), Util$ReactTemplate.$$Array[/* map2 */49]((function (param, param$1) {
                            var with_evars$1 = with_evars;
                            var dests = lhyp0;
                            var avoid$prime = avoid;
                            var tac = function (param) {
                              return re_intro_dependent_hypotheses(statuslists, param);
                            };
                            var param$2 = param;
                            var names = param$1;
                            var avoid$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], param$2[0], avoid$prime);
                            var peel_tac = function (ra, dests, names, thin) {
                              if (ra) {
                                var match = ra[0];
                                switch (match[0]) {
                                  case 0 : 
                                      var ra$prime = ra[1];
                                      var recvarname = match[3];
                                      var deprec = match[2];
                                      var exit = 0;
                                      if (ra$prime) {
                                        var match$1 = ra$prime[0];
                                        if (match$1[0] !== 1) {
                                          exit = 1;
                                        } else {
                                          var ra$prime$1 = ra$prime[1];
                                          var hyprecname = match$1[3];
                                          var depind = match$1[2];
                                          return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                                        var match;
                                                        var exit = 0;
                                                        if (names) {
                                                          var pat = names[0];
                                                          var match$1 = pat[/* v */0];
                                                          switch (match$1.tag | 0) {
                                                            case 1 : 
                                                                var match$2 = match$1[0];
                                                                if (typeof match$2 === "number") {
                                                                  exit = 1;
                                                                } else if (match$2.tag) {
                                                                  exit = 1;
                                                                } else if (names[1]) {
                                                                  exit = 1;
                                                                } else {
                                                                  var id$prime = Namegen$ReactTemplate.next_ident_away(Nameops$ReactTemplate.add_prefix("IH", match$2[0]), avoid$1);
                                                                  var eta = /* IntroNaming */Block.__(1, [/* IntroIdentifier */Block.__(0, [id$prime])]);
                                                                  match = /* tuple */[
                                                                    pat,
                                                                    /* :: */[
                                                                      CAst$ReactTemplate.make(/* None */0, eta),
                                                                      /* [] */0
                                                                    ]
                                                                  ];
                                                                }
                                                                break;
                                                            case 0 : 
                                                            case 2 : 
                                                                exit = 1;
                                                                break;
                                                            
                                                          }
                                                        } else {
                                                          exit = 1;
                                                        }
                                                        if (exit === 1) {
                                                          match = consume_pattern(avoid$1, /* Name */[recvarname], deprec, gl, names);
                                                        }
                                                        var names$1 = match[1];
                                                        var dest = get_recarg_dest(dests);
                                                        return dest_intro_patterns(with_evars$1, avoid$1, thin, dest, /* :: */[
                                                                    match[0],
                                                                    /* [] */0
                                                                  ], (function (_, thin) {
                                                                      return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                                                                    var match = consume_pattern(avoid$1, /* Name */[hyprecname], depind, gl, names$1);
                                                                                    var names$2 = match[1];
                                                                                    return dest_intro_patterns(with_evars$1, avoid$1, thin, /* MoveLast */1, /* :: */[
                                                                                                match[0],
                                                                                                /* [] */0
                                                                                              ], (function (ids$prime, thin) {
                                                                                                  return peel_tac(ra$prime$1, update_dest(dests, ids$prime), names$2, thin);
                                                                                                }));
                                                                                  }));
                                                                    }));
                                                      }));
                                        }
                                      } else {
                                        exit = 1;
                                      }
                                      if (exit === 1) {
                                        return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                                      var match = consume_pattern(avoid$1, /* Name */[recvarname], deprec, gl, names);
                                                      var names$1 = match[1];
                                                      var dest = get_recarg_dest(dests);
                                                      return dest_intro_patterns(with_evars$1, avoid$1, thin, dest, /* :: */[
                                                                  match[0],
                                                                  /* [] */0
                                                                ], (function (_, thin) {
                                                                    return peel_tac(ra$prime, dests, names$1, thin);
                                                                  }));
                                                    }));
                                      }
                                      break;
                                  case 1 : 
                                      var ra$prime$2 = ra[1];
                                      var hyprecname$1 = match[3];
                                      var dep = match[2];
                                      return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                                    var match = consume_pattern(avoid$1, /* Name */[hyprecname$1], dep, gl, names);
                                                    var names$1 = match[1];
                                                    return dest_intro_patterns(with_evars$1, avoid$1, thin, /* MoveLast */1, /* :: */[
                                                                match[0],
                                                                /* [] */0
                                                              ], (function (ids, thin) {
                                                                  return peel_tac(ra$prime$2, update_dest(dests, ids), names$1, thin);
                                                                }));
                                                  }));
                                  case 2 : 
                                      var ra$prime$3 = ra[1];
                                      var dep$1 = match[2];
                                      return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                                    var match = consume_pattern(avoid$1, /* Anonymous */0, dep$1, gl, names);
                                                    var names$1 = match[1];
                                                    var dest = get_recarg_dest(dests);
                                                    var with_evars$2 = with_evars$1;
                                                    var avoid$2 = avoid$1;
                                                    var thin$1 = thin;
                                                    var dest$1 = dest;
                                                    var pat = /* :: */[
                                                      match[0],
                                                      /* [] */0
                                                    ];
                                                    var tac = function (_, thin) {
                                                      return peel_tac(ra$prime$3, dests, names$1, thin);
                                                    };
                                                    return Proofview$ReactTemplate.tclORELSE(dest_intro_patterns(with_evars$2, avoid$2, thin$1, dest$1, pat, tac), (function (param) {
                                                                  var info = param[1];
                                                                  var e = param[0];
                                                                  if (e[0] === CErrors$ReactTemplate.UserError) {
                                                                    var match = e[1];
                                                                    if (match) {
                                                                      if (match[0] === "move_hyp") {
                                                                        return dest_intro_patterns(with_evars$2, avoid$2, thin$1, /* MoveLast */1, pat, tac);
                                                                      } else {
                                                                        return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                                                                      }
                                                                    } else {
                                                                      return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                                                                    }
                                                                  } else {
                                                                    return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                                                                  }
                                                                }));
                                                  }));
                                  
                                }
                              } else {
                                return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                              var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                                              var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                                              check_unused_names(env, sigma, names);
                                              return Tacticals$ReactTemplate.New[/* tclTHEN */2](clear_wildcards(thin), Curry._1(tac, dests));
                                            }));
                              }
                            };
                            return peel_tac(param$2[1], dests, names, /* [] */0);
                          }), indsign, names$1));
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$1[0]), tac);
              }));
}

function induction_with_atomization_of_ind_arg(isrec, with_evars, elim, names, hyp0, inhyps) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var elim_info = find_induction_type(isrec, elim, hyp0, gl);
                var param = elim_info;
                var hyp0$1 = hyp0;
                var tac = function (indvars) {
                  return apply_induction_in_context(with_evars, /* Some */[hyp0], inhyps, Util$ReactTemplate.pi3(elim_info), indvars, names, (function (elim) {
                                return induction_tac(with_evars, /* [] */0, /* :: */[
                                            hyp0,
                                            /* [] */0
                                          ], elim);
                              }));
                };
                var nparams = param[1];
                var indref = param[0];
                return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                              var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                              var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                              var tmptyp0 = Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](hyp0$1, gl);
                              var reduce_to_quantified_ref = Tacmach$ReactTemplate.New[/* pf_apply */0](Tacred$ReactTemplate.reduce_to_quantified_ref, gl);
                              var typ0 = Curry._2(reduce_to_quantified_ref, indref, tmptyp0);
                              var match = EConstr$ReactTemplate.decompose_prod_assum(sigma, typ0);
                              var match$1 = EConstr$ReactTemplate.decompose_app(sigma, match[1]);
                              var argl = match$1[1];
                              var hd = match$1[0];
                              var env$prime = EConstr$ReactTemplate.push_rel_context(match[0], env);
                              var params = Curry._2(Util$ReactTemplate.List[/* firstn */104], nparams, argl);
                              var params$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      return expand_projections(env$prime, sigma, param);
                                    }), params);
                              var atomize_one = function (_i, _args, _args$prime, _avoid) {
                                while(true) {
                                  var avoid = _avoid;
                                  var args$prime = _args$prime;
                                  var args = _args;
                                  var i = _i;
                                  if (i === nparams) {
                                    var t = EConstr$ReactTemplate.applist(/* tuple */[
                                          hd,
                                          Util$ReactTemplate.$at(params, args)
                                        ]);
                                    return Tacticals$ReactTemplate.New[/* tclTHEN */2](change_in_hyp(/* None */0, (function(t){
                                                  return function (param, param$1) {
                                                    return make_change_arg(t, param, param$1);
                                                  }
                                                  }(t)), /* tuple */[
                                                    hyp0$1,
                                                    /* InHypTypeOnly */1
                                                  ]), Curry._1(tac, avoid));
                                  } else {
                                    var c = Curry._2(Util$ReactTemplate.List[/* nth */3], argl, i - 1 | 0);
                                    var match = EConstr$ReactTemplate.kind(sigma, c);
                                    var exit = 0;
                                    if (match.tag === 1) {
                                      var id = match[0];
                                      if (!Curry._2(Util$ReactTemplate.List[/* exists */21], (function(id){
                                            return function (c) {
                                              return Termops$ReactTemplate.occur_var(env, sigma, id, c);
                                            }
                                            }(id)), args$prime) && !Curry._2(Util$ReactTemplate.List[/* exists */21], (function(id){
                                            return function (c) {
                                              return Termops$ReactTemplate.occur_var(env, sigma, id, c);
                                            }
                                            }(id)), params$prime)) {
                                        _avoid = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid);
                                        _args$prime = /* :: */[
                                          c,
                                          args$prime
                                        ];
                                        _args = /* :: */[
                                          c,
                                          args
                                        ];
                                        _i = i - 1 | 0;
                                        continue ;
                                        
                                      } else {
                                        exit = 1;
                                      }
                                    } else {
                                      exit = 1;
                                    }
                                    if (exit === 1) {
                                      var c$prime = expand_projections(env$prime, sigma, c);
                                      var dependent = (function(c){
                                      return function dependent(t) {
                                        return Termops$ReactTemplate.dependent(sigma, c, t);
                                      }
                                      }(c));
                                      if (Curry._2(Util$ReactTemplate.List[/* exists */21], dependent, params$prime) || Curry._2(Util$ReactTemplate.List[/* exists */21], dependent, args$prime)) {
                                        _args$prime = /* :: */[
                                          c$prime,
                                          args$prime
                                        ];
                                        _args = /* :: */[
                                          c,
                                          args
                                        ];
                                        _i = i - 1 | 0;
                                        continue ;
                                        
                                      } else {
                                        var match$1 = EConstr$ReactTemplate.kind(sigma, c);
                                        var id$1;
                                        if (match$1.tag === 1) {
                                          id$1 = match$1[0];
                                        } else {
                                          var partial_arg = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6];
                                          var type_of = (function(partial_arg){
                                          return function type_of(param) {
                                            return partial_arg(gl, param);
                                          }
                                          }(partial_arg));
                                          id$1 = Namegen$ReactTemplate.id_of_name_using_hdchar(env, sigma, Curry._1(type_of, c), /* Anonymous */0);
                                        }
                                        var x = fresh_id_in_env(avoid, id$1, env);
                                        return Tacticals$ReactTemplate.New[/* tclTHEN */2](letin_tac(/* None */0, /* Name */[x], c, /* None */0, Locusops$ReactTemplate.allHypsAndConcl), atomize_one(i - 1 | 0, /* :: */[
                                                        EConstr$ReactTemplate.mkVar(x),
                                                        args
                                                      ], /* :: */[
                                                        EConstr$ReactTemplate.mkVar(x),
                                                        args$prime
                                                      ], Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], x, avoid)));
                                      }
                                    }
                                    
                                  }
                                };
                              };
                              return atomize_one(Curry._1(Util$ReactTemplate.List[/* length */0], argl), /* [] */0, /* [] */0, Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
                            }));
              }));
}

function msg_not_right_number_induction_arguments(scheme) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Not the right number of induction arguments (expected "), Pp$ReactTemplate.pr_enum((function (x) {
                        return x;
                      }), /* :: */[
                      scheme[/* farg_in_concl */14] ? Pp$ReactTemplate.str("the function name") : Pp$ReactTemplate.mt(/* () */0),
                      /* :: */[
                        scheme[/* nparams */4] !== 0 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(scheme[/* nparams */4]), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], scheme[/* nparams */4], " parameter"))) : Pp$ReactTemplate.mt(/* () */0),
                        /* :: */[
                          scheme[/* nargs */10] !== 0 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(scheme[/* nargs */10]), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], scheme[/* nargs */10], " argument"))) : Pp$ReactTemplate.mt(/* () */0),
                          /* [] */0
                        ]
                      ]
                    ])), Pp$ReactTemplate.str(")."));
}

function clear_unselected_context(id, inhyps, cls) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                if (Termops$ReactTemplate.occur_var(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), Tacmach$ReactTemplate.New[/* project */3](gl), id, Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl)) && cls[/* concl_occs */1] === /* NoOccurrences */1) {
                  CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Conclusion must be mentioned: it depends on "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(".")));
                }
                var match = cls[/* onhyps */0];
                if (match) {
                  var to_erase = function (d) {
                    var id$prime = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
                    if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], id$prime, inhyps)) {
                      return /* None */0;
                    } else {
                      var test = function (id) {
                        return Termops$ReactTemplate.occur_var_in_decl(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), Tacmach$ReactTemplate.New[/* project */3](gl), id, d);
                      };
                      if (Curry._2(Util$ReactTemplate.List[/* exists */21], test, /* :: */[
                              id,
                              inhyps
                            ])) {
                        return /* Some */[id$prime];
                      } else {
                        return /* None */0;
                      }
                    }
                  };
                  return clear(Curry._2(Util$ReactTemplate.List[/* map_filter */62], to_erase, Proofview$ReactTemplate.Goal[/* hyps */3](gl)));
                } else {
                  return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                }
              }));
}

function use_bindings(env, sigma, elim, must_be_closed, param, typ) {
  var lbind = param[1];
  var c = param[0];
  var typ$1;
  if (elim) {
    typ$1 = typ;
  } else {
    var match = Reductionops$ReactTemplate.splay_prod(env, sigma)(typ);
    typ$1 = Curry._1(Termops$ReactTemplate.it_mkProd(match[1]), match[0]);
  }
  var find_clause = function (typ) {
    try {
      var indclause = Clenv$ReactTemplate.make_clenv_binding(env, sigma)(/* tuple */[
            c,
            typ
          ], lbind);
      if (must_be_closed && Termops$ReactTemplate.occur_meta(indclause[/* evd */1], Clenv$ReactTemplate.clenv_value(indclause))) {
        error("Need a fully applied argument.");
      }
      return Unification$ReactTemplate.pose_all_metas_as_evars(env, indclause[/* evd */1], Clenv$ReactTemplate.clenv_value(indclause));
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (Logic$ReactTemplate.catchable_exception(e)) {
        try {
          return find_clause(Tacred$ReactTemplate.try_red_product(env, sigma, typ));
        }
        catch (exn){
          if (exn === Tacred$ReactTemplate.Redelimination) {
            throw e;
          } else {
            throw exn;
          }
        }
      } else {
        throw e;
      }
    }
  };
  return find_clause(typ$1);
}

function check_enough_applied(env, sigma, elim) {
  if (elim) {
    var elimc = elim[0];
    var elimt = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, elimc[0]);
    var scheme = compute_elim_sig(sigma, /* Some */[elimc], elimt);
    var match = scheme[/* indref */2];
    if (match) {
      var env$1 = env;
      var sigma$1 = sigma;
      var param = elimc;
      var elimt$1 = elimt;
      var match$1 = Reductionops$ReactTemplate.splay_prod(env$1, sigma$1)(elimt$1);
      var n = Curry._1(Util$ReactTemplate.List[/* length */0], match$1[0]);
      if (!n) {
        error("Scheme cannot be applied.");
      }
      var match$2 = Clenv$ReactTemplate.make_evar_clause(env$1, sigma$1, /* Some */[n - 1 | 0], elimt$1);
      var cl = match$2[1];
      var sigma$2 = Clenv$ReactTemplate.solve_evar_clause(env$1, match$2[0], /* true */1, cl, param[1]);
      var match$3 = EConstr$ReactTemplate.destProd(sigma$2, cl[/* cl_concl */1]);
      var u = match$3[1];
      return (function (t) {
          return Evarconv$ReactTemplate.e_cumul(env$1, /* None */0, [sigma$2], t, u);
        });
    } else {
      return (function () {
          return /* true */1;
        });
    }
  } else {
    return (function (u) {
        var match = EConstr$ReactTemplate.decompose_app(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, u));
        return EConstr$ReactTemplate.isInd(sigma, match[0]);
      });
  }
}

var guard_no_unifiable = Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.guard_no_unifiable, (function (param) {
        if (param) {
          var l = param[0];
          return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclENV, (function (env) {
                        return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                                      return Proofview$ReactTemplate.tclZERO(/* None */0, [
                                                  Logic$ReactTemplate.RefinerError,
                                                  env,
                                                  sigma,
                                                  /* UnresolvedBindings */Block.__(1, [l])
                                                ]);
                                    }));
                      }));
        } else {
          return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
        }
      }));

function has_generic_occurrences_but_goal(cls, id, env, sigma, ccl) {
  if (Locusops$ReactTemplate.clause_with_generic_context_selection(cls)) {
    if (cls[/* concl_occs */1] !== /* NoOccurrences */1) {
      return /* true */1;
    } else {
      return 1 - Termops$ReactTemplate.occur_var(env, sigma, id, ccl);
    }
  } else {
    return /* false */0;
  }
}

function induction_gen(clear_flag, isrec, with_evars, elim, arg, cls) {
  var match = arg[1];
  var names = match[1];
  var eqname = match[0];
  var match$1 = arg[0][1];
  var lbind = match$1[1];
  var c = match$1[0];
  var inhyps;
  if (cls) {
    var match$2 = cls[0][/* onhyps */0];
    inhyps = match$2 ? Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return param[0][1];
            }), match$2[0]) : /* [] */0;
  } else {
    inhyps = /* [] */0;
  }
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var evd = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var ccl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var cls$1 = Option$ReactTemplate.$$default(Locusops$ReactTemplate.allHypsAndConcl, cls);
                var t = typ_of(env, evd, c);
                var is_arg_pure_hyp = EConstr$ReactTemplate.isVar(evd, c) && 1 - Termops$ReactTemplate.mem_named_context_val(EConstr$ReactTemplate.destVar(evd, c), Global$ReactTemplate.named_context_val(/* () */0)) && +(lbind === /* NoBindings */0) && 1 - with_evars && Option$ReactTemplate.is_empty(eqname) && +(clear_flag === /* None */0) && has_generic_occurrences_but_goal(cls$1, EConstr$ReactTemplate.destVar(evd, c), env, evd, ccl);
                var enough_applied = Curry._1(check_enough_applied(env, evd, elim), t);
                if (is_arg_pure_hyp && enough_applied) {
                  var id = EConstr$ReactTemplate.destVar(evd, c);
                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](clear_unselected_context(id, inhyps, cls$1), induction_with_atomization_of_ind_arg(isrec, with_evars, elim, names, id, inhyps));
                } else {
                  var x = Namegen$ReactTemplate.id_of_name_using_hdchar(env, evd, t, /* Anonymous */0);
                  var id$1 = new_fresh_id(Names$ReactTemplate.Id[/* Set */9][/* empty */0], x, gl);
                  var info_arg_001 = 1 - enough_applied;
                  var info_arg = /* tuple */[
                    is_arg_pure_hyp,
                    info_arg_001
                  ];
                  var isrec$1 = isrec;
                  var with_evars$1 = with_evars;
                  var param = info_arg;
                  var elim$1 = elim;
                  var id$2 = id$1;
                  var param$1 = arg;
                  var t0 = t;
                  var cls$2 = cls$1;
                  var tac = induction_with_atomization_of_ind_arg(isrec, with_evars, elim, names, id$1, inhyps);
                  var eqname$1 = param$1[1][0];
                  var match = param$1[0];
                  var match$1 = match[1];
                  var lbind$1 = match$1[1];
                  var c0 = match$1[0];
                  var pending = match[0];
                  var from_prefix = param[1];
                  var is_arg_pure_hyp$1 = param[0];
                  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                                var ccl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
                                var store = Proofview$ReactTemplate.Goal[/* extra */6](gl);
                                var check = check_enough_applied(env, sigma, elim$1);
                                var match = use_bindings(env, sigma, elim$1, /* false */0, /* tuple */[
                                      c0,
                                      lbind$1
                                    ], t0);
                                var abs_002 = /* Name */[id$2];
                                var abs_003 = /* tuple */[
                                  pending,
                                  match[1]
                                ];
                                var abs = /* AbstractPattern */Block.__(0, [
                                    from_prefix,
                                    check,
                                    abs_002,
                                    abs_003,
                                    cls$2,
                                    /* false */0
                                  ]);
                                var match$1 = Unification$ReactTemplate.make_abstraction(env, match[0], ccl, abs);
                                var res = match$1[5];
                                var ccl$1 = match$1[4];
                                var lastlhyp = match$1[3];
                                var id$3 = match$1[0];
                                if (res) {
                                  var match$2 = res[0];
                                  var c = match$2[1];
                                  var with_eq = Option$ReactTemplate.map((function (eq) {
                                          return /* tuple */[
                                                  /* false */0,
                                                  eq
                                                ];
                                        }), eqname$1);
                                  var env$1 = Environ$ReactTemplate.reset_with_named_context(match$1[1], env);
                                  var tac$1 = Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                        Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                                return mkletin_goal(env$1, sigma, store, with_eq, /* true */1, /* tuple */[
                                                            id$3,
                                                            lastlhyp,
                                                            ccl$1,
                                                            c
                                                          ], /* None */0);
                                              })),
                                        /* :: */[
                                          tac,
                                          /* [] */0
                                        ]
                                      ]);
                                  return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$2[0]), tac$1);
                                } else {
                                  var with_eq$1 = Option$ReactTemplate.map((function (eq) {
                                          return /* tuple */[
                                                  /* false */0,
                                                  eq
                                                ];
                                        }), eqname$1);
                                  var flags = tactic_infer_flags(with_evars$1 && /* false */0);
                                  var match$3 = Unification$ReactTemplate.finish_evar_resolution(/* Some */[flags], env, sigma, /* tuple */[
                                        pending,
                                        c0
                                      ]);
                                  var c0$1 = match$3[1];
                                  var tac$2 = Curry._2(isrec$1 ? Tacticals$ReactTemplate.New[/* tclTHENFIRST */15] : Tacticals$ReactTemplate.New[/* tclTHENLAST */17], Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                            Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                                    var b = 1 - with_evars$1 && +(with_eq$1 !== /* None */0);
                                                    var match = use_bindings(env, sigma, elim$1, b, /* tuple */[
                                                          c0$1,
                                                          lbind$1
                                                        ], t0);
                                                    var c = match[1];
                                                    var sigma$1 = match[0];
                                                    var t = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma$1, c);
                                                    return mkletin_goal(env, sigma$1, store, with_eq$1, /* false */0, /* tuple */[
                                                                id$3,
                                                                lastlhyp,
                                                                ccl$1,
                                                                c
                                                              ], /* Some */[t]);
                                                  })),
                                            /* :: */[
                                              with_evars$1 ? Proofview$ReactTemplate.shelve_unifiable : guard_no_unifiable,
                                              /* :: */[
                                                is_arg_pure_hyp$1 ? Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                                                          return Tacticals$ReactTemplate.New[/* tclTRY */21](clear(/* :: */[
                                                                          EConstr$ReactTemplate.destVar(sigma, c0$1),
                                                                          /* [] */0
                                                                        ]));
                                                        })) : Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0),
                                                /* :: */[
                                                  isrec$1 ? Proofview$ReactTemplate.cycle(-1) : Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0),
                                                  /* [] */0
                                                ]
                                              ]
                                            ]
                                          ]), tac);
                                  return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$3[0]), tac$2);
                                }
                              }));
                }
              }));
}

function induction_gen_l(isrec, with_evars, elim, names, lc) {
  var newlc = [/* [] */0];
  var lc$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var match = param[1];
          if (match) {
            var match$1 = match[0];
            return CErrors$ReactTemplate.user_err(match$1[/* loc */1], /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Do not know what to do with "), Miscprint$ReactTemplate.pr_intro_pattern_naming(match$1[/* v */0])));
          } else {
            return param[0];
          }
        }), lc);
  var atomize_list = function (l) {
    if (l) {
      var l$prime = l[1];
      var c = l[0];
      return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                    var match = EConstr$ReactTemplate.kind(sigma, c);
                    var exit = 0;
                    if (match.tag === 1) {
                      var id = match[0];
                      if (!Termops$ReactTemplate.mem_named_context_val(id, Global$ReactTemplate.named_context_val(/* () */0)) && !with_evars) {
                        newlc[0] = /* :: */[
                          id,
                          newlc[0]
                        ];
                        return atomize_list(l$prime);
                      } else {
                        exit = 1;
                      }
                    } else {
                      exit = 1;
                    }
                    if (exit === 1) {
                      return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                    var partial_arg = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6];
                                    var type_of = function (param) {
                                      return partial_arg(gl, param);
                                    };
                                    var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                                    return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclENV, (function (env) {
                                                  var x = Namegen$ReactTemplate.id_of_name_using_hdchar(env, sigma, Curry._1(type_of, c), /* Anonymous */0);
                                                  var id = new_fresh_id(Names$ReactTemplate.Id[/* Set */9][/* empty */0], x, gl);
                                                  var newl$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (r) {
                                                          return Termops$ReactTemplate.replace_term(sigma, c, EConstr$ReactTemplate.mkVar(id), r);
                                                        }), l$prime);
                                                  newlc[0] = /* :: */[
                                                    id,
                                                    newlc[0]
                                                  ];
                                                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](letin_tac(/* None */0, /* Name */[id], c, /* None */0, Locusops$ReactTemplate.allHypsAndConcl), atomize_list(newl$prime));
                                                }));
                                  }));
                    }
                    
                  }));
    } else {
      return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
    }
  };
  return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
              atomize_list(lc$1),
              /* :: */[
                Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0), (function () {
                        var with_evars$1 = with_evars;
                        var elim$1 = elim;
                        var names$1 = names;
                        var lid = newlc[0];
                        return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                      var match = get_elim_signature(elim$1, Curry._1(Util$ReactTemplate.List[/* hd */1], lid), gl);
                                      var match$1 = match[1];
                                      var scheme = match$1[1];
                                      var nargs_indarg_farg = scheme[/* nargs */10] + (
                                        scheme[/* farg_in_concl */14] ? 1 : 0
                                      ) | 0;
                                      if (Curry._1(Util$ReactTemplate.List[/* length */0], lid) !== (scheme[/* nparams */4] + nargs_indarg_farg | 0)) {
                                        return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, msg_not_right_number_induction_arguments(scheme));
                                      } else {
                                        var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], nargs_indarg_farg, lid);
                                        var lid_params = match$2[1];
                                        var indvars = match$2[0];
                                        var realindvars = Curry._1(Util$ReactTemplate.List[/* rev */4], scheme[/* farg_in_concl */14] ? Curry._1(Util$ReactTemplate.List[/* tl */2], indvars) : indvars);
                                        var lidcstr = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.mkVar, Curry._1(Util$ReactTemplate.List[/* rev */4], indvars));
                                        var params = Curry._1(Util$ReactTemplate.List[/* rev */4], lid_params);
                                        var indvars$1 = Curry._1(Util$ReactTemplate.List[/* is_empty */45], indvars) ? Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], Curry._1(Util$ReactTemplate.List[/* hd */1], lid_params)) : Curry._1(Names$ReactTemplate.Id[/* Set */9][/* of_list */25], indvars);
                                        var induct_tac = function (elim) {
                                          return Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                                      reduce(/* Pattern */Block.__(7, [Curry._2(Util$ReactTemplate.List[/* map */10], inj_with_occurrences, lidcstr)]), Locusops$ReactTemplate.onConcl),
                                                      /* :: */[
                                                        induction_tac(with_evars$1, params, realindvars, elim),
                                                        /* [] */0
                                                      ]
                                                    ]);
                                        };
                                        var elim_000 = /* tuple */[
                                          /* record */[
                                            /* elimindex : Some */[-1],
                                            /* elimrename : None */0,
                                            /* elimbody */Option$ReactTemplate.get(scheme[/* elimc */0])
                                          ],
                                          scheme[/* elimt */1]
                                        ];
                                        var elim_001 = match$1[0];
                                        var elim$2 = /* ElimUsing */Block.__(0, [
                                            elim_000,
                                            elim_001
                                          ]);
                                        return apply_induction_in_context(with_evars$1, /* None */0, /* [] */0, elim$2, indvars$1, names$1, induct_tac);
                                      }
                                    }));
                      })),
                /* [] */0
              ]
            ]);
}

function induction_destruct(isrec, with_evars, param) {
  var elim = param[1];
  var lc = param[0];
  if (lc) {
    if (lc[1]) {
      return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                    var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                    var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                    if (elim) {
                      var lc$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                              return Util$ReactTemplate.on_pi1((function (c) {
                                            return force_destruction_arg(/* false */0, env, sigma, c)[1];
                                          }), param);
                            }), lc);
                      var newlc = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                              var match = param[1];
                              if (param[2] !== /* None */0) {
                                error("'in' clause not yet supported here.");
                              }
                              var match$1 = param[0][1];
                              switch (match$1.tag | 0) {
                                case 0 : 
                                    if (match[0] !== /* None */0) {
                                      error("'eqn' clause not supported here.");
                                    }
                                    return /* tuple */[
                                            with_no_bindings(match$1[0]),
                                            match[1]
                                          ];
                                case 1 : 
                                case 2 : 
                                    return error("Don't know where to find some argument.");
                                
                              }
                            }), lc$1);
                      var match = Curry._1(Util$ReactTemplate.List[/* sep_last */93], Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                  return prim[1];
                                }), newlc));
                      if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (n) {
                                return 1 - Option$ReactTemplate.is_empty(n);
                              }), match[1])) {
                        error("'as' clause with multiple arguments and 'using' clause can only occur last.");
                      }
                      var newlc$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                              return /* tuple */[
                                      param[0],
                                      /* None */0
                                    ];
                            }), newlc);
                      return induction_gen_l(isrec, with_evars, elim[0], match[0], newlc$1);
                    } else {
                      var match$1 = Curry._1(Util$ReactTemplate.List[/* hd */1], lc);
                      var cl = match$1[2];
                      var b = match$1[1];
                      var l = Curry._1(Util$ReactTemplate.List[/* tl */2], lc);
                      return Tacticals$ReactTemplate.New[/* tclTHEN */2](onOpenInductionArg(env, sigma, (function (clear_flag, a) {
                                        return induction_gen(clear_flag, isrec, with_evars, /* None */0, /* tuple */[
                                                    a,
                                                    b
                                                  ], cl);
                                      }), match$1[0]), Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                                        var cl = param[2];
                                        var b = param[1];
                                        var a = param[0];
                                        return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                                      var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                                                      var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                                                      return onOpenInductionArg(env, sigma, (function (clear_flag, a) {
                                                                    return induction_gen(clear_flag, /* false */0, with_evars, /* None */0, /* tuple */[
                                                                                a,
                                                                                b
                                                                              ], cl);
                                                                  }), a);
                                                    }));
                                      }), l));
                    }
                  }));
    } else {
      var match = lc[0];
      var cls = match[2];
      var allnames = match[1];
      var names = allnames[1];
      var eqname = allnames[0];
      var c = match[0];
      return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                    var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                    var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                    var exit = 0;
                    if (elim) {
                      var elim$1 = elim[0];
                      if (is_functional_induction(elim$1, gl)) {
                        if (!Option$ReactTemplate.is_empty(cls)) {
                          error("'in' clause not supported here.");
                        }
                        var match = force_destruction_arg(/* false */0, env, sigma, c);
                        return onInductionArg((function (_, c) {
                                      return induction_gen_l(isrec, with_evars, elim$1, names, /* :: */[
                                                  /* tuple */[
                                                    with_no_bindings(c),
                                                    eqname
                                                  ],
                                                  /* [] */0
                                                ]);
                                    }), match[1]);
                      } else {
                        exit = 1;
                      }
                    } else {
                      exit = 1;
                    }
                    if (exit === 1) {
                      return onOpenInductionArg(env, sigma, (function (clear_flag, c) {
                                    return induction_gen(clear_flag, isrec, with_evars, elim, /* tuple */[
                                                c,
                                                allnames
                                              ], cls);
                                  }), c);
                    }
                    
                  }));
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "tactics.ml",
            4515,
            10
          ]
        ];
  }
}

function induction(ev, clr, c, l, e) {
  return induction_gen(clr, /* true */1, ev, e, /* tuple */[
              /* tuple */[
                Evd$ReactTemplate.empty,
                /* tuple */[
                  c,
                  /* NoBindings */0
                ]
              ],
              /* tuple */[
                /* None */0,
                l
              ]
            ], /* None */0);
}

function destruct(ev, clr, c, l, e) {
  return induction_gen(clr, /* false */0, ev, e, /* tuple */[
              /* tuple */[
                Evd$ReactTemplate.empty,
                /* tuple */[
                  c,
                  /* NoBindings */0
                ]
              ],
              /* tuple */[
                /* None */0,
                l
              ]
            ], /* None */0);
}

function elim_scheme_type(elim, t) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var clause = Clenv$ReactTemplate.mk_clenv_type_of(gl, elim);
                var match = EConstr$ReactTemplate.kind(clause[/* evd */1], last_arg(clause[/* evd */1], clause[/* templval */2][/* rebus */0]));
                if (match.tag === 2) {
                  var clause$prime = Clenv$ReactTemplate.clenv_unify(/* Some */[Unification$ReactTemplate.elim_flags(/* () */0)], /* CUMUL */1, t, Clenv$ReactTemplate.clenv_meta_type(clause, match[0]), clause);
                  return Clenvtac$ReactTemplate.res_pf(/* Some */[/* false */0], /* None */0, /* Some */[Unification$ReactTemplate.elim_flags(/* () */0)], clause$prime);
                } else {
                  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("elim_scheme_type."));
                }
              }));
}

function elim_type(t) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var match = Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0](Tacred$ReactTemplate.reduce_to_atomic_ind, gl), t);
                var match$1 = find_ind_eliminator(match[0][0], Tacticals$ReactTemplate.New[/* elimination_sort_of_goal */50](gl), gl);
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$1[0]), elim_scheme_type(match$1[1], match[1]));
              }));
}

function case_type(t) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var env = Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl);
                var match = Tacred$ReactTemplate.reduce_to_atomic_ind(env, sigma, t);
                var match$1 = match[0];
                var u = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$1[1]);
                var s = Tacticals$ReactTemplate.New[/* elimination_sort_of_goal */50](gl);
                var match$2 = Indrec$ReactTemplate.build_case_analysis_scheme_default(env, sigma, /* tuple */[
                      match$1[0],
                      u
                    ], s);
                var elimc = EConstr$ReactTemplate.of_constr(match$2[1]);
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match$2[0]), elim_scheme_type(elimc, match[1]));
              }));
}

var match$2 = Hook$ReactTemplate.make(/* None */0, /* () */0);

var forward_setoid_reflexivity = match$2[0];

function maybe_betadeltaiota_concl(allowred, gl) {
  var concl = Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
  if (allowred) {
    var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
    return Reductionops$ReactTemplate.whd_all(env)(sigma, concl);
  } else {
    return concl;
  }
}

function reflexivity_red(allowred) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var concl = maybe_betadeltaiota_concl(allowred, gl);
                var match = Hipattern$ReactTemplate.match_with_equality_type(sigma, concl);
                if (match) {
                  return one_constructor(1, /* NoBindings */0);
                } else {
                  return Proofview$ReactTemplate.tclZERO(/* None */0, Hipattern$ReactTemplate.NoEquationFound);
                }
              }));
}

var reflexivity = Proofview$ReactTemplate.tclORELSE(reflexivity_red(/* false */0), (function (param) {
        var e = param[0];
        if (e === Hipattern$ReactTemplate.NoEquationFound) {
          return Hook$ReactTemplate.get(forward_setoid_reflexivity);
        } else {
          return Proofview$ReactTemplate.tclZERO(/* Some */[param[1]], e);
        }
      }));

var intros_reflexivity = Tacticals$ReactTemplate.New[/* tclTHEN */2](intros, reflexivity);

var match$3 = Hook$ReactTemplate.make(/* None */0, /* () */0);

var forward_setoid_symmetry = match$3[0];

function match_with_equation(sigma, c) {
  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclENV, (function (env) {
                try {
                  return Curry._1(Proofview$ReactTemplate.tclUNIT, Hipattern$ReactTemplate.match_with_equation(env, sigma, c));
                }
                catch (exn){
                  if (exn === Hipattern$ReactTemplate.NoEquationFound) {
                    return Proofview$ReactTemplate.tclZERO(/* None */0, Hipattern$ReactTemplate.NoEquationFound);
                  } else {
                    throw exn;
                  }
                }
              }));
}

function symmetry_red(allowred) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var concl = maybe_betadeltaiota_concl(allowred, gl);
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], match_with_equation(sigma, concl), (function (with_eqn) {
                              var match = with_eqn[0];
                              if (match) {
                                return Tacticals$ReactTemplate.New[/* tclTHEN */2](convert_concl_no_check(concl, /* DEFAULTcast */2), Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](match[0][/* sym */3]), apply));
                              } else {
                                var hdcncl = with_eqn[1];
                                var eq_kind = with_eqn[2];
                                var symc;
                                switch (eq_kind.tag | 0) {
                                  case 0 : 
                                      symc = EConstr$ReactTemplate.mkApp(/* tuple */[
                                            hdcncl,
                                            /* array */[
                                              eq_kind[1],
                                              eq_kind[0]
                                            ]
                                          ]);
                                      break;
                                  case 1 : 
                                      symc = EConstr$ReactTemplate.mkApp(/* tuple */[
                                            hdcncl,
                                            /* array */[
                                              eq_kind[0],
                                              eq_kind[2],
                                              eq_kind[1]
                                            ]
                                          ]);
                                      break;
                                  case 2 : 
                                      symc = EConstr$ReactTemplate.mkApp(/* tuple */[
                                            hdcncl,
                                            /* array */[
                                              eq_kind[2],
                                              eq_kind[3],
                                              eq_kind[0],
                                              eq_kind[1]
                                            ]
                                          ]);
                                      break;
                                  
                                }
                                return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](cut(symc), Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                                intro,
                                                /* :: */[
                                                  Tacticals$ReactTemplate.New[/* onLastHyp */43](simplest_case),
                                                  /* :: */[
                                                    one_constructor(1, /* NoBindings */0),
                                                    /* [] */0
                                                  ]
                                                ]
                                              ]));
                              }
                            }));
              }));
}

var symmetry = Proofview$ReactTemplate.tclORELSE(symmetry_red(/* false */0), (function (param) {
        var e = param[0];
        if (e === Hipattern$ReactTemplate.NoEquationFound) {
          return Hook$ReactTemplate.get(forward_setoid_symmetry);
        } else {
          return Proofview$ReactTemplate.tclZERO(/* Some */[param[1]], e);
        }
      }));

var match$4 = Hook$ReactTemplate.make(/* None */0, /* () */0);

var forward_setoid_symmetry_in = match$4[0];

var partial_arg$10 = Tacticals$ReactTemplate.New[/* onClause */49];

function intros_symmetry(param) {
  return partial_arg$10((function (param) {
                if (param) {
                  var id = param[0];
                  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                                var ctype = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, EConstr$ReactTemplate.mkVar(id));
                                var match = EConstr$ReactTemplate.decompose_prod_assum(sigma, ctype);
                                var sign = match[0];
                                return Proofview$ReactTemplate.tclORELSE(Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], match_with_equation(sigma, match[1]), (function (param) {
                                                  var eq = param[2];
                                                  var hdcncl = param[1];
                                                  var symccl;
                                                  switch (eq.tag | 0) {
                                                    case 0 : 
                                                        symccl = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                              hdcncl,
                                                              /* array */[
                                                                eq[1],
                                                                eq[0]
                                                              ]
                                                            ]);
                                                        break;
                                                    case 1 : 
                                                        symccl = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                              hdcncl,
                                                              /* array */[
                                                                eq[0],
                                                                eq[2],
                                                                eq[1]
                                                              ]
                                                            ]);
                                                        break;
                                                    case 2 : 
                                                        symccl = EConstr$ReactTemplate.mkApp(/* tuple */[
                                                              hdcncl,
                                                              /* array */[
                                                                eq[2],
                                                                eq[3],
                                                                eq[0],
                                                                eq[1]
                                                              ]
                                                            ]);
                                                        break;
                                                    
                                                  }
                                                  return Tacticals$ReactTemplate.New[/* tclTHENS */18](cut(EConstr$ReactTemplate.it_mkProd_or_LetIn(symccl, sign)), /* :: */[
                                                              intro_replacing(id),
                                                              /* :: */[
                                                                Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                                                      intros,
                                                                      /* :: */[
                                                                        symmetry,
                                                                        /* :: */[
                                                                          apply(EConstr$ReactTemplate.mkVar(id)),
                                                                          /* :: */[
                                                                            assumption,
                                                                            /* [] */0
                                                                          ]
                                                                        ]
                                                                      ]
                                                                    ]),
                                                                /* [] */0
                                                              ]
                                                            ]);
                                                })), (function (param) {
                                              var e = param[0];
                                              if (e === Hipattern$ReactTemplate.NoEquationFound) {
                                                return Curry._1(Hook$ReactTemplate.get(forward_setoid_symmetry_in), id);
                                              } else {
                                                return Proofview$ReactTemplate.tclZERO(/* Some */[param[1]], e);
                                              }
                                            }));
                              }));
                } else {
                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](intros, symmetry);
                }
              }), param);
}

var match$5 = Hook$ReactTemplate.make(/* None */0, /* () */0);

var forward_setoid_transitivity = match$5[0];

function transitivity_red(allowred, t) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var concl = maybe_betadeltaiota_concl(allowred, gl);
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], match_with_equation(sigma, concl), (function (with_eqn) {
                              var match = with_eqn[0];
                              if (match) {
                                var eq_data = match[0];
                                var tmp;
                                if (t) {
                                  var t$1 = t[0];
                                  tmp = Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](eq_data[/* trans */4]), (function (trans) {
                                          var param = /* :: */[
                                            trans,
                                            /* :: */[
                                              t$1,
                                              /* [] */0
                                            ]
                                          ];
                                          if (param) {
                                            return apply_with_bindings(/* tuple */[
                                                        param[0],
                                                        /* ImplicitBindings */Block.__(0, [param[1]])
                                                      ]);
                                          } else {
                                            throw [
                                                  Caml_builtin_exceptions.assert_failure,
                                                  [
                                                    "tactics.ml",
                                                    1745,
                                                    9
                                                  ]
                                                ];
                                          }
                                        }));
                                } else {
                                  tmp = Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Tacticals$ReactTemplate.New[/* pf_constr_of_global */58](eq_data[/* trans */4]), eapply);
                                }
                                return Tacticals$ReactTemplate.New[/* tclTHEN */2](convert_concl_no_check(concl, /* DEFAULTcast */2), tmp);
                              } else if (t) {
                                var hdcncl = with_eqn[1];
                                var eq_kind = with_eqn[2];
                                var t$2 = t[0];
                                return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                              var match;
                                              switch (eq_kind.tag | 0) {
                                                case 0 : 
                                                    match = /* tuple */[
                                                      EConstr$ReactTemplate.mkApp(/* tuple */[
                                                            hdcncl,
                                                            /* array */[
                                                              eq_kind[0],
                                                              t$2
                                                            ]
                                                          ]),
                                                      EConstr$ReactTemplate.mkApp(/* tuple */[
                                                            hdcncl,
                                                            /* array */[
                                                              t$2,
                                                              eq_kind[1]
                                                            ]
                                                          ])
                                                    ];
                                                    break;
                                                case 1 : 
                                                    var typ = eq_kind[0];
                                                    match = /* tuple */[
                                                      EConstr$ReactTemplate.mkApp(/* tuple */[
                                                            hdcncl,
                                                            /* array */[
                                                              typ,
                                                              eq_kind[1],
                                                              t$2
                                                            ]
                                                          ]),
                                                      EConstr$ReactTemplate.mkApp(/* tuple */[
                                                            hdcncl,
                                                            /* array */[
                                                              typ,
                                                              t$2,
                                                              eq_kind[2]
                                                            ]
                                                          ])
                                                    ];
                                                    break;
                                                case 2 : 
                                                    var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                                                    var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                                                    var typt = Typing$ReactTemplate.unsafe_type_of(env, sigma, t$2);
                                                    match = /* tuple */[
                                                      EConstr$ReactTemplate.mkApp(/* tuple */[
                                                            hdcncl,
                                                            /* array */[
                                                              eq_kind[0],
                                                              eq_kind[1],
                                                              typt,
                                                              t$2
                                                            ]
                                                          ]),
                                                      EConstr$ReactTemplate.mkApp(/* tuple */[
                                                            hdcncl,
                                                            /* array */[
                                                              typt,
                                                              t$2,
                                                              eq_kind[2],
                                                              eq_kind[3]
                                                            ]
                                                          ])
                                                    ];
                                                    break;
                                                
                                              }
                                              return Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](cut(match[1]), Tacticals$ReactTemplate.New[/* tclTHENFIRST */15](cut(match[0]), Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                                                                  Tacticals$ReactTemplate.New[/* tclDO */28](2, intro),
                                                                  /* :: */[
                                                                    Tacticals$ReactTemplate.New[/* onLastHyp */43](simplest_case),
                                                                    /* :: */[
                                                                      assumption,
                                                                      /* [] */0
                                                                    ]
                                                                  ]
                                                                ])));
                                            }));
                              } else {
                                return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("etransitivity not supported for this relation."));
                              }
                            }));
              }));
}

function transitivity_gen(t) {
  return Proofview$ReactTemplate.tclORELSE(transitivity_red(/* false */0, t), (function (param) {
                var e = param[0];
                if (e === Hipattern$ReactTemplate.NoEquationFound) {
                  return Curry._1(Hook$ReactTemplate.get(forward_setoid_transitivity), t);
                } else {
                  return Proofview$ReactTemplate.tclZERO(/* Some */[param[1]], e);
                }
              }));
}

var etransitivity = transitivity_gen(/* None */0);

function transitivity(t) {
  return transitivity_gen(/* Some */[t]);
}

function intros_transitivity(n) {
  return Tacticals$ReactTemplate.New[/* tclTHEN */2](intros, transitivity_gen(n));
}

function interpretable_as_section_decl(env, evd, d1, d2) {
  var e_eq_constr_univs = function (sigma, c1, c2) {
    var match = EConstr$ReactTemplate.eq_constr_universes(env, sigma[0], c1, c2);
    if (match) {
      try {
        Evd$ReactTemplate.add_universe_constraints(sigma[0], match[0]);
        return /* true */1;
      }
      catch (exn){
        if (exn === Evd$ReactTemplate.UniversesDiffer) {
          return /* false */0;
        } else {
          throw exn;
        }
      }
    } else {
      return /* false */0;
    }
  };
  if (d2.tag) {
    if (!d1.tag || !e_eq_constr_univs(evd, d2[1], d1[1])) {
      return /* false */0;
    } else {
      return e_eq_constr_univs(evd, d2[2], d1[2]);
    }
  } else {
    return e_eq_constr_univs(evd, d2[1], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], d1));
  }
}

function decompose(_len, _c, _t, _accu) {
  while(true) {
    var accu = _accu;
    var t = _t;
    var c = _c;
    var len = _len;
    if (len) {
      var match = Constr$ReactTemplate.kind(c);
      var match$1 = Constr$ReactTemplate.kind(t);
      var exit = 0;
      switch (match.tag | 0) {
        case 7 : 
            if (match$1.tag === 6) {
              _accu = /* :: */[
                /* LocalAssum */Block.__(0, [
                    match[0],
                    match[1]
                  ]),
                accu
              ];
              _t = match$1[2];
              _c = match[2];
              _len = len - 1 | 0;
              continue ;
              
            } else {
              exit = 1;
            }
            break;
        case 8 : 
            if (match$1.tag === 8) {
              _accu = /* :: */[
                /* LocalDef */Block.__(1, [
                    match[0],
                    match[1],
                    match[2]
                  ]),
                accu
              ];
              _t = match$1[3];
              _c = match[3];
              _len = len - 1 | 0;
              continue ;
              
            } else {
              exit = 1;
            }
            break;
        default:
          exit = 1;
      }
      if (exit === 1) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "tactics.ml",
                4850,
                9
              ]
            ];
      }
      
    } else {
      return /* tuple */[
              c,
              t,
              accu
            ];
    }
  };
}

function shrink(_ctx, _sign, _c, _t, _accu) {
  while(true) {
    var accu = _accu;
    var t = _t;
    var c = _c;
    var sign = _sign;
    var ctx = _ctx;
    if (ctx) {
      if (sign) {
        var sign$1 = sign[1];
        var ctx$1 = ctx[1];
        var p = ctx[0];
        if (Vars$ReactTemplate.noccurn(1, c) && Vars$ReactTemplate.noccurn(1, t)) {
          var c$1 = Vars$ReactTemplate.subst1(Constr$ReactTemplate.mkProp, c);
          var t$1 = Vars$ReactTemplate.subst1(Constr$ReactTemplate.mkProp, t);
          _t = t$1;
          _c = c$1;
          _sign = sign$1;
          _ctx = ctx$1;
          continue ;
          
        } else {
          var c$2 = Term$ReactTemplate.mkLambda_or_LetIn(p, c);
          var t$2 = Term$ReactTemplate.mkProd_or_LetIn(p, t);
          var accu$1 = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], p) ? /* :: */[
              Constr$ReactTemplate.mkVar(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], sign[0])),
              accu
            ] : accu;
          _accu = accu$1;
          _t = t$2;
          _c = c$2;
          _sign = sign$1;
          _ctx = ctx$1;
          continue ;
          
        }
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "tactics.ml",
                4870,
                7
              ]
            ];
      }
    } else if (sign) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "tactics.ml",
              4870,
              7
            ]
          ];
    } else {
      return /* tuple */[
              c,
              t,
              accu
            ];
    }
  };
}

function shrink_entry(sign, $$const) {
  var match = $$const[/* const_entry_type */3];
  var typ;
  if (match) {
    typ = match[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "tactics.ml",
            4875,
            12
          ]
        ];
  }
  if (!Future$ReactTemplate.is_over($$const[/* const_entry_body */0])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "tactics.ml",
            4879,
            11
          ]
        ];
  }
  var match$1 = Future$ReactTemplate.force($$const[/* const_entry_body */0]);
  var match$2 = match$1[0];
  var match$3 = decompose(Curry._1(Util$ReactTemplate.List[/* length */0], sign), match$2[0], typ, /* [] */0);
  var match$4 = shrink(match$3[2], sign, match$3[0], match$3[1], /* [] */0);
  var const_000 = /* const_entry_body */Future$ReactTemplate.from_val(/* None */0, /* tuple */[
        /* tuple */[
          match$4[0],
          match$2[1]
        ],
        match$1[1]
      ]);
  var const_001 = /* const_entry_secctx */$$const[/* const_entry_secctx */1];
  var const_002 = /* const_entry_feedback */$$const[/* const_entry_feedback */2];
  var const_003 = /* const_entry_type : Some */[match$4[1]];
  var const_004 = /* const_entry_universes */$$const[/* const_entry_universes */4];
  var const_005 = /* const_entry_opaque */$$const[/* const_entry_opaque */5];
  var const_006 = /* const_entry_inline_code */$$const[/* const_entry_inline_code */6];
  var $$const$1 = /* record */[
    const_000,
    const_001,
    const_002,
    const_003,
    const_004,
    const_005,
    const_006
  ];
  return /* tuple */[
          $$const$1,
          match$4[2]
        ];
}

function cache_term_by_tactic_then(opaque, $staropt$star, id, gk, tac, tacK) {
  var goal_type = $staropt$star ? $staropt$star[0] : /* None */0;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var current_sign = Global$ReactTemplate.named_context_val(/* () */0);
                var global_sign = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                var evdref = [sigma];
                var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (d, param) {
                        var s2 = param[1];
                        var s1 = param[0];
                        var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
                        if (Termops$ReactTemplate.mem_named_context_val(id, current_sign) && interpretable_as_section_decl(env, evdref, EConstr$ReactTemplate.lookup_named_val(id, current_sign), d)) {
                          return /* tuple */[
                                  s1,
                                  EConstr$ReactTemplate.push_named_context_val(d, s2)
                                ];
                        } else {
                          return /* tuple */[
                                  Context$ReactTemplate.Named[/* add */2](d, s1),
                                  s2
                                ];
                        }
                      }), global_sign, /* tuple */[
                      Context$ReactTemplate.Named[/* empty */1],
                      Environ$ReactTemplate.empty_named_context_val
                    ]);
                var sign = match[0];
                var id$1 = Namegen$ReactTemplate.next_global_ident_away(id, Tacmach$ReactTemplate.New[/* pf_ids_set_of_hyps */12](gl));
                var concl = goal_type ? goal_type[0] : Proofview$ReactTemplate.Goal[/* concl */2](gl);
                var concl$1 = Curry._1(Termops$ReactTemplate.it_mkNamedProd_or_LetIn(concl), sign);
                var concl$2;
                try {
                  concl$2 = Evarutil$ReactTemplate.flush_and_check_evars(evdref[0], concl$1);
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === Evarutil$ReactTemplate.Uninstantiated_evar) {
                    concl$2 = error("\"abstract\" cannot handle existentials.");
                  } else {
                    throw exn;
                  }
                }
                var match$1 = Evarutil$ReactTemplate.nf_evars_and_universes(evdref[0]);
                var evd = match$1[0];
                var ctx = Evd$ReactTemplate.universe_context_set(evd);
                var match_002 = Curry._1(match$1[1], concl$2);
                var concl$3 = EConstr$ReactTemplate.of_constr(match_002);
                var solve_tac = Tacticals$ReactTemplate.New[/* tclCOMPLETE */31](Tacticals$ReactTemplate.New[/* tclTHEN */2](Tacticals$ReactTemplate.New[/* tclDO */28](Curry._1(Util$ReactTemplate.List[/* length */0], sign), intro), tac));
                var ectx = Evd$ReactTemplate.evar_universe_context(evd);
                var match$2;
                try {
                  match$2 = Pfedit$ReactTemplate.build_constant_by_tactic(id$1, ectx, match[1], /* Some */[gk], concl$3, solve_tac);
                }
                catch (raw_src){
                  var src = Js_exn.internalToOCamlException(raw_src);
                  if (src[0] === Logic_monad$ReactTemplate.TacticFailure) {
                    var match$3 = CErrors$ReactTemplate.push(src);
                    match$2 = Util$ReactTemplate.iraise(/* tuple */[
                          src[1],
                          match$3[1]
                        ]);
                  } else {
                    throw src;
                  }
                }
                var match$4 = shrink_entry(sign, match$2[0]);
                var $$const = match$4[0];
                var args = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, match$4[1]);
                var newrecord = $$const.slice();
                var cd = /* DefinitionEntry */Block.__(0, [(newrecord[/* const_entry_opaque */5] = opaque, newrecord)]);
                var decl_001 = opaque ? /* IsProof */Block.__(2, [/* Lemma */1]) : /* IsDefinition */Block.__(1, [/* Definition */0]);
                var decl = /* tuple */[
                  cd,
                  decl_001
                ];
                var cst = function () {
                  Impargs$ReactTemplate.make_implicit_args(/* false */0);
                  return Declare$ReactTemplate.declare_constant(/* Some */[/* InternalTacticRequest */1], /* Some */[/* true */1], id$1, /* None */0, decl);
                };
                var cst$1 = Impargs$ReactTemplate.with_implicit_protection(cst, /* () */0);
                var match$5 = $$const[/* const_entry_universes */4];
                var lem;
                if (match$5.tag) {
                  var uctx = Univ$ReactTemplate.ContextSet[/* of_context */14](match$5[0]);
                  var match$6 = Future$ReactTemplate.force($$const[/* const_entry_body */0]);
                  var uctx$1 = Univ$ReactTemplate.ContextSet[/* to_context */13](Univ$ReactTemplate.ContextSet[/* union */6](uctx, match$6[0][1]));
                  var u = Univ$ReactTemplate.UContext[/* instance */3](uctx$1);
                  lem = EConstr$ReactTemplate.mkConstU(/* tuple */[
                        cst$1,
                        EConstr$ReactTemplate.EInstance[/* make */0](u)
                      ]);
                } else {
                  lem = EConstr$ReactTemplate.mkConst(cst$1);
                }
                var evd$1 = Evd$ReactTemplate.set_universe_context(evd, match$2[2]);
                var eff = Safe_typing$ReactTemplate.private_con_of_con(Global$ReactTemplate.safe_env(/* () */0), cst$1);
                var effs = Safe_typing$ReactTemplate.add_private(eff, Future$ReactTemplate.force($$const[/* const_entry_body */0])[1]);
                var solve = Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.tclEFFECTS(effs), Curry._2(tacK, lem, args));
                var tac$1 = match$2[1] ? solve : Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.mark_as_unsafe, solve);
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](evd$1), tac$1);
              }));
}

var anon_id = Names$ReactTemplate.Id[/* of_string */5]("anonymous");

function name_op_to_name(name_op, object_kind, suffix) {
  var default_gk = /* tuple */[
    /* Global */2,
    /* false */0,
    object_kind
  ];
  if (name_op) {
    var s = name_op[0];
    try {
      var match = Pfedit$ReactTemplate.current_proof_statement(/* () */0);
      return /* tuple */[
              s,
              match[1]
            ];
    }
    catch (exn){
      if (exn === Proof_global$ReactTemplate.NoCurrentProof) {
        return /* tuple */[
                s,
                default_gk
              ];
      } else {
        throw exn;
      }
    }
  } else {
    var match$1;
    try {
      var match$2 = Pfedit$ReactTemplate.current_proof_statement(/* () */0);
      match$1 = /* tuple */[
        match$2[0],
        match$2[1]
      ];
    }
    catch (exn$1){
      if (exn$1 === Proof_global$ReactTemplate.NoCurrentProof) {
        match$1 = /* tuple */[
          anon_id,
          default_gk
        ];
      } else {
        throw exn$1;
      }
    }
    return /* tuple */[
            Nameops$ReactTemplate.add_suffix(match$1[0], suffix),
            match$1[1]
          ];
  }
}

function tclABSTRACT($staropt$star, name_op, tac) {
  var opaque = $staropt$star ? $staropt$star[0] : /* true */1;
  var match = opaque ? name_op_to_name(name_op, /* Proof */Block.__(1, [/* Theorem */0]), "_subproof") : name_op_to_name(name_op, /* DefinitionBody */Block.__(0, [/* Definition */0]), "_subterm");
  var opaque$1 = opaque;
  var id = match[0];
  var gk = match[1];
  var tac$1 = tac;
  return cache_term_by_tactic_then(opaque$1, /* None */0, id, gk, tac$1, (function (lem, args) {
                return exact_no_check(EConstr$ReactTemplate.applist(/* tuple */[
                                lem,
                                args
                              ]));
              }));
}

function unify($staropt$star, x, y) {
  var state = $staropt$star ? $staropt$star[0] : Names$ReactTemplate.full_transparent_state;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                try {
                  var newrecord = Unification$ReactTemplate.default_unify_flags(/* () */0)[/* core_unify_flags */0].slice();
                  newrecord[/* modulo_conv_on_closed_terms */0] = /* Some */[state];
                  newrecord[/* modulo_delta */3] = state;
                  var init = Unification$ReactTemplate.default_unify_flags(/* () */0);
                  var newrecord$1 = newrecord.slice();
                  var flags_002 = /* subterm_unify_flags */(newrecord$1[/* modulo_delta */3] = Names$ReactTemplate.empty_transparent_state, newrecord$1);
                  var flags_003 = /* allow_K_in_toplevel_higher_order_unification */init[/* allow_K_in_toplevel_higher_order_unification */3];
                  var flags_004 = /* resolve_evars */init[/* resolve_evars */4];
                  var flags = /* record */[
                    /* core_unify_flags */newrecord,
                    /* merge_unify_flags */newrecord,
                    flags_002,
                    flags_003,
                    flags_004
                  ];
                  return Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](Unification$ReactTemplate.w_unify(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), sigma, /* CONV */0, /* Some */[flags], x, y));
                }
                catch (raw_e){
                  var e = Js_exn.internalToOCamlException(raw_e);
                  if (CErrors$ReactTemplate.noncritical(e)) {
                    return Tacticals$ReactTemplate.New[/* tclFAIL */3](0, Pp$ReactTemplate.str("Not unifiable"));
                  } else {
                    throw e;
                  }
                }
              }));
}

function intro$1(x) {
  return intro_move(/* Some */[x], /* MoveLast */1);
}

function apply$1(c) {
  return apply_with_bindings_gen(/* false */0, /* false */0, /* :: */[
              /* tuple */[
                /* None */0,
                CAst$ReactTemplate.make(/* None */0, /* tuple */[
                      c,
                      /* NoBindings */0
                    ])
              ],
              /* [] */0
            ]);
}

function eapply$1(c) {
  return apply_with_bindings_gen(/* false */0, /* true */1, /* :: */[
              /* tuple */[
                /* None */0,
                CAst$ReactTemplate.make(/* None */0, /* tuple */[
                      c,
                      /* NoBindings */0
                    ])
              ],
              /* [] */0
            ]);
}

function elim$1(c) {
  return elim(/* false */0, /* None */0, /* tuple */[
              c,
              /* NoBindings */0
            ], /* None */0);
}

function $$case(c) {
  return general_case_analysis(/* false */0, /* None */0, /* tuple */[
              c,
              /* NoBindings */0
            ]);
}

function apply_in$1(id, c) {
  return apply_in(/* false */0, /* false */0, id, /* :: */[
              /* tuple */[
                /* None */0,
                CAst$ReactTemplate.make(/* None */0, /* tuple */[
                      c,
                      /* NoBindings */0
                    ])
              ],
              /* [] */0
            ], /* None */0);
}

var Simple = /* module */[
  /* intro */intro$1,
  /* apply */apply$1,
  /* eapply */eapply$1,
  /* elim */elim$1,
  /* case */$$case,
  /* apply_in */apply_in$1
];

var reduce_after_refine = reduce(/* Lazy */Block.__(4, [/* record */[
          /* rBeta : true */1,
          /* rMatch : true */1,
          /* rFix : true */1,
          /* rCofix : true */1,
          /* rZeta : false */0,
          /* rDelta : false */0,
          /* rConst : [] */0
        ]]), /* record */[
      /* onhyps : Some */[/* [] */0],
      /* concl_occs : AllOccurrences */0
    ]);

function refine(typecheck, c) {
  return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Refine$ReactTemplate.refine(typecheck, c), reduce_after_refine);
}

var setoid_reflexivity = match$2[1];

var setoid_symmetry = match$3[1];

var setoid_symmetry_in = match$4[1];

var setoid_transitivity = match$5[1];

var general_rewrite_clause = match[1];

var subst_one = match$1[1];

var New = [
  refine,
  reduce_after_refine
];

exports.is_quantified_hypothesis = is_quantified_hypothesis;
exports.introduction = introduction;
exports.convert_concl = convert_concl;
exports.convert_hyp = convert_hyp;
exports.convert_concl_no_check = convert_concl_no_check;
exports.convert_hyp_no_check = convert_hyp_no_check;
exports.mutual_fix = mutual_fix;
exports.fix = fix;
exports.mutual_cofix = mutual_cofix;
exports.cofix = cofix;
exports.convert = convert;
exports.convert_leq = convert_leq;
exports.fresh_id_in_env = fresh_id_in_env;
exports.fresh_id = fresh_id;
exports.find_intro_names = find_intro_names;
exports.intro = intro;
exports.introf = introf;
exports.intro_move = intro_move;
exports.intro_move_avoid = intro_move_avoid;
exports.intro_avoiding = intro_avoiding;
exports.intro_replacing = intro_replacing;
exports.intro_using = intro_using;
exports.intro_mustbe_force = intro_mustbe_force;
exports.intro_then = intro_then;
exports.intros_using = intros_using;
exports.intros_replacing = intros_replacing;
exports.intros_possibly_replacing = intros_possibly_replacing;
exports.intros = intros;
exports.depth_of_quantified_hypothesis = depth_of_quantified_hypothesis;
exports.intros_until = intros_until;
exports.intros_clearing = intros_clearing;
exports.try_intros_until = try_intros_until;
exports.onInductionArg = onInductionArg;
exports.force_destruction_arg = force_destruction_arg;
exports.use_clear_hyp_by_default = use_clear_hyp_by_default;
exports.intro_patterns = intro_patterns;
exports.intro_patterns_to = intro_patterns_to;
exports.intro_patterns_bound_to = intro_patterns_bound_to;
exports.intro_pattern_to = intro_pattern_to;
exports.intros_patterns = intros_patterns;
exports.assumption = assumption;
exports.exact_no_check = exact_no_check;
exports.vm_cast_no_check = vm_cast_no_check;
exports.exact_check = exact_check;
exports.exact_proof = exact_proof;
exports.make_change_arg = make_change_arg;
exports.reduct_in_hyp = reduct_in_hyp;
exports.reduct_option = reduct_option;
exports.reduct_in_concl = reduct_in_concl;
exports.e_reduct_in_concl = e_reduct_in_concl;
exports.change_in_concl = change_in_concl;
exports.change_concl = change_concl;
exports.change_in_hyp = change_in_hyp;
exports.red_in_concl = red_in_concl;
exports.red_in_hyp = red_in_hyp;
exports.red_option = red_option;
exports.hnf_in_concl = hnf_in_concl;
exports.hnf_in_hyp = hnf_in_hyp;
exports.hnf_option = hnf_option;
exports.simpl_in_concl = simpl_in_concl;
exports.simpl_in_hyp = simpl_in_hyp;
exports.simpl_option = simpl_option;
exports.normalise_in_concl = normalise_in_concl;
exports.normalise_in_hyp = normalise_in_hyp;
exports.normalise_option = normalise_option;
exports.normalise_vm_in_concl = normalise_vm_in_concl;
exports.unfold_in_concl = unfold_in_concl;
exports.unfold_in_hyp = unfold_in_hyp;
exports.unfold_option = unfold_option;
exports.change = change;
exports.pattern_option = pattern_option;
exports.reduce = reduce;
exports.unfold_constr = unfold_constr;
exports.clear = clear;
exports.clear_body = clear_body;
exports.unfold_body = unfold_body;
exports.keep = keep;
exports.apply_clear_request = apply_clear_request;
exports.specialize = specialize;
exports.move_hyp = move_hyp;
exports.rename_hyp = rename_hyp;
exports.revert = revert;
exports.apply_type = apply_type;
exports.bring_hyps = bring_hyps;
exports.apply = apply;
exports.eapply = eapply;
exports.apply_with_bindings_gen = apply_with_bindings_gen;
exports.apply_with_delayed_bindings_gen = apply_with_delayed_bindings_gen;
exports.apply_with_bindings = apply_with_bindings;
exports.eapply_with_bindings = eapply_with_bindings;
exports.cut_and_apply = cut_and_apply;
exports.apply_in = apply_in;
exports.apply_delayed_in = apply_delayed_in;
exports.compute_elim_sig = compute_elim_sig;
exports.general_elim = general_elim;
exports.general_elim_clause = general_elim_clause;
exports.default_elim = default_elim;
exports.simplest_elim = simplest_elim;
exports.elim = elim;
exports.induction = induction;
exports.general_case_analysis = general_case_analysis;
exports.simplest_case = simplest_case;
exports.destruct = destruct;
exports.induction_destruct = induction_destruct;
exports.case_type = case_type;
exports.elim_type = elim_type;
exports.constructor_tac = constructor_tac;
exports.any_constructor = any_constructor;
exports.one_constructor = one_constructor;
exports.left = left;
exports.right = right;
exports.split = split;
exports.left_with_bindings = left_with_bindings;
exports.right_with_bindings = right_with_bindings;
exports.split_with_bindings = split_with_bindings;
exports.simplest_left = simplest_left;
exports.simplest_right = simplest_right;
exports.simplest_split = simplest_split;
exports.setoid_reflexivity = setoid_reflexivity;
exports.reflexivity_red = reflexivity_red;
exports.reflexivity = reflexivity;
exports.intros_reflexivity = intros_reflexivity;
exports.setoid_symmetry = setoid_symmetry;
exports.symmetry_red = symmetry_red;
exports.symmetry = symmetry;
exports.setoid_symmetry_in = setoid_symmetry_in;
exports.intros_symmetry = intros_symmetry;
exports.setoid_transitivity = setoid_transitivity;
exports.transitivity_red = transitivity_red;
exports.transitivity = transitivity;
exports.etransitivity = etransitivity;
exports.intros_transitivity = intros_transitivity;
exports.assert_before_replacing = assert_before_replacing;
exports.assert_after_replacing = assert_after_replacing;
exports.assert_before = assert_before;
exports.assert_after = assert_after;
exports.assert_as = assert_as;
exports.assert_by = assert_by;
exports.enough_by = enough_by;
exports.pose_proof = pose_proof;
exports.forward = forward;
exports.cut = cut;
exports.letin_tac = letin_tac;
exports.letin_pat_tac = letin_pat_tac;
exports.generalize = generalize;
exports.generalize_gen = generalize_gen;
exports.new_generalize_gen = new_generalize_gen;
exports.generalize_dep = generalize_dep;
exports.unify = unify;
exports.cache_term_by_tactic_then = cache_term_by_tactic_then;
exports.tclABSTRACT = tclABSTRACT;
exports.abstract_generalize = abstract_generalize;
exports.specialize_eqs = specialize_eqs;
exports.general_rewrite_clause = general_rewrite_clause;
exports.subst_one = subst_one;
exports.declare_intro_decomp_eq = declare_intro_decomp_eq;
exports.Simple = Simple;
exports.New = New;
/*  Not a pure module */
