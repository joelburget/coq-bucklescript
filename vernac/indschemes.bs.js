// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var CAst$ReactTemplate = require("../src/cAst.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Sorts$ReactTemplate = require("../src/sorts.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Coqlib$ReactTemplate = require("../library/coqlib.bs.js");
var Future$ReactTemplate = require("../src/future.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Indrec$ReactTemplate = require("../src/indrec.bs.js");
var UState$ReactTemplate = require("../src/uState.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Declare$ReactTemplate = require("../src/declare.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Printer$ReactTemplate = require("../src/printer.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Typeops$ReactTemplate = require("../src/typeops.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Retyping$ReactTemplate = require("../src/retyping.bs.js");
var CWarnings$ReactTemplate = require("../src/cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Eqschemes$ReactTemplate = require("../tactics/eqschemes.bs.js");
var Hipattern$ReactTemplate = require("../tactics/hipattern.bs.js");
var Inductive$ReactTemplate = require("../src/inductive.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Ind_tables$ReactTemplate = require("../tactics/ind_tables.bs.js");
var Elimschemes$ReactTemplate = require("../tactics/elimschemes.bs.js");
var Safe_typing$ReactTemplate = require("../src/safe_typing.bs.js");
var Smartlocate$ReactTemplate = require("../shims/smartlocate.bs.js");
var Inductiveops$ReactTemplate = require("../src/inductiveops.bs.js");
var Auto_ind_decl$ReactTemplate = require("./auto_ind_decl.bs.js");

var elim_flag = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"automatic declaration of induction schemes",
      /* optkey : :: */[
        "Elimination",
        /* :: */[
          "Schemes",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return elim_flag[0];
        }),
      /* optwrite */(function (b) {
          elim_flag[0] = b;
          return /* () */0;
        })
    ]);

var bifinite_elim_flag = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"automatic declaration of induction schemes for non-recursive types",
      /* optkey : :: */[
        "Nonrecursive",
        /* :: */[
          "Elimination",
          /* :: */[
            "Schemes",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return bifinite_elim_flag[0];
        }),
      /* optwrite */(function (b) {
          bifinite_elim_flag[0] = b;
          return /* () */0;
        })
    ]);

var case_flag = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"automatic declaration of case analysis schemes",
      /* optkey : :: */[
        "Case",
        /* :: */[
          "Analysis",
          /* :: */[
            "Schemes",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return case_flag[0];
        }),
      /* optwrite */(function (b) {
          case_flag[0] = b;
          return /* () */0;
        })
    ]);

var eq_flag = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"automatic declaration of boolean equality",
      /* optkey : :: */[
        "Boolean",
        /* :: */[
          "Equality",
          /* :: */[
            "Schemes",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return eq_flag[0];
        }),
      /* optwrite */(function (b) {
          eq_flag[0] = b;
          return /* () */0;
        })
    ]);

var eq_dec_flag = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"automatic declaration of decidable equality",
      /* optkey : :: */[
        "Decidable",
        /* :: */[
          "Equality",
          /* :: */[
            "Schemes",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return eq_dec_flag[0];
        }),
      /* optwrite */(function (b) {
          eq_dec_flag[0] = b;
          return /* () */0;
        })
    ]);

var rewriting_flag = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"automatic declaration of rewriting schemes for equality types",
      /* optkey : :: */[
        "Rewriting",
        /* :: */[
          "Schemes",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return rewriting_flag[0];
        }),
      /* optwrite */(function (b) {
          rewriting_flag[0] = b;
          return /* () */0;
        })
    ]);

function define(id, internal, ctx, c, t) {
  var partial_arg = /* Some */[internal];
  var f = function (param, param$1, param$2, param$3) {
    return Declare$ReactTemplate.declare_constant(partial_arg, param, param$1, param$2, param$3);
  };
  var univs = Flags$ReactTemplate.is_universe_polymorphism(/* () */0) ? /* Polymorphic_const_entry */Block.__(1, [Evd$ReactTemplate.to_universe_context(ctx)]) : /* Monomorphic_const_entry */Block.__(0, [Evd$ReactTemplate.universe_context_set(ctx)]);
  var kn = Curry._4(f, /* None */0, id, /* None */0, /* tuple */[
        /* DefinitionEntry */Block.__(0, [/* record */[
              /* const_entry_body */c,
              /* const_entry_secctx : None */0,
              /* const_entry_feedback : None */0,
              /* const_entry_type */t,
              /* const_entry_universes */univs,
              /* const_entry_opaque : false */0,
              /* const_entry_inline_code : false */0
            ]]),
        /* IsDefinition */Block.__(1, [/* Scheme */7])
      ]);
  Declare$ReactTemplate.definition_message(id);
  return kn;
}

function declare_beq_scheme_gen(internal, names, kn) {
  Ind_tables$ReactTemplate.define_mutual_scheme(Auto_ind_decl$ReactTemplate.beq_scheme_kind, internal, names, kn);
  return /* () */0;
}

function alarm(_, internal, msg) {
  if (internal >= 2) {
    return /* Some */[msg];
  } else {
    return /* None */0;
  }
}

function try_declare_scheme(what, f, internal, names, kn) {
  try {
    return Curry._3(f, internal, names, kn);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    var e$1 = CErrors$ReactTemplate.push(e);
    var e$2 = e$1[0];
    var msg = e$2[0] === Auto_ind_decl$ReactTemplate.ParameterWithoutEquality ? alarm(what, internal, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Boolean equality not found for parameter "), Printer$ReactTemplate.pr_global(e$2[1])), Pp$ReactTemplate.str("."))) : (
        e$2 === Auto_ind_decl$ReactTemplate.InductiveWithProduct ? alarm(what, internal, Pp$ReactTemplate.str("Unable to decide equality of functional arguments.")) : (
            e$2 === Auto_ind_decl$ReactTemplate.InductiveWithSort ? alarm(what, internal, Pp$ReactTemplate.str("Unable to decide equality of type arguments.")) : (
                e$2[0] === Auto_ind_decl$ReactTemplate.NonSingletonProp ? alarm(what, internal, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot extract computational content from proposition "), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), e$2[1]))), Pp$ReactTemplate.str("."))) : (
                    e$2[0] === Auto_ind_decl$ReactTemplate.EqNotFound ? alarm(what, internal, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Boolean equality on "), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), e$2[1]))), Pp$ReactTemplate.strbrk(" is missing."))) : (
                        e$2[0] === Auto_ind_decl$ReactTemplate.UndefinedCst ? alarm(what, internal, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Required constant "), Pp$ReactTemplate.str(e$2[1])), Pp$ReactTemplate.str(" undefined."))) : (
                            e$2[0] === CErrors$ReactTemplate.AlreadyDeclared ? alarm(what, internal, Pp$ReactTemplate.$plus$plus(e$2[1], Pp$ReactTemplate.str("."))) : (
                                e$2 === Auto_ind_decl$ReactTemplate.DecidabilityMutualNotSupported ? alarm(what, internal, Pp$ReactTemplate.str("Decidability lemma for mutual inductive types not supported.")) : (
                                    e$2[0] === Auto_ind_decl$ReactTemplate.EqUnknown ? alarm(what, internal, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Found unsupported "), Pp$ReactTemplate.str(e$2[1])), Pp$ReactTemplate.str(" while building Boolean equality."))) : (
                                        e$2 === Auto_ind_decl$ReactTemplate.NoDecidabilityCoInductive ? alarm(what, internal, Pp$ReactTemplate.str("Scheme Equality is only for inductive types.")) : (
                                            CErrors$ReactTemplate.noncritical(e$2) ? alarm(what, internal, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unexpected error during scheme creation: "), CErrors$ReactTemplate.print(/* None */0, e$2))) : Util$ReactTemplate.iraise(e$1)
                                          )
                                      )
                                  )
                              )
                          )
                      )
                  )
              )
          )
      );
    if (msg) {
      return Util$ReactTemplate.iraise(/* tuple */[
                  [
                    CErrors$ReactTemplate.UserError,
                    /* None */0,
                    msg[0]
                  ],
                  e$1[1]
                ]);
    } else {
      return /* () */0;
    }
  }
}

function beq_scheme_msg(mind) {
  var mib = Global$ReactTemplate.lookup_mind(mind);
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Boolean equality on "), Pp$ReactTemplate.pr_enum((function (ind) {
                    return Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), ind));
                  }), Curry._2(Util$ReactTemplate.List[/* init */46], mib[/* mind_packets */0].length, (function (i) {
                        return /* tuple */[
                                mind,
                                i
                              ];
                      }))));
}

function declare_beq_scheme_with(l, kn) {
  return try_declare_scheme(beq_scheme_msg(kn), declare_beq_scheme_gen, /* UserIndividualRequest */2, l, kn);
}

function try_declare_beq_scheme(kn) {
  return try_declare_scheme(beq_scheme_msg(kn), declare_beq_scheme_gen, /* UserAutomaticRequest */0, /* [] */0, kn);
}

function declare_beq_scheme(param) {
  return declare_beq_scheme_with(/* [] */0, param);
}

function declare_one_case_analysis_scheme(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  var mip = match[1];
  var mib = match[0];
  var kind = Inductive$ReactTemplate.inductive_sort_family(mip);
  var dep = kind ? (
      Inductiveops$ReactTemplate.has_dependent_elim(mib) ? Elimschemes$ReactTemplate.case_dep_scheme_kind_from_type : Elimschemes$ReactTemplate.case_scheme_kind_from_type
    ) : Elimschemes$ReactTemplate.case_scheme_kind_from_prop;
  var kelim = Inductive$ReactTemplate.elim_sorts(/* tuple */[
        mib,
        mip
      ]);
  if (Curry._2(Sorts$ReactTemplate.List[/* mem */0], /* InType */2, kelim)) {
    Ind_tables$ReactTemplate.define_individual_scheme(dep, /* UserAutomaticRequest */0, /* None */0, ind);
    return /* () */0;
  } else {
    return 0;
  }
}

var kinds_from_prop_000 = /* tuple */[
  /* InType */2,
  Elimschemes$ReactTemplate.rect_scheme_kind_from_prop
];

var kinds_from_prop_001 = /* :: */[
  /* tuple */[
    /* InProp */0,
    Elimschemes$ReactTemplate.ind_scheme_kind_from_prop
  ],
  /* :: */[
    /* tuple */[
      /* InSet */1,
      Elimschemes$ReactTemplate.rec_scheme_kind_from_prop
    ],
    /* [] */0
  ]
];

var kinds_from_prop = /* :: */[
  kinds_from_prop_000,
  kinds_from_prop_001
];

var kinds_from_type_000 = /* tuple */[
  /* InType */2,
  Elimschemes$ReactTemplate.rect_dep_scheme_kind_from_type
];

var kinds_from_type_001 = /* :: */[
  /* tuple */[
    /* InProp */0,
    Elimschemes$ReactTemplate.ind_dep_scheme_kind_from_type
  ],
  /* :: */[
    /* tuple */[
      /* InSet */1,
      Elimschemes$ReactTemplate.rec_dep_scheme_kind_from_type
    ],
    /* [] */0
  ]
];

var kinds_from_type = /* :: */[
  kinds_from_type_000,
  kinds_from_type_001
];

var nondep_kinds_from_type_000 = /* tuple */[
  /* InType */2,
  Elimschemes$ReactTemplate.rect_scheme_kind_from_type
];

var nondep_kinds_from_type_001 = /* :: */[
  /* tuple */[
    /* InProp */0,
    Elimschemes$ReactTemplate.ind_scheme_kind_from_type
  ],
  /* :: */[
    /* tuple */[
      /* InSet */1,
      Elimschemes$ReactTemplate.rec_scheme_kind_from_type
    ],
    /* [] */0
  ]
];

var nondep_kinds_from_type = /* :: */[
  nondep_kinds_from_type_000,
  nondep_kinds_from_type_001
];

function declare_one_induction_scheme(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  var mip = match[1];
  var mib = match[0];
  var kind = Inductive$ReactTemplate.inductive_sort_family(mip);
  var from_prop = +(kind === /* InProp */0);
  var depelim = Inductiveops$ReactTemplate.has_dependent_elim(mib);
  var kelim = Inductive$ReactTemplate.elim_sorts(/* tuple */[
        mib,
        mip
      ]);
  var elims = Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function (param) {
          if (Curry._2(Sorts$ReactTemplate.List[/* mem */0], param[0], kelim)) {
            return /* Some */[param[1]];
          } else {
            return /* None */0;
          }
        }), from_prop ? kinds_from_prop : (
          depelim ? kinds_from_type : nondep_kinds_from_type
        ));
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (kind) {
                Ind_tables$ReactTemplate.define_individual_scheme(kind, /* UserAutomaticRequest */0, /* None */0, ind);
                return /* () */0;
              }), elims);
}

function declare_induction_schemes(kn) {
  var mib = Global$ReactTemplate.lookup_mind(kn);
  if (mib[/* mind_finite */2] !== /* CoFinite */1) {
    for(var i = 0 ,i_finish = mib[/* mind_packets */0].length - 1 | 0; i <= i_finish; ++i){
      declare_one_induction_scheme(/* tuple */[
            kn,
            i
          ]);
    }
    return /* () */0;
  } else {
    return 0;
  }
}

function declare_eq_decidability_gen(internal, names, kn) {
  var mib = Global$ReactTemplate.lookup_mind(kn);
  if (mib[/* mind_finite */2] !== /* CoFinite */1) {
    Ind_tables$ReactTemplate.define_mutual_scheme(Auto_ind_decl$ReactTemplate.eq_dec_scheme_kind, internal, names, kn);
    return /* () */0;
  } else {
    return 0;
  }
}

function eq_dec_scheme_msg(ind) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Decidable equality on "), Pp$ReactTemplate.quote(Printer$ReactTemplate.pr_inductive(Global$ReactTemplate.env(/* () */0), ind)));
}

function declare_eq_decidability_scheme_with(l, kn) {
  return try_declare_scheme(eq_dec_scheme_msg(/* tuple */[
                  kn,
                  0
                ]), declare_eq_decidability_gen, /* UserIndividualRequest */2, l, kn);
}

function try_declare_eq_decidability(kn) {
  return try_declare_scheme(eq_dec_scheme_msg(/* tuple */[
                  kn,
                  0
                ]), declare_eq_decidability_gen, /* UserAutomaticRequest */0, /* [] */0, kn);
}

function declare_eq_decidability(param) {
  return declare_eq_decidability_scheme_with(/* [] */0, param);
}

function ignore_error(f, x) {
  try {
    Curry._1(f, x);
    return /* () */0;
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      return /* () */0;
    } else {
      throw e;
    }
  }
}

function declare_rewriting_schemes(ind) {
  if (Hipattern$ReactTemplate.is_inductive_equality(ind)) {
    Ind_tables$ReactTemplate.define_individual_scheme(Eqschemes$ReactTemplate.rew_r2l_scheme_kind, /* UserAutomaticRequest */0, /* None */0, ind);
    Ind_tables$ReactTemplate.define_individual_scheme(Eqschemes$ReactTemplate.rew_r2l_dep_scheme_kind, /* UserAutomaticRequest */0, /* None */0, ind);
    Ind_tables$ReactTemplate.define_individual_scheme(Eqschemes$ReactTemplate.rew_r2l_forward_dep_scheme_kind, /* UserAutomaticRequest */0, /* None */0, ind);
    ignore_error((function (param) {
            return Ind_tables$ReactTemplate.define_individual_scheme(Eqschemes$ReactTemplate.rew_l2r_scheme_kind, /* UserAutomaticRequest */0, /* None */0, param);
          }), ind);
    ignore_error((function (param) {
            return Ind_tables$ReactTemplate.define_individual_scheme(Eqschemes$ReactTemplate.rew_l2r_dep_scheme_kind, /* UserAutomaticRequest */0, /* None */0, param);
          }), ind);
    return ignore_error((function (param) {
                  return Ind_tables$ReactTemplate.define_individual_scheme(Eqschemes$ReactTemplate.rew_l2r_forward_dep_scheme_kind, /* UserAutomaticRequest */0, /* None */0, param);
                }), ind);
  } else {
    return 0;
  }
}

var warn_cannot_build_congruence = CWarnings$ReactTemplate.create("cannot-build-congruence", "schemes", /* None */0, (function () {
        return Pp$ReactTemplate.strbrk("Cannot build congruence scheme because eq is not found");
      }));

function declare_congr_scheme(ind) {
  if (Hipattern$ReactTemplate.is_equality_type(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(Constr$ReactTemplate.mkInd(ind)))) {
    var tmp;
    try {
      Coqlib$ReactTemplate.check_required_library(Coqlib$ReactTemplate.logic_module_name);
      tmp = /* true */1;
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (CErrors$ReactTemplate.noncritical(e)) {
        tmp = /* false */0;
      } else {
        throw e;
      }
    }
    if (tmp) {
      Ind_tables$ReactTemplate.define_individual_scheme(Eqschemes$ReactTemplate.congr_scheme_kind, /* UserAutomaticRequest */0, /* None */0, ind);
      return /* () */0;
    } else {
      return Curry._2(warn_cannot_build_congruence, /* None */0, /* () */0);
    }
  } else {
    return 0;
  }
}

function declare_sym_scheme(ind) {
  if (Hipattern$ReactTemplate.is_inductive_equality(ind)) {
    return ignore_error((function (param) {
                  return Ind_tables$ReactTemplate.define_individual_scheme(Eqschemes$ReactTemplate.sym_scheme_kind, /* UserAutomaticRequest */0, /* None */0, param);
                }), ind);
  } else {
    return 0;
  }
}

function split_scheme(l) {
  var env = Global$ReactTemplate.env(/* () */0);
  if (l) {
    var match = l[0];
    var match$1 = match[0];
    if (match$1) {
      var t = match[1];
      var id = match$1[0];
      var match$2 = split_scheme(l[1]);
      var l2 = match$2[1];
      var l1 = match$2[0];
      var exit = 0;
      switch (t.tag | 0) {
        case 0 : 
        case 1 : 
            exit = 1;
            break;
        case 2 : 
            return /* tuple */[
                    l1,
                    /* :: */[
                      /* tuple */[
                        /* Some */[id],
                        Curry._1(Smartlocate$ReactTemplate.smart_global_inductive, t[0])
                      ],
                      l2
                    ]
                  ];
        
      }
      if (exit === 1) {
        return /* tuple */[
                /* :: */[
                  /* tuple */[
                    id,
                    t[0],
                    Curry._1(Smartlocate$ReactTemplate.smart_global_inductive, t[1]),
                    t[2]
                  ],
                  l1
                ],
                l2
              ];
      }
      
    } else {
      var t$1 = match[1];
      var match$3 = split_scheme(l[1]);
      var l2$1 = match$3[1];
      var l1$1 = match$3[0];
      var names = function (inds, recs, isdep, y, z) {
        var ind = Curry._1(Smartlocate$ReactTemplate.smart_global_inductive, y);
        var sort_of_ind = Inductive$ReactTemplate.inductive_sort_family(Inductive$ReactTemplate.lookup_mind_specif(env, ind)[1]);
        var suffix;
        if (sort_of_ind !== 0) {
          if (isdep) {
            switch (z) {
              case 0 : 
                  suffix = inds;
                  break;
              case 1 : 
                  suffix = recs;
                  break;
              case 2 : 
                  suffix = recs + "t";
                  break;
              
            }
          } else {
            switch (z) {
              case 0 : 
                  suffix = inds + "_nodep";
                  break;
              case 1 : 
                  suffix = recs + "_nodep";
                  break;
              case 2 : 
                  suffix = recs + "t_nodep";
                  break;
              
            }
          }
        } else if (isdep) {
          switch (z) {
            case 0 : 
                suffix = inds + "_dep";
                break;
            case 1 : 
                suffix = recs + "_dep";
                break;
            case 2 : 
                suffix = recs + "t_dep";
                break;
            
          }
        } else {
          switch (z) {
            case 0 : 
                suffix = inds;
                break;
            case 1 : 
                suffix = recs;
                break;
            case 2 : 
                suffix = recs + "t";
                break;
            
          }
        }
        var newid = Nameops$ReactTemplate.add_suffix(Nametab$ReactTemplate.basename_of_global(/* IndRef */Block.__(2, [ind])), suffix);
        var newref = CAst$ReactTemplate.make(/* None */0, newid);
        return /* tuple */[
                /* :: */[
                  /* tuple */[
                    newref,
                    isdep,
                    ind,
                    z
                  ],
                  l1$1
                ],
                l2$1
              ];
      };
      switch (t$1.tag | 0) {
        case 0 : 
            return names("_ind", "_rec", t$1[0], t$1[1], t$1[2]);
        case 1 : 
            return names("_case", "_case", t$1[0], t$1[1], t$1[2]);
        case 2 : 
            return /* tuple */[
                    l1$1,
                    /* :: */[
                      /* tuple */[
                        /* None */0,
                        Curry._1(Smartlocate$ReactTemplate.smart_global_inductive, t$1[0])
                      ],
                      l2$1
                    ]
                  ];
        
      }
    }
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function do_mutual_induction_scheme(lnamedepindsort) {
  var lrecnames = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return param[0][/* v */0];
        }), lnamedepindsort);
  var env0 = Global$ReactTemplate.env(/* () */0);
  var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
          var inst = param$1[2];
          var ind = param[2];
          var match;
          if (inst) {
            match = /* tuple */[
              param$1[0],
              /* tuple */[
                ind,
                inst[0]
              ],
              inst
            ];
          } else {
            var match$1 = Global$ReactTemplate.type_of_global_in_context(env0, /* IndRef */Block.__(2, [ind]));
            var match$2 = Universes$ReactTemplate.fresh_instance_from(match$1[1], /* None */0);
            var u = match$2[0];
            var evd = Evd$ReactTemplate.from_ctx(UState$ReactTemplate.of_context_set(match$2[1]));
            match = /* tuple */[
              evd,
              /* tuple */[
                ind,
                u
              ],
              /* Some */[u]
            ];
          }
          return /* tuple */[
                  match[0],
                  /* :: */[
                    /* tuple */[
                      match[1],
                      param[1],
                      param[3]
                    ],
                    param$1[1]
                  ],
                  match[2]
                ];
        }), lnamedepindsort, /* tuple */[
        Evd$ReactTemplate.from_env(env0),
        /* [] */0,
        /* None */0
      ]);
  var match$1 = Indrec$ReactTemplate.build_mutual_induction_scheme(env0, match[0], match[1]);
  var sigma = match$1[0];
  var declare = function (decl, fi, lrecref) {
    var decltype = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env0, sigma, EConstr$ReactTemplate.of_constr(decl));
    var decltype$1 = EConstr$ReactTemplate.to_constr(sigma, decltype);
    var proof_output = Future$ReactTemplate.from_val(/* None */0, /* tuple */[
          /* tuple */[
            decl,
            Univ$ReactTemplate.ContextSet[/* empty */0]
          ],
          Safe_typing$ReactTemplate.empty_private_constants
        ]);
    var cst = define(fi, /* UserIndividualRequest */2, sigma, proof_output, /* Some */[decltype$1]);
    return /* :: */[
            /* ConstRef */Block.__(1, [cst]),
            lrecref
          ];
  };
  Curry._4(Util$ReactTemplate.List[/* fold_right2 */19], declare, match$1[1], lrecnames, /* [] */0);
  return Declare$ReactTemplate.fixpoint_message(/* None */0, lrecnames);
}

function get_common_underlying_mutual_inductive(all) {
  if (all) {
    var ind = all[0][1];
    var mind = ind[0];
    var match = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
            return 1 - Names$ReactTemplate.MutInd[/* equal */12](mind, param[1][0]);
          }), all[1]);
    if (match) {
      throw [
            Indrec$ReactTemplate.RecursionSchemeError,
            /* NotMutualInScheme */Block.__(1, [
                ind,
                match[0][1]
              ])
          ];
    } else {
      if (!Curry._2(Util$ReactTemplate.List[/* distinct_f */59], Caml_primitive.caml_int_compare, Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                    return prim[1];
                  }), Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                        return prim[1];
                      }), all)))) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("A type occurs twice"));
      }
      return /* tuple */[
              mind,
              Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function (param) {
                      var match = param[0];
                      if (match) {
                        return /* Some */[/* tuple */[
                                  param[1][1],
                                  match[0][/* v */0]
                                ]];
                      } else {
                        return /* None */0;
                      }
                    }), all)
            ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "indschemes.ml",
            403,
            10
          ]
        ];
  }
}

function do_scheme(l) {
  var match = split_scheme(l);
  var escheme = match[1];
  var ischeme = match[0];
  if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], ischeme) && !Curry._1(Util$ReactTemplate.List[/* is_empty */45], escheme)) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Do not declare equality and induction scheme at the same time."));
  } else if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], ischeme)) {
    var match$1 = get_common_underlying_mutual_inductive(escheme);
    var l$1 = match$1[1];
    var mind = match$1[0];
    declare_beq_scheme_with(l$1, mind);
    return declare_eq_decidability_scheme_with(l$1, mind);
  } else {
    return do_mutual_induction_scheme(ischeme);
  }
}

function list_split_rev_at(index, l) {
  var _i = 0;
  var _acc = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var acc = _acc;
    var i = _i;
    if (param) {
      var tl = param[1];
      if (i === index) {
        return /* tuple */[
                acc,
                tl
              ];
      } else {
        _param = tl;
        _acc = /* :: */[
          param[0],
          acc
        ];
        _i = i + 1 | 0;
        continue ;
        
      }
    } else {
      return Pervasives.failwith("List.split_when: Invalid argument");
    }
  };
}

function fold_left$prime(f, param) {
  if (param) {
    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], f, param[0], param[1]);
  } else {
    return CErrors$ReactTemplate.invalid_arg(/* None */0, "fold_left'");
  }
}

function build_combined_scheme(env, schemes) {
  var evdref = [Evd$ReactTemplate.from_env(env)];
  var defs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (cst) {
          var match = Evd$ReactTemplate.fresh_constant_instance(/* None */0, env, evdref[0], cst);
          var c = match[1];
          evdref[0] = match[0];
          return /* tuple */[
                  c,
                  Typeops$ReactTemplate.type_of_constant_in(env, c)
                ];
        }), schemes);
  var find_inductive = function (ty) {
    var match = Term$ReactTemplate.decompose_prod(ty);
    var ctx = match[0];
    var match$1 = Curry._1(Util$ReactTemplate.List[/* hd */1], ctx);
    var last = match$1[1];
    var match$2 = Constr$ReactTemplate.kind(last);
    if (match$2.tag === 9) {
      var ind = Constr$ReactTemplate.destInd(match$2[0]);
      var match$3 = Inductive$ReactTemplate.lookup_mind_specif(env, ind[0]);
      return /* tuple */[
              ctx,
              ind,
              match$3[1][/* mind_nrealargs */5]
            ];
    } else {
      return /* tuple */[
              ctx,
              Constr$ReactTemplate.destInd(last),
              0
            ];
    }
  };
  var match = Curry._1(Util$ReactTemplate.List[/* hd */1], defs);
  var t = match[1];
  var match$1 = find_inductive(t);
  var prods = Termops$ReactTemplate.nb_prod(evdref[0], EConstr$ReactTemplate.of_constr(t)) - (match$1[2] + 1 | 0) | 0;
  var match$2 = Evarutil$ReactTemplate.new_global(evdref[0], Coqlib$ReactTemplate.build_coq_and(/* () */0));
  var coqand = match$2[1];
  var match$3 = Evarutil$ReactTemplate.new_global(match$2[0], Coqlib$ReactTemplate.build_coq_conj(/* () */0));
  var coqconj = match$3[1];
  evdref[0] = match$3[0];
  var relargs = Termops$ReactTemplate.rel_vect(0, prods);
  var concls = Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (param) {
          return /* tuple */[
                  Constr$ReactTemplate.mkApp(/* tuple */[
                        Constr$ReactTemplate.mkConstU(param[0]),
                        relargs
                      ]),
                  Term$ReactTemplate.decompose_prod_n(prods)(param[1])[1]
                ];
        }), defs);
  var match$4 = fold_left$prime((function (param, param$1) {
          var x = param$1[1];
          var acct = param[1];
          return /* tuple */[
                  Constr$ReactTemplate.mkApp(/* tuple */[
                        EConstr$ReactTemplate.to_constr(evdref[0], coqconj),
                        /* array */[
                          x,
                          acct,
                          param$1[0],
                          param[0]
                        ]
                      ]),
                  Constr$ReactTemplate.mkApp(/* tuple */[
                        EConstr$ReactTemplate.to_constr(evdref[0], coqand),
                        /* array */[
                          x,
                          acct
                        ]
                      ])
                ];
        }), concls);
  var match$5 = list_split_rev_at(prods, Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (param) {
              return /* LocalAssum */Block.__(0, [
                        param[0],
                        param[1]
                      ]);
            }), match$1[0]));
  var ctx = match$5[0];
  var typ = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (d, c) {
          return Term$ReactTemplate.mkProd_wo_LetIn(c, d);
        }), match$4[1], ctx);
  var body = Curry._1(Termops$ReactTemplate.it_mkLambda_or_LetIn(match$4[0]), ctx);
  return /* tuple */[
          evdref[0],
          body,
          typ
        ];
}

function do_combined_scheme(name, schemes) {
  var csts = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var qualid = Libnames$ReactTemplate.qualid_of_ident(param[/* v */0]);
          try {
            return Nametab$ReactTemplate.locate_constant(qualid);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return CErrors$ReactTemplate.user_err(param[/* loc */1], /* None */0, Pp$ReactTemplate.$plus$plus(Libnames$ReactTemplate.pr_qualid(qualid), Pp$ReactTemplate.str(" is not declared.")));
            } else {
              throw exn;
            }
          }
        }), schemes);
  var match = build_combined_scheme(Global$ReactTemplate.env(/* () */0), csts);
  var proof_output = Future$ReactTemplate.from_val(/* None */0, /* tuple */[
        /* tuple */[
          match[1],
          Univ$ReactTemplate.ContextSet[/* empty */0]
        ],
        Safe_typing$ReactTemplate.empty_private_constants
      ]);
  define(name[/* v */0], /* UserIndividualRequest */2, match[0], proof_output, /* Some */[match[2]]);
  return Declare$ReactTemplate.fixpoint_message(/* None */0, /* :: */[
              name[/* v */0],
              /* [] */0
            ]);
}

function map_inductive_block(f, kn, n) {
  for(var i = 0 ,i_finish = n - 1 | 0; i <= i_finish; ++i){
    Curry._1(f, /* tuple */[
          kn,
          i
        ]);
  }
  return /* () */0;
}

function declare_default_schemes(kn) {
  var mib = Global$ReactTemplate.lookup_mind(kn);
  var n = mib[/* mind_packets */0].length;
  if (elim_flag[0] && (mib[/* mind_finite */2] !== /* BiFinite */2 || bifinite_elim_flag[0]) && mib[/* mind_typing_flags */10][/* check_guarded */0]) {
    declare_induction_schemes(kn);
  }
  if (case_flag[0]) {
    map_inductive_block(declare_one_case_analysis_scheme, kn, n);
  }
  if (eq_flag[0]) {
    try_declare_beq_scheme(kn);
  }
  if (eq_dec_flag[0]) {
    try_declare_eq_decidability(kn);
  }
  if (rewriting_flag[0]) {
    map_inductive_block(declare_congr_scheme, kn, n);
  }
  if (rewriting_flag[0]) {
    map_inductive_block(declare_sym_scheme, kn, n);
  }
  if (rewriting_flag[0]) {
    return map_inductive_block(declare_rewriting_schemes, kn, n);
  } else {
    return 0;
  }
}

exports.declare_beq_scheme = declare_beq_scheme;
exports.declare_eq_decidability = declare_eq_decidability;
exports.declare_congr_scheme = declare_congr_scheme;
exports.declare_rewriting_schemes = declare_rewriting_schemes;
exports.do_mutual_induction_scheme = do_mutual_induction_scheme;
exports.do_scheme = do_scheme;
exports.build_combined_scheme = build_combined_scheme;
exports.do_combined_scheme = do_combined_scheme;
exports.declare_default_schemes = declare_default_schemes;
/*  Not a pure module */
