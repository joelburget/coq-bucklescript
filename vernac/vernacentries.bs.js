// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Lazy = require("bs-platform/lib/js/lazy.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Caml_sys = require("bs-platform/lib/js/caml_sys.js");
var Filename = require("bs-platform/lib/js/filename.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_oo_curry = require("bs-platform/lib/js/caml_oo_curry.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var Loc$ReactTemplate = require("../src/loc.bs.js");
var Evar$ReactTemplate = require("../src/evar.bs.js");
var Goal$ReactTemplate = require("../src/goal.bs.js");
var Hook$ReactTemplate = require("../src/hook.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Class$ReactTemplate = require("./class.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Hints$ReactTemplate = require("../tactics/hints.bs.js");
var Logic$ReactTemplate = require("../src/logic.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Proof$ReactTemplate = require("../src/proof.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Lemmas$ReactTemplate = require("../src/lemmas.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var Pfedit$ReactTemplate = require("../src/pfedit.bs.js");
var Record$ReactTemplate = require("./record.bs.js");
var Search$ReactTemplate = require("./search.bs.js");
var Topfmt$ReactTemplate = require("./topfmt.bs.js");
var UGraph$ReactTemplate = require("../src/uGraph.bs.js");
var UState$ReactTemplate = require("../src/uState.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var CString$ReactTemplate = require("../src/cString.bs.js");
var Caml_missing_polyfill = require("bs-platform/lib/js/caml_missing_polyfill.js");
var Classes$ReactTemplate = require("./classes.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var Control$ReactTemplate = require("../shims/control.bs.js");
var Declare$ReactTemplate = require("../src/declare.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Impargs$ReactTemplate = require("../src/impargs.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Prettyp$ReactTemplate = require("../printing/prettyp.bs.js");
var Printer$ReactTemplate = require("../src/printer.bs.js");
var Redexpr$ReactTemplate = require("../proofs/redexpr.bs.js");
var Reserve$ReactTemplate = require("../src/reserve.bs.js");
var Tacmach$ReactTemplate = require("../proofs/tacmach.bs.js");
var Tactics$ReactTemplate = require("../src/tactics.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var CClosure$ReactTemplate = require("../src/cClosure.bs.js");
var Detyping$ReactTemplate = require("../src/detyping.bs.js");
var Evarconv$ReactTemplate = require("../src/evarconv.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Locality$ReactTemplate = require("./locality.bs.js");
var Notation$ReactTemplate = require("../src/notation.bs.js");
var Ppvernac$ReactTemplate = require("../src/ppvernac.bs.js");
var Printmod$ReactTemplate = require("../printing/printmod.bs.js");
var Retyping$ReactTemplate = require("../src/retyping.bs.js");
var CWarnings$ReactTemplate = require("../src/cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Genintern$ReactTemplate = require("../src/genintern.bs.js");
var Globnames$ReactTemplate = require("../src/globnames.bs.js");
var Modintern$ReactTemplate = require("../src/modintern.bs.js");
var Recordops$ReactTemplate = require("../src/recordops.bs.js");
var Tacticals$ReactTemplate = require("../tactics/tacticals.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var ExplainErr$ReactTemplate = require("../src/explainErr.bs.js");
var Metasyntax$ReactTemplate = require("./metasyntax.bs.js");
var Assumptions$ReactTemplate = require("./assumptions.bs.js");
var Conv_oracle$ReactTemplate = require("../src/conv_oracle.bs.js");
var Declaremods$ReactTemplate = require("../src/declaremods.bs.js");
var Logic_monad$ReactTemplate = require("../src/logic_monad.bs.js");
var Obligations$ReactTemplate = require("../src/obligations.bs.js");
var Proof_using$ReactTemplate = require("../src/proof_using.bs.js");
var Safe_typing$ReactTemplate = require("../src/safe_typing.bs.js");
var Smartlocate$ReactTemplate = require("../shims/smartlocate.bs.js");
var Vernacstate$ReactTemplate = require("../src/vernacstate.bs.js");
var Constrextern$ReactTemplate = require("../src/constrextern.bs.js");
var Constrintern$ReactTemplate = require("../src/constrintern.bs.js");
var Inductiveops$ReactTemplate = require("../src/inductiveops.bs.js");
var Notation_ops$ReactTemplate = require("../src/notation_ops.bs.js");
var Proof_bullet$ReactTemplate = require("../src/proof_bullet.bs.js");
var Proof_global$ReactTemplate = require("../src/proof_global.bs.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");
var Vernacinterp$ReactTemplate = require("./vernacinterp.bs.js");
var Arguments_renaming$ReactTemplate = require("../src/arguments_renaming.bs.js");
var Implicit_quantifiers$ReactTemplate = require("../src/implicit_quantifiers.bs.js");

var match = Hook$ReactTemplate.make(/* None */0, /* () */0);

var f_interp_redexp = match[0];

function vernac_pperr_endline() {
  return /* () */0;
}

function cl_of_qualid(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return /* CL_SORT */0;
    } else {
      return /* CL_FUN */1;
    }
  } else {
    return Class$ReactTemplate.class_of_global(Curry._2(Smartlocate$ReactTemplate.smart_global, /* Some */[/* true */1], param[0]));
  }
}

function scope_class_of_qualid(qid) {
  return Notation$ReactTemplate.scope_class_of_class(cl_of_qualid(qid));
}

function make_cases_aux(glob_ref) {
  if (glob_ref.tag === 2) {
    var ind = glob_ref[0];
    var match = Global$ReactTemplate.lookup_inductive(ind);
    var np = match[0][/* mind_nparams */5];
    return Util$ReactTemplate.$$Array[/* fold_right_i */37]((function (i, typ, l) {
                  var al = Curry._1(Util$ReactTemplate.List[/* rev */4], Term$ReactTemplate.decompose_prod(typ)[0]);
                  var al$1 = Curry._2(Util$ReactTemplate.List[/* skipn */107], np, al);
                  var rename = function (avoid, param) {
                    if (param) {
                      var n$prime = Namegen$ReactTemplate.next_name_away_with_default(Names$ReactTemplate.Id[/* to_string */7](Namegen$ReactTemplate.default_dependent_ident), param[0][0], avoid);
                      return /* :: */[
                              Names$ReactTemplate.Id[/* to_string */7](n$prime),
                              rename(Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], n$prime, avoid), param[1])
                            ];
                    } else {
                      return /* [] */0;
                    }
                  };
                  var al$prime = rename(Names$ReactTemplate.Id[/* Set */9][/* empty */0], al$1);
                  var consref = /* ConstructRef */Block.__(3, [Names$ReactTemplate.ith_constructor_of_inductive(ind, i + 1 | 0)]);
                  return /* :: */[
                          /* :: */[
                            Libnames$ReactTemplate.string_of_qualid(Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], consref)),
                            al$prime
                          ],
                          l
                        ];
                }), match[1][/* mind_nf_lc */8], /* [] */0);
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function make_cases(s) {
  var qualified_name = Libnames$ReactTemplate.qualid_of_string(s);
  return make_cases_aux(Nametab$ReactTemplate.locate(qualified_name));
}

Pervasives.failwith("undefined: msg_found_library");

function dump_global() {
  return Pervasives.failwith("undefined: dump_global");
}

function vernac_arguments_scope(atts, _, scl) {
  var local = Locality$ReactTemplate.make_section_locality(atts[/* locality */1]);
  return Notation$ReactTemplate.declare_arguments_scope(local, Pervasives.failwith("undefined: smart_global"), scl);
}

function vernac_infix(atts) {
  var local = Locality$ReactTemplate.enforce_module_locality(atts[/* locality */1]);
  var partial_arg = Global$ReactTemplate.env(/* () */0);
  return (function (param, param$1, param$2) {
      return Metasyntax$ReactTemplate.add_infix(local, partial_arg, param, param$1, param$2);
    });
}

function vernac_notation(atts) {
  var local = Locality$ReactTemplate.enforce_module_locality(atts[/* locality */1]);
  var partial_arg = Global$ReactTemplate.env(/* () */0);
  return (function (param, param$1, param$2) {
      return Metasyntax$ReactTemplate.add_notation(local, partial_arg, param, param$1, param$2);
    });
}

Lemmas$ReactTemplate.mk_hook((function (_, _$1) {
        return /* () */0;
      }));

CWarnings$ReactTemplate.create("require-in-section", "deprecated", /* None */0, (function () {
        return Pp$ReactTemplate.strbrk("Use of \xe2\x80\x9cRequire\xe2\x80\x9d inside a section is deprecated.");
      }));

function vernac_require(_, _$1, _$2) {
  return Pervasives.failwith("undefined: vernac_require");
}

var command_focus = Proof$ReactTemplate.new_focus_kind(/* () */0);

var focus_command_cond = Proof$ReactTemplate.no_cond(/* None */0, command_focus);

function vernac_set_end_tac(tac) {
  var env = Genintern$ReactTemplate.empty_glob_sign(Global$ReactTemplate.env(/* () */0));
  var match = Genintern$ReactTemplate.generic_intern(env, tac);
  if (!Proof_global$ReactTemplate.there_are_pending_proofs(/* () */0)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Unknown command of the non proof-editing mode."));
  }
  return Proof_global$ReactTemplate.set_endline_tactic(match[1]);
}

function vernac_set_used_variables(e) {
  var env = Global$ReactTemplate.env(/* () */0);
  var tys = Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
          return prim[1];
        }), Proof$ReactTemplate.initial_goals(Proof_global$ReactTemplate.give_me_the_proof(/* () */0)));
  var tys$1 = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.Unsafe[/* to_constr */0], tys);
  var l = Proof_using$ReactTemplate.process_expr(env, e, tys$1);
  var vars = Environ$ReactTemplate.named_context(env);
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (id) {
          var partial_arg = Names$ReactTemplate.Id[/* equal */0];
          var partial_arg$1 = function (param) {
            return partial_arg(id, param);
          };
          var partial_arg$2 = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
          if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                    return Util$ReactTemplate.$percent$great(partial_arg$2, partial_arg$1, param);
                  }), vars)) {
            return 0;
          } else {
            return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["vernac_set_used_variables"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unknown variable: "), Names$ReactTemplate.Id[/* print */8](id)));
          }
        }), l);
  var match = Proof_global$ReactTemplate.set_used_variables(l);
  var to_clear = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
          return x[/* v */0];
        }), match[1]);
  return Proof_global$ReactTemplate.with_current_proof((function (_, p) {
                if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], to_clear)) {
                  return /* tuple */[
                          p,
                          /* () */0
                        ];
                } else {
                  var tac = Tactics$ReactTemplate.clear(to_clear);
                  return /* tuple */[
                          Pfedit$ReactTemplate.solve(/* None */0, /* SelectAll */0, /* None */0, tac, p)[0],
                          /* () */0
                        ];
                }
              }));
}

function vernac_declare_implicits(atts, _, l) {
  var local = Locality$ReactTemplate.make_section_locality(atts[/* locality */1]);
  if (l) {
    return Impargs$ReactTemplate.declare_manual_implicits(local, Pervasives.failwith("undefined: smart_global"), /* Some */[/* false */0], Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Util$ReactTemplate.List[/* map */10], (function (param) {
                          return /* tuple */[
                                  param[0],
                                  /* tuple */[
                                    param[1],
                                    /* true */1,
                                    param[2]
                                  ]
                                ];
                        })), l));
  } else {
    return Impargs$ReactTemplate.declare_implicits(local, Pervasives.failwith("undefined: smart_global"));
  }
}

var warn_arguments_assert = CWarnings$ReactTemplate.create("arguments-assert", "vernacular", /* None */0, (function (sr) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("This command is just asserting the names of arguments of "), Printer$ReactTemplate.pr_global(sr)), Pp$ReactTemplate.strbrk(". If this is what you want add ")), Pp$ReactTemplate.strbrk("': assert' to silence the warning. If you want ")), Pp$ReactTemplate.strbrk("to clear implicit arguments add ': clear implicits'. ")), Pp$ReactTemplate.strbrk("If you want to clear notation scopes add ': clear scopes'"));
      }));

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"silent",
      /* optkey : :: */[
        "Silent",
        /* [] */0
      ],
      /* optread */(function () {
          return Flags$ReactTemplate.quiet[0];
        }),
      /* optwrite */(function (param) {
          Flags$ReactTemplate.quiet[0] = param;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"implicit arguments",
      /* optkey : :: */[
        "Implicit",
        /* :: */[
          "Arguments",
          /* [] */0
        ]
      ],
      /* optread */Impargs$ReactTemplate.is_implicit_args,
      /* optwrite */Impargs$ReactTemplate.make_implicit_args
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"strict implicit arguments",
      /* optkey : :: */[
        "Strict",
        /* :: */[
          "Implicit",
          /* [] */0
        ]
      ],
      /* optread */Impargs$ReactTemplate.is_strict_implicit_args,
      /* optwrite */Impargs$ReactTemplate.make_strict_implicit_args
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"strong strict implicit arguments",
      /* optkey : :: */[
        "Strongly",
        /* :: */[
          "Strict",
          /* :: */[
            "Implicit",
            /* [] */0
          ]
        ]
      ],
      /* optread */Impargs$ReactTemplate.is_strongly_strict_implicit_args,
      /* optwrite */Impargs$ReactTemplate.make_strongly_strict_implicit_args
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"contextual implicit arguments",
      /* optkey : :: */[
        "Contextual",
        /* :: */[
          "Implicit",
          /* [] */0
        ]
      ],
      /* optread */Impargs$ReactTemplate.is_contextual_implicit_args,
      /* optwrite */Impargs$ReactTemplate.make_contextual_implicit_args
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"implicit status of reversible patterns",
      /* optkey : :: */[
        "Reversible",
        /* :: */[
          "Pattern",
          /* :: */[
            "Implicit",
            /* [] */0
          ]
        ]
      ],
      /* optread */Impargs$ReactTemplate.is_reversible_pattern_implicit_args,
      /* optwrite */Impargs$ReactTemplate.make_reversible_pattern_implicit_args
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"maximal insertion of implicit",
      /* optkey : :: */[
        "Maximal",
        /* :: */[
          "Implicit",
          /* :: */[
            "Insertion",
            /* [] */0
          ]
        ]
      ],
      /* optread */Impargs$ReactTemplate.is_maximal_implicit_args,
      /* optwrite */Impargs$ReactTemplate.make_maximal_implicit_args
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : true */1,
      /* optname */"automatic introduction of variables",
      /* optkey : :: */[
        "Automatic",
        /* :: */[
          "Introduction",
          /* [] */0
        ]
      ],
      /* optread */Flags$ReactTemplate.is_auto_intros,
      /* optwrite */Flags$ReactTemplate.make_auto_intros
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"coercion printing",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Coercions",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return Constrextern$ReactTemplate.print_coercions[0];
        }),
      /* optwrite */(function (b) {
          Constrextern$ReactTemplate.print_coercions[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"printing of existential variable instances",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Existential",
          /* :: */[
            "Instances",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return Detyping$ReactTemplate.print_evar_arguments[0];
        }),
      /* optwrite */(function (param) {
          Detyping$ReactTemplate.print_evar_arguments[0] = param;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"implicit arguments printing",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Implicit",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return Constrextern$ReactTemplate.print_implicits[0];
        }),
      /* optwrite */(function (b) {
          Constrextern$ReactTemplate.print_implicits[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"implicit arguments defensive printing",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Implicit",
          /* :: */[
            "Defensive",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return Constrextern$ReactTemplate.print_implicits_defensive[0];
        }),
      /* optwrite */(function (b) {
          Constrextern$ReactTemplate.print_implicits_defensive[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"projection printing using dot notation",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Projections",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return Constrextern$ReactTemplate.print_projections[0];
        }),
      /* optwrite */(function (b) {
          Constrextern$ReactTemplate.print_projections[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"notations printing",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Notations",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return 1 - Constrextern$ReactTemplate.print_no_symbol[0];
        }),
      /* optwrite */(function (b) {
          Constrextern$ReactTemplate.print_no_symbol[0] = 1 - b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"raw printing",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "All",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return Flags$ReactTemplate.raw_print[0];
        }),
      /* optwrite */(function (b) {
          Flags$ReactTemplate.raw_print[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"use of the program extension",
      /* optkey : :: */[
        "Program",
        /* :: */[
          "Mode",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return Flags$ReactTemplate.program_mode[0];
        }),
      /* optwrite */(function (b) {
          Flags$ReactTemplate.program_mode[0] = b;
          return /* () */0;
        })
    ]);

var universe_polymorphism_option_name = /* :: */[
  "Universe",
  /* :: */[
    "Polymorphism",
    /* [] */0
  ]
];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"universe polymorphism",
      /* optkey */universe_polymorphism_option_name,
      /* optread */Flags$ReactTemplate.is_universe_polymorphism,
      /* optwrite */Flags$ReactTemplate.make_universe_polymorphism
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"Polymorphic inductive cumulativity",
      /* optkey : :: */[
        "Polymorphic",
        /* :: */[
          "Inductive",
          /* :: */[
            "Cumulativity",
            /* [] */0
          ]
        ]
      ],
      /* optread */Flags$ReactTemplate.is_polymorphic_inductive_cumulativity,
      /* optwrite */Flags$ReactTemplate.make_polymorphic_inductive_cumulativity
    ]);

Goptions$ReactTemplate.declare_int_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"the level of inlining during functor application",
      /* optkey : :: */[
        "Inline",
        /* :: */[
          "Level",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return /* Some */[Flags$ReactTemplate.get_inline_level(/* () */0)];
        }),
      /* optwrite */(function (o) {
          return Flags$ReactTemplate.set_inline_level(Option$ReactTemplate.$$default(Flags$ReactTemplate.default_inline_level, o));
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"kernel term sharing",
      /* optkey : :: */[
        "Kernel",
        /* :: */[
          "Term",
          /* :: */[
            "Sharing",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return CClosure$ReactTemplate.share[0];
        }),
      /* optwrite */(function (b) {
          CClosure$ReactTemplate.share[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"display compact goal contexts",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Compact",
          /* :: */[
            "Contexts",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return Curry._1(Printer$ReactTemplate.get_compact_context, /* () */0);
        }),
      /* optwrite */(function (b) {
          return Curry._1(Printer$ReactTemplate.set_compact_context, b);
        })
    ]);

Goptions$ReactTemplate.declare_int_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"the printing depth",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Depth",
          /* [] */0
        ]
      ],
      /* optread */Topfmt$ReactTemplate.get_depth_boxes,
      /* optwrite */Topfmt$ReactTemplate.set_depth_boxes
    ]);

Goptions$ReactTemplate.declare_int_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"the printing width",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Width",
          /* [] */0
        ]
      ],
      /* optread */Topfmt$ReactTemplate.get_margin,
      /* optwrite */Topfmt$ReactTemplate.set_margin
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"printing of universes",
      /* optkey : :: */[
        "Printing",
        /* :: */[
          "Universes",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return Constrextern$ReactTemplate.print_universes[0];
        }),
      /* optwrite */(function (b) {
          Constrextern$ReactTemplate.print_universes[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"dumping bytecode after compilation",
      /* optkey : :: */[
        "Dump",
        /* :: */[
          "Bytecode",
          /* [] */0
        ]
      ],
      /* optread */Flags$ReactTemplate.get_dump_bytecode,
      /* optwrite */Flags$ReactTemplate.set_dump_bytecode
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"dumping VM lambda code after compilation",
      /* optkey : :: */[
        "Dump",
        /* :: */[
          "Lambda",
          /* [] */0
        ]
      ],
      /* optread */Flags$ReactTemplate.get_dump_lambda,
      /* optwrite */Flags$ReactTemplate.set_dump_lambda
    ]);

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"explicitly parsing implicit arguments",
      /* optkey : :: */[
        "Parsing",
        /* :: */[
          "Explicit",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return Constrintern$ReactTemplate.parsing_explicit[0];
        }),
      /* optwrite */(function (b) {
          Constrintern$ReactTemplate.parsing_explicit[0] = b;
          return /* () */0;
        })
    ]);

Goptions$ReactTemplate.declare_string_option(/* Some */[CWarnings$ReactTemplate.normalize_flags_string], /* record */[
      /* optdepr : false */0,
      /* optname */"warnings display",
      /* optkey : :: */[
        "Warnings",
        /* [] */0
      ],
      /* optread */CWarnings$ReactTemplate.get_flags,
      /* optwrite */CWarnings$ReactTemplate.set_flags
    ]);

function get_option_locality($$export, local) {
  if ($$export) {
    if (Option$ReactTemplate.is_empty(local)) {
      return /* OptExport */2;
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Locality modifiers forbidden with Export"));
    }
  } else if (local) {
    if (local[0] !== 0) {
      return /* OptLocal */1;
    } else {
      return /* OptGlobal */3;
    }
  } else {
    return /* OptDefault */0;
  }
}

function vernac_set_option0(atts, $$export, key, opt) {
  var locality = get_option_locality($$export, atts[/* locality */1]);
  switch (opt.tag | 0) {
    case 0 : 
        return Goptions$ReactTemplate.set_bool_option_value_gen(/* Some */[locality], key, opt[0]);
    case 1 : 
        return Goptions$ReactTemplate.set_int_option_value_gen(/* Some */[locality])(key, opt[0]);
    case 2 : 
        return Goptions$ReactTemplate.set_string_option_value_gen(/* Some */[locality])(key, opt[0]);
    case 3 : 
        var match = opt[0];
        if (match) {
          return Goptions$ReactTemplate.set_string_option_value_gen(/* Some */[locality])(key, match[0]);
        } else {
          return Goptions$ReactTemplate.unset_option_value_gen(/* Some */[locality], key);
        }
    
  }
}

function vernac_set_append_option(atts, $$export, key, s) {
  var locality = get_option_locality($$export, atts[/* locality */1]);
  return Goptions$ReactTemplate.set_string_option_append_value_gen(/* Some */[locality], key, s);
}

function get_current_context_of_args(param) {
  if (param) {
    return Pfedit$ReactTemplate.get_goal_context(param[0]);
  } else {
    return Pfedit$ReactTemplate.get_current_context(/* () */0);
  }
}

function query_command_selector(loc, param) {
  if (param) {
    var match = param[0];
    if (typeof match === "number") {
      return CErrors$ReactTemplate.user_err(loc, /* Some */["query_command_selector"], Pp$ReactTemplate.str("Query commands only support the single numbered goal selector."));
    } else if (match.tag) {
      return CErrors$ReactTemplate.user_err(loc, /* Some */["query_command_selector"], Pp$ReactTemplate.str("Query commands only support the single numbered goal selector."));
    } else {
      return /* Some */[match[0]];
    }
  } else {
    return /* None */0;
  }
}

function vernac_check_may_eval(atts, redexp, glopt, rc) {
  var glopt$1 = query_command_selector(atts[/* loc */0], glopt);
  var match = get_current_context_of_args(glopt$1);
  var env = match[1];
  var sigma = match[0];
  var match$1 = Constrintern$ReactTemplate.interp_open_constr(env, sigma, rc);
  var c = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match$1[1]);
  var sigma$prime = Evarconv$ReactTemplate.solve_unif_constraints_with_heuristics(env, /* None */0, match$1[0]);
  Evarconv$ReactTemplate.check_problems_are_solved(env, sigma$prime);
  var match$2 = Evarutil$ReactTemplate.nf_evars_and_universes(sigma$prime);
  var sigma$prime$1 = match$2[0];
  var uctx = Evd$ReactTemplate.universe_context_set(sigma$prime$1);
  var env$1 = Environ$ReactTemplate.push_context_set(/* None */0, uctx, Evarutil$ReactTemplate.nf_env_evar(sigma$prime$1, env));
  var c$1 = Curry._1(match$2[1], c);
  var j = Evarutil$ReactTemplate.has_undefined_evars(sigma$prime$1, EConstr$ReactTemplate.of_constr(c$1)) ? Evarutil$ReactTemplate.j_nf_evar(sigma$prime$1, Retyping$ReactTemplate.get_judgment_of(env$1, sigma$prime$1, EConstr$ReactTemplate.of_constr(c$1))) : Termops$ReactTemplate.on_judgment(EConstr$ReactTemplate.of_constr, Arguments_renaming$ReactTemplate.rename_typing(env$1, c$1));
  if (redexp) {
    var match$3 = Curry._3(Hook$ReactTemplate.get(f_interp_redexp), env$1, sigma$prime$1, redexp[0]);
    var r_interp = match$3[1];
    var redfun = function (env, evm, c) {
      var match = Redexpr$ReactTemplate.reduction_of_red_expr(env)(r_interp);
      return Curry._3(match[0], env, evm, c)[1];
    };
    return Curry._4(Prettyp$ReactTemplate.print_eval(redfun), env$1, match$3[0], rc, j);
  } else {
    var l = Curry._2(Evar$ReactTemplate.$$Set[/* union */6], Evarutil$ReactTemplate.undefined_evars_of_term(sigma$prime$1, j[/* uj_val */0]), Evarutil$ReactTemplate.undefined_evars_of_term(sigma$prime$1, j[/* uj_type */1]));
    var j_000 = /* uj_val */j[/* uj_val */0];
    var j_001 = /* uj_type */Reductionops$ReactTemplate.nf_betaiota(env$1, sigma$prime$1, j[/* uj_type */1]);
    var j$1 = /* record */[
      j_000,
      j_001
    ];
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Prettyp$ReactTemplate.print_judgment(env$1, sigma$prime$1, j$1), Printer$ReactTemplate.pr_ne_evar_set(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str("where")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.mt(/* () */0), sigma$prime$1, l)), Printer$ReactTemplate.pr_universe_ctx_set(sigma, uctx));
  }
}

function vernac_global_check(c) {
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_env(env);
  var match = Constrintern$ReactTemplate.interp_constr(env, sigma, /* None */0, c);
  var senv = Global$ReactTemplate.safe_env(/* () */0);
  var uctx = UState$ReactTemplate.context_set(match[1]);
  var senv$1 = Safe_typing$ReactTemplate.push_context_set(/* false */0, uctx)(senv);
  var c$1 = EConstr$ReactTemplate.to_constr(sigma, match[0]);
  var j = Curry._1(Safe_typing$ReactTemplate.typing(senv$1), c$1);
  var env$1 = Safe_typing$ReactTemplate.env_of_safe_env(senv$1);
  return Pp$ReactTemplate.$plus$plus(Prettyp$ReactTemplate.print_safe_judgment(env$1, sigma, j), Printer$ReactTemplate.pr_universe_ctx_set(sigma, uctx));
}

function get_nth_goal(n) {
  var pf = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
  var match = Proof$ReactTemplate.proof(pf);
  return /* record */[
          /* it */Curry._2(Util$ReactTemplate.List[/* nth */3], match[0], n - 1 | 0),
          /* sigma */match[4]
        ];
}

var NoHyp = Caml_exceptions.create("Vernacentries-ReactTemplate.NoHyp");

function vernac_print(atts, env, sigma) {
  var loc = atts[/* loc */0];
  return (function (param) {
      if (typeof param === "number") {
        switch (param) {
          case 0 : 
              return Goptions$ReactTemplate.print_tables(/* () */0);
          case 1 : 
              return Prettyp$ReactTemplate.print_full_context_typ(env, sigma);
          case 2 : 
              return Pervasives.failwith("undefined: print_modules");
          case 6 : 
              return Prettyp$ReactTemplate.print_graph(env, sigma);
          case 7 : 
              return Prettyp$ReactTemplate.print_classes(/* () */0);
          case 8 : 
              return Prettyp$ReactTemplate.print_typeclasses(/* () */0);
          case 9 : 
              return Prettyp$ReactTemplate.print_coercions(env, sigma);
          case 10 : 
              return Prettyp$ReactTemplate.print_canonical_projections(env, sigma);
          case 11 : 
              return Hints$ReactTemplate.pr_applicable_hint(/* () */0);
          case 12 : 
              return Hints$ReactTemplate.pr_searchtable(env, sigma);
          case 13 : 
              return Notation$ReactTemplate.pr_scopes(Constrextern$ReactTemplate.without_symbols((function (param) {
                                return Printer$ReactTemplate.pr_lglob_constr_env(env, param);
                              })));
          default:
            throw [
                  Caml_builtin_exceptions.match_failure,
                  [
                    "vernacentries.ml",
                    1777,
                    2
                  ]
                ];
        }
      } else {
        switch (param.tag | 0) {
          case 0 : 
              return Prettyp$ReactTemplate.print_sec_context_typ(env, sigma, param[0]);
          case 1 : 
              return Prettyp$ReactTemplate.inspect(env, sigma, param[0]);
          case 2 : 
              return Metasyntax$ReactTemplate.pr_grammar(param[0]);
          case 3 : 
              return Pervasives.failwith("undefined: print_loadpath");
          case 4 : 
              var r = param[0];
              var qid = Libnames$ReactTemplate.qualid_of_reference(r);
              try {
                var globdir = Nametab$ReactTemplate.locate_dir(qid[/* v */0]);
                if (globdir.tag === 3) {
                  var match = globdir[0];
                  return Printmod$ReactTemplate.print_module(Printmod$ReactTemplate.printable_body(match[/* obj_dir */0]), match[/* obj_mp */1]);
                } else {
                  throw Caml_builtin_exceptions.not_found;
                }
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unknown Module "), Libnames$ReactTemplate.pr_qualid(qid[/* v */0])));
                } else {
                  throw exn;
                }
              }
          case 5 : 
              var r$1 = param[0];
              var qid$1 = Libnames$ReactTemplate.qualid_of_reference(r$1);
              try {
                return Printmod$ReactTemplate.print_modtype(Nametab$ReactTemplate.locate_modtype(qid$1[/* v */0]));
              }
              catch (exn$1){
                if (exn$1 === Caml_builtin_exceptions.not_found) {
                  try {
                    var mp = Nametab$ReactTemplate.locate_module(qid$1[/* v */0]);
                    return Printmod$ReactTemplate.print_module(/* false */0, mp);
                  }
                  catch (exn$2){
                    if (exn$2 === Caml_builtin_exceptions.not_found) {
                      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unknown Module Type or Module "), Libnames$ReactTemplate.pr_qualid(qid$1[/* v */0])));
                    } else {
                      throw exn$2;
                    }
                  }
                } else {
                  throw exn$1;
                }
              }
          case 6 : 
              var ns = param[0];
              var ns$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], Names$ReactTemplate.DirPath[/* repr */4](ns));
              var match_dirpath = function (ns, param) {
                if (param) {
                  var y = match_dirpath(ns, param[1]);
                  if (y) {
                    var match = y[0];
                    if (match) {
                      if (Names$ReactTemplate.Id[/* equal */0](match[0], param[0])) {
                        return /* Some */[match[1]];
                      } else {
                        return /* None */0;
                      }
                    } else {
                      return y;
                    }
                  } else {
                    return /* None */0;
                  }
                } else {
                  return /* Some */[ns];
                }
              };
              var match_modulepath = function (ns, param) {
                switch (param.tag | 0) {
                  case 0 : 
                      return match_dirpath(ns, Names$ReactTemplate.DirPath[/* repr */4](param[0]));
                  case 1 : 
                      return /* None */0;
                  case 2 : 
                      var id = Names$ReactTemplate.Label[/* to_id */6](param[1]);
                      var y = match_modulepath(ns, param[0]);
                      if (y) {
                        var match = y[0];
                        if (match) {
                          if (Names$ReactTemplate.Id[/* equal */0](match[0], id)) {
                            return /* Some */[match[1]];
                          } else {
                            return /* None */0;
                          }
                        } else {
                          return y;
                        }
                      } else {
                        return /* None */0;
                      }
                      break;
                  
                }
              };
              var qualified_minus = function (n, mp) {
                var list_of_modulepath = function (param) {
                  switch (param.tag | 0) {
                    case 0 : 
                        return Names$ReactTemplate.DirPath[/* repr */4](param[0]);
                    case 1 : 
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "vernacentries.ml",
                                253,
                                21
                              ]
                            ];
                    case 2 : 
                        return /* :: */[
                                Names$ReactTemplate.Label[/* to_id */6](param[1]),
                                list_of_modulepath(param[0])
                              ];
                    
                  }
                };
                return Curry._2(Util$ReactTemplate.List[/* chop */99], n, Curry._1(Util$ReactTemplate.List[/* rev */4], list_of_modulepath(mp)))[1];
              };
              var print_list = function (pr, l) {
                return Pp$ReactTemplate.prlist_with_sep((function () {
                              return Pp$ReactTemplate.str(".");
                            }), pr, l);
              };
              var print_kn = function (kn) {
                var match = Names$ReactTemplate.KerName[/* repr */2](kn);
                var qn = Util$ReactTemplate.$at(qualified_minus(Curry._1(Util$ReactTemplate.List[/* length */0], ns$1), match[0]), /* :: */[
                      Names$ReactTemplate.Label[/* to_id */6](match[2]),
                      /* [] */0
                    ]);
                return print_list(Names$ReactTemplate.Id[/* print */8], qn);
              };
              var print_constant = function (k, body) {
                var t = body[/* const_type */2];
                var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(print_kn(k), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), Printer$ReactTemplate.pr_type_env(match[1], match[0], t));
              };
              var matches = function (mp) {
                var match = match_modulepath(ns$1, mp);
                if (match && !match[0]) {
                  return /* true */1;
                } else {
                  return /* false */0;
                }
              };
              var constants = Environ$ReactTemplate.pre_env(Global$ReactTemplate.env(/* () */0))[/* env_globals */0][/* env_constants */0];
              var constants_in_namespace = Curry._3(Names$ReactTemplate.Cmap_env[/* fold */10], (function (c, param, acc) {
                      var kn = Names$ReactTemplate.Constant[/* user */4](c);
                      if (matches(Names$ReactTemplate.KerName[/* modpath */3](kn))) {
                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(acc, Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(2, print_constant(kn, param[0])));
                      } else {
                        return acc;
                      }
                    }), constants, Pp$ReactTemplate.str(""));
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(print_list(Names$ReactTemplate.Id[/* print */8], ns$1), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.fnl(/* () */0)), constants_in_namespace);
          case 7 : 
              Pervasives.failwith("undefined: dump_global");
              return Prettyp$ReactTemplate.print_name(env, sigma, param[0], param[1]);
          case 8 : 
              return Prettyp$ReactTemplate.print_instances(Pervasives.failwith("undefined: smart_global"));
          case 9 : 
              return Prettyp$ReactTemplate.print_path_between(env, sigma, cl_of_qualid(param[0]), cl_of_qualid(param[1]));
          case 10 : 
              var dst = param[1];
              var univ = Global$ReactTemplate.universes(/* () */0);
              var univ$1 = param[0] ? UGraph$ReactTemplate.sort_universes(univ) : univ;
              var pr_remaining = Global$ReactTemplate.is_joined_environment(/* () */0) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.str("There may remain asynchronous universe constraints");
              if (dst) {
                var g = univ$1;
                var s = dst[0];
                var output = Pervasives.open_out(s);
                var match$1;
                if (Curry._2(Filename.check_suffix, s, ".dot") || Curry._2(Filename.check_suffix, s, ".gv")) {
                  var init = Block.__(246, [(function () {
                          return Printf.fprintf(output, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "digraph universes {\n",
                                          /* End_of_format */0
                                        ]),
                                      "digraph universes {\n"
                                    ]);
                        })]);
                  match$1 = /* tuple */[
                    (function (kind, left, right) {
                        var tag = init.tag | 0;
                        if (tag !== 250) {
                          if (tag === 246) {
                            CamlinternalLazy.force_lazy_block(init);
                          }
                          
                        }
                        switch (kind) {
                          case 0 : 
                              return Curry._2(Printf.fprintf(output, /* Format */[
                                              /* String_literal */Block.__(11, [
                                                  "  \"",
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* String_literal */Block.__(11, [
                                                          "\" -> \"",
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* String_literal */Block.__(11, [
                                                                  "\" [style=bold];\n",
                                                                  /* End_of_format */0
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ]),
                                              "  \"%s\" -> \"%s\" [style=bold];\n"
                                            ]), right, left);
                          case 1 : 
                              return Curry._2(Printf.fprintf(output, /* Format */[
                                              /* String_literal */Block.__(11, [
                                                  "  \"",
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* String_literal */Block.__(11, [
                                                          "\" -> \"",
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* String_literal */Block.__(11, [
                                                                  "\" [style=solid];\n",
                                                                  /* End_of_format */0
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ]),
                                              "  \"%s\" -> \"%s\" [style=solid];\n"
                                            ]), right, left);
                          case 2 : 
                              return Curry._2(Printf.fprintf(output, /* Format */[
                                              /* String_literal */Block.__(11, [
                                                  "  \"",
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* String_literal */Block.__(11, [
                                                          "\" -> \"",
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* String_literal */Block.__(11, [
                                                                  "\" [style=dashed];\n",
                                                                  /* End_of_format */0
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ]),
                                              "  \"%s\" -> \"%s\" [style=dashed];\n"
                                            ]), left, right);
                          
                        }
                      }),
                    (function () {
                        if (Lazy.is_val(init)) {
                          Printf.fprintf(output, /* Format */[
                                /* String_literal */Block.__(11, [
                                    "}\n",
                                    /* End_of_format */0
                                  ]),
                                "}\n"
                              ]);
                        }
                        return Pervasives.close_out(output);
                      })
                  ];
                } else {
                  match$1 = /* tuple */[
                    (function (kind, left, right) {
                        var kind$1;
                        switch (kind) {
                          case 0 : 
                              kind$1 = "<";
                              break;
                          case 1 : 
                              kind$1 = "<=";
                              break;
                          case 2 : 
                              kind$1 = "=";
                              break;
                          
                        }
                        return Curry._3(Printf.fprintf(output, /* Format */[
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* Char_literal */Block.__(12, [
                                                /* " " */32,
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* Char_literal */Block.__(12, [
                                                        /* " " */32,
                                                        /* String */Block.__(2, [
                                                            /* No_padding */0,
                                                            /* String_literal */Block.__(11, [
                                                                " ;\n",
                                                                /* End_of_format */0
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ]),
                                        "%s %s %s ;\n"
                                      ]), left, kind$1, right);
                      }),
                    (function () {
                        return Pervasives.close_out(output);
                      })
                  ];
                }
                var close = match$1[1];
                try {
                  UGraph$ReactTemplate.dump_universes(match$1[0], g);
                  Curry._1(close, /* () */0);
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Universes written to file \""), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str("\"."));
                }
                catch (raw_reraise){
                  var reraise = Js_exn.internalToOCamlException(raw_reraise);
                  var reraise$1 = CErrors$ReactTemplate.push(reraise);
                  Curry._1(close, /* () */0);
                  return Util$ReactTemplate.iraise(reraise$1);
                }
              } else {
                return Pp$ReactTemplate.$plus$plus(UGraph$ReactTemplate.pr_universes(Universes$ReactTemplate.pr_with_global_universes, univ$1), pr_remaining);
              }
          case 11 : 
              return Hints$ReactTemplate.pr_hint_ref(env)(sigma, Pervasives.failwith("undefined: smart_global"));
          case 12 : 
              return Hints$ReactTemplate.pr_hint_db_by_name(env, sigma, param[0]);
          case 13 : 
              return Notation$ReactTemplate.pr_scope(Constrextern$ReactTemplate.without_symbols((function (param) {
                                return Printer$ReactTemplate.pr_lglob_constr_env(env, param);
                              })), param[0]);
          case 14 : 
              return Notation$ReactTemplate.pr_visibility(Constrextern$ReactTemplate.without_symbols((function (param) {
                                return Printer$ReactTemplate.pr_lglob_constr_env(env, param);
                              })), param[0]);
          case 15 : 
              var loc$1 = loc;
              var ref_or_by_not = param[0];
              var udecl = param[1];
              var glopt = param[2];
              try {
                var glnumopt = query_command_selector(loc$1, glopt);
                var match$2 = ref_or_by_not[/* v */0];
                var match$3;
                if (glnumopt) {
                  var n = glnumopt[0];
                  if (match$2.tag) {
                    throw NoHyp;
                  } else {
                    var match$4 = match$2[0][/* v */0];
                    if (match$4.tag) {
                      try {
                        match$3 = /* tuple */[
                          get_nth_goal(n),
                          match$4[0]
                        ];
                      }
                      catch (raw_exn){
                        var exn$3 = Js_exn.internalToOCamlException(raw_exn);
                        if (exn$3[0] === Caml_builtin_exceptions.failure) {
                          match$3 = CErrors$ReactTemplate.user_err(loc$1, /* Some */["print_about_hyp_globs"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such goal: "), Pp$ReactTemplate.$$int(n)), Pp$ReactTemplate.str(".")));
                        } else {
                          throw exn$3;
                        }
                      }
                    } else {
                      throw NoHyp;
                    }
                  }
                } else if (match$2.tag) {
                  throw NoHyp;
                } else {
                  var match$5 = match$2[0][/* v */0];
                  if (match$5.tag) {
                    try {
                      match$3 = /* tuple */[
                        get_nth_goal(1),
                        match$5[0]
                      ];
                    }
                    catch (exn$4){
                      throw NoHyp;
                    }
                  } else {
                    throw NoHyp;
                  }
                }
                var id = match$3[1];
                var hyps = Tacmach$ReactTemplate.pf_hyps(match$3[0]);
                var decl = Context$ReactTemplate.Named[/* lookup */4](id, hyps);
                var natureofid;
                natureofid = decl.tag ? "Constant (let in)" : "Hypothesis";
                var match$6 = Pfedit$ReactTemplate.get_current_context(/* () */0);
                return Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(":")), Printer$ReactTemplate.pr_econstr_env(match$6[1], match$6[0], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str(natureofid)), Pp$ReactTemplate.str(" of the goal context.")));
              }
              catch (exn$5){
                var exit = 0;
                if (exn$5 === NoHyp) {
                  exit = 1;
                } else if (exn$5 === Caml_builtin_exceptions.not_found) {
                  exit = 1;
                } else {
                  throw exn$5;
                }
                if (exit === 1) {
                  var match$7 = Pfedit$ReactTemplate.get_current_context(/* () */0);
                  return Prettyp$ReactTemplate.print_about(match$7[1], match$7[0], ref_or_by_not, udecl);
                }
                
              }
          case 16 : 
              Pervasives.failwith("undefined: dump_global");
              return Prettyp$ReactTemplate.print_impargs(param[0]);
          case 17 : 
              var gr = Pervasives.failwith("undefined: smart_global");
              var cstr = Globnames$ReactTemplate.printable_constr_of_global(gr);
              var st = Conv_oracle$ReactTemplate.get_transp_state(Environ$ReactTemplate.oracle(Global$ReactTemplate.env(/* () */0)));
              var nassums = Assumptions$ReactTemplate.assumptions(/* Some */[param[0]], /* Some */[param[1]], st, gr, cstr);
              return Printer$ReactTemplate.pr_assumptionset(env, sigma, nassums);
          case 18 : 
              var r$2 = param[0];
              var pr_level = function (param) {
                if (typeof param === "number") {
                  if (param !== 0) {
                    return Pp$ReactTemplate.str("opaque");
                  } else {
                    return Pp$ReactTemplate.str("expand");
                  }
                } else {
                  var n = param[0];
                  if (n !== 0) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("level"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(n));
                  } else {
                    return Pp$ReactTemplate.str("transparent");
                  }
                }
              };
              var pr_strategy = function (param) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(param[0]), Pp$ReactTemplate.str(" : ")), pr_level(param[1]));
              };
              var oracle = Environ$ReactTemplate.oracle(Global$ReactTemplate.env(/* () */0));
              if (r$2) {
                var r$3 = Curry._2(Smartlocate$ReactTemplate.smart_global, /* None */0, r$2[0]);
                var key;
                switch (r$3.tag | 0) {
                  case 0 : 
                      key = /* VarKey */Block.__(1, [r$3[0]]);
                      break;
                  case 1 : 
                      key = /* ConstKey */Block.__(0, [r$3[0]]);
                      break;
                  case 2 : 
                  case 3 : 
                      key = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The reference is not unfoldable"));
                      break;
                  
                }
                var lvl = Conv_oracle$ReactTemplate.get_strategy(oracle)(key);
                return pr_strategy(/* tuple */[
                            r$3,
                            lvl
                          ]);
              } else {
                var fold = function (key, lvl, param) {
                  var cacc = param[1];
                  var vacc = param[0];
                  switch (key.tag | 0) {
                    case 0 : 
                        return /* tuple */[
                                vacc,
                                /* :: */[
                                  /* tuple */[
                                    /* ConstRef */Block.__(1, [key[0]]),
                                    lvl
                                  ],
                                  cacc
                                ]
                              ];
                    case 1 : 
                        return /* tuple */[
                                /* :: */[
                                  /* tuple */[
                                    /* VarRef */Block.__(0, [key[0]]),
                                    lvl
                                  ],
                                  vacc
                                ],
                                cacc
                              ];
                    case 2 : 
                        return /* tuple */[
                                vacc,
                                cacc
                              ];
                    
                  }
                };
                var match$8 = Conv_oracle$ReactTemplate.fold_strategy(fold, oracle, /* tuple */[
                      /* [] */0,
                      /* [] */0
                    ]);
                var cst_lvl = match$8[1];
                var var_lvl = match$8[0];
                var var_msg = Curry._1(Util$ReactTemplate.List[/* is_empty */45], var_lvl) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Variable strategies"), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, pr_strategy, var_lvl))), Pp$ReactTemplate.fnl(/* () */0));
                var cst_msg = Curry._1(Util$ReactTemplate.List[/* is_empty */45], cst_lvl) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Constant strategies"), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, pr_strategy, cst_lvl)));
                return Pp$ReactTemplate.$plus$plus(var_msg, cst_msg);
              }
          
        }
      }
    });
}

function global_module(r) {
  var match = Libnames$ReactTemplate.qualid_of_reference(r);
  var qid = match[/* v */0];
  try {
    return Nametab$ReactTemplate.full_name_module(qid);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(match[/* loc */1], /* Some */["global_module"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Module/section "), Libnames$ReactTemplate.pr_qualid(qid)), Pp$ReactTemplate.str(" not found.")));
    } else {
      throw exn;
    }
  }
}

function interp_search_restriction(param) {
  if (param.tag) {
    return /* tuple */[
            Curry._2(Util$ReactTemplate.List[/* map */10], global_module, param[0]),
            /* true */1
          ];
  } else {
    return /* tuple */[
            Curry._2(Util$ReactTemplate.List[/* map */10], global_module, param[0]),
            /* false */0
          ];
  }
}

var search_output_name_only = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"output-name-only search",
      /* optkey : :: */[
        "Search",
        /* :: */[
          "Output",
          /* :: */[
            "Name",
            /* :: */[
              "Only",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */(function () {
          return search_output_name_only[0];
        }),
      /* optwrite */(function (param) {
          search_output_name_only[0] = param;
          return /* () */0;
        })
    ]);

function vernac_locate(param) {
  var exit = 0;
  var ntn;
  var sc;
  switch (param.tag | 0) {
    case 0 : 
        var match = param[0][/* v */0];
        if (match.tag) {
          var match$1 = match[0];
          ntn = match$1[0];
          sc = match$1[1];
          exit = 1;
        } else {
          return Prettyp$ReactTemplate.print_located_qualid(match[0]);
        }
        break;
    case 1 : 
        var match$2 = param[0][/* v */0];
        if (match$2.tag) {
          var match$3 = match$2[0];
          ntn = match$3[0];
          sc = match$3[1];
          exit = 1;
        } else {
          return Prettyp$ReactTemplate.print_located_term(match$2[0]);
        }
        break;
    case 2 : 
        return Pervasives.failwith("undefined: print_located_library");
    case 3 : 
        return Prettyp$ReactTemplate.print_located_module(param[0]);
    case 4 : 
        return Prettyp$ReactTemplate.print_located_other(param[0], param[1]);
    case 5 : 
        return Pervasives.failwith("undefined: locate_file");
    
  }
  if (exit === 1) {
    var match$4 = Pfedit$ReactTemplate.get_current_context(/* () */0);
    var env = match$4[1];
    return Notation$ReactTemplate.locate_notation(Constrextern$ReactTemplate.without_symbols((function (param) {
                      return Printer$ReactTemplate.pr_lglob_constr_env(env, param);
                    })), ntn, sc);
  }
  
}

function vernac_unfocused() {
  var p = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
  if (Proof$ReactTemplate.unfocused(p)) {
    return Pp$ReactTemplate.str("The proof is indeed fully unfocused.");
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The proof is not fully unfocused."));
  }
}

var subproof_kind = Proof$ReactTemplate.new_focus_kind(/* () */0);

var subproof_cond = Proof$ReactTemplate.done_cond(/* None */0, subproof_kind);

function vernac_show(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          var p = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
          var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
          var env = match[1];
          var sigma = match[0];
          var pprf = Proof$ReactTemplate.partial_proof(p);
          return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (param) {
                        return Printer$ReactTemplate.pr_econstr_env(env, sigma, param);
                      }), pprf);
      case 1 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "vernacentries.ml",
                  1997,
                  18
                ]
              ];
      case 2 : 
          var pfts = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
          var match$1 = Proof$ReactTemplate.proof(pfts);
          var sigma$1 = match$1[4];
          return Printer$ReactTemplate.pr_evars_int(sigma$1, match$1[2], match$1[3], 1, Evd$ReactTemplate.undefined_map(sigma$1));
      case 3 : 
          var pfts$1 = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
          var match$2 = Proof$ReactTemplate.proof(pfts$1);
          var sigma$2 = match$2[4];
          var ctx = Evd$ReactTemplate.universe_context_set(Evd$ReactTemplate.minimize_universes(sigma$2));
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Termops$ReactTemplate.pr_evar_universe_context(Evd$ReactTemplate.evar_universe_context(sigma$2)), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("Normalized constraints: ")), Univ$ReactTemplate.pr_universe_context_set(Termops$ReactTemplate.pr_evd_level(sigma$2), ctx));
      case 4 : 
          return Pp$ReactTemplate.pr_sequence(Names$ReactTemplate.Id[/* print */8], Proof_global$ReactTemplate.get_all_proof_names(/* () */0));
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var goalref = param[0];
          var proof = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
          if (typeof goalref === "number") {
            return Printer$ReactTemplate.pr_open_subgoals(proof);
          } else if (goalref.tag) {
            return Printer$ReactTemplate.pr_goal_by_id(proof, goalref[0]);
          } else {
            return Printer$ReactTemplate.pr_nth_open_subgoal(proof, goalref[0]);
          }
          break;
      case 1 : 
          var all = param[0];
          var pf = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
          var match$3 = Proof$ReactTemplate.proof(pf);
          var sigma$3 = match$3[4];
          var gls = match$3[0];
          if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], gls)) {
            return Pp$ReactTemplate.mt(/* () */0);
          } else {
            var gl_000 = /* it */Curry._1(Util$ReactTemplate.List[/* hd */1], gls);
            var gl = /* record */[
              gl_000,
              /* sigma */sigma$3
            ];
            var match$4 = EConstr$ReactTemplate.decompose_prod_assum(sigma$3, Termops$ReactTemplate.strip_outer_cast(sigma$3, Tacmach$ReactTemplate.pf_concl(gl)));
            var l = match$4[0];
            if (all) {
              var lid = Tactics$ReactTemplate.find_intro_names(l, gl);
              return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Names$ReactTemplate.Id[/* print */8], lid));
            } else if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
              return Pp$ReactTemplate.mt(/* () */0);
            } else {
              var n = Curry._1(Util$ReactTemplate.List[/* last */105], l);
              return Names$ReactTemplate.Id[/* print */8](Curry._1(Util$ReactTemplate.List[/* hd */1], Tactics$ReactTemplate.find_intro_names(/* :: */[
                                  n,
                                  /* [] */0
                                ], gl)));
            }
          }
      case 2 : 
          var id = param[0];
          var patterns;
          try {
            patterns = make_cases_aux(Nametab$ReactTemplate.$$global(id));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              patterns = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Unknown inductive type."));
            } else {
              throw exn;
            }
          }
          var pr_branch = function (l) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("| "), Pp$ReactTemplate.hov(1, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Pp$ReactTemplate.str, l))), Pp$ReactTemplate.str(" =>"));
          };
          return Pp$ReactTemplate.v(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("match # with"), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, pr_branch, patterns)), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("end")), Pp$ReactTemplate.fnl(/* () */0)));
      
    }
  }
}

function vernac_check_guard() {
  var pts = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
  var pfterm = Curry._1(Util$ReactTemplate.List[/* hd */1], Proof$ReactTemplate.partial_proof(pts));
  try {
    var match = Proof$ReactTemplate.V82[/* top_goal */2](pts);
    var sigma = match[/* sigma */1];
    Inductiveops$ReactTemplate.control_only_guard(Goal$ReactTemplate.V82[/* env */0](sigma, match[/* it */0]), sigma, pfterm);
    return Pp$ReactTemplate.str("The condition holds up to here");
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === CErrors$ReactTemplate.UserError) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Condition violated: "), exn[2]);
    } else {
      throw exn;
    }
  }
}

function interp(proof, atts, st, c) {
  vernac_pperr_endline((function () {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("interpreting: "), Ppvernac$ReactTemplate.pr_vernac_expr(c));
        }));
  if (typeof c === "number") {
    switch (c) {
      case 0 : 
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("VernacResetInitial not handled by Stm."));
      case 1 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("AbortAll cannot be used through the Load command"));
      case 2 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Restart cannot be used through the Load command"));
      case 3 : 
          return Proof_global$ReactTemplate.simple_with_current_proof((function (_, p) {
                        return Proof$ReactTemplate.unfocus(command_focus, p, /* () */0);
                      }));
      case 4 : 
          var eta = vernac_unfocused(/* () */0);
          return Feedback$ReactTemplate.msg_notice(/* None */0, eta);
      case 5 : 
          return Proof_global$ReactTemplate.simple_with_current_proof((function (_, p) {
                        return Proof$ReactTemplate.unfocus(subproof_kind, p, /* () */0);
                      }));
      case 6 : 
          var eta$1 = vernac_check_guard(/* () */0);
          return Feedback$ReactTemplate.msg_notice(/* None */0, eta$1);
      
    }
  } else {
    switch (c.tag | 0) {
      case 0 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "vernacentries.ml",
                  2072,
                  20
                ]
              ];
      case 1 : 
          var atts$1 = atts;
          var infix = c[0];
          var l = c[1];
          var local = Locality$ReactTemplate.enforce_module_locality(atts$1[/* locality */1]);
          if (infix) {
            Metasyntax$ReactTemplate.check_infix_modifiers(l[1]);
          }
          return Metasyntax$ReactTemplate.add_syntax_extension(local, l);
      case 2 : 
          var atts$2 = atts;
          var param = /* tuple */[
            c[0],
            c[1]
          ];
          var local$1 = Locality$ReactTemplate.enforce_section_locality(atts$2[/* locality */1]);
          return Notation$ReactTemplate.open_close_scope(/* tuple */[
                      local$1,
                      param[0],
                      param[1]
                    ]);
      case 3 : 
          var sc = c[0];
          var param$1 = c[1];
          if (param$1) {
            return Metasyntax$ReactTemplate.add_delimiters(sc, param$1[0]);
          } else {
            return Metasyntax$ReactTemplate.remove_delimiters(sc);
          }
      case 4 : 
          var sc$1 = c[0];
          var cll = c[1];
          return Metasyntax$ReactTemplate.add_class_scope(sc$1, Curry._2(Util$ReactTemplate.List[/* map */10], scope_class_of_qualid, cll));
      case 5 : 
          return vernac_infix(atts)(c[0], c[1], c[2]);
      case 6 : 
          return vernac_notation(atts)(c[0], c[1], c[2]);
      case 7 : 
          return Metasyntax$ReactTemplate.add_notation_extra_printing_rule(c[0], c[1], c[2]);
      case 8 : 
          var match = c[0];
          return Pervasives.failwith("undefined: vernac_definition");
      case 9 : 
          return Pervasives.failwith("undefined: vernac_start_proof");
      case 10 : 
          var proof$1 = proof;
          var e = c[0];
          if (e) {
            return Lemmas$ReactTemplate.save_proof(proof$1, e);
          } else {
            return Lemmas$ReactTemplate.save_proof(proof$1, /* Admitted */0);
          }
      case 11 : 
          var c$1 = c[0];
          var status = Pfedit$ReactTemplate.by(Tactics$ReactTemplate.exact_proof(c$1));
          Lemmas$ReactTemplate.save_proof(/* None */0, /* Proved */[
                /* Opaque */0,
                /* None */0
              ]);
          if (status) {
            return 0;
          } else {
            return Feedback$ReactTemplate.feedback(/* None */0, /* None */0, /* None */0, /* AddedAxiom */3);
          }
      case 12 : 
          return Pervasives.failwith("undefined: vernac_assumption");
      case 13 : 
          return Pervasives.failwith("vernac_inductive");
      case 14 : 
          return Pervasives.failwith("vernac_fixpoint");
      case 15 : 
          return Pervasives.failwith("vernac_cofixpoint");
      case 16 : 
          return Pervasives.failwith("vernac_scheme");
      case 17 : 
          return Pervasives.failwith("vernac_combined_scheme");
      case 18 : 
          var atts$3 = atts;
          var l$1 = c[0];
          if (atts$3[/* polymorphic */2] && !Lib$ReactTemplate.sections_are_opened(/* () */0)) {
            CErrors$ReactTemplate.user_err(atts$3[/* loc */0], /* Some */["vernac_universe"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Polymorphic universes can only be declared inside sections, "), Pp$ReactTemplate.str("use Monomorphic Universe instead")));
          }
          return Declare$ReactTemplate.do_universe(atts$3[/* polymorphic */2], l$1);
      case 19 : 
          var atts$4 = atts;
          var l$2 = c[0];
          if (atts$4[/* polymorphic */2] && !Lib$ReactTemplate.sections_are_opened(/* () */0)) {
            CErrors$ReactTemplate.user_err(atts$4[/* loc */0], /* Some */["vernac_constraint"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Polymorphic universe constraints can only be declared"), Pp$ReactTemplate.str(" inside sections, use Monomorphic Constraint instead")));
          }
          return Declare$ReactTemplate.do_constraint(atts$4[/* polymorphic */2], l$2);
      case 20 : 
          return Pervasives.failwith("vernac_begin_section");
      case 21 : 
          var lid = c[0];
          Proof_global$ReactTemplate.check_no_pending_proof(/* () */0);
          var match$1 = Lib$ReactTemplate.find_opening_node(lid[/* v */0]);
          switch (match$1.tag | 0) {
            case 2 : 
                if (match$1[0] !== 0) {
                  return Pervasives.failwith("vernac_end_modtype");
                } else {
                  return Pervasives.failwith("vernac_end_module");
                }
            case 4 : 
                return Pervasives.failwith("vernac_end_section");
            default:
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "vernacentries.ml",
                      851,
                      9
                    ]
                  ];
          }
      case 22 : 
          return Pervasives.failwith("undefined: vernac_require");
      case 23 : 
          return Pervasives.failwith("undefined: vernac_import");
      case 24 : 
          return Recordops$ReactTemplate.declare_canonical_structure(Pervasives.failwith("undefined: smart_global"));
      case 25 : 
          var atts$5 = atts;
          var qids = c[1];
          var qidt = c[2];
          var local$2 = Locality$ReactTemplate.enforce_locality(atts$5[/* locality */1]);
          var target = cl_of_qualid(qidt);
          var source = cl_of_qualid(qids);
          var ref$prime = Pervasives.failwith("undefined: smart_global");
          Class$ReactTemplate.try_add_new_coercion_with_target(ref$prime, local$2, atts$5[/* polymorphic */2], source, target);
          return Flags$ReactTemplate.if_verbose((function (eta) {
                        return Feedback$ReactTemplate.msg_info(/* None */0, eta);
                      }), Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(ref$prime), Pp$ReactTemplate.str(" is now a coercion")));
      case 26 : 
          var atts$6 = atts;
          var id = c[0][/* v */0];
          var qids$1 = c[1];
          var qidt$1 = c[2];
          var local$3 = Locality$ReactTemplate.enforce_locality(atts$6[/* locality */1]);
          var target$1 = cl_of_qualid(qidt$1);
          var source$1 = cl_of_qualid(qids$1);
          return Class$ReactTemplate.try_add_new_identity_coercion(id, local$3, atts$6[/* polymorphic */2], source$1, target$1);
      case 27 : 
          var param$2 = c[0];
          var set = c[1];
          return Proof_using$ReactTemplate.name_set(param$2[/* v */0], set);
      case 28 : 
          return Pervasives.failwith("vernac_instance");
      case 29 : 
          var atts$7 = atts;
          var l$3 = c[0];
          if (Classes$ReactTemplate.context(atts$7[/* polymorphic */2], l$3)) {
            return 0;
          } else {
            return Feedback$ReactTemplate.feedback(/* None */0, /* None */0, /* None */0, /* AddedAxiom */3);
          }
      case 30 : 
          var atts$8 = atts;
          var insts = c[0];
          var glob = 1 - Locality$ReactTemplate.make_section_locality(atts$8[/* locality */1]);
          return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                        return Classes$ReactTemplate.existing_instance(glob, param[0], /* Some */[param[1]]);
                      }), insts);
      case 31 : 
          return Record$ReactTemplate.declare_existing_class(Nametab$ReactTemplate.$$global(c[0]));
      case 32 : 
          return Pervasives.failwith("vernac_declare_module");
      case 33 : 
          return Pervasives.failwith("vernac_define_module");
      case 34 : 
          return Pervasives.failwith("vernac_declare_module_type");
      case 35 : 
          return Declaremods$ReactTemplate.declare_include(Modintern$ReactTemplate.interp_module_ast, c[0]);
      case 36 : 
          return Pfedit$ReactTemplate.instantiate_nth_evar_com(c[0], c[1]);
      case 37 : 
          return Pervasives.failwith("undefined: vernac_add_loadpath");
      case 38 : 
          return Pervasives.failwith("undefined: vernac_remove_loadpath");
      case 39 : 
          return Pervasives.failwith("vernac_add_ml_path");
      case 40 : 
          return Pervasives.failwith("vernac_declare_ml_module");
      case 41 : 
          var param$3 = c[0];
          if (param$3) {
            try {
              Caml_missing_polyfill.not_implemented("caml_sys_chdir not implemented by bucklescript yet\n");
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Caml_builtin_exceptions.sys_error) {
                CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cd failed: " + exn[1]));
              } else {
                throw exn;
              }
            }
            return Flags$ReactTemplate.if_verbose((function (eta) {
                          return Feedback$ReactTemplate.msg_info(/* None */0, eta);
                        }), Pp$ReactTemplate.str(Caml_sys.caml_sys_getcwd(/* () */0)));
          } else {
            return Feedback$ReactTemplate.msg_notice(/* None */0, Pp$ReactTemplate.str(Caml_sys.caml_sys_getcwd(/* () */0)));
          }
      case 42 : 
      case 43 : 
          throw [
                Caml_builtin_exceptions.match_failure,
                [
                  "vernacentries.ml",
                  2069,
                  2
                ]
              ];
      case 44 : 
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("VernacResetName not handled by Stm."));
      case 45 : 
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("VernacBack not handled by Stm."));
      case 46 : 
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("VernacBackTo not handled by Stm."));
      case 47 : 
          var atts$9 = atts;
          var id$1 = c[0];
          var b = c[1];
          var local$4 = Locality$ReactTemplate.make_module_locality(atts$9[/* locality */1]);
          return Hints$ReactTemplate.create_hint_db(local$4, id$1, Names$ReactTemplate.full_transparent_state, b);
      case 48 : 
          var atts$10 = atts;
          var dbs = c[0];
          var ids = c[1];
          var local$5 = Locality$ReactTemplate.make_module_locality(atts$10[/* locality */1]);
          return Hints$ReactTemplate.remove_hints(local$5, dbs, Curry._2(Util$ReactTemplate.List[/* map */10], (function (eta) {
                            return Curry._2(Smartlocate$ReactTemplate.global_with_alias, /* None */0, eta);
                          }), ids));
      case 49 : 
          var atts$11 = atts;
          var lb = c[0];
          var h = c[1];
          var local$6 = Locality$ReactTemplate.enforce_module_locality(atts$11[/* locality */1]);
          return Hints$ReactTemplate.add_hints(local$6, lb, Hints$ReactTemplate.interp_hints(atts$11[/* polymorphic */2], h));
      case 50 : 
          return Pervasives.failwith("vernac_syntactic_definition");
      case 51 : 
          return vernac_declare_implicits(atts, c[0], c[1]);
      case 52 : 
          var atts$12 = atts;
          var reference = c[0];
          var args = c[1];
          var more_implicits = c[2];
          var nargs_for_red = c[3];
          var flags = c[4];
          var assert_flag = Curry._2(Util$ReactTemplate.List[/* mem */24], /* Assert */9943782, flags);
          var rename_flag = Curry._2(Util$ReactTemplate.List[/* mem */24], /* Rename */968597406, flags);
          var clear_scopes_flag = Curry._2(Util$ReactTemplate.List[/* mem */24], /* ClearScopes */1032426924, flags);
          var extra_scopes_flag = Curry._2(Util$ReactTemplate.List[/* mem */24], /* ExtraScopes */676717295, flags);
          var clear_implicits_flag = Curry._2(Util$ReactTemplate.List[/* mem */24], /* ClearImplicits */-560228223, flags);
          var default_implicits_flag = Curry._2(Util$ReactTemplate.List[/* mem */24], /* DefaultImplicits */-751570227, flags);
          var never_unfold_flag = Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionNeverUnfold */1012736563, flags);
          var err_incompat = function (x, y) {
            return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Options \"" + (x + ("\" and \"" + (y + "\" are incompatible.")))));
          };
          if (assert_flag && rename_flag) {
            err_incompat("assert", "rename");
          }
          if (Option$ReactTemplate.has_some(nargs_for_red) && never_unfold_flag) {
            err_incompat("simpl never", "/");
          }
          if (never_unfold_flag && Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionDontExposeCase */-1020251784, flags)) {
            err_incompat("simpl never", "simpl nomatch");
          }
          if (clear_scopes_flag && extra_scopes_flag) {
            err_incompat("clear scopes", "extra scopes");
          }
          if (clear_implicits_flag && default_implicits_flag) {
            err_incompat("clear implicits", "default implicits");
          }
          var sr = Pervasives.failwith("undefined: smart_global");
          var match$2 = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), sr);
          var env = Global$ReactTemplate.env(/* () */0);
          var sigma = Evd$ReactTemplate.from_env(env);
          var inf_names = Impargs$ReactTemplate.compute_implicits_names(env, sigma, EConstr$ReactTemplate.of_constr(match$2[0]));
          var prev_names;
          try {
            prev_names = Arguments_renaming$ReactTemplate.arguments_names(sr);
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              prev_names = inf_names;
            } else {
              throw exn$1;
            }
          }
          var num_args = Curry._1(Util$ReactTemplate.List[/* length */0], inf_names);
          if (num_args !== Curry._1(Util$ReactTemplate.List[/* length */0], prev_names)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "vernacentries.ml",
                    1105,
                    2
                  ]
                ];
          }
          var names_of = function (args) {
            return Curry._2(Util$ReactTemplate.List[/* map */10], (function (a) {
                          return a[/* name */0];
                        }), args);
          };
          var err_extra_args = function (names) {
            return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["vernac_declare_arguments"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Extra arguments: "), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Nameops$ReactTemplate.Name[/* print */7], names)), Pp$ReactTemplate.str(".")));
          };
          var check_extra_args = function (_extra_args) {
            while(true) {
              var extra_args = _extra_args;
              if (extra_args) {
                var match = extra_args[0];
                if (match[/* notation_scope */2]) {
                  if (match[/* name */0]) {
                    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Extra notation scopes can be set on anonymous and explicit arguments only."));
                  } else {
                    _extra_args = extra_args[1];
                    continue ;
                    
                  }
                } else {
                  return err_extra_args(names_of(extra_args));
                }
              } else {
                return /* () */0;
              }
            };
          };
          var scopes = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return param[/* notation_scope */2];
                }), args);
          var match$3;
          if (Curry._1(Util$ReactTemplate.List[/* length */0], args) > num_args) {
            var match$4 = Curry._2(Util$ReactTemplate.List[/* chop */99], num_args, args);
            var extra_args = match$4[1];
            if (extra_scopes_flag) {
              check_extra_args(extra_args);
              match$3 = /* tuple */[
                match$4[0],
                scopes
              ];
            } else {
              match$3 = err_extra_args(names_of(extra_args));
            }
          } else {
            match$3 = /* tuple */[
              args,
              scopes
            ];
          }
          var scopes$1 = match$3[1];
          var args$1 = match$3[0];
          if (Option$ReactTemplate.cata((function (n) {
                    return +(n > num_args);
                  }), /* false */0, nargs_for_red)) {
            CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The \"/\" modifier should be put before any extra scope."));
          }
          var scopes_specified = Curry._2(Util$ReactTemplate.List[/* exists */21], Option$ReactTemplate.has_some, scopes$1);
          if (scopes_specified && clear_scopes_flag) {
            CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The \"clear scopes\" flag is incompatible with scope annotations."));
          }
          var names = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return param[/* name */0];
                }), args$1);
          var names_001 = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Util$ReactTemplate.List[/* map */10], (function (prim) {
                      return prim[0];
                    })), more_implicits);
          var names$1 = /* :: */[
            names,
            names_001
          ];
          var rename_flag_required = [/* false */0];
          var example_renaming = [/* None */0];
          var save_example_renaming = function (renaming) {
            rename_flag_required[0] = rename_flag_required[0] || 1 - Curry._2(Nameops$ReactTemplate.Name[/* equal */4], renaming[0], /* Anonymous */0);
            if (Option$ReactTemplate.is_empty(example_renaming[0])) {
              example_renaming[0] = /* Some */[renaming];
              return /* () */0;
            } else {
              return 0;
            }
          };
          var names_union = function (names1, names2) {
            if (names1) {
              var name = names1[0];
              var exit = 0;
              if (names2) {
                if (name) {
                  if (names2[0]) {
                    exit = 1;
                  } else {
                    return /* :: */[
                            name,
                            names_union(names1[1], names2[1])
                          ];
                  }
                } else {
                  var name$1 = names2[0];
                  if (name$1) {
                    return /* :: */[
                            name$1,
                            names_union(names1[1], names2[1])
                          ];
                  } else {
                    exit = 1;
                  }
                }
              } else {
                return names1;
              }
              if (exit === 1) {
                if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], name, names2[0])) {
                  return /* :: */[
                          name,
                          names_union(names1[1], names2[1])
                        ];
                } else {
                  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Argument lists should agree on the names they provide."));
                }
              }
              
            } else if (names2) {
              return names2;
            } else {
              return /* [] */0;
            }
          };
          var names$2 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], names_union, /* [] */0, names$1);
          var rename = function (prev_names, names) {
            if (prev_names) {
              var prev_names$1 = prev_names[1];
              var prev = prev_names[0];
              if (names) {
                var name = names[0];
                if (name) {
                  if (!Curry._2(Nameops$ReactTemplate.Name[/* equal */4], prev, name)) {
                    save_example_renaming(/* tuple */[
                          prev,
                          name
                        ]);
                  }
                  return /* :: */[
                          name,
                          rename(prev_names$1, names[1])
                        ];
                } else {
                  return /* :: */[
                          prev,
                          rename(prev_names$1, names[1])
                        ];
                }
              } else if (assert_flag) {
                var names$1 = Curry._2(Util$ReactTemplate.List[/* lastn */106], Curry._1(Util$ReactTemplate.List[/* length */0], prev_names), inf_names);
                return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["vernac_declare_arguments"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("The following arguments are not declared: "), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Nameops$ReactTemplate.Name[/* print */7], names$1)), Pp$ReactTemplate.str(".")));
              } else {
                return prev_names;
              }
            } else if (names) {
              return err_extra_args(names);
            } else {
              return /* [] */0;
            }
          };
          var names$3 = rename(prev_names, names$2);
          var renaming_specified = Option$ReactTemplate.has_some(example_renaming[0]);
          if (rename_flag_required[0] && !rename_flag) {
            var match$5 = example_renaming[0];
            var tmp;
            if (match$5) {
              var match$6 = match$5[0];
              tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Argument "), Curry._1(Nameops$ReactTemplate.Name[/* print */7], match$6[0])), Pp$ReactTemplate.str(" renamed to ")), Curry._1(Nameops$ReactTemplate.Name[/* print */7], match$6[1])), Pp$ReactTemplate.str("."));
            } else {
              tmp = Pp$ReactTemplate.mt(/* () */0);
            }
            CErrors$ReactTemplate.user_err(/* None */0, /* Some */["vernac_declare_arguments"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("To rename arguments the \"rename\" flag must be specified."), Pp$ReactTemplate.spc(/* () */0)), tmp));
          }
          var duplicate_names = Curry._2(Util$ReactTemplate.List[/* duplicates */60], Nameops$ReactTemplate.Name[/* equal */4], Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                      return +(/* Anonymous */0 !== param);
                    }), names$3));
          if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], duplicate_names)) {
            var duplicates = Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Nameops$ReactTemplate.Name[/* print */7], duplicate_names);
            CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Some argument names are duplicated: "), duplicates));
          }
          var implicits = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return /* tuple */[
                          param[/* name */0],
                          param[/* implicit_status */3]
                        ];
                }), args$1);
          var implicits$1 = /* :: */[
            implicits,
            more_implicits
          ];
          var build_implicits = function (_inf_names, _implicits) {
            while(true) {
              var implicits = _implicits;
              var inf_names = _inf_names;
              if (implicits) {
                if (inf_names) {
                  var match = inf_names[0];
                  if (implicits[0][1] >= 2) {
                    _implicits = implicits[1];
                    _inf_names = inf_names[1];
                    continue ;
                    
                  } else if (match) {
                    var max = +(implicits[0][1] === /* MaximallyImplicit */1);
                    return /* :: */[
                            /* tuple */[
                              /* ExplByName */Block.__(1, [match[0]]),
                              max,
                              /* false */0
                            ],
                            build_implicits(inf_names[1], implicits[1])
                          ];
                  } else {
                    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["vernac_declare_arguments"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Argument "), Curry._1(Nameops$ReactTemplate.Name[/* print */7], implicits[0][0])), Pp$ReactTemplate.strbrk(" cannot be declared implicit.")));
                  }
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "vernacentries.ml",
                          1247,
                          11
                        ]
                      ];
                }
              } else {
                return /* [] */0;
              }
            };
          };
          var implicits$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return build_implicits(inf_names, param);
                }), implicits$1);
          var implicits_specified = implicits$2 && !(implicits$2[0] || implicits$2[1]) ? /* false */0 : /* true */1;
          if (implicits_specified && clear_implicits_flag) {
            CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The \"clear implicits\" flag is incompatible with implicit annotations"));
          }
          if (implicits_specified && default_implicits_flag) {
            CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The \"default implicits\" flag is incompatible with implicit annotations"));
          }
          var rargs = Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function (param) {
                  if (param[1] !== 0) {
                    return /* Some */[param[0]];
                  } else {
                    return /* None */0;
                  }
                }), Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, param) {
                      return /* tuple */[
                              i,
                              param[/* recarg_like */1]
                            ];
                    }), 0, args$1));
          var narrow = function (_param) {
            while(true) {
              var param = _param;
              if (param) {
                var x = param[0];
                if (x !== -1020251784) {
                  if (x !== 1012736563) {
                    _param = param[1];
                    continue ;
                    
                  } else {
                    return /* :: */[
                            x,
                            narrow(param[1])
                          ];
                  }
                } else {
                  return /* :: */[
                          x,
                          narrow(param[1])
                        ];
                }
              } else {
                return /* [] */0;
              }
            };
          };
          var red_flags = narrow(flags);
          var red_modifiers_specified = 1 - Curry._1(Util$ReactTemplate.List[/* is_empty */45], rargs) || Option$ReactTemplate.has_some(nargs_for_red) || 1 - Curry._1(Util$ReactTemplate.List[/* is_empty */45], red_flags);
          if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], rargs) && never_unfold_flag) {
            err_incompat("simpl never", "!");
          }
          if (renaming_specified) {
            var local$7 = Locality$ReactTemplate.make_section_locality(atts$12[/* locality */1]);
            Arguments_renaming$ReactTemplate.rename_arguments(local$7, sr, names$3);
          }
          if (scopes_specified || clear_scopes_flag) {
            var scopes$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return Option$ReactTemplate.map((function (param) {
                                  var k = param[/* v */0];
                                  try {
                                    Notation$ReactTemplate.find_scope(k);
                                    return k;
                                  }
                                  catch (raw_exn){
                                    var exn = Js_exn.internalToOCamlException(raw_exn);
                                    if (exn[0] === CErrors$ReactTemplate.UserError) {
                                      return Notation$ReactTemplate.find_delimiters_scope(param[/* loc */1], k);
                                    } else {
                                      throw exn;
                                    }
                                  }
                                }), param);
                  }), scopes$1);
            vernac_arguments_scope(atts$12, reference, scopes$2);
          }
          if (implicits_specified || clear_implicits_flag) {
            vernac_declare_implicits(atts$12, reference, implicits$2);
          }
          if (default_implicits_flag) {
            vernac_declare_implicits(atts$12, reference, /* [] */0);
          }
          if (red_modifiers_specified) {
            if (sr.tag === 1) {
              Reductionops$ReactTemplate.ReductionBehaviour[/* set */0](Locality$ReactTemplate.make_section_locality(atts$12[/* locality */1]), sr, /* tuple */[
                    rargs,
                    Option$ReactTemplate.$$default(-1, nargs_for_red),
                    red_flags
                  ]);
            } else {
              CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Modifiers of the behavior of the simpl tactic "), Pp$ReactTemplate.strbrk("are relevant for constants only.")));
            }
          }
          if (!(renaming_specified || implicits_specified || scopes_specified || red_modifiers_specified) && Curry._1(Util$ReactTemplate.List[/* is_empty */45], flags)) {
            return Curry._2(warn_arguments_assert, /* None */0, sr);
          } else {
            return 0;
          }
      case 53 : 
          return vernac_arguments_scope(atts, c[0], c[1]);
      case 54 : 
          var bl = c[0];
          var sb_decl = function (param) {
            var env = Global$ReactTemplate.env(/* () */0);
            var sigma = Evd$ReactTemplate.from_env(env);
            var match = Constrintern$ReactTemplate.interp_type(env, sigma, /* None */0, param[1]);
            var t = Detyping$ReactTemplate.detype(/* Now */0, /* None */0, /* false */0, Names$ReactTemplate.Id[/* Set */9][/* empty */0], env, Evd$ReactTemplate.from_ctx(match[1]), match[0]);
            var match$1 = Notation_ops$ReactTemplate.notation_constr_of_glob_constr(/* record */[
                  /* ninterp_var_type */Names$ReactTemplate.Id[/* Map */10][/* empty */0],
                  /* ninterp_rec_vars */Names$ReactTemplate.Id[/* Map */10][/* empty */0]
                ], t);
            return Reserve$ReactTemplate.declare_reserved_type(param[0], match$1[0]);
          };
          return Curry._2(Util$ReactTemplate.List[/* iter */9], sb_decl, bl);
      case 55 : 
          var partial_arg = Locality$ReactTemplate.make_non_locality(atts[/* locality */1]);
          return (function (param) {
                      return Implicit_quantifiers$ReactTemplate.declare_generalizable(partial_arg, param);
                    })(c[0]);
      case 56 : 
          var atts$13 = atts;
          var param$4 = c[0];
          var local$8 = Locality$ReactTemplate.make_non_locality(atts$13[/* locality */1]);
          var glob_ref = function () {
            var match = Pervasives.failwith("undefined: smart_global");
            switch (match.tag | 0) {
              case 0 : 
                  return /* EvalVarRef */Block.__(0, [match[0]]);
              case 1 : 
                  return /* EvalConstRef */Block.__(1, [match[0]]);
              case 2 : 
              case 3 : 
                  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("cannot set an inductive type or a constructor as transparent"));
              
            }
          };
          var l$4 = Curry._2(Util$ReactTemplate.List[/* map */10], glob_ref, param$4[1]);
          return Redexpr$ReactTemplate.set_strategy(local$8, /* :: */[
                      /* tuple */[
                        param$4[0],
                        l$4
                      ],
                      /* [] */0
                    ]);
      case 57 : 
          var atts$14 = atts;
          var l$5 = c[0];
          var local$9 = Locality$ReactTemplate.make_locality(atts$14[/* locality */1]);
          var glob_ref$1 = function () {
            var match = Pervasives.failwith("undefined: smart_global");
            switch (match.tag | 0) {
              case 0 : 
                  return /* EvalVarRef */Block.__(0, [match[0]]);
              case 1 : 
                  return /* EvalConstRef */Block.__(1, [match[0]]);
              case 2 : 
              case 3 : 
                  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("cannot set an inductive type or a constructor as transparent"));
              
            }
          };
          var l$6 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return /* tuple */[
                          param[0],
                          Curry._2(Util$ReactTemplate.List[/* map */10], glob_ref$1, param[1])
                        ];
                }), l$5);
          return Redexpr$ReactTemplate.set_strategy(local$9, l$6);
      case 58 : 
          var atts$15 = atts;
          var $$export = c[0];
          var key = c[1];
          var locality = get_option_locality($$export, atts$15[/* locality */1]);
          return Goptions$ReactTemplate.unset_option_value_gen(/* Some */[locality], key);
      case 59 : 
          var atts$16 = atts;
          var $$export$1 = c[0];
          var table = c[1];
          var v = c[2];
          if (v.tag === 2) {
            var s = v[0];
            if (CString$ReactTemplate.List[/* equal */0](table, /* :: */[
                    "Warnings",
                    /* [] */0
                  ])) {
              return vernac_set_append_option(atts$16, $$export$1, table, s);
            } else {
              var match$7 = Curry._1(Util$ReactTemplate.List[/* sep_last */93], table);
              var prefix = match$7[1];
              if (match$7[0] === "Append" && !Curry._1(Util$ReactTemplate.List[/* is_empty */45], prefix)) {
                return vernac_set_append_option(atts$16, $$export$1, prefix, s);
              } else {
                return vernac_set_option0(atts$16, $$export$1, table, v);
              }
            }
          } else {
            return vernac_set_option0(atts$16, $$export$1, table, v);
          }
      case 60 : 
          var key$1 = c[0];
          var lv = c[1];
          var f = function (param) {
            if (param.tag) {
              var tmp = Goptions$ReactTemplate.get_ref_table(key$1);
              return Caml_oo_curry.js2(4846113, 1, tmp, param[0]);
            } else {
              var tmp$1 = Goptions$ReactTemplate.get_string_table(key$1);
              return Caml_oo_curry.js2(4846113, 2, tmp$1, param[0]);
            }
          };
          try {
            return Curry._2(Util$ReactTemplate.List[/* iter */9], f, lv);
          }
          catch (exn$2){
            if (exn$2 === Caml_builtin_exceptions.not_found) {
              return Goptions$ReactTemplate.error_undeclared_key(key$1);
            } else {
              throw exn$2;
            }
          }
      case 61 : 
          var key$2 = c[0];
          var lv$1 = c[1];
          var f$1 = function (param) {
            if (param.tag) {
              var tmp = Goptions$ReactTemplate.get_ref_table(key$2);
              return Caml_oo_curry.js2(76061764, 3, tmp, param[0]);
            } else {
              var tmp$1 = Goptions$ReactTemplate.get_string_table(key$2);
              return Caml_oo_curry.js2(76061764, 4, tmp$1, param[0]);
            }
          };
          try {
            return Curry._2(Util$ReactTemplate.List[/* iter */9], f$1, lv$1);
          }
          catch (exn$3){
            if (exn$3 === Caml_builtin_exceptions.not_found) {
              return Goptions$ReactTemplate.error_undeclared_key(key$2);
            } else {
              throw exn$3;
            }
          }
      case 62 : 
          var key$3 = c[0];
          var lv$2 = c[1];
          var f$2 = function (param) {
            if (param.tag) {
              var tmp = Goptions$ReactTemplate.get_ref_table(key$3);
              return Caml_oo_curry.js2(5443093, 5, tmp, param[0]);
            } else {
              var tmp$1 = Goptions$ReactTemplate.get_string_table(key$3);
              return Caml_oo_curry.js2(5443093, 6, tmp$1, param[0]);
            }
          };
          try {
            return Curry._2(Util$ReactTemplate.List[/* iter */9], f$2, lv$2);
          }
          catch (exn$4){
            if (exn$4 === Caml_builtin_exceptions.not_found) {
              return Goptions$ReactTemplate.error_undeclared_key(key$3);
            } else {
              throw exn$4;
            }
          }
      case 63 : 
          var key$4 = c[0];
          try {
            var tmp$1 = Goptions$ReactTemplate.get_ref_table(key$4);
            return Caml_oo_curry.js1(-930392019, 7, tmp$1);
          }
          catch (exn$5){
            if (exn$5 === Caml_builtin_exceptions.not_found) {
              try {
                var tmp$2 = Goptions$ReactTemplate.get_string_table(key$4);
                return Caml_oo_curry.js1(-930392019, 9, tmp$2);
              }
              catch (exn$6){
                if (exn$6 === Caml_builtin_exceptions.not_found) {
                  try {
                    return Goptions$ReactTemplate.print_option_value(key$4);
                  }
                  catch (exn$7){
                    if (exn$7 === Caml_builtin_exceptions.not_found) {
                      return Goptions$ReactTemplate.error_undeclared_key(key$4);
                    } else {
                      throw exn$7;
                    }
                  }
                } else {
                  throw exn$6;
                }
              }
            } else {
              throw exn$5;
            }
          }
      case 64 : 
          var eta$2 = vernac_check_may_eval(atts, c[0], c[1], c[2]);
          return Feedback$ReactTemplate.msg_notice(/* None */0, eta$2);
      case 65 : 
          var eta$3 = vernac_global_check(c[0]);
          return Feedback$ReactTemplate.msg_notice(/* None */0, eta$3);
      case 66 : 
          var atts$17 = atts;
          var s$1 = c[0];
          var r = c[1];
          var local$10 = Locality$ReactTemplate.make_locality(atts$17[/* locality */1]);
          return Redexpr$ReactTemplate.declare_red_expr(local$10, s$1, Curry._3(Hook$ReactTemplate.get(f_interp_redexp), Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, r)[1]);
      case 67 : 
          var match$8 = Pfedit$ReactTemplate.get_current_context(/* () */0);
          var eta$4 = vernac_print(atts, match$8[1], match$8[0])(c[0]);
          return Feedback$ReactTemplate.msg_notice(/* None */0, eta$4);
      case 68 : 
          var atts$18 = atts;
          var s$2 = c[0];
          var gopt = c[1];
          var r$1 = c[2];
          var gopt$1 = query_command_selector(atts$18[/* loc */0], gopt);
          var r$2 = interp_search_restriction(r$1);
          var match$9;
          if (gopt$1) {
            var g = gopt$1[0];
            match$9 = /* tuple */[
              Pfedit$ReactTemplate.get_goal_context(g)[1],
              /* Some */[g]
            ];
          } else {
            try {
              match$9 = /* tuple */[
                Pfedit$ReactTemplate.get_goal_context(1)[1],
                /* Some */[1]
              ];
            }
            catch (exn$8){
              match$9 = /* tuple */[
                Global$ReactTemplate.env(/* () */0),
                /* None */0
              ];
            }
          }
          var gopt$2 = match$9[1];
          var env$1 = match$9[0];
          var get_pattern = function (c) {
            return Constrintern$ReactTemplate.intern_constr_pattern(env$1, Evd$ReactTemplate.from_env(env$1), /* None */0, /* None */0, c)[1];
          };
          var pr_search = function (ref, env, c) {
            var pr = Printer$ReactTemplate.pr_global(ref);
            var pp;
            if (search_output_name_only[0]) {
              pp = pr;
            } else {
              var pc = Printer$ReactTemplate.pr_lconstr_env(env, Evd$ReactTemplate.from_env(env), c);
              pp = Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr, Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), pc));
            }
            return Feedback$ReactTemplate.msg_notice(/* None */0, pp);
          };
          switch (s$2.tag | 0) {
            case 0 : 
                var partial_arg$1 = get_pattern(s$2[0]);
                var partial_arg$2 = function (param) {
                  return Search$ReactTemplate.search_pattern(gopt$2, partial_arg$1, r$2, param);
                };
                return (function (param) {
                            return Search$ReactTemplate.prioritize_search(partial_arg$2, param);
                          })(pr_search);
            case 1 : 
                var partial_arg$3 = get_pattern(s$2[0]);
                var partial_arg$4 = function (param) {
                  return Search$ReactTemplate.search_rewrite(gopt$2, partial_arg$3, r$2, param);
                };
                return (function (param) {
                            return Search$ReactTemplate.prioritize_search(partial_arg$4, param);
                          })(pr_search);
            case 2 : 
                var partial_arg$5 = get_pattern(s$2[0]);
                var partial_arg$6 = function (param) {
                  return Search$ReactTemplate.search_by_head(gopt$2, partial_arg$5, r$2, param);
                };
                return (function (param) {
                            return Search$ReactTemplate.prioritize_search(partial_arg$6, param);
                          })(pr_search);
            case 3 : 
                var partial_arg$7 = Evd$ReactTemplate.from_env(env$1);
                var partial_arg$8 = function (param) {
                  var env$2 = env$1;
                  var sigma = partial_arg$7;
                  var param$1 = param;
                  if (param$1.tag) {
                    var sc = param$1[1];
                    var s = param$1[0];
                    var exit = 0;
                    if (sc) {
                      exit = 1;
                    } else if (Names$ReactTemplate.Id[/* is_valid */3](s)) {
                      return /* GlobSearchString */Block.__(1, [s]);
                    } else {
                      exit = 1;
                    }
                    if (exit === 1) {
                      try {
                        var ref = Notation$ReactTemplate.interp_notation_as_global_reference(/* None */0, (function () {
                                return /* true */1;
                              }), s, sc);
                        return /* GlobSearchSubPattern */Block.__(0, [/* PRef */Block.__(0, [ref])]);
                      }
                      catch (raw_exn){
                        var exn = Js_exn.internalToOCamlException(raw_exn);
                        if (exn[0] === CErrors$ReactTemplate.UserError) {
                          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["interp_search_about_item"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unable to interp \""), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str("\" either as a reference or as an identifier component")));
                        } else {
                          throw exn;
                        }
                      }
                    }
                    
                  } else {
                    var match = Constrintern$ReactTemplate.intern_constr_pattern(env$2, sigma, /* None */0, /* None */0, param$1[0]);
                    return /* GlobSearchSubPattern */Block.__(0, [match[1]]);
                  }
                };
                var partial_arg$9 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                        return Util$ReactTemplate.on_snd(partial_arg$8, param);
                      }), s$2[0]);
                var partial_arg$10 = function (param) {
                  return Search$ReactTemplate.search_about(gopt$2, partial_arg$9, r$2, param);
                };
                return (function (param) {
                            return Search$ReactTemplate.prioritize_search(partial_arg$10, param);
                          })(pr_search);
            
          }
      case 69 : 
          var eta$5 = vernac_locate(c[0]);
          return Feedback$ReactTemplate.msg_notice(/* None */0, eta$5);
      case 70 : 
          var id$2 = c[0];
          if (Proof_global$ReactTemplate.there_are_pending_proofs(/* () */0)) {
            CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot register a primitive while in proof editing mode."));
          }
          var kn = Constrintern$ReactTemplate.global_reference(id$2[/* v */0]);
          if (Globnames$ReactTemplate.isConstRef(kn)) {
            return 0;
          } else {
            return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Register inline: a constant is expected"));
          }
      case 71 : 
          return Flags$ReactTemplate.if_verbose((function (eta) {
                        return Feedback$ReactTemplate.msg_info(/* None */0, eta);
                      }), Pp$ReactTemplate.str("Comments ok\n"));
      case 72 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Abort cannot be used through the Load command"));
      case 73 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Undo cannot be used through the Load command"));
      case 74 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("UndoTo cannot be used through the Load command"));
      case 75 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Backtrack cannot be used through the Load command"));
      case 76 : 
          var gln = c[0];
          return Proof_global$ReactTemplate.simple_with_current_proof((function (_, p) {
                        if (gln) {
                          var n = gln[0];
                          if (n !== 0) {
                            return Proof$ReactTemplate.focus(focus_command_cond, /* () */0, n, p);
                          } else {
                            return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Invalid goal number: 0. Goal numbering starts with 1."));
                          }
                        } else {
                          return Proof$ReactTemplate.focus(focus_command_cond, /* () */0, 1, p);
                        }
                      }));
      case 77 : 
          var bullet = c[0];
          return Proof_global$ReactTemplate.simple_with_current_proof((function (_, p) {
                        return Proof_bullet$ReactTemplate.put(p, bullet);
                      }));
      case 78 : 
          var gln$1 = c[0];
          return Proof_global$ReactTemplate.simple_with_current_proof((function (_, p) {
                        if (gln$1) {
                          var match = gln$1[0];
                          if (typeof match === "number") {
                            return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["bracket_selector"], Pp$ReactTemplate.str("Brackets only support the single numbered goal selector."));
                          } else if (match.tag) {
                            return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["bracket_selector"], Pp$ReactTemplate.str("Brackets only support the single numbered goal selector."));
                          } else {
                            return Proof$ReactTemplate.focus(subproof_cond, /* () */0, match[0], p);
                          }
                        } else {
                          return Proof$ReactTemplate.focus(subproof_cond, /* () */0, 1, p);
                        }
                      }));
      case 79 : 
          var eta$6 = vernac_show(c[0]);
          return Feedback$ReactTemplate.msg_notice(/* None */0, eta$6);
      case 80 : 
          var tac = c[0];
          var using = Option$ReactTemplate.append(c[1], Proof_using$ReactTemplate.get_default_proof_using(/* () */0));
          Option$ReactTemplate.is_empty(tac);
          Option$ReactTemplate.is_empty(using);
          Option$ReactTemplate.iter(vernac_set_end_tac, tac);
          return Option$ReactTemplate.iter(vernac_set_used_variables, using);
      case 81 : 
          return Proof_global$ReactTemplate.set_proof_mode(c[0]);
      case 82 : 
          throw c[0];
      case 83 : 
          Vernacinterp$ReactTemplate.call(c[0], c[1], atts, st);
          return /* () */0;
      
    }
  }
}

function check_vernac_supports_locality(c, l) {
  if (l) {
    if (typeof c === "number") {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This command does not support Locality"));
    } else {
      switch (c.tag | 0) {
        case 1 : 
        case 2 : 
        case 5 : 
        case 6 : 
        case 8 : 
        case 9 : 
        case 12 : 
        case 13 : 
        case 14 : 
        case 15 : 
        case 25 : 
        case 26 : 
        case 28 : 
        case 30 : 
        case 40 : 
        case 47 : 
        case 48 : 
        case 49 : 
        case 50 : 
        case 51 : 
        case 52 : 
        case 53 : 
        case 55 : 
        case 56 : 
        case 57 : 
        case 58 : 
        case 59 : 
        case 66 : 
        case 83 : 
            return /* () */0;
        default:
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This command does not support Locality"));
      }
    }
  } else {
    return /* () */0;
  }
}

function check_vernac_supports_polymorphism(c, p) {
  if (p) {
    if (typeof c === "number") {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This command does not support Polymorphism"));
    } else {
      switch (c.tag | 0) {
        case 8 : 
        case 9 : 
        case 12 : 
        case 13 : 
        case 14 : 
        case 15 : 
        case 18 : 
        case 19 : 
        case 25 : 
        case 26 : 
        case 28 : 
        case 29 : 
        case 30 : 
        case 49 : 
        case 83 : 
            return /* () */0;
        default:
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This command does not support Polymorphism"));
      }
    }
  } else {
    return /* () */0;
  }
}

var default_timeout = [/* None */0];

Goptions$ReactTemplate.declare_int_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"the default timeout",
      /* optkey : :: */[
        "Default",
        /* :: */[
          "Timeout",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return default_timeout[0];
        }),
      /* optwrite */(function (param) {
          default_timeout[0] = param;
          return /* () */0;
        })
    ]);

var current_timeout = [/* None */0];

function locate_if_not_already(loc, param) {
  var info = param[1];
  var e = param[0];
  var match = Loc$ReactTemplate.get_loc(info);
  if (match) {
    return /* tuple */[
            e,
            info
          ];
  } else {
    return /* tuple */[
            e,
            Option$ReactTemplate.cata((function (param) {
                    return Loc$ReactTemplate.add_loc(info, param);
                  }), info, loc)
          ];
  }
}

var HasNotFailed = Caml_exceptions.create("Vernacentries-ReactTemplate.HasNotFailed");

var HasFailed = Caml_exceptions.create("Vernacentries-ReactTemplate.HasFailed");

function with_fail(st, b, f) {
  if (b) {
    try {
      try {
        Curry._1(f, /* () */0);
        throw HasNotFailed;
      }
      catch (raw_e){
        var e = Js_exn.internalToOCamlException(raw_e);
        if (e === HasNotFailed) {
          throw e;
        } else {
          var e$1 = CErrors$ReactTemplate.push(e);
          throw [
                HasFailed,
                CErrors$ReactTemplate.iprint(ExplainErr$ReactTemplate.process_vernac_interp_error(/* Some */[/* false */0], e$1))
              ];
        }
      }
    }
    catch (raw_e$1){
      var e$2 = Js_exn.internalToOCamlException(raw_e$1);
      if (CErrors$ReactTemplate.noncritical(e$2)) {
        Vernacstate$ReactTemplate.invalidate_cache(/* () */0);
        Vernacstate$ReactTemplate.unfreeze_interp_state(st);
        var match = CErrors$ReactTemplate.push(e$2);
        var e$3 = match[0];
        if (e$3 === HasNotFailed) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Fail"], Pp$ReactTemplate.str("The command has not failed!"));
        } else if (e$3[0] === HasFailed) {
          if (!Flags$ReactTemplate.quiet[0] || Flags$ReactTemplate.test_mode[0] || Flags$ReactTemplate.ide_slave[0]) {
            return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The command has indeed failed with message:"), Pp$ReactTemplate.fnl(/* () */0)), e$3[1]));
          } else {
            return 0;
          }
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "vernacentries.ml",
                  2329,
                  13
                ]
              ];
        }
      } else {
        throw e$2;
      }
    }
  } else {
    return Curry._1(f, /* () */0);
  }
}

function interp$1($staropt$star, proof, st, param) {
  var loc = param[/* loc */1];
  var c = param[/* v */0];
  var verbosely = $staropt$star ? $staropt$star[0] : /* true */1;
  var orig_univ_poly = Flags$ReactTemplate.is_universe_polymorphism(/* () */0);
  var orig_program_mode = Flags$ReactTemplate.is_program_mode(/* () */0);
  var flags = function (f, atts) {
    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, f) {
                  var atts = param[1];
                  var polymorphism = param[0];
                  if (typeof f === "number") {
                    if (atts[/* program */3]) {
                      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Program mode specified twice"));
                    } else {
                      return /* tuple */[
                              polymorphism,
                              /* record */[
                                /* loc */atts[/* loc */0],
                                /* locality */atts[/* locality */1],
                                /* polymorphic */atts[/* polymorphic */2],
                                /* program : true */1
                              ]
                            ];
                    }
                  } else if (f.tag) {
                    if (Option$ReactTemplate.is_empty(atts[/* locality */1])) {
                      return /* tuple */[
                              polymorphism,
                              /* record */[
                                /* loc */atts[/* loc */0],
                                /* locality : Some */[f[0]],
                                /* polymorphic */atts[/* polymorphic */2],
                                /* program */atts[/* program */3]
                              ]
                            ];
                    } else {
                      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Locality specified twice"));
                    }
                  } else if (polymorphism) {
                    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Polymorphism specified twice"));
                  } else {
                    return /* tuple */[
                            /* Some */[f[0]],
                            atts
                          ];
                  }
                }), /* tuple */[
                /* None */0,
                atts
              ], f);
  };
  var control = function (_param) {
    while(true) {
      var param = _param;
      switch (param.tag | 0) {
        case 0 : 
            var match = flags(param[0], /* record */[
                  /* loc */loc,
                  /* locality : None */0,
                  /* polymorphic : false */0,
                  /* program */orig_program_mode
                ]);
            var polymorphism = match[0];
            var atts = match[1];
            var c = param[1];
            var exit = 0;
            if (typeof c === "number") {
              exit = 1;
            } else if (c.tag) {
              exit = 1;
            } else {
              return Pervasives.failwith("undefined: vernac_load");
            }
            if (exit === 1) {
              check_vernac_supports_locality(c, atts[/* locality */1]);
              check_vernac_supports_polymorphism(c, polymorphism);
              var polymorphic = Option$ReactTemplate.$$default(Flags$ReactTemplate.is_universe_polymorphism(/* () */0), polymorphism);
              Flags$ReactTemplate.make_universe_polymorphism(polymorphic);
              Obligations$ReactTemplate.set_program_mode(atts[/* program */3]);
              try {
                ((function(atts,c,polymorphic){
                  return function () {
                    var atts_000 = /* loc */atts[/* loc */0];
                    var atts_001 = /* locality */atts[/* locality */1];
                    var atts_003 = /* program */atts[/* program */3];
                    var atts$1 = /* record */[
                      atts_000,
                      atts_001,
                      /* polymorphic */polymorphic,
                      atts_003
                    ];
                    if (verbosely) {
                      Flags$ReactTemplate.verbosely((function (param) {
                              return interp(proof, atts$1, st, param);
                            }), c);
                    } else {
                      Flags$ReactTemplate.silently((function (param) {
                              return interp(proof, atts$1, st, param);
                            }), c);
                    }
                    if (orig_program_mode || !Flags$ReactTemplate.program_mode[0] || atts_003) {
                      Flags$ReactTemplate.program_mode[0] = orig_program_mode;
                    }
                    if (Flags$ReactTemplate.is_universe_polymorphism(/* () */0) === polymorphic) {
                      return Flags$ReactTemplate.make_universe_polymorphism(orig_univ_poly);
                    } else {
                      return 0;
                    }
                  }
                  }(atts,c,polymorphic)));
                var match$1 = current_timeout[0];
                var match$2 = default_timeout[0];
                var exit$1 = 0;
                var n;
                if (match$1) {
                  n = match$1[0];
                  exit$1 = 1;
                } else if (match$2) {
                  n = match$2[0];
                  exit$1 = 1;
                } else {
                  return Curry._1(f, /* () */0);
                }
                if (exit$1 === 1) {
                  var f$1 = function () {
                    Curry._1(f, /* () */0);
                    current_timeout[0] = /* None */0;
                    return /* () */0;
                  };
                  return Control$ReactTemplate.timeout(n, f$1, /* () */0, CErrors$ReactTemplate.Timeout);
                }
                
              }
              catch (raw_reraise){
                var reraise = Js_exn.internalToOCamlException(raw_reraise);
                if (reraise === CErrors$ReactTemplate.Timeout ? /* true */1 : CErrors$ReactTemplate.noncritical(reraise)) {
                  var e = CErrors$ReactTemplate.push(reraise);
                  var e$1 = locate_if_not_already(loc, e);
                  current_timeout[0] = /* None */0;
                  Flags$ReactTemplate.make_universe_polymorphism(orig_univ_poly);
                  Flags$ReactTemplate.program_mode[0] = orig_program_mode;
                  return Util$ReactTemplate.iraise(e$1);
                } else {
                  throw reraise;
                }
              }
            }
            case 1 : 
            throw [
                  Caml_builtin_exceptions.match_failure,
                  [
                    "vernacentries.ml",
                    2355,
                    20
                  ]
                ];
        case 2 : 
            return Topfmt$ReactTemplate.with_output_to_file(param[0], control, param[1][/* v */0]);
        case 3 : 
            current_timeout[0] = /* Some */[param[0]];
            _param = param[1];
            continue ;
            case 4 : 
            var v = param[0];
            return with_fail(st, /* true */1, (function(v){
                      return function () {
                        return control(v);
                      }
                      }(v)));
        
      }
    };
  };
  if (verbosely) {
    return Flags$ReactTemplate.verbosely(control, c);
  } else {
    return control(c);
  }
}

function interp$2(verbosely, proof, st, cmd) {
  Vernacstate$ReactTemplate.unfreeze_interp_state(st);
  try {
    interp$1(verbosely, proof, st, cmd);
    return Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    var exn$1 = CErrors$ReactTemplate.push(exn);
    Vernacstate$ReactTemplate.invalidate_cache(/* () */0);
    return Util$ReactTemplate.iraise(exn$1);
  }
}

var interp_redexp_hook = match[1];

exports.dump_global = dump_global;
exports.vernac_require = vernac_require;
exports.interp = interp$2;
exports.make_cases = make_cases;
exports.with_fail = with_fail;
exports.command_focus = command_focus;
exports.interp_redexp_hook = interp_redexp_hook;
exports.universe_polymorphism_option_name = universe_polymorphism_option_name;
/* match Not a pure module */
