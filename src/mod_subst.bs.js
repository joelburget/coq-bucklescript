// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var empty_000 = Names$ReactTemplate.MPmap[/* empty */0];

var empty_001 = Names$ReactTemplate.KNmap[/* empty */0];

var empty = /* tuple */[
  empty_000,
  empty_001
];

function is_empty(param) {
  if (Curry._1(Names$ReactTemplate.MPmap[/* is_empty */1], param[0])) {
    return Curry._1(Names$ReactTemplate.KNmap[/* is_empty */1], param[1]);
  } else {
    return /* false */0;
  }
}

function add_kn(kn, hint, param) {
  return /* tuple */[
          param[0],
          Curry._3(Names$ReactTemplate.KNmap[/* add */3], kn, hint, param[1])
        ];
}

function add_mp(mp, mp$prime, param) {
  return /* tuple */[
          Curry._3(Names$ReactTemplate.MPmap[/* add */3], mp, mp$prime, param[0]),
          param[1]
        ];
}

function find_mp(mp, map) {
  return Curry._2(Names$ReactTemplate.MPmap[/* find */21], mp, map[0]);
}

function find_kn(kn, map) {
  return Curry._2(Names$ReactTemplate.KNmap[/* find */21], kn, map[1]);
}

function fold(fmp, fkn, param, i) {
  return Curry._3(Names$ReactTemplate.MPmap[/* fold */10], fmp, param[0], Curry._3(Names$ReactTemplate.KNmap[/* fold */10], fkn, param[1], i));
}

var empty_000$1 = Names$ReactTemplate.MPmap[/* empty */0];

var empty_001$1 = Names$ReactTemplate.MBImap[/* empty */0];

var empty$1 = /* tuple */[
  empty_000$1,
  empty_001$1
];

function is_empty$1(param) {
  if (Curry._1(Names$ReactTemplate.MPmap[/* is_empty */1], param[0])) {
    return Curry._1(Names$ReactTemplate.MBImap[/* is_empty */1], param[1]);
  } else {
    return /* false */0;
  }
}

function add_mbi(mbi, x, param) {
  return /* tuple */[
          param[0],
          Curry._3(Names$ReactTemplate.MBImap[/* add */3], mbi, x, param[1])
        ];
}

function add_mp$1(mp, x, param) {
  return /* tuple */[
          Curry._3(Names$ReactTemplate.MPmap[/* add */3], mp, x, param[0]),
          param[1]
        ];
}

function find_mp$1(mp, map) {
  return Curry._2(Names$ReactTemplate.MPmap[/* find */21], mp, map[0]);
}

function iter_mbi(f, map) {
  return Curry._2(Names$ReactTemplate.MBImap[/* iter */9], f, map[1]);
}

function fold$1(fmp, fmbi, param, i) {
  return Curry._3(Names$ReactTemplate.MPmap[/* fold */10], fmp, param[0], Curry._3(Names$ReactTemplate.MBImap[/* fold */10], fmbi, param[1], i));
}

function join(map1, map2) {
  return fold$1(add_mp$1, add_mbi, map1, map2);
}

function string_of_hint(param) {
  if (param.tag) {
    return Names$ReactTemplate.KerName[/* to_string */5](param[0]);
  } else if (param[1]) {
    return "inline(Some _)";
  } else {
    return "inline()";
  }
}

function debug_string_of_delta(resolve) {
  var kn_to_string = function (kn, hint, l) {
    return /* :: */[
            Names$ReactTemplate.KerName[/* to_string */5](kn) + ("=>" + string_of_hint(hint)),
            l
          ];
  };
  var mp_to_string = function (mp, mp$prime, l) {
    return /* :: */[
            Names$ReactTemplate.ModPath[/* to_string */4](mp) + ("=>" + Names$ReactTemplate.ModPath[/* to_string */4](mp$prime)),
            l
          ];
  };
  var l = fold(mp_to_string, kn_to_string, resolve, /* [] */0);
  return Curry._2(Util$ReactTemplate.$$String[/* concat */6], ", ", Curry._1(Util$ReactTemplate.List[/* rev */4], l));
}

function list_contents(sub) {
  var one_pair = function (param) {
    return /* tuple */[
            Names$ReactTemplate.ModPath[/* to_string */4](param[0]),
            debug_string_of_delta(param[1])
          ];
  };
  var mp_one_pair = function (mp0, p, l) {
    return /* :: */[
            /* tuple */[
              Names$ReactTemplate.ModPath[/* to_string */4](mp0),
              one_pair(p)
            ],
            l
          ];
  };
  var mbi_one_pair = function (mbi, p, l) {
    return /* :: */[
            /* tuple */[
              Names$ReactTemplate.MBId[/* debug_to_string */7](mbi),
              one_pair(p)
            ],
            l
          ];
  };
  return fold$1(mp_one_pair, mbi_one_pair, sub, /* [] */0);
}

function debug_string_of_subst(sub) {
  var l = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var match = param[1];
          return param[0] + ("|->" + (match[0] + ("[" + (match[1] + "]"))));
        }), list_contents(sub));
  return "{" + (Curry._2(Util$ReactTemplate.$$String[/* concat */6], "; ", l) + "}");
}

function debug_pr_delta(resolve) {
  return Pp$ReactTemplate.str(debug_string_of_delta(resolve));
}

function debug_pr_subst(sub) {
  var l = list_contents(sub);
  var f = function (param) {
    var match = param[1];
    return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(param[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("|-> ")), Pp$ReactTemplate.str(match[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("[")), Pp$ReactTemplate.str(match[1])), Pp$ReactTemplate.str("]")));
  };
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{"), Pp$ReactTemplate.hov(2, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, f, l))), Pp$ReactTemplate.str("}"));
}

function add_inline_delta_resolver(kn, param) {
  var partial_arg_000 = param[0];
  var partial_arg_001 = param[1];
  var partial_arg = /* Inline */Block.__(0, [
      partial_arg_000,
      partial_arg_001
    ]);
  return (function (param) {
      return add_kn(kn, partial_arg, param);
    });
}

function add_kn_delta_resolver(kn, kn$prime) {
  if (!Names$ReactTemplate.Label[/* equal */0](Names$ReactTemplate.KerName[/* label */4](kn), Names$ReactTemplate.KerName[/* label */4](kn$prime))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "mod_subst.ml",
            122,
            2
          ]
        ];
  }
  var partial_arg = /* Equiv */Block.__(1, [kn$prime]);
  return (function (param) {
      return add_kn(kn, partial_arg, param);
    });
}

function add_mp_delta_resolver(mp1, mp2) {
  return (function (param) {
      return add_mp(mp1, mp2, param);
    });
}

function add_mbid(mbid, mp, resolve, s) {
  return add_mbi(mbid, /* tuple */[
              mp,
              resolve
            ], s);
}

function add_mp$2(mp1, mp2, resolve, s) {
  return add_mp$1(mp1, /* tuple */[
              mp2,
              resolve
            ], s);
}

function map_mbid(mbid, mp, resolve) {
  return add_mbid(mbid, mp, resolve, empty$1);
}

function map_mp(mp1, mp2, resolve) {
  return add_mp$2(mp1, mp2, resolve, empty$1);
}

function mp_in_delta(mp) {
  return (function (param) {
      var mp$1 = mp;
      var map = param;
      return Curry._2(Names$ReactTemplate.MPmap[/* mem */2], mp$1, map[0]);
    });
}

function kn_in_delta(kn, resolver) {
  try {
    var match = find_kn(kn, resolver);
    if (match.tag) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function con_in_delta(con, resolver) {
  return kn_in_delta(Names$ReactTemplate.Constant[/* user */4](con), resolver);
}

function mind_in_delta(mind, resolver) {
  return kn_in_delta(Names$ReactTemplate.MutInd[/* user */4](mind), resolver);
}

function mp_of_delta(resolve, mp) {
  try {
    return find_mp(mp, resolve);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return mp;
    } else {
      throw exn;
    }
  }
}

function find_prefix(resolve, mp) {
  var sub_mp = function (mp_sup) {
    switch (mp_sup.tag | 0) {
      case 0 : 
      case 1 : 
          return find_mp(mp_sup, resolve);
      case 2 : 
          try {
            return find_mp(mp_sup, resolve);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* MPdot */Block.__(2, [
                        sub_mp(mp_sup[0]),
                        mp_sup[1]
                      ]);
            } else {
              throw exn;
            }
          }
          break;
      
    }
  };
  try {
    return sub_mp(mp);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return mp;
    } else {
      throw exn;
    }
  }
}

var Change_equiv_to_inline = Caml_exceptions.create("Mod_subst-ReactTemplate.Change_equiv_to_inline");

function solve_delta_kn(resolve, kn) {
  try {
    var match = find_kn(kn, resolve);
    if (match.tag) {
      return match[0];
    } else {
      var match$1 = match[1];
      if (match$1) {
        throw [
              Change_equiv_to_inline,
              /* tuple */[
                match[0],
                match$1[0]
              ]
            ];
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var match$2 = Names$ReactTemplate.KerName[/* repr */2](kn);
      var mp = match$2[0];
      var new_mp = find_prefix(resolve, mp);
      if (mp === new_mp) {
        return kn;
      } else {
        return Names$ReactTemplate.KerName[/* make */0](new_mp, match$2[1], match$2[2]);
      }
    } else {
      throw exn;
    }
  }
}

function kn_of_delta(resolve, kn) {
  try {
    return solve_delta_kn(resolve, kn);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Change_equiv_to_inline) {
      return kn;
    } else {
      throw exn;
    }
  }
}

function kn_of_deltas(resolve1, resolve2, kn) {
  var kn$prime = kn_of_delta(resolve1, kn);
  if (kn$prime === kn) {
    return kn_of_delta(resolve2, kn);
  } else {
    return kn$prime;
  }
}

function constant_of_delta_kn(resolve, kn) {
  return Names$ReactTemplate.Constant[/* make */0](kn, kn_of_delta(resolve, kn));
}

function constant_of_deltas_kn(resolve1, resolve2, kn) {
  return Names$ReactTemplate.Constant[/* make */0](kn, kn_of_deltas(resolve1, resolve2, kn));
}

function mind_of_delta_kn(resolve, kn) {
  return Names$ReactTemplate.MutInd[/* make */0](kn, kn_of_delta(resolve, kn));
}

function mind_of_deltas_kn(resolve1, resolve2, kn) {
  return Names$ReactTemplate.MutInd[/* make */0](kn, kn_of_deltas(resolve1, resolve2, kn));
}

function inline_of_delta(inline, resolver) {
  if (inline) {
    var inl_lev = inline[0];
    var extract = function (kn, hint, l) {
      if (hint.tag) {
        return l;
      } else {
        var lev = hint[0];
        if (lev <= inl_lev) {
          return /* :: */[
                  /* tuple */[
                    lev,
                    kn
                  ],
                  l
                ];
        } else {
          return l;
        }
      }
    };
    var f = extract;
    var map = resolver;
    var i = /* [] */0;
    return Curry._3(Names$ReactTemplate.KNmap[/* fold */10], f, map[1], i);
  } else {
    return /* [] */0;
  }
}

function search_delta_inline(resolve, kn1, kn2) {
  var find = function (kn) {
    var match = find_kn(kn, resolve);
    if (match.tag) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      return match[1];
    }
  };
  try {
    return find(kn1);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (kn1 === kn2) {
        return /* None */0;
      } else {
        try {
          return find(kn2);
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            return /* None */0;
          } else {
            throw exn$1;
          }
        }
      }
    } else {
      throw exn;
    }
  }
}

function subst_mp0(sub, mp) {
  var aux = function (mp) {
    switch (mp.tag | 0) {
      case 0 : 
          return find_mp$1(mp, sub);
      case 1 : 
          try {
            var mbi = mp[0];
            var map = sub;
            return Curry._2(Names$ReactTemplate.MBImap[/* find */21], mbi, map[1]);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return find_mp$1(mp, sub);
            } else {
              throw exn;
            }
          }
          break;
      case 2 : 
          try {
            return find_mp$1(mp, sub);
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              var match = aux(mp[0]);
              return /* tuple */[
                      /* MPdot */Block.__(2, [
                          match[0],
                          mp[1]
                        ]),
                      match[1]
                    ];
            } else {
              throw exn$1;
            }
          }
          break;
      
    }
  };
  try {
    return /* Some */[aux(mp)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function subst_mp(sub, mp) {
  var match = subst_mp0(sub, mp);
  if (match) {
    return match[0][0];
  } else {
    return mp;
  }
}

function subst_kn_delta(sub, kn) {
  var match = Names$ReactTemplate.KerName[/* repr */2](kn);
  var match$1 = subst_mp0(sub, match[0]);
  if (match$1) {
    var match$2 = match$1[0];
    return solve_delta_kn(match$2[1], Names$ReactTemplate.KerName[/* make */0](match$2[0], match[1], match[2]));
  } else {
    return kn;
  }
}

function subst_kn(sub, kn) {
  var match = Names$ReactTemplate.KerName[/* repr */2](kn);
  var match$1 = subst_mp0(sub, match[0]);
  if (match$1) {
    return Names$ReactTemplate.KerName[/* make */0](match$1[0][0], match[1], match[2]);
  } else {
    return kn;
  }
}

var No_subst = Caml_exceptions.create("Mod_subst-ReactTemplate.No_subst");

function subst_dual_mp(sub, mp1, mp2) {
  var o1 = subst_mp0(sub, mp1);
  var o2 = mp1 === mp2 ? o1 : subst_mp0(sub, mp2);
  if (o1) {
    var match = o1[0];
    var mp1$prime = match[0];
    if (o2) {
      var match$1 = o2[0];
      return /* tuple */[
              mp1$prime,
              match$1[0],
              match$1[1],
              /* false */0
            ];
    } else {
      return /* tuple */[
              mp1$prime,
              mp2,
              match[1],
              /* true */1
            ];
    }
  } else if (o2) {
    var match$2 = o2[0];
    return /* tuple */[
            mp1,
            match$2[0],
            match$2[1],
            /* false */0
          ];
  } else {
    throw No_subst;
  }
}

function progress(f, x, orelse) {
  var y = Curry._1(f, x);
  if (y !== x) {
    return y;
  } else {
    return orelse;
  }
}

function subst_mind(sub, mind) {
  var match = Names$ReactTemplate.MutInd[/* repr3 */6](mind);
  var l = match[2];
  var dir = match[1];
  var mpc = Names$ReactTemplate.KerName[/* modpath */3](Names$ReactTemplate.MutInd[/* canonical */5](mind));
  try {
    var match$1 = subst_dual_mp(sub, match[0], mpc);
    var resolve = match$1[2];
    var mpc$1 = match$1[1];
    var mpu = match$1[0];
    var knu = Names$ReactTemplate.KerName[/* make */0](mpu, dir, l);
    var knc = mpu === mpc$1 ? knu : Names$ReactTemplate.KerName[/* make */0](mpc$1, dir, l);
    var knc$prime = progress((function (param) {
            return kn_of_delta(resolve, param);
          }), match$1[3] ? knu : knc, knc);
    return Names$ReactTemplate.MutInd[/* make */0](knu, knc$prime);
  }
  catch (exn){
    if (exn === No_subst) {
      return mind;
    } else {
      throw exn;
    }
  }
}

function subst_ind(sub, indi) {
  var ind = indi[0];
  var ind$prime = subst_mind(sub, ind);
  if (ind$prime === ind) {
    return indi;
  } else {
    return /* tuple */[
            ind$prime,
            indi[1]
          ];
  }
}

function subst_pind(sub, param) {
  return /* tuple */[
          subst_ind(sub, param[0]),
          param[1]
        ];
}

function subst_con0(sub, param) {
  var cst = param[0];
  var match = Names$ReactTemplate.Constant[/* repr3 */6](cst);
  var l = match[2];
  var dir = match[1];
  var mpc = Names$ReactTemplate.KerName[/* modpath */3](Names$ReactTemplate.Constant[/* canonical */5](cst));
  var match$1 = subst_dual_mp(sub, match[0], mpc);
  var resolve = match$1[2];
  var mpc$1 = match$1[1];
  var mpu = match$1[0];
  var knu = Names$ReactTemplate.KerName[/* make */0](mpu, dir, l);
  var knc = mpu === mpc$1 ? knu : Names$ReactTemplate.KerName[/* make */0](mpc$1, dir, l);
  var match$2 = search_delta_inline(resolve, knu, knc);
  if (match$2) {
    return /* tuple */[
            Names$ReactTemplate.Constant[/* make1 */1](knu),
            match$2[0]
          ];
  } else {
    var knc$prime = progress((function (param) {
            return kn_of_delta(resolve, param);
          }), match$1[3] ? knu : knc, knc);
    var cst$prime = Names$ReactTemplate.Constant[/* make */0](knu, knc$prime);
    return /* tuple */[
            cst$prime,
            Constr$ReactTemplate.mkConstU(/* tuple */[
                  cst$prime,
                  param[1]
                ])
          ];
  }
}

function subst_con(sub, cst) {
  try {
    return subst_con0(sub, cst);
  }
  catch (exn){
    if (exn === No_subst) {
      return /* tuple */[
              cst[0],
              Constr$ReactTemplate.mkConstU(cst)
            ];
    } else {
      throw exn;
    }
  }
}

function subst_con_kn(sub, con) {
  return subst_con(sub, /* tuple */[
              con,
              Univ$ReactTemplate.Instance[/* empty */0]
            ]);
}

function subst_pcon(sub, pcon) {
  try {
    var match = subst_con0(sub, pcon);
    return /* tuple */[
            match[0],
            pcon[1]
          ];
  }
  catch (exn){
    if (exn === No_subst) {
      return pcon;
    } else {
      throw exn;
    }
  }
}

function subst_pcon_term(sub, pcon) {
  try {
    var match = subst_con0(sub, pcon);
    return /* tuple */[
            /* tuple */[
              match[0],
              pcon[1]
            ],
            match[1]
          ];
  }
  catch (exn){
    if (exn === No_subst) {
      return /* tuple */[
              pcon,
              Constr$ReactTemplate.mkConstU(pcon)
            ];
    } else {
      throw exn;
    }
  }
}

function subst_constant(sub, con) {
  try {
    return subst_con0(sub, /* tuple */[
                  con,
                  Univ$ReactTemplate.Instance[/* empty */0]
                ])[0];
  }
  catch (exn){
    if (exn === No_subst) {
      return con;
    } else {
      throw exn;
    }
  }
}

function subst_evaluable_reference(subst, param) {
  if (param.tag) {
    return /* EvalConstRef */Block.__(1, [subst_constant(subst, param[0])]);
  } else {
    return /* EvalVarRef */Block.__(0, [param[0]]);
  }
}

function map_kn(f, f$prime, c) {
  var func = function (param) {
    return map_kn(f, f$prime, param);
  };
  var match = Constr$ReactTemplate.kind(c);
  switch (match.tag | 0) {
    case 3 : 
        var match$1 = match[0];
        var l = match$1[1];
        var l$prime = Util$ReactTemplate.$$Array[/* smartmap */47](func, l);
        if (l$prime === l) {
          return c;
        } else {
          return Constr$ReactTemplate.mkEvar(/* tuple */[
                      match$1[0],
                      l$prime
                    ]);
        }
    case 5 : 
        var t = match[2];
        var ct = match[0];
        var ct$prime = map_kn(f, f$prime, ct);
        var t$prime = map_kn(f, f$prime, t);
        if (t$prime === t && ct$prime === ct) {
          return c;
        } else {
          return Constr$ReactTemplate.mkCast(/* tuple */[
                      ct$prime,
                      match[1],
                      t$prime
                    ]);
        }
    case 6 : 
        var ct$1 = match[2];
        var t$1 = match[1];
        var ct$prime$1 = map_kn(f, f$prime, ct$1);
        var t$prime$1 = map_kn(f, f$prime, t$1);
        if (t$prime$1 === t$1 && ct$prime$1 === ct$1) {
          return c;
        } else {
          return Constr$ReactTemplate.mkProd(/* tuple */[
                      match[0],
                      t$prime$1,
                      ct$prime$1
                    ]);
        }
    case 7 : 
        var ct$2 = match[2];
        var t$2 = match[1];
        var ct$prime$2 = map_kn(f, f$prime, ct$2);
        var t$prime$2 = map_kn(f, f$prime, t$2);
        if (t$prime$2 === t$2 && ct$prime$2 === ct$2) {
          return c;
        } else {
          return Constr$ReactTemplate.mkLambda(/* tuple */[
                      match[0],
                      t$prime$2,
                      ct$prime$2
                    ]);
        }
    case 8 : 
        var ct$3 = match[3];
        var t$3 = match[2];
        var b = match[1];
        var ct$prime$3 = map_kn(f, f$prime, ct$3);
        var t$prime$3 = map_kn(f, f$prime, t$3);
        var b$prime = map_kn(f, f$prime, b);
        if (t$prime$3 === t$3 && ct$prime$3 === ct$3 && b === b$prime) {
          return c;
        } else {
          return Constr$ReactTemplate.mkLetIn(/* tuple */[
                      match[0],
                      b$prime,
                      t$prime$3,
                      ct$prime$3
                    ]);
        }
    case 9 : 
        var l$1 = match[1];
        var ct$4 = match[0];
        var ct$prime$4 = map_kn(f, f$prime, ct$4);
        var l$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](func, l$1);
        if (ct$prime$4 === ct$4 && l$prime$1 === l$1) {
          return c;
        } else {
          return Constr$ReactTemplate.mkApp(/* tuple */[
                      ct$prime$4,
                      l$prime$1
                    ]);
        }
    case 10 : 
        try {
          return Curry._1(f$prime, match[0])[1];
        }
        catch (exn){
          if (exn === No_subst) {
            return c;
          } else {
            throw exn;
          }
        }
        break;
    case 11 : 
        var match$2 = match[0];
        var match$3 = match$2[0];
        var kn = match$3[0];
        var kn$prime = Curry._1(f, kn);
        if (kn$prime === kn) {
          return c;
        } else {
          return Constr$ReactTemplate.mkIndU(/* tuple */[
                      /* tuple */[
                        kn$prime,
                        match$3[1]
                      ],
                      match$2[1]
                    ]);
        }
    case 12 : 
        var match$4 = match[0];
        var match$5 = match$4[0];
        var match$6 = match$5[0];
        var kn$1 = match$6[0];
        var kn$prime$1 = Curry._1(f, kn$1);
        if (kn$prime$1 === kn$1) {
          return c;
        } else {
          return Constr$ReactTemplate.mkConstructU(/* tuple */[
                      /* tuple */[
                        /* tuple */[
                          kn$prime$1,
                          match$6[1]
                        ],
                        match$5[1]
                      ],
                      match$4[1]
                    ]);
        }
    case 13 : 
        var l$2 = match[3];
        var ct$5 = match[2];
        var p = match[1];
        var ci = match[0];
        var match$7 = ci[/* ci_ind */0];
        var kn$2 = match$7[0];
        var kn$prime$2 = Curry._1(f, kn$2);
        var ci_ind = kn$prime$2 === kn$2 ? ci[/* ci_ind */0] : /* tuple */[
            kn$prime$2,
            match$7[1]
          ];
        var p$prime = map_kn(f, f$prime, p);
        var ct$prime$5 = map_kn(f, f$prime, ct$5);
        var l$prime$2 = Util$ReactTemplate.$$Array[/* smartmap */47](func, l$2);
        if (ci[/* ci_ind */0] === ci_ind && p$prime === p && l$prime$2 === l$2 && ct$prime$5 === ct$5) {
          return c;
        } else {
          return Constr$ReactTemplate.mkCase(/* tuple */[
                      /* record */[
                        /* ci_ind */ci_ind,
                        /* ci_npar */ci[/* ci_npar */1],
                        /* ci_cstr_ndecls */ci[/* ci_cstr_ndecls */2],
                        /* ci_cstr_nargs */ci[/* ci_cstr_nargs */3],
                        /* ci_pp_info */ci[/* ci_pp_info */4]
                      ],
                      p$prime,
                      ct$prime$5,
                      l$prime$2
                    ]);
        }
    case 14 : 
        var match$8 = match[0];
        var match$9 = match$8[1];
        var bl = match$9[2];
        var tl = match$9[1];
        var tl$prime = Util$ReactTemplate.$$Array[/* smartmap */47](func, tl);
        var bl$prime = Util$ReactTemplate.$$Array[/* smartmap */47](func, bl);
        if (bl === bl$prime && tl === tl$prime) {
          return c;
        } else {
          return Constr$ReactTemplate.mkFix(/* tuple */[
                      match$8[0],
                      /* tuple */[
                        match$9[0],
                        tl$prime,
                        bl$prime
                      ]
                    ]);
        }
    case 15 : 
        var match$10 = match[0];
        var match$11 = match$10[1];
        var bl$1 = match$11[2];
        var tl$1 = match$11[1];
        var tl$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](func, tl$1);
        var bl$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](func, bl$1);
        if (bl$1 === bl$prime$1 && tl$1 === tl$prime$1) {
          return c;
        } else {
          return Constr$ReactTemplate.mkCoFix(/* tuple */[
                      match$10[0],
                      /* tuple */[
                        match$11[0],
                        tl$prime$1,
                        bl$prime$1
                      ]
                    ]);
        }
    case 16 : 
        var t$4 = match[1];
        var p$1 = match[0];
        var p$prime$1;
        try {
          p$prime$1 = Names$ReactTemplate.Projection[/* map */9]((function (kn) {
                  return Curry._1(f$prime, /* tuple */[
                                kn,
                                Univ$ReactTemplate.Instance[/* empty */0]
                              ])[0];
                }), p$1);
        }
        catch (exn$1){
          if (exn$1 === No_subst) {
            p$prime$1 = p$1;
          } else {
            throw exn$1;
          }
        }
        var t$prime$4 = map_kn(f, f$prime, t$4);
        if (p$prime$1 === p$1 && t$prime$4 === t$4) {
          return c;
        } else {
          return Constr$ReactTemplate.mkProj(/* tuple */[
                      p$prime$1,
                      t$prime$4
                    ]);
        }
    default:
      return c;
  }
}

function subst_mps(sub, c) {
  if (is_empty$1(sub)) {
    return c;
  } else {
    return map_kn((function (param) {
                  return subst_mind(sub, param);
                }), (function (param) {
                  return subst_con0(sub, param);
                }), c);
  }
}

function replace_mp_in_mp(mpfrom, mpto, mp) {
  if (Names$ReactTemplate.ModPath[/* equal */1](mp, mpfrom)) {
    return mpto;
  } else {
    switch (mp.tag | 0) {
      case 0 : 
      case 1 : 
          return mp;
      case 2 : 
          var mp1 = mp[0];
          var mp1$prime = replace_mp_in_mp(mpfrom, mpto, mp1);
          if (mp1 === mp1$prime) {
            return mp;
          } else {
            return /* MPdot */Block.__(2, [
                      mp1$prime,
                      mp[1]
                    ]);
          }
      
    }
  }
}

function replace_mp_in_kn(mpfrom, mpto, kn) {
  var match = Names$ReactTemplate.KerName[/* repr */2](kn);
  var mp = match[0];
  var mp$prime$prime = replace_mp_in_mp(mpfrom, mpto, mp);
  if (mp === mp$prime$prime) {
    return kn;
  } else {
    return Names$ReactTemplate.KerName[/* make */0](mp$prime$prime, match[1], match[2]);
  }
}

function mp_in_mp(mp, _mp1) {
  while(true) {
    var mp1 = _mp1;
    if (Names$ReactTemplate.ModPath[/* equal */1](mp1, mp)) {
      return /* true */1;
    } else {
      switch (mp1.tag | 0) {
        case 0 : 
        case 1 : 
            return /* false */0;
        case 2 : 
            _mp1 = mp1[0];
            continue ;
            
      }
    }
  };
}

function subset_prefixed_by(mp, resolver) {
  var mp_prefix = function (mkey, mequ, rslv) {
    if (mp_in_mp(mp, mkey)) {
      return add_mp(mkey, mequ, rslv);
    } else {
      return rslv;
    }
  };
  var kn_prefix = function (kn, hint, rslv) {
    if (!hint.tag || !mp_in_mp(mp, Names$ReactTemplate.KerName[/* modpath */3](kn))) {
      return rslv;
    } else {
      return add_kn(kn, hint, rslv);
    }
  };
  return fold(mp_prefix, kn_prefix, resolver, empty);
}

function subst_dom_delta_resolver(subst, resolver) {
  var mp_apply_subst = function (mkey, mequ, rslv) {
    return add_mp(subst_mp(subst, mkey), mequ, rslv);
  };
  var kn_apply_subst = function (kkey, hint, rslv) {
    return add_kn(subst_kn(subst, kkey), hint, rslv);
  };
  return fold(mp_apply_subst, kn_apply_subst, resolver, empty);
}

function subst_mp_delta(sub, mp, mkey) {
  var match = subst_mp0(sub, mp);
  if (match) {
    var match$1 = match[0];
    var resolve = match$1[1];
    var mp1 = find_prefix(resolve, match$1[0]);
    var resolve1 = subset_prefixed_by(mp1, resolve);
    return /* tuple */[
            subst_dom_delta_resolver(map_mp(mp1, mkey, empty), resolve1),
            mp1
          ];
  } else {
    return /* tuple */[
            empty,
            mp
          ];
  }
}

function gen_subst_delta_resolver(dom, subst, resolver) {
  var mp_apply_subst = function (mkey, mequ, rslv) {
    var mkey$prime = dom ? subst_mp(subst, mkey) : mkey;
    var match = subst_mp_delta(subst, mequ, mkey);
    var map1 = match[0];
    var map2 = add_mp(mkey$prime, match[1], rslv);
    return fold(add_mp, add_kn, map1, map2);
  };
  var kn_apply_subst = function (kkey, hint, rslv) {
    var kkey$prime = dom ? subst_kn(subst, kkey) : kkey;
    var hint$prime;
    if (hint.tag) {
      try {
        hint$prime = /* Equiv */Block.__(1, [subst_kn_delta(subst, hint[0])]);
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Change_equiv_to_inline) {
          var match = exn[1];
          hint$prime = /* Inline */Block.__(0, [
              match[0],
              /* Some */[match[1]]
            ]);
        } else {
          throw exn;
        }
      }
    } else {
      var match$1 = hint[1];
      hint$prime = match$1 ? /* Inline */Block.__(0, [
            hint[0],
            /* Some */[subst_mps(subst, match$1[0])]
          ]) : hint;
    }
    return add_kn(kkey$prime, hint$prime, rslv);
  };
  return fold(mp_apply_subst, kn_apply_subst, resolver, empty);
}

function subst_codom_delta_resolver(param, param$1) {
  return gen_subst_delta_resolver(/* false */0, param, param$1);
}

function subst_dom_codom_delta_resolver(param, param$1) {
  return gen_subst_delta_resolver(/* true */1, param, param$1);
}

function add_delta_resolver(resolver1, resolver2) {
  if (is_empty(resolver2)) {
    return resolver1;
  } else {
    var resolver1$1 = resolver1;
    var resolver2$1 = resolver2;
    var mp_apply_rslv = function (mkey, mequ, rslv) {
      return add_mp(mkey, find_prefix(resolver2$1, mequ), rslv);
    };
    var kn_apply_rslv = function (kkey, hint1, rslv) {
      var hint;
      if (hint1.tag) {
        try {
          hint = /* Equiv */Block.__(1, [solve_delta_kn(resolver2$1, hint1[0])]);
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn[0] === Change_equiv_to_inline) {
            var match = exn[1];
            hint = /* Inline */Block.__(0, [
                match[0],
                /* Some */[match[1]]
              ]);
          } else {
            throw exn;
          }
        }
      } else if (hint1[1]) {
        hint = hint1;
      } else {
        try {
          hint = find_kn(kkey, resolver2$1);
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            hint = hint1;
          } else {
            throw exn$1;
          }
        }
      }
      return add_kn(kkey, hint, rslv);
    };
    return fold(mp_apply_rslv, kn_apply_rslv, resolver1$1, resolver2$1);
  }
}

function substition_prefixed_by(k, mp, subst) {
  var mp_prefixmp = function (kmp, param, sub) {
    if (mp_in_mp(mp, kmp) && !Names$ReactTemplate.ModPath[/* equal */1](mp, kmp)) {
      var new_key = replace_mp_in_mp(mp, k, kmp);
      return add_mp$1(new_key, /* tuple */[
                  param[0],
                  param[1]
                ], sub);
    } else {
      return sub;
    }
  };
  var mbi_prefixmp = function (_, _$1, sub) {
    return sub;
  };
  return fold$1(mp_prefixmp, mbi_prefixmp, subst, empty$1);
}

function join$1(subst1, subst2) {
  var apply_subst = function (mpk, add, param, res) {
    var resolve = param[1];
    var mp = param[0];
    var match = subst_mp0(subst2, mp);
    var match$1;
    if (match) {
      var match$2 = match[0];
      match$1 = /* tuple */[
        match$2[0],
        /* Some */[match$2[1]]
      ];
    } else {
      match$1 = /* tuple */[
        mp,
        /* None */0
      ];
    }
    var resolve$prime = match$1[1];
    var mp$prime = match$1[0];
    var resolve$prime$prime = resolve$prime ? add_delta_resolver(subst_dom_codom_delta_resolver(subst2, resolve), resolve$prime[0]) : subst_codom_delta_resolver(subst2, resolve);
    var prefixed_subst = substition_prefixed_by(mpk, mp$prime, subst2);
    return join(prefixed_subst, Curry._2(add, /* tuple */[
                    mp$prime,
                    resolve$prime$prime
                  ], res));
  };
  var mp_apply_subst = function (mp) {
    return (function (param, param$1) {
        return apply_subst(mp, (function (param, param$1) {
                      return add_mp$1(mp, param, param$1);
                    }), param, param$1);
      });
  };
  var mbi_apply_subst = function (mbi) {
    var partial_arg = /* MPbound */Block.__(1, [mbi]);
    return (function (param, param$1) {
        return apply_subst(partial_arg, (function (param, param$1) {
                      return add_mbi(mbi, param, param$1);
                    }), param, param$1);
      });
  };
  var subst = fold$1(mp_apply_subst, mbi_apply_subst, subst1, empty$1);
  return join(subst2, subst);
}

function occur_in_path(mbi, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return /* false */0;
      case 1 : 
          return Names$ReactTemplate.MBId[/* equal */0](mbi, param[0]);
      case 2 : 
          _param = param[0];
          continue ;
          
    }
  };
}

function occur_mbid(mbi, sub) {
  var check_one = function (mbi$prime, param) {
    if (Names$ReactTemplate.MBId[/* equal */0](mbi, mbi$prime) || occur_in_path(mbi, param[0])) {
      throw Pervasives.Exit;
    } else {
      return 0;
    }
  };
  try {
    iter_mbi(check_one, sub);
    return /* false */0;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function from_val(x) {
  return /* record */[
          /* subst_value */x,
          /* subst_subst : [] */0
        ];
}

function force(fsubst, r) {
  var s = r[/* subst_subst */1];
  if (s) {
    var subst = Curry._3(Util$ReactTemplate.List[/* fold_left */13], join$1, empty$1, Curry._1(Util$ReactTemplate.List[/* rev */4], s));
    var x = Curry._2(fsubst, subst, r[/* subst_value */0]);
    r[/* subst_subst */1] = /* [] */0;
    r[/* subst_value */0] = x;
    return x;
  } else {
    return r[/* subst_value */0];
  }
}

function subst_substituted(s, r) {
  return /* record */[
          /* subst_value */r[/* subst_value */0],
          /* subst_subst : :: */[
            s,
            r[/* subst_subst */1]
          ]
        ];
}

function force_constr(param) {
  return force(subst_mps, param);
}

function repr_substituted(r) {
  var s = r[/* subst_subst */1];
  if (s) {
    return /* tuple */[
            /* Some */[s],
            r[/* subst_value */0]
          ];
  } else {
    return /* tuple */[
            /* None */0,
            r[/* subst_value */0]
          ];
  }
}

var empty_delta_resolver = empty;

var empty_subst = empty$1;

var is_empty_subst = is_empty$1;

var subst_constr = subst_substituted;

exports.empty_delta_resolver = empty_delta_resolver;
exports.add_mp_delta_resolver = add_mp_delta_resolver;
exports.add_kn_delta_resolver = add_kn_delta_resolver;
exports.add_inline_delta_resolver = add_inline_delta_resolver;
exports.add_delta_resolver = add_delta_resolver;
exports.mp_of_delta = mp_of_delta;
exports.kn_of_delta = kn_of_delta;
exports.constant_of_delta_kn = constant_of_delta_kn;
exports.constant_of_deltas_kn = constant_of_deltas_kn;
exports.mind_of_delta_kn = mind_of_delta_kn;
exports.mind_of_deltas_kn = mind_of_deltas_kn;
exports.inline_of_delta = inline_of_delta;
exports.mp_in_delta = mp_in_delta;
exports.con_in_delta = con_in_delta;
exports.mind_in_delta = mind_in_delta;
exports.empty_subst = empty_subst;
exports.is_empty_subst = is_empty_subst;
exports.add_mbid = add_mbid;
exports.add_mp = add_mp$2;
exports.map_mbid = map_mbid;
exports.map_mp = map_mp;
exports.join = join$1;
exports.subst_dom_delta_resolver = subst_dom_delta_resolver;
exports.subst_codom_delta_resolver = subst_codom_delta_resolver;
exports.subst_dom_codom_delta_resolver = subst_dom_codom_delta_resolver;
exports.from_val = from_val;
exports.force = force;
exports.subst_substituted = subst_substituted;
exports.debug_string_of_subst = debug_string_of_subst;
exports.debug_pr_subst = debug_pr_subst;
exports.debug_string_of_delta = debug_string_of_delta;
exports.debug_pr_delta = debug_pr_delta;
exports.subst_mp = subst_mp;
exports.subst_mind = subst_mind;
exports.subst_ind = subst_ind;
exports.subst_pind = subst_pind;
exports.subst_kn = subst_kn;
exports.subst_con = subst_con;
exports.subst_pcon = subst_pcon;
exports.subst_pcon_term = subst_pcon_term;
exports.subst_con_kn = subst_con_kn;
exports.subst_constant = subst_constant;
exports.subst_evaluable_reference = subst_evaluable_reference;
exports.replace_mp_in_kn = replace_mp_in_kn;
exports.subst_mps = subst_mps;
exports.occur_mbid = occur_mbid;
exports.repr_substituted = repr_substituted;
exports.force_constr = force_constr;
exports.subst_constr = subst_constr;
/* Pp-ReactTemplate Not a pure module */
