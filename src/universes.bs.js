// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var UGraph$ReactTemplate = require("./uGraph.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var CProfile$ReactTemplate = require("../shims/cProfile.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Unionfind$ReactTemplate = require("./unionfind.bs.js");
var OrderedType$ReactTemplate = require("./orderedType.bs.js");
var RemoteCounter$ReactTemplate = require("./remoteCounter.bs.js");

var UPairs = OrderedType$ReactTemplate.UnorderedPair([Univ$ReactTemplate.Level[5]]);

var UPairSet = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], UPairs);

function reference_of_level(l) {
  var match = Univ$ReactTemplate.Level[/* name */13](l);
  var eta;
  if (match) {
    var na = match[0];
    var qid;
    try {
      qid = Nametab$ReactTemplate.shortest_qualid_of_universe(na);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var name = Names$ReactTemplate.Id[/* of_string_soft */6](Pervasives.string_of_int(na[1]));
        qid = Libnames$ReactTemplate.make_qualid(na[0], name);
      } else {
        throw exn;
      }
    }
    eta = /* Qualid */Block.__(0, [qid]);
  } else {
    eta = /* Ident */Block.__(1, [Names$ReactTemplate.Id[/* of_string_soft */6](Univ$ReactTemplate.Level[/* to_string */10](l))]);
  }
  return CAst$ReactTemplate.make(/* None */0, eta);
}

function pr_with_global_universes(l) {
  return Libnames$ReactTemplate.pr_reference(reference_of_level(l));
}

var universe_map = Summary$ReactTemplate.ref(/* None */0, "global universe info", Nametab$ReactTemplate.UnivIdMap[/* empty */0]);

function add_global_universe(u, p) {
  var match = Univ$ReactTemplate.Level[/* name */13](u);
  if (match) {
    universe_map[0] = Curry._3(Nametab$ReactTemplate.UnivIdMap[/* add */3], match[0], p, universe_map[0]);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function is_polymorphic(l) {
  var match = Univ$ReactTemplate.Level[/* name */13](l);
  if (match) {
    try {
      return Curry._2(Nametab$ReactTemplate.UnivIdMap[/* find */21], match[0], universe_map[0]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  } else {
    return /* false */0;
  }
}

var empty_binders = Names$ReactTemplate.Id[/* Map */10][/* empty */0];

var universe_binders_table = Summary$ReactTemplate.ref(/* None */0, "universe binders", Globnames$ReactTemplate.Refmap[/* empty */0]);

function universe_binders_of_global(ref) {
  try {
    return Curry._2(Globnames$ReactTemplate.Refmap[/* find */21], ref, universe_binders_table[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Names$ReactTemplate.Id[/* Map */10][/* empty */0];
    } else {
      throw exn;
    }
  }
}

function cache_ubinder(param) {
  var match = param[1];
  universe_binders_table[0] = Curry._3(Globnames$ReactTemplate.Refmap[/* add */3], match[0], match[1], universe_binders_table[0]);
  return /* () */0;
}

function subst_ubinder(param) {
  var orig = param[1];
  var ref = orig[0];
  var ref$prime = Globnames$ReactTemplate.subst_global(param[0], ref)[0];
  if (ref === ref$prime) {
    return orig;
  } else {
    return /* tuple */[
            ref$prime,
            orig[1]
          ];
  }
}

function discharge_ubinder(param) {
  var match = param[1];
  return /* Some */[/* tuple */[
            Lib$ReactTemplate.discharge_global(match[0]),
            match[1]
          ]];
}

var init = Libobject$ReactTemplate.default_object("universe binder");

var ubinder_obj = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_ubinder,
      /* load_function */(function (_, x) {
          return cache_ubinder(x);
        }),
      /* open_function */init[/* open_function */3],
      /* classify_function */(function (x) {
          return /* Substitute */Block.__(0, [x]);
        }),
      /* subst_function */subst_ubinder,
      /* discharge_function */discharge_ubinder,
      /* rebuild_function */(function (x) {
          return x;
        })
    ]);

function register_universe_binders(ref, ubinders) {
  var ubinders$1 = Curry._3(Nametab$ReactTemplate.UnivIdMap[/* fold */10], (function (lvl, poly, ubinders) {
          var qid = Nametab$ReactTemplate.shortest_qualid_of_universe(lvl);
          var level = Univ$ReactTemplate.Level[/* make */8](lvl[0], lvl[1]);
          if (poly) {
            return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], Libnames$ReactTemplate.repr_qualid(qid)[1], level, ubinders);
          } else {
            return ubinders;
          }
        }), universe_map[0], ubinders);
  if (Curry._1(Names$ReactTemplate.Id[/* Map */10][/* is_empty */1], ubinders$1)) {
    return 0;
  } else {
    return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(ubinder_obj, /* tuple */[
                    ref,
                    ubinders$1
                  ]));
  }
}

function universe_binders_with_opt_names(ref, levels, param) {
  if (param) {
    var udecl = param[0];
    if (Curry._1(Util$ReactTemplate.List[/* length */0], levels) === Curry._1(Util$ReactTemplate.List[/* length */0], udecl)) {
      return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (acc, param, lvl) {
                    var na = param[/* v */0];
                    if (na) {
                      return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], na[0], lvl, acc);
                    } else {
                      return acc;
                    }
                  }), empty_binders, udecl, levels);
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["universe_binders_with_opt_names"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Universe instance should have length "), Pp$ReactTemplate.$$int(Curry._1(Util$ReactTemplate.List[/* length */0], levels))));
    }
  } else {
    return universe_binders_of_global(ref);
  }
}

var set_minimization = [/* true */1];

function is_set_minimization() {
  return set_minimization[0];
}

function compare(x, y) {
  var exit = 0;
  var u;
  var v;
  var u$prime;
  var v$prime;
  switch (x.tag | 0) {
    case 0 : 
        if (y.tag) {
          return -1;
        } else {
          var i = Univ$ReactTemplate.Universe[/* compare */0](x[0], y[0]);
          if (i) {
            return i;
          } else {
            return Univ$ReactTemplate.Universe[/* compare */0](x[1], y[1]);
          }
        }
        break;
    case 1 : 
        var v$1 = x[1];
        var u$1 = x[0];
        switch (y.tag | 0) {
          case 0 : 
              return 1;
          case 1 : 
              var v$prime$1 = y[1];
              var u$prime$1 = y[0];
              var i$1 = Univ$ReactTemplate.Universe[/* compare */0](u$1, u$prime$1);
              if (i$1) {
                if (Univ$ReactTemplate.Universe[/* equal */1](u$1, v$prime$1) && Univ$ReactTemplate.Universe[/* equal */1](v$1, u$prime$1)) {
                  return 0;
                } else {
                  return i$1;
                }
              } else {
                return Univ$ReactTemplate.Universe[/* compare */0](v$1, v$prime$1);
              }
          case 2 : 
          case 3 : 
              return -1;
          
        }
        break;
    case 2 : 
        switch (y.tag | 0) {
          case 0 : 
          case 1 : 
              return 1;
          case 2 : 
              u = x[0];
              v = x[1];
              u$prime = y[0];
              v$prime = y[1];
              exit = 1;
              break;
          case 3 : 
              return -1;
          
        }
        break;
    case 3 : 
        switch (y.tag | 0) {
          case 0 : 
          case 1 : 
          case 2 : 
              return 1;
          case 3 : 
              u = x[0];
              v = x[1];
              u$prime = y[0];
              v$prime = y[1];
              exit = 1;
              break;
          
        }
        break;
    
  }
  if (exit === 1) {
    var i$2 = Univ$ReactTemplate.Level[/* compare */5](u, u$prime);
    if (i$2) {
      if (Univ$ReactTemplate.Level[/* equal */6](u, v$prime) && Univ$ReactTemplate.Level[/* equal */6](v, u$prime)) {
        return 0;
      } else {
        return i$2;
      }
    } else {
      return Univ$ReactTemplate.Level[/* compare */5](v, v$prime);
    }
  }
  
}

var S = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], /* module */[/* compare */compare]);

var empty = S[0];

var add = S[3];

var singleton = S[4];

var equal = S[10];

var fold = S[13];

function is_trivial(param) {
  switch (param.tag | 0) {
    case 0 : 
    case 1 : 
        return Univ$ReactTemplate.Universe[/* equal */1](param[0], param[1]);
    case 2 : 
    case 3 : 
        return Univ$ReactTemplate.Level[/* equal */6](param[0], param[1]);
    
  }
}

function add$1(cst, s) {
  if (is_trivial(cst)) {
    return s;
  } else {
    return Curry._2(add, cst, s);
  }
}

function pr_one(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Univ$ReactTemplate.Universe[/* pr */4](param[0]), Pp$ReactTemplate.str(" <= ")), Univ$ReactTemplate.Universe[/* pr */4](param[1]));
    case 1 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Univ$ReactTemplate.Universe[/* pr */4](param[0]), Pp$ReactTemplate.str(" = ")), Univ$ReactTemplate.Universe[/* pr */4](param[1]));
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Univ$ReactTemplate.Level[/* pr */9](param[0]), Pp$ReactTemplate.str(" /\\ ")), Univ$ReactTemplate.Level[/* pr */9](param[1]));
    case 3 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Univ$ReactTemplate.Level[/* pr */9](param[0]), Pp$ReactTemplate.str(" ~ ")), Univ$ReactTemplate.Level[/* pr */9](param[1]));
    
  }
}

function pr(c) {
  return Curry._3(fold, (function (cst, pp_std) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pp_std, pr_one(cst)), Pp$ReactTemplate.fnl(/* () */0));
              }), c, Pp$ReactTemplate.str(""));
}

function equal$1(x, y) {
  if (x === y) {
    return /* true */1;
  } else {
    return Curry._2(equal, x, y);
  }
}

function enforce_eq_instances_univs(strict, x, y, c) {
  var mk = function (u, v) {
    if (strict) {
      return /* ULub */Block.__(2, [
                u,
                v
              ]);
    } else {
      return /* UEq */Block.__(1, [
                Univ$ReactTemplate.Universe[/* make */3](u),
                Univ$ReactTemplate.Universe[/* make */3](v)
              ]);
    }
  };
  var ax = Univ$ReactTemplate.Instance[/* to_array */3](x);
  var ay = Univ$ReactTemplate.Instance[/* to_array */3](y);
  if (ax.length !== ay.length) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Invalid argument: enforce_eq_instances_univs called with"), Pp$ReactTemplate.str(" instances of different lengths.")));
  }
  return CArray$ReactTemplate.fold_right2((function (x, y) {
                var partial_arg = mk(x, y);
                return (function (param) {
                    return add$1(partial_arg, param);
                  });
              }), ax, ay, c);
}

function enforce_univ_constraint(param) {
  var v = param[2];
  var u = param[0];
  switch (param[1]) {
    case 0 : 
        var partial_arg = Univ$ReactTemplate.$$super(u);
        return (function (param) {
            return Univ$ReactTemplate.enforce_leq(partial_arg, v, param);
          });
    case 1 : 
        return (function (param) {
            return Univ$ReactTemplate.enforce_leq(u, v, param);
          });
    case 2 : 
        return (function (param) {
            return Univ$ReactTemplate.enforce_eq(u, v, param);
          });
    
  }
}

function subst_univs_level(fn, l) {
  try {
    return /* Some */[Curry._1(fn, l)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function subst_univs_constraints(subst, csts) {
  return Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], (function (c, cstrs) {
                var fn = subst;
                var c$1 = c;
                var cstrs$1 = cstrs;
                var v = c$1[2];
                var d = c$1[1];
                var u = c$1[0];
                var u$prime = subst_univs_level(fn, u);
                var v$prime = subst_univs_level(fn, v);
                if (u$prime) {
                  var u$1 = u$prime[0];
                  if (v$prime) {
                    return Curry._1(enforce_univ_constraint(/* tuple */[
                                    u$1,
                                    d,
                                    v$prime[0]
                                  ]), cstrs$1);
                  } else {
                    return Curry._1(enforce_univ_constraint(/* tuple */[
                                    u$1,
                                    d,
                                    Univ$ReactTemplate.Universe[/* make */3](v)
                                  ]), cstrs$1);
                  }
                } else if (v$prime) {
                  return Curry._1(enforce_univ_constraint(/* tuple */[
                                  Univ$ReactTemplate.Universe[/* make */3](u),
                                  d,
                                  v$prime[0]
                                ]), cstrs$1);
                } else {
                  return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], c$1, cstrs$1);
                }
              }), csts, Univ$ReactTemplate.Constraint[/* empty */0]);
}

function level_subst_of(f, l) {
  try {
    var u = Curry._1(f, l);
    var match = Univ$ReactTemplate.Universe[/* level */8](u);
    if (match) {
      return match[0];
    } else {
      return l;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return l;
    } else {
      throw exn;
    }
  }
}

function subst_univs_universe_constraint(fn, param) {
  var exit = 0;
  switch (param.tag | 0) {
    case 0 : 
    case 1 : 
        exit = 1;
        break;
    case 2 : 
        var u$prime = level_subst_of(fn, param[0]);
        var v$prime = level_subst_of(fn, param[1]);
        if (Univ$ReactTemplate.Level[/* equal */6](u$prime, v$prime)) {
          return /* None */0;
        } else {
          return /* Some */[/* ULub */Block.__(2, [
                      u$prime,
                      v$prime
                    ])];
        }
    case 3 : 
        var u$prime$1 = level_subst_of(fn, param[0]);
        var v$prime$1 = level_subst_of(fn, param[1]);
        if (Univ$ReactTemplate.Level[/* equal */6](u$prime$1, v$prime$1)) {
          return /* None */0;
        } else {
          return /* Some */[/* UWeak */Block.__(3, [
                      u$prime$1,
                      v$prime$1
                    ])];
        }
    
  }
  if (exit === 1) {
    var u$prime$2 = Univ$ReactTemplate.subst_univs_universe(fn, param[0]);
    var v$prime$2 = Univ$ReactTemplate.subst_univs_universe(fn, param[1]);
    if (Univ$ReactTemplate.Universe[/* equal */1](u$prime$2, v$prime$2)) {
      return /* None */0;
    } else {
      return /* Some */[/* ULe */Block.__(0, [
                  u$prime$2,
                  v$prime$2
                ])];
    }
  }
  
}

function subst_univs_universe_constraints(subst, csts) {
  return Curry._3(fold, (function (c) {
                var partial_arg = subst_univs_universe_constraint(subst, c);
                return (function (param) {
                    return Option$ReactTemplate.fold_right(add$1, partial_arg, param);
                  });
              }), csts, empty);
}

function to_constraints(force_weak, g, s) {
  var tr = function (cst, acc) {
    switch (cst.tag | 0) {
      case 0 : 
          var l$prime = cst[1];
          var l = cst[0];
          var match = Univ$ReactTemplate.Universe[/* level */8](l);
          var match$1 = Univ$ReactTemplate.Universe[/* level */8](l$prime);
          var exit = 0;
          if (match) {
            if (match$1) {
              return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                          match[0],
                          /* Le */1,
                          match$1[0]
                        ], acc);
            } else {
              exit = 1;
            }
          } else if (match$1) {
            return Univ$ReactTemplate.enforce_leq(l, l$prime, acc);
          } else {
            exit = 1;
          }
          if (exit === 1) {
            if (UGraph$ReactTemplate.check_leq(g, l, l$prime)) {
              return acc;
            } else {
              throw [
                    Caml_builtin_exceptions.invalid_argument,
                    "to_constraints: non-trivial algebraic constraint between universes"
                  ];
            }
          }
          break;
      case 1 : 
          var l$prime$1 = cst[1];
          var l$1 = cst[0];
          var match$2 = Univ$ReactTemplate.Universe[/* level */8](l$1);
          var match$3 = Univ$ReactTemplate.Universe[/* level */8](l$prime$1);
          var exit$1 = 0;
          if (match$2) {
            if (match$3) {
              return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                          match$2[0],
                          /* Eq */2,
                          match$3[0]
                        ], acc);
            } else {
              exit$1 = 1;
            }
          } else {
            exit$1 = 1;
          }
          if (exit$1 === 1) {
            if (UGraph$ReactTemplate.check_eq(g, l$1, l$prime$1)) {
              return acc;
            } else {
              throw [
                    Caml_builtin_exceptions.invalid_argument,
                    "to_constraints: non-trivial algebraic constraint between universes"
                  ];
            }
          }
          break;
      case 2 : 
          return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                      cst[0],
                      /* Eq */2,
                      cst[1]
                    ], acc);
      case 3 : 
          if (force_weak) {
            return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                        cst[0],
                        /* Eq */2,
                        cst[1]
                      ], acc);
          } else {
            return acc;
          }
      
    }
  };
  return Curry._3(fold, tr, s, Univ$ReactTemplate.Constraint[/* empty */0]);
}

function eq_constr_univs_infer_with(kind1, kind2, univs, fold, m, n, accu) {
  var cstrs = [accu];
  var eq_universes = function (_, _$1) {
    return (function (param, param$1) {
        return UGraph$ReactTemplate.check_eq_instances(univs, param, param$1);
      });
  };
  var eq_sorts = function (s1, s2) {
    if (Sorts$ReactTemplate.equal(s1, s2)) {
      return /* true */1;
    } else {
      var u1 = Sorts$ReactTemplate.univ_of_sort(s1);
      var u2 = Sorts$ReactTemplate.univ_of_sort(s2);
      var match = Curry._2(fold, Curry._1(singleton, /* UEq */Block.__(1, [
                  u1,
                  u2
                ])), cstrs[0]);
      if (match) {
        cstrs[0] = match[0];
        return /* true */1;
      } else {
        return /* false */0;
      }
    }
  };
  var eq_constr$prime = function (nargs, m, n) {
    return Constr$ReactTemplate.compare_head_gen_with(kind1, kind2, eq_universes, eq_sorts, eq_constr$prime, nargs, m)(n);
  };
  var res = Constr$ReactTemplate.compare_head_gen_with(kind1, kind2, eq_universes, eq_sorts, eq_constr$prime, 0, m)(n);
  if (res) {
    return /* Some */[cstrs[0]];
  } else {
    return /* None */0;
  }
}

var match = RemoteCounter$ReactTemplate.new_counter("Universes", 0, (function (param) {
        return 1 + param | 0;
      }), (function (n) {
        return /* tuple */[
                Global$ReactTemplate.current_dirpath(/* () */0),
                n
              ];
      }));

var new_univ_id = match[0];

function new_univ_level() {
  var match = Curry._1(new_univ_id, /* () */0);
  return Univ$ReactTemplate.Level[/* make */8](match[0], match[1]);
}

function new_univ(dp) {
  return Univ$ReactTemplate.Universe[/* make */3](new_univ_level(dp));
}

function new_Type(dp) {
  return Constr$ReactTemplate.mkType(Univ$ReactTemplate.Universe[/* make */3](new_univ_level(dp)));
}

function new_Type_sort(dp) {
  return /* Type */Block.__(1, [Univ$ReactTemplate.Universe[/* make */3](new_univ_level(dp))]);
}

function fresh_universe_instance(ctx) {
  var init = function () {
    return new_univ_level(/* () */0);
  };
  return Univ$ReactTemplate.Instance[/* of_array */2](Util$ReactTemplate.$$Array[/* init */0](Univ$ReactTemplate.AUContext[/* size */4](ctx), init));
}

function fresh_instance_from_context(ctx) {
  var inst = fresh_universe_instance(ctx);
  var constraints = Univ$ReactTemplate.AUContext[/* instantiate */6](inst, ctx);
  return /* tuple */[
          inst,
          constraints
        ];
}

function fresh_instance(ctx) {
  var ctx$prime = [Univ$ReactTemplate.LSet[/* empty */0]];
  var init = function () {
    var u = new_univ_level(/* () */0);
    ctx$prime[0] = Curry._2(Univ$ReactTemplate.LSet[/* add */3], u, ctx$prime[0]);
    return u;
  };
  var inst = Univ$ReactTemplate.Instance[/* of_array */2](Util$ReactTemplate.$$Array[/* init */0](Univ$ReactTemplate.AUContext[/* size */4](ctx), init));
  return /* tuple */[
          ctx$prime[0],
          inst
        ];
}

function existing_instance(ctx, inst) {
  var len1 = Univ$ReactTemplate.Instance[/* to_array */3](inst).length;
  var len2 = Univ$ReactTemplate.AUContext[/* size */4](ctx);
  if (len1 !== len2) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Universes"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Polymorphic constant expected "), Pp$ReactTemplate.$$int(len2)), Pp$ReactTemplate.str(" levels but was given ")), Pp$ReactTemplate.$$int(len1)));
  }
  return /* tuple */[
          Univ$ReactTemplate.LSet[/* empty */0],
          inst
        ];
}

function fresh_instance_from(ctx, inst) {
  var match = inst ? existing_instance(ctx, inst[0]) : fresh_instance(ctx);
  var inst$1 = match[1];
  var constraints = Univ$ReactTemplate.AUContext[/* instantiate */6](inst$1, ctx);
  return /* tuple */[
          inst$1,
          /* tuple */[
            match[0],
            constraints
          ]
        ];
}

function fresh_constant_instance(env, c, inst) {
  var cb = Environ$ReactTemplate.lookup_constant(c, env);
  var match = cb[/* const_universes */4];
  if (match.tag) {
    var match$1 = fresh_instance_from(match[0], inst);
    return /* tuple */[
            /* tuple */[
              c,
              match$1[0]
            ],
            match$1[1]
          ];
  } else {
    return /* tuple */[
            /* tuple */[
              c,
              Univ$ReactTemplate.Instance[/* empty */0]
            ],
            Univ$ReactTemplate.ContextSet[/* empty */0]
          ];
  }
}

function fresh_inductive_instance(env, ind, inst) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  var match$1 = match[0][/* mind_universes */8];
  switch (match$1.tag | 0) {
    case 0 : 
        return /* tuple */[
                /* tuple */[
                  ind,
                  Univ$ReactTemplate.Instance[/* empty */0]
                ],
                Univ$ReactTemplate.ContextSet[/* empty */0]
              ];
    case 1 : 
        var match$2 = fresh_instance_from(match$1[0], inst);
        return /* tuple */[
                /* tuple */[
                  ind,
                  match$2[0]
                ],
                match$2[1]
              ];
    case 2 : 
        var match$3 = fresh_instance_from(Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](match$1[0]), inst);
        return /* tuple */[
                /* tuple */[
                  ind,
                  match$3[0]
                ],
                match$3[1]
              ];
    
  }
}

function fresh_constructor_instance(env, param, inst) {
  var i = param[1];
  var ind = param[0];
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  var match$1 = match[0][/* mind_universes */8];
  switch (match$1.tag | 0) {
    case 0 : 
        return /* tuple */[
                /* tuple */[
                  /* tuple */[
                    ind,
                    i
                  ],
                  Univ$ReactTemplate.Instance[/* empty */0]
                ],
                Univ$ReactTemplate.ContextSet[/* empty */0]
              ];
    case 1 : 
        var match$2 = fresh_instance_from(match$1[0], inst);
        return /* tuple */[
                /* tuple */[
                  /* tuple */[
                    ind,
                    i
                  ],
                  match$2[0]
                ],
                match$2[1]
              ];
    case 2 : 
        var match$3 = fresh_instance_from(Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](match$1[0]), inst);
        return /* tuple */[
                /* tuple */[
                  /* tuple */[
                    ind,
                    i
                  ],
                  match$3[0]
                ],
                match$3[1]
              ];
    
  }
}

function fresh_global_instance(names, env, gr) {
  switch (gr.tag | 0) {
    case 0 : 
        return /* tuple */[
                Constr$ReactTemplate.mkVar(gr[0]),
                Univ$ReactTemplate.ContextSet[/* empty */0]
              ];
    case 1 : 
        var match = fresh_constant_instance(env, gr[0], names);
        return /* tuple */[
                Constr$ReactTemplate.mkConstU(match[0]),
                match[1]
              ];
    case 2 : 
        var match$1 = fresh_inductive_instance(env, gr[0], names);
        return /* tuple */[
                Constr$ReactTemplate.mkIndU(match$1[0]),
                match$1[1]
              ];
    case 3 : 
        var match$2 = fresh_constructor_instance(env, gr[0], names);
        return /* tuple */[
                Constr$ReactTemplate.mkConstructU(match$2[0]),
                match$2[1]
              ];
    
  }
}

function fresh_constant_instance$1(env, sp) {
  return fresh_constant_instance(env, sp, /* None */0);
}

function fresh_inductive_instance$1(env, sp) {
  return fresh_inductive_instance(env, sp, /* None */0);
}

function fresh_constructor_instance$1(env, sp) {
  return fresh_constructor_instance(env, sp, /* None */0);
}

function constr_of_global(gr) {
  var match = fresh_global_instance(/* None */0, Global$ReactTemplate.env(/* () */0), gr);
  var ctx = match[1];
  var c = match[0];
  if (!Univ$ReactTemplate.ContextSet[/* is_empty */1](ctx) && !Curry._1(Univ$ReactTemplate.LSet[/* is_empty */1], Univ$ReactTemplate.ContextSet[/* levels */16](ctx))) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["constr_of_global"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("globalization of polymorphic reference "), Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], gr)), Pp$ReactTemplate.str(" would forget universes.")));
  } else {
    return c;
  }
}

function constr_of_global_univ(param) {
  var u = param[1];
  var gr = param[0];
  switch (gr.tag | 0) {
    case 0 : 
        return Constr$ReactTemplate.mkVar(gr[0]);
    case 1 : 
        return Constr$ReactTemplate.mkConstU(/* tuple */[
                    gr[0],
                    u
                  ]);
    case 2 : 
        return Constr$ReactTemplate.mkIndU(/* tuple */[
                    gr[0],
                    u
                  ]);
    case 3 : 
        return Constr$ReactTemplate.mkConstructU(/* tuple */[
                    gr[0],
                    u
                  ]);
    
  }
}

function fresh_global_or_constr_instance(env, param) {
  if (param.tag) {
    return /* tuple */[
            param[0],
            Univ$ReactTemplate.ContextSet[/* empty */0]
          ];
  } else {
    return fresh_global_instance(/* None */0, env, param[0]);
  }
}

function global_of_constr(c) {
  var match = Constr$ReactTemplate.kind(c);
  switch (match.tag | 0) {
    case 1 : 
        return /* tuple */[
                /* VarRef */Block.__(0, [match[0]]),
                Univ$ReactTemplate.Instance[/* empty */0]
              ];
    case 10 : 
        var match$1 = match[0];
        return /* tuple */[
                /* ConstRef */Block.__(1, [match$1[0]]),
                match$1[1]
              ];
    case 11 : 
        var match$2 = match[0];
        return /* tuple */[
                /* IndRef */Block.__(2, [match$2[0]]),
                match$2[1]
              ];
    case 12 : 
        var match$3 = match[0];
        return /* tuple */[
                /* ConstructRef */Block.__(3, [match$3[0]]),
                match$3[1]
              ];
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function type_of_global(t) {
  var env = Global$ReactTemplate.env(/* () */0);
  var r = t;
  switch (r.tag | 0) {
    case 0 : 
        return /* tuple */[
                Environ$ReactTemplate.named_type(r[0], env),
                Univ$ReactTemplate.ContextSet[/* empty */0]
              ];
    case 1 : 
        var cb = Environ$ReactTemplate.lookup_constant(r[0], env);
        var ty = cb[/* const_type */2];
        var match = cb[/* const_universes */4];
        if (match.tag) {
          var match$1 = fresh_instance_from(match[0], /* None */0);
          return /* tuple */[
                  Vars$ReactTemplate.subst_instance_constr(match$1[0], ty),
                  match$1[1]
                ];
        } else {
          return /* tuple */[
                  ty,
                  Univ$ReactTemplate.ContextSet[/* empty */0]
                ];
        }
        break;
    case 2 : 
        var specif = Inductive$ReactTemplate.lookup_mind_specif(env, r[0]);
        var match$2 = specif[0][/* mind_universes */8];
        switch (match$2.tag | 0) {
          case 0 : 
              var ty$1 = Inductive$ReactTemplate.type_of_inductive(env, /* tuple */[
                    specif,
                    Univ$ReactTemplate.Instance[/* empty */0]
                  ]);
              return /* tuple */[
                      ty$1,
                      Univ$ReactTemplate.ContextSet[/* empty */0]
                    ];
          case 1 : 
              var match$3 = fresh_instance_from(match$2[0], /* None */0);
              var ty$2 = Inductive$ReactTemplate.type_of_inductive(env, /* tuple */[
                    specif,
                    match$3[0]
                  ]);
              return /* tuple */[
                      ty$2,
                      match$3[1]
                    ];
          case 2 : 
              var match$4 = fresh_instance_from(Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](match$2[0]), /* None */0);
              var ty$3 = Inductive$ReactTemplate.type_of_inductive(env, /* tuple */[
                    specif,
                    match$4[0]
                  ]);
              return /* tuple */[
                      ty$3,
                      match$4[1]
                    ];
          
        }
        break;
    case 3 : 
        var cstr = r[0];
        var specif$1 = Inductive$ReactTemplate.lookup_mind_specif(env, Names$ReactTemplate.inductive_of_constructor(cstr));
        var match$5 = specif$1[0][/* mind_universes */8];
        switch (match$5.tag | 0) {
          case 0 : 
              return /* tuple */[
                      Inductive$ReactTemplate.type_of_constructor(/* tuple */[
                            cstr,
                            Univ$ReactTemplate.Instance[/* empty */0]
                          ], specif$1),
                      Univ$ReactTemplate.ContextSet[/* empty */0]
                    ];
          case 1 : 
              var match$6 = fresh_instance_from(match$5[0], /* None */0);
              return /* tuple */[
                      Inductive$ReactTemplate.type_of_constructor(/* tuple */[
                            cstr,
                            match$6[0]
                          ], specif$1),
                      match$6[1]
                    ];
          case 2 : 
              var match$7 = fresh_instance_from(Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](match$5[0]), /* None */0);
              return /* tuple */[
                      Inductive$ReactTemplate.type_of_constructor(/* tuple */[
                            cstr,
                            match$7[0]
                          ], specif$1),
                      match$7[1]
                    ];
          
        }
        break;
    
  }
}

function fresh_sort_in_family(_, param) {
  switch (param) {
    case 0 : 
        return /* tuple */[
                Sorts$ReactTemplate.prop,
                Univ$ReactTemplate.ContextSet[/* empty */0]
              ];
    case 1 : 
        return /* tuple */[
                Sorts$ReactTemplate.set,
                Univ$ReactTemplate.ContextSet[/* empty */0]
              ];
    case 2 : 
        var u = new_univ_level(/* () */0);
        return /* tuple */[
                /* Type */Block.__(1, [Univ$ReactTemplate.Universe[/* make */3](u)]),
                Univ$ReactTemplate.ContextSet[/* singleton */2](u)
              ];
    
  }
}

function new_sort_in_family(sf) {
  return fresh_sort_in_family(Global$ReactTemplate.env(/* () */0), sf)[0];
}

function extend_context(param, ctx$prime) {
  return /* tuple */[
          param[0],
          Univ$ReactTemplate.ContextSet[/* union */6](param[1], ctx$prime)
        ];
}

function new_global_univ() {
  var u = new_univ_level(/* () */0);
  return /* tuple */[
          Univ$ReactTemplate.Universe[/* make */3](u),
          Univ$ReactTemplate.ContextSet[/* singleton */2](u)
        ];
}

var LevelUnionFind = Unionfind$ReactTemplate.Make([
        Univ$ReactTemplate.LSet[4],
        Univ$ReactTemplate.LSet[6],
        Univ$ReactTemplate.LSet[22],
        Univ$ReactTemplate.LSet[12]
      ])([
      Univ$ReactTemplate.LMap[0],
      Univ$ReactTemplate.LMap[21],
      Univ$ReactTemplate.LMap[3],
      Univ$ReactTemplate.LMap[2],
      Univ$ReactTemplate.LMap[10]
    ]);

function add_list_map(u, t, map) {
  try {
    var l = Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, map);
    return Curry._3(Univ$ReactTemplate.LMap[/* set */25], u, /* :: */[
                t,
                l
              ], map);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, /* :: */[
                  t,
                  /* [] */0
                ], map);
    } else {
      throw exn;
    }
  }
}

function choose_canonical(ctx, flexible, algs, s) {
  var $$global = Curry._2(Univ$ReactTemplate.LSet[/* diff */8], s, ctx);
  var match = Curry._2(Univ$ReactTemplate.LSet[/* partition */17], flexible, Curry._2(Univ$ReactTemplate.LSet[/* inter */7], s, ctx));
  var rigid = match[1];
  var flexible$1 = match[0];
  if (Curry._1(Univ$ReactTemplate.LSet[/* is_empty */1], $$global)) {
    if (Curry._1(Univ$ReactTemplate.LSet[/* is_empty */1], rigid)) {
      var match$1 = Curry._2(Univ$ReactTemplate.LSet[/* partition */17], (function (x) {
              return Curry._2(Univ$ReactTemplate.LSet[/* mem */2], x, algs);
            }), flexible$1);
      var nonalgs = match$1[1];
      if (Curry._1(Univ$ReactTemplate.LSet[/* is_empty */1], nonalgs)) {
        var canon = Curry._1(Univ$ReactTemplate.LSet[/* choose */22], match$1[0]);
        return /* tuple */[
                canon,
                /* tuple */[
                  $$global,
                  rigid,
                  Curry._2(Univ$ReactTemplate.LSet[/* remove */5], canon, flexible$1)
                ]
              ];
      } else {
        var canon$1 = Curry._1(Univ$ReactTemplate.LSet[/* choose */22], nonalgs);
        return /* tuple */[
                canon$1,
                /* tuple */[
                  $$global,
                  rigid,
                  Curry._2(Univ$ReactTemplate.LSet[/* remove */5], canon$1, flexible$1)
                ]
              ];
      }
    } else {
      var canon$2 = Curry._1(Univ$ReactTemplate.LSet[/* choose */22], rigid);
      return /* tuple */[
              canon$2,
              /* tuple */[
                $$global,
                Curry._2(Univ$ReactTemplate.LSet[/* remove */5], canon$2, rigid),
                flexible$1
              ]
            ];
    }
  } else {
    var canon$3 = Curry._1(Univ$ReactTemplate.LSet[/* choose */22], $$global);
    return /* tuple */[
            canon$3,
            /* tuple */[
              Curry._2(Univ$ReactTemplate.LSet[/* remove */5], canon$3, $$global),
              rigid,
              flexible$1
            ]
          ];
  }
}

function subst_univs_fn_constr(f, c) {
  var changed = [/* false */0];
  var partial_arg = Univ$ReactTemplate.Instance[/* subst_fn */10];
  var fi = function (param) {
    return partial_arg((function (param) {
                  return level_subst_of(f, param);
                }), param);
  };
  var aux = function (t) {
    var match = Constr$ReactTemplate.kind(t);
    switch (match.tag | 0) {
      case 4 : 
          var match$1 = match[0];
          if (match$1.tag) {
            var u = match$1[0];
            var u$prime = Univ$ReactTemplate.subst_univs_universe(f, u);
            if (u$prime === u) {
              return t;
            } else {
              changed[0] = /* true */1;
              return Constr$ReactTemplate.mkSort(Sorts$ReactTemplate.sort_of_univ(u$prime));
            }
          } else {
            return Constr$ReactTemplate.map(aux, t);
          }
          break;
      case 10 : 
          var match$2 = match[0];
          var u$1 = match$2[1];
          var u$prime$1 = Curry._1(fi, u$1);
          if (u$prime$1 === u$1) {
            return t;
          } else {
            changed[0] = /* true */1;
            return Constr$ReactTemplate.mkConstU(/* tuple */[
                        match$2[0],
                        u$prime$1
                      ]);
          }
      case 11 : 
          var match$3 = match[0];
          var u$2 = match$3[1];
          var u$prime$2 = Curry._1(fi, u$2);
          if (u$prime$2 === u$2) {
            return t;
          } else {
            changed[0] = /* true */1;
            return Constr$ReactTemplate.mkIndU(/* tuple */[
                        match$3[0],
                        u$prime$2
                      ]);
          }
      case 12 : 
          var match$4 = match[0];
          var u$3 = match$4[1];
          var u$prime$3 = Curry._1(fi, u$3);
          if (u$prime$3 === u$3) {
            return t;
          } else {
            changed[0] = /* true */1;
            return Constr$ReactTemplate.mkConstructU(/* tuple */[
                        match$4[0],
                        u$prime$3
                      ]);
          }
      default:
        return Constr$ReactTemplate.map(aux, t);
    }
  };
  var c$prime = aux(c);
  if (changed[0]) {
    return c$prime;
  } else {
    return c;
  }
}

function subst_univs_constr(subst, c) {
  if (Curry._1(Univ$ReactTemplate.is_empty_subst, subst)) {
    return c;
  } else {
    var f = function (param) {
      return Univ$ReactTemplate.make_subst(subst, param);
    };
    return subst_univs_fn_constr(f, c);
  }
}

var subst_univs_constr$1;

if (Flags$ReactTemplate.profile) {
  var subst_univs_constr_key = CProfile$ReactTemplate.declare_profile("subst_univs_constr");
  subst_univs_constr$1 = CProfile$ReactTemplate.profile2(subst_univs_constr_key, subst_univs_constr);
} else {
  subst_univs_constr$1 = subst_univs_constr;
}

function subst_univs_fn_puniverses(lsubst, cu) {
  var u = cu[1];
  var u$prime = Univ$ReactTemplate.Instance[/* subst_fn */10](lsubst, u);
  if (u$prime === u) {
    return cu;
  } else {
    return /* tuple */[
            cu[0],
            u$prime
          ];
  }
}

function nf_evars_and_universes_opt_subst(f, subst) {
  var subst$1 = function (l) {
    var match = Curry._2(Univ$ReactTemplate.LMap[/* find */21], l, subst);
    if (match) {
      return match[0];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var lsubst = function (param) {
    return level_subst_of(subst$1, param);
  };
  var aux = function (_c) {
    while(true) {
      var c = _c;
      var match = Constr$ReactTemplate.kind(c);
      switch (match.tag | 0) {
        case 3 : 
            var match$1 = match[0];
            var args = Util$ReactTemplate.$$Array[/* map */12](aux, match$1[1]);
            var match$2;
            try {
              match$2 = Curry._1(f, /* tuple */[
                    match$1[0],
                    args
                  ]);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                match$2 = /* None */0;
              } else {
                throw exn;
              }
            }
            if (match$2) {
              _c = match$2[0];
              continue ;
              
            } else {
              return c;
            }
            break;
        case 4 : 
            var match$3 = match[0];
            if (match$3.tag) {
              var u = match$3[0];
              var u$prime = Univ$ReactTemplate.subst_univs_universe(subst$1, u);
              if (u$prime === u) {
                return c;
              } else {
                return Constr$ReactTemplate.mkSort(Sorts$ReactTemplate.sort_of_univ(u$prime));
              }
            } else {
              return Constr$ReactTemplate.map(aux, c);
            }
            break;
        case 10 : 
            var pu = match[0];
            var pu$prime = subst_univs_fn_puniverses(lsubst, pu);
            if (pu$prime === pu) {
              return c;
            } else {
              return Constr$ReactTemplate.mkConstU(pu$prime);
            }
        case 11 : 
            var pu$1 = match[0];
            var pu$prime$1 = subst_univs_fn_puniverses(lsubst, pu$1);
            if (pu$prime$1 === pu$1) {
              return c;
            } else {
              return Constr$ReactTemplate.mkIndU(pu$prime$1);
            }
        case 12 : 
            var pu$2 = match[0];
            var pu$prime$2 = subst_univs_fn_puniverses(lsubst, pu$2);
            if (pu$prime$2 === pu$2) {
              return c;
            } else {
              return Constr$ReactTemplate.mkConstructU(pu$prime$2);
            }
        default:
          return Constr$ReactTemplate.map(aux, c);
      }
    };
  };
  return aux;
}

function fresh_universe_context_set_instance(ctx) {
  if (Univ$ReactTemplate.ContextSet[/* is_empty */1](ctx)) {
    return /* tuple */[
            Univ$ReactTemplate.LMap[/* empty */0],
            ctx
          ];
  } else {
    var univs = Univ$ReactTemplate.ContextSet[/* levels */16](ctx);
    var cst = Univ$ReactTemplate.ContextSet[/* constraints */15](ctx);
    var match = Curry._3(Univ$ReactTemplate.LSet[/* fold */13], (function (u, param) {
            var u$prime = new_univ_level(/* () */0);
            return /* tuple */[
                    Curry._2(Univ$ReactTemplate.LSet[/* add */3], u$prime, param[0]),
                    Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, u$prime, param[1])
                  ];
          }), univs, /* tuple */[
          Univ$ReactTemplate.LSet[/* empty */0],
          Univ$ReactTemplate.LMap[/* empty */0]
        ]);
    var subst = match[1];
    var cst$prime = Univ$ReactTemplate.subst_univs_level_constraints(subst, cst);
    return /* tuple */[
            subst,
            /* tuple */[
              match[0],
              cst$prime
            ]
          ];
  }
}

function normalize_univ_variable(find, update) {
  var aux = function (cur) {
    var b = Curry._1(find, cur);
    var b$prime = Univ$ReactTemplate.subst_univs_universe(aux, b);
    if (Univ$ReactTemplate.Universe[/* equal */1](b$prime, b)) {
      return b;
    } else {
      return Curry._2(update, cur, b$prime);
    }
  };
  return aux;
}

function normalize_univ_variable_opt_subst(ectx) {
  var find = function (l) {
    var match = Curry._2(Univ$ReactTemplate.LMap[/* find */21], l, ectx[0]);
    if (match) {
      return match[0];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var update = function (l, b) {
    var match = Univ$ReactTemplate.Universe[/* level */8](b);
    if (!(
        match ? 1 - Univ$ReactTemplate.Level[/* equal */6](l, match[0]) : /* true */1
      )) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "universes.ml",
              656,
              4
            ]
          ];
    }
    try {
      ectx[0] = Curry._3(Univ$ReactTemplate.LMap[/* add */3], l, /* Some */[b], ectx[0]);
      return b;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "universes.ml",
                657,
                68
              ]
            ];
      } else {
        throw exn;
      }
    }
  };
  return normalize_univ_variable(find, update);
}

function normalize_univ_variable_subst(subst) {
  var find = function (l) {
    return Curry._2(Univ$ReactTemplate.LMap[/* find */21], l, subst[0]);
  };
  var update = function (l, b) {
    var match = Univ$ReactTemplate.Universe[/* level */8](b);
    if (!(
        match ? 1 - Univ$ReactTemplate.Level[/* equal */6](l, match[0]) : /* true */1
      )) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "universes.ml",
              663,
              4
            ]
          ];
    }
    try {
      subst[0] = Curry._3(Univ$ReactTemplate.LMap[/* set */25], l, b, subst[0]);
      return b;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "universes.ml",
                664,
                63
              ]
            ];
      } else {
        throw exn;
      }
    }
  };
  return normalize_univ_variable(find, update);
}

function normalize_universe_opt_subst(subst) {
  var partial_arg = normalize_univ_variable_opt_subst(subst);
  return (function (param) {
      return Univ$ReactTemplate.subst_univs_universe(partial_arg, param);
    });
}

function normalize_universe_subst(subst) {
  var partial_arg = normalize_univ_variable_subst(subst);
  return (function (param) {
      return Univ$ReactTemplate.subst_univs_universe(partial_arg, param);
    });
}

function normalize_opt_subst(ctx) {
  var ectx = [ctx];
  var normalize = normalize_univ_variable_opt_subst(ectx);
  Curry._2(Univ$ReactTemplate.LMap[/* iter */9], (function (u, v) {
          if (Option$ReactTemplate.is_empty(v)) {
            return /* () */0;
          } else {
            try {
              Curry._1(normalize, u);
              return /* () */0;
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "universes.ml",
                        681,
                        53
                      ]
                    ];
              } else {
                throw exn;
              }
            }
          }
        }), ctx);
  return ectx[0];
}

function make_opt_subst(s, x) {
  var match = Curry._2(Univ$ReactTemplate.LMap[/* find */21], x, s);
  if (match) {
    return match[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function subst_opt_univs_constr(s) {
  return (function (param) {
      return subst_univs_fn_constr((function (param) {
                    return make_opt_subst(s, param);
                  }), param);
    });
}

function normalize_univ_variables(ctx) {
  var ctx$1 = normalize_opt_subst(ctx);
  var match = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (u, v, param) {
          var subst = param[2];
          var def = param[1];
          var undef = param[0];
          if (v) {
            return /* tuple */[
                    undef,
                    Curry._2(Univ$ReactTemplate.LSet[/* add */3], u, def),
                    Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, v[0], subst)
                  ];
          } else {
            return /* tuple */[
                    Curry._2(Univ$ReactTemplate.LSet[/* add */3], u, undef),
                    def,
                    subst
                  ];
          }
        }), ctx$1, /* tuple */[
        Univ$ReactTemplate.LSet[/* empty */0],
        Univ$ReactTemplate.LSet[/* empty */0],
        Univ$ReactTemplate.LMap[/* empty */0]
      ]);
  return /* tuple */[
          ctx$1,
          match[0],
          match[1],
          match[2]
        ];
}

function pr_universe_body(param) {
  if (param) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" := "), Univ$ReactTemplate.Universe[/* pr */4](param[0]));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

var partial_arg = Univ$ReactTemplate.LMap[/* pr */39];

function pr_universe_opt_subst(param) {
  return partial_arg(pr_universe_body, param);
}

function compare_constraint_type(d, d$prime) {
  switch (d) {
    case 0 : 
        switch (d$prime) {
          case 0 : 
              return 0;
          case 1 : 
          case 2 : 
              return 1;
          
        }
        break;
    case 1 : 
        switch (d$prime) {
          case 0 : 
              return -1;
          case 1 : 
              return 0;
          case 2 : 
              return 1;
          
        }
        break;
    case 2 : 
        if (d$prime >= 2) {
          return 0;
        } else {
          return -1;
        }
    
  }
}

function merge(_, a, b) {
  if (a) {
    if (b && compare_constraint_type(a[0], b[0]) < 0) {
      return b;
    } else {
      return a;
    }
  } else if (b) {
    return b;
  } else {
    return /* None */0;
  }
}

var lower_union = Curry._1(Univ$ReactTemplate.LMap[/* merge */6], merge);

function lower_add(l, c, m) {
  try {
    var c$prime = Curry._2(Univ$ReactTemplate.LMap[/* find */21], l, m);
    if (compare_constraint_type(c, c$prime) > 0) {
      return Curry._3(Univ$ReactTemplate.LMap[/* add */3], l, c, m);
    } else {
      return m;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Curry._3(Univ$ReactTemplate.LMap[/* add */3], l, c, m);
    } else {
      throw exn;
    }
  }
}

function lower_of_list(l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
                return Curry._3(Univ$ReactTemplate.LMap[/* add */3], param[1], param[0], acc);
              }), Univ$ReactTemplate.LMap[/* empty */0], l);
}

var Found = Caml_exceptions.create("Universes-ReactTemplate.Found");

function find_inst(insts, v) {
  try {
    Curry._2(Univ$ReactTemplate.LMap[/* iter */9], (function (k, param) {
            if (!param[1] && param[0] && Univ$ReactTemplate.Universe[/* equal */1](param[2], v)) {
              throw [
                    Found,
                    k,
                    param[3]
                  ];
            } else {
              return 0;
            }
          }), insts);
    throw Caml_builtin_exceptions.not_found;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Found) {
      return /* tuple */[
              exn[1],
              exn[2]
            ];
    } else {
      throw exn;
    }
  }
}

function compute_lbound(left) {
  var sup = function (l, lbound) {
    if (lbound) {
      return /* Some */[Univ$ReactTemplate.Universe[/* sup */11](l, lbound[0])];
    } else {
      return /* Some */[l];
    }
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (lbound, param) {
                var l = param[1];
                var d = param[0];
                if (d === /* Le */1) {
                  return sup(l, lbound);
                } else {
                  if (d !== /* Lt */0) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "universes.ml",
                            763,
                            2
                          ]
                        ];
                  }
                  if (Univ$ReactTemplate.Universe[/* level */8](l) !== /* None */0) {
                    return sup(Univ$ReactTemplate.Universe[/* super */10](l), lbound);
                  } else {
                    return /* None */0;
                  }
                }
              }), /* None */0, left);
}

function instantiate_with_lbound(u, lbound, lower, alg, enforce, param) {
  var cstrs = param[4];
  var insts = param[3];
  var algs = param[2];
  var us = param[1];
  var ctx = param[0];
  if (enforce) {
    var inst = Univ$ReactTemplate.Universe[/* make */3](u);
    var cstrs$prime = Univ$ReactTemplate.enforce_leq(lbound, inst, cstrs);
    return /* tuple */[
            /* tuple */[
              ctx,
              us,
              Curry._2(Univ$ReactTemplate.LSet[/* remove */5], u, algs),
              Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, /* tuple */[
                    enforce,
                    alg,
                    lbound,
                    lower
                  ], insts),
              cstrs$prime
            ],
            /* tuple */[
              enforce,
              alg,
              inst,
              lower
            ]
          ];
  } else {
    return /* tuple */[
            /* tuple */[
              Curry._2(Univ$ReactTemplate.LSet[/* remove */5], u, ctx),
              Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, /* Some */[lbound], us),
              algs,
              Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, /* tuple */[
                    enforce,
                    alg,
                    lbound,
                    lower
                  ], insts),
              cstrs
            ],
            /* tuple */[
              enforce,
              alg,
              lbound,
              lower
            ]
          ];
  }
}

function remove_alg(l, param) {
  return /* tuple */[
          param[0],
          param[1],
          Curry._2(Univ$ReactTemplate.LSet[/* remove */5], l, param[2]),
          param[3],
          param[4]
        ];
}

function remove_lower(u, lower) {
  var levels = Univ$ReactTemplate.Universe[/* levels */9](u);
  return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], (function (l, acc) {
                return Curry._2(Univ$ReactTemplate.LMap[/* remove */5], l, acc);
              }), levels, lower);
}

function minimize_univ_variables(ctx, us, algs, left, right, cstrs) {
  var match = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (r, lower, acc) {
          var lbounds = acc[1];
          if (Curry._2(Univ$ReactTemplate.LMap[/* mem */2], r, us) || !Curry._2(Univ$ReactTemplate.LSet[/* mem */2], r, ctx)) {
            return acc;
          } else {
            var match = compute_lbound(Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                        return /* tuple */[
                                param[0],
                                Univ$ReactTemplate.Universe[/* make */3](param[1])
                              ];
                      }), lower));
            var lbounds$prime = match ? Curry._3(Univ$ReactTemplate.LMap[/* add */3], r, /* tuple */[
                    /* true */1,
                    /* false */0,
                    match[0],
                    lower_of_list(lower)
                  ], lbounds) : lbounds;
            return /* tuple */[
                    Curry._2(Univ$ReactTemplate.LMap[/* remove */5], r, acc[0]),
                    lbounds$prime
                  ];
          }
        }), left, /* tuple */[
        left,
        Univ$ReactTemplate.LMap[/* empty */0]
      ]);
  var left$1 = match[0];
  var aux = function (acc, u) {
    try {
      return /* tuple */[
              acc,
              Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, acc[3])
            ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var acc$1 = acc;
        var u$1 = u;
        var insts = acc$1[3];
        var algs = acc$1[2];
        var us = acc$1[1];
        var match;
        try {
          var l = Curry._2(Univ$ReactTemplate.LMap[/* find */21], u$1, left$1);
          var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                  var l = param$1[1];
                  var d = param$1[0];
                  var match = aux(param[0], l);
                  var match$1 = match[1];
                  var l$prime = match$1[0] ? Univ$ReactTemplate.Universe[/* make */3](l) : match$1[2];
                  return /* tuple */[
                          match[0],
                          /* :: */[
                            /* tuple */[
                              d,
                              l$prime
                            ],
                            param[1]
                          ],
                          lower_add(l, d, param[2]),
                          Curry._2(lower_union, match$1[3], param[3])
                        ];
                }), /* tuple */[
                acc$1,
                /* [] */0,
                Univ$ReactTemplate.LMap[/* empty */0],
                Univ$ReactTemplate.LMap[/* empty */0]
              ], l);
          var lower = match$1[3];
          var not_lower = function (param) {
            var d = param[0];
            return Curry._2(Univ$ReactTemplate.Universe[/* exists */15], (function (param) {
                          var d$1 = param[1] === 0 || d !== 1 ? d : /* Lt */0;
                          try {
                            var d$prime = Curry._2(Univ$ReactTemplate.LMap[/* find */21], param[0], lower);
                            return +(compare_constraint_type(d$1, d$prime) > 0);
                          }
                          catch (exn){
                            if (exn === Caml_builtin_exceptions.not_found) {
                              return /* true */1;
                            } else {
                              throw exn;
                            }
                          }
                        }), param[1]);
          };
          var left$2 = Curry._1(Util$ReactTemplate.List[/* uniquize */95], Curry._2(Util$ReactTemplate.List[/* filter */27], not_lower, match$1[1]));
          match = /* tuple */[
            match$1[0],
            left$2,
            Univ$ReactTemplate.LMap[/* union */36](match$1[2], lower)
          ];
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            match = /* tuple */[
              acc$1,
              /* [] */0,
              Univ$ReactTemplate.LMap[/* empty */0]
            ];
          } else {
            throw exn$1;
          }
        }
        var lower$1 = match[2];
        var acc$2 = match[0];
        var right$1;
        try {
          right$1 = /* Some */[Curry._2(Univ$ReactTemplate.LMap[/* find */21], u$1, right)];
        }
        catch (exn$2){
          if (exn$2 === Caml_builtin_exceptions.not_found) {
            right$1 = /* None */0;
          } else {
            throw exn$2;
          }
        }
        var instantiate_lbound = function (lbound) {
          var alg = Curry._2(Univ$ReactTemplate.LSet[/* mem */2], u$1, algs);
          if (alg) {
            var lower$2 = remove_lower(lbound, lower$1);
            return instantiate_with_lbound(u$1, lbound, lower$2, /* true */1, /* false */0, acc$2);
          } else {
            var match = Univ$ReactTemplate.Universe[/* level */8](lbound);
            if (match) {
              var l = match[0];
              var lower$3 = Curry._2(Univ$ReactTemplate.LMap[/* remove */5], l, lower$1);
              if (Univ$ReactTemplate.Level[/* equal */6](l, u$1)) {
                return /* tuple */[
                        acc$2,
                        /* tuple */[
                          /* true */1,
                          /* false */0,
                          lbound,
                          lower$3
                        ]
                      ];
              } else {
                var acc$prime = remove_alg(l, acc$2);
                return instantiate_with_lbound(u$1, lbound, lower$3, /* false */0, /* false */0, acc$prime);
              }
            } else {
              try {
                var match$1 = find_inst(insts, lbound);
                var can = match$1[0];
                var lower$4 = Curry._2(Univ$ReactTemplate.LMap[/* remove */5], can, match$1[1]);
                return instantiate_with_lbound(u$1, Univ$ReactTemplate.Universe[/* make */3](can), lower$4, /* false */0, /* false */0, acc$2);
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return instantiate_with_lbound(u$1, lbound, lower$1, /* false */0, /* true */1, acc$2);
                } else {
                  throw exn;
                }
              }
            }
          }
        };
        var acc$prime = function (acc) {
          if (right$1) {
            var dangling = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                    return 1 - Curry._2(Univ$ReactTemplate.LMap[/* mem */2], param[1], us);
                  }), right$1[0]);
            if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], dangling)) {
              return acc;
            } else {
              var b = acc[1];
              var inst = b[2];
              var match = acc[0];
              var cstrs$prime = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (cstrs, param) {
                      var r = param[1];
                      var d = param[0];
                      if (d === /* Le */1) {
                        return Univ$ReactTemplate.enforce_leq(inst, Univ$ReactTemplate.Universe[/* make */3](r), cstrs);
                      } else {
                        try {
                          var lev = Option$ReactTemplate.get(Univ$ReactTemplate.Universe[/* level */8](inst));
                          return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                                      lev,
                                      d,
                                      r
                                    ], cstrs);
                        }
                        catch (exn){
                          if (exn === Option$ReactTemplate.IsNone) {
                            return Pervasives.failwith("");
                          } else {
                            throw exn;
                          }
                        }
                      }
                    }), match[4], dangling);
              return /* tuple */[
                      /* tuple */[
                        match[0],
                        match[1],
                        match[2],
                        match[3],
                        cstrs$prime
                      ],
                      b
                    ];
            }
          } else {
            return acc;
          }
        };
        if (Curry._2(Univ$ReactTemplate.LSet[/* mem */2], u$1, ctx)) {
          var lbound = compute_lbound(match[1]);
          if (lbound) {
            try {
              return acc$prime(instantiate_lbound(lbound[0]));
            }
            catch (raw_exn){
              var exn$3 = Js_exn.internalToOCamlException(raw_exn);
              if (exn$3[0] === Caml_builtin_exceptions.failure) {
                return acc$prime(/* tuple */[
                            acc$2,
                            /* tuple */[
                              /* true */1,
                              /* false */0,
                              Univ$ReactTemplate.Universe[/* make */3](u$1),
                              lower$1
                            ]
                          ]);
              } else {
                throw exn$3;
              }
            }
          } else {
            return acc$prime(/* tuple */[
                        acc$2,
                        /* tuple */[
                          /* true */1,
                          /* false */0,
                          Univ$ReactTemplate.Universe[/* make */3](u$1),
                          lower$1
                        ]
                      ]);
          }
        } else {
          return acc$prime(/* tuple */[
                      acc$2,
                      /* tuple */[
                        /* true */1,
                        /* false */0,
                        Univ$ReactTemplate.Universe[/* make */3](u$1),
                        lower$1
                      ]
                    ]);
        }
      } else {
        throw exn;
      }
    }
  };
  return Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (u, v, acc) {
                if (v) {
                  return /* tuple */[
                          Curry._2(Univ$ReactTemplate.LSet[/* remove */5], u, acc[0]),
                          acc[1],
                          Curry._2(Univ$ReactTemplate.LSet[/* remove */5], u, acc[2]),
                          acc[3],
                          acc[4]
                        ];
                } else {
                  return aux(acc, u)[0];
                }
              }), us, /* tuple */[
              ctx,
              us,
              algs,
              match[1],
              cstrs
            ]);
}

function normalize_context_set(g, ctx, us, algs, weak) {
  var ctx$1 = Univ$ReactTemplate.ContextSet[/* levels */16](ctx);
  var csts = Univ$ReactTemplate.ContextSet[/* constraints */15](ctx);
  var uf = Curry._1(LevelUnionFind[/* create */0], /* () */0);
  var match = Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], (function (cstr, param) {
          var noneqs = param[1];
          var smallles = param[0];
          var r = cstr[2];
          var l = cstr[0];
          if (cstr[1] === /* Le */1) {
            if (Univ$ReactTemplate.Level[/* is_small */2](l)) {
              if (set_minimization[0] && Curry._2(Univ$ReactTemplate.LSet[/* mem */2], r, ctx$1)) {
                return /* tuple */[
                        Curry._2(Univ$ReactTemplate.Constraint[/* add */3], cstr, smallles),
                        noneqs
                      ];
              } else {
                return /* tuple */[
                        smallles,
                        noneqs
                      ];
              }
            } else if (Univ$ReactTemplate.Level[/* is_small */2](r)) {
              if (Univ$ReactTemplate.Level[/* is_prop */3](r)) {
                throw [
                      Univ$ReactTemplate.UniverseInconsistency,
                      /* tuple */[
                        /* Le */1,
                        Univ$ReactTemplate.Universe[/* make */3](l),
                        Univ$ReactTemplate.Universe[/* make */3](r),
                        /* None */0
                      ]
                    ];
              } else {
                return /* tuple */[
                        smallles,
                        Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                              l,
                              /* Eq */2,
                              r
                            ], noneqs)
                      ];
              }
            } else {
              return /* tuple */[
                      smallles,
                      Curry._2(Univ$ReactTemplate.Constraint[/* add */3], cstr, noneqs)
                    ];
            }
          } else {
            return /* tuple */[
                    smallles,
                    Curry._2(Univ$ReactTemplate.Constraint[/* add */3], cstr, noneqs)
                  ];
          }
        }), csts, /* tuple */[
        Univ$ReactTemplate.Constraint[/* empty */0],
        Univ$ReactTemplate.Constraint[/* empty */0]
      ]);
  var csts$1 = match[1];
  var g$1 = Curry._3(Univ$ReactTemplate.LSet[/* fold */13], (function (v, g) {
          return UGraph$ReactTemplate.add_universe(v, /* false */0, g);
        }), ctx$1, UGraph$ReactTemplate.initial_universes);
  var g$2 = Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], (function (param, g) {
          var r = param[2];
          var l = param[0];
          var g$1;
          if (Univ$ReactTemplate.Level[/* is_small */2](l) || Curry._2(Univ$ReactTemplate.LSet[/* mem */2], l, ctx$1)) {
            g$1 = g;
          } else {
            try {
              g$1 = UGraph$ReactTemplate.add_universe(l, /* false */0, g);
            }
            catch (exn){
              if (exn === UGraph$ReactTemplate.AlreadyDeclared) {
                g$1 = g;
              } else {
                throw exn;
              }
            }
          }
          if (Univ$ReactTemplate.Level[/* is_small */2](r) || Curry._2(Univ$ReactTemplate.LSet[/* mem */2], r, ctx$1)) {
            return g$1;
          } else {
            try {
              return UGraph$ReactTemplate.add_universe(r, /* false */0, g$1);
            }
            catch (exn$1){
              if (exn$1 === UGraph$ReactTemplate.AlreadyDeclared) {
                return g$1;
              } else {
                throw exn$1;
              }
            }
          }
        }), csts$1, g$1);
  var g$3 = Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], UGraph$ReactTemplate.enforce_constraint, csts$1, g$2);
  var csts$2 = UGraph$ReactTemplate.constraints_of_universes(g$3);
  var noneqs = Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], (function (cstr, noneqs) {
          var r = cstr[2];
          var d = cstr[1];
          var l = cstr[0];
          if (d === /* Eq */2) {
            Curry._3(LevelUnionFind[/* union */3], l, r, uf);
            return noneqs;
          } else if (d === /* Le */1 && Univ$ReactTemplate.Level[/* is_small */2](l) || Univ$ReactTemplate.Level[/* is_prop */3](l) && d === /* Lt */0 && Univ$ReactTemplate.Level[/* is_set */4](r)) {
            return noneqs;
          } else {
            return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], cstr, noneqs);
          }
        }), csts$2, Univ$ReactTemplate.Constraint[/* empty */0]);
  var noneqs$1 = Curry._2(Univ$ReactTemplate.Constraint[/* union */6], noneqs, match[0]);
  var partition = Curry._1(LevelUnionFind[/* partition */5], uf);
  var flex = function (x) {
    return Curry._2(Univ$ReactTemplate.LMap[/* mem */2], x, us);
  };
  var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, s) {
          var ctx = param[0];
          var match = choose_canonical(ctx, flex, algs, s);
          var match$1 = match[1];
          var flexible = match$1[2];
          var canon = match[0];
          var cstrs = Curry._3(Univ$ReactTemplate.LSet[/* fold */13], (function (g, cst) {
                  return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                              canon,
                              /* Eq */2,
                              g
                            ], cst);
                }), match$1[0], param[2]);
          var cstrs$1 = Curry._3(Univ$ReactTemplate.LSet[/* fold */13], (function (g, cst) {
                  return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                              canon,
                              /* Eq */2,
                              g
                            ], cst);
                }), match$1[1], cstrs);
          var canonu = /* Some */[Univ$ReactTemplate.Universe[/* make */3](canon)];
          var us = Curry._3(Univ$ReactTemplate.LSet[/* fold */13], (function (f) {
                  return Curry._2(Univ$ReactTemplate.LMap[/* add */3], f, canonu);
                }), flexible, param[1]);
          return /* tuple */[
                  Curry._2(Univ$ReactTemplate.LSet[/* diff */8], ctx, flexible),
                  us,
                  cstrs$1
                ];
        }), /* tuple */[
        ctx$1,
        us,
        Univ$ReactTemplate.Constraint[/* empty */0]
      ], partition);
  var match$2 = Curry._3(UPairSet[/* fold */13], (function (param, acc) {
          var g = acc[2];
          var us = acc[1];
          var ctx = acc[0];
          var us$1 = [us];
          var partial_arg = normalize_univ_variable_opt_subst(us$1);
          var norm = function (param) {
            return level_subst_of(partial_arg, param);
          };
          var u = Curry._1(norm, param[0]);
          var v = Curry._1(norm, param[1]);
          var set_to = function (a, b) {
            return /* tuple */[
                    Curry._2(Univ$ReactTemplate.LSet[/* remove */5], a, ctx),
                    Curry._3(Univ$ReactTemplate.LMap[/* add */3], a, /* Some */[Univ$ReactTemplate.Universe[/* make */3](b)], us),
                    UGraph$ReactTemplate.enforce_constraint(/* tuple */[
                          a,
                          /* Eq */2,
                          b
                        ], g)
                  ];
          };
          if (UGraph$ReactTemplate.check_constraint(g, /* tuple */[
                  u,
                  /* Le */1,
                  v
                ]) || UGraph$ReactTemplate.check_constraint(g, /* tuple */[
                  v,
                  /* Le */1,
                  u
                ])) {
            return acc;
          } else if (Curry._2(Univ$ReactTemplate.LMap[/* mem */2], u, us)) {
            return set_to(u, v);
          } else if (Curry._2(Univ$ReactTemplate.LMap[/* mem */2], v, us)) {
            return set_to(v, u);
          } else {
            return acc;
          }
        }), weak, /* tuple */[
        match$1[0],
        match$1[1],
        g
      ]);
  var us$1 = match$2[1];
  var us$2 = [us$1];
  var partial_arg = normalize_univ_variable_opt_subst(us$2);
  var norm = function (param) {
    return level_subst_of(partial_arg, param);
  };
  var noneqs$2 = Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], (function (param, noneqs) {
          var d = param[1];
          var u = Curry._1(norm, param[0]);
          var v = Curry._1(norm, param[2]);
          if (d !== /* Lt */0 && Univ$ReactTemplate.Level[/* equal */6](u, v)) {
            return noneqs;
          } else {
            return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                        u,
                        d,
                        v
                      ], noneqs);
          }
        }), noneqs$1, Univ$ReactTemplate.Constraint[/* empty */0]);
  var match$3 = Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], (function (cstr, param) {
          var ucstrsl = param[1];
          var noneq = param[0];
          var r = cstr[2];
          var d = cstr[1];
          var l = cstr[0];
          var lus = Curry._2(Univ$ReactTemplate.LMap[/* mem */2], l, us$1);
          var rus = Curry._2(Univ$ReactTemplate.LMap[/* mem */2], r, us$1);
          var ucstrsl$prime = lus ? add_list_map(l, /* tuple */[
                  d,
                  r
                ], ucstrsl) : ucstrsl;
          var ucstrsr$prime = add_list_map(r, /* tuple */[
                d,
                l
              ], param[2]);
          var noneqs = lus || rus ? noneq : Curry._2(Univ$ReactTemplate.Constraint[/* add */3], cstr, noneq);
          return /* tuple */[
                  noneqs,
                  ucstrsl$prime,
                  ucstrsr$prime
                ];
        }), noneqs$2, /* tuple */[
        Univ$ReactTemplate.Constraint[/* empty */0],
        Univ$ReactTemplate.LMap[/* empty */0],
        Univ$ReactTemplate.LMap[/* empty */0]
      ]);
  var match$4 = minimize_univ_variables(match$2[0], us$1, algs, match$3[2], match$3[1], match$3[0]);
  var us$3 = normalize_opt_subst(match$4[1]);
  return /* tuple */[
          /* tuple */[
            us$3,
            match$4[2]
          ],
          /* tuple */[
            match$4[0],
            Curry._2(Univ$ReactTemplate.Constraint[/* union */6], match$4[4], match$1[2])
          ]
        ];
}

function is_trivial_leq(param) {
  var d = param[1];
  if (Univ$ReactTemplate.Level[/* is_prop */3](param[0])) {
    if (d === /* Le */1) {
      return /* true */1;
    } else if (d) {
      return /* false */0;
    } else {
      return Univ$ReactTemplate.Level[/* is_set */4](param[2]);
    }
  } else {
    return /* false */0;
  }
}

function translate_cstr(cstr) {
  var r = cstr[2];
  var d = cstr[1];
  if (Univ$ReactTemplate.Level[/* equal */6](Univ$ReactTemplate.Level[/* prop */1], cstr[0]) && d === /* Lt */0 && !Univ$ReactTemplate.Level[/* equal */6](Univ$ReactTemplate.Level[/* set */0], r)) {
    return /* tuple */[
            Univ$ReactTemplate.Level[/* set */0],
            d,
            r
          ];
  } else {
    return cstr;
  }
}

function refresh_constraints(univs, param) {
  var match = Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], (function (c, acc) {
          var c$1 = translate_cstr(c);
          if (is_trivial_leq(c$1)) {
            return acc;
          } else {
            return /* tuple */[
                    Curry._2(Univ$ReactTemplate.Constraint[/* add */3], c$1, acc[0]),
                    UGraph$ReactTemplate.enforce_constraint(c$1, acc[1])
                  ];
          }
        }), param[1], /* tuple */[
        Univ$ReactTemplate.Constraint[/* empty */0],
        univs
      ]);
  return /* tuple */[
          /* tuple */[
            param[0],
            match[0]
          ],
          match[1]
        ];
}

function is_direct_sort_constraint(s, v) {
  if (s) {
    return Univ$ReactTemplate.univ_level_mem(s[0], v);
  } else {
    return /* false */0;
  }
}

function solve_constraints_system(levels, level_bounds, _) {
  var levels$1 = Util$ReactTemplate.$$Array[/* mapi */14]((function (i, o) {
          if (o) {
            var u = o[0];
            var match = Univ$ReactTemplate.Universe[/* level */8](u);
            if (match) {
              return /* Some */[match[0]];
            } else {
              Caml_array.caml_array_set(level_bounds, i, Univ$ReactTemplate.Universe[/* sup */11](Caml_array.caml_array_get(level_bounds, i), u));
              return /* None */0;
            }
          } else {
            return /* None */0;
          }
        }), levels);
  var v = Util$ReactTemplate.$$Array[/* copy */6](level_bounds);
  var nind = v.length;
  var clos = Util$ReactTemplate.$$Array[/* map */12]((function () {
          return Int$ReactTemplate.$$Set[/* empty */0];
        }), levels$1);
  for(var i = 0 ,i_finish = nind - 1 | 0; i <= i_finish; ++i){
    for(var j = 0 ,j_finish = nind - 1 | 0; j <= j_finish; ++j){
      if (i !== j && is_direct_sort_constraint(Caml_array.caml_array_get(levels$1, j), Caml_array.caml_array_get(v, i))) {
        Caml_array.caml_array_set(clos, i, Curry._2(Int$ReactTemplate.$$Set[/* add */3], j, Caml_array.caml_array_get(clos, i)));
      }
      
    }
  }
  var closure = function (_param) {
    while(true) {
      var $$continue = [/* false */0];
      Util$ReactTemplate.$$Array[/* iteri */13]((function($$continue){
          return function (i, deps) {
            var deps$prime = Curry._3(Int$ReactTemplate.$$Set[/* fold */13], (function (j, acc) {
                    return Curry._2(Int$ReactTemplate.$$Set[/* union */6], acc, Caml_array.caml_array_get(clos, j));
                  }), deps, deps);
            if (Curry._2(Int$ReactTemplate.$$Set[/* equal */10], deps, deps$prime)) {
              return /* () */0;
            } else {
              Caml_array.caml_array_set(clos, i, deps$prime);
              $$continue[0] = /* true */1;
              return /* () */0;
            }
          }
          }($$continue)), clos);
      if ($$continue[0]) {
        _param = /* () */0;
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  };
  closure(/* () */0);
  for(var i$1 = 0 ,i_finish$1 = nind - 1 | 0; i$1 <= i_finish$1; ++i$1){
    for(var j$1 = 0 ,j_finish$1 = nind - 1 | 0; j$1 <= j_finish$1; ++j$1){
      if (i$1 !== j$1 && Curry._2(Int$ReactTemplate.$$Set[/* mem */2], j$1, Caml_array.caml_array_get(clos, i$1))) {
        Caml_array.caml_array_set(v, i$1, Univ$ReactTemplate.Universe[/* sup */11](Caml_array.caml_array_get(v, i$1), Caml_array.caml_array_get(level_bounds, j$1)));
      }
      
    }
  }
  return v;
}

var set_remote_new_univ_id = match[1];

var Constraints_001 = S[1];

var Constraints_002 = S[2];

var Constraints_005 = S[5];

var Constraints_006 = S[6];

var Constraints_007 = S[7];

var Constraints_008 = S[8];

var Constraints_009 = S[9];

var Constraints_011 = S[11];

var Constraints_012 = S[12];

var Constraints_014 = S[14];

var Constraints_015 = S[15];

var Constraints_016 = S[16];

var Constraints_017 = S[17];

var Constraints_018 = S[18];

var Constraints_019 = S[19];

var Constraints_020 = S[20];

var Constraints_021 = S[21];

var Constraints_022 = S[22];

var Constraints_023 = S[23];

var Constraints_024 = S[24];

var Constraints_025 = S[25];

var Constraints = [
  empty,
  Constraints_001,
  Constraints_002,
  add$1,
  singleton,
  Constraints_005,
  Constraints_006,
  Constraints_007,
  Constraints_008,
  Constraints_009,
  equal$1,
  Constraints_011,
  Constraints_012,
  fold,
  Constraints_014,
  Constraints_015,
  Constraints_016,
  Constraints_017,
  Constraints_018,
  Constraints_019,
  Constraints_020,
  Constraints_021,
  Constraints_022,
  Constraints_023,
  Constraints_024,
  Constraints_025,
  is_trivial,
  pr
];

var UF = LevelUnionFind;

var constr_of_reference = constr_of_global;

exports.UPairSet = UPairSet;
exports.set_minimization = set_minimization;
exports.is_set_minimization = is_set_minimization;
exports.pr_with_global_universes = pr_with_global_universes;
exports.reference_of_level = reference_of_level;
exports.add_global_universe = add_global_universe;
exports.is_polymorphic = is_polymorphic;
exports.empty_binders = empty_binders;
exports.register_universe_binders = register_universe_binders;
exports.universe_binders_of_global = universe_binders_of_global;
exports.universe_binders_with_opt_names = universe_binders_with_opt_names;
exports.set_remote_new_univ_id = set_remote_new_univ_id;
exports.new_univ_id = new_univ_id;
exports.new_univ_level = new_univ_level;
exports.new_univ = new_univ;
exports.new_Type = new_Type;
exports.new_Type_sort = new_Type_sort;
exports.new_global_univ = new_global_univ;
exports.new_sort_in_family = new_sort_in_family;
exports.Constraints = Constraints;
exports.subst_univs_universe_constraints = subst_univs_universe_constraints;
exports.enforce_eq_instances_univs = enforce_eq_instances_univs;
exports.to_constraints = to_constraints;
exports.eq_constr_univs_infer_with = eq_constr_univs_infer_with;
exports.fresh_instance_from_context = fresh_instance_from_context;
exports.fresh_instance_from = fresh_instance_from;
exports.fresh_sort_in_family = fresh_sort_in_family;
exports.fresh_constant_instance = fresh_constant_instance$1;
exports.fresh_inductive_instance = fresh_inductive_instance$1;
exports.fresh_constructor_instance = fresh_constructor_instance$1;
exports.fresh_global_instance = fresh_global_instance;
exports.fresh_global_or_constr_instance = fresh_global_or_constr_instance;
exports.fresh_universe_context_set_instance = fresh_universe_context_set_instance;
exports.global_of_constr = global_of_constr;
exports.constr_of_global_univ = constr_of_global_univ;
exports.extend_context = extend_context;
exports.UF = UF;
exports.level_subst_of = level_subst_of;
exports.subst_univs_constraints = subst_univs_constraints;
exports.subst_univs_constr = subst_univs_constr$1;
exports.make_opt_subst = make_opt_subst;
exports.subst_opt_univs_constr = subst_opt_univs_constr;
exports.normalize_context_set = normalize_context_set;
exports.normalize_univ_variables = normalize_univ_variables;
exports.normalize_univ_variable = normalize_univ_variable;
exports.normalize_univ_variable_opt_subst = normalize_univ_variable_opt_subst;
exports.normalize_univ_variable_subst = normalize_univ_variable_subst;
exports.normalize_universe_opt_subst = normalize_universe_opt_subst;
exports.normalize_universe_subst = normalize_universe_subst;
exports.constr_of_global = constr_of_global;
exports.constr_of_reference = constr_of_reference;
exports.type_of_global = type_of_global;
exports.nf_evars_and_universes_opt_subst = nf_evars_and_universes_opt_subst;
exports.refresh_constraints = refresh_constraints;
exports.pr_universe_opt_subst = pr_universe_opt_subst;
exports.solve_constraints_system = solve_constraints_system;
/* UPairs Not a pure module */
