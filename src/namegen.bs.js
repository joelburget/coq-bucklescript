// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Unicode$ReactTemplate = require("./unicode.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");

var default_prop_ident = Names$ReactTemplate.Id[/* of_string */5]("H");

var default_small_ident = Names$ReactTemplate.Id[/* of_string */5]("H");

var default_type_ident = Names$ReactTemplate.Id[/* of_string */5]("X");

var default_non_dependent_string = "H";

var default_non_dependent_ident = Names$ReactTemplate.Id[/* of_string */5](default_non_dependent_string);

var default_dependent_ident = Names$ReactTemplate.Id[/* of_string */5]("x");

function is_imported_modpath(param) {
  switch (param.tag | 0) {
    case 0 : 
        var dp = param[0];
        var _param = Lib$ReactTemplate.current_mp(/* () */0);
        while(true) {
          var param$1 = _param;
          switch (param$1.tag | 0) {
            case 0 : 
                return 1 - Curry._2(Names$ReactTemplate.DirPath[/* equal */0], param$1[0], dp);
            case 1 : 
                return /* false */0;
            case 2 : 
                _param = param$1[0];
                continue ;
                
          }
        };
    case 1 : 
    case 2 : 
        return /* false */0;
    
  }
}

function is_imported_ref(param) {
  var exit = 0;
  var kn;
  switch (param.tag | 0) {
    case 0 : 
        return /* false */0;
    case 1 : 
        var match = Names$ReactTemplate.Constant[/* repr3 */6](param[0]);
        return is_imported_modpath(match[0]);
    case 2 : 
        kn = param[0][0];
        exit = 1;
        break;
    case 3 : 
        kn = param[0][0][0];
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    var match$1 = Names$ReactTemplate.MutInd[/* repr3 */6](kn);
    return is_imported_modpath(match$1[0]);
  }
  
}

function is_global(id) {
  try {
    var ref = Nametab$ReactTemplate.locate(Libnames$ReactTemplate.qualid_of_ident(id));
    return 1 - is_imported_ref(ref);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_constructor(id) {
  try {
    var match = Nametab$ReactTemplate.locate(Libnames$ReactTemplate.qualid_of_ident(id));
    if (match.tag === 3) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_section_variable(id) {
  try {
    Global$ReactTemplate.lookup_named(id);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function global_of_constr(param) {
  switch (param.tag | 0) {
    case 1 : 
        return /* VarRef */Block.__(0, [param[0]]);
    case 10 : 
        return /* ConstRef */Block.__(1, [param[0][0]]);
    case 11 : 
        return /* IndRef */Block.__(2, [param[0][0]]);
    case 12 : 
        return /* ConstructRef */Block.__(3, [param[0][0]]);
    default:
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "namegen.ml",
              97,
              7
            ]
          ];
  }
}

function head_name(sigma, c) {
  var _c = c;
  while(true) {
    var c$1 = _c;
    var c$2 = EConstr$ReactTemplate.kind(sigma, c$1);
    var exit = 0;
    var i;
    var lna;
    switch (c$2.tag | 0) {
      case 6 : 
      case 7 : 
          _c = c$2[2];
          continue ;
          case 8 : 
          _c = c$2[3];
          continue ;
          case 5 : 
      case 9 : 
          _c = c$2[0];
          continue ;
          case 1 : 
      case 10 : 
      case 11 : 
      case 12 : 
          return /* Some */[Nametab$ReactTemplate.basename_of_global(global_of_constr(c$2))];
      case 14 : 
          var match = c$2[0];
          i = match[0][1];
          lna = match[1][0];
          exit = 1;
          break;
      case 15 : 
          var match$1 = c$2[0];
          i = match$1[0];
          lna = match$1[1][0];
          exit = 1;
          break;
      case 16 : 
          return /* Some */[Names$ReactTemplate.Label[/* to_id */6](Names$ReactTemplate.Constant[/* label */8](Names$ReactTemplate.Projection[/* constant */2](c$2[0])))];
      default:
        return /* None */0;
    }
    if (exit === 1) {
      var match$2 = Caml_array.caml_array_get(lna, i);
      var tmp;
      if (match$2) {
        tmp = match$2[0];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "namegen.ml",
                108,
                47
              ]
            ];
      }
      return /* Some */[tmp];
    }
    
  };
}

function lowercase_first_char(id) {
  var s = Names$ReactTemplate.Id[/* to_string */7](id);
  var match = Unicode$ReactTemplate.split_at_first_letter(s);
  if (match) {
    var match$1 = match[0];
    var s$prime = match$1[1];
    if (s$prime.length) {
      return match$1[0] + Unicode$ReactTemplate.lowercase_first_char(s$prime);
    } else {
      return "x";
    }
  } else {
    return Unicode$ReactTemplate.lowercase_first_char(s);
  }
}

function sort_hdchar(param) {
  if (param.tag) {
    return "T";
  } else {
    return "P";
  }
}

function hdchar(env, sigma, c) {
  var hdrec = function (_k, _c) {
    while(true) {
      var c = _c;
      var k = _k;
      var match = EConstr$ReactTemplate.kind(sigma, c);
      var exit = 0;
      var i;
      var lna;
      switch (match.tag | 0) {
        case 0 : 
            var n = match[0];
            if (n <= k) {
              return "p";
            } else {
              try {
                var match$1 = EConstr$ReactTemplate.lookup_rel(n - k | 0, env);
                var exit$1 = 0;
                var t;
                if (match$1.tag) {
                  var match$2 = match$1[0];
                  if (match$2) {
                    return lowercase_first_char(match$2[0]);
                  } else {
                    t = match$1[2];
                    exit$1 = 2;
                  }
                } else {
                  var match$3 = match$1[0];
                  if (match$3) {
                    return lowercase_first_char(match$3[0]);
                  } else {
                    t = match$1[1];
                    exit$1 = 2;
                  }
                }
                if (exit$1 === 2) {
                  return hdrec(0, EConstr$ReactTemplate.Vars[/* lift */0](n - k | 0, t));
                }
                
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return "y";
                } else {
                  throw exn;
                }
              }
            }
            break;
        case 1 : 
            return lowercase_first_char(match[0]);
        case 4 : 
            return sort_hdchar(EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]));
        case 6 : 
        case 7 : 
            _c = match[2];
            _k = k + 1 | 0;
            continue ;
            case 8 : 
            _c = match[3];
            _k = k + 1 | 0;
            continue ;
            case 5 : 
        case 9 : 
            _c = match[0];
            continue ;
            case 10 : 
            return lowercase_first_char(Names$ReactTemplate.Label[/* to_id */6](Names$ReactTemplate.Constant[/* label */8](match[0][0])));
        case 11 : 
            try {
              return lowercase_first_char(Nametab$ReactTemplate.basename_of_global(/* IndRef */Block.__(2, [match[0][0]])));
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                if (Flags$ReactTemplate.in_debugger[0]) {
                  return "zz";
                } else {
                  throw exn$1;
                }
              } else {
                throw exn$1;
              }
            }
            break;
        case 12 : 
            try {
              return lowercase_first_char(Nametab$ReactTemplate.basename_of_global(/* ConstructRef */Block.__(3, [match[0][0]])));
            }
            catch (exn$2){
              if (exn$2 === Caml_builtin_exceptions.not_found) {
                if (Flags$ReactTemplate.in_debugger[0]) {
                  return "zz";
                } else {
                  throw exn$2;
                }
              } else {
                throw exn$2;
              }
            }
            break;
        case 14 : 
            var match$4 = match[0];
            i = match$4[0][1];
            lna = match$4[1][0];
            exit = 1;
            break;
        case 15 : 
            var match$5 = match[0];
            i = match$5[0];
            lna = match$5[1][0];
            exit = 1;
            break;
        case 16 : 
            return lowercase_first_char(Names$ReactTemplate.Label[/* to_id */6](Names$ReactTemplate.Constant[/* label */8](Names$ReactTemplate.Projection[/* constant */2](match[0]))));
        default:
          return "y";
      }
      if (exit === 1) {
        var match$6 = Caml_array.caml_array_get(lna, i);
        var tmp;
        if (match$6) {
          tmp = match$6[0];
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "namegen.ml",
                  149,
                  50
                ]
              ];
        }
        return lowercase_first_char(tmp);
      }
      
    };
  };
  return hdrec(0, c);
}

function id_of_name_using_hdchar(env, sigma, a, param) {
  if (param) {
    return param[0];
  } else {
    return Names$ReactTemplate.Id[/* of_string */5](hdchar(env, sigma, a));
  }
}

function named_hd(env, sigma, a, x) {
  if (x) {
    return x;
  } else {
    return /* Name */[Names$ReactTemplate.Id[/* of_string */5](hdchar(env, sigma, a))];
  }
}

function mkProd_name(env, sigma, param) {
  var a = param[1];
  return EConstr$ReactTemplate.mkProd(/* tuple */[
              named_hd(env, sigma, a, param[0]),
              a,
              param[2]
            ]);
}

function mkLambda_name(env, sigma, param) {
  var a = param[1];
  return EConstr$ReactTemplate.mkLambda(/* tuple */[
              named_hd(env, sigma, a, param[0]),
              a,
              param[2]
            ]);
}

function prod_create(env, sigma, param) {
  var a = param[0];
  return EConstr$ReactTemplate.mkProd(/* tuple */[
              named_hd(env, sigma, a, /* Anonymous */0),
              a,
              param[1]
            ]);
}

function lambda_create(env, sigma, param) {
  var a = param[0];
  return EConstr$ReactTemplate.mkLambda(/* tuple */[
              named_hd(env, sigma, a, /* Anonymous */0),
              a,
              param[1]
            ]);
}

function name_assumption(env, sigma, param) {
  if (param.tag) {
    var c = param[1];
    return /* LocalDef */Block.__(1, [
              named_hd(env, sigma, c, param[0]),
              c,
              param[2]
            ]);
  } else {
    var t = param[1];
    return /* LocalAssum */Block.__(0, [
              named_hd(env, sigma, t, param[0]),
              t
            ]);
  }
}

function name_context(env, sigma, hyps) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, d) {
                  var env = param[0];
                  var d$prime = name_assumption(env, sigma, d);
                  return /* tuple */[
                          EConstr$ReactTemplate.push_rel(d$prime, env),
                          /* :: */[
                            d$prime,
                            param[1]
                          ]
                        ];
                }), /* tuple */[
                env,
                /* [] */0
              ], Curry._1(Util$ReactTemplate.List[/* rev */4], hyps))[1];
}

function mkProd_or_LetIn_name(env, sigma, b, d) {
  return EConstr$ReactTemplate.mkProd_or_LetIn(name_assumption(env, sigma, d), b);
}

function mkLambda_or_LetIn_name(env, sigma, b, d) {
  return EConstr$ReactTemplate.mkLambda_or_LetIn(name_assumption(env, sigma, d), b);
}

function it_mkProd_or_LetIn_name(env, sigma, b, hyps) {
  return EConstr$ReactTemplate.it_mkProd_or_LetIn(b, name_context(env, sigma, hyps));
}

function it_mkLambda_or_LetIn_name(env, sigma, b, hyps) {
  return EConstr$ReactTemplate.it_mkLambda_or_LetIn(b, name_context(env, sigma, hyps));
}

var mangle_names = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"mangle auto-generated names",
      /* optkey : :: */[
        "Mangle",
        /* :: */[
          "Names",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return mangle_names[0];
        }),
      /* optwrite */(function (param) {
          mangle_names[0] = param;
          return /* () */0;
        })
    ]);

var mangle_names_prefix = [Names$ReactTemplate.Id[/* of_string */5]("_0")];

function set_mangle_names_mode(x) {
  mangle_names_prefix[0] = Nameops$ReactTemplate.forget_subscript(x);
  mangle_names[0] = /* true */1;
  return /* () */0;
}

Goptions$ReactTemplate.declare_string_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"mangled names prefix",
      /* optkey : :: */[
        "Mangle",
        /* :: */[
          "Names",
          /* :: */[
            "Prefix",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return Names$ReactTemplate.Id[/* to_string */7](mangle_names_prefix[0]);
        }),
      /* optwrite */(function (x) {
          var x$1;
          try {
            x$1 = Names$ReactTemplate.Id[/* of_string */5](x);
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === CErrors$ReactTemplate.UserError) {
              x$1 = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not a valid identifier: \"" + (x + "\".")));
            } else {
              throw exn;
            }
          }
          mangle_names_prefix[0] = Nameops$ReactTemplate.forget_subscript(x$1);
          return /* () */0;
        })
    ]);

function mangle_id(id) {
  if (mangle_names[0]) {
    return mangle_names_prefix[0];
  } else {
    return id;
  }
}

function next_ident_away_from(id, bad) {
  var id$1 = mangle_id(id);
  var _id = id$1;
  while(true) {
    var id$2 = _id;
    if (Curry._1(bad, id$2)) {
      _id = Nameops$ReactTemplate.increment_subscript(id$2);
      continue ;
      
    } else {
      return id$2;
    }
  };
}

function restart_subscript(id) {
  if (Nameops$ReactTemplate.has_subscript(id)) {
    return Nameops$ReactTemplate.forget_subscript(id);
  } else {
    return id;
  }
}

function visible_ids(sigma, param) {
  var nenv = param[0];
  var accu = [/* tuple */[
      Globnames$ReactTemplate.Refset_env[/* empty */0],
      Int$ReactTemplate.$$Set[/* empty */0],
      Names$ReactTemplate.Id[/* Set */9][/* empty */0]
    ]];
  var visible_ids$1 = function (n, c) {
    var c$1 = EConstr$ReactTemplate.kind(sigma, c);
    var exit = 0;
    switch (c$1.tag | 0) {
      case 0 : 
          var p = c$1[0];
          var match = accu[0];
          var ids = match[2];
          var vseen = match[1];
          if (p > n && !Curry._2(Int$ReactTemplate.$$Set[/* mem */2], p, vseen)) {
            var vseen$1 = Curry._2(Int$ReactTemplate.$$Set[/* add */3], p, vseen);
            var name;
            try {
              name = /* Some */[Curry._2(Util$ReactTemplate.List[/* nth */3], nenv, (p - n | 0) - 1 | 0)];
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
                name = /* None */0;
              } else if (exn[0] === Caml_builtin_exceptions.failure) {
                name = /* None */0;
              } else {
                throw exn;
              }
            }
            var ids$1;
            if (name) {
              var match$1 = name[0];
              ids$1 = match$1 ? Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], match$1[0], ids) : ids;
            } else {
              ids$1 = ids;
            }
            accu[0] = /* tuple */[
              match[0],
              vseen$1,
              ids$1
            ];
            return /* () */0;
          } else {
            return 0;
          }
          break;
      case 1 : 
      case 10 : 
      case 11 : 
      case 12 : 
          exit = 1;
          break;
      default:
        return EConstr$ReactTemplate.iter_with_binders(sigma, (function (prim) {
                      return prim + 1 | 0;
                    }), visible_ids$1, n, c);
    }
    if (exit === 1) {
      var match$2 = accu[0];
      var ids$2 = match$2[2];
      var gseen = match$2[0];
      var g = global_of_constr(c$1);
      if (Curry._2(Globnames$ReactTemplate.Refset_env[/* mem */2], g, gseen)) {
        return 0;
      } else {
        try {
          var gseen$1 = Curry._2(Globnames$ReactTemplate.Refset_env[/* add */3], g, gseen);
          var $$short = Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], g);
          var match$3 = Libnames$ReactTemplate.repr_qualid($$short);
          var ids$3 = Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], match$3[0]) ? Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], match$3[1], ids$2) : ids$2;
          accu[0] = /* tuple */[
            gseen$1,
            match$2[1],
            ids$3
          ];
          return /* () */0;
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            if (Flags$ReactTemplate.in_debugger[0] || Flags$ReactTemplate.in_toplevel[0]) {
              return /* () */0;
            } else {
              throw exn$1;
            }
          } else {
            throw exn$1;
          }
        }
      }
    }
    
  };
  visible_ids$1(1, param[1]);
  return accu[0][2];
}

function next_ident_away_in_goal(id, avoid) {
  var id$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, avoid) ? restart_subscript(id) : id;
  var bad = function (id) {
    if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, avoid)) {
      return /* true */1;
    } else if (is_global(id)) {
      return 1 - is_section_variable(id);
    } else {
      return /* false */0;
    }
  };
  return next_ident_away_from(id$1, bad);
}

function next_name_away_in_goal(na, avoid) {
  var id = na ? na[0] : default_non_dependent_ident;
  return next_ident_away_in_goal(id, avoid);
}

function next_global_ident_away(id, avoid) {
  var id$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, avoid) ? restart_subscript(id) : id;
  var bad = function (id) {
    if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, avoid)) {
      return /* true */1;
    } else {
      return is_global(id);
    }
  };
  return next_ident_away_from(id$1, bad);
}

function next_ident_away(id, avoid) {
  var id$1 = mangle_id(id);
  if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id$1, avoid)) {
    return next_ident_away_from(restart_subscript(id$1), (function (id) {
                  return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, avoid);
                }));
  } else {
    return id$1;
  }
}

function next_name_away_with_default($$default, na, avoid) {
  var id = na ? na[0] : Names$ReactTemplate.Id[/* of_string */5]($$default);
  return next_ident_away(id, avoid);
}

var reserved_type_name = [(function () {
      return /* Anonymous */0;
    })];

function set_reserved_typed_name(f) {
  reserved_type_name[0] = f;
  return /* () */0;
}

function next_name_away_with_default_using_types($$default, na, avoid, t) {
  var id;
  if (na) {
    id = na[0];
  } else {
    var match = Curry._1(reserved_type_name[0], t);
    id = match ? match[0] : Names$ReactTemplate.Id[/* of_string */5]($$default);
  }
  return next_ident_away(id, avoid);
}

function next_name_away(param, param$1) {
  return next_name_away_with_default(default_non_dependent_string, param, param$1);
}

function make_all_name_different(env, sigma) {
  var avoid = [Environ$ReactTemplate.ids_of_named_context_val(Environ$ReactTemplate.named_context_val(env))];
  var sign = Environ$ReactTemplate.named_context_val(env);
  var rels = EConstr$ReactTemplate.rel_context(env);
  var env0 = Environ$ReactTemplate.reset_with_named_context(sign, env);
  return Context$ReactTemplate.Rel[/* fold_outside */10]((function (decl, newenv) {
                var na = named_hd(newenv, sigma, Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl), Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl));
                var id = next_name_away(na, avoid[0]);
                avoid[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid[0]);
                return EConstr$ReactTemplate.push_rel(Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], /* Name */[id], decl), newenv);
              }), rels, env0);
}

function next_name_for_display(sigma, flags) {
  if (typeof flags === "number") {
    return next_name_away_in_goal;
  } else if (flags.tag) {
    var env_t = flags[0];
    return (function (param, param$1) {
        var sigma$1 = sigma;
        var env_t$1 = env_t;
        var na = param;
        var avoid = param$1;
        var id = na ? na[0] : default_non_dependent_ident;
        var sigma$2 = sigma$1;
        var env_t$2 = env_t$1;
        var id$1 = id;
        var avoid$1 = avoid;
        var visible = visible_ids(sigma$2, env_t$2);
        var bad = function (id) {
          if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, avoid$1)) {
            return /* true */1;
          } else {
            return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, visible);
          }
        };
        return next_ident_away_from(id$1, bad);
      });
  } else {
    var env_t$1 = flags[0];
    return (function (param, param$1) {
        var sigma$1 = sigma;
        var env_t$2 = env_t$1;
        var na = param;
        var avoid = param$1;
        var id = na ? na[0] : default_dependent_ident;
        var visible = visible_ids(sigma$1, env_t$2);
        var bad = function (id) {
          if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, avoid) || is_constructor(id)) {
            return /* true */1;
          } else {
            return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, visible);
          }
        };
        return next_ident_away_from(id, bad);
      });
  }
}

function compute_displayed_name_in_gen_poly(noccurn_fun, sigma, flags, avoid, na, c) {
  var exit = 0;
  if (na) {
    exit = 1;
  } else if (Curry._3(noccurn_fun, sigma, 1, c)) {
    return /* tuple */[
            /* Anonymous */0,
            avoid
          ];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var fresh_id = Curry._2(next_name_for_display(sigma, flags), na, avoid);
    var idopt = Curry._3(noccurn_fun, sigma, 1, c) ? /* Anonymous */0 : /* Name */[fresh_id];
    return /* tuple */[
            idopt,
            Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], fresh_id, avoid)
          ];
  }
  
}

var partial_arg = EConstr$ReactTemplate.Vars[/* noccurn */12];

function compute_displayed_name_in(param, param$1, param$2, param$3, param$4) {
  return compute_displayed_name_in_gen_poly(partial_arg, param, param$1, param$2, param$3, param$4);
}

function compute_displayed_name_in_gen(f, sigma) {
  return (function (param, param$1, param$2) {
      return compute_displayed_name_in_gen_poly(f, sigma, /* RenamingForGoal */0, param, param$1, param$2);
    });
}

function compute_and_force_displayed_name_in(sigma, flags, avoid, na, c) {
  var exit = 0;
  if (na) {
    exit = 1;
  } else if (EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, c)) {
    return /* tuple */[
            /* Anonymous */0,
            avoid
          ];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var fresh_id = Curry._2(next_name_for_display(sigma, flags), na, avoid);
    return /* tuple */[
            /* Name */[fresh_id],
            Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], fresh_id, avoid)
          ];
  }
  
}

function compute_displayed_let_name_in(sigma, flags, avoid, na, _) {
  var fresh_id = Curry._2(next_name_for_display(sigma, flags), na, avoid);
  return /* tuple */[
          /* Name */[fresh_id],
          Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], fresh_id, avoid)
        ];
}

function rename_bound_vars_as_displayed(sigma, avoid, env, c) {
  var rename = function (avoid, env, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 5 : 
          return EConstr$ReactTemplate.mkCast(/* tuple */[
                      rename(avoid, env, match[0]),
                      match[1],
                      match[2]
                    ]);
      case 6 : 
          var c2 = match[2];
          var match$1 = compute_displayed_name_in(sigma, /* RenamingElsewhereFor */Block.__(1, [/* tuple */[
                    env,
                    c2
                  ]]), avoid, match[0], c2);
          var na$prime = match$1[0];
          return EConstr$ReactTemplate.mkProd(/* tuple */[
                      na$prime,
                      match[1],
                      rename(match$1[1], /* :: */[
                            na$prime,
                            env
                          ], c2)
                    ]);
      case 8 : 
          var c2$1 = match[3];
          var match$2 = compute_displayed_let_name_in(sigma, /* RenamingElsewhereFor */Block.__(1, [/* tuple */[
                    env,
                    c2$1
                  ]]), avoid, match[0], c2$1);
          var na$prime$1 = match$2[0];
          return EConstr$ReactTemplate.mkLetIn(/* tuple */[
                      na$prime$1,
                      match[1],
                      match[2],
                      rename(match$2[1], /* :: */[
                            na$prime$1,
                            env
                          ], c2$1)
                    ]);
      default:
        return c;
    }
  };
  return rename(avoid, env, c);
}

var prod_name = mkProd_name;

var lambda_name = mkLambda_name;

exports.default_prop_ident = default_prop_ident;
exports.default_small_ident = default_small_ident;
exports.default_type_ident = default_type_ident;
exports.default_non_dependent_ident = default_non_dependent_ident;
exports.default_dependent_ident = default_dependent_ident;
exports.lowercase_first_char = lowercase_first_char;
exports.sort_hdchar = sort_hdchar;
exports.hdchar = hdchar;
exports.id_of_name_using_hdchar = id_of_name_using_hdchar;
exports.named_hd = named_hd;
exports.head_name = head_name;
exports.mkProd_name = mkProd_name;
exports.mkLambda_name = mkLambda_name;
exports.prod_name = prod_name;
exports.lambda_name = lambda_name;
exports.prod_create = prod_create;
exports.lambda_create = lambda_create;
exports.name_assumption = name_assumption;
exports.name_context = name_context;
exports.mkProd_or_LetIn_name = mkProd_or_LetIn_name;
exports.mkLambda_or_LetIn_name = mkLambda_or_LetIn_name;
exports.it_mkProd_or_LetIn_name = it_mkProd_or_LetIn_name;
exports.it_mkLambda_or_LetIn_name = it_mkLambda_or_LetIn_name;
exports.next_ident_away_from = next_ident_away_from;
exports.next_ident_away = next_ident_away;
exports.next_ident_away_in_goal = next_ident_away_in_goal;
exports.next_global_ident_away = next_global_ident_away;
exports.next_name_away = next_name_away;
exports.next_name_away_with_default = next_name_away_with_default;
exports.next_name_away_with_default_using_types = next_name_away_with_default_using_types;
exports.set_reserved_typed_name = set_reserved_typed_name;
exports.make_all_name_different = make_all_name_different;
exports.compute_displayed_name_in = compute_displayed_name_in;
exports.compute_and_force_displayed_name_in = compute_and_force_displayed_name_in;
exports.compute_displayed_let_name_in = compute_displayed_let_name_in;
exports.rename_bound_vars_as_displayed = rename_bound_vars_as_displayed;
exports.compute_displayed_name_in_gen = compute_displayed_name_in_gen;
exports.set_mangle_names_mode = set_mangle_names_mode;
/* default_prop_ident Not a pure module */
