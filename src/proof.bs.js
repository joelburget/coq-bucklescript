// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Goal$ReactTemplate = require("./goal.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Proofview$ReactTemplate = require("./proofview.bs.js");
var Constrintern$ReactTemplate = require("./constrintern.bs.js");
var Evar_refiner$ReactTemplate = require("./evar_refiner.bs.js");

var next_kind = [0];

function new_focus_kind() {
  var r = next_kind[0];
  next_kind[0] = next_kind[0] + 1 | 0;
  return r;
}

var CannotUnfocusThisWay = Caml_exceptions.create("Proof-ReactTemplate.CannotUnfocusThisWay");

var NoSuchGoals = Caml_exceptions.create("Proof-ReactTemplate.NoSuchGoals");

var FullyUnfocused = Caml_exceptions.create("Proof-ReactTemplate.FullyUnfocused");

CErrors$ReactTemplate.register_handler((function (param) {
        if (param === CannotUnfocusThisWay) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This proof is focused, but cannot be unfocused this way"));
        } else if (param[0] === NoSuchGoals) {
          var j = param[2];
          var i = param[1];
          if (i === j) {
            return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Focus"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such goal ("), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(").")));
          } else {
            return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Focus"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Not every goal in range ["), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.$$int(j)), Pp$ReactTemplate.str("] exist.")));
          }
        } else if (param === FullyUnfocused) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The proof is not focused"));
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

function check_cond_kind(c, k) {
  var kind_of_cond = function (param) {
    switch (param.tag | 0) {
      case 0 : 
      case 1 : 
          return param[1];
      case 2 : 
          return param[0];
      
    }
  };
  return +(kind_of_cond(c) === k);
}

function test_cond(c, k1, pw) {
  switch (c.tag | 0) {
    case 0 : 
        if (c[1] === k1) {
          return /* Strict */1;
        } else if (c[0] !== 0) {
          return /* Loose */0;
        } else {
          return /* Cannot */[/* NotThisWay */0];
        }
    case 1 : 
        if (c[1] === k1 && Proofview$ReactTemplate.finished(pw)) {
          return /* Strict */1;
        } else if (c[0] !== 0) {
          return /* Loose */0;
        } else {
          return /* Cannot */[/* NotThisWay */0];
        }
    case 2 : 
        if (c[0] === k1) {
          return /* Strict */1;
        } else {
          return /* Cannot */[/* AlreadyNoFocus */1];
        }
    
  }
}

function no_cond($staropt$star, k) {
  var loose_end = $staropt$star ? $staropt$star[0] : /* false */0;
  return /* CondNo */Block.__(0, [
            loose_end,
            k
          ]);
}

function done_cond($staropt$star, k) {
  var loose_end = $staropt$star ? $staropt$star[0] : /* false */0;
  return /* CondDone */Block.__(1, [
            loose_end,
            k
          ]);
}

function proof(p) {
  var match = Proofview$ReactTemplate.proofview(p[/* proofview */0]);
  var map_minus_one = function (f, param) {
    if (param) {
      var l = param[1];
      if (l) {
        return /* :: */[
                Curry._1(f, param[0]),
                map_minus_one(f, l)
              ];
      } else {
        return /* [] */0;
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "proof.ml",
              129,
              12
            ]
          ];
    }
  };
  var stack = map_minus_one((function (param) {
          return Proofview$ReactTemplate.focus_context(param[2]);
        }), p[/* focus_stack */2]);
  var shelf = p[/* shelf */3];
  var given_up = p[/* given_up */4];
  return /* tuple */[
          match[0],
          stack,
          shelf,
          given_up,
          match[1]
        ];
}

function map_structured_proof(pfts, process_goal) {
  var match = proof(pfts);
  var sigma = match[4];
  var fg = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(process_goal, sigma), match[0]);
  var map_zip = function (param) {
    var lg = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(process_goal, sigma), param[0]);
    var rg = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(process_goal, sigma), param[1]);
    return /* tuple */[
            lg,
            rg
          ];
  };
  var bg = Curry._2(Util$ReactTemplate.List[/* map */10], map_zip, match[1]);
  var shelf = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(process_goal, sigma), match[2]);
  var given_up = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(process_goal, sigma), match[3]);
  return /* record */[
          /* fg_goals */fg,
          /* bg_goals */bg,
          /* shelved_goals */shelf,
          /* given_up_goals */given_up
        ];
}

function unroll_focus(_pv, _param) {
  while(true) {
    var param = _param;
    var pv = _pv;
    if (param) {
      _param = param[1];
      _pv = Proofview$ReactTemplate.unfocus(param[0][2], pv);
      continue ;
      
    } else {
      return pv;
    }
  };
}

function is_done(p) {
  if (Proofview$ReactTemplate.finished(p[/* proofview */0])) {
    return Proofview$ReactTemplate.finished(unroll_focus(p[/* proofview */0], p[/* focus_stack */2]));
  } else {
    return /* false */0;
  }
}

function is_complete(p) {
  if (is_done(p) && !Proofview$ReactTemplate.V82[/* has_unresolved_evar */2](p[/* proofview */0]) && CList$ReactTemplate.is_empty(p[/* shelf */3])) {
    return CList$ReactTemplate.is_empty(p[/* given_up */4]);
  } else {
    return /* false */0;
  }
}

function partial_proof(p) {
  return Proofview$ReactTemplate.partial_proof(p[/* entry */1], p[/* proofview */0]);
}

function push_focus(cond, inf, context, pr) {
  var newrecord = pr.slice();
  newrecord[/* focus_stack */2] = /* :: */[
    /* tuple */[
      cond,
      inf,
      context
    ],
    pr[/* focus_stack */2]
  ];
  return newrecord;
}

function cond_of_focus(pr) {
  var match = pr[/* focus_stack */2];
  if (match) {
    return match[0][0];
  } else {
    throw FullyUnfocused;
  }
}

function pop_focus(pr) {
  var match = pr[/* focus_stack */2];
  if (match) {
    var newrecord = pr.slice();
    return /* tuple */[
            (newrecord[/* focus_stack */2] = match[1], newrecord),
            match[0]
          ];
  } else {
    throw FullyUnfocused;
  }
}

function _focus(cond, inf, i, j, pr) {
  var match = Proofview$ReactTemplate.focus(i, j, pr[/* proofview */0]);
  var pr$1 = push_focus(cond, inf, match[1], pr);
  var newrecord = pr$1.slice();
  newrecord[/* proofview */0] = match[0];
  return newrecord;
}

function _unfocus(pr) {
  var match = pop_focus(pr);
  var pr$1 = match[0];
  var newrecord = pr$1.slice();
  newrecord[/* proofview */0] = Proofview$ReactTemplate.unfocus(match[1][2], pr$1[/* proofview */0]);
  return newrecord;
}

function focus(cond, inf, i, pr) {
  try {
    return _focus(cond, inf, i, i, pr);
  }
  catch (exn){
    if (exn === CList$ReactTemplate.IndexOutOfRange) {
      throw [
            NoSuchGoals,
            i,
            i
          ];
    } else {
      throw exn;
    }
  }
}

function unfocus(kind, pr, _) {
  var cond = cond_of_focus(pr);
  var match = test_cond(cond, kind, pr[/* proofview */0]);
  if (typeof match === "number") {
    if (match !== 0) {
      return _unfocus(pr);
    } else {
      try {
        var pr$1 = _unfocus(pr);
        return unfocus(kind, pr$1, /* () */0);
      }
      catch (exn){
        if (exn === FullyUnfocused) {
          throw CannotUnfocusThisWay;
        } else {
          throw exn;
        }
      }
    }
  } else if (match[0] !== 0) {
    throw FullyUnfocused;
  } else {
    throw CannotUnfocusThisWay;
  }
}

var NoSuchFocus = Caml_exceptions.create("Proof-ReactTemplate.NoSuchFocus");

function get_at_focus(kind, pr) {
  var kind$1 = kind;
  var _stack = pr[/* focus_stack */2];
  while(true) {
    var stack = _stack;
    if (stack) {
      var match = stack[0];
      if (check_cond_kind(match[0], kind$1)) {
        return match[1];
      } else {
        _stack = stack[1];
        continue ;
        
      }
    } else {
      throw NoSuchFocus;
    }
  };
}

function is_last_focus(kind, pr) {
  var match = Curry._1(Util$ReactTemplate.List[/* hd */1], pr[/* focus_stack */2]);
  return check_cond_kind(match[0], kind);
}

function no_focused_goal(p) {
  return Proofview$ReactTemplate.finished(p[/* proofview */0]);
}

function maximal_unfocus(k, p) {
  if (Proofview$ReactTemplate.finished(p[/* proofview */0])) {
    try {
      return maximal_unfocus(k, unfocus(k, p, /* () */0));
    }
    catch (exn){
      if (exn === FullyUnfocused) {
        return p;
      } else if (exn === CannotUnfocusThisWay) {
        return p;
      } else {
        throw exn;
      }
    }
  } else {
    return p;
  }
}

var end_of_stack_kind = new_focus_kind(/* () */0);

var end_of_stack = /* CondEndStack */Block.__(2, [end_of_stack_kind]);

function unfocused(param) {
  return is_last_focus(end_of_stack_kind, param);
}

function start(sigma, goals) {
  var match = Proofview$ReactTemplate.init(sigma, goals);
  var proofview = match[1];
  var pr_001 = /* entry */match[0];
  var pr_005 = /* initial_euctx */Evd$ReactTemplate.evar_universe_context(Proofview$ReactTemplate.proofview(proofview)[1]);
  var pr = /* record */[
    /* proofview */proofview,
    pr_001,
    /* focus_stack : [] */0,
    /* shelf : [] */0,
    /* given_up : [] */0,
    pr_005
  ];
  return _focus(end_of_stack, /* () */0, 1, Curry._1(Util$ReactTemplate.List[/* length */0], goals), pr);
}

function dependent_start(goals) {
  var match = Proofview$ReactTemplate.dependent_init(goals);
  var proofview = match[1];
  var entry = match[0];
  var pr_005 = /* initial_euctx */Evd$ReactTemplate.evar_universe_context(Proofview$ReactTemplate.proofview(proofview)[1]);
  var pr = /* record */[
    /* proofview */proofview,
    /* entry */entry,
    /* focus_stack : [] */0,
    /* shelf : [] */0,
    /* given_up : [] */0,
    pr_005
  ];
  var number_of_goals = Curry._1(Util$ReactTemplate.List[/* length */0], Proofview$ReactTemplate.initial_goals(entry));
  return _focus(end_of_stack, /* () */0, 1, number_of_goals, pr);
}

var UnfinishedProof = Caml_exceptions.create("Proof-ReactTemplate.UnfinishedProof");

var HasShelvedGoals = Caml_exceptions.create("Proof-ReactTemplate.HasShelvedGoals");

var HasGivenUpGoals = Caml_exceptions.create("Proof-ReactTemplate.HasGivenUpGoals");

var HasUnresolvedEvar = Caml_exceptions.create("Proof-ReactTemplate.HasUnresolvedEvar");

CErrors$ReactTemplate.register_handler((function (param) {
        if (param === UnfinishedProof) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Some goals have not been solved."));
        } else if (param === HasShelvedGoals) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Some goals have been left on the shelf."));
        } else if (param === HasGivenUpGoals) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Some goals have been given up."));
        } else if (param === HasUnresolvedEvar) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Some existential variables are uninstantiated."));
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

function $$return(p) {
  if (is_done(p)) {
    if (CList$ReactTemplate.is_empty(p[/* shelf */3])) {
      if (CList$ReactTemplate.is_empty(p[/* given_up */4])) {
        if (Proofview$ReactTemplate.V82[/* has_unresolved_evar */2](p[/* proofview */0])) {
          throw HasUnresolvedEvar;
        } else {
          var p$1 = unfocus(end_of_stack_kind, p, /* () */0);
          return Proofview$ReactTemplate.$$return(p$1[/* proofview */0]);
        }
      } else {
        throw HasGivenUpGoals;
      }
    } else {
      throw HasShelvedGoals;
    }
  } else {
    throw UnfinishedProof;
  }
}

function initial_goals(p) {
  return Proofview$ReactTemplate.initial_goals(p[/* entry */1]);
}

function initial_euctx(p) {
  return p[/* initial_euctx */5];
}

function compact(p) {
  var match = Proofview$ReactTemplate.compact(p[/* entry */1], p[/* proofview */0]);
  return /* record */[
          /* proofview */match[1],
          /* entry */match[0],
          /* focus_stack */p[/* focus_stack */2],
          /* shelf */p[/* shelf */3],
          /* given_up */p[/* given_up */4],
          /* initial_euctx */p[/* initial_euctx */5]
        ];
}

function run_tactic(env, tac, pr) {
  var sp = pr[/* proofview */0];
  var undef = function (sigma, l) {
    return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (g) {
                  return Evd$ReactTemplate.is_undefined(sigma, g);
                }), l);
  };
  var tac$1 = Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], tac, (function () {
          return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                        var retrieved = Evd$ReactTemplate.filter_future_goals((function (param) {
                                return Evd$ReactTemplate.is_undefined(sigma, param);
                              }), Evd$ReactTemplate.save_future_goals(sigma));
                        var match = Evd$ReactTemplate.extract_given_up_future_goals(retrieved);
                        var retrieved$1 = match[0];
                        if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], match[1])) {
                          CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Evars generated outside of proof engine (e.g. V82, clear, ...) are not supposed to be explicitly given up."));
                        }
                        var sigma$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], Proofview$ReactTemplate.Unsafe[/* mark_as_goal */12], sigma, retrieved$1);
                        return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](sigma$1), (function () {
                                      return Curry._1(Proofview$ReactTemplate.tclUNIT, retrieved$1);
                                    }));
                      }));
        }));
  var match = Proofview$ReactTemplate.apply(env, tac$1, sp);
  var match$1 = match[2];
  var proofview = match[1];
  var sigma = Proofview$ReactTemplate.$$return(proofview);
  var to_shelve = undef(sigma, match$1[1]);
  var shelf = Util$ReactTemplate.$at(undef(sigma, pr[/* shelf */3]), Util$ReactTemplate.$at(match[0], to_shelve));
  var proofview$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], Proofview$ReactTemplate.Unsafe[/* mark_as_unresolvable */13], proofview, to_shelve);
  var given_up = Util$ReactTemplate.$at(pr[/* given_up */4], match$1[2]);
  var proofview$2 = Proofview$ReactTemplate.Unsafe[/* reset_future_goals */11](proofview$1);
  return /* tuple */[
          /* record */[
            /* proofview */proofview$2,
            /* entry */pr[/* entry */1],
            /* focus_stack */pr[/* focus_stack */2],
            /* shelf */shelf,
            /* given_up */given_up,
            /* initial_euctx */pr[/* initial_euctx */5]
          ],
          /* tuple */[
            match$1[0],
            match[3]
          ]
        ];
}

function in_proof(p, k) {
  return Curry._1(k, Proofview$ReactTemplate.$$return(p[/* proofview */0]));
}

function unshelve(p) {
  return /* record */[
          /* proofview */Proofview$ReactTemplate.unshelve(p[/* shelf */3], p[/* proofview */0]),
          /* entry */p[/* entry */1],
          /* focus_stack */p[/* focus_stack */2],
          /* shelf : [] */0,
          /* given_up */p[/* given_up */4],
          /* initial_euctx */p[/* initial_euctx */5]
        ];
}

function pr_proof(p) {
  var p$1 = map_structured_proof(p, (function (_, g) {
          return g;
        }));
  var aux = function (_acc, _param) {
    while(true) {
      var param = _param;
      var acc = _acc;
      if (param) {
        var match = param[0];
        _param = param[1];
        _acc = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Goal$ReactTemplate.pr_goal, match[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("{")), acc), Pp$ReactTemplate.str("}")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Goal$ReactTemplate.pr_goal, match[1]));
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Pp$ReactTemplate.str("focus structure: ")), aux(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Goal$ReactTemplate.pr_goal, p$1[/* fg_goals */0]), p$1[/* bg_goals */1])), Pp$ReactTemplate.str(";")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("shelved: ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Goal$ReactTemplate.pr_goal, p$1[/* shelved_goals */2])), Pp$ReactTemplate.str(";")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("given up: ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Goal$ReactTemplate.pr_goal, p$1[/* given_up_goals */3])), Pp$ReactTemplate.str("]"));
}

function subgoals(p) {
  var match = Proofview$ReactTemplate.proofview(p[/* proofview */0]);
  return /* record */[
          /* it */match[0],
          /* sigma */match[1]
        ];
}

function background_subgoals(p) {
  var match = Proofview$ReactTemplate.proofview(unroll_focus(p[/* proofview */0], p[/* focus_stack */2]));
  return /* record */[
          /* it */match[0],
          /* sigma */match[1]
        ];
}

function top_goal(p) {
  var match = Proofview$ReactTemplate.V82[/* top_goals */5](p[/* entry */1], p[/* proofview */0]);
  return /* record */[
          /* it */Curry._1(Util$ReactTemplate.List[/* hd */1], match[/* it */0]),
          /* sigma */match[/* sigma */1]
        ];
}

function top_evars(p) {
  return Proofview$ReactTemplate.V82[/* top_evars */6](p[/* entry */1]);
}

function grab_evars(p) {
  if (is_done(p)) {
    var newrecord = p.slice();
    newrecord[/* proofview */0] = Proofview$ReactTemplate.V82[/* grab */3](p[/* proofview */0]);
    return newrecord;
  } else {
    throw UnfinishedProof;
  }
}

function instantiate_evar(n, com, pr) {
  var tac = Curry._2(Proofview$ReactTemplate.tclBIND, Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
          var evl = Evarutil$ReactTemplate.non_instantiated(sigma);
          var evl$1 = Curry._1(Evar$ReactTemplate.$$Map[/* bindings */16], evl);
          var match = n <= 0 ? CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("incorrect existential variable index")) : (
              CList$ReactTemplate.length(evl$1) < n ? CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("not so many uninstantiated existential variables")) : CList$ReactTemplate.nth(evl$1, n - 1 | 0)
            );
          var evi = match[1];
          var env = Evd$ReactTemplate.evar_filtered_env(evi);
          var rawc = Constrintern$ReactTemplate.intern_constr(env, sigma, com);
          return Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](Evar_refiner$ReactTemplate.w_refine(/* tuple */[
                          match[0],
                          evi
                        ], /* tuple */[
                          Glob_ops$ReactTemplate.empty_lvar,
                          rawc
                        ], sigma));
        }));
  var match = Proofview$ReactTemplate.apply(Global$ReactTemplate.env(/* () */0), tac, pr[/* proofview */0]);
  var proofview = match[1];
  var shelf = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (g) {
          return Evd$ReactTemplate.is_undefined(Proofview$ReactTemplate.$$return(proofview), g);
        }), pr[/* shelf */3]);
  return /* record */[
          /* proofview */proofview,
          /* entry */pr[/* entry */1],
          /* focus_stack */pr[/* focus_stack */2],
          /* shelf */shelf,
          /* given_up */pr[/* given_up */4],
          /* initial_euctx */pr[/* initial_euctx */5]
        ];
}

var V82 = /* module */[
  /* subgoals */subgoals,
  /* background_subgoals */background_subgoals,
  /* top_goal */top_goal,
  /* top_evars */top_evars,
  /* grab_evars */grab_evars,
  /* instantiate_evar */instantiate_evar
];

exports.proof = proof;
exports.map_structured_proof = map_structured_proof;
exports.start = start;
exports.dependent_start = dependent_start;
exports.initial_goals = initial_goals;
exports.initial_euctx = initial_euctx;
exports.is_done = is_done;
exports.is_complete = is_complete;
exports.partial_proof = partial_proof;
exports.compact = compact;
exports.UnfinishedProof = UnfinishedProof;
exports.HasShelvedGoals = HasShelvedGoals;
exports.HasGivenUpGoals = HasGivenUpGoals;
exports.HasUnresolvedEvar = HasUnresolvedEvar;
exports.$$return = $$return;
exports.new_focus_kind = new_focus_kind;
exports.no_cond = no_cond;
exports.done_cond = done_cond;
exports.focus = focus;
exports.FullyUnfocused = FullyUnfocused;
exports.CannotUnfocusThisWay = CannotUnfocusThisWay;
exports.NoSuchGoals = NoSuchGoals;
exports.unfocus = unfocus;
exports.unfocused = unfocused;
exports.NoSuchFocus = NoSuchFocus;
exports.get_at_focus = get_at_focus;
exports.is_last_focus = is_last_focus;
exports.no_focused_goal = no_focused_goal;
exports.run_tactic = run_tactic;
exports.maximal_unfocus = maximal_unfocus;
exports.in_proof = in_proof;
exports.unshelve = unshelve;
exports.pr_proof = pr_proof;
exports.V82 = V82;
/*  Not a pure module */
