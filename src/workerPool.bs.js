// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Marshal = require("bs-platform/lib/js/marshal.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Mutex$ReactTemplate = require("./mutex.bs.js");
var Thread$ReactTemplate = require("../shims/thread.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var CThread$ReactTemplate = require("../shims/cThread.bs.js");

function Make(funarg) {
  var master_handshake = function (worker_id, ic, oc) {
    try {
      Marshal.to_channel(oc, 17, /* [] */0);
      Pervasives.flush(oc);
      var n = Curry._1(CThread$ReactTemplate.thread_friendly_input_value, ic);
      if (n !== 17) {
        Curry._1(Printf.eprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "Handshake with ",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String_literal */Block.__(11, [
                              " failed: protocol mismatch\n",
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "Handshake with %s failed: protocol mismatch\n"
                ]), worker_id);
        return Pervasives.exit(1);
      } else {
        return 0;
      }
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (CErrors$ReactTemplate.noncritical(e)) {
        Curry._2(Printf.eprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "Handshake with ",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String_literal */Block.__(11, [
                              " failed: ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* "\n" */10,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "Handshake with %s failed: %s\n"
                ]), worker_id, Printexc.to_string(e));
        return Pervasives.exit(1);
      } else {
        throw e;
      }
    }
  };
  var worker_handshake = function (slave_ic, slave_oc) {
    try {
      var v = Curry._1(CThread$ReactTemplate.thread_friendly_input_value, slave_ic);
      if (v !== 17) {
        console.error("Handshake failed: protocol mismatch\n");
        Pervasives.exit(1);
      }
      Marshal.to_channel(slave_oc, v, /* [] */0);
      return Pervasives.flush(slave_oc);
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (CErrors$ReactTemplate.noncritical(e)) {
        console.error("Handshake failed: " + Printexc.to_string(e));
        return Pervasives.exit(1);
      } else {
        throw e;
      }
    }
  };
  var locking = function (param, f) {
    var lock = param[/* lock */0];
    try {
      Mutex$ReactTemplate.lock(lock);
      var x = Curry._1(f, param[/* pool */1]);
      Mutex$ReactTemplate.unlock(lock);
      return x;
    }
    catch (e){
      Mutex$ReactTemplate.unlock(lock);
      throw e;
    }
  };
  var create_worker = function (extra, pool, id) {
    var cancel = [/* false */0];
    var worker = Curry._1(funarg[/* spawn */0], id);
    var name = worker[0];
    master_handshake(name, worker[2], worker[3]);
    var exit = function () {
      cancel[0] = /* true */1;
      cleanup(pool);
      return Thread$ReactTemplate.exit(/* () */0);
    };
    var cancelled = function () {
      return cancel[0];
    };
    var cpanel = /* record */[
      /* exit */exit,
      /* cancelled */cancelled,
      /* extra */extra
    ];
    var manager = Thread$ReactTemplate.create(Curry._1(funarg[/* manager */1], cpanel), worker);
    return /* record */[
            /* name */name,
            /* cancel */cancel,
            /* manager */manager,
            /* process */worker[1]
          ];
  };
  var cleanup = function (x) {
    return locking(x, (function (param) {
                  var extra_arg = param[/* extra_arg */2];
                  var count = param[/* count */1];
                  var workers = param[/* workers */0];
                  workers[0] = List.map((function (w) {
                          if (w[/* cancel */1][0]) {
                            var n = count[0];
                            count[0] = count[0] + 1 | 0;
                            return create_worker(extra_arg, x, n);
                          } else {
                            return w;
                          }
                        }), workers[0]);
                  return /* () */0;
                }));
  };
  var n_workers = function (x) {
    return locking(x, (function (param) {
                  return List.length(param[/* workers */0][0]);
                }));
  };
  var is_empty = function (x) {
    return locking(x, (function (param) {
                  return +(param[/* workers */0][0] === /* [] */0);
                }));
  };
  var create = function (extra_arg, size) {
    var x_000 = /* lock */Mutex$ReactTemplate.create(/* () */0);
    var x_001 = /* pool : record */[
      /* workers */[/* [] */0],
      /* count */[size],
      /* extra_arg */extra_arg
    ];
    var x = /* record */[
      x_000,
      x_001
    ];
    locking(x, (function (param) {
            param[/* workers */0][0] = CList$ReactTemplate.init(size, (function (param) {
                    return create_worker(extra_arg, x, param);
                  }));
            return /* () */0;
          }));
    return x;
  };
  var cancel = function (n, x) {
    return locking(x, (function (param) {
                  return List.iter((function (param) {
                                if (n === param[/* name */0]) {
                                  param[/* cancel */1][0] = /* true */1;
                                  return /* () */0;
                                } else {
                                  return 0;
                                }
                              }), param[/* workers */0][0]);
                }));
  };
  var cancel_all = function (x) {
    return locking(x, (function (param) {
                  return List.iter((function (param) {
                                param[/* cancel */1][0] = /* true */1;
                                return /* () */0;
                              }), param[/* workers */0][0]);
                }));
  };
  var destroy = function (x) {
    return locking(x, (function (param) {
                  var workers = param[/* workers */0];
                  List.iter((function (param) {
                          param[/* cancel */1][0] = /* true */1;
                          return /* () */0;
                        }), workers[0]);
                  workers[0] = /* [] */0;
                  return /* () */0;
                }));
  };
  return [
          create,
          is_empty,
          n_workers,
          cancel,
          cancel_all,
          destroy,
          worker_handshake
        ];
}

exports.Make = Make;
/* CErrors-ReactTemplate Not a pure module */
