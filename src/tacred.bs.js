// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Cbv$ReactTemplate = require("./cbv.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Typing$ReactTemplate = require("./typing.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var CClosure$ReactTemplate = require("./cClosure.bs.js");
var CProfile$ReactTemplate = require("../shims/cProfile.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Locusops$ReactTemplate = require("./locusops.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Patternops$ReactTemplate = require("./patternops.bs.js");
var Type_errors$ReactTemplate = require("./type_errors.bs.js");
var Find_subterm$ReactTemplate = require("./find_subterm.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Constr_matching$ReactTemplate = require("./constr_matching.bs.js");

var ReductionTacticError = Caml_exceptions.create("Tacred-ReactTemplate.ReductionTacticError");

var Elimconst = Caml_exceptions.create("Tacred-ReactTemplate.Elimconst");

var Redelimination = Caml_exceptions.create("Tacred-ReactTemplate.Redelimination");

function error_not_evaluable(r) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["error_not_evaluable"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot coerce"), Pp$ReactTemplate.spc(/* () */0)), Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], r)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("to an evaluable reference.")));
}

function is_evaluable_const(env, cst) {
  if (Reductionops$ReactTemplate.is_transparent(env, /* ConstKey */Block.__(0, [cst]))) {
    if (Environ$ReactTemplate.evaluable_constant(cst, env)) {
      return /* true */1;
    } else {
      return Environ$ReactTemplate.is_projection(cst, env);
    }
  } else {
    return /* false */0;
  }
}

function is_evaluable_var(env, id) {
  if (Reductionops$ReactTemplate.is_transparent(env, /* VarKey */Block.__(1, [id]))) {
    return Environ$ReactTemplate.evaluable_named(id, env);
  } else {
    return /* false */0;
  }
}

function is_evaluable(env, param) {
  if (param.tag) {
    return is_evaluable_const(env, param[0]);
  } else {
    return is_evaluable_var(env, param[0]);
  }
}

function evaluable_of_global_reference(env, r) {
  switch (r.tag | 0) {
    case 0 : 
        var id = r[0];
        if (is_evaluable_var(env, id)) {
          return /* EvalVarRef */Block.__(0, [id]);
        } else {
          return error_not_evaluable(r);
        }
    case 1 : 
        var cst = r[0];
        if (is_evaluable_const(env, cst)) {
          return /* EvalConstRef */Block.__(1, [cst]);
        } else {
          return error_not_evaluable(r);
        }
    case 2 : 
    case 3 : 
        return error_not_evaluable(r);
    
  }
}

function global_of_evaluable_reference(param) {
  if (param.tag) {
    return /* ConstRef */Block.__(1, [param[0]]);
  } else {
    return /* VarRef */Block.__(0, [param[0]]);
  }
}

function evaluable_reference_eq(sigma, r1, r2) {
  switch (r1.tag | 0) {
    case 0 : 
        if (r2.tag) {
          return /* false */0;
        } else {
          return Names$ReactTemplate.Constant[/* equal */12](r1[0], r2[0]);
        }
        break;
    case 1 : 
        if (r2.tag === 1) {
          return Names$ReactTemplate.Id[/* equal */0](r1[0], r2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 2 : 
        if (r2.tag === 2) {
          return +(r1[0] === r2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 3 : 
        if (r2.tag === 3) {
          var match = r2[0];
          var match$1 = r1[0];
          if (Evar$ReactTemplate.equal(match$1[0], match[0])) {
            return Util$ReactTemplate.$$Array[/* equal */21]((function (param, param$1) {
                          return EConstr$ReactTemplate.eq_constr(sigma, param, param$1);
                        }), match$1[1], match[1]);
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
        break;
    
  }
}

function mkEvalRef(ref, u) {
  switch (ref.tag | 0) {
    case 0 : 
        return EConstr$ReactTemplate.mkConstU(/* tuple */[
                    ref[0],
                    u
                  ]);
    case 1 : 
        return EConstr$ReactTemplate.mkVar(ref[0]);
    case 2 : 
        return EConstr$ReactTemplate.mkRel(ref[0]);
    case 3 : 
        return EConstr$ReactTemplate.mkEvar(ref[0]);
    
  }
}

function isEvalRef(env, sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 1 : 
        return is_evaluable(env, /* EvalVarRef */Block.__(0, [match[0]]));
    case 0 : 
    case 3 : 
        return /* true */1;
    case 10 : 
        return is_evaluable(env, /* EvalConstRef */Block.__(1, [match[0][0]]));
    default:
      return /* false */0;
  }
}

function destEvalRefU(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 0 : 
        return /* tuple */[
                /* EvalRel */Block.__(2, [match[0]]),
                EConstr$ReactTemplate.EInstance[/* empty */2]
              ];
    case 1 : 
        return /* tuple */[
                /* EvalVar */Block.__(1, [match[0]]),
                EConstr$ReactTemplate.EInstance[/* empty */2]
              ];
    case 3 : 
        return /* tuple */[
                /* EvalEvar */Block.__(3, [match[0]]),
                EConstr$ReactTemplate.EInstance[/* empty */2]
              ];
    case 10 : 
        var match$1 = match[0];
        return /* tuple */[
                /* EvalConst */Block.__(0, [match$1[0]]),
                match$1[1]
              ];
    default:
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not an unfoldable reference."));
  }
}

function unsafe_reference_opt_value(env, sigma, $$eval) {
  switch ($$eval.tag | 0) {
    case 0 : 
        var match = Environ$ReactTemplate.lookup_constant($$eval[0], env)[/* const_body */1];
        switch (match.tag | 0) {
          case 1 : 
              return /* Some */[EConstr$ReactTemplate.of_constr(Mod_subst$ReactTemplate.force_constr(match[0]))];
          case 0 : 
          case 2 : 
              return /* None */0;
          
        }
        break;
    case 1 : 
        return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], EConstr$ReactTemplate.lookup_named($$eval[0], env));
    case 2 : 
        var n = $$eval[0];
        var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
        return Option$ReactTemplate.map((function (param) {
                      return partial_arg(n, param);
                    }), Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_value */1], EConstr$ReactTemplate.lookup_rel(n, env)));
    case 3 : 
        var c = EConstr$ReactTemplate.kind(sigma, EConstr$ReactTemplate.mkEvar($$eval[0]));
        if (c.tag === 3) {
          return /* None */0;
        } else {
          return /* Some */[EConstr$ReactTemplate.of_kind(c)];
        }
        break;
    
  }
}

function reference_opt_value(env, sigma, $$eval, u) {
  switch ($$eval.tag | 0) {
    case 0 : 
        var u$1 = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, u);
        return Option$ReactTemplate.map(EConstr$ReactTemplate.of_constr, Environ$ReactTemplate.constant_opt_value_in(env, /* tuple */[
                        $$eval[0],
                        u$1
                      ]));
    case 1 : 
        return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], EConstr$ReactTemplate.lookup_named($$eval[0], env));
    case 2 : 
        var n = $$eval[0];
        var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
        return Option$ReactTemplate.map((function (param) {
                      return partial_arg(n, param);
                    }), Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_value */1], EConstr$ReactTemplate.lookup_rel(n, env)));
    case 3 : 
        var c = EConstr$ReactTemplate.kind(sigma, EConstr$ReactTemplate.mkEvar($$eval[0]));
        if (c.tag === 3) {
          return /* None */0;
        } else {
          return /* Some */[EConstr$ReactTemplate.of_kind(c)];
        }
        break;
    
  }
}

var NotEvaluable = Caml_exceptions.create("Tacred-ReactTemplate.NotEvaluable");

function reference_value(env, sigma, c, u) {
  var match = reference_opt_value(env, sigma, c, u);
  if (match) {
    return match[0];
  } else {
    throw NotEvaluable;
  }
}

var eval_table = Summary$ReactTemplate.ref(/* None */0, "evaluation", Names$ReactTemplate.Cmap[/* empty */0]);

function compute_consteval_direct(env, sigma, ref) {
  var match = unsafe_reference_opt_value(env, sigma, ref);
  if (match) {
    var _env = env;
    var _n = 0;
    var _labs = /* [] */0;
    var _onlyproj = /* false */0;
    var _c = match[0];
    while(true) {
      var c = _c;
      var onlyproj = _onlyproj;
      var labs = _labs;
      var n = _n;
      var env$1 = _env;
      var match$1 = Reductionops$ReactTemplate.whd_betadeltazeta_stack(env$1)(sigma, c);
      var l = match$1[1];
      var match$2 = EConstr$ReactTemplate.kind(sigma, match$1[0]);
      switch (match$2.tag | 0) {
        case 7 : 
            var t = match$2[1];
            if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l) && !onlyproj) {
              _c = match$2[2];
              _labs = /* :: */[
                t,
                labs
              ];
              _n = n + 1 | 0;
              _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      match$2[0],
                      t
                    ]), env$1);
              continue ;
              
            } else {
              return /* NotAnElimination */0;
            }
            break;
        case 13 : 
            var d = match$2[2];
            if (EConstr$ReactTemplate.isRel(sigma, d) && !onlyproj) {
              return /* EliminationCases */Block.__(2, [n]);
            } else {
              _c = d;
              _onlyproj = /* true */1;
              continue ;
              
            }
            break;
        case 14 : 
            if (onlyproj) {
              return /* NotAnElimination */0;
            } else {
              try {
                var sigma$1 = sigma;
                var labs$1 = labs;
                var args = l;
                var param = match$2[0];
                var match$3 = param[1];
                var bds = match$3[2];
                var tys = match$3[1];
                var match$4 = param[0];
                var n$1 = Curry._1(Util$ReactTemplate.List[/* length */0], labs$1);
                var nargs = Curry._1(Util$ReactTemplate.List[/* length */0], args);
                if (nargs > n$1) {
                  throw Elimconst;
                }
                var nbfix = bds.length;
                var li = Curry._2(Util$ReactTemplate.List[/* map */10], (function(sigma$1,labs$1,tys,bds,n$1,nbfix){
                    return function (d) {
                      var match = EConstr$ReactTemplate.kind(sigma$1, d);
                      if (match.tag) {
                        throw Elimconst;
                      } else {
                        var k = match[0];
                        var partial_arg = EConstr$ReactTemplate.Vars[/* noccurn */12];
                        var partial_arg$1 = k + nbfix | 0;
                        var partial_arg$2 = EConstr$ReactTemplate.Vars[/* noccurn */12];
                        if (Util$ReactTemplate.$$Array[/* for_all */26]((function (param) {
                                  return partial_arg(sigma$1, k, param);
                                }), tys) && Util$ReactTemplate.$$Array[/* for_all */26]((function (param) {
                                  return partial_arg$2(sigma$1, partial_arg$1, param);
                                }), bds) && k <= n$1) {
                          return /* tuple */[
                                  k,
                                  Curry._2(Util$ReactTemplate.List[/* nth */3], labs$1, k - 1 | 0)
                                ];
                        } else {
                          throw Elimconst;
                        }
                      }
                    }
                    }(sigma$1,labs$1,tys,bds,n$1,nbfix)), args);
                var reversible_rels = Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                        return prim[0];
                      }), li);
                if (!Curry._2(Util$ReactTemplate.List[/* distinct_f */59], Caml_primitive.caml_int_compare, reversible_rels)) {
                  throw Elimconst;
                }
                Curry._2(Util$ReactTemplate.List[/* iteri */79], (function(sigma$1,li,reversible_rels){
                    return function (i, t_i) {
                      if (Curry._2(Int$ReactTemplate.List[/* mem_assoc */2], i + 1 | 0, li)) {
                        return 0;
                      } else {
                        var partial_arg = i + 1 | 0;
                        var fvs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                return partial_arg + param | 0;
                              }), Curry._1(Int$ReactTemplate.$$Set[/* elements */19], Termops$ReactTemplate.free_rels(sigma$1, t_i)));
                        var match = Curry._3(Util$ReactTemplate.List[/* intersect */50], (function (prim, prim$1) {
                                return +(prim === prim$1);
                              }), fvs, reversible_rels);
                        if (match) {
                          throw Elimconst;
                        } else {
                          return /* () */0;
                        }
                      }
                    }
                    }(sigma$1,li,reversible_rels)), labs$1);
                var k = Caml_array.caml_array_get(match$4[0], match$4[1]);
                if (k < nargs) {
                  return /* EliminationFix */Block.__(0, [
                            n$1,
                            nargs,
                            /* tuple */[
                              nbfix,
                              li,
                              n$1
                            ]
                          ]);
                } else {
                  return /* EliminationFix */Block.__(0, [
                            ((n$1 - nargs | 0) + k | 0) + 1 | 0,
                            nargs,
                            /* tuple */[
                              nbfix,
                              li,
                              n$1
                            ]
                          ]);
                }
              }
              catch (exn){
                if (exn === Elimconst) {
                  return /* NotAnElimination */0;
                } else {
                  throw exn;
                }
              }
            }
            break;
        case 16 : 
            if (EConstr$ReactTemplate.isRel(sigma, match$2[1])) {
              return /* EliminationProj */Block.__(3, [n]);
            } else {
              return /* NotAnElimination */0;
            }
        default:
          return /* NotAnElimination */0;
      }
    };
  } else {
    return /* NotAnElimination */0;
  }
}

function compute_consteval(env, sigma, ref) {
  var elim = compute_consteval_direct(env, sigma, ref);
  if (typeof elim === "number" || !(!elim.tag && elim[2][0] !== 1)) {
    return elim;
  } else {
    var env$1 = env;
    var sigma$1 = sigma;
    var ref$1 = ref;
    var match = unsafe_reference_opt_value(env$1, sigma$1, ref$1);
    if (match) {
      var _env = env$1;
      var _minarg = 0;
      var _labs = /* [] */0;
      var _ref = ref$1;
      var _c = match[0];
      while(true) {
        var c = _c;
        var ref$2 = _ref;
        var labs = _labs;
        var minarg = _minarg;
        var env$2 = _env;
        var match$1 = Reductionops$ReactTemplate.whd_betalet_stack(sigma$1, c);
        var l = match$1[1];
        var c$prime = match$1[0];
        var nargs = Curry._1(Util$ReactTemplate.List[/* length */0], l);
        var match$2 = EConstr$ReactTemplate.kind(sigma$1, c$prime);
        var exit = 0;
        switch (match$2.tag | 0) {
          case 7 : 
              var t = match$2[1];
              if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
                _c = match$2[2];
                _labs = /* :: */[
                  t,
                  labs
                ];
                _minarg = minarg + 1 | 0;
                _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                        match$2[0],
                        t
                      ]), env$2);
                continue ;
                
              } else {
                exit = 1;
              }
              break;
          case 14 : 
              var match$3 = match$2[0];
              var names = match$3[1][0];
              var match$4 = compute_consteval_direct(env$2, sigma$1, ref$2);
              if (typeof match$4 === "number") {
                return /* NotAnElimination */0;
              } else if (match$4.tag) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "tacred.ml",
                        304,
                        13
                      ]
                    ];
              } else {
                var minarg$prime = match$4[0];
                var partial_arg = Caml_array.caml_array_get(names, match$3[0][1]);
                var refs = Util$ReactTemplate.$$Array[/* map */12]((function(env$2,labs,ref$2,l,partial_arg){
                    return function (param) {
                      var labs$1 = labs;
                      var l$1 = l;
                      var na0 = partial_arg;
                      var env$3 = env$2;
                      var sigma$2 = sigma$1;
                      var ref$3 = ref$2;
                      var param$1 = param;
                      if (param$1) {
                        var id = param$1[0];
                        var minfxargs = Curry._1(Util$ReactTemplate.List[/* length */0], l$1);
                        var exit = 0;
                        if (na0) {
                          if (Names$ReactTemplate.Id[/* equal */0](na0[0], id)) {
                            return /* Some */[/* tuple */[
                                      minfxargs,
                                      ref$3
                                    ]];
                          } else {
                            exit = 1;
                          }
                        } else {
                          exit = 1;
                        }
                        if (exit === 1) {
                          var refi;
                          switch (ref$3.tag | 0) {
                            case 0 : 
                                refi = /* Some */[/* EvalConst */Block.__(0, [Names$ReactTemplate.Constant[/* change_label */14](ref$3[0], Names$ReactTemplate.Label[/* of_id */5](id))])];
                                break;
                            case 1 : 
                                refi = /* Some */[/* EvalVar */Block.__(1, [id])];
                                break;
                            case 2 : 
                            case 3 : 
                                refi = /* None */0;
                                break;
                            
                          }
                          if (refi) {
                            var ref$4 = refi[0];
                            try {
                              var match = unsafe_reference_opt_value(env$3, sigma$2, ref$4);
                              if (match) {
                                var match$1 = EConstr$ReactTemplate.decompose_lam(sigma$2, match[0]);
                                var match$2 = Reductionops$ReactTemplate.whd_betalet_stack(sigma$2, match$1[1]);
                                var labs$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                        return prim[1];
                                      }), match$1[0]);
                                var eq_constr = function (c1, c2) {
                                  return EConstr$ReactTemplate.eq_constr(sigma$2, c1, c2);
                                };
                                if (Curry._3(Util$ReactTemplate.List[/* equal */44], eq_constr, labs$prime, labs$1) && Curry._3(Util$ReactTemplate.List[/* equal */44], eq_constr, l$1, match$2[1])) {
                                  return /* Some */[/* tuple */[
                                            minfxargs,
                                            ref$4
                                          ]];
                                } else {
                                  return /* None */0;
                                }
                              } else {
                                return /* None */0;
                              }
                            }
                            catch (exn){
                              if (exn === Caml_builtin_exceptions.not_found) {
                                return /* None */0;
                              } else {
                                throw exn;
                              }
                            }
                          } else {
                            return /* None */0;
                          }
                        }
                        
                      } else {
                        return /* None */0;
                      }
                    }
                    }(env$2,labs,ref$2,l,partial_arg)), names);
                var new_minarg = Caml_primitive.caml_int_max((minarg$prime + minarg | 0) - nargs | 0, minarg$prime);
                return /* EliminationMutualFix */Block.__(1, [
                          new_minarg,
                          ref$2,
                          /* tuple */[
                            refs,
                            match$4[2]
                          ]
                        ]);
              }
              break;
          default:
            exit = 1;
        }
        if (exit === 1) {
          if (isEvalRef(env$2, sigma$1, c$prime)) {
            var match$5 = destEvalRefU(sigma$1, c$prime);
            var ref$3 = match$5[0];
            var match$6 = unsafe_reference_opt_value(env$2, sigma$1, ref$3);
            if (match$6) {
              _c = match$6[0];
              _ref = ref$3;
              _labs = /* [] */0;
              _minarg = minarg - nargs | 0;
              continue ;
              
            } else {
              return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Should have been trapped by compute_direct."));
            }
          } else {
            return /* NotAnElimination */0;
          }
        }
        
      };
    } else {
      return /* NotAnElimination */0;
    }
  }
}

function reference_eval(env, sigma, ref) {
  if (ref.tag) {
    return compute_consteval(env, sigma, ref);
  } else {
    var cst = ref[0];
    try {
      return Curry._2(Names$ReactTemplate.Cmap[/* find */21], cst, eval_table[0]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var v = compute_consteval(env, sigma, ref);
        eval_table[0] = Curry._3(Names$ReactTemplate.Cmap[/* add */3], cst, v, eval_table[0]);
        return v;
      } else {
        throw exn;
      }
    }
  }
}

var x = /* Name */[Namegen$ReactTemplate.default_dependent_ident];

function make_elim_fun(param, u, largs) {
  var match = param[1];
  var n = match[2];
  var lv = match[1];
  var names = param[0];
  var lu = Curry._2(Util$ReactTemplate.List[/* firstn */104], n, largs);
  var p = Curry._1(Util$ReactTemplate.List[/* length */0], lv);
  var lyi = Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
          return prim[0];
        }), lv);
  var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
  var la = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (q, aq) {
          try {
            return EConstr$ReactTemplate.mkRel((p + 1 | 0) - Curry._3(Util$ReactTemplate.List[/* index */77], (function (prim, prim$1) {
                              return +(prim === prim$1);
                            }), n - q | 0, lyi) | 0);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return aq;
            } else {
              throw exn;
            }
          }
        }), 0, Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return partial_arg(p, param);
            }), lu));
  return (function (i) {
      var match = Caml_array.caml_array_get(names, i);
      if (match) {
        var match$1 = match[0];
        var body = EConstr$ReactTemplate.applist(/* tuple */[
              mkEvalRef(match$1[1], u),
              la
            ]);
        var g = Curry._4(Util$ReactTemplate.List[/* fold_left_i */82], (function (q, c, param) {
                var partial_arg = -q | 0;
                var partial_arg$1 = EConstr$ReactTemplate.Vars[/* lift */0];
                var subst = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                        return partial_arg$1(partial_arg, param);
                      }), Curry._2(Util$ReactTemplate.List[/* firstn */104], n - param[0] | 0, la));
                var tij$prime = EConstr$ReactTemplate.Vars[/* substl */3](Curry._1(Util$ReactTemplate.List[/* rev */4], subst), param[1]);
                return EConstr$ReactTemplate.mkLambda(/* tuple */[
                            x,
                            tij$prime,
                            c
                          ]);
              }), 1, body, Curry._1(Util$ReactTemplate.List[/* rev */4], lv));
        return /* Some */[/* tuple */[
                  match$1[0],
                  g
                ]];
      } else {
        return /* None */0;
      }
    });
}

var vfx = Names$ReactTemplate.Id[/* of_string */5]("_expanded_fix_");

var vfun = Names$ReactTemplate.Id[/* of_string */5]("_eliminator_function_");

var venv = EConstr$ReactTemplate.val_of_named_context(/* :: */[
      /* LocalAssum */Block.__(0, [
          vfx,
          EConstr$ReactTemplate.mkProp
        ]),
      /* :: */[
        /* LocalAssum */Block.__(0, [
            vfun,
            EConstr$ReactTemplate.mkProp
          ]),
        /* [] */0
      ]
    ]);

function substl_with_function(subst, sigma, constr) {
  var evd = [sigma];
  var minargs = [Evar$ReactTemplate.$$Map[/* empty */0]];
  var v = Util$ReactTemplate.$$Array[/* of_list */10](subst);
  var subst_total = function (k, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    var exit = 0;
    if (match.tag) {
      exit = 1;
    } else {
      var i = match[0];
      if (k < i) {
        if (i <= (k + v.length | 0)) {
          var match$1 = Caml_array.caml_array_get(v, (i - k | 0) - 1 | 0);
          var match$2 = match$1[1];
          var fx = match$1[0];
          if (match$2) {
            var match$3 = match$2[0];
            var sigma$1 = evd[0];
            var match$4 = Evarutil$ReactTemplate.new_pure_evar(venv, sigma$1, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, EConstr$ReactTemplate.mkProp);
            var evk = match$4[1];
            evd[0] = match$4[0];
            minargs[0] = Curry._3(Evar$ReactTemplate.$$Map[/* add */3], evk, match$3[0], minargs[0]);
            return EConstr$ReactTemplate.Vars[/* lift */0](k, EConstr$ReactTemplate.mkEvar(/* tuple */[
                            evk,
                            /* array */[
                              fx,
                              match$3[1]
                            ]
                          ]));
          } else {
            return EConstr$ReactTemplate.Vars[/* lift */0](k, fx);
          }
        } else {
          return EConstr$ReactTemplate.mkRel(i - v.length | 0);
        }
      } else {
        exit = 1;
      }
    }
    if (exit === 1) {
      return EConstr$ReactTemplate.map_with_binders(sigma, (function (prim) {
                    return prim + 1 | 0;
                  }), subst_total, k, c);
    }
    
  };
  var c = subst_total(0, constr);
  return /* tuple */[
          c,
          evd[0],
          minargs[0]
        ];
}

var Partial = Caml_exceptions.create("Tacred-ReactTemplate.Partial");

function solve_arity_problem(env, sigma, fxminargs, c) {
  var evm = [sigma];
  var set_fix = function (i) {
    evm[0] = Evd$ReactTemplate.define(i, Constr$ReactTemplate.mkVar(vfx), evm[0]);
    return /* () */0;
  };
  var check = function (strict, _c) {
    while(true) {
      var c = _c;
      var c$prime = Reductionops$ReactTemplate.whd_betaiotazeta(sigma, c);
      var match = Termops$ReactTemplate.decompose_app_vect(sigma, c$prime);
      var rcargs = match[1];
      var h = match[0];
      var match$1 = EConstr$ReactTemplate.kind(sigma, h);
      var exit = 0;
      var exit$1 = 0;
      switch (match$1.tag | 0) {
        case 3 : 
            var i = match$1[0][0];
            if (Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], i, fxminargs) && !Evd$ReactTemplate.is_defined(evm[0], i)) {
              var minargs = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], i, fxminargs);
              if (rcargs.length < minargs) {
                if (strict) {
                  set_fix(i);
                } else {
                  throw Partial;
                }
              }
              return Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                            return check(strict, param);
                          }), rcargs);
            } else {
              exit = 1;
            }
            break;
        case 1 : 
        case 10 : 
            exit$1 = 2;
            break;
        default:
          exit = 1;
      }
      if (exit$1 === 2) {
        if (isEvalRef(env, sigma, h)) {
          var match$2 = destEvalRefU(sigma, h);
          var match$3 = reference_opt_value(env, sigma, match$2[0], match$2[1]);
          if (match$3) {
            var bak = evm[0];
            try {
              return Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                            return check(/* false */0, param);
                          }), rcargs);
            }
            catch (exn){
              if (exn === Partial) {
                evm[0] = bak;
                _c = EConstr$ReactTemplate.mkApp(/* tuple */[
                      match$3[0],
                      rcargs
                    ]);
                continue ;
                
              } else {
                throw exn;
              }
            }
          } else {
            return Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                          return check(strict, param);
                        }), rcargs);
          }
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        return EConstr$ReactTemplate.iter(sigma, (function (param) {
                      return check(strict, param);
                    }), c$prime);
      }
      
    };
  };
  check(/* true */1, c);
  return evm[0];
}

function substl_checking_arity(env, subst, sigma, c) {
  var match = substl_with_function(subst, sigma, c);
  var minargs = match[2];
  var sigma$1 = match[1];
  var body = match[0];
  var sigma$prime = solve_arity_problem(env, sigma$1, minargs, body);
  var nf_fix = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma$1, c);
    if (match.tag === 3) {
      var match$1 = match[0];
      var match$2 = match$1[1];
      if (match$2.length !== 2) {
        return EConstr$ReactTemplate.map(sigma$1, nf_fix, c);
      } else {
        var f = match$2[1];
        if (Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], match$1[0], minargs)) {
          var c$1 = EConstr$ReactTemplate.kind(sigma$prime, c);
          if (c$1.tag === 3) {
            return f;
          } else {
            return EConstr$ReactTemplate.of_kind(c$1);
          }
        } else {
          return EConstr$ReactTemplate.map(sigma$1, nf_fix, c);
        }
      }
    } else {
      return EConstr$ReactTemplate.map(sigma$1, nf_fix, c);
    }
  };
  return nf_fix(body);
}

function reduce_fix(whdfun, sigma, fix, stack) {
  var match = Reductionops$ReactTemplate.fix_recarg(fix, Reductionops$ReactTemplate.Stack[/* append_app_list */11](stack, Reductionops$ReactTemplate.Stack[/* empty */2]));
  if (match) {
    var match$1 = match[0];
    var recarg$prime = Curry._2(whdfun, sigma, match$1[1]);
    var stack$prime = Curry._3(Util$ReactTemplate.List[/* assign */57], stack, match$1[0], EConstr$ReactTemplate.applist(recarg$prime));
    var match$2 = EConstr$ReactTemplate.kind(sigma, recarg$prime[0]);
    if (match$2.tag === 12) {
      return /* Reduced */[/* tuple */[
                Reductionops$ReactTemplate.contract_fix(/* None */0, sigma, /* None */0, fix),
                stack$prime
              ]];
    } else {
      return /* NotReducible */0;
    }
  } else {
    return /* NotReducible */0;
  }
}

function contract_fix_use_function(env, sigma, f, param) {
  var typedbodies = param[1];
  var match = param[0];
  var recindices = match[0];
  var nbodies = recindices.length;
  var make_Fi = function (j) {
    return /* tuple */[
            EConstr$ReactTemplate.mkFix(/* tuple */[
                  /* tuple */[
                    recindices,
                    j
                  ],
                  typedbodies
                ]),
            Curry._1(f, j)
          ];
  };
  var lbodies = Curry._2(Util$ReactTemplate.List[/* init */46], nbodies, make_Fi);
  return substl_checking_arity(env, Curry._1(Util$ReactTemplate.List[/* rev */4], lbodies), sigma, Reductionops$ReactTemplate.nf_beta(env, sigma, Caml_array.caml_array_get(typedbodies[2], match[1])));
}

function reduce_fix_use_function(env, sigma, f, whfun, fix, stack) {
  var match = Reductionops$ReactTemplate.fix_recarg(fix, Reductionops$ReactTemplate.Stack[/* append_app_list */11](stack, Reductionops$ReactTemplate.Stack[/* empty */2]));
  if (match) {
    var match$1 = match[0];
    var recarg = match$1[1];
    var recarg$prime = EConstr$ReactTemplate.isRel(sigma, recarg) ? /* tuple */[
        recarg,
        /* [] */0
      ] : Curry._1(whfun, recarg);
    var stack$prime = Curry._3(Util$ReactTemplate.List[/* assign */57], stack, match$1[0], EConstr$ReactTemplate.applist(recarg$prime));
    var match$2 = EConstr$ReactTemplate.kind(sigma, recarg$prime[0]);
    if (match$2.tag === 12) {
      return /* Reduced */[/* tuple */[
                contract_fix_use_function(env, sigma, f, fix),
                stack$prime
              ]];
    } else {
      return /* NotReducible */0;
    }
  } else {
    return /* NotReducible */0;
  }
}

function contract_cofix_use_function(env, sigma, f, param) {
  var typedbodies = param[1];
  var bodies = typedbodies[2];
  var nbodies = bodies.length;
  var make_Fi = function (j) {
    return /* tuple */[
            EConstr$ReactTemplate.mkCoFix(/* tuple */[
                  j,
                  typedbodies
                ]),
            Curry._1(f, j)
          ];
  };
  var subbodies = Curry._2(Util$ReactTemplate.List[/* init */46], nbodies, make_Fi);
  return substl_checking_arity(env, Curry._1(Util$ReactTemplate.List[/* rev */4], subbodies), sigma, Reductionops$ReactTemplate.nf_beta(env, sigma, Caml_array.caml_array_get(bodies, param[0])));
}

function match_eval_ref(env, sigma, constr, stack) {
  var match = EConstr$ReactTemplate.kind(sigma, constr);
  switch (match.tag | 0) {
    case 0 : 
        return /* Some */[/* tuple */[
                  /* EvalRel */Block.__(2, [match[0]]),
                  EConstr$ReactTemplate.EInstance[/* empty */2]
                ]];
    case 1 : 
        var id = match[0];
        if (is_evaluable(env, /* EvalVarRef */Block.__(0, [id]))) {
          return /* Some */[/* tuple */[
                    /* EvalVar */Block.__(1, [id]),
                    EConstr$ReactTemplate.EInstance[/* empty */2]
                  ]];
        } else {
          return /* None */0;
        }
    case 3 : 
        return /* Some */[/* tuple */[
                  /* EvalEvar */Block.__(3, [match[0]]),
                  EConstr$ReactTemplate.EInstance[/* empty */2]
                ]];
    case 10 : 
        var match$1 = match[0];
        var sp = match$1[0];
        Reductionops$ReactTemplate.reduction_effect_hook(env, sigma, EConstr$ReactTemplate.to_constr(sigma, constr), Block.__(246, [(function () {
                    return EConstr$ReactTemplate.to_constr(sigma, EConstr$ReactTemplate.applist(/* tuple */[
                                    constr,
                                    stack
                                  ]));
                  })]));
        if (is_evaluable(env, /* EvalConstRef */Block.__(1, [sp]))) {
          return /* Some */[/* tuple */[
                    /* EvalConst */Block.__(0, [sp]),
                    match$1[1]
                  ]];
        } else {
          return /* None */0;
        }
    default:
      return /* None */0;
  }
}

function match_eval_ref_value(env, sigma, constr, stack) {
  var match = EConstr$ReactTemplate.kind(sigma, constr);
  switch (match.tag | 0) {
    case 0 : 
        var n = match[0];
        var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
        return Option$ReactTemplate.map((function (param) {
                      return partial_arg(n, param);
                    }), Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_value */1], EConstr$ReactTemplate.lookup_rel(n, env)));
    case 1 : 
        var id = match[0];
        if (is_evaluable(env, /* EvalVarRef */Block.__(0, [id]))) {
          return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], EConstr$ReactTemplate.lookup_named(id, env));
        } else {
          return /* None */0;
        }
    case 10 : 
        var match$1 = match[0];
        var sp = match$1[0];
        Reductionops$ReactTemplate.reduction_effect_hook(env, sigma, EConstr$ReactTemplate.to_constr(sigma, constr), Block.__(246, [(function () {
                    return EConstr$ReactTemplate.to_constr(sigma, EConstr$ReactTemplate.applist(/* tuple */[
                                    constr,
                                    stack
                                  ]));
                  })]));
        if (is_evaluable(env, /* EvalConstRef */Block.__(1, [sp]))) {
          var u = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$1[1]);
          return /* Some */[EConstr$ReactTemplate.of_constr(Environ$ReactTemplate.constant_value_in(env, /* tuple */[
                            sp,
                            u
                          ]))];
        } else {
          return /* None */0;
        }
        break;
    case 16 : 
        var p = match[0];
        if (Names$ReactTemplate.Projection[/* unfolded */3](p)) {
          return /* None */0;
        } else {
          Reductionops$ReactTemplate.reduction_effect_hook(env, sigma, EConstr$ReactTemplate.to_constr(sigma, constr), Block.__(246, [(function () {
                      return EConstr$ReactTemplate.to_constr(sigma, EConstr$ReactTemplate.applist(/* tuple */[
                                      constr,
                                      stack
                                    ]));
                    })]));
          if (is_evaluable(env, /* EvalConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](p)]))) {
            return /* Some */[EConstr$ReactTemplate.mkProj(/* tuple */[
                          Names$ReactTemplate.Projection[/* unfold */4](p),
                          match[1]
                        ])];
          } else {
            return /* None */0;
          }
        }
    default:
      return /* None */0;
  }
}

function special_red_case(env, sigma, whfun, param) {
  var lf = param[3];
  var p = param[1];
  var ci = param[0];
  var _s = param[2];
  while(true) {
    var s = _s;
    var match = Curry._1(whfun, s);
    var cargs = match[1];
    var constr = match[0];
    var match$1 = match_eval_ref(env, sigma, constr, cargs);
    if (match$1) {
      var match$2 = match$1[0];
      var match$3 = reference_opt_value(env, sigma, match$2[0], match$2[1]);
      if (match$3) {
        var gvalue = match$3[0];
        if (Reductionops$ReactTemplate.reducible_mind_case(sigma, gvalue)) {
          var func = constr;
          var env$1 = env;
          var sigma$1 = sigma;
          var mia = /* record */[
            /* mP */p,
            /* mconstr */gvalue,
            /* mci */ci,
            /* mcargs */cargs,
            /* mlf */lf
          ];
          var match$4 = EConstr$ReactTemplate.kind(sigma$1, mia[/* mconstr */1]);
          switch (match$4.tag | 0) {
            case 12 : 
                var real_cargs = Curry._2(Util$ReactTemplate.List[/* skipn */107], mia[/* mci */2][/* ci_npar */1], mia[/* mcargs */3]);
                return EConstr$ReactTemplate.applist(/* tuple */[
                            Caml_array.caml_array_get(mia[/* mlf */4], match$4[0][0][1] - 1 | 0),
                            real_cargs
                          ]);
            case 15 : 
                var cofix = match$4[0];
                var names = cofix[1][0];
                var bodynum = cofix[0];
                var build_cofix_name;
                if (EConstr$ReactTemplate.isConst(sigma$1, func)) {
                  var minargs = Curry._1(Util$ReactTemplate.List[/* length */0], mia[/* mcargs */3]);
                  build_cofix_name = (function(func,env$1,sigma$1,bodynum,names,minargs){
                  return function (i) {
                    if (i === bodynum) {
                      return /* Some */[/* tuple */[
                                minargs,
                                func
                              ]];
                    } else {
                      var match = Caml_array.caml_array_get(names, i);
                      if (match) {
                        var match$1 = EConstr$ReactTemplate.destConst(sigma$1, func);
                        var u = match$1[1];
                        var kn = Names$ReactTemplate.Constant[/* change_label */14](match$1[0], Names$ReactTemplate.Label[/* of_id */5](match[0]));
                        var cst_001 = EConstr$ReactTemplate.EInstance[/* kind */1](sigma$1, u);
                        var cst = /* tuple */[
                          kn,
                          cst_001
                        ];
                        try {
                          var match$2 = Environ$ReactTemplate.constant_opt_value_in(env$1, cst);
                          if (match$2) {
                            return /* Some */[/* tuple */[
                                      minargs,
                                      EConstr$ReactTemplate.mkConstU(/* tuple */[
                                            kn,
                                            u
                                          ])
                                    ]];
                          } else {
                            return /* None */0;
                          }
                        }
                        catch (exn){
                          if (exn === Caml_builtin_exceptions.not_found) {
                            return /* None */0;
                          } else {
                            throw exn;
                          }
                        }
                      } else {
                        return /* None */0;
                      }
                    }
                  }
                  }(func,env$1,sigma$1,bodynum,names,minargs));
                } else {
                  build_cofix_name = (function () {
                      return /* None */0;
                    });
                }
                var cofix_def = contract_cofix_use_function(env$1, sigma$1, build_cofix_name, cofix);
                return EConstr$ReactTemplate.mkCase(/* tuple */[
                            mia[/* mci */2],
                            mia[/* mP */0],
                            EConstr$ReactTemplate.applist(/* tuple */[
                                  cofix_def,
                                  mia[/* mcargs */3]
                                ]),
                            mia[/* mlf */4]
                          ]);
            default:
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "tacred.ml",
                      536,
                      11
                    ]
                  ];
          }
        } else {
          _s = EConstr$ReactTemplate.applist(/* tuple */[
                gvalue,
                cargs
              ]);
          continue ;
          
        }
      } else {
        throw Redelimination;
      }
    } else if (Reductionops$ReactTemplate.reducible_mind_case(sigma, constr)) {
      return Reductionops$ReactTemplate.reduce_mind_case(sigma, /* record */[
                  /* mP */p,
                  /* mconstr */constr,
                  /* mci */ci,
                  /* mcargs */cargs,
                  /* mlf */lf
                ]);
    } else {
      throw Redelimination;
    }
  };
}

function recargs(param) {
  if (param.tag) {
    return /* None */0;
  } else {
    return Reductionops$ReactTemplate.ReductionBehaviour[/* get */1](/* ConstRef */Block.__(1, [param[0]]));
  }
}

function reduce_projection(_, sigma, pb, param, stack) {
  var match = EConstr$ReactTemplate.kind(sigma, param[0]);
  if (match.tag === 12) {
    var proj_narg = pb[/* proj_npars */1] + pb[/* proj_arg */2] | 0;
    return /* Reduced */[/* tuple */[
              Curry._2(Util$ReactTemplate.List[/* nth */3], param[1], proj_narg),
              stack
            ]];
  } else {
    return /* NotReducible */0;
  }
}

function reduce_proj(env, sigma, whfun, whfun$prime, c) {
  var redrec = function (s) {
    var match = EConstr$ReactTemplate.kind(sigma, s);
    switch (match.tag | 0) {
      case 13 : 
          var c$prime = redrec(match[2]);
          var p_000 = match[0];
          var p_001 = match[1];
          var p_003 = match[3];
          var p = /* tuple */[
            p_000,
            p_001,
            c$prime,
            p_003
          ];
          try {
            return special_red_case(env, sigma, whfun$prime, p);
          }
          catch (exn){
            if (exn === Redelimination) {
              return EConstr$ReactTemplate.mkCase(p);
            } else {
              throw exn;
            }
          }
          break;
      case 16 : 
          var c = match[1];
          var c$prime$1;
          try {
            c$prime$1 = redrec(c);
          }
          catch (exn$1){
            if (exn$1 === Redelimination) {
              c$prime$1 = c;
            } else {
              throw exn$1;
            }
          }
          var match$1 = Curry._1(whfun, c$prime$1);
          var match$2 = EConstr$ReactTemplate.kind(sigma, match$1[0]);
          if (match$2.tag === 12) {
            var pb = Environ$ReactTemplate.lookup_projection(match[0], env);
            var proj_narg = pb[/* proj_npars */1] + pb[/* proj_arg */2] | 0;
            return Curry._2(Util$ReactTemplate.List[/* nth */3], match$1[1], proj_narg);
          } else {
            throw Redelimination;
          }
          break;
      default:
        throw Redelimination;
    }
  };
  return redrec(c);
}

function whd_nothing_for_iota(env, sigma, s) {
  var whrec = function (_s) {
    while(true) {
      var s = _s;
      var stack = s[1];
      var x = EConstr$ReactTemplate.kind(sigma, s[0]);
      switch (x.tag | 0) {
        case 0 : 
            var n = x[0];
            var match = EConstr$ReactTemplate.lookup_rel(n, env);
            if (match.tag) {
              _s = /* tuple */[
                EConstr$ReactTemplate.Vars[/* lift */0](n, match[1]),
                stack
              ];
              continue ;
              
            } else {
              return s;
            }
            break;
        case 1 : 
            var match$1 = EConstr$ReactTemplate.lookup_named(x[0], env);
            if (match$1.tag) {
              _s = /* tuple */[
                match$1[1],
                stack
              ];
              continue ;
              
            } else {
              return s;
            }
            break;
        case 2 : 
            try {
              return whrec(/* tuple */[
                          EConstr$ReactTemplate.of_constr(Evd$ReactTemplate.meta_value(sigma, x[0])),
                          stack
                        ]);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return s;
              } else {
                throw exn;
              }
            }
            break;
        case 3 : 
            return s;
        case 5 : 
            _s = /* tuple */[
              x[0],
              stack
            ];
            continue ;
            case 7 : 
            var match$2 = Reductionops$ReactTemplate.Stack[/* decomp */5](stack);
            if (match$2) {
              var match$3 = match$2[0];
              return Reductionops$ReactTemplate.stacklam(whrec, /* :: */[
                          match$3[0],
                          /* [] */0
                        ], sigma, x[2], match$3[1]);
            } else {
              return s;
            }
            break;
        case 8 : 
            return Reductionops$ReactTemplate.stacklam(whrec, /* :: */[
                        x[1],
                        /* [] */0
                      ], sigma, x[3], stack);
        case 9 : 
            _s = /* tuple */[
              x[0],
              Reductionops$ReactTemplate.Stack[/* append_app */4](x[1], stack)
            ];
            continue ;
            case 10 : 
            var match$4 = x[0];
            var $$const = match$4[0];
            if (CClosure$ReactTemplate.is_transparent_constant(Names$ReactTemplate.full_transparent_state, $$const)) {
              var u = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$4[1]);
              var match$5 = Environ$ReactTemplate.constant_opt_value_in(env, /* tuple */[
                    $$const,
                    u
                  ]);
              if (match$5) {
                _s = /* tuple */[
                  EConstr$ReactTemplate.of_constr(match$5[0]),
                  stack
                ];
                continue ;
                
              } else {
                return s;
              }
            } else {
              return s;
            }
            break;
        default:
          return s;
      }
    };
  };
  return EConstr$ReactTemplate.decompose_app(sigma, Reductionops$ReactTemplate.Stack[/* zip */21](/* None */0, sigma, whrec(/* tuple */[
                      s,
                      Reductionops$ReactTemplate.Stack[/* empty */2]
                    ])));
}

function red_elim_const(env, sigma, ref, u, largs) {
  var nargs = Curry._1(Util$ReactTemplate.List[/* length */0], largs);
  var match = recargs(ref);
  var match$1;
  if (match) {
    var match$2 = match[0];
    var l = match$2[0];
    var exit = 0;
    if (nargs < match$2[1] || Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionNeverUnfold */1012736563, match$2[2])) {
      throw Redelimination;
    } else if (l) {
      if (nargs <= Curry._3(Util$ReactTemplate.List[/* fold_left */13], Caml_obj.caml_max, l[0], l[1])) {
        throw Redelimination;
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var n = match$2[1];
      var is_empty = l ? /* false */0 : /* true */1;
      match$1 = /* tuple */[
        reduce_params(env, sigma, largs, l),
        +(n >= 0) && is_empty && +(nargs >= n),
        +(n >= 0) && 1 - is_empty && +(nargs >= n),
        Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionDontExposeCase */-1020251784, match$2[2])
      ];
    }
    
  } else {
    match$1 = /* tuple */[
      largs,
      /* false */0,
      /* false */0,
      /* false */0
    ];
  }
  var nocase = match$1[3];
  var largs$1 = match$1[0];
  try {
    var match$3 = reference_eval(env, sigma, ref);
    if (typeof match$3 === "number") {
      if (match$1[2]) {
        var c = reference_value(env, sigma, ref, u);
        return /* tuple */[
                /* tuple */[
                  Reductionops$ReactTemplate.whd_betaiotazeta(sigma, EConstr$ReactTemplate.applist(/* tuple */[
                            c,
                            largs$1
                          ])),
                  /* [] */0
                ],
                nocase
              ];
      } else {
        throw Redelimination;
      }
    } else {
      switch (match$3.tag | 0) {
        case 0 : 
            if (nargs >= match$3[0]) {
              var c$1 = reference_value(env, sigma, ref, u);
              var match$4 = whd_nothing_for_iota(env, sigma, EConstr$ReactTemplate.applist(/* tuple */[
                        c$1,
                        largs$1
                      ]));
              var f = make_elim_fun(/* tuple */[
                    /* array */[/* Some */[/* tuple */[
                          match$3[1],
                          ref
                        ]]],
                    match$3[2]
                  ], u, largs$1);
              var whfun = function (param) {
                return whd_construct_stack(env, sigma, param);
              };
              var match$5 = reduce_fix_use_function(env, sigma, f, whfun, EConstr$ReactTemplate.destFix(sigma, match$4[0]), match$4[1]);
              if (match$5) {
                var match$6 = match$5[0];
                return /* tuple */[
                        /* tuple */[
                          Reductionops$ReactTemplate.nf_beta(env, sigma, match$6[0]),
                          match$6[1]
                        ],
                        nocase
                      ];
              } else {
                throw Redelimination;
              }
            } else {
              throw Redelimination;
            }
            break;
        case 1 : 
            if (nargs >= match$3[0]) {
              var refgoal = match$3[1];
              var descend = function (_param, _args) {
                while(true) {
                  var param = _param;
                  var args = _args;
                  var ref = param[0];
                  var c = reference_value(env, sigma, ref, param[1]);
                  if (evaluable_reference_eq(sigma, ref, refgoal)) {
                    return /* tuple */[
                            c,
                            args
                          ];
                  } else {
                    var match = Reductionops$ReactTemplate.whd_betalet_stack(sigma, EConstr$ReactTemplate.applist(/* tuple */[
                              c,
                              args
                            ]));
                    _args = match[1];
                    _param = destEvalRefU(sigma, match[0]);
                    continue ;
                    
                  }
                };
              };
              var s = descend(/* tuple */[
                    ref,
                    u
                  ], largs$1);
              var match$7 = whd_nothing_for_iota(env, sigma, EConstr$ReactTemplate.applist(s));
              var f$1 = make_elim_fun(match$3[2], u, s[1]);
              var whfun$1 = function (param) {
                return whd_construct_stack(env, sigma, param);
              };
              var match$8 = reduce_fix_use_function(env, sigma, f$1, whfun$1, EConstr$ReactTemplate.destFix(sigma, match$7[0]), match$7[1]);
              if (match$8) {
                var match$9 = match$8[0];
                return /* tuple */[
                        /* tuple */[
                          Reductionops$ReactTemplate.nf_beta(env, sigma, match$9[0]),
                          match$9[1]
                        ],
                        nocase
                      ];
              } else {
                throw Redelimination;
              }
            } else {
              throw Redelimination;
            }
            break;
        case 2 : 
            if (nargs >= match$3[0]) {
              var c$2 = reference_value(env, sigma, ref, u);
              var match$10 = whd_nothing_for_iota(env, sigma, EConstr$ReactTemplate.applist(/* tuple */[
                        c$2,
                        largs$1
                      ]));
              var whfun$2 = whd_simpl_stack(env, sigma);
              return /* tuple */[
                      /* tuple */[
                        special_red_case(env, sigma, whfun$2, EConstr$ReactTemplate.destCase(sigma, match$10[0])),
                        match$10[1]
                      ],
                      nocase
                    ];
            } else {
              throw Redelimination;
            }
            break;
        case 3 : 
            if (nargs >= match$3[0]) {
              var c$3 = reference_value(env, sigma, ref, u);
              var match$11 = whd_nothing_for_iota(env, sigma, EConstr$ReactTemplate.applist(/* tuple */[
                        c$3,
                        largs$1
                      ]));
              var whfun$3 = function (param) {
                return whd_construct_stack(env, sigma, param);
              };
              var whfun$prime = whd_simpl_stack(env, sigma);
              return /* tuple */[
                      /* tuple */[
                        reduce_proj(env, sigma, whfun$3, whfun$prime, match$11[0]),
                        match$11[1]
                      ],
                      nocase
                    ];
            } else {
              throw Redelimination;
            }
            break;
        
      }
    }
  }
  catch (exn){
    if (exn === Redelimination) {
      if (match$1[1]) {
        var c$4 = reference_value(env, sigma, ref, u);
        return /* tuple */[
                /* tuple */[
                  Reductionops$ReactTemplate.whd_betaiotazeta(sigma, EConstr$ReactTemplate.applist(/* tuple */[
                            c$4,
                            largs$1
                          ])),
                  /* [] */0
                ],
                nocase
              ];
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
}

function reduce_params(env, sigma, stack, l) {
  var len = Curry._1(Util$ReactTemplate.List[/* length */0], stack);
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (stack, i) {
                if (len <= i) {
                  throw Redelimination;
                } else {
                  var arg = Curry._2(Util$ReactTemplate.List[/* nth */3], stack, i);
                  var rarg = whd_construct_stack(env, sigma, arg);
                  var match = EConstr$ReactTemplate.kind(sigma, rarg[0]);
                  if (match.tag === 12) {
                    return Curry._3(Util$ReactTemplate.List[/* assign */57], stack, i, EConstr$ReactTemplate.applist(rarg));
                  } else {
                    throw Redelimination;
                  }
                }
              }), stack, l);
}

function whd_simpl_stack(env, sigma) {
  var redrec = function (_s) {
    while(true) {
      var s = _s;
      var match = Termops$ReactTemplate.decompose_app_vect(sigma, s);
      var x = match[0];
      var stack = Util$ReactTemplate.$$Array[/* to_list */9](match[1]);
      var s$prime = /* tuple */[
        x,
        stack
      ];
      var match$1 = EConstr$ReactTemplate.kind(sigma, x);
      switch (match$1.tag | 0) {
        case 5 : 
            _s = EConstr$ReactTemplate.applist(/* tuple */[
                  match$1[0],
                  stack
                ]);
            continue ;
            case 7 : 
            if (stack) {
              _s = Reductionops$ReactTemplate.beta_applist(sigma, /* tuple */[
                    x,
                    stack
                  ]);
              continue ;
              
            } else {
              return s$prime;
            }
            break;
        case 8 : 
            _s = EConstr$ReactTemplate.applist(/* tuple */[
                  EConstr$ReactTemplate.Vars[/* substl */3](/* :: */[
                        match$1[1],
                        /* [] */0
                      ], match$1[3]),
                  stack
                ]);
            continue ;
            case 9 : 
            _s = EConstr$ReactTemplate.applist(/* tuple */[
                  match$1[0],
                  Util$ReactTemplate.$at(Util$ReactTemplate.$$Array[/* to_list */9](match$1[1]), stack)
                ]);
            continue ;
            case 13 : 
            try {
              return redrec(EConstr$ReactTemplate.applist(/* tuple */[
                              special_red_case(env, sigma, redrec, /* tuple */[
                                    match$1[0],
                                    match$1[1],
                                    match$1[2],
                                    match$1[3]
                                  ]),
                              stack
                            ]));
            }
            catch (exn){
              if (exn === Redelimination) {
                return s$prime;
              } else {
                throw exn;
              }
            }
            break;
        case 14 : 
            try {
              var match$2 = reduce_fix((function (param, param$1) {
                      return whd_construct_stack(env, param, param$1);
                    }), sigma, match$1[0], stack);
              if (match$2) {
                return redrec(EConstr$ReactTemplate.applist(match$2[0]));
              } else {
                return s$prime;
              }
            }
            catch (exn$1){
              if (exn$1 === Redelimination) {
                return s$prime;
              } else {
                throw exn$1;
              }
            }
            break;
        case 16 : 
            var c = match$1[1];
            var p = match$1[0];
            try {
              var unf = Names$ReactTemplate.Projection[/* unfolded */3](p);
              if (unf || is_evaluable(env, /* EvalConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](p)]))) {
                var pb = Environ$ReactTemplate.lookup_projection(p, env);
                var match$3 = Reductionops$ReactTemplate.ReductionBehaviour[/* get */1](/* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](p)]));
                var exit = 0;
                if (unf !== 0) {
                  exit = 1;
                } else if (match$3) {
                  var match$4 = match$3[0];
                  var l = match$4[0];
                  if (Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionNeverUnfold */1012736563, match$4[2])) {
                    return s$prime;
                  } else if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
                    exit = 1;
                  } else {
                    var l$prime = Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function(pb){
                        return function (i) {
                          var idx = i - (pb[/* proj_npars */1] + 1 | 0) | 0;
                          if (idx < 0) {
                            return /* None */0;
                          } else {
                            return /* Some */[idx];
                          }
                        }
                        }(pb)), l);
                    var stack$1 = reduce_params(env, sigma, stack, l$prime);
                    var match$5 = reduce_projection(env, sigma, pb, whd_construct_stack(env, sigma, c), stack$1);
                    if (match$5) {
                      return redrec(EConstr$ReactTemplate.applist(match$5[0]));
                    } else {
                      return s$prime;
                    }
                  }
                } else {
                  exit = 1;
                }
                if (exit === 1) {
                  var match$6 = reduce_projection(env, sigma, pb, whd_construct_stack(env, sigma, c), stack);
                  if (match$6) {
                    return redrec(EConstr$ReactTemplate.applist(match$6[0]));
                  } else {
                    return s$prime;
                  }
                }
                
              } else {
                return s$prime;
              }
            }
            catch (exn$2){
              if (exn$2 === Redelimination) {
                return s$prime;
              } else {
                throw exn$2;
              }
            }
            break;
        default:
          var match$7 = match_eval_ref(env, sigma, x, stack);
          if (match$7) {
            var match$8 = match$7[0];
            try {
              var match$9 = red_elim_const(env, sigma, match$8[0], match$8[1], stack);
              var s$prime$prime = redrec(EConstr$ReactTemplate.applist(match$9[0]));
              var is_case = function (_x) {
                while(true) {
                  var x = _x;
                  var match = EConstr$ReactTemplate.kind(sigma, x);
                  switch (match.tag | 0) {
                    case 7 : 
                        _x = match[2];
                        continue ;
                        case 8 : 
                        _x = match[3];
                        continue ;
                        case 5 : 
                    case 9 : 
                        _x = match[0];
                        continue ;
                        case 13 : 
                        return /* true */1;
                    default:
                      return /* false */0;
                  }
                };
              };
              if (match$9[1] && is_case(s$prime$prime[0])) {
                throw Redelimination;
              } else {
                return s$prime$prime;
              }
            }
            catch (exn$3){
              if (exn$3 === Redelimination) {
                return s$prime;
              } else {
                throw exn$3;
              }
            }
          } else {
            return s$prime;
          }
      }
    };
  };
  return redrec;
}

function whd_construct_stack(env, sigma, _s) {
  while(true) {
    var s = _s;
    var s$prime = whd_simpl_stack(env, sigma)(s);
    var cargs = s$prime[1];
    var constr = s$prime[0];
    if (Reductionops$ReactTemplate.reducible_mind_case(sigma, constr)) {
      return s$prime;
    } else {
      var match = match_eval_ref(env, sigma, constr, cargs);
      if (match) {
        var match$1 = match[0];
        var match$2 = reference_opt_value(env, sigma, match$1[0], match$1[1]);
        if (match$2) {
          _s = EConstr$ReactTemplate.applist(/* tuple */[
                match$2[0],
                cargs
              ]);
          continue ;
          
        } else {
          throw Redelimination;
        }
      } else {
        throw Redelimination;
      }
    }
  };
}

function try_red_product(env, sigma, c) {
  var simpfun = function (c) {
    return Reductionops$ReactTemplate.clos_norm_flags(CClosure$ReactTemplate.betaiotazeta, env, sigma, c);
  };
  var redrec = function (env, _x) {
    while(true) {
      var x = _x;
      var x$1 = Reductionops$ReactTemplate.whd_betaiota(sigma, x);
      var match = EConstr$ReactTemplate.kind(sigma, x$1);
      switch (match.tag | 0) {
        case 5 : 
            _x = match[0];
            continue ;
            case 6 : 
            var a = match[1];
            var x$2 = match[0];
            return EConstr$ReactTemplate.mkProd(/* tuple */[
                        x$2,
                        a,
                        redrec(EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                    x$2,
                                    a
                                  ]), env), match[2])
                      ]);
        case 8 : 
            _x = EConstr$ReactTemplate.Vars[/* subst1 */4](match[1], match[3]);
            continue ;
            case 9 : 
            var l = match[1];
            var f = match[0];
            var match$1 = EConstr$ReactTemplate.kind(sigma, f);
            if (match$1.tag === 14) {
              var stack = Reductionops$ReactTemplate.Stack[/* append_app */4](l, Reductionops$ReactTemplate.Stack[/* empty */2]);
              var match$2 = Reductionops$ReactTemplate.fix_recarg(match$1[0], stack);
              if (match$2) {
                var match$3 = match$2[0];
                var recarg$prime = redrec(env, match$3[1]);
                var stack$prime = Reductionops$ReactTemplate.Stack[/* assign */16](stack, match$3[0], recarg$prime);
                return simpfun(Reductionops$ReactTemplate.Stack[/* zip */21](/* None */0, sigma, /* tuple */[
                                f,
                                stack$prime
                              ]));
              } else {
                throw Redelimination;
              }
            } else {
              return simpfun(EConstr$ReactTemplate.mkApp(/* tuple */[
                              redrec(env, f),
                              l
                            ]));
            }
            break;
        case 13 : 
            return simpfun(EConstr$ReactTemplate.mkCase(/* tuple */[
                            match[0],
                            match[1],
                            redrec(env, match[2]),
                            match[3]
                          ]));
        case 16 : 
            var c = match[1];
            var match$4 = EConstr$ReactTemplate.kind(sigma, c);
            var c$prime;
            c$prime = match$4.tag === 12 ? c : redrec(env, c);
            var pb = Environ$ReactTemplate.lookup_projection(match[0], env);
            var match$5 = reduce_projection(env, sigma, pb, Reductionops$ReactTemplate.whd_betaiotazeta_stack(sigma, c$prime), /* [] */0);
            if (match$5) {
              return simpfun(EConstr$ReactTemplate.applist(match$5[0]));
            } else {
              throw Redelimination;
            }
            break;
        default:
          var match$6 = match_eval_ref(env, sigma, x$1, /* [] */0);
          if (match$6) {
            var match$7 = match$6[0];
            var match$8 = reference_opt_value(env, sigma, match$7[0], match$7[1]);
            if (match$8) {
              return match$8[0];
            } else {
              throw Redelimination;
            }
          } else {
            throw Redelimination;
          }
      }
    };
  };
  return redrec(env, c);
}

function red_product(env, sigma, c) {
  try {
    return try_red_product(env, sigma, c);
  }
  catch (exn){
    if (exn === Redelimination) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No head constant to reduce."));
    } else {
      throw exn;
    }
  }
}

var whd_simpl_stack$1;

if (Flags$ReactTemplate.profile) {
  var key = CProfile$ReactTemplate.declare_profile("whd_simpl_stack");
  whd_simpl_stack$1 = CProfile$ReactTemplate.profile3(key, whd_simpl_stack);
} else {
  whd_simpl_stack$1 = whd_simpl_stack;
}

function whd_simpl_orelse_delta_but_fix(env, sigma, c) {
  var redrec = function (_s) {
    while(true) {
      var s = _s;
      var s$prime = Curry._3(whd_simpl_stack$1, env, sigma, s);
      var stack = s$prime[1];
      var constr = s$prime[0];
      var match = match_eval_ref_value(env, sigma, constr, stack);
      if (match) {
        var c = match[0];
        var match$1 = EConstr$ReactTemplate.kind(sigma, EConstr$ReactTemplate.decompose_lam(sigma, c)[1]);
        switch (match$1.tag | 0) {
          case 14 : 
          case 15 : 
              return s$prime;
          case 16 : 
              var p = match$1[0];
              var match$2 = EConstr$ReactTemplate.kind(sigma, constr);
              var tmp;
              tmp = match$2.tag === 10 ? Names$ReactTemplate.Constant[/* equal */12](Names$ReactTemplate.Projection[/* constant */2](p), match$2[0][0]) : /* false */0;
              if (tmp) {
                var pb = Environ$ReactTemplate.lookup_projection(p, env);
                if (Curry._1(Util$ReactTemplate.List[/* length */0], stack) <= pb[/* proj_npars */1]) {
                  return s$prime;
                } else {
                  _s = EConstr$ReactTemplate.applist(/* tuple */[
                        c,
                        stack
                      ]);
                  continue ;
                  
                }
              } else {
                _s = EConstr$ReactTemplate.applist(/* tuple */[
                      c,
                      stack
                    ]);
                continue ;
                
              }
              break;
          default:
            _s = EConstr$ReactTemplate.applist(/* tuple */[
                  c,
                  stack
                ]);
            continue ;
            
        }
      } else {
        return s$prime;
      }
    };
  };
  var param = EConstr$ReactTemplate.applist(redrec(c));
  return Reductionops$ReactTemplate.clos_norm_flags(CClosure$ReactTemplate.betaiota, env, sigma, param);
}

function whd_simpl(env, sigma, c) {
  return EConstr$ReactTemplate.applist(Curry._3(whd_simpl_stack$1, env, sigma, c));
}

function simpl(env, sigma, c) {
  return Reductionops$ReactTemplate.strong(whd_simpl, env, sigma, c);
}

function matches_head(env, sigma, c, t) {
  var match = EConstr$ReactTemplate.kind(sigma, t);
  switch (match.tag | 0) {
    case 9 : 
        return Constr_matching$ReactTemplate.matches(env, sigma, c, match[0]);
    case 16 : 
        return Constr_matching$ReactTemplate.matches(env, sigma, c, EConstr$ReactTemplate.mkConstU(/* tuple */[
                        Names$ReactTemplate.Projection[/* constant */2](match[0]),
                        EConstr$ReactTemplate.EInstance[/* empty */2]
                      ]));
    default:
      throw Constr_matching$ReactTemplate.PatternMatchingFailure;
  }
}

function e_contextually(byhead, param, f, env, sigma, t) {
  var match = Locusops$ReactTemplate.convert_occs(param[0]);
  var locs = match[1];
  var nowhere_except_in = match[0];
  var maxocc = Curry._3(Util$ReactTemplate.List[/* fold_right */14], Caml_obj.caml_max, locs, 0);
  var pos = [1];
  var evd = [sigma];
  var traverse = function (nested, envc, t) {
    if (nowhere_except_in && pos[0] > maxocc) {
      return t;
    } else {
      var c = envc[1];
      var env = envc[0];
      try {
        var subst = byhead ? matches_head(env, sigma, c, t) : Constr_matching$ReactTemplate.matches(env, sigma, c, t);
        var ok = nowhere_except_in ? Curry._2(Int$ReactTemplate.List[/* mem */0], pos[0], locs) : 1 - Curry._2(Int$ReactTemplate.List[/* mem */0], pos[0], locs);
        pos[0] = pos[0] + 1 | 0;
        if (ok) {
          if (Option$ReactTemplate.has_some(nested)) {
            CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The subterm at occurrence "), Pp$ReactTemplate.$$int(Option$ReactTemplate.get(nested))), Pp$ReactTemplate.str(" overlaps with the subterm at occurrence ")), Pp$ReactTemplate.$$int(pos[0] - 1 | 0)), Pp$ReactTemplate.str(".")));
          }
          if (locs !== /* [] */0) {
            traverse_below(/* Some */[pos[0] - 1 | 0], envc, t);
          }
          var match = Curry._4(f, subst, env, evd[0], t);
          evd[0] = match[0];
          return match[1];
        } else {
          return traverse_below(nested, envc, t);
        }
      }
      catch (exn){
        if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
          return traverse_below(nested, envc, t);
        } else {
          throw exn;
        }
      }
    }
  };
  var traverse_below = function (nested, envc, t) {
    var match = EConstr$ReactTemplate.kind(evd[0], t);
    var exit = 0;
    switch (match.tag | 0) {
      case 9 : 
          if (byhead) {
            return EConstr$ReactTemplate.mkApp(/* tuple */[
                        match[0],
                        Util$ReactTemplate.$$Array[/* map_left */52]((function (param) {
                                return traverse(nested, envc, param);
                              }), match[1])
                      ]);
          } else {
            exit = 1;
          }
          break;
      case 16 : 
          if (byhead) {
            return EConstr$ReactTemplate.mkProj(/* tuple */[
                        match[0],
                        traverse(nested, envc, match[1])
                      ]);
          } else {
            exit = 1;
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      var g = function (d, param) {
        return /* tuple */[
                EConstr$ReactTemplate.push_rel(d, param[0]),
                Patternops$ReactTemplate.lift_pattern(1)(param[1])
              ];
      };
      var f = function (param, param$1) {
        return traverse(nested, param, param$1);
      };
      var acc = envc;
      var sigma$1 = sigma;
      var c = t;
      var match$1 = EConstr$ReactTemplate.kind(sigma$1, c);
      if (match$1.tag === 16) {
        var p = match$1[0];
        var t$1 = Retyping$ReactTemplate.expand_projection(acc[0], sigma$1, p, match$1[1], /* [] */0);
        var match$2 = EConstr$ReactTemplate.destApp(sigma$1, t$1);
        var al = match$2[1];
        var hdf = match$2[0];
        var a = Caml_array.caml_array_get(al, al.length - 1 | 0);
        var app = EConstr$ReactTemplate.mkApp(/* tuple */[
              hdf,
              Util$ReactTemplate.$$Array[/* sub */5](al, 0, al.length - 1 | 0)
            ]);
        var app$prime = Curry._2(f, acc, app);
        var a$prime = Curry._2(f, acc, a);
        var match$3 = EConstr$ReactTemplate.kind(sigma$1, app$prime);
        if (match$3.tag === 9) {
          if (match$3[0] === hdf) {
            return EConstr$ReactTemplate.mkProj(/* tuple */[
                        p,
                        a$prime
                      ]);
          } else {
            return EConstr$ReactTemplate.mkApp(/* tuple */[
                        app$prime,
                        /* array */[a$prime]
                      ]);
          }
        } else {
          return EConstr$ReactTemplate.mkApp(/* tuple */[
                      app$prime,
                      /* array */[a$prime]
                    ]);
        }
      } else {
        return Termops$ReactTemplate.map_constr_with_binders_left_to_right(sigma$1, g, f, acc, c);
      }
    }
    
  };
  var t$prime = traverse(/* None */0, /* tuple */[
        env,
        param[1]
      ], t);
  if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (o) {
            return +(o >= pos[0]);
          }), locs)) {
    Find_subterm$ReactTemplate.error_invalid_occurrence(locs);
  }
  return /* tuple */[
          evd[0],
          t$prime
        ];
}

function contextually(byhead, occs, f, env, sigma, t) {
  var f$prime = function (subst, env, sigma, t) {
    return /* tuple */[
            sigma,
            Curry._4(f, subst, env, sigma, t)
          ];
  };
  return e_contextually(byhead, occs, f$prime, env, sigma, t)[1];
}

function match_constr_evaluable_ref(sigma, c, evref) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 1 : 
        if (!evref.tag && Names$ReactTemplate.Id[/* equal */0](match[0], evref[0])) {
          return /* Some */[EConstr$ReactTemplate.EInstance[/* empty */2]];
        } else {
          return /* None */0;
        }
        break;
    case 10 : 
        var match$1 = match[0];
        if (!evref.tag || !Names$ReactTemplate.Constant[/* equal */12](match$1[0], evref[0])) {
          return /* None */0;
        } else {
          return /* Some */[match$1[1]];
        }
        break;
    default:
      return /* None */0;
  }
}

function substlin(env, sigma, evalref, n, param, c) {
  var locs = param[1];
  var nowhere_except_in = param[0];
  var maxocc = Curry._3(Util$ReactTemplate.List[/* fold_right */14], Caml_obj.caml_max, locs, 0);
  var pos = [n];
  if (!Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (x) {
            return +(x >= 0);
          }), locs)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "tacred.ml",
            1060,
            2
          ]
        ];
  }
  var substrec = function (_, c) {
    if (nowhere_except_in && pos[0] > maxocc) {
      return c;
    } else {
      var match = match_constr_evaluable_ref(sigma, c, evalref);
      if (match) {
        var ok = nowhere_except_in ? Curry._2(Int$ReactTemplate.List[/* mem */0], pos[0], locs) : 1 - Curry._2(Int$ReactTemplate.List[/* mem */0], pos[0], locs);
        pos[0] = pos[0] + 1 | 0;
        if (ok) {
          var env$1 = env;
          var evref = evalref;
          var u = match[0];
          if (evref.tag) {
            var u$1 = EConstr$ReactTemplate.Unsafe[/* to_instance */4](u);
            return EConstr$ReactTemplate.of_constr(Environ$ReactTemplate.constant_value_in(env$1, /* tuple */[
                            evref[0],
                            u$1
                          ]));
          } else {
            return Option$ReactTemplate.get(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], EConstr$ReactTemplate.lookup_named(evref[0], env$1)));
          }
        } else {
          return c;
        }
      } else {
        return Termops$ReactTemplate.map_constr_with_binders_left_to_right(sigma, (function (_, _$1) {
                      return /* () */0;
                    }), substrec, /* () */0, c);
      }
    }
  };
  var t$prime = substrec(/* () */0, c);
  return /* tuple */[
          pos[0],
          t$prime
        ];
}

function string_of_evaluable_ref(env, param) {
  if (param.tag) {
    return Libnames$ReactTemplate.string_of_qualid(Nametab$ReactTemplate.shortest_qualid_of_global(Termops$ReactTemplate.vars_of_env(env), /* ConstRef */Block.__(1, [param[0]])));
  } else {
    return Names$ReactTemplate.Id[/* to_string */7](param[0]);
  }
}

function unfoldn(loccname, env, sigma, c) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (c, occname) {
                var env$1 = env;
                var sigma$1 = sigma;
                var param = occname;
                var c$1 = c;
                var name = param[1];
                var occs = param[0];
                var unfo = function (nowhere_except_in, locs) {
                  var match = substlin(env$1, sigma$1, name, 1, /* tuple */[
                        nowhere_except_in,
                        locs
                      ], c$1);
                  var nbocc = match[0];
                  if (nbocc === 1) {
                    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(string_of_evaluable_ref(env$1, name) + " does not occur."));
                  }
                  var rest = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (o) {
                          return +(o >= nbocc);
                        }), locs);
                  if (rest) {
                    Find_subterm$ReactTemplate.error_invalid_occurrence(rest);
                  }
                  return Reductionops$ReactTemplate.nf_betaiotazeta(env$1, sigma$1, match[1]);
                };
                if (typeof occs === "number") {
                  if (occs) {
                    return c$1;
                  } else {
                    var env$2 = env$1;
                    var sigma$2 = sigma$1;
                    var name$1 = name;
                    var c$2 = c$1;
                    if (is_evaluable(env$2, name$1)) {
                      return Reductionops$ReactTemplate.clos_norm_flags(CClosure$ReactTemplate.unfold_red(name$1), env$2, sigma$2, c$2);
                    } else {
                      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(string_of_evaluable_ref(env$2, name$1) + " is opaque."));
                    }
                  }
                } else if (occs.tag) {
                  return unfo(/* true */1, occs[0]);
                } else {
                  return unfo(/* false */0, occs[0]);
                }
              }), c, loccname);
}

function fold_commands(cl, env, sigma, c) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (com, c) {
                var com$1 = com;
                var env$1 = env;
                var sigma$1 = sigma;
                var c$1 = c;
                var rcom;
                try {
                  rcom = red_product(env$1, sigma$1, com$1);
                }
                catch (exn){
                  if (exn === Redelimination) {
                    rcom = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not reducible."));
                  } else {
                    throw exn;
                  }
                }
                var a = Termops$ReactTemplate.subst_term(sigma$1, Reductionops$ReactTemplate.clos_norm_flags(CClosure$ReactTemplate.unfold_side_red, env$1, sigma$1, rcom), c$1);
                if (EConstr$ReactTemplate.eq_constr(sigma$1, a, c$1)) {
                  var a$1 = Termops$ReactTemplate.subst_term(sigma$1, rcom, c$1);
                  return EConstr$ReactTemplate.Vars[/* subst1 */4](com$1, a$1);
                } else {
                  return EConstr$ReactTemplate.Vars[/* subst1 */4](com$1, a);
                }
              }), Curry._1(Util$ReactTemplate.List[/* rev */4], cl), c);
}

function cbv_norm_flags(flags, env, sigma, t) {
  return Cbv$ReactTemplate.cbv_norm(Cbv$ReactTemplate.create_cbv_infos(flags, env, sigma), t);
}

function cbv_beta(param, param$1) {
  return cbv_norm_flags(CClosure$ReactTemplate.beta, Environ$ReactTemplate.empty_env, param, param$1);
}

function cbv_betaiota(param, param$1) {
  return cbv_norm_flags(CClosure$ReactTemplate.betaiota, Environ$ReactTemplate.empty_env, param, param$1);
}

function cbv_betadeltaiota(env, sigma) {
  return (function (param) {
      return cbv_norm_flags(CClosure$ReactTemplate.all, env, sigma, param);
    });
}

function pattern_occs(loccs_trm, env, sigma, c) {
  var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
          var env$1 = env;
          var param$2 = param;
          var param$3 = param$1;
          var sigma$1 = param$3[1];
          var c = param$3[0];
          var a = param$2[1];
          var ta = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env$1, sigma$1, a);
          var na = Namegen$ReactTemplate.named_hd(env$1, sigma$1, ta, /* Anonymous */0);
          if (Termops$ReactTemplate.occur_meta(sigma$1, ta)) {
            CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot find a type for the generalisation."));
          }
          if (Termops$ReactTemplate.occur_meta(sigma$1, a)) {
            return /* tuple */[
                    EConstr$ReactTemplate.mkLambda(/* tuple */[
                          na,
                          ta,
                          c
                        ]),
                    sigma$1
                  ];
          } else {
            var match = Find_subterm$ReactTemplate.subst_closed_term_occ(env$1, sigma$1, /* AtOccs */[param$2[0]], a, c);
            return /* tuple */[
                    EConstr$ReactTemplate.mkLambda(/* tuple */[
                          na,
                          ta,
                          match[0]
                        ]),
                    match[1]
                  ];
          }
        }), loccs_trm, /* tuple */[
        c,
        sigma
      ]);
  var sigma$1 = match[1];
  var abstr_trm = match[0];
  try {
    Typing$ReactTemplate.unsafe_type_of(env, sigma$1, abstr_trm);
    return /* tuple */[
            sigma$1,
            EConstr$ReactTemplate.applist(/* tuple */[
                  abstr_trm,
                  Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                          return prim[1];
                        }), loccs_trm)
                ])
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Type_errors$ReactTemplate.TypeError) {
      throw [
            ReductionTacticError,
            /* InvalidAbstraction */[
              env,
              sigma$1,
              abstr_trm,
              /* tuple */[
                exn[1],
                exn[2]
              ]
            ]
          ];
    } else {
      throw exn;
    }
  }
}

function check_privacy(env, ind) {
  var spec = Inductive$ReactTemplate.lookup_mind_specif(env, ind[0]);
  if (Inductive$ReactTemplate.is_private(spec)) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("case analysis on a private type."));
  } else {
    return ind;
  }
}

function check_not_primitive_record(env, ind) {
  var spec = Inductive$ReactTemplate.lookup_mind_specif(env, ind[0]);
  if (Inductive$ReactTemplate.is_primitive_record(spec)) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("case analysis on a primitive record type: "), Pp$ReactTemplate.str("use projections or let instead.")));
  } else {
    return ind;
  }
}

function reduce_to_ind_gen(allow_product, env, sigma, t) {
  var _env = env;
  var _t = t;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var t$1 = _t;
    var env$1 = _env;
    var t$2 = whd_simpl_orelse_delta_but_fix(env$1, sigma, t$1);
    var match = EConstr$ReactTemplate.kind(sigma, Termops$ReactTemplate.decompose_app_vect(sigma, t$2)[0]);
    switch (match.tag | 0) {
      case 6 : 
          var ty = match[1];
          var n = match[0];
          if (allow_product) {
            _l = /* :: */[
              /* LocalAssum */Block.__(0, [
                  n,
                  ty
                ]),
              l
            ];
            _t = match[2];
            _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                    n,
                    ty
                  ]), env$1);
            continue ;
            
          } else {
            return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not an inductive definition."));
          }
          break;
      case 11 : 
          return /* tuple */[
                  check_privacy(env$1, match[0]),
                  EConstr$ReactTemplate.it_mkProd_or_LetIn(t$2, l)
                ];
      default:
        var t$prime = Reductionops$ReactTemplate.whd_all(env$1)(sigma, t$2);
        var match$1 = EConstr$ReactTemplate.kind(sigma, Termops$ReactTemplate.decompose_app_vect(sigma, t$prime)[0]);
        if (match$1.tag === 11) {
          return /* tuple */[
                  check_privacy(env$1, match$1[0]),
                  EConstr$ReactTemplate.it_mkProd_or_LetIn(t$prime, l)
                ];
        } else {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not an inductive product."));
        }
    }
  };
}

function reduce_to_quantified_ind(env, sigma, c) {
  return reduce_to_ind_gen(/* true */1, env, sigma, c);
}

function reduce_to_atomic_ind(env, sigma, c) {
  return reduce_to_ind_gen(/* false */0, env, sigma, c);
}

function find_hnf_rectype(env, sigma, t) {
  var match = reduce_to_atomic_ind(env, sigma, t);
  return /* tuple */[
          match[0],
          EConstr$ReactTemplate.decompose_app(sigma, match[1])[1]
        ];
}

var NotStepReducible = Caml_exceptions.create("Tacred-ReactTemplate.NotStepReducible");

function one_step_reduce(env, sigma, c) {
  var redrec = function (_param) {
    while(true) {
      var param = _param;
      var stack = param[1];
      var x = param[0];
      var match = EConstr$ReactTemplate.kind(sigma, x);
      switch (match.tag | 0) {
        case 5 : 
            _param = /* tuple */[
              match[0],
              stack
            ];
            continue ;
            case 7 : 
            if (stack) {
              return /* tuple */[
                      EConstr$ReactTemplate.Vars[/* subst1 */4](stack[0], match[2]),
                      stack[1]
                    ];
            } else {
              throw NotStepReducible;
            }
            break;
        case 8 : 
            return /* tuple */[
                    EConstr$ReactTemplate.Vars[/* subst1 */4](match[1], match[3]),
                    stack
                  ];
        case 9 : 
            _param = /* tuple */[
              match[0],
              Util$ReactTemplate.$at(Util$ReactTemplate.$$Array[/* to_list */9](match[1]), stack)
            ];
            continue ;
            case 13 : 
            try {
              return /* tuple */[
                      special_red_case(env, sigma, Curry._2(whd_simpl_stack$1, env, sigma), /* tuple */[
                            match[0],
                            match[1],
                            match[2],
                            match[3]
                          ]),
                      stack
                    ];
            }
            catch (exn){
              if (exn === Redelimination) {
                throw NotStepReducible;
              } else {
                throw exn;
              }
            }
            break;
        case 14 : 
            try {
              var match$1 = reduce_fix((function (param, param$1) {
                      return whd_construct_stack(env, param, param$1);
                    }), sigma, match[0], stack);
              if (match$1) {
                return match$1[0];
              } else {
                throw NotStepReducible;
              }
            }
            catch (exn$1){
              if (exn$1 === Redelimination) {
                throw NotStepReducible;
              } else {
                throw exn$1;
              }
            }
            break;
        default:
          if (isEvalRef(env, sigma, x)) {
            var match$2 = destEvalRefU(sigma, x);
            var u = match$2[1];
            var ref = match$2[0];
            try {
              return red_elim_const(env, sigma, ref, u, stack)[0];
            }
            catch (exn$2){
              if (exn$2 === Redelimination) {
                var match$3 = reference_opt_value(env, sigma, ref, u);
                if (match$3) {
                  return /* tuple */[
                          match$3[0],
                          stack
                        ];
                } else {
                  throw NotStepReducible;
                }
              } else {
                throw exn$2;
              }
            }
          } else {
            throw NotStepReducible;
          }
      }
    };
  };
  return EConstr$ReactTemplate.applist(redrec(/* tuple */[
                  c,
                  /* [] */0
                ]));
}

function error_cannot_recognize(ref) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot recognize a statement based on "), Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], ref)), Pp$ReactTemplate.str(".")));
}

function reduce_to_ref_gen(allow_product, env, sigma, ref, t) {
  if (Globnames$ReactTemplate.isIndRef(ref)) {
    var match = reduce_to_ind_gen(allow_product, env, sigma, t);
    if (ref.tag === 2 && Names$ReactTemplate.eq_ind(match[0][0], ref[0])) {
      return match[1];
    } else {
      return error_cannot_recognize(ref);
    }
  } else {
    var elimrec = function (_env, _t, _l) {
      while(true) {
        var l = _l;
        var t = _t;
        var env = _env;
        var match = Termops$ReactTemplate.decompose_app_vect(sigma, t);
        var c = match[0];
        var match$1 = EConstr$ReactTemplate.kind(sigma, c);
        if (match$1.tag === 6) {
          var n = match$1[0];
          if (allow_product) {
            _l = /* :: */[
              /* LocalAssum */Block.__(0, [
                  n,
                  match$1[1]
                ]),
              l
            ];
            _t = match$1[2];
            _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                    n,
                    t
                  ]), env);
            continue ;
            
          } else {
            return error_cannot_recognize(ref);
          }
        } else {
          try {
            if (Globnames$ReactTemplate.eq_gr(Termops$ReactTemplate.global_of_constr(sigma, c)[0], ref)) {
              return EConstr$ReactTemplate.it_mkProd_or_LetIn(t, l);
            } else {
              throw Caml_builtin_exceptions.not_found;
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              try {
                var t$prime = Reductionops$ReactTemplate.nf_betaiota(env, sigma, one_step_reduce(env, sigma, t));
                return elimrec(env, t$prime, l);
              }
              catch (exn$1){
                if (exn$1 === NotStepReducible) {
                  return error_cannot_recognize(ref);
                } else {
                  throw exn$1;
                }
              }
            } else {
              throw exn;
            }
          }
        }
      };
    };
    return elimrec(env, t, /* [] */0);
  }
}

function reduce_to_quantified_ref(param, param$1, param$2, param$3) {
  return reduce_to_ref_gen(/* true */1, param, param$1, param$2, param$3);
}

function reduce_to_atomic_ref(param, param$1, param$2, param$3) {
  return reduce_to_ref_gen(/* false */0, param, param$1, param$2, param$3);
}

var hnf_constr = whd_simpl_orelse_delta_but_fix;

var compute = cbv_betadeltaiota;

exports.ReductionTacticError = ReductionTacticError;
exports.is_evaluable = is_evaluable;
exports.error_not_evaluable = error_not_evaluable;
exports.evaluable_of_global_reference = evaluable_of_global_reference;
exports.global_of_evaluable_reference = global_of_evaluable_reference;
exports.Redelimination = Redelimination;
exports.red_product = red_product;
exports.try_red_product = try_red_product;
exports.simpl = simpl;
exports.whd_simpl = whd_simpl;
exports.hnf_constr = hnf_constr;
exports.unfoldn = unfoldn;
exports.fold_commands = fold_commands;
exports.pattern_occs = pattern_occs;
exports.cbv_norm_flags = cbv_norm_flags;
exports.cbv_beta = cbv_beta;
exports.cbv_betaiota = cbv_betaiota;
exports.cbv_betadeltaiota = cbv_betadeltaiota;
exports.compute = compute;
exports.reduce_to_atomic_ind = reduce_to_atomic_ind;
exports.reduce_to_quantified_ind = reduce_to_quantified_ind;
exports.reduce_to_quantified_ref = reduce_to_quantified_ref;
exports.reduce_to_atomic_ref = reduce_to_atomic_ref;
exports.find_hnf_rectype = find_hnf_rectype;
exports.contextually = contextually;
exports.e_contextually = e_contextually;
exports.check_privacy = check_privacy;
exports.check_not_primitive_record = check_not_primitive_record;
/* eval_table Not a pure module */
