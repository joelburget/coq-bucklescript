// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("bs-platform/lib/js/sys.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Cases$ReactTemplate = require("./cases.bs.js");
var Himsg$ReactTemplate = require("./himsg.bs.js");
var Logic$ReactTemplate = require("./logic.bs.js");
var Token$ReactTemplate = require("../camlp5/ocaml_src/lib/token.bs.js");
var CLexer$ReactTemplate = require("./cLexer.bs.js");
var Indrec$ReactTemplate = require("./indrec.bs.js");
var Modops$ReactTemplate = require("./modops.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Tacred$ReactTemplate = require("./tacred.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Refiner$ReactTemplate = require("./refiner.bs.js");
var Indtypes$ReactTemplate = require("./indtypes.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var Logic_monad$ReactTemplate = require("./logic_monad.bs.js");
var Type_errors$ReactTemplate = require("./type_errors.bs.js");
var Constrextern$ReactTemplate = require("./constrextern.bs.js");
var Pretype_errors$ReactTemplate = require("./pretype_errors.bs.js");
var Typeclasses_errors$ReactTemplate = require("./typeclasses_errors.bs.js");

function guill(s) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("\""), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str("\""));
}

var EvaluatedError = Caml_exceptions.create("ExplainErr-ReactTemplate.EvaluatedError");

function explain_exn_default(param) {
  if (param[0] === Stream.$$Error) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Syntax error: "), Pp$ReactTemplate.str(param[1])), Pp$ReactTemplate.str(".")));
  } else if (param[0] === Token$ReactTemplate.$$Error) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Syntax error: "), Pp$ReactTemplate.str(param[1])), Pp$ReactTemplate.str(".")));
  } else if (param[0] === CLexer$ReactTemplate.$$Error[/* E */0]) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.str(CLexer$ReactTemplate.$$Error[/* to_string */1](param[1])));
  } else if (param[0] === Caml_builtin_exceptions.sys_error) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("System error: "), guill(param[1])));
  } else if (param === Caml_builtin_exceptions.out_of_memory) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.str("Out of memory."));
  } else if (param === Caml_builtin_exceptions.stack_overflow) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.str("Stack overflow."));
  } else if (param === CErrors$ReactTemplate.Timeout) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.str("Timeout!"));
  } else if (param === Sys.Break) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str("User interrupt.")));
  } else if (param[0] === EvaluatedError) {
    var match = param[2];
    var msg = param[1];
    if (match) {
      return Pp$ReactTemplate.$plus$plus(msg, CErrors$ReactTemplate.print(/* None */0, match[0]));
    } else {
      return msg;
    }
  } else {
    throw CErrors$ReactTemplate.Unhandled;
  }
}

CErrors$ReactTemplate.register_handler(explain_exn_default);

function wrap_vernac_error(param, strm) {
  return /* tuple */[
          [
            EvaluatedError,
            strm,
            /* None */0
          ],
          param[1]
        ];
}

function process_vernac_interp_error(exn) {
  var match = exn[0];
  if (match[0] === Univ$ReactTemplate.UniverseInconsistency) {
    var msg = Constrextern$ReactTemplate.print_universes[0] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("."), Pp$ReactTemplate.spc(/* () */0)), Univ$ReactTemplate.explain_universe_inconsistency(Universes$ReactTemplate.pr_with_global_universes, match[1])) : Pp$ReactTemplate.mt(/* () */0);
    return wrap_vernac_error(exn, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Universe inconsistency"), msg), Pp$ReactTemplate.str(".")));
  } else if (match[0] === Type_errors$ReactTemplate.TypeError) {
    var te = Himsg$ReactTemplate.map_ptype_error(EConstr$ReactTemplate.of_constr, match[2]);
    return wrap_vernac_error(exn, Himsg$ReactTemplate.explain_type_error(match[1], Evd$ReactTemplate.empty, te));
  } else if (match[0] === Pretype_errors$ReactTemplate.PretypeError) {
    return wrap_vernac_error(exn, Himsg$ReactTemplate.explain_pretype_error(match[1], match[2], match[3]));
  } else if (match[0] === Typeclasses_errors$ReactTemplate.TypeClassError) {
    return wrap_vernac_error(exn, Himsg$ReactTemplate.explain_typeclass_error(match[1], match[2]));
  } else if (match[0] === Indtypes$ReactTemplate.InductiveError) {
    return wrap_vernac_error(exn, Himsg$ReactTemplate.explain_inductive_error(match[1]));
  } else if (match[0] === Modops$ReactTemplate.ModuleTypingError) {
    return wrap_vernac_error(exn, Himsg$ReactTemplate.explain_module_error(match[1]));
  } else if (match[0] === Indrec$ReactTemplate.RecursionSchemeError) {
    return wrap_vernac_error(exn, Himsg$ReactTemplate.explain_recursion_scheme_error(match[1]));
  } else if (match[0] === Cases$ReactTemplate.PatternMatchingError) {
    return wrap_vernac_error(exn, Himsg$ReactTemplate.explain_pattern_matching_error(match[1], match[2], match[3]));
  } else if (match[0] === Tacred$ReactTemplate.ReductionTacticError) {
    return wrap_vernac_error(exn, Himsg$ReactTemplate.explain_reduction_tactic_error(match[1]));
  } else if (match[0] === Logic$ReactTemplate.RefinerError) {
    return wrap_vernac_error(exn, Himsg$ReactTemplate.explain_refiner_error(match[1], match[2], match[3]));
  } else if (match[0] === Nametab$ReactTemplate.GlobalizationError) {
    return wrap_vernac_error(exn, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The reference"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_qualid(match[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("was not found")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("in the current")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("environment.")));
  } else if (match[0] === Refiner$ReactTemplate.FailError) {
    var s = match[2];
    var i = match[1];
    var tag = s.tag | 0;
    var s$1 = tag === 250 ? s[0] : (
        tag === 246 ? CamlinternalLazy.force_lazy_block(s) : s
      );
    return wrap_vernac_error(exn, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Tactic failure"), Pp$ReactTemplate.ismt(s$1) ? s$1 : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(": "), s$1)), i ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" (level "), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(").")) : Pp$ReactTemplate.str(".")));
  } else if (match[0] === CErrors$ReactTemplate.AlreadyDeclared) {
    return wrap_vernac_error(exn, Pp$ReactTemplate.$plus$plus(match[1], Pp$ReactTemplate.str(".")));
  } else {
    return exn;
  }
}

function strip_wrapping_exceptions(_exc) {
  while(true) {
    var exc = _exc;
    if (exc[0] === Logic_monad$ReactTemplate.TacticFailure) {
      _exc = exc[1];
      continue ;
      
    } else {
      return exc;
    }
  };
}

var additional_error_info = [/* [] */0];

function register_additional_error_info(f) {
  additional_error_info[0] = /* :: */[
    f,
    additional_error_info[0]
  ];
  return /* () */0;
}

function process_vernac_interp_error$1($staropt$star, param) {
  var allow_uncaught = $staropt$star ? $staropt$star[0] : /* true */1;
  var exc = strip_wrapping_exceptions(param[0]);
  var e = process_vernac_interp_error(/* tuple */[
        exc,
        param[1]
      ]);
  if (!allow_uncaught && !CErrors$ReactTemplate.handled(e[0])) {
    var msg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Uncaught exception "), Pp$ReactTemplate.str(Printexc.to_string(e[0]))), Pp$ReactTemplate.str("."));
    var err = CErrors$ReactTemplate.make_anomaly(/* None */0, msg);
    Util$ReactTemplate.iraise(/* tuple */[
          err,
          e[1]
        ]);
  }
  var e$prime;
  try {
    e$prime = /* Some */[CList$ReactTemplate.find_map((function (f) {
              return Curry._1(f, e);
            }), additional_error_info[0])];
  }
  catch (exn){
    e$prime = /* None */0;
  }
  var add_loc_opt = function (loc, info) {
    return Option$ReactTemplate.cata((function (l) {
                  return Loc$ReactTemplate.add_loc(info, l);
                }), info, loc);
  };
  if (e$prime) {
    var match = e$prime[0];
    var match$1 = match[1];
    var loc = match[0];
    if (match$1) {
      return /* tuple */[
              [
                EvaluatedError,
                match$1[0],
                /* Some */[e[0]]
              ],
              add_loc_opt(loc, e[1])
            ];
    } else {
      return /* tuple */[
              e[0],
              add_loc_opt(loc, e[1])
            ];
    }
  } else {
    return e;
  }
}

exports.EvaluatedError = EvaluatedError;
exports.process_vernac_interp_error = process_vernac_interp_error$1;
exports.explain_exn_default = explain_exn_default;
exports.register_additional_error_info = register_additional_error_info;
/*  Not a pure module */
