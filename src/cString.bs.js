// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Set = require("bs-platform/lib/js/set.js");
var List = require("bs-platform/lib/js/list.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var CMap$ReactTemplate = require("./cMap.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Hashcons$ReactTemplate = require("./hashcons.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function hash(s) {
  var len = s.length;
  var len$1 = len;
  var s$1 = s;
  var _i = 0;
  var _accu = 0;
  while(true) {
    var accu = _accu;
    var i = _i;
    if (i === len$1) {
      return accu;
    } else {
      var c = s$1.charCodeAt(i);
      _accu = Caml_int32.imul(accu, 19) + c | 0;
      _i = i + 1 | 0;
      continue ;
      
    }
  };
}

function explode(s) {
  var explode_rec = function (n) {
    if (n >= s.length) {
      return /* [] */0;
    } else {
      return /* :: */[
              $$String.make(1, Caml_string.get(s, n)),
              explode_rec(n + 1 | 0)
            ];
    }
  };
  return explode_rec(0);
}

function implode(sl) {
  return $$String.concat("", sl);
}

function is_blank(param) {
  var switcher = param - 9 | 0;
  if (switcher > 4 || switcher < 0) {
    if (switcher !== 23) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  } else if (switcher === 3 || switcher === 2) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function is_empty(s) {
  return +(s.length === 0);
}

function strip(s) {
  var n = s.length;
  var lstrip_rec = function (_i) {
    while(true) {
      var i = _i;
      if (i < n && is_blank(Caml_string.get(s, i))) {
        _i = i + 1 | 0;
        continue ;
        
      } else {
        return i;
      }
    };
  };
  var rstrip_rec = function (_i) {
    while(true) {
      var i = _i;
      if (i >= 0 && is_blank(Caml_string.get(s, i))) {
        _i = i - 1 | 0;
        continue ;
        
      } else {
        return i;
      }
    };
  };
  var a = lstrip_rec(0);
  var b = rstrip_rec(n - 1 | 0);
  return $$String.sub(s, a, (b - a | 0) + 1 | 0);
}

function drop_simple_quotes(s) {
  var n = s.length;
  if (n > 2 && Caml_string.get(s, 0) === /* "'" */39 && Caml_string.get(s, n - 1 | 0) === /* "'" */39) {
    return $$String.sub(s, 1, n - 2 | 0);
  } else {
    return s;
  }
}

function raw_is_sub(gdzie, _, _gi, co, cl, _ci) {
  while(true) {
    var ci = _ci;
    var gi = _gi;
    if (ci >= cl) {
      return /* true */1;
    } else if (gdzie[gi] === co[ci]) {
      _ci = ci + 1 | 0;
      _gi = gi + 1 | 0;
      continue ;
      
    } else {
      return /* false */0;
    }
  };
}

function string_index_from(gdzie, i, co) {
  if (co === "") {
    return i;
  } else {
    var _i = i;
    var gdzie$1 = gdzie;
    var l = gdzie.length;
    var c = co.charCodeAt(0);
    var co$1 = co;
    var cl = co.length;
    while(true) {
      var i$1 = _i;
      if ((i$1 + cl | 0) > l) {
        throw Caml_builtin_exceptions.not_found;
      }
      var i$prime = $$String.index_from(gdzie$1, i$1, c);
      if ((i$prime + cl | 0) <= l && raw_is_sub(gdzie$1, l, i$prime, co$1, cl, 0)) {
        return i$prime;
      } else {
        _i = i$prime + 1 | 0;
        continue ;
        
      }
    };
  }
}

function string_contains(where, what) {
  try {
    string_index_from(where, 0, what);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_sub(p, s, off) {
  var lp = p.length;
  var ls = s.length;
  if (ls < (off + lp | 0)) {
    return /* false */0;
  } else {
    var _i = 0;
    while(true) {
      var i = _i;
      if (lp <= i) {
        return /* true */1;
      } else {
        var cp = p.charCodeAt(i);
        var cs = s.charCodeAt(off + i | 0);
        if (cp === cs) {
          _i = i + 1 | 0;
          continue ;
          
        } else {
          return /* false */0;
        }
      }
    };
  }
}

function plural(n, s) {
  if (n !== 1) {
    return s + "s";
  } else {
    return s;
  }
}

function conjugate_verb_to_be(n) {
  if (n !== 1) {
    return "are";
  } else {
    return "is";
  }
}

function ordinal(n) {
  var s;
  if ((n / 10 | 0) % 10 === 1) {
    s = "th";
  } else {
    var match = n % 10;
    var switcher = match - 1 | 0;
    if (switcher > 2 || switcher < 0) {
      s = "th";
    } else {
      switch (switcher) {
        case 0 : 
            s = "st";
            break;
        case 1 : 
            s = "nd";
            break;
        case 2 : 
            s = "rd";
            break;
        
      }
    }
  }
  return Pervasives.string_of_int(n) + s;
}

function split(c, s) {
  var len = s.length;
  var split$1 = function (n) {
    try {
      var pos = $$String.index_from(s, n, c);
      var dir = $$String.sub(s, n, pos - n | 0);
      return /* :: */[
              dir,
              split$1(pos + 1 | 0)
            ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* :: */[
                $$String.sub(s, n, len - n | 0),
                /* [] */0
              ];
      } else {
        throw exn;
      }
    }
  };
  if (len) {
    return split$1(0);
  } else {
    return /* [] */0;
  }
}

var Self = /* module */[/* compare */$$String.compare];

var $$Set$1 = $$Set.Make(Self);

var $$Map = CMap$ReactTemplate.Make(Self);

function mem(id, l) {
  return List.exists((function (s) {
                return +(id === s);
              }), l);
}

function assoc(id, l) {
  return CList$ReactTemplate.assoc_f((function (prim, prim$1) {
                return +(prim === prim$1);
              }), id, l);
}

function remove_assoc(id, l) {
  return CList$ReactTemplate.remove_assoc_f((function (prim, prim$1) {
                return +(prim === prim$1);
              }), id, l);
}

function mem_assoc(id, l) {
  return List.exists((function (param) {
                return +(id === param[0]);
              }), l);
}

function mem_assoc_sym(id, l) {
  return List.exists((function (param) {
                return +(id === param[1]);
              }), l);
}

function equal(l, l$prime) {
  return CList$ReactTemplate.equal((function (prim, prim$1) {
                return +(prim === prim$1);
              }), l, l$prime);
}

var hcons = Hashcons$ReactTemplate.simple_hcons(Hashcons$ReactTemplate.Hstring[/* generate */0], Hashcons$ReactTemplate.Hstring[/* hcons */1], /* () */0);

var make = $$String.make;

var init = $$String.init;

var copy = $$String.copy;

var sub = $$String.sub;

var fill = $$String.fill;

var blit = $$String.blit;

var concat = $$String.concat;

var iter = $$String.iter;

var iteri = $$String.iteri;

var map = $$String.map;

var mapi = $$String.mapi;

var trim = $$String.trim;

var escaped = $$String.escaped;

var index = $$String.index;

var rindex = $$String.rindex;

var index_from = $$String.index_from;

var rindex_from = $$String.rindex_from;

var contains = $$String.contains;

var contains_from = $$String.contains_from;

var rcontains_from = $$String.rcontains_from;

var uppercase = $$String.uppercase;

var lowercase = $$String.lowercase;

var capitalize = $$String.capitalize;

var uncapitalize = $$String.uncapitalize;

var compare = $$String.compare;

var List$1 = [
  equal,
  mem,
  assoc,
  mem_assoc,
  remove_assoc,
  mem_assoc_sym
];

exports.make = make;
exports.init = init;
exports.copy = copy;
exports.sub = sub;
exports.fill = fill;
exports.blit = blit;
exports.concat = concat;
exports.iter = iter;
exports.iteri = iteri;
exports.map = map;
exports.mapi = mapi;
exports.trim = trim;
exports.escaped = escaped;
exports.index = index;
exports.rindex = rindex;
exports.index_from = index_from;
exports.rindex_from = rindex_from;
exports.contains = contains;
exports.contains_from = contains_from;
exports.rcontains_from = rcontains_from;
exports.uppercase = uppercase;
exports.lowercase = lowercase;
exports.capitalize = capitalize;
exports.uncapitalize = uncapitalize;
exports.compare = compare;
exports.hash = hash;
exports.is_empty = is_empty;
exports.explode = explode;
exports.implode = implode;
exports.strip = strip;
exports.drop_simple_quotes = drop_simple_quotes;
exports.string_index_from = string_index_from;
exports.string_contains = string_contains;
exports.plural = plural;
exports.conjugate_verb_to_be = conjugate_verb_to_be;
exports.ordinal = ordinal;
exports.split = split;
exports.is_sub = is_sub;
exports.$$Set = $$Set$1;
exports.$$Map = $$Map;
exports.List = List$1;
exports.hcons = hcons;
/* Set Not a pure module */
