// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Pputils$ReactTemplate = require("./pputils.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Notation$ReactTemplate = require("./notation.bs.js");
var Ppextend$ReactTemplate = require("./ppextend.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Constrextern$ReactTemplate = require("./constrextern.bs.js");
var Constrintern$ReactTemplate = require("./constrintern.bs.js");
var Notation_ops$ReactTemplate = require("./notation_ops.bs.js");
var Constrexpr_ops$ReactTemplate = require("./constrexpr_ops.bs.js");

var keyword = "constr.keyword";

var evar = "constr.evar";

var univ = "constr.type";

var variable = "constr.variable";

var reference = "constr.reference";

var path = "constr.path";

function tag_unparsing(param) {
  if (param.tag === 4) {
    return (function (param) {
        return Pp$ReactTemplate.tag("constr.notation", param);
      });
  } else {
    return (function (param) {
        return param;
      });
  }
}

function sep_v() {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(","), Pp$ReactTemplate.spc(/* () */0));
}

function pr_tight_coma() {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(","), Pp$ReactTemplate.cut(/* () */0));
}

var ltop = /* tuple */[
  200,
  /* E */1
];

var lsimpleconstr = /* tuple */[
  8,
  /* E */1
];

var lsimplepatt = /* tuple */[
  1,
  /* E */1
];

function prec_less(child, param) {
  var parent = param[0];
  if (parent < 0 && child === 200) {
    return /* true */1;
  } else {
    var assoc = param[1];
    var parent$1 = Pervasives.abs(parent);
    if (typeof assoc === "number") {
      switch (assoc) {
        case 0 : 
            return +(child < parent$1);
        case 1 : 
            return +(child <= parent$1);
        case 2 : 
            return /* true */1;
        
      }
    } else {
      return +(child <= assoc[0]);
    }
  }
}

function prec_of_prim_token(param) {
  if (!param.tag && !param[1]) {
    return 35;
  } else {
    return 0;
  }
}

function print_hunks(n, pr, pr_patt, pr_binders, param, unps) {
  var env = [param[0]];
  var envlist = [param[1]];
  var bl = [param[2]];
  var bll = [param[3]];
  var pop = function (r) {
    var a = Curry._1(Util$ReactTemplate.List[/* hd */1], r[0]);
    r[0] = Curry._1(Util$ReactTemplate.List[/* tl */2], r[0]);
    return a;
  };
  var $$return = function (unp, pp1, pp2) {
    return Pp$ReactTemplate.$plus$plus(Curry._1(tag_unparsing(unp), pp1), pp2);
  };
  var aux = function (param) {
    if (param) {
      var unp = param[0];
      switch (unp.tag | 0) {
        case 0 : 
            var c = pop(env);
            var pp2 = aux(param[1]);
            var pp1 = Curry._2(pr, /* tuple */[
                  n,
                  unp[1]
                ], c);
            return $$return(unp, pp1, pp2);
        case 1 : 
            var c$1 = pop(bl);
            var pp2$1 = aux(param[1]);
            var pp1$1 = Curry._2(pr_patt, /* tuple */[
                  n,
                  unp[1]
                ], c$1);
            return $$return(unp, pp1$1, pp2$1);
        case 2 : 
            var sl = unp[2];
            var cl = pop(envlist);
            var pp1$2 = Pp$ReactTemplate.prlist_with_sep((function () {
                    return aux(sl);
                  }), Curry._1(pr, /* tuple */[
                      n,
                      unp[1]
                    ]), cl);
            var pp2$2 = aux(param[1]);
            return $$return(unp, pp1$2, pp2$2);
        case 3 : 
            var sl$1 = unp[2];
            var cl$1 = pop(bll);
            var pp2$3 = aux(param[1]);
            var pp1$3 = Curry._3(pr_binders, (function () {
                    return aux(sl$1);
                  }), unp[1], cl$1);
            return $$return(unp, pp1$3, pp2$3);
        case 4 : 
            var pp2$4 = aux(param[1]);
            var pp1$4 = Pp$ReactTemplate.str(unp[0]);
            return $$return(unp, pp1$4, pp2$4);
        case 5 : 
            var pp1$5 = Curry._1(Ppextend$ReactTemplate.ppcmd_of_box(unp[0]), aux(Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                            return prim[1];
                          }), unp[1])));
            var pp2$5 = aux(param[1]);
            return $$return(unp, pp1$5, pp2$5);
        case 6 : 
            var pp2$6 = aux(param[1]);
            var pp1$6 = Ppextend$ReactTemplate.ppcmd_of_cut(unp[0]);
            return $$return(unp, pp1$6, pp2$6);
        
      }
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  };
  return aux(unps);
}

function pr_notation(pr, pr_patt, pr_binders, s, env) {
  var match = Notation$ReactTemplate.find_notation_printing_rule(s);
  var level = match[1];
  return /* tuple */[
          print_hunks(level, pr, pr_patt, pr_binders, env, match[0]),
          level
        ];
}

function pr_delimiters(key, strm) {
  return Pp$ReactTemplate.$plus$plus(strm, Pp$ReactTemplate.str("%" + key));
}

function pr_generalization(bk, _, c) {
  var match = bk !== 0 ? /* tuple */[
      "{",
      "}"
    ] : /* tuple */[
      "(",
      ")"
    ];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("`"), Pp$ReactTemplate.str(match[0])), c), Pp$ReactTemplate.str(match[1]));
}

function pr_com_at(n) {
  if (Flags$ReactTemplate.beautify[0] && n !== 0) {
    return Pp$ReactTemplate.comment(Pputils$ReactTemplate.extract_comments(n));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_with_comments(loc, pp) {
  return Pputils$ReactTemplate.pr_located((function (x) {
                return x;
              }), /* tuple */[
              loc,
              pp
            ]);
}

function pr_sep_com(sep, f, c) {
  return pr_with_comments(Constrexpr_ops$ReactTemplate.constr_loc(c), Pp$ReactTemplate.$plus$plus(Curry._1(sep, /* () */0), Curry._1(f, c)));
}

function pr_univ_expr(param) {
  if (param) {
    var match = param[0];
    var n = match[1];
    return Pp$ReactTemplate.$plus$plus(Libnames$ReactTemplate.pr_reference(match[0]), n !== 0 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("+"), Pp$ReactTemplate.$$int(n)) : Pp$ReactTemplate.mt(/* () */0));
  } else {
    return Pp$ReactTemplate.str("_");
  }
}

function pr_univ(l) {
  var exit = 0;
  if (l) {
    if (l[1]) {
      exit = 1;
    } else {
      return pr_univ_expr(l[0]);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("max("), Pp$ReactTemplate.prlist_with_sep((function () {
                          return Pp$ReactTemplate.str(",");
                        }), pr_univ_expr, l)), Pp$ReactTemplate.str(")"));
  }
  
}

function pr_univ_annot(pr, x) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@{"), Curry._1(pr, x)), Pp$ReactTemplate.str("}"));
}

function pr_glob_sort(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      var s = Pp$ReactTemplate.str("Set");
      return Pp$ReactTemplate.tag(univ, s);
    } else {
      var s$1 = Pp$ReactTemplate.str("Prop");
      return Pp$ReactTemplate.tag(univ, s$1);
    }
  } else {
    var u = param[0];
    if (u) {
      var s$2 = Pp$ReactTemplate.str("Type");
      return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(univ, s$2), pr_univ_annot(pr_univ, u)));
    } else {
      var s$3 = Pp$ReactTemplate.str("Type");
      return Pp$ReactTemplate.tag(univ, s$3);
    }
  }
}

function pr_glob_level(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      var s = Pp$ReactTemplate.str("Set");
      return Pp$ReactTemplate.tag(univ, s);
    } else {
      var s$1 = Pp$ReactTemplate.str("Prop");
      return Pp$ReactTemplate.tag(univ, s$1);
    }
  } else {
    var match = param[0];
    if (typeof match === "number") {
      if (match !== 0) {
        var s$2 = Pp$ReactTemplate.str("Type");
        return Pp$ReactTemplate.tag(univ, s$2);
      } else {
        var s$3 = Pp$ReactTemplate.str("_");
        return Pp$ReactTemplate.tag(univ, s$3);
      }
    } else {
      var s$4 = Libnames$ReactTemplate.pr_reference(match[0]);
      return Pp$ReactTemplate.tag(univ, s$4);
    }
  }
}

function pr_qualid(sp) {
  var match = Libnames$ReactTemplate.repr_qualid(sp);
  var s = Names$ReactTemplate.Id[/* print */8](match[1]);
  var id = Pp$ReactTemplate.tag(reference, s);
  var sl = Curry._1(Util$ReactTemplate.List[/* rev */4], Names$ReactTemplate.DirPath[/* repr */4](match[0]));
  var sl$1;
  if (sl) {
    var pr = function (dir) {
      var s = Names$ReactTemplate.Id[/* print */8](dir);
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(path, s), Pp$ReactTemplate.str("."));
    };
    sl$1 = Pp$ReactTemplate.prlist(pr, sl);
  } else {
    sl$1 = Pp$ReactTemplate.mt(/* () */0);
  }
  return Pp$ReactTemplate.$plus$plus(sl$1, id);
}

var pr_id = Names$ReactTemplate.Id[/* print */8];

var pr_name = Nameops$ReactTemplate.Name[/* print */7];

function pr_glob_sort_instance(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      var s = Pp$ReactTemplate.str("Set");
      return Pp$ReactTemplate.tag(univ, s);
    } else {
      var s$1 = Pp$ReactTemplate.str("Prop");
      return Pp$ReactTemplate.tag(univ, s$1);
    }
  } else {
    var u = param[0];
    if (typeof u === "number") {
      if (u !== 0) {
        var s$2 = Pp$ReactTemplate.str("_");
        return Pp$ReactTemplate.tag(univ, s$2);
      } else {
        var s$3 = Pp$ReactTemplate.str("Type");
        return Pp$ReactTemplate.tag(univ, s$3);
      }
    } else {
      return Libnames$ReactTemplate.pr_reference(u[0]);
    }
  }
}

function pr_universe_instance(l) {
  return Pp$ReactTemplate.pr_opt_no_spc((function (param) {
                return pr_univ_annot((function (param) {
                              return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_glob_sort_instance, param);
                            }), param);
              }), l);
}

function pr_reference(param) {
  return CAst$ReactTemplate.with_val((function (param) {
                if (param.tag) {
                  var s = pr_id(param[0]);
                  return Pp$ReactTemplate.tag(variable, s);
                } else {
                  return pr_qualid(param[0]);
                }
              }), param);
}

function pr_cref(ref, us) {
  return Pp$ReactTemplate.$plus$plus(pr_reference(ref), pr_universe_instance(us));
}

function pr_expl_args(pr, param) {
  var expl = param[1];
  var a = param[0];
  if (expl) {
    var match = expl[0][/* v */0];
    if (match.tag) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_id(match[0])), Pp$ReactTemplate.str(":=")), Curry._2(pr, ltop, a)), Pp$ReactTemplate.str(")"));
    } else {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Explicitation by position not implemented."));
    }
  } else {
    return Curry._2(pr, /* tuple */[
                10,
                /* L */0
              ], a);
  }
}

function pr_opt_type_spc(pr, t) {
  var match = t[/* v */0];
  var exit = 0;
  if (match.tag === 12) {
    if (typeof match[1] === "number") {
      return Pp$ReactTemplate.mt(/* () */0);
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" :"), pr_sep_com((function () {
                      return Pp$ReactTemplate.brk(/* tuple */[
                                  1,
                                  2
                                ]);
                    }), Curry._1(pr, ltop), t));
  }
  
}

function pr_lident(param) {
  var loc = param[/* loc */1];
  var id = param[/* v */0];
  if (loc) {
    var match = Loc$ReactTemplate.unloc(loc[0]);
    var b = match[0];
    return Pputils$ReactTemplate.pr_located(pr_id, /* tuple */[
                /* Some */[Loc$ReactTemplate.make_loc(/* tuple */[
                        b,
                        b + Names$ReactTemplate.Id[/* to_string */7](id).length | 0
                      ])],
                id
              ]);
  } else {
    return pr_id(id);
  }
}

function pr_lname(x) {
  var match = x[/* v */0];
  if (match) {
    return pr_lident(CAst$ReactTemplate.make(x[/* loc */1], match[0]));
  } else {
    return Pputils$ReactTemplate.pr_ast(Nameops$ReactTemplate.Name[/* print */7], x);
  }
}

function pr_or_var(pr, param) {
  if (param.tag) {
    return pr_lident(param[0]);
  } else {
    return Curry._1(pr, param[0]);
  }
}

function pr_prim_token(param) {
  if (param.tag) {
    return Pp$ReactTemplate.qs(param[0]);
  } else {
    var n = param[0];
    return Pp$ReactTemplate.str(param[1] ? n : "-" + n);
  }
}

function pr_evar(pr, id, l) {
  var s = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("?"), pr_id(id));
  var tmp;
  if (l) {
    var f = function (param) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_id(param[0]), Pp$ReactTemplate.str(":=")), Curry._2(pr, ltop, param[1]));
    };
    tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@{"), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_semicolon, f, Curry._1(Util$ReactTemplate.List[/* rev */4], l)))), Pp$ReactTemplate.str("}"));
  } else {
    tmp = Pp$ReactTemplate.mt(/* () */0);
  }
  return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(evar, s), tmp));
}

function pr_patt(sep, inh, p) {
  var match = p[/* v */0];
  var match$1;
  switch (match.tag | 0) {
    case 0 : 
        match$1 = /* tuple */[
          Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_patt(Pp$ReactTemplate.mt, /* tuple */[
                        10,
                        /* E */1
                      ], match[0]), Pp$ReactTemplate.str(" as ")), pr_lname(match[1])),
          10
        ];
        break;
    case 1 : 
        var match$2 = match[1];
        var c = match[0];
        if (match$2) {
          var extra_args = match[2];
          var args = match$2[0];
          if (extra_args) {
            var partial_arg = /* tuple */[
              10,
              /* L */0
            ];
            var partial_arg$1 = /* tuple */[
              10,
              /* L */0
            ];
            match$1 = /* tuple */[
              Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.surround(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@"), pr_reference(c)), Pp$ReactTemplate.prlist((function (param) {
                                  return pr_patt(Pp$ReactTemplate.spc, partial_arg, param);
                                }), args))), Pp$ReactTemplate.prlist((function (param) {
                          return pr_patt(Pp$ReactTemplate.spc, partial_arg$1, param);
                        }), extra_args)),
              10
            ];
          } else {
            var partial_arg$2 = /* tuple */[
              10,
              /* L */0
            ];
            match$1 = /* tuple */[
              Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@"), pr_reference(c)), Pp$ReactTemplate.prlist((function (param) {
                          return pr_patt(Pp$ReactTemplate.spc, partial_arg$2, param);
                        }), args)),
              10
            ];
          }
        } else {
          var args$1 = match[2];
          if (args$1) {
            var partial_arg$3 = /* tuple */[
              10,
              /* L */0
            ];
            match$1 = /* tuple */[
              Pp$ReactTemplate.$plus$plus(pr_reference(c), Pp$ReactTemplate.prlist((function (param) {
                          return pr_patt(Pp$ReactTemplate.spc, partial_arg$3, param);
                        }), args$1)),
              10
            ];
          } else {
            match$1 = /* tuple */[
              pr_reference(c),
              0
            ];
          }
        }
        break;
    case 2 : 
        var match$3 = match[0];
        match$1 = match$3 ? /* tuple */[
            pr_reference(match$3[0]),
            0
          ] : /* tuple */[
            Pp$ReactTemplate.str("_"),
            0
          ];
        break;
    case 3 : 
        var partial_arg$4 = /* tuple */[
          100,
          /* L */0
        ];
        match$1 = /* tuple */[
          Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_spcbar, (function (param) {
                      return pr_patt(Pp$ReactTemplate.mt, partial_arg$4, param);
                    }), match[0])),
          100
        ];
        break;
    case 4 : 
        var s = match[0];
        var exit = 0;
        if (s === "( _ )") {
          var match$4 = match[1];
          var match$5 = match$4[0];
          if (match$5 && !(match$5[1] || match$4[1] || match[2])) {
            match$1 = /* tuple */[
              Pp$ReactTemplate.$plus$plus(pr_patt((function () {
                          return Pp$ReactTemplate.str("(");
                        }), /* tuple */[
                        Pervasives.max_int,
                        /* E */1
                      ], match$5[0]), Pp$ReactTemplate.str(")")),
              0
            ];
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          var args$2 = match[2];
          var match$6 = match[1];
          var match$7 = pr_notation((function (param, param$1) {
                  return pr_patt(Pp$ReactTemplate.mt, param, param$1);
                }), (function (_, _$1) {
                  return Pp$ReactTemplate.mt(/* () */0);
                }), (function (_, _$1, _$2) {
                  return Pp$ReactTemplate.mt(/* () */0);
                }), s, /* tuple */[
                match$6[0],
                match$6[1],
                /* [] */0,
                /* [] */0
              ]);
          var l_not = match$7[1];
          var strm_not = match$7[0];
          var partial_arg$5 = /* tuple */[
            10,
            /* L */0
          ];
          match$1 = /* tuple */[
            Pp$ReactTemplate.$plus$plus(Curry._1(Util$ReactTemplate.List[/* is_empty */45], args$2) || prec_less(l_not, /* tuple */[
                      10,
                      /* L */0
                    ]) ? strm_not : Pp$ReactTemplate.surround(strm_not), Pp$ReactTemplate.prlist((function (param) {
                        return pr_patt(Pp$ReactTemplate.spc, partial_arg$5, param);
                      }), args$2)),
            Curry._1(Util$ReactTemplate.List[/* is_empty */45], args$2) ? l_not : 10
          ];
        }
        break;
    case 5 : 
        match$1 = /* tuple */[
          pr_prim_token(match[0]),
          0
        ];
        break;
    case 6 : 
        var pp = function (param) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_reference(param[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":=")), pr_patt(Pp$ReactTemplate.spc, /* tuple */[
                          0,
                          /* Any */2
                        ], param[1]));
        };
        match$1 = /* tuple */[
          Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{| "), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_semicolon, pp, match[0])), Pp$ReactTemplate.str(" |}")),
          0
        ];
        break;
    case 7 : 
        match$1 = /* tuple */[
          pr_delimiters(match[0], pr_patt(Pp$ReactTemplate.mt, lsimplepatt, match[1])),
          1
        ];
        break;
    case 8 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "ppconstr.ml",
                313,
                8
              ]
            ];
    
  }
  var strm = match$1[0];
  var loc = p[/* loc */1];
  return pr_with_comments(loc, Pp$ReactTemplate.$plus$plus(Curry._1(sep, /* () */0), prec_less(match$1[1], inh) ? strm : Pp$ReactTemplate.surround(strm)));
}

function pr_patt$1(param, param$1) {
  return pr_patt(Pp$ReactTemplate.mt, param, param$1);
}

function begin_of_binders(param) {
  if (param) {
    var l_bi = param[0];
    var b_loc = function (l) {
      return Option$ReactTemplate.cata(Loc$ReactTemplate.unloc, /* tuple */[
                    0,
                    0
                  ], l)[0];
    };
    switch (l_bi.tag | 0) {
      case 0 : 
          var match = l_bi[0];
          if (match) {
            return b_loc(match[0][/* loc */1]);
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "ppconstr.ml",
                    335,
                    11
                  ]
                ];
          }
          break;
      case 1 : 
      case 2 : 
          return b_loc(l_bi[0][/* loc */1]);
      
    }
  } else {
    return 0;
  }
}

function surround_impl(k, p) {
  if (k !== 0) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{"), p), Pp$ReactTemplate.str("}"));
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), p), Pp$ReactTemplate.str(")"));
  }
}

function surround_implicit(k, p) {
  if (k !== 0) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{"), p), Pp$ReactTemplate.str("}"));
  } else {
    return p;
  }
}

function pr_binder(many, pr, param) {
  var t = param[2];
  var k = param[1];
  var nal = param[0];
  if (k.tag) {
    var t$prime = k[2];
    var b$prime = k[1];
    if (!(
        k[0] !== 0 ? /* true */1 : /* false */0
      )) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "ppconstr.ml",
              354,
              8
            ]
          ];
    }
    var exit = 0;
    if (nal) {
      var match = nal[0];
      var match$1 = match[/* v */0];
      if (match$1) {
        if (nal[1]) {
          exit = 1;
        } else {
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("`"), surround_impl(b$prime, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_lident(CAst$ReactTemplate.make(match[/* loc */1], match$1[0])), Pp$ReactTemplate.str(" : ")), t$prime ? Pp$ReactTemplate.str("!") : Pp$ReactTemplate.mt(/* () */0)), Curry._1(pr, t)))));
        }
      } else if (nal[1]) {
        exit = 1;
      } else {
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("`"), surround_impl(b$prime, Pp$ReactTemplate.$plus$plus(t$prime ? Pp$ReactTemplate.str("!") : Pp$ReactTemplate.mt(/* () */0), Curry._1(pr, t)))));
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("List of generalized binders have alwais one element."));
    }
    
  } else {
    var match$2 = t[/* v */0];
    var b = k[0];
    var exit$1 = 0;
    if (match$2.tag === 12) {
      if (typeof match$2[1] === "number") {
        var s = Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_lname, nal);
        return Pp$ReactTemplate.hov(1, surround_implicit(b, s));
      } else {
        exit$1 = 1;
      }
    } else {
      exit$1 = 1;
    }
    if (exit$1 === 1) {
      var s$1 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_lname, nal), Pp$ReactTemplate.str(" : ")), Curry._1(pr, t));
      return Pp$ReactTemplate.hov(1, many ? surround_impl(b, s$1) : surround_implicit(b, s$1));
    }
    
  }
}

function pr_binder_among_many(pr_c, param) {
  switch (param.tag | 0) {
    case 0 : 
        return pr_binder(/* true */1, pr_c, /* tuple */[
                    param[0],
                    param[1],
                    param[2]
                  ]);
    case 1 : 
        return Pp$ReactTemplate.surround(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_lname(param[0]), Pp$ReactTemplate.pr_opt_no_spc((function (t) {
                                          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" :"), Pp$ReactTemplate.ws(1)), Curry._1(pr_c, t));
                                        }), param[2])), Pp$ReactTemplate.str(" :=")), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pr_c, param[1])));
    case 2 : 
        var match = param[0][/* v */0];
        var tyo = match[1];
        var p = pr_patt(Pp$ReactTemplate.mt, lsimplepatt, match[0]);
        if (tyo) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("'"), Pp$ReactTemplate.surround(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(p, Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.ws(1)), Curry._1(pr_c, tyo[0]))));
        } else {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("'"), p);
        }
    
  }
}

function pr_delimited_binders(kw, sep, pr_c, bl) {
  var n = begin_of_binders(bl);
  if (bl) {
    var match = bl[0];
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          if (bl[1]) {
            exit = 1;
          } else {
            return Pp$ReactTemplate.$plus$plus(Curry._1(kw, n), pr_binder(/* false */0, pr_c, /* tuple */[
                            match[0],
                            match[1],
                            match[2]
                          ]));
          }
          break;
      case 1 : 
      case 2 : 
          exit = 1;
          break;
      
    }
    if (exit === 1) {
      return Pp$ReactTemplate.$plus$plus(Curry._1(kw, n), Pp$ReactTemplate.prlist_with_sep(sep, (function (param) {
                        return pr_binder_among_many(pr_c, param);
                      }), bl));
    }
    
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "ppconstr.ml",
            399,
            14
          ]
        ];
  }
}

function pr_recursive_decl(pr, pr_dangling, dangling_with_for, id, bl, annot, t, c) {
  var pr_body = dangling_with_for ? pr_dangling : pr;
  var pr_c = Curry._1(pr, ltop);
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_id(id), bl ? Pp$ReactTemplate.str(" ") : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus((function (param) {
                                      return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                                                    return pr_binder_among_many(pr_c, param);
                                                  }), param);
                                    })(bl), annot))), pr_opt_type_spc(pr, t)), Pp$ReactTemplate.str(" :=")), pr_sep_com((function () {
                    return Pp$ReactTemplate.brk(/* tuple */[
                                1,
                                2
                              ]);
                  }), Curry._1(pr_body, ltop), c));
}

function pr_guard_annot(pr_aux, bl, param) {
  var ro = param[1];
  var n = param[0];
  if (n) {
    var id = n[0][/* v */0];
    if (typeof ro === "number") {
      var names_of_binder = function (param) {
        switch (param.tag | 0) {
          case 0 : 
              return param[0];
          case 1 : 
              return /* [] */0;
          case 2 : 
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "ppconstr.ml",
                      422,
                      35
                    ]
                  ];
          
        }
      };
      var ids = Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], names_of_binder, bl));
      if (Curry._1(Util$ReactTemplate.List[/* length */0], ids) > 1) {
        var s = Pp$ReactTemplate.str("struct");
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("{")), Pp$ReactTemplate.tag(keyword, s)), Pp$ReactTemplate.spc(/* () */0)), pr_id(id)), Pp$ReactTemplate.str("}"));
      } else {
        return Pp$ReactTemplate.mt(/* () */0);
      }
    } else if (ro.tag) {
      var r = ro[1];
      var s$1 = Pp$ReactTemplate.str("measure");
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("{")), Pp$ReactTemplate.tag(keyword, s$1)), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pr_aux, ro[0])), Pp$ReactTemplate.spc(/* () */0)), pr_id(id)), r ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" on "), Curry._1(pr_aux, r[0])) : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.str("}"));
    } else {
      var s$2 = Pp$ReactTemplate.str("wf");
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("{")), Pp$ReactTemplate.tag(keyword, s$2)), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pr_aux, ro[0])), Pp$ReactTemplate.spc(/* () */0)), pr_id(id)), Pp$ReactTemplate.str("}"));
    }
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_recursive(pr_decl, id, dl) {
  if (dl) {
    if (dl[1]) {
      var s = Pp$ReactTemplate.str("for");
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep((function () {
                                    var s = Pp$ReactTemplate.str("with");
                                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.tag(keyword, s)), Pp$ReactTemplate.spc(/* () */0));
                                  }), Curry._1(pr_decl, /* true */1), dl), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.tag(keyword, s)), Pp$ReactTemplate.spc(/* () */0)), pr_id(id));
    } else {
      return Curry._2(pr_decl, /* false */0, dl[0]);
    }
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("(co)fixpoint with no definition."));
  }
}

function pr_asin(_, na, indnalopt) {
  var tmp;
  if (na) {
    var s = Pp$ReactTemplate.str("as");
    tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.tag(keyword, s)), Pp$ReactTemplate.spc(/* () */0)), pr_lname(na[0]));
  } else {
    tmp = Pp$ReactTemplate.mt(/* () */0);
  }
  var tmp$1;
  if (indnalopt) {
    var s$1 = Pp$ReactTemplate.str("in");
    tmp$1 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.tag(keyword, s$1)), Pp$ReactTemplate.spc(/* () */0)), pr_patt(Pp$ReactTemplate.mt, lsimplepatt, indnalopt[0]));
  } else {
    tmp$1 = Pp$ReactTemplate.mt(/* () */0);
  }
  return Pp$ReactTemplate.$plus$plus(tmp, tmp$1);
}

function pr_case_type(pr, po) {
  if (po) {
    var p = po[0];
    var match = p[/* v */0];
    var exit = 0;
    if (match.tag === 12) {
      if (typeof match[1] === "number") {
        return Pp$ReactTemplate.mt(/* () */0);
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var s = Pp$ReactTemplate.str("return");
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s), pr_sep_com(Pp$ReactTemplate.spc, Curry._1(pr, lsimpleconstr), p))));
    }
    
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_simple_return_type(pr, na, po) {
  var tmp;
  if (na) {
    var match = na[0][/* v */0];
    if (match) {
      var s = Pp$ReactTemplate.str("as");
      tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.tag(keyword, s)), Pp$ReactTemplate.spc(/* () */0)), pr_id(match[0]));
    } else {
      tmp = Pp$ReactTemplate.mt(/* () */0);
    }
  } else {
    tmp = Pp$ReactTemplate.mt(/* () */0);
  }
  return Pp$ReactTemplate.$plus$plus(tmp, pr_case_type(pr, po));
}

function pr_proj(pr, pr_app, a, f, l) {
  return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._2(pr, /* tuple */[
                                  1,
                                  /* E */1
                                ], a), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str(".(")), Curry._3(pr_app, pr, f, l)), Pp$ReactTemplate.str(")")));
}

function pr_appexpl(pr, param, l) {
  var partial_arg = Curry._1(pr, /* tuple */[
        10,
        /* L */0
      ]);
  return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@"), pr_reference(param[0])), pr_universe_instance(param[1])), Pp$ReactTemplate.prlist((function (param) {
                        return pr_sep_com(Pp$ReactTemplate.spc, partial_arg, param);
                      }), l)));
}

function pr_app(pr, a, l) {
  return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Curry._2(pr, /* tuple */[
                      10,
                      /* L */0
                    ], a), Pp$ReactTemplate.prlist((function (a) {
                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), pr_expl_args(pr, a));
                      }), l)));
}

function pr_record_body_gen(pr, l) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_semicolon, (function (param) {
                    return Pp$ReactTemplate.h(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_reference(param[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":=")), Curry._2(pr, ltop, param[1])));
                  }), l));
}

function pr_forall(n) {
  var s = Pp$ReactTemplate.str("forall");
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s), pr_com_at(n)), Pp$ReactTemplate.spc(/* () */0));
}

function pr_fun(n) {
  var s = Pp$ReactTemplate.str("fun");
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s), pr_com_at(n)), Pp$ReactTemplate.spc(/* () */0));
}

var pr_fun_sep = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("=>"));

function pr_dangling_with_for(sep, pr, inherited, a) {
  var match = a[/* v */0];
  var exit = 0;
  switch (match.tag | 0) {
    case 1 : 
    case 2 : 
        exit = 1;
        break;
    default:
      return Curry._3(pr, sep, inherited, a);
  }
  if (exit === 1) {
    var match$1 = match[1];
    if (match$1 && !match$1[1]) {
      return Curry._3(pr, sep, /* tuple */[
                  0,
                  /* E */1
                ], a);
    } else {
      return Curry._3(pr, sep, inherited, a);
    }
  }
  
}

function pr(pr$1, sep, inherited, a) {
  var $$return = function (param) {
    return /* tuple */[
            param[0],
            param[1]
          ];
  };
  var match = a[/* v */0];
  var match$1;
  var exit = 0;
  var exit$1 = 0;
  var $$var;
  var t;
  switch (match.tag | 0) {
    case 0 : 
        match$1 = $$return(/* tuple */[
              pr_cref(match[0], match[1]),
              0
            ]);
        break;
    case 1 : 
        var s = Pp$ReactTemplate.str("fix");
        var partial_arg = Curry._1(pr$1, Pp$ReactTemplate.mt);
        match$1 = $$return(/* tuple */[
              Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s), Pp$ReactTemplate.spc(/* () */0)), pr_recursive((function (param, param$1) {
                              var pr$2 = partial_arg;
                              var prd = function (param, param$1) {
                                return pr_dangling_with_for(Pp$ReactTemplate.mt, pr$1, param, param$1);
                              };
                              var dangling_with_for = param;
                              var param$2 = param$1;
                              var bl = param$2[2];
                              var annot = pr_guard_annot(Curry._1(pr$2, lsimpleconstr), bl, param$2[1]);
                              return pr_recursive_decl(pr$2, prd, dangling_with_for, param$2[0][/* v */0], bl, annot, param$2[3], param$2[4]);
                            }), match[0][/* v */0], match[1]))),
              200
            ]);
        break;
    case 2 : 
        var s$1 = Pp$ReactTemplate.str("cofix");
        var partial_arg$1 = Curry._1(pr$1, Pp$ReactTemplate.mt);
        match$1 = $$return(/* tuple */[
              Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$1), Pp$ReactTemplate.spc(/* () */0)), pr_recursive((function (param, param$1) {
                              var pr$2 = partial_arg$1;
                              var prd = function (param, param$1) {
                                return pr_dangling_with_for(Pp$ReactTemplate.mt, pr$1, param, param$1);
                              };
                              var dangling_with_for = param;
                              var param$2 = param$1;
                              return pr_recursive_decl(pr$2, prd, dangling_with_for, param$2[0][/* v */0], param$2[1], Pp$ReactTemplate.mt(/* () */0), param$2[2], param$2[3]);
                            }), match[0][/* v */0], match[1]))),
              200
            ]);
        break;
    case 3 : 
        match$1 = $$return(/* tuple */[
              Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(2, pr_delimited_binders(pr_forall, Pp$ReactTemplate.spc, Curry._2(pr$1, Pp$ReactTemplate.mt, ltop), match[0])), Pp$ReactTemplate.str(",")), Curry._3(pr$1, Pp$ReactTemplate.spc, ltop, match[1]))),
              200
            ]);
        break;
    case 4 : 
        match$1 = $$return(/* tuple */[
              Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(2, pr_delimited_binders(pr_fun, Pp$ReactTemplate.spc, Curry._2(pr$1, Pp$ReactTemplate.mt, ltop), match[0])), pr_fun_sep), Curry._3(pr$1, Pp$ReactTemplate.spc, ltop, match[1]))),
              200
            ]);
        break;
    case 5 : 
        var x = match[0];
        var match$2 = x[/* v */0];
        var exit$2 = 0;
        if (match$2) {
          var fx = match[1];
          var match$3 = fx[/* v */0];
          var exit$3 = 0;
          switch (match$3.tag | 0) {
            case 1 : 
            case 2 : 
                exit$3 = 4;
                break;
            default:
              exit$2 = 3;
          }
          if (exit$3 === 4) {
            var match$4 = match$3[1];
            if (match$4) {
              if (match$4[1]) {
                exit$2 = 3;
              } else if (Names$ReactTemplate.Id[/* equal */0](match$2[0], match$3[0][/* v */0])) {
                var s$2 = Pp$ReactTemplate.str("let");
                var s$3 = Pp$ReactTemplate.str("in");
                match$1 = $$return(/* tuple */[
                      Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$2), Pp$ReactTemplate.spc(/* () */0)), Curry._3(pr$1, Pp$ReactTemplate.mt, ltop, fx)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.tag(keyword, s$3))), Curry._3(pr$1, Pp$ReactTemplate.spc, ltop, match[3]))),
                      200
                    ]);
              } else {
                exit$2 = 3;
              }
            } else {
              exit$2 = 3;
            }
          }
          
        } else {
          exit$2 = 3;
        }
        if (exit$2 === 3) {
          var s$4 = Pp$ReactTemplate.str("let");
          var s$5 = Pp$ReactTemplate.str("in");
          match$1 = $$return(/* tuple */[
                Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$4), Pp$ReactTemplate.spc(/* () */0)), pr_lname(x)), Pp$ReactTemplate.pr_opt_no_spc((function (t) {
                                                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" :"), Pp$ReactTemplate.ws(1)), Curry._3(pr$1, Pp$ReactTemplate.mt, ltop, t));
                                                      }), match[2])), Pp$ReactTemplate.str(" :=")), Curry._3(pr$1, Pp$ReactTemplate.spc, ltop, match[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.tag(keyword, s$5))), Curry._3(pr$1, Pp$ReactTemplate.spc, ltop, match[3]))),
                200
              ]);
        }
        break;
    case 6 : 
        var match$5 = match[0];
        var match$6 = match$5[0];
        if (match$6) {
          var match$7 = Curry._2(Util$ReactTemplate.List[/* chop */99], match$6[0], match[1]);
          var l2 = match$7[1];
          var match$8 = Curry._1(Util$ReactTemplate.List[/* sep_last */93], match$7[0]);
          var p = pr_proj(Curry._1(pr$1, Pp$ReactTemplate.mt), pr_appexpl, match$8[0], /* tuple */[
                match$5[1],
                match$5[2]
              ], match$8[1]);
          match$1 = Curry._1(Util$ReactTemplate.List[/* is_empty */45], l2) ? $$return(/* tuple */[
                  p,
                  1
                ]) : $$return(/* tuple */[
                  Pp$ReactTemplate.$plus$plus(p, Pp$ReactTemplate.prlist(Curry._2(pr$1, Pp$ReactTemplate.spc, /* tuple */[
                                10,
                                /* L */0
                              ]), l2)),
                  10
                ]);
        } else {
          var match$9 = match$5[1][/* v */0];
          if (match$9.tag) {
            var match$10 = match[1];
            if (match$10) {
              if (match$10[1]) {
                exit = 1;
              } else {
                $$var = match$9[0];
                t = match$10[0];
                exit$1 = 2;
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
        }
        break;
    case 7 : 
        var match$11 = match[0][1][/* v */0];
        if (match$11.tag) {
          exit = 1;
        } else {
          var match$12 = match$11[0][/* v */0];
          if (match$12.tag) {
            var match$13 = match[1];
            if (match$13) {
              var match$14 = match$13[0];
              if (match$14[1]) {
                exit = 1;
              } else if (match$13[1]) {
                exit = 1;
              } else {
                $$var = match$12[0];
                t = match$14[0];
                exit$1 = 2;
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
        }
        break;
    case 8 : 
        match$1 = $$return(/* tuple */[
              Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{|"), pr_record_body_gen(Curry._1(pr$1, Pp$ReactTemplate.spc), match[0])), Pp$ReactTemplate.str(" |}"))),
              0
            ]);
        break;
    case 9 : 
        var exit$4 = 0;
        if (match[0] !== 2) {
          exit$4 = 3;
        } else {
          var match$15 = match[2];
          if (match$15) {
            if (match$15[1]) {
              exit$4 = 3;
            } else {
              var match$16 = match[3];
              if (match$16) {
                var match$17 = match$16[0][/* v */0];
                var match$18 = match$17[0];
                if (match$18) {
                  var match$19 = match$18[0];
                  if (match$19) {
                    if (match$19[1]) {
                      exit$4 = 3;
                    } else if (match$18[1]) {
                      exit$4 = 3;
                    } else if (match$16[1]) {
                      exit$4 = 3;
                    } else {
                      var match$20 = match$15[0];
                      var s$6 = Pp$ReactTemplate.str("let");
                      var s$7 = Pp$ReactTemplate.str("in");
                      match$1 = $$return(/* tuple */[
                            Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$6), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("'")), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_patt(Pp$ReactTemplate.mt, ltop, match$19[0]), pr_asin((function (param, param$1) {
                                                                            return pr_dangling_with_for(Pp$ReactTemplate.mt, pr$1, param, param$1);
                                                                          }), match$20[1], match$20[2])), Pp$ReactTemplate.str(" :=")), Curry._3(pr$1, Pp$ReactTemplate.spc, ltop, match$20[0])), pr_case_type((function (param, param$1) {
                                                                return pr_dangling_with_for(Pp$ReactTemplate.mt, pr$1, param, param$1);
                                                              }), match[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.tag(keyword, s$7)), Curry._3(pr$1, Pp$ReactTemplate.spc, ltop, match$17[1]))))),
                            200
                          ]);
                    }
                  } else {
                    exit$4 = 3;
                  }
                } else {
                  exit$4 = 3;
                }
              } else {
                exit$4 = 3;
              }
            }
          } else {
            exit$4 = 3;
          }
        }
        if (exit$4 === 3) {
          var s$8 = Pp$ReactTemplate.str("match");
          var s$9 = Pp$ReactTemplate.str("with");
          var partial_arg$2 = Curry._1(pr$1, Pp$ReactTemplate.mt);
          var s$10 = Pp$ReactTemplate.str("end");
          match$1 = $$return(/* tuple */[
                Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$8), Pp$ReactTemplate.brk(/* tuple */[
                                                          1,
                                                          2
                                                        ])), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(sep_v, (function (param) {
                                                                var pr$2 = function (param, param$1) {
                                                                  return pr_dangling_with_for(Pp$ReactTemplate.mt, pr$1, param, param$1);
                                                                };
                                                                var param$1 = param;
                                                                return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Curry._2(pr$2, /* tuple */[
                                                                                    100,
                                                                                    /* E */1
                                                                                  ], param$1[0]), pr_asin(pr$2, param$1[1], param$1[2])));
                                                              }), match[2]), pr_case_type((function (param, param$1) {
                                                                return pr_dangling_with_for(Pp$ReactTemplate.mt, pr$1, param, param$1);
                                                              }), match[1])))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.tag(keyword, s$9))), Pp$ReactTemplate.prlist((function (param) {
                                        var pr = partial_arg$2;
                                        var param$1 = param;
                                        var match = param$1[/* v */0];
                                        var partial_arg$3 = function (param) {
                                          return pr_patt$1(ltop, param);
                                        };
                                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.hov(4, pr_with_comments(param$1[/* loc */1], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("| "), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_spcbar, (function (param) {
                                                                                  return Pp$ReactTemplate.prlist_with_sep(sep_v, partial_arg$3, param);
                                                                                }), match[0]), Pp$ReactTemplate.str(" =>")))), pr_sep_com(Pp$ReactTemplate.spc, Curry._1(pr, ltop), match[1])))));
                                      }), match[3])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.tag(keyword, s$10))),
                0
              ]);
        }
        break;
    case 10 : 
        var match$21 = match[1];
        var s$11 = Pp$ReactTemplate.str("let");
        var s$12 = Pp$ReactTemplate.str(" in");
        match$1 = $$return(/* tuple */[
              Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$11), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), Pp$ReactTemplate.prlist_with_sep(sep_v, pr_lname, match[0])), Pp$ReactTemplate.str(")")), pr_simple_return_type(Curry._1(pr$1, Pp$ReactTemplate.mt), match$21[0], match$21[1])), Pp$ReactTemplate.str(" :=")))), Curry._3(pr$1, Pp$ReactTemplate.spc, ltop, match[2])), Pp$ReactTemplate.tag(keyword, s$12))), Curry._3(pr$1, Pp$ReactTemplate.spc, ltop, match[3]))),
              200
            ]);
        break;
    case 11 : 
        var match$22 = match[1];
        var s$13 = Pp$ReactTemplate.str("if");
        var s$14 = Pp$ReactTemplate.str("then");
        var s$15 = Pp$ReactTemplate.str("else");
        match$1 = $$return(/* tuple */[
              Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$13), Pp$ReactTemplate.spc(/* () */0)), Curry._3(pr$1, Pp$ReactTemplate.mt, ltop, match[0])), pr_simple_return_type(Curry._1(pr$1, Pp$ReactTemplate.mt), match$22[0], match$22[1]))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$14), Curry._3(pr$1, (function () {
                                              return Pp$ReactTemplate.brk(/* tuple */[
                                                          1,
                                                          1
                                                        ]);
                                            }), ltop, match[2])))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.tag(keyword, s$15), Curry._3(pr$1, (function () {
                                      return Pp$ReactTemplate.brk(/* tuple */[
                                                  1,
                                                  1
                                                ]);
                                    }), ltop, match[3]))))),
              200
            ]);
        break;
    case 12 : 
        var match$23 = match[1];
        match$1 = typeof match$23 === "number" ? $$return(/* tuple */[
                Pp$ReactTemplate.str("_"),
                0
              ]) : (
            match$23.tag ? $$return(/* tuple */[
                    Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("?[?"), pr_id(match$23[0])), Pp$ReactTemplate.str("]")),
                    0
                  ]) : $$return(/* tuple */[
                    Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("?["), pr_id(match$23[0])), Pp$ReactTemplate.str("]")),
                    0
                  ])
          );
        break;
    case 13 : 
        match$1 = $$return(/* tuple */[
              Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@?"), pr_id(match[0])),
              0
            ]);
        break;
    case 14 : 
        match$1 = $$return(/* tuple */[
              pr_evar(Curry._1(pr$1, Pp$ReactTemplate.mt), match[0], match[1]),
              0
            ]);
        break;
    case 15 : 
        match$1 = $$return(/* tuple */[
              pr_glob_sort(match[0]),
              0
            ]);
        break;
    case 16 : 
        var b = match[1];
        var tmp;
        tmp = typeof b === "number" ? Pp$ReactTemplate.str(":>") : (
            b.tag ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("<:"), Pp$ReactTemplate.ws(1)), Curry._3(pr$1, Pp$ReactTemplate.mt, /* tuple */[
                        -100,
                        /* E */1
                      ], b[0])) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":"), Pp$ReactTemplate.ws(1)), Curry._3(pr$1, Pp$ReactTemplate.mt, /* tuple */[
                        -100,
                        /* E */1
                      ], b[0]))
          );
        match$1 = $$return(/* tuple */[
              Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._3(pr$1, Pp$ReactTemplate.mt, /* tuple */[
                                100,
                                /* L */0
                              ], match[0]), Pp$ReactTemplate.spc(/* () */0)), tmp)),
              100
            ]);
        break;
    case 17 : 
        var s$16 = match[0];
        var exit$5 = 0;
        if (s$16 === "( _ )") {
          var match$24 = match[1];
          var match$25 = match$24[0];
          if (match$25 && !(match$25[1] || match$24[1] || match$24[2] || match$24[3])) {
            match$1 = $$return(/* tuple */[
                  Pp$ReactTemplate.$plus$plus(Curry._3(pr$1, (function () {
                              return Pp$ReactTemplate.str("(");
                            }), /* tuple */[
                            Pervasives.max_int,
                            /* L */0
                          ], match$25[0]), Pp$ReactTemplate.str(")")),
                  0
                ]);
          } else {
            exit$5 = 3;
          }
        } else {
          exit$5 = 3;
        }
        if (exit$5 === 3) {
          var partial_arg$3 = Curry._2(pr$1, Pp$ReactTemplate.mt, ltop);
          match$1 = pr_notation(Curry._1(pr$1, Pp$ReactTemplate.mt), pr_patt$1, (function (param, param$1) {
                  var pr_c = partial_arg$3;
                  var sep = param;
                  var is_open = param$1;
                  if (is_open) {
                    return (function (param) {
                        return pr_delimited_binders(pr_com_at, sep, pr_c, param);
                      });
                  } else {
                    return (function (param) {
                        return Pp$ReactTemplate.prlist_with_sep(sep, (function (param) {
                                      return pr_binder_among_many(pr_c, param);
                                    }), param);
                      });
                  }
                }), s$16, match[1]);
        }
        break;
    case 18 : 
        match$1 = $$return(/* tuple */[
              pr_generalization(match[0], match[1], Curry._3(pr$1, Pp$ReactTemplate.mt, ltop, match[2])),
              0
            ]);
        break;
    case 19 : 
        var p$1 = match[0];
        match$1 = $$return(/* tuple */[
              pr_prim_token(p$1),
              prec_of_prim_token(p$1)
            ]);
        break;
    case 20 : 
        match$1 = $$return(/* tuple */[
              pr_delimiters(match[0], Curry._3(pr$1, Pp$ReactTemplate.mt, /* tuple */[
                        1,
                        /* E */1
                      ], match[1])),
              1
            ]);
        break;
    case 21 : 
        var p$2 = pr_proj(Curry._1(pr$1, Pp$ReactTemplate.mt), pr_app, match[1], CAst$ReactTemplate.make(/* None */0, /* CRef */Block.__(0, [
                    match[0],
                    /* None */0
                  ])), /* [] */0);
        match$1 = $$return(/* tuple */[
              p$2,
              1
            ]);
        break;
    
  }
  if (exit$1 === 2) {
    if (Names$ReactTemplate.Id[/* equal */0]($$var, Notation_ops$ReactTemplate.ldots_var)) {
      match$1 = $$return(/* tuple */[
            Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(".."), Curry._3(pr$1, Pp$ReactTemplate.spc, /* tuple */[
                                  0,
                                  /* E */1
                                ], t)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(".."))),
            9
          ]);
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    if (match.tag === 6) {
      var match$26 = match[0];
      match$1 = $$return(/* tuple */[
            pr_appexpl(Curry._1(pr$1, Pp$ReactTemplate.mt), /* tuple */[
                  match$26[1],
                  match$26[2]
                ], match[1]),
            10
          ]);
    } else {
      var match$27 = match[0];
      var match$28 = match$27[0];
      if (match$28) {
        var match$29 = Curry._2(Util$ReactTemplate.List[/* chop */99], match$28[0], match[1]);
        var l2$1 = match$29[1];
        var match$30 = Curry._1(Util$ReactTemplate.List[/* sep_last */93], match$29[0]);
        var c = match$30[0];
        if (!Option$ReactTemplate.is_empty(c[1])) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "ppconstr.ml",
                  580,
                  8
                ]
              ];
        }
        var p$3 = pr_proj(Curry._1(pr$1, Pp$ReactTemplate.mt), pr_app, c[0], match$27[1], match$30[1]);
        match$1 = Curry._1(Util$ReactTemplate.List[/* is_empty */45], l2$1) ? $$return(/* tuple */[
                p$3,
                1
              ]) : $$return(/* tuple */[
                Pp$ReactTemplate.$plus$plus(p$3, Pp$ReactTemplate.prlist((function (a) {
                            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), pr_expl_args(Curry._1(pr$1, Pp$ReactTemplate.mt), a));
                          }), l2$1)),
                10
              ]);
      } else {
        match$1 = $$return(/* tuple */[
              pr_app(Curry._1(pr$1, Pp$ReactTemplate.mt), match$27[1], match[1]),
              10
            ]);
      }
    }
  }
  var strm = match$1[0];
  var loc = Constrexpr_ops$ReactTemplate.constr_loc(a);
  return pr_with_comments(loc, Pp$ReactTemplate.$plus$plus(Curry._1(sep, /* () */0), prec_less(match$1[1], inherited) ? strm : Pp$ReactTemplate.surround(strm)));
}

function fix(rf, x) {
  return Curry._2(rf, (function (param) {
                return Curry._2(rf, (function (param) {
                              return fix(rf, param);
                            }), param);
              }), x);
}

function pr$1(param, param$1) {
  return pr((function (param) {
                return (function (param$1, param$2) {
                    return pr((function (param) {
                                  return fix(pr, param);
                                }), param, param$1, param$2);
                  });
              }), Pp$ReactTemplate.mt, param, param$1);
}

function pr$2(prec, c) {
  var match = c[/* v */0];
  if (match.tag === 6) {
    var match$1 = match[0];
    if (match$1[0] || match[1]) {
      return pr$1(prec, c);
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@"), pr_cref(match$1[1], match$1[2]));
    }
  } else {
    return pr$1(prec, c);
  }
}

function transf(env, sigma, c) {
  if (Flags$ReactTemplate.beautify_file[0]) {
    var r = Constrintern$ReactTemplate.for_grammar((function (param) {
            return Constrintern$ReactTemplate.intern_constr(env, sigma, param);
          }), c);
    return Constrextern$ReactTemplate.extern_glob_constr(Termops$ReactTemplate.vars_of_env(env), r);
  } else {
    return c;
  }
}

function pr_expr(prec, c) {
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_env(env);
  return pr$2(prec, transf(env, sigma, c));
}

function pr_simpleconstr(param) {
  return pr_expr(lsimpleconstr, param);
}

function default_term_pr_001(param) {
  return pr_expr(ltop, param);
}

function default_term_pr_003(param) {
  return pr_expr(ltop, param);
}

var default_term_pr = /* record */[
  /* pr_constr_expr */pr_simpleconstr,
  default_term_pr_001,
  /* pr_constr_pattern_expr */pr_simpleconstr,
  default_term_pr_003
];

var term_pr = [default_term_pr];

function set_term_pr(param) {
  term_pr[0] = param;
  return /* () */0;
}

var pr_constr_expr_n = pr_expr;

function pr_constr_expr(c) {
  return Curry._1(term_pr[0][/* pr_constr_expr */0], c);
}

function pr_lconstr_expr(c) {
  return Curry._1(term_pr[0][/* pr_lconstr_expr */1], c);
}

function pr_constr_pattern_expr(c) {
  return Curry._1(term_pr[0][/* pr_constr_pattern_expr */2], c);
}

function pr_lconstr_pattern_expr(c) {
  return Curry._1(term_pr[0][/* pr_lconstr_pattern_expr */3], c);
}

function pr_cases_pattern_expr(param) {
  return pr_patt$1(ltop, param);
}

function pr_record_body(param) {
  return pr_record_body_gen(pr$2, param);
}

function pr_c(param) {
  return pr_expr(ltop, param);
}

function pr_binders(param) {
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                return pr_binder_among_many(pr_c, param);
              }), param);
}

var pr_patvar = pr_id;

var modular_constr_pr = pr;

exports.prec_less = prec_less;
exports.pr_tight_coma = pr_tight_coma;
exports.pr_or_var = pr_or_var;
exports.pr_lident = pr_lident;
exports.pr_lname = pr_lname;
exports.pr_with_comments = pr_with_comments;
exports.pr_com_at = pr_com_at;
exports.pr_sep_com = pr_sep_com;
exports.pr_id = pr_id;
exports.pr_name = pr_name;
exports.pr_qualid = pr_qualid;
exports.pr_patvar = pr_patvar;
exports.pr_glob_level = pr_glob_level;
exports.pr_glob_sort = pr_glob_sort;
exports.pr_guard_annot = pr_guard_annot;
exports.pr_record_body = pr_record_body;
exports.pr_binders = pr_binders;
exports.pr_constr_pattern_expr = pr_constr_pattern_expr;
exports.pr_lconstr_pattern_expr = pr_lconstr_pattern_expr;
exports.pr_constr_expr = pr_constr_expr;
exports.pr_lconstr_expr = pr_lconstr_expr;
exports.pr_cases_pattern_expr = pr_cases_pattern_expr;
exports.pr_constr_expr_n = pr_constr_expr_n;
exports.set_term_pr = set_term_pr;
exports.default_term_pr = default_term_pr;
exports.lsimpleconstr = lsimpleconstr;
exports.ltop = ltop;
exports.modular_constr_pr = modular_constr_pr;
/* pr_fun_sep Not a pure module */
