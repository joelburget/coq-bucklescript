// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Hashset$ReactTemplate = require("./hashset.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Opaqueproof$ReactTemplate = require("./opaqueproof.bs.js");

function pop_dirpath(p) {
  var match = Names$ReactTemplate.DirPath[/* repr */4](p);
  if (match) {
    return Names$ReactTemplate.DirPath[/* make */3](match[1]);
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["dirpath_prefix"], Pp$ReactTemplate.str("empty dirpath."));
  }
}

function pop_mind(kn) {
  var match = Names$ReactTemplate.MutInd[/* repr3 */6](kn);
  return Names$ReactTemplate.MutInd[/* make3 */3](match[0], pop_dirpath(match[1]), match[2]);
}

function pop_con(con) {
  var match = Names$ReactTemplate.Constant[/* repr3 */6](con);
  return Names$ReactTemplate.Constant[/* make3 */3](match[0], pop_dirpath(match[1]), match[2]);
}

function equal(gr1, gr2) {
  switch (gr1.tag | 0) {
    case 0 : 
        switch (gr2.tag | 0) {
          case 0 : 
              return Curry._2(Names$ReactTemplate.Constant[/* SyntacticOrd */11][/* equal */1], gr1[0], gr2[0]);
          case 1 : 
          case 2 : 
              return /* false */0;
          
        }
        break;
    case 1 : 
        switch (gr2.tag | 0) {
          case 1 : 
              return Names$ReactTemplate.eq_syntactic_ind(gr1[0], gr2[0]);
          case 0 : 
          case 2 : 
              return /* false */0;
          
        }
        break;
    case 2 : 
        switch (gr2.tag | 0) {
          case 0 : 
          case 1 : 
              return /* false */0;
          case 2 : 
              return Names$ReactTemplate.eq_syntactic_constructor(gr1[0], gr2[0]);
          
        }
        break;
    
  }
}

function hash(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, Curry._1(Names$ReactTemplate.Constant[/* SyntacticOrd */11][/* hash */2], param[0]));
    case 1 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](2, Names$ReactTemplate.ind_syntactic_hash(param[0]));
    case 2 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](3, Names$ReactTemplate.constructor_syntactic_hash(param[0]));
    
  }
}

var RefHash = /* module */[
  /* equal */equal,
  /* hash */hash
];

var RefTable = Hashtbl.Make(RefHash);

function instantiate_my_gr(gr, u) {
  switch (gr.tag | 0) {
    case 0 : 
        return Constr$ReactTemplate.mkConstU(/* tuple */[
                    gr[0],
                    u
                  ]);
    case 1 : 
        return Constr$ReactTemplate.mkIndU(/* tuple */[
                    gr[0],
                    u
                  ]);
    case 2 : 
        return Constr$ReactTemplate.mkConstructU(/* tuple */[
                    gr[0],
                    u
                  ]);
    
  }
}

function share(cache, r, param) {
  var knl = param[1];
  try {
    return Curry._2(RefTable[/* find */6], cache, r);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var match;
      switch (r.tag | 0) {
        case 0 : 
            var cst = r[0];
            match = /* tuple */[
              /* ConstRef */Block.__(0, [pop_con(cst)]),
              Curry._2(Names$ReactTemplate.Cmap[/* find */21], cst, param[0])
            ];
            break;
        case 1 : 
            var match$1 = r[0];
            var kn = match$1[0];
            match = /* tuple */[
              /* IndRef */Block.__(1, [/* tuple */[
                    pop_mind(kn),
                    match$1[1]
                  ]]),
              Curry._2(Names$ReactTemplate.Mindmap[/* find */21], kn, knl)
            ];
            break;
        case 2 : 
            var match$2 = r[0];
            var match$3 = match$2[0];
            var kn$1 = match$3[0];
            match = /* tuple */[
              /* ConstructRef */Block.__(2, [/* tuple */[
                    /* tuple */[
                      pop_mind(kn$1),
                      match$3[1]
                    ],
                    match$2[1]
                  ]]),
              Curry._2(Names$ReactTemplate.Mindmap[/* find */21], kn$1, knl)
            ];
            break;
        
      }
      var match$4 = match[1];
      var c_000 = match[0];
      var c_001 = /* tuple */[
        match$4[0],
        Util$ReactTemplate.$$Array[/* map */12](Constr$ReactTemplate.mkVar, match$4[1])
      ];
      var c = /* tuple */[
        c_000,
        c_001
      ];
      Curry._3(RefTable[/* add */4], cache, r, c);
      return c;
    } else {
      throw exn;
    }
  }
}

function share_univs(cache, r, u, l) {
  var match = share(cache, r, l);
  var match$1 = match[1];
  return Constr$ReactTemplate.mkApp(/* tuple */[
              instantiate_my_gr(match[0], Univ$ReactTemplate.Instance[/* append */4](match$1[0], u)),
              match$1[1]
            ]);
}

function update_case_info(cache, ci, modlist) {
  try {
    var match = share(cache, /* IndRef */Block.__(1, [ci[/* ci_ind */0]]), modlist);
    var match$1 = match[0];
    var match$2;
    switch (match$1.tag | 0) {
      case 1 : 
          match$2 = /* tuple */[
            match$1[0],
            match[1][1].length
          ];
          break;
      case 0 : 
      case 2 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "cooking.ml",
                  94,
                  13
                ]
              ];
      
    }
    return /* record */[
            /* ci_ind */match$2[0],
            /* ci_npar */ci[/* ci_npar */1] + match$2[1] | 0,
            /* ci_cstr_ndecls */ci[/* ci_cstr_ndecls */2],
            /* ci_cstr_nargs */ci[/* ci_cstr_nargs */3],
            /* ci_pp_info */ci[/* ci_pp_info */4]
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ci;
    } else {
      throw exn;
    }
  }
}

function is_empty_modlist(param) {
  if (Curry._1(Names$ReactTemplate.Cmap[/* is_empty */1], param[0])) {
    return Curry._1(Names$ReactTemplate.Mindmap[/* is_empty */1], param[1]);
  } else {
    return /* false */0;
  }
}

function expmod_constr(cache, modlist, c) {
  var share_univs$1 = function (param, param$1, param$2) {
    return share_univs(cache, param, param$1, param$2);
  };
  var substrec = function (c) {
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 10 : 
          var match$1 = match[0];
          try {
            return share_univs$1(/* ConstRef */Block.__(0, [match$1[0]]), match$1[1], modlist);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return Constr$ReactTemplate.map(substrec, c);
            } else {
              throw exn;
            }
          }
          break;
      case 11 : 
          var match$2 = match[0];
          try {
            return share_univs$1(/* IndRef */Block.__(1, [match$2[0]]), match$2[1], modlist);
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              return Constr$ReactTemplate.map(substrec, c);
            } else {
              throw exn$1;
            }
          }
          break;
      case 12 : 
          var match$3 = match[0];
          try {
            return share_univs$1(/* ConstructRef */Block.__(2, [match$3[0]]), match$3[1], modlist);
          }
          catch (exn$2){
            if (exn$2 === Caml_builtin_exceptions.not_found) {
              return Constr$ReactTemplate.map(substrec, c);
            } else {
              throw exn$2;
            }
          }
          break;
      case 13 : 
          return Constr$ReactTemplate.map(substrec, Constr$ReactTemplate.mkCase(/* tuple */[
                          update_case_info(cache, match[0], modlist),
                          match[1],
                          match[2],
                          match[3]
                        ]));
      case 16 : 
          var c$prime = match[1];
          var p = match[0];
          try {
            var p$prime = share_univs$1(/* ConstRef */Block.__(0, [Names$ReactTemplate.Projection[/* constant */2](p)]), Univ$ReactTemplate.Instance[/* empty */0], modlist);
            var make = function (c) {
              return Names$ReactTemplate.Projection[/* make */0](c, Names$ReactTemplate.Projection[/* unfolded */3](p));
            };
            var match$4 = Constr$ReactTemplate.kind(p$prime);
            switch (match$4.tag | 0) {
              case 9 : 
                  var match$5 = Constr$ReactTemplate.kind(match$4[0]);
                  if (match$5.tag === 10) {
                    return Constr$ReactTemplate.mkProj(/* tuple */[
                                make(match$5[0][0]),
                                substrec(c$prime)
                              ]);
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "cooking.ml",
                            137,
                            15
                          ]
                        ];
                  }
                  break;
              case 10 : 
                  return Constr$ReactTemplate.mkProj(/* tuple */[
                              make(match$4[0][0]),
                              substrec(c$prime)
                            ]);
              default:
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "cooking.ml",
                        138,
                        13
                      ]
                    ];
            }
          }
          catch (exn$3){
            if (exn$3 === Caml_builtin_exceptions.not_found) {
              return Constr$ReactTemplate.map(substrec, c);
            } else {
              throw exn$3;
            }
          }
          break;
      default:
        return Constr$ReactTemplate.map(substrec, c);
    }
  };
  if (is_empty_modlist(modlist)) {
    return c;
  } else {
    return substrec(c);
  }
}

var abstract_constant_type = Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (c, d) {
        return Term$ReactTemplate.mkNamedProd_wo_LetIn(d, c);
      }));

var abstract_constant_body = Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (c, d) {
        return Term$ReactTemplate.mkNamedLambda_or_LetIn(d, c);
      }));

function on_body(ml, hy, f, x) {
  switch (x.tag | 0) {
    case 0 : 
        return x;
    case 1 : 
        return /* Def */Block.__(1, [Mod_subst$ReactTemplate.from_val(Curry._1(f, Mod_subst$ReactTemplate.force_constr(x[0])))]);
    case 2 : 
        return /* OpaqueDef */Block.__(2, [Opaqueproof$ReactTemplate.discharge_direct_opaque(f, /* record */[
                        /* modlist */ml,
                        /* abstract */hy
                      ], x[0])]);
    
  }
}

function expmod_constr_subst(cache, modlist, subst, c) {
  var subst$1 = Univ$ReactTemplate.make_instance_subst(subst);
  var c$1 = expmod_constr(cache, modlist, c);
  return Vars$ReactTemplate.subst_univs_level_constr(subst$1, c$1);
}

function cook_constr(param, c) {
  var match = param[/* abstract */1];
  var subst = match[1];
  var modlist = param[/* modlist */0];
  var cache = Curry._1(RefTable[/* create */0], 13);
  var expmod = function (param) {
    return expmod_constr_subst(cache, modlist, subst, param);
  };
  var hyps = Curry._1(Context$ReactTemplate.Named[/* map */6](expmod), match[0]);
  return Curry._2(abstract_constant_body, expmod(c), hyps);
}

function lift_univs(cb, subst, auctx0) {
  var match = cb[/* const_universes */4];
  if (match.tag) {
    var auctx = match[0];
    if (Univ$ReactTemplate.Instance[/* is_empty */1](subst)) {
      return /* tuple */[
              subst,
              /* Polymorphic_const */Block.__(1, [Univ$ReactTemplate.AUContext[/* union */5](auctx0, auctx)])
            ];
    } else {
      var ainst = Univ$ReactTemplate.make_abstract_instance(auctx);
      var subst$1 = Univ$ReactTemplate.Instance[/* append */4](subst, ainst);
      var auctx$prime = Univ$ReactTemplate.subst_univs_level_abstract_universe_context(Univ$ReactTemplate.make_instance_subst(subst$1), auctx);
      return /* tuple */[
              subst$1,
              /* Polymorphic_const */Block.__(1, [Univ$ReactTemplate.AUContext[/* union */5](auctx0, auctx$prime)])
            ];
    }
  } else {
    if (!Univ$ReactTemplate.AUContext[/* is_empty */2](auctx0)) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cooking.ml",
              186,
              4
            ]
          ];
    }
    return /* tuple */[
            subst,
            /* Monomorphic_const */Block.__(0, [match[0]])
          ];
  }
}

function cook_constant(hcons, _, param) {
  var info = param[/* info */1];
  var $$abstract = info[/* abstract */1];
  var modlist = info[/* modlist */0];
  var cb = param[/* from */0];
  var cache = Curry._1(RefTable[/* create */0], 13);
  var abs_ctx = $$abstract[2];
  var match = lift_univs(cb, $$abstract[1], abs_ctx);
  var usubst = match[0];
  var expmod = function (param) {
    return expmod_constr_subst(cache, modlist, usubst, param);
  };
  var hyps = Curry._1(Context$ReactTemplate.Named[/* map */6](expmod), $$abstract[0]);
  var map = function (c) {
    var c$1 = Curry._2(abstract_constant_body, expmod(c), hyps);
    if (hcons) {
      return Constr$ReactTemplate.hcons(c$1);
    } else {
      return c$1;
    }
  };
  var body = on_body(modlist, /* tuple */[
        hyps,
        usubst,
        abs_ctx
      ], map, cb[/* const_body */1]);
  var const_hyps = Context$ReactTemplate.Named[/* fold_outside */9]((function (decl, hyps) {
          return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (decl$prime) {
                        return 1 - Names$ReactTemplate.Id[/* equal */0](Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl$prime));
                      }), hyps);
        }), hyps, cb[/* const_hyps */0]);
  var typ = Curry._2(abstract_constant_type, expmod(cb[/* const_type */2]), hyps);
  var projection = function (pb) {
    var c$prime = Curry._2(abstract_constant_body, expmod(pb[/* proj_body */5]), hyps);
    var etab = Curry._2(abstract_constant_body, expmod(pb[/* proj_eta */4][0]), hyps);
    var etat = Curry._2(abstract_constant_body, expmod(pb[/* proj_eta */4][1]), hyps);
    var match;
    try {
      var c$prime$1 = share_univs(cache, /* IndRef */Block.__(1, [/* tuple */[
                pb[/* proj_ind */0],
                0
              ]]), Univ$ReactTemplate.Instance[/* empty */0], modlist);
      var match$1 = Constr$ReactTemplate.kind(c$prime$1);
      switch (match$1.tag | 0) {
        case 9 : 
            match = /* tuple */[
              Constr$ReactTemplate.destInd(match$1[0]),
              match$1[1].length
            ];
            break;
        case 11 : 
            match = /* tuple */[
              match$1[0],
              0
            ];
            break;
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "cooking.ml",
                  240,
                  10
                ]
              ];
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        match = /* tuple */[
          /* tuple */[
            /* tuple */[
              pb[/* proj_ind */0],
              0
            ],
            Univ$ReactTemplate.Instance[/* empty */0]
          ],
          0
        ];
      } else {
        throw exn;
      }
    }
    var n$prime = match[1];
    var match$2 = Term$ReactTemplate.decompose_prod_n((n$prime + pb[/* proj_npars */1] | 0) + 1 | 0)(typ);
    return /* record */[
            /* proj_ind */match[0][0][0],
            /* proj_npars */pb[/* proj_npars */1] + n$prime | 0,
            /* proj_arg */pb[/* proj_arg */2],
            /* proj_type */match$2[1],
            /* proj_eta : tuple */[
              etab,
              etat
            ],
            /* proj_body */c$prime
          ];
  };
  return /* record */[
          /* cook_body */body,
          /* cook_type */typ,
          /* cook_proj */Option$ReactTemplate.map(projection, cb[/* const_proj */5]),
          /* cook_universes */match[1],
          /* cook_inline */cb[/* const_inline_code */6],
          /* cook_context : Some */[const_hyps]
        ];
}

function expmod_constr$1(modlist, c) {
  return expmod_constr(Curry._1(RefTable[/* create */0], 13), modlist, c);
}

exports.cook_constant = cook_constant;
exports.cook_constr = cook_constr;
exports.expmod_constr = expmod_constr$1;
/* RefTable Not a pure module */
