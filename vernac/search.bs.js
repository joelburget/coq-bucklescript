// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Str$ReactTemplate = require("../shims/str.bs.js");
var CSet$ReactTemplate = require("../src/cSet.bs.js");
var Heap$ReactTemplate = require("../clib/heap.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Coqlib$ReactTemplate = require("../library/coqlib.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Pfedit$ReactTemplate = require("../src/pfedit.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Libobject$ReactTemplate = require("../src/libobject.bs.js");
var Declareops$ReactTemplate = require("../src/declareops.bs.js");
var Declaremods$ReactTemplate = require("../src/declaremods.bs.js");
var Inductiveops$ReactTemplate = require("../src/inductiveops.bs.js");
var Constr_matching$ReactTemplate = require("../src/constr_matching.bs.js");

function member_message(s, b) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Search blacklist does "), b ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.str("not ")), Pp$ReactTemplate.str("include ")), Pp$ReactTemplate.str(s));
}

var SearchBlacklist = Goptions$ReactTemplate.MakeStringTable(/* module */[
      /* key : :: */[
        "Search",
        /* :: */[
          "Blacklist",
          /* [] */0
        ]
      ],
      /* title */"Current search blacklist : ",
      /* member_message */member_message
    ]);

function iter_named_context_name_type(f) {
  return Curry._1(Util$ReactTemplate.List[/* iter */9], (function (decl) {
                return Curry._2(f, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl));
              }));
}

function iter_hypothesis(glnum, fn) {
  var env = Global$ReactTemplate.env(/* () */0);
  var iter_hyp = function (idh, typ) {
    return Curry._3(fn, /* VarRef */Block.__(0, [idh]), env, typ);
  };
  var match = Pfedit$ReactTemplate.get_goal_context(glnum);
  return Curry._1(iter_named_context_name_type(iter_hyp), Environ$ReactTemplate.named_context(match[1]));
}

function generic_search(glnumopt, fn) {
  if (glnumopt) {
    iter_hypothesis(glnumopt[0], fn);
  }
  var fn$1 = fn;
  var env = Global$ReactTemplate.env(/* () */0);
  var iter_obj = function (param, lobj) {
    var kn = param[1];
    var match = Libobject$ReactTemplate.object_tag(lobj);
    switch (match) {
      case "CONSTANT" : 
          var cst = Global$ReactTemplate.constant_of_delta_kn(kn);
          var gr = /* ConstRef */Block.__(1, [cst]);
          var match$1 = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), gr);
          return Curry._3(fn$1, gr, env, match$1[0]);
      case "INDUCTIVE" : 
          var mind = Global$ReactTemplate.mind_of_delta_kn(kn);
          var mib = Global$ReactTemplate.lookup_mind(mind);
          var iter_packet = function (i, mip) {
            var ind = /* tuple */[
              mind,
              i
            ];
            var u = Univ$ReactTemplate.make_abstract_instance(Declareops$ReactTemplate.inductive_polymorphic_context(mib));
            var i$1 = /* tuple */[
              ind,
              u
            ];
            var typ = Inductiveops$ReactTemplate.type_of_inductive(env, i$1);
            Curry._3(fn$1, /* IndRef */Block.__(2, [ind]), env, typ);
            var len = mip[/* mind_user_lc */4].length;
            var indsp = ind;
            var u$1 = u;
            var fn$2 = fn$1;
            var env$1 = env;
            var nconstr = len;
            for(var i$2 = 1; i$2 <= nconstr; ++i$2){
              var typ$1 = Inductiveops$ReactTemplate.type_of_constructor(env$1, /* tuple */[
                    /* tuple */[
                      indsp,
                      i$2
                    ],
                    u$1
                  ]);
              Curry._3(fn$2, /* ConstructRef */Block.__(3, [/* tuple */[
                        indsp,
                        i$2
                      ]]), env$1, typ$1);
            }
            return /* () */0;
          };
          return Util$ReactTemplate.$$Array[/* iteri */13](iter_packet, mib[/* mind_packets */0]);
      case "VARIABLE" : 
          try {
            var decl = Global$ReactTemplate.lookup_named(Libnames$ReactTemplate.basename(param[0]));
            return Curry._3(fn$1, /* VarRef */Block.__(0, [Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl)]), env, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* () */0;
            } else {
              throw exn;
            }
          }
          break;
      default:
        return /* () */0;
    }
  };
  try {
    return Declaremods$ReactTemplate.iter_all_segments(iter_obj);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

var ConstrSet = CSet$ReactTemplate.Make([Constr$ReactTemplate.compare]);

function size(t) {
  return Constr$ReactTemplate.fold((function (s, t) {
                return (1 + s | 0) + size(t) | 0;
              }), 0, t);
}

function symbols(acc, t) {
  var match = Constr$ReactTemplate.kind(t);
  switch (match.tag | 0) {
    case 10 : 
    case 11 : 
    case 12 : 
        return Curry._2(ConstrSet[/* add */3], t, acc);
    default:
      return Constr$ReactTemplate.fold(symbols, acc, t);
  }
}

function num_symbols(t) {
  return Curry._1(ConstrSet[/* cardinal */18], symbols(ConstrSet[/* empty */0], t));
}

function priority(t) {
  return -(Caml_int32.imul(3, num_symbols(t)) + size(t) | 0) | 0;
}

function compare(param, param$1) {
  return Caml_obj.caml_compare(param[3], param$1[3]);
}

var PriorityQueue = Heap$ReactTemplate.Functional([compare]);

function prioritize_search(seq, fn) {
  var acc = [PriorityQueue[/* empty */0]];
  var iter = function (gref, env, t) {
    var p = priority(t);
    acc[0] = Curry._2(PriorityQueue[/* add */1], /* tuple */[
          gref,
          env,
          t,
          p
        ], acc[0]);
    return /* () */0;
  };
  Curry._1(seq, iter);
  var _q = acc[0];
  var fn$1 = fn;
  while(true) {
    var q = _q;
    var next;
    try {
      next = /* Some */[Curry._1(PriorityQueue[/* maximum */2], q)];
    }
    catch (exn){
      if (exn === Heap$ReactTemplate.EmptyHeap) {
        next = /* None */0;
      } else {
        throw exn;
      }
    }
    if (next) {
      var match = next[0];
      Curry._3(fn$1, match[0], match[1], match[2]);
      _q = Curry._1(PriorityQueue[/* remove */3], q);
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function pattern_filter(pat, _, env, sigma, _typ) {
  while(true) {
    var typ = _typ;
    var typ$1 = Termops$ReactTemplate.strip_outer_cast(sigma, typ);
    if (Constr_matching$ReactTemplate.is_matching(env, sigma, pat, typ$1)) {
      return /* true */1;
    } else {
      var match = EConstr$ReactTemplate.kind(sigma, typ$1);
      switch (match.tag | 0) {
        case 6 : 
            _typ = match[2];
            continue ;
            case 8 : 
            _typ = match[3];
            continue ;
            default:
          return /* false */0;
      }
    }
  };
}

function head_filter(pat, _, env, sigma, _typ) {
  while(true) {
    var typ = _typ;
    var typ$1 = Termops$ReactTemplate.strip_outer_cast(sigma, typ);
    if (Constr_matching$ReactTemplate.is_matching_head(env, sigma, pat, typ$1)) {
      return /* true */1;
    } else {
      var match = EConstr$ReactTemplate.kind(sigma, typ$1);
      switch (match.tag | 0) {
        case 6 : 
            _typ = match[2];
            continue ;
            case 8 : 
            _typ = match[3];
            continue ;
            default:
          return /* false */0;
      }
    }
  };
}

function full_name_of_reference(ref) {
  var match = Libnames$ReactTemplate.repr_path(Nametab$ReactTemplate.path_of_global(ref));
  return Names$ReactTemplate.DirPath[/* to_string */7](match[0]) + ("." + Names$ReactTemplate.Id[/* to_string */7](match[1]));
}

function blacklist_filter_aux() {
  var l = Curry._1(SearchBlacklist[/* elements */1], /* () */0);
  return (function (ref, _, _$1) {
      var name = full_name_of_reference(ref);
      var is_not_bl = function (str) {
        return 1 - Curry._2(Util$ReactTemplate.$$String[/* string_contains */32], name, str);
      };
      return Curry._2(Util$ReactTemplate.List[/* for_all */20], is_not_bl, l);
    });
}

function module_filter(param, ref, _, _$1) {
  var mods = param[0];
  var sp = Nametab$ReactTemplate.path_of_global(ref);
  var sl = Libnames$ReactTemplate.dirpath(sp);
  var is_outside = function (md) {
    return 1 - Libnames$ReactTemplate.is_dirpath_prefix_of(md, sl);
  };
  var is_inside = function (md) {
    return Libnames$ReactTemplate.is_dirpath_prefix_of(md, sl);
  };
  if (param[1]) {
    return Curry._2(Util$ReactTemplate.List[/* for_all */20], is_outside, mods);
  } else if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], mods)) {
    return /* true */1;
  } else {
    return Curry._2(Util$ReactTemplate.List[/* exists */21], is_inside, mods);
  }
}

function search_about_filter(query, gr, env, typ) {
  if (query.tag) {
    return Curry._2(Util$ReactTemplate.$$String[/* string_contains */32], Names$ReactTemplate.Id[/* to_string */7](Nametab$ReactTemplate.basename_of_global(gr)), query[0]);
  } else {
    return Constr_matching$ReactTemplate.is_matching_appsubterm(/* Some */[/* false */0], env, Evd$ReactTemplate.empty, query[0], EConstr$ReactTemplate.of_constr(typ));
  }
}

function search_pattern(gopt, pat, mods, pr_search) {
  var blacklist_filter = blacklist_filter_aux(/* () */0);
  var filter = function (ref, env, typ) {
    if (module_filter(mods, ref, env, typ) && pattern_filter(pat, ref, env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(typ))) {
      return Curry._3(blacklist_filter, ref, env, typ);
    } else {
      return /* false */0;
    }
  };
  var iter = function (ref, env, typ) {
    if (filter(ref, env, typ)) {
      return Curry._3(pr_search, ref, env, typ);
    } else {
      return 0;
    }
  };
  return generic_search(gopt, iter);
}

function rewrite_pat1(pat) {
  return /* PApp */Block.__(4, [
            /* PRef */Block.__(0, [Coqlib$ReactTemplate.glob_eq]),
            /* array */[
              /* PMeta */Block.__(11, [/* None */0]),
              pat,
              /* PMeta */Block.__(11, [/* None */0])
            ]
          ]);
}

function rewrite_pat2(pat) {
  return /* PApp */Block.__(4, [
            /* PRef */Block.__(0, [Coqlib$ReactTemplate.glob_eq]),
            /* array */[
              /* PMeta */Block.__(11, [/* None */0]),
              /* PMeta */Block.__(11, [/* None */0]),
              pat
            ]
          ]);
}

function search_rewrite(gopt, pat, mods, pr_search) {
  var pat1 = rewrite_pat1(pat);
  var pat2 = rewrite_pat2(pat);
  var blacklist_filter = blacklist_filter_aux(/* () */0);
  var filter = function (ref, env, typ) {
    if (module_filter(mods, ref, env, typ) && (pattern_filter(pat1, ref, env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(typ)) || pattern_filter(pat2, ref, env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(typ)))) {
      return Curry._3(blacklist_filter, ref, env, typ);
    } else {
      return /* false */0;
    }
  };
  var iter = function (ref, env, typ) {
    if (filter(ref, env, typ)) {
      return Curry._3(pr_search, ref, env, typ);
    } else {
      return 0;
    }
  };
  return generic_search(gopt, iter);
}

function search_by_head(gopt, pat, mods, pr_search) {
  var blacklist_filter = blacklist_filter_aux(/* () */0);
  var filter = function (ref, env, typ) {
    if (module_filter(mods, ref, env, typ) && head_filter(pat, ref, env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(typ))) {
      return Curry._3(blacklist_filter, ref, env, typ);
    } else {
      return /* false */0;
    }
  };
  var iter = function (ref, env, typ) {
    if (filter(ref, env, typ)) {
      return Curry._3(pr_search, ref, env, typ);
    } else {
      return 0;
    }
  };
  return generic_search(gopt, iter);
}

function search_about(gopt, items, mods, pr_search) {
  var blacklist_filter = blacklist_filter_aux(/* () */0);
  var filter = function (ref, env, typ) {
    if (module_filter(mods, ref, env, typ) && Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
              var b1 = param[0];
              var b2 = search_about_filter(param[1], ref, env, typ);
              if (b1) {
                return b2;
              } else {
                return 1 - b2;
              }
            }), items)) {
      return Curry._3(blacklist_filter, ref, env, typ);
    } else {
      return /* false */0;
    }
  };
  var iter = function (ref, env, typ) {
    if (filter(ref, env, typ)) {
      return Curry._3(pr_search, ref, env, typ);
    } else {
      return 0;
    }
  };
  return generic_search(gopt, iter);
}

function extract_flags(_name, _tpe, _subtpe, _mods, _blacklist, _param) {
  while(true) {
    var param = _param;
    var blacklist = _blacklist;
    var mods = _mods;
    var subtpe = _subtpe;
    var tpe = _tpe;
    var name = _name;
    if (param) {
      var match = param[0];
      var match$1 = match[0];
      if (typeof match$1 === "number") {
        _param = param[1];
        _blacklist = match[1];
        continue ;
        
      } else {
        switch (match$1.tag | 0) {
          case 0 : 
              _param = param[1];
              _name = /* :: */[
                /* tuple */[
                  match$1[0],
                  match[1]
                ],
                name
              ];
              continue ;
              case 1 : 
              _param = param[1];
              _tpe = /* :: */[
                /* tuple */[
                  match$1[0],
                  match[1]
                ],
                tpe
              ];
              continue ;
              case 2 : 
              _param = param[1];
              _subtpe = /* :: */[
                /* tuple */[
                  match$1[0],
                  match[1]
                ],
                subtpe
              ];
              continue ;
              case 3 : 
              _param = param[1];
              _mods = /* :: */[
                /* tuple */[
                  match$1[0],
                  match[1]
                ],
                mods
              ];
              continue ;
              
        }
      }
    } else {
      return /* tuple */[
              name,
              tpe,
              subtpe,
              mods,
              blacklist
            ];
    }
  };
}

function interface_search(glnum, flags) {
  var match = extract_flags(/* [] */0, /* [] */0, /* [] */0, /* [] */0, /* false */0, flags);
  var blacklist = match[4];
  var mods = match[3];
  var subtpe = match[2];
  var tpe = match[1];
  var name = match[0];
  var blacklist_filter = blacklist_filter_aux(/* () */0);
  var filter_function = function (ref, env, constr) {
    var id = Names$ReactTemplate.Id[/* to_string */7](Nametab$ReactTemplate.basename_of_global(ref));
    var path = Libnames$ReactTemplate.dirpath(Nametab$ReactTemplate.path_of_global(ref));
    var toggle = function (x, b) {
      if (x) {
        return b;
      } else {
        return 1 - b;
      }
    };
    var match_name = function (param) {
      return toggle(Curry._3(Str$ReactTemplate.string_match, param[0], id, 0), param[1]);
    };
    var match_type = function (param) {
      return toggle(Constr_matching$ReactTemplate.is_matching(env, Evd$ReactTemplate.empty, param[0], EConstr$ReactTemplate.of_constr(constr)), param[1]);
    };
    var match_subtype = function (param) {
      return toggle(Constr_matching$ReactTemplate.is_matching_appsubterm(/* Some */[/* false */0], env, Evd$ReactTemplate.empty, param[0], EConstr$ReactTemplate.of_constr(constr)), param[1]);
    };
    var match_module = function (param) {
      return toggle(Libnames$ReactTemplate.is_dirpath_prefix_of(param[0], path), param[1]);
    };
    if (Curry._2(Util$ReactTemplate.List[/* for_all */20], match_name, name) && Curry._2(Util$ReactTemplate.List[/* for_all */20], match_type, tpe) && Curry._2(Util$ReactTemplate.List[/* for_all */20], match_subtype, subtpe) && Curry._2(Util$ReactTemplate.List[/* for_all */20], match_module, mods)) {
      if (blacklist) {
        return /* true */1;
      } else {
        return Curry._3(blacklist_filter, ref, env, constr);
      }
    } else {
      return /* false */0;
    }
  };
  var ans = [/* [] */0];
  var iter = function (ref, env, typ) {
    if (filter_function(ref, env, typ)) {
      var ref$1 = ref;
      var constr = typ;
      var fullpath = Names$ReactTemplate.DirPath[/* repr */4](Nametab$ReactTemplate.dirpath_of_global(ref$1));
      var qualid = Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], ref$1);
      var match = Libnames$ReactTemplate.repr_qualid(qualid);
      var shortpath = Names$ReactTemplate.DirPath[/* repr */4](match[0]);
      var prefix = function (_full, _short, _accu) {
        while(true) {
          var accu = _accu;
          var $$short = _short;
          var full = _full;
          if ($$short) {
            if (full) {
              _accu = /* :: */[
                Names$ReactTemplate.Id[/* to_string */7]($$short[0]),
                accu
              ];
              _short = $$short[1];
              _full = full[1];
              continue ;
              
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "search.ml",
                      363,
                      11
                    ]
                  ];
            }
          } else {
            var full$1 = Curry._2(Util$ReactTemplate.List[/* rev_map */12], Names$ReactTemplate.Id[/* to_string */7], full);
            return /* tuple */[
                    full$1,
                    accu
                  ];
          }
        };
      };
      var match$1 = prefix(fullpath, shortpath, /* :: */[
            Names$ReactTemplate.Id[/* to_string */7](match[1]),
            /* [] */0
          ]);
      var answer_000 = /* coq_object_prefix */match$1[0];
      var answer_001 = /* coq_object_qualid */match$1[1];
      var answer = /* record */[
        answer_000,
        answer_001,
        /* coq_object_object */constr
      ];
      ans[0] = /* :: */[
        answer,
        ans[0]
      ];
      return /* () */0;
    } else {
      return 0;
    }
  };
  generic_search(glnum, iter);
  return ans[0];
}

function blacklist_filter(ref, env, typ) {
  return blacklist_filter_aux(/* () */0)(ref, env, typ);
}

exports.blacklist_filter = blacklist_filter;
exports.module_filter = module_filter;
exports.search_about_filter = search_about_filter;
exports.search_by_head = search_by_head;
exports.search_rewrite = search_rewrite;
exports.search_pattern = search_pattern;
exports.search_about = search_about;
exports.interface_search = interface_search;
exports.generic_search = generic_search;
exports.prioritize_search = prioritize_search;
/* SearchBlacklist Not a pure module */
