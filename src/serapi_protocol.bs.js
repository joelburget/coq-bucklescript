// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Stream = require("bs-platform/lib/js/stream.js");
var $$String = require("bs-platform/lib/js/string.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var Stm$ReactTemplate = require("./stm.bs.js");
var Tok$ReactTemplate = require("./tok.bs.js");
var Pcoq$ReactTemplate = require("./pcoq.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Proof$ReactTemplate = require("./proof.bs.js");
var CLexer$ReactTemplate = require("./cLexer.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Pfedit$ReactTemplate = require("./pfedit.bs.js");
var Search$ReactTemplate = require("../vernac/search.bs.js");
var Tacenv$ReactTemplate = require("../shims/tacenv.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Impargs$ReactTemplate = require("./impargs.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Printer$ReactTemplate = require("./printer.bs.js");
var Stateid$ReactTemplate = require("./stateid.bs.js");
var Genprint$ReactTemplate = require("./genprint.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Notation$ReactTemplate = require("./notation.bs.js");
var Ppconstr$ReactTemplate = require("./ppconstr.bs.js");
var Ppvernac$ReactTemplate = require("./ppvernac.bs.js");
var Printmod$ReactTemplate = require("../printing/printmod.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Proof_global$ReactTemplate = require("./proof_global.bs.js");
var Serapi_goals$ReactTemplate = require("./serapi_goals.bs.js");

function hd_opt(l) {
  if (l) {
    return /* Some */[l[0]];
  } else {
    return /* None */0;
  }
}

function is_prefix(s, prefix) {
  var s$1 = s;
  var prefix$1 = prefix;
  var char_equal = function (x, y) {
    return +(x === y);
  };
  var prefix_len = prefix$1.length;
  if (s$1.length >= prefix_len) {
    var s$2 = s$1;
    var prefix$2 = prefix$1;
    var char_equal$1 = char_equal;
    var _i = prefix_len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return /* true */1;
      } else if (Curry._2(char_equal$1, Caml_string.get(prefix$2, i), Caml_string.get(s$2, i))) {
        _i = i - 1 | 0;
        continue ;
        
      } else {
        return /* false */0;
      }
    };
  } else {
    return /* false */0;
  }
}

function stream_tok(_acc, str) {
  while(true) {
    var acc = _acc;
    var e = Stream.next(str);
    if (Tok$ReactTemplate.equal(e, /* EOI */1)) {
      return List.rev(/* :: */[
                  e,
                  acc
                ]);
    } else {
      _acc = /* :: */[
        e,
        acc
      ];
      continue ;
      
    }
  };
}

var NoSuchState = Caml_exceptions.create("Serapi_protocol-ReactTemplate.NoSuchState");

function pp_goal_gen(pr_c, param) {
  var pr_idl = function (idl) {
    return Pp$ReactTemplate.prlist_with_sep((function () {
                  return Pp$ReactTemplate.str(", ");
                }), Names$ReactTemplate.Id[/* print */8], idl);
  };
  var pr_lconstr_opt = function (c) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" := "), Curry._1(pr_c, c));
  };
  var partial_arg = Pp$ReactTemplate.mt(/* () */0);
  var pr_hdef = function (param) {
    return Option$ReactTemplate.cata(pr_lconstr_opt, partial_arg, param);
  };
  var pr_hyp = function (param) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_idl(param[0]), Curry._1(pr_hdef, param[1])), Pp$ReactTemplate.str(" : ")), Curry._1(pr_c, param[2]));
  };
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_vertical_list(pr_hyp, param[/* hyp */2]), Pp$ReactTemplate.str("============================\n")), Curry._1(pr_c, param[/* ty */1]));
}

function pp_opt_value(s) {
  switch (s.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.bool(s[0]);
    case 1 : 
        return Pp$ReactTemplate.pr_opt(Pp$ReactTemplate.$$int, s[0]);
    case 2 : 
        return Pp$ReactTemplate.str(s[0]);
    case 3 : 
        return Pp$ReactTemplate.pr_opt(Pp$ReactTemplate.str, s[0]);
    
  }
}

function pp_implicit(param) {
  if (param) {
    return Names$ReactTemplate.Id[/* print */8](param[0][0]);
  } else {
    return Pp$ReactTemplate.str("!");
  }
}

function gen_pp_obj(obj) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  var env = match[1];
  var sigma = match[0];
  switch (obj.tag | 0) {
    case 1 : 
        return Pp$ReactTemplate.pr_sequence(Pp$ReactTemplate.str, obj[0]);
    case 2 : 
        return obj[0];
    case 3 : 
        return Pp$ReactTemplate.mt(/* () */0);
    case 4 : 
        return Pp$ReactTemplate.pr_sequence((function (tok) {
                      return Pp$ReactTemplate.str(Tok$ReactTemplate.to_string(tok));
                    }), obj[0]);
    case 5 : 
        return Ppvernac$ReactTemplate.pr_vernac(obj[0][1]);
    case 6 : 
        var n = obj[0];
        var s = obj[1];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str($$String.concat(".", n)), Pp$ReactTemplate.str(" := ")), pp_opt_value(s[/* opt_value */2]));
    case 7 : 
        return Printer$ReactTemplate.pr_lconstr_env(env, sigma, obj[0]);
    case 8 : 
        return Ppconstr$ReactTemplate.pr_lconstr_expr(obj[0]);
    case 9 : 
        return Printmod$ReactTemplate.pr_mutual_inductive_body(env, obj[0], obj[1], /* None */0);
    case 10 : 
        return Names$ReactTemplate.KerName[/* print */7](obj[0]);
    case 11 : 
        throw [
              Caml_builtin_exceptions.match_failure,
              [
                "serapi_protocol.ml",
                187,
                2
              ]
            ];
    case 12 : 
        var match$1 = Genprint$ReactTemplate.generic_raw_print(obj[0]);
        if (match$1.tag) {
          return Curry._1(match$1[0][/* printer */2], /* tuple */[
                      99,
                      /* Any */2
                    ]);
        } else {
          return Curry._1(match$1[0], /* () */0);
        }
        break;
    case 13 : 
        return Pp$ReactTemplate.str(Libnames$ReactTemplate.string_of_qualid(obj[0]));
    case 14 : 
        return Pp$ReactTemplate.str("FIXME GlobRef");
    case 15 : 
        return Pp$ReactTemplate.pr_sequence(pp_implicit, obj[0][1]);
    case 16 : 
        return Pp$ReactTemplate.str("FIXME UPSTREAM, provide pr_prof_results");
    case 0 : 
    case 17 : 
        return Pp$ReactTemplate.str(obj[0]);
    case 18 : 
        return Pp$ReactTemplate.str("FIXME Unparsing");
    case 19 : 
        return Pp$ReactTemplate.pr_sequence((function (param) {
                      return pp_goal_gen((function (param) {
                                    return Printer$ReactTemplate.pr_lconstr_env(env, sigma, param);
                                  }), param);
                    }), obj[0][/* fg_goals */0]);
    case 20 : 
        return Pp$ReactTemplate.pr_sequence((function (param) {
                      return pp_goal_gen(Ppconstr$ReactTemplate.pr_lconstr_expr, param);
                    }), obj[0][/* fg_goals */0]);
    case 21 : 
        return Pp$ReactTemplate.str("FIXME UPSTREAM, provide pr_proof");
    
  }
}

function str_pp_obj(fmt, obj) {
  return Curry._2(Format.fprintf(fmt, /* Format */[
                  /* Alpha */Block.__(15, [/* End_of_format */0]),
                  "%a"
                ]), Pp$ReactTemplate.pp_with, gen_pp_obj(obj));
}

function obj_print(pr_opt, obj) {
  var match = pr_opt[/* pp_format */0];
  switch (match) {
    case 0 : 
        return obj;
    case 1 : 
        var mb = Format.pp_get_max_boxes(Format.str_formatter, /* () */0);
        var et = Format.pp_get_ellipsis_text(Format.str_formatter, /* () */0);
        var mg = Format.pp_get_margin(Format.str_formatter, /* () */0);
        Format.pp_set_max_boxes(Format.str_formatter, pr_opt[/* pp_depth */1]);
        Format.pp_set_ellipsis_text(Format.str_formatter, pr_opt[/* pp_elide */2]);
        Format.pp_set_margin(Format.str_formatter, pr_opt[/* pp_margin */3]);
        Curry._2(Format.fprintf(Format.str_formatter, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* End_of_format */0,
                            ""
                          ]]),
                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                              /* Close_box */0,
                              /* End_of_format */0
                            ])])
                    ]),
                  "@[%a@]"
                ]), str_pp_obj, obj);
        var str_obj = /* CoqString */Block.__(0, [Format.flush_str_formatter(/* () */0)]);
        Format.pp_set_max_boxes(Format.str_formatter, mb);
        Format.pp_set_ellipsis_text(Format.str_formatter, et);
        Format.pp_set_margin(Format.str_formatter, mg);
        return str_obj;
    case 2 : 
        return /* CoqString */Block.__(0, [Pervasives.failwith("pp_tex")]);
    case 3 : 
        return /* CoqPp */Block.__(2, [gen_pp_obj(obj)]);
    
  }
}

function query_tactics(prefix) {
  var prefix_long = function (kn) {
    return is_prefix(Names$ReactTemplate.KerName[/* to_string */5](kn), prefix);
  };
  var tpred = function (kn, _) {
    if (prefix_long(kn)) {
      return /* true */1;
    } else {
      var kn$1 = kn;
      try {
        return is_prefix(Libnames$ReactTemplate.string_of_qualid(Curry._1(Tacenv$ReactTemplate.shortest_qualid_of_tactic, kn$1)), prefix);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* false */0;
        } else {
          throw exn;
        }
      }
    }
  };
  return Curry._1(Names$ReactTemplate.KNmap[/* bindings */16], Curry._2(Names$ReactTemplate.KNmap[/* filter */13], tpred, Curry._1(Tacenv$ReactTemplate.ltac_entries, /* () */0)));
}

function query_unparsing(nt) {
  return /* tuple */[
          Notation$ReactTemplate.find_notation_printing_rule(nt),
          Notation$ReactTemplate.find_notation_extra_printing_rules(nt),
          Notation$ReactTemplate.find_notation_parsing_rules(nt)
        ];
}

function locate(id) {
  var qid = Libnames$ReactTemplate.qualid_of_string(id);
  var expand = function (param) {
    if (param.tag) {
      return Nametab$ReactTemplate.shortest_qualid_of_syndef(Names$ReactTemplate.Id[/* Set */9][/* empty */0], param[0]);
    } else {
      return Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], param[0]);
    }
  };
  return List.map(expand, Nametab$ReactTemplate.locate_extended_all(qid));
}

function implicits(id) {
  try {
    return Impargs$ReactTemplate.implicits_of_global(Nametab$ReactTemplate.locate(Libnames$ReactTemplate.qualid_of_ident(Names$ReactTemplate.Id[/* of_string */5](id))));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

function info_of_id(id) {
  var qid = Libnames$ReactTemplate.qualid_of_string(id);
  try {
    var lid = Nametab$ReactTemplate.locate(qid);
    switch (lid.tag | 0) {
      case 0 : 
          var vr = lid[0];
          var vdef = Global$ReactTemplate.lookup_named(vr);
          return /* tuple */[
                  Option$ReactTemplate.cata((function (cb) {
                          return /* :: */[
                                  /* CoqConstr */Block.__(7, [cb]),
                                  /* [] */0
                                ];
                        }), /* [] */0, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], vdef)),
                  /* :: */[
                    /* CoqConstr */Block.__(7, [Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], vdef)]),
                    /* [] */0
                  ]
                ];
      case 1 : 
          var cr = lid[0];
          var cdef = Global$ReactTemplate.lookup_constant(cr);
          return /* tuple */[
                  Option$ReactTemplate.cata((function (param) {
                          return /* :: */[
                                  /* CoqConstr */Block.__(7, [param[0]]),
                                  /* [] */0
                                ];
                        }), /* [] */0, Global$ReactTemplate.body_of_constant(cr)),
                  /* :: */[
                    /* CoqConstr */Block.__(7, [cdef[/* const_type */2]]),
                    /* [] */0
                  ]
                ];
      case 2 : 
          var param = lid[0];
          var sp = param[0];
          return /* tuple */[
                  /* :: */[
                    /* CoqMInd */Block.__(9, [
                        sp,
                        Global$ReactTemplate.lookup_mind(sp)
                      ]),
                    /* [] */0
                  ],
                  /* [] */0
                ];
      case 3 : 
          var cr$1 = lid[0];
          var match = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), /* ConstructRef */Block.__(3, [cr$1]));
          return /* tuple */[
                  /* [] */0,
                  /* :: */[
                    /* CoqConstr */Block.__(7, [match[0]]),
                    /* [] */0
                  ]
                ];
      
    }
  }
  catch (exn){
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

var doc_id = [0];

function obj_query(opt, cmd) {
  var doc = Stm$ReactTemplate.get_doc(doc_id[0]);
  if (typeof cmd === "number") {
    switch (cmd) {
      case 0 : 
          var table = Goptions$ReactTemplate.get_tables(/* () */0);
          var opts = Curry._1(Goptions$ReactTemplate.OptionMap[/* bindings */16], table);
          return List.map((function (param) {
                        return /* CoqOption */Block.__(6, [
                                  param[0],
                                  param[1]
                                ]);
                      }), opts);
      case 1 : 
          return /* :: */[
                  /* CoqString */Block.__(0, ["Not Implemented"]),
                  /* [] */0
                ];
      case 2 : 
          return Option$ReactTemplate.cata((function (g) {
                        return /* :: */[
                                /* CoqGoal */Block.__(19, [g]),
                                /* [] */0
                              ];
                      }), /* [] */0, Serapi_goals$ReactTemplate.get_goals(doc, opt[/* sid */0]));
      case 3 : 
          return Option$ReactTemplate.cata((function (g) {
                        return /* :: */[
                                /* CoqExtGoal */Block.__(20, [g]),
                                /* [] */0
                              ];
                      }), /* [] */0, Serapi_goals$ReactTemplate.get_egoals(doc, opt[/* sid */0]));
      case 4 : 
          return Option$ReactTemplate.cata((function (last) {
                        return /* :: */[
                                /* CoqAst */Block.__(5, [last]),
                                /* [] */0
                              ];
                      }), /* [] */0, Stm$ReactTemplate.get_ast(doc, opt[/* sid */0]));
      case 5 : 
          return List.map((function (s) {
                        return /* CoqNotation */Block.__(17, [s]);
                      }), Notation$ReactTemplate.get_defined_notations(/* () */0));
      case 6 : 
          throw [
                Caml_builtin_exceptions.match_failure,
                [
                  "serapi_protocol.ml",
                  499,
                  2
                ]
              ];
      case 7 : 
          try {
            var match = Proof$ReactTemplate.proof(Proof_global$ReactTemplate.give_me_the_proof(/* () */0));
            return /* :: */[
                    /* CoqProof */Block.__(21, [
                        match[0],
                        match[1],
                        match[2],
                        match[3]
                      ]),
                    /* [] */0
                  ];
          }
          catch (exn){
            if (exn === Proof_global$ReactTemplate.NoCurrentProof) {
              return /* [] */0;
            } else {
              throw exn;
            }
          }
          break;
      
    }
  } else {
    switch (cmd.tag | 0) {
      case 0 : 
          return info_of_id(cmd[0])[1];
      case 1 : 
          var prefix = cmd[0];
          var all_gr = Nametab$ReactTemplate.locate_all(Libnames$ReactTemplate.qualid_of_ident(Names$ReactTemplate.Id[/* of_string */5](prefix)));
          return List.map((function (x) {
                        return /* CoqGlobRef */Block.__(14, [x]);
                      }), all_gr);
      case 2 : 
          return List.map((function (param) {
                        return /* CoqTactic */Block.__(10, [
                                  param[0],
                                  param[1]
                                ]);
                      }), query_tactics(cmd[0]));
      case 3 : 
          return List.map((function (qid) {
                        return /* CoqQualId */Block.__(13, [qid]);
                      }), locate(cmd[0]));
      case 4 : 
          return List.map((function (ii) {
                        return /* CoqImplicit */Block.__(15, [ii]);
                      }), implicits(cmd[0]));
      case 5 : 
          try {
            var match$1 = query_unparsing(cmd[0]);
            return /* :: */[
                    /* CoqUnparsing */Block.__(18, [
                        match$1[0],
                        match$1[1],
                        match$1[2]
                      ]),
                    /* [] */0
                  ];
          }
          catch (_exn){
            return /* [] */0;
          }
          break;
      case 6 : 
          return info_of_id(cmd[0])[0];
      case 7 : 
          var pa = Pcoq$ReactTemplate.Gram[/* parsable */7](/* None */0, Stream.of_string(cmd[0]));
          Stm$ReactTemplate.query(doc, opt[/* sid */0], opt[/* route */2], pa);
          return /* [] */0;
      
    }
  }
}

function exec_query(opt, cmd) {
  var res = obj_query(opt, cmd);
  var partial_arg = opt[/* pp */1];
  return List.map((function (param) {
                return obj_print(partial_arg, param);
              }), res);
}

function coq_exn_info(exn) {
  var bt = Printexc.get_raw_backtrace(/* () */0);
  var match = CErrors$ReactTemplate.push(exn);
  var info = match[1];
  return /* CoqExn */Block.__(3, [
            Loc$ReactTemplate.get_loc(info),
            Stateid$ReactTemplate.get(info),
            bt,
            match[0]
          ]);
}

var cur_doc = [/* :: */[
    Stateid$ReactTemplate.of_int(1),
    /* [] */0
  ]];

function invalid_range(can_st, include_st) {
  var pred = function (st) {
    if (include_st) {
      if (Stateid$ReactTemplate.newer_than(st, can_st)) {
        return /* true */1;
      } else {
        return Stateid$ReactTemplate.equal(st, can_st);
      }
    } else {
      return Stateid$ReactTemplate.newer_than(st, can_st);
    }
  };
  if (List.mem(can_st, cur_doc[0])) {
    var xs = cur_doc[0];
    var f = pred;
    var _acc = /* [] */0;
    var _t = xs;
    while(true) {
      var t = _t;
      var acc = _acc;
      if (t) {
        var hd = t[0];
        if (Curry._1(f, hd)) {
          _t = t[1];
          _acc = /* :: */[
            hd,
            acc
          ];
          continue ;
          
        } else {
          return /* tuple */[
                  List.rev(acc),
                  t
                ];
        }
      } else {
        return /* tuple */[
                List.rev(acc),
                t
              ];
      }
    };
  } else {
    return /* tuple */[
            /* [] */0,
            cur_doc[0]
          ];
  }
}

function cancel_sentence(doc, can_st) {
  var match = invalid_range(can_st, /* true */1);
  var k_ran = match[1];
  var x = hd_opt(k_ran);
  var prev_st = Option$ReactTemplate.$$default(Stateid$ReactTemplate.initial, x);
  var match$1 = Stm$ReactTemplate.edit_at(doc, prev_st);
  var doc$1 = match$1[0];
  if (typeof match$1[1] === "number") {
    cur_doc[0] = k_ran;
    return /* tuple */[
            doc$1,
            /* :: */[
              /* Canceled */Block.__(1, [match[0]]),
              /* [] */0
            ]
          ];
  } else {
    return /* tuple */[
            doc$1,
            Pervasives.failwith("cancel_interval")
          ];
  }
}

function serproto_help() {
  return Curry._1(Format.eprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* Flush */Block.__(10, [/* End_of_format */0])
                    ]),
                  "%s%!"
                ]), "Coq SerAPI -- Protocol documentation is still incomplete, the main commands are: \n\n  (Add add_opt \"gallina code\") -- Add new sentences to the current document \n  (Cancel sid_list)            -- Cancel sentences in the current document \n  (Exec sid)                   -- Check sentence `sid` \n  (Query query_opt query_cmd)  -- Query information about a sentence / global data \n  (Print print_opt coq_object) -- Print object with options \n\nSee sertop_protocol.mli for more details.\n\n");
}

function exec_cmd(cmd) {
  var doc = Stm$ReactTemplate.get_doc(doc_id[0]);
  var e = function () {
    if (typeof cmd === "number") {
      switch (cmd) {
        case 0 : 
            Stm$ReactTemplate.join(doc);
            return /* [] */0;
        case 1 : 
            Stm$ReactTemplate.finish(doc);
            return /* [] */0;
        case 3 : 
            serproto_help(/* () */0);
            return /* [] */0;
        case 2 : 
        case 4 : 
            return /* [] */0;
        
      }
    } else {
      switch (cmd.tag | 0) {
        case 0 : 
            return Pervasives.failwith("add_sentences")[1];
        case 1 : 
            return List.concat(List.map((function (x) {
                              return cancel_sentence(doc, x)[1];
                            }), cmd[0]));
        case 2 : 
            Stm$ReactTemplate.observe(doc, cmd[0]);
            return /* [] */0;
        case 3 : 
            return /* :: */[
                    /* ObjList */Block.__(2, [exec_query(cmd[0], cmd[1])]),
                    /* [] */0
                  ];
        case 4 : 
            return /* :: */[
                    /* ObjList */Block.__(2, [/* :: */[
                          obj_print(cmd[0], cmd[1]),
                          /* [] */0
                        ]]),
                    /* [] */0
                  ];
        case 5 : 
            var inc = Pervasives.open_in(cmd[0]);
            try {
              var fsize = Pervasives.in_channel_length(inc);
              Pervasives.really_input_string(inc, fsize);
              return Pervasives.failwith("add_sentences")[1];
            }
            catch (exn){
              Pervasives.close_in(inc);
              return /* [] */0;
            }
            break;
        case 6 : 
            var st = CLexer$ReactTemplate.get_lexer_state(/* () */0);
            try {
              var istr = Stream.of_string(cmd[0]);
              var lex = Curry._1(CLexer$ReactTemplate.lexer[/* tok_func */0], istr);
              CLexer$ReactTemplate.set_lexer_state(st);
              var objs = stream_tok(/* [] */0, lex[0]);
              return /* :: */[
                      /* ObjList */Block.__(2, [/* :: */[
                            /* CoqTok */Block.__(4, [objs]),
                            /* [] */0
                          ]]),
                      /* [] */0
                    ];
            }
            catch (exn$1){
              CLexer$ReactTemplate.set_lexer_state(st);
              throw exn$1;
            }
            break;
        
      }
    }
  };
  try {
    return Pervasives.$at(Curry._1(e, /* () */0), /* :: */[
                /* Completed */1,
                /* [] */0
              ]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    return /* :: */[
            coq_exn_info(exn),
            /* [] */0
          ];
  }
}

exports.NoSuchState = NoSuchState;
exports.exec_cmd = exec_cmd;
/* cur_doc Not a pure module */
