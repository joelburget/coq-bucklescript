// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Hashset$ReactTemplate = require("./hashset.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function eq_structured_constant(c1, c2) {
  switch (c1.tag | 0) {
    case 0 : 
        if (c2.tag) {
          return /* false */0;
        } else {
          return Sorts$ReactTemplate.equal(c1[0], c2[0]);
        }
        break;
    case 1 : 
        if (c2.tag === 1) {
          return Names$ReactTemplate.eq_ind(c1[0], c2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 2 : 
        if (c2.tag === 2) {
          return Names$ReactTemplate.Constant[/* equal */12](c1[0], c2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 3 : 
        if (c2.tag === 3) {
          return +(c1[0] === c2[0]);
        } else {
          return /* false */0;
        }
        break;
    case 4 : 
        if (c2.tag === 4 && c1[0] === c2[0]) {
          return CArray$ReactTemplate.equal(eq_structured_constant, c1[1], c2[1]);
        } else {
          return /* false */0;
        }
        break;
    case 5 : 
        if (c2.tag === 5) {
          return Univ$ReactTemplate.Level[/* equal */6](c1[0], c2[0]);
        } else {
          return /* false */0;
        }
        break;
    
  }
}

function hash_structured_constant(c) {
  switch (c.tag | 0) {
    case 0 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, Sorts$ReactTemplate.hash(c[0]));
    case 1 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](2, Names$ReactTemplate.ind_hash(c[0]));
    case 2 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](3, Names$ReactTemplate.Constant[/* hash */13](c[0]));
    case 3 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](4, Int$ReactTemplate.hash(c[0]));
    case 4 : 
        var fold = function (h, c) {
          return Hashset$ReactTemplate.Combine[/* combine */0](h, hash_structured_constant(c));
        };
        var h = $$Array.fold_left(fold, 0, c[1]);
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](5, Hashset$ReactTemplate.Combine[/* combine */0](Int$ReactTemplate.hash(c[0]), h));
    case 5 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](6, Univ$ReactTemplate.Level[/* hash */7](c[0]));
    
  }
}

function eq_annot_switch(asw1, asw2) {
  var eq_ci = function (ci1, ci2) {
    if (Names$ReactTemplate.eq_ind(ci1[/* ci_ind */0], ci2[/* ci_ind */0]) && ci1[/* ci_npar */1] === ci2[/* ci_npar */1]) {
      return CArray$ReactTemplate.equal((function (prim, prim$1) {
                    return +(prim === prim$1);
                  }), ci1[/* ci_cstr_ndecls */2], ci2[/* ci_cstr_ndecls */2]);
    } else {
      return /* false */0;
    }
  };
  var eq_rlc = function (param, param$1) {
    if (param[0] === param$1[0]) {
      return +(param[1] === param$1[1]);
    } else {
      return /* false */0;
    }
  };
  if (eq_ci(asw1[/* ci */0], asw2[/* ci */0]) && CArray$ReactTemplate.equal(eq_rlc, asw1[/* rtbl */1], asw2[/* rtbl */1])) {
    return +(asw1[/* tailcall */2] === asw2[/* tailcall */2]);
  } else {
    return /* false */0;
  }
}

function hash_annot_switch(asw) {
  var h1 = Constr$ReactTemplate.case_info_hash(asw[/* ci */0]);
  var h2 = $$Array.fold_left((function (h, param) {
          return Hashset$ReactTemplate.Combine[/* combine3 */2](h, param[0], param[1]);
        }), 0, asw[/* rtbl */1]);
  var h3 = asw[/* tailcall */2] ? 1 : 0;
  return Hashset$ReactTemplate.Combine[/* combine3 */2](h1, h2, h3);
}

var counter = [-1];

function create() {
  counter[0] = counter[0] + 1 | 0;
  return counter[0];
}

function reset_label_counter() {
  counter[0] = -1;
  return /* () */0;
}

var NotClosed = Caml_exceptions.create("Cbytecodes-ReactTemplate.NotClosed");

function compare(e1, e2) {
  switch (e1.tag | 0) {
    case 0 : 
        if (e2.tag) {
          return -1;
        } else {
          return Curry._2(Names$ReactTemplate.Id[/* compare */1], e1[0], e2[0]);
        }
        break;
    case 1 : 
        switch (e2.tag | 0) {
          case 0 : 
              return 1;
          case 1 : 
              return Caml_primitive.caml_int_compare(e1[0], e2[0]);
          case 2 : 
          case 3 : 
              return -1;
          
        }
        break;
    case 2 : 
        switch (e2.tag | 0) {
          case 0 : 
          case 1 : 
              return 1;
          case 2 : 
              return Caml_primitive.caml_int_compare(e1[0], e2[0]);
          case 3 : 
              return -1;
          
        }
        break;
    case 3 : 
        if (e2.tag === 3) {
          return Evar$ReactTemplate.compare(e1[0], e2[0]);
        } else {
          return 1;
        }
        break;
    
  }
}

var Fv_elem = /* module */[/* compare */compare];

var FvMap = $$Map.Make(Fv_elem);

function pp_struct_const(param) {
  switch (param.tag | 0) {
    case 0 : 
        var s = param[0];
        if (s.tag) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Type@{"), Univ$ReactTemplate.pr_uni(s[0])), Pp$ReactTemplate.str("}"));
        } else if (s[0] !== 0) {
          return Pp$ReactTemplate.str("Prop");
        } else {
          return Pp$ReactTemplate.str("Set");
        }
    case 1 : 
        var match = param[0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.MutInd[/* print */15](match[0]), Pp$ReactTemplate.str("#")), Pp$ReactTemplate.$$int(match[1]));
    case 2 : 
        return Names$ReactTemplate.Constant[/* print */16](param[0]);
    case 3 : 
        return Pp$ReactTemplate.$$int(param[0]);
    case 4 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(param[0]), Pp$ReactTemplate.surround(Pp$ReactTemplate.prvect_with_sep(Pp$ReactTemplate.pr_comma, pp_struct_const, param[1])));
    case 5 : 
        return Univ$ReactTemplate.Level[/* pr */9](param[0]);
    
  }
}

function pp_lbl(lbl) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("L"), Pp$ReactTemplate.$$int(lbl));
}

function pp_fv_elem(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("FVnamed("), Names$ReactTemplate.Id[/* print */8](param[0])), Pp$ReactTemplate.str(")"));
    case 1 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Rel("), Pp$ReactTemplate.$$int(param[0])), Pp$ReactTemplate.str(")"));
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("FVuniv("), Pp$ReactTemplate.$$int(param[0])), Pp$ReactTemplate.str(")"));
    case 3 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("FVevar("), Pp$ReactTemplate.$$int(Evar$ReactTemplate.repr(param[0]))), Pp$ReactTemplate.str(")"));
    
  }
}

function pp_instr(i) {
  if (typeof i === "number") {
    switch (i) {
      case 0 : 
          return Pp$ReactTemplate.str("push");
      case 1 : 
          return Pp$ReactTemplate.str("jump");
      case 2 : 
          return Pp$ReactTemplate.str("restart");
      case 3 : 
          return Pp$ReactTemplate.str("makeprod");
      case 4 : 
          return Pp$ReactTemplate.str("stop");
      case 5 : 
          return Pp$ReactTemplate.str("addint31");
      case 6 : 
          return Pp$ReactTemplate.str("addcint31");
      case 7 : 
          return Pp$ReactTemplate.str("addcarrycint31");
      case 8 : 
          return Pp$ReactTemplate.str("subint31");
      case 9 : 
          return Pp$ReactTemplate.str("subcint31");
      case 10 : 
          return Pp$ReactTemplate.str("subcarrycint31");
      case 11 : 
          return Pp$ReactTemplate.str("mulint31");
      case 12 : 
          return Pp$ReactTemplate.str("mulcint31");
      case 13 : 
          return Pp$ReactTemplate.str("div21int31");
      case 14 : 
          return Pp$ReactTemplate.str("divint31");
      case 15 : 
          return Pp$ReactTemplate.str("addmuldivint31");
      case 16 : 
          return Pp$ReactTemplate.str("compareint31");
      case 17 : 
          return Pp$ReactTemplate.str("head0int31");
      case 18 : 
          return Pp$ReactTemplate.str("tail0int31");
      case 19 : 
          return Pp$ReactTemplate.str("compint31");
      case 20 : 
          return Pp$ReactTemplate.str("decompint");
      case 21 : 
          return Pp$ReactTemplate.str("lorint31");
      case 22 : 
          return Pp$ReactTemplate.str("landint31");
      case 23 : 
          return Pp$ReactTemplate.str("lxorint31");
      
    }
  } else {
    switch (i.tag | 0) {
      case 1 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("acc "), Pp$ReactTemplate.$$int(i[0]));
      case 2 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("envacc "), Pp$ReactTemplate.$$int(i[0]));
      case 3 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("offsetclosure "), Pp$ReactTemplate.$$int(i[0]));
      case 4 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("pop "), Pp$ReactTemplate.$$int(i[0]));
      case 5 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("push_retaddr "), pp_lbl(i[0]));
      case 6 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("apply "), Pp$ReactTemplate.$$int(i[0]));
      case 7 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("appterm "), Pp$ReactTemplate.$$int(i[0])), Pp$ReactTemplate.str(", ")), Pp$ReactTemplate.$$int(i[1]));
      case 8 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("return "), Pp$ReactTemplate.$$int(i[0]));
      case 9 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("grab "), Pp$ReactTemplate.$$int(i[0]));
      case 10 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("grabrec "), Pp$ReactTemplate.$$int(i[0]));
      case 11 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("closure "), pp_lbl(i[0])), Pp$ReactTemplate.str(", ")), Pp$ReactTemplate.$$int(i[1]));
      case 12 : 
          return Pp$ReactTemplate.h(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("closurerec "), Pp$ReactTemplate.$$int(i[0])), Pp$ReactTemplate.str(", ")), Pp$ReactTemplate.$$int(i[1])), Pp$ReactTemplate.str(" types = ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lbl, Util$ReactTemplate.$$Array[/* to_list */9](i[2]))), Pp$ReactTemplate.str(" bodies = ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lbl, Util$ReactTemplate.$$Array[/* to_list */9](i[3]))));
      case 13 : 
          return Pp$ReactTemplate.h(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("closurecofix "), Pp$ReactTemplate.$$int(i[0])), Pp$ReactTemplate.str(", ")), Pp$ReactTemplate.$$int(i[1])), Pp$ReactTemplate.str(" types = ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lbl, Util$ReactTemplate.$$Array[/* to_list */9](i[2]))), Pp$ReactTemplate.str(" bodies = ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lbl, Util$ReactTemplate.$$Array[/* to_list */9](i[3]))));
      case 14 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("getglobal "), Names$ReactTemplate.Constant[/* print */16](i[0]));
      case 15 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("const "), pp_struct_const(i[0]));
      case 16 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("makeblock "), Pp$ReactTemplate.$$int(i[0])), Pp$ReactTemplate.str(", ")), Pp$ReactTemplate.$$int(i[1]));
      case 17 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("makeswitchblock "), pp_lbl(i[0])), Pp$ReactTemplate.str(", ")), pp_lbl(i[1])), Pp$ReactTemplate.str(", ")), Pp$ReactTemplate.$$int(i[3]));
      case 18 : 
          return Pp$ReactTemplate.h(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("switch "), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lbl, Util$ReactTemplate.$$Array[/* to_list */9](i[0]))), Pp$ReactTemplate.str(" | ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lbl, Util$ReactTemplate.$$Array[/* to_list */9](i[1]))));
      case 19 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("pushfields "), Pp$ReactTemplate.$$int(i[0]));
      case 20 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("field "), Pp$ReactTemplate.$$int(i[0]));
      case 21 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("set field"), Pp$ReactTemplate.$$int(i[0]));
      case 0 : 
      case 22 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "cbytecodes.ml",
                  265,
                  32
                ]
              ];
      case 23 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("proj "), Pp$ReactTemplate.$$int(i[0])), Pp$ReactTemplate.str(" ")), Names$ReactTemplate.Constant[/* print */16](i[1]));
      case 24 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("growstack "), Pp$ReactTemplate.$$int(i[0]));
      case 25 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("branch "), pp_lbl(i[0]));
      case 26 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("isconst "), Pp$ReactTemplate.$$int(i[0]));
      case 27 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("areconst "), Pp$ReactTemplate.$$int(i[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(i[1]));
      
    }
  }
}

function pp_bytecodes(c) {
  if (c) {
    var i = c[0];
    var exit = 0;
    if (typeof i === "number") {
      exit = 1;
    } else {
      switch (i.tag | 0) {
        case 0 : 
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("L"), Pp$ReactTemplate.$$int(i[0])), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.fnl(/* () */0)), pp_bytecodes(c[1]));
        case 22 : 
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pp_bytecodes(i[0]), pp_bytecodes(i[1])), pp_bytecodes(c[1]));
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pp_instr(i), Pp$ReactTemplate.fnl(/* () */0)), pp_bytecodes(c[1]));
    }
    
  } else {
    return Pp$ReactTemplate.str("");
  }
}

var accu_tag = 0;

var type_atom_tag = 2;

var max_atom_tag = 2;

var proj_tag = 3;

var fix_app_tag = 4;

var switch_tag = 5;

var cofix_tag = 6;

var cofix_evaluated_tag = 7;

var last_variant_tag = 245;

var Label = [
  -1,
  create,
  reset_label_counter
];

exports.accu_tag = accu_tag;
exports.type_atom_tag = type_atom_tag;
exports.max_atom_tag = max_atom_tag;
exports.proj_tag = proj_tag;
exports.fix_app_tag = fix_app_tag;
exports.switch_tag = switch_tag;
exports.cofix_tag = cofix_tag;
exports.cofix_evaluated_tag = cofix_evaluated_tag;
exports.last_variant_tag = last_variant_tag;
exports.pp_struct_const = pp_struct_const;
exports.eq_structured_constant = eq_structured_constant;
exports.hash_structured_constant = hash_structured_constant;
exports.eq_annot_switch = eq_annot_switch;
exports.hash_annot_switch = hash_annot_switch;
exports.Label = Label;
exports.NotClosed = NotClosed;
exports.FvMap = FvMap;
exports.pp_bytecodes = pp_bytecodes;
exports.pp_fv_elem = pp_fv_elem;
/* FvMap Not a pure module */
