// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");

function occurrences_map(f, o) {
  if (typeof o === "number") {
    return o;
  } else if (o.tag) {
    var l$prime = Curry._1(f, o[0]);
    if (l$prime) {
      return /* OnlyOccurrences */Block.__(1, [l$prime]);
    } else {
      return /* NoOccurrences */1;
    }
  } else {
    var l$prime$1 = Curry._1(f, o[0]);
    if (l$prime$1) {
      return /* AllOccurrencesBut */Block.__(0, [l$prime$1]);
    } else {
      return /* AllOccurrences */0;
    }
  }
}

function convert_occs(param) {
  if (typeof param === "number") {
    if (param) {
      return /* tuple */[
              /* true */1,
              /* [] */0
            ];
    } else {
      return /* tuple */[
              /* false */0,
              /* [] */0
            ];
    }
  } else if (param.tag) {
    return /* tuple */[
            /* true */1,
            param[0]
          ];
  } else {
    return /* tuple */[
            /* false */0,
            param[0]
          ];
  }
}

function is_selected(occ, param) {
  if (typeof param === "number") {
    if (param) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  } else if (param.tag) {
    return Curry._2(Int$ReactTemplate.List[/* mem */0], occ, param[0]);
  } else {
    return 1 - Curry._2(Int$ReactTemplate.List[/* mem */0], occ, param[0]);
  }
}

function onHyp(h) {
  return /* record */[
          /* onhyps : Some */[/* :: */[
              /* tuple */[
                /* tuple */[
                  /* AllOccurrences */0,
                  h
                ],
                /* InHyp */0
              ],
              /* [] */0
            ]],
          /* concl_occs : NoOccurrences */1
        ];
}

function is_nowhere(param) {
  var match = param[/* onhyps */0];
  if (match) {
    if (match[0]) {
      return /* false */0;
    } else {
      var match$1 = param[/* concl_occs */1];
      if (typeof match$1 === "number" && match$1 !== 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    }
  } else {
    return /* false */0;
  }
}

function simple_clause_of(enum_hyps, cl) {
  var error_occurrences = function () {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This tactic does not support occurrences selection"));
  };
  var error_body_selection = function () {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This tactic does not support body selection"));
  };
  var match = cl[/* onhyps */0];
  var hyps = match ? List.map((function (param) {
            var match = param[0];
            if (match[0] !== /* AllOccurrences */0) {
              error_occurrences(/* () */0);
            }
            if (param[1] === /* InHypValueOnly */2) {
              error_body_selection(/* () */0);
            }
            return /* Some */[match[1]];
          }), match[0]) : List.map(Option$ReactTemplate.make, Curry._1(enum_hyps, /* () */0));
  if (cl[/* concl_occs */1] === /* NoOccurrences */1) {
    return hyps;
  } else if (cl[/* concl_occs */1] !== /* AllOccurrences */0) {
    return error_occurrences(/* () */0);
  } else {
    return /* :: */[
            /* None */0,
            hyps
          ];
  }
}

function concrete_clause_of(enum_hyps, cl) {
  var match = cl[/* onhyps */0];
  var hyps;
  if (match) {
    hyps = List.map((function (param) {
            var match = param[0];
            return /* OnHyp */Block.__(0, [
                      match[1],
                      match[0],
                      param[1]
                    ]);
          }), match[0]);
  } else {
    var f = function (id) {
      return /* OnHyp */Block.__(0, [
                id,
                /* AllOccurrences */0,
                /* InHyp */0
              ]);
    };
    hyps = List.map(f, Curry._1(enum_hyps, /* () */0));
  }
  if (cl[/* concl_occs */1] === /* NoOccurrences */1) {
    return hyps;
  } else {
    return /* :: */[
            /* OnConcl */Block.__(1, [cl[/* concl_occs */1]]),
            hyps
          ];
  }
}

function out_arg(param) {
  if (param.tag) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unevaluated or_var variable."));
  } else {
    return param[0];
  }
}

function occurrences_of_hyp(id, cls) {
  var match = cls[/* onhyps */0];
  if (match) {
    var _param = match[0];
    while(true) {
      var param = _param;
      if (param) {
        var match$1 = param[0];
        var match$2 = match$1[0];
        if (Names$ReactTemplate.Id[/* equal */0](id, match$2[1])) {
          return /* tuple */[
                  occurrences_map((function (param) {
                          return List.map(out_arg, param);
                        }), match$2[0]),
                  match$1[1]
                ];
        } else {
          _param = param[1];
          continue ;
          
        }
      } else {
        return /* tuple */[
                /* NoOccurrences */1,
                /* InHyp */0
              ];
      }
    };
  } else {
    return /* tuple */[
            /* AllOccurrences */0,
            /* InHyp */0
          ];
  }
}

function occurrences_of_goal(cls) {
  return occurrences_map((function (param) {
                return List.map(out_arg, param);
              }), cls[/* concl_occs */1]);
}

function in_every_hyp(cls) {
  return Option$ReactTemplate.is_empty(cls[/* onhyps */0]);
}

function clause_with_generic_occurrences(cls) {
  var match = cls[/* onhyps */0];
  var hyps = match ? List.for_all((function (param) {
            var match = param[0][0];
            if (typeof match === "number" && match === 0) {
              return /* true */1;
            } else {
              return /* false */0;
            }
          }), match[0]) : /* true */1;
  var match$1 = cls[/* concl_occs */1];
  var concl = typeof match$1 === "number" ? /* true */1 : /* false */0;
  if (hyps) {
    return concl;
  } else {
    return /* false */0;
  }
}

function clause_with_generic_context_selection(cls) {
  var match = cls[/* onhyps */0];
  var hyps = match ? List.for_all((function (param) {
            var match = param[0][0];
            if (typeof match === "number" && !(match !== 0 || param[1] !== 0)) {
              return /* true */1;
            } else {
              return /* false */0;
            }
          }), match[0]) : /* true */1;
  var match$1 = cls[/* concl_occs */1];
  var concl = typeof match$1 === "number" ? /* true */1 : /* false */0;
  if (hyps) {
    return concl;
  } else {
    return /* false */0;
  }
}

var allHypsAndConcl = /* record */[
  /* onhyps : None */0,
  /* concl_occs : AllOccurrences */0
];

var allHyps = /* record */[
  /* onhyps : None */0,
  /* concl_occs : NoOccurrences */1
];

var onConcl = /* record */[
  /* onhyps : Some */[/* [] */0],
  /* concl_occs : AllOccurrences */0
];

var nowhere = /* record */[
  /* onhyps : Some */[/* [] */0],
  /* concl_occs : NoOccurrences */1
];

exports.occurrences_map = occurrences_map;
exports.convert_occs = convert_occs;
exports.is_selected = is_selected;
exports.allHypsAndConcl = allHypsAndConcl;
exports.allHyps = allHyps;
exports.onConcl = onConcl;
exports.nowhere = nowhere;
exports.onHyp = onHyp;
exports.is_nowhere = is_nowhere;
exports.simple_clause_of = simple_clause_of;
exports.concrete_clause_of = concrete_clause_of;
exports.occurrences_of_hyp = occurrences_of_hyp;
exports.occurrences_of_goal = occurrences_of_goal;
exports.in_every_hyp = in_every_hyp;
exports.clause_with_generic_occurrences = clause_with_generic_occurrences;
exports.clause_with_generic_context_selection = clause_with_generic_context_selection;
/* Pp-ReactTemplate Not a pure module */
