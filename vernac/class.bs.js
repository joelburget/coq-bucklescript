// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Vars$ReactTemplate = require("../src/vars.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Lemmas$ReactTemplate = require("../src/lemmas.bs.js");
var Typing$ReactTemplate = require("../src/typing.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var Declare$ReactTemplate = require("../src/declare.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Printer$ReactTemplate = require("../src/printer.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Classops$ReactTemplate = require("../src/classops.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var CWarnings$ReactTemplate = require("../src/cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");

var CoercionError = Caml_exceptions.create("Class-ReactTemplate.CoercionError");

function explain_coercion_error(g, param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(g), Pp$ReactTemplate.str(" is already a coercion"));
      case 1 : 
          return Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(g), Pp$ReactTemplate.str(" is not a function"));
      case 2 : 
          return Pp$ReactTemplate.str("Cannot find the target class");
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var match = param[0];
          if (match) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot recognize "), Classops$ReactTemplate.pr_class(match[0])), Pp$ReactTemplate.str(" as a source class of ")), Printer$ReactTemplate.pr_global(g));
          } else {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(": cannot find the source class of "), Printer$ReactTemplate.pr_global(g));
          }
      case 1 : 
          return Pp$ReactTemplate.$plus$plus(Classops$ReactTemplate.pr_class(param[0]), Pp$ReactTemplate.str(" cannot be a source class"));
      case 2 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Found target class "), Classops$ReactTemplate.pr_class(param[1])), Pp$ReactTemplate.str(" instead of ")), Classops$ReactTemplate.pr_class(param[0]));
      case 3 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Type of "), Printer$ReactTemplate.pr_global(param[0])), Pp$ReactTemplate.str(" does not end with a sort"));
      
    }
  }
}

function check_reference_arity(ref) {
  var env = Global$ReactTemplate.env(/* () */0);
  var match = Global$ReactTemplate.type_of_global_in_context(env, ref);
  if (Reductionops$ReactTemplate.is_arity(env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(match[0]))) {
    return 0;
  } else {
    throw [
          CoercionError,
          /* NotAClass */Block.__(3, [ref])
        ];
  }
}

function check_arity(param) {
  if (typeof param === "number") {
    return /* () */0;
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return check_reference_arity(/* VarRef */Block.__(0, [param[0]]));
      case 2 : 
          return check_reference_arity(/* IndRef */Block.__(2, [param[0]]));
      case 1 : 
      case 3 : 
          return check_reference_arity(/* ConstRef */Block.__(1, [param[0]]));
      
    }
  }
}

function check_target(clt, param) {
  if (param) {
    var cl = param[0];
    if (Classops$ReactTemplate.cl_typ_eq(cl, clt)) {
      return /* () */0;
    } else {
      throw [
            CoercionError,
            /* WrongTarget */Block.__(2, [
                clt,
                cl
              ])
          ];
    }
  } else {
    return /* () */0;
  }
}

function uniform_cond(sigma, ctx, lt) {
  return Curry._3(Util$ReactTemplate.List[/* for_all2eq */92], (function (param, param$1) {
                return EConstr$ReactTemplate.eq_constr(sigma, param, param$1);
              }), lt, Context$ReactTemplate.Rel[/* to_extended_list */12](EConstr$ReactTemplate.mkRel, 0, ctx));
}

function class_of_global(c) {
  switch (c.tag | 0) {
    case 0 : 
        return /* CL_SECVAR */Block.__(0, [c[0]]);
    case 1 : 
        var sp = c[0];
        if (Environ$ReactTemplate.is_projection(sp, Global$ReactTemplate.env(/* () */0))) {
          return /* CL_PROJ */Block.__(3, [sp]);
        } else {
          return /* CL_CONST */Block.__(1, [sp]);
        }
    case 2 : 
        return /* CL_IND */Block.__(2, [c[0]]);
    case 3 : 
        return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["class_of_global"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Constructors, such as "), Printer$ReactTemplate.pr_global(c)), Pp$ReactTemplate.str(", cannot be used as a class.")));
    
  }
}

function get_source(lp, source) {
  if (source) {
    var cl = source[0];
    var _acc = /* [] */0;
    var _param = Curry._1(Util$ReactTemplate.List[/* rev */4], lp);
    while(true) {
      var param = _param;
      var acc = _acc;
      if (param) {
        var decl = param[0];
        if (decl.tag) {
          _param = param[1];
          _acc = /* :: */[
            decl,
            acc
          ];
          continue ;
          
        } else {
          var lt = param[1];
          try {
            var match = Classops$ReactTemplate.find_class_type(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(decl[1]));
            var cl1 = match[0];
            if (Classops$ReactTemplate.cl_typ_eq(cl, cl1)) {
              return /* tuple */[
                      cl1,
                      acc,
                      match[2],
                      Context$ReactTemplate.Rel[/* nhyps */5](lt) + 1 | 0
                    ];
            } else {
              throw Caml_builtin_exceptions.not_found;
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              _param = lt;
              _acc = /* :: */[
                decl,
                acc
              ];
              continue ;
              
            } else {
              throw exn;
            }
          }
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  } else {
    var _param$1 = lp;
    while(true) {
      var param$1 = _param$1;
      if (param$1) {
        var match$1 = param$1[0];
        if (match$1.tag) {
          _param$1 = param$1[1];
          continue ;
          
        } else {
          var match$2 = Classops$ReactTemplate.find_class_type(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(match$1[1]));
          return /* tuple */[
                  match$2[0],
                  param$1[1],
                  match$2[2],
                  1
                ];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  }
}

function get_target(t, ind) {
  if (ind > 1) {
    return /* CL_FUN */1;
  } else {
    var x = Util$ReactTemplate.pi1(Classops$ReactTemplate.find_class_type(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(t)));
    if (typeof x === "number") {
      return x;
    } else if (x.tag === 1) {
      var p = x[0];
      if (Environ$ReactTemplate.is_projection(p, Global$ReactTemplate.env(/* () */0))) {
        return /* CL_PROJ */Block.__(3, [p]);
      } else {
        return x;
      }
    } else {
      return x;
    }
  }
}

function strength_of_cl(param) {
  if (typeof param === "number") {
    return /* GLOBAL */-634069661;
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return /* LOCAL */-153157301;
      case 1 : 
          return /* GLOBAL */-634069661;
      default:
        return /* GLOBAL */-634069661;
    }
  }
}

function strength_of_global(param) {
  if (param.tag) {
    return /* GLOBAL */-634069661;
  } else {
    return /* LOCAL */-153157301;
  }
}

function get_strength(stre, ref, cls, clt) {
  var stres = strength_of_cl(cls);
  var stret = strength_of_cl(clt);
  var stref = strength_of_global(ref);
  var l = /* :: */[
    stre,
    /* :: */[
      stres,
      /* :: */[
        stret,
        /* :: */[
          stref,
          /* [] */0
        ]
      ]
    ]
  ];
  if (Curry._2(Util$ReactTemplate.List[/* mem */24], /* LOCAL */-153157301, l)) {
    return /* LOCAL */-153157301;
  } else {
    return /* GLOBAL */-634069661;
  }
}

function ident_key_of_class(param) {
  if (typeof param === "number") {
    if (param) {
      return "Funclass";
    } else {
      return "Sortclass";
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Names$ReactTemplate.Id[/* to_string */7](param[0]);
      case 2 : 
          return Names$ReactTemplate.Label[/* to_string */4](Names$ReactTemplate.MutInd[/* label */8](param[0][0]));
      case 1 : 
      case 3 : 
          return Names$ReactTemplate.Label[/* to_string */4](Names$ReactTemplate.Constant[/* label */8](param[0]));
      
    }
  }
}

function error_not_transparent(source) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["build_id_coercion"], Pp$ReactTemplate.$plus$plus(Classops$ReactTemplate.pr_class(source), Pp$ReactTemplate.str(" must be a transparent constant.")));
}

function build_id_coercion(idf_opt, source, poly) {
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_env(env);
  var match;
  match = typeof source === "number" || source.tag !== 1 ? error_not_transparent(source) : Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env, sigma, /* ConstRef */Block.__(1, [source[0]]));
  var vs = match[1];
  var sigma$1 = match[0];
  var match$1 = Environ$ReactTemplate.constant_opt_value_in(env, Constr$ReactTemplate.destConst(vs));
  var c = match$1 ? match$1[0] : error_not_transparent(source);
  var match$2 = Term$ReactTemplate.decompose_lam_assum(c);
  var t = match$2[1];
  var lams = match$2[0];
  var val_f = Curry._1(Termops$ReactTemplate.it_mkLambda_or_LetIn(Constr$ReactTemplate.mkLambda(/* tuple */[
                /* Name */[Namegen$ReactTemplate.default_dependent_ident],
                Term$ReactTemplate.applistc(vs, Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, lams)),
                Constr$ReactTemplate.mkRel(1)
              ])), lams);
  var typ_f = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (d, c) {
          return Term$ReactTemplate.mkProd_wo_LetIn(c, d);
        }), Constr$ReactTemplate.mkProd(/* tuple */[
            /* Anonymous */0,
            Term$ReactTemplate.applistc(vs, Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, lams)),
            Vars$ReactTemplate.lift(1)(t)
          ]), lams);
  if (!Reductionops$ReactTemplate.is_conv_leq(/* None */0, env, sigma$1)(Typing$ReactTemplate.unsafe_type_of(env, sigma$1, EConstr$ReactTemplate.of_constr(val_f)), EConstr$ReactTemplate.of_constr(typ_f))) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.strbrk("Cannot be defined as coercion (maybe a bad number of arguments)."));
  }
  var idf;
  if (idf_opt) {
    idf = idf_opt[0];
  } else {
    var match$3 = Classops$ReactTemplate.find_class_type(sigma$1, EConstr$ReactTemplate.of_constr(t));
    idf = Names$ReactTemplate.Id[/* of_string */5]("Id_" + (ident_key_of_class(source) + ("_" + ident_key_of_class(match$3[0]))));
  }
  var univs = Evd$ReactTemplate.const_univ_entry(poly, sigma$1);
  var constr_entry = /* DefinitionEntry */Block.__(0, [Declare$ReactTemplate.definition_entry(/* None */0, /* None */0, /* Some */[/* true */1], /* Some */[typ_f], /* Some */[univs], /* None */0, Constr$ReactTemplate.mkCast(/* tuple */[
                val_f,
                /* DEFAULTcast */2,
                typ_f
              ]))]);
  var decl_001 = /* IsDefinition */Block.__(1, [/* IdentityCoercion */9]);
  var decl = /* tuple */[
    constr_entry,
    decl_001
  ];
  var kn = Declare$ReactTemplate.declare_constant(/* None */0, /* None */0, idf, /* None */0, decl);
  return /* ConstRef */Block.__(1, [kn]);
}

function check_source(param) {
  if (param) {
    var s = param[0];
    if (typeof s === "number") {
      if (s !== 0) {
        throw [
              CoercionError,
              /* ForbiddenSourceClass */Block.__(1, [s])
            ];
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

var warn_uniform_inheritance = CWarnings$ReactTemplate.create("uniform-inheritance", "typechecker", /* None */0, (function (g) {
        return Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(g), Pp$ReactTemplate.strbrk(" does not respect the uniform inheritance condition"));
      }));

function try_add_new_coercion_core(ref, local, c, d, e, f) {
  try {
    var coef = ref;
    var stre = local ? /* LOCAL */-153157301 : /* GLOBAL */-634069661;
    var source = d;
    var target = e;
    var isid = f;
    check_source(source);
    var match = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), coef);
    if (Classops$ReactTemplate.coercion_exists(coef)) {
      throw [
            CoercionError,
            /* AlreadyExists */0
          ];
    }
    var match$1 = Term$ReactTemplate.decompose_prod_assum(match[0]);
    var lp = match$1[0];
    var llp = Curry._1(Util$ReactTemplate.List[/* length */0], lp);
    if (!llp) {
      throw [
            CoercionError,
            /* NotAFunction */1
          ];
    }
    var match$2;
    try {
      match$2 = get_source(lp, source);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              CoercionError,
              /* NoSource */Block.__(0, [source])
            ];
      } else {
        throw exn;
      }
    }
    var lvs = match$2[2];
    var cls = match$2[0];
    check_source(/* Some */[cls]);
    if (!uniform_cond(Evd$ReactTemplate.empty, match$2[1], lvs)) {
      Curry._2(warn_uniform_inheritance, /* None */0, coef);
    }
    var clt;
    try {
      clt = get_target(match$1[1], match$2[3]);
    }
    catch (exn$1){
      if (exn$1 === Caml_builtin_exceptions.not_found) {
        throw [
              CoercionError,
              /* NoTarget */2
            ];
      } else {
        throw exn$1;
      }
    }
    check_target(clt, target);
    check_arity(cls);
    check_arity(clt);
    var match$3 = get_strength(stre, coef, cls, clt);
    var local$1 = match$3 >= -153157301 ? /* true */1 : /* false */0;
    return Classops$ReactTemplate.declare_coercion(coef, /* Some */[local$1], isid, cls, clt, Curry._1(Util$ReactTemplate.List[/* length */0], lvs));
  }
  catch (raw_exn){
    var exn$2 = Js_exn.internalToOCamlException(raw_exn);
    if (exn$2[0] === CoercionError) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["try_add_new_coercion_core"], Pp$ReactTemplate.$plus$plus(explain_coercion_error(ref, exn$2[1]), Pp$ReactTemplate.str(".")));
    } else {
      throw exn$2;
    }
  }
}

function try_add_new_coercion(ref, local, poly) {
  return try_add_new_coercion_core(ref, local, poly, /* None */0, /* None */0, /* false */0);
}

function try_add_new_coercion_subclass(cl, local, poly) {
  var coe_ref = build_id_coercion(/* None */0, cl, poly);
  return try_add_new_coercion_core(coe_ref, local, poly, /* Some */[cl], /* None */0, /* true */1);
}

function try_add_new_coercion_with_target(ref, local, poly, source, target) {
  return try_add_new_coercion_core(ref, local, poly, /* Some */[source], /* Some */[target], /* false */0);
}

function try_add_new_identity_coercion(id, local, poly, source, target) {
  var ref = build_id_coercion(/* Some */[id], source, poly);
  return try_add_new_coercion_core(ref, local, poly, /* Some */[source], /* Some */[target], /* true */1);
}

function try_add_new_coercion_with_source(ref, local, poly, source) {
  return try_add_new_coercion_core(ref, local, poly, /* Some */[source], /* None */0, /* false */0);
}

function add_coercion_hook(poly) {
  return Lemmas$ReactTemplate.mk_hook((function (param, param$1) {
                var poly$1 = poly;
                var local = param;
                var ref = param$1;
                var stre;
                switch (local) {
                  case 0 : 
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "class.ml",
                              308,
                              17
                            ]
                          ];
                  case 1 : 
                      stre = /* true */1;
                      break;
                  case 2 : 
                      stre = /* false */0;
                      break;
                  
                }
                try_add_new_coercion(ref, stre, poly$1);
                var msg = Pp$ReactTemplate.$plus$plus(Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], ref), Pp$ReactTemplate.str(" is now a coercion"));
                return Flags$ReactTemplate.if_verbose((function (eta) {
                              return Feedback$ReactTemplate.msg_info(/* None */0, eta);
                            }), msg);
              }));
}

function add_subclass_hook(poly) {
  return Lemmas$ReactTemplate.mk_hook((function (param, param$1) {
                var poly$1 = poly;
                var local = param;
                var ref = param$1;
                var stre;
                switch (local) {
                  case 0 : 
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "class.ml",
                              320,
                              17
                            ]
                          ];
                  case 1 : 
                      stre = /* true */1;
                      break;
                  case 2 : 
                      stre = /* false */0;
                      break;
                  
                }
                var cl = class_of_global(ref);
                return try_add_new_coercion_subclass(cl, stre, poly$1);
              }));
}

exports.try_add_new_coercion_with_target = try_add_new_coercion_with_target;
exports.try_add_new_coercion = try_add_new_coercion;
exports.try_add_new_coercion_subclass = try_add_new_coercion_subclass;
exports.try_add_new_coercion_with_source = try_add_new_coercion_with_source;
exports.try_add_new_identity_coercion = try_add_new_identity_coercion;
exports.add_coercion_hook = add_coercion_hook;
exports.add_subclass_hook = add_subclass_hook;
exports.class_of_global = class_of_global;
/* warn_uniform_inheritance Not a pure module */
