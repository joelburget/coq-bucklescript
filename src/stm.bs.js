// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Unix = require("bs-platform/lib/js/unix.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_sys = require("bs-platform/lib/js/caml_sys.js");
var Filename = require("bs-platform/lib/js/filename.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_module = require("bs-platform/lib/js/caml_module.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Dyn$ReactTemplate = require("./dyn.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var Str$ReactTemplate = require("../shims/str.bs.js");
var Vcs$ReactTemplate = require("./vcs.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Goal$ReactTemplate = require("./goal.bs.js");
var Hook$ReactTemplate = require("./hook.bs.js");
var Pcoq$ReactTemplate = require("./pcoq.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Mutex$ReactTemplate = require("./mutex.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Proof$ReactTemplate = require("./proof.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Lemmas$ReactTemplate = require("./lemmas.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Pfedit$ReactTemplate = require("./pfedit.bs.js");
var States$ReactTemplate = require("./states.bs.js");
var Thread$ReactTemplate = require("../shims/thread.bs.js");
var UState$ReactTemplate = require("./uState.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Cooking$ReactTemplate = require("./cooking.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Exninfo$ReactTemplate = require("./exninfo.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Printer$ReactTemplate = require("./printer.bs.js");
var Refiner$ReactTemplate = require("./refiner.bs.js");
var Spawned$ReactTemplate = require("../shims/spawned.bs.js");
var Stateid$ReactTemplate = require("./stateid.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Tactics$ReactTemplate = require("./tactics.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Ppvernac$ReactTemplate = require("./ppvernac.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Condition$ReactTemplate = require("../shims/condition.bs.js");
var Proofview$ReactTemplate = require("./proofview.bs.js");
var Tacticals$ReactTemplate = require("../tactics/tacticals.bs.js");
var ExplainErr$ReactTemplate = require("./explainErr.bs.js");
var Vernacprop$ReactTemplate = require("../vernac/vernacprop.bs.js");
var Obligations$ReactTemplate = require("./obligations.bs.js");
var Opaqueproof$ReactTemplate = require("./opaqueproof.bs.js");
var Safe_typing$ReactTemplate = require("./safe_typing.bs.js");
var Vernacstate$ReactTemplate = require("./vernacstate.bs.js");
var Proof_global$ReactTemplate = require("./proof_global.bs.js");
var RemoteCounter$ReactTemplate = require("./remoteCounter.bs.js");
var Vernacentries$ReactTemplate = require("../vernac/vernacentries.bs.js");
var AsyncTaskQueue$ReactTemplate = require("./asyncTaskQueue.bs.js");
var Vernac_classifier$ReactTemplate = require("../stm/vernac_classifier.bs.js");

var stm_debug = [/* false */0];

function stm_pr_err(s) {
  return Curry._2(Format.eprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* String_literal */Block.__(11, [
                          "] ",
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Char_literal */Block.__(12, [
                                  /* "\n" */10,
                                  /* Flush */Block.__(10, [/* End_of_format */0])
                                ])
                            ])
                        ])
                    ]),
                  "%s] %s\n%!"
                ]), Spawned$ReactTemplate.process_id(/* () */0), s);
}

function stm_prerr_endline(s) {
  if (stm_debug[0]) {
    return stm_pr_err(Curry._1(s, /* () */0));
  } else {
    return /* () */0;
  }
}

function stm_pperr_endline(s) {
  if (stm_debug[0]) {
    var pp = Curry._1(s, /* () */0);
    return Curry._3(Format.eprintf(/* Format */[
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            "] ",
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Close_box */0,
                                        /* Char_literal */Block.__(12, [
                                            /* "\n" */10,
                                            /* Flush */Block.__(10, [/* End_of_format */0])
                                          ])
                                      ])])
                              ])
                          ])
                      ]),
                    "%s] @[%a@]\n%!"
                  ]), Spawned$ReactTemplate.process_id(/* () */0), Pp$ReactTemplate.pp_with, pp);
  } else {
    return /* () */0;
  }
}

function stm_prerr_debug(s) {
  if (Flags$ReactTemplate.debug[0]) {
    return stm_pr_err(Curry._1(s, /* () */0));
  } else {
    return /* () */0;
  }
}

var default_opts = /* record */[
  /* async_proofs_n_workers */1,
  /* async_proofs_n_tacworkers */2,
  /* async_proofs_cache : None */0,
  /* async_proofs_mode : APoff */0,
  /* async_proofs_private_flags : None */0,
  /* async_proofs_full : false */0,
  /* async_proofs_never_reopen_branch : false */0,
  /* async_proofs_tac_error_resilience : `Only */[
    881570188,
    /* :: */[
      "curly",
      /* [] */0
    ]
  ],
  /* async_proofs_cmd_error_resilience : true */1,
  /* async_proofs_delegation_threshold */0.03
];

var cur_opt = [default_opts];

function async_proofs_is_master(opt) {
  if (opt[/* async_proofs_mode */3] === /* APon */2) {
    return +(Flags$ReactTemplate.async_proofs_worker_id[0] === "master");
  } else {
    return /* false */0;
  }
}

function stm_purify(f, x) {
  var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
  try {
    var res = Curry._1(f, x);
    Vernacstate$ReactTemplate.unfreeze_interp_state(st);
    return res;
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    var e$1 = CErrors$ReactTemplate.push(e);
    Vernacstate$ReactTemplate.unfreeze_interp_state(st);
    return Exninfo$ReactTemplate.iraise(e$1);
  }
}

function execution_error(loc, state_id, msg) {
  return Feedback$ReactTemplate.feedback(/* None */0, /* Some */[state_id], /* None */0, /* Message */Block.__(8, [
                /* Error */4,
                loc,
                msg
              ]));
}

var match = Hook$ReactTemplate.make(/* Some */[(function (state_id, _) {
          return Feedback$ReactTemplate.feedback(/* None */0, /* Some */[state_id], /* None */0, /* Processed */0);
        })], /* () */0);

var state_computed = match[0];

var match$1 = Hook$ReactTemplate.make(/* Some */[(function () {
          return /* () */0;
        })], /* () */0);

var state_ready = match$1[0];

var m = Mutex$ReactTemplate.create(/* () */0);

var match$2 = Hook$ReactTemplate.make(/* Some */[(function (param) {
          try {
            Mutex$ReactTemplate.lock(m);
            Feedback$ReactTemplate.feedback(/* Some */[param[/* doc_id */0]], /* Some */[param[/* span_id */1]], /* Some */[param[/* route */2]], param[/* contents */3]);
            return Mutex$ReactTemplate.unlock(m);
          }
          catch (e){
            Mutex$ReactTemplate.unlock(m);
            throw e;
          }
        })], /* () */0);

var forward_feedback = match$2[0];

var match$3 = Hook$ReactTemplate.make(/* Some */[(function (_, _$1) {
          return /* () */0;
        })], /* () */0);

var unreachable_state = match$3[0];

var processed = Curry._1(Exninfo$ReactTemplate.make, /* () */0);

function call_process_error_once(ei) {
  var match = Curry._2(Exninfo$ReactTemplate.get, ei[1], processed);
  if (match) {
    return ei;
  } else {
    var match$1 = ExplainErr$ReactTemplate.process_vernac_interp_error(/* None */0, ei);
    var info = Curry._3(Exninfo$ReactTemplate.add, match$1[1], processed, /* () */0);
    return /* tuple */[
            match$1[0],
            info
          ];
  }
}

var async_proofs_workers_extra_env = [/* array */[]];

function pr_ast(param) {
  var expr = param[/* expr */4];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(param[/* indentation */2]), Pp$ReactTemplate.str(" ")), Ppvernac$ReactTemplate.pr_vernac(expr));
}

function may_pierce_opaque(param) {
  if (typeof param === "number") {
    return /* false */0;
  } else {
    switch (param.tag | 0) {
      case 67 : 
          return /* true */1;
      case 83 : 
          switch (param[0][0]) {
            case "Extraction" : 
            case "ExtractionConstant" : 
            case "ExtractionInductive" : 
            case "ExtractionInlinedConstant" : 
            case "ExtractionLibrary" : 
            case "RecursiveExtractionLibrary" : 
            case "SeparateExtraction" : 
                return /* true */1;
            default:
              return /* false */0;
          }
          break;
      default:
        return /* false */0;
    }
  }
}

function update_global_env() {
  if (Proof_global$ReactTemplate.there_are_pending_proofs(/* () */0)) {
    return Proof_global$ReactTemplate.update_global_env(/* () */0);
  } else {
    return 0;
  }
}

var Vcs_ = Vcs$ReactTemplate.Make(Stateid$ReactTemplate.Self);

function mkTransTac(cast, cblock, cqueue) {
  return /* Cmd */Block.__(0, [/* record */[
              /* ctac : true */1,
              /* ceff : false */0,
              /* cast */cast,
              /* cids : [] */0,
              /* cblock */cblock,
              /* cqueue */cqueue
            ]]);
}

function mkTransCmd(cast, cids, ceff, cqueue) {
  return /* Cmd */Block.__(0, [/* record */[
              /* ctac : false */0,
              /* ceff */ceff,
              /* cast */cast,
              /* cids */cids,
              /* cblock : None */0,
              /* cqueue */cqueue
            ]]);
}

var summary_pstate = /* tuple */[
  Evarutil$ReactTemplate.meta_counter_summary_tag,
  Evd$ReactTemplate.evar_counter_summary_tag,
  Obligations$ReactTemplate.program_tcc_summary_tag
];

var DynBlockData = Dyn$ReactTemplate.Make(/* module */[]);

function proof_nesting(vcs) {
  return List.fold_left(Caml_obj.caml_max, 0, CList$ReactTemplate.map_filter((function (param) {
                    var match = param[/* kind */0];
                    if (typeof match === "number") {
                      return /* None */0;
                    } else {
                      var variant = match[0];
                      if (variant !== -608348572) {
                        if (variant !== 770176554) {
                          return /* None */0;
                        } else {
                          return /* Some */[1];
                        }
                      } else {
                        return /* Some */[match[1][1]];
                      }
                    }
                  }), List.map(Curry._1(Vcs_[/* get_branch */4], vcs), Curry._1(Vcs_[/* branches */3], vcs))));
}

function find_proof_at_depth(vcs, pl) {
  try {
    return List.find((function (param) {
                  var match = param[1][/* kind */0];
                  if (typeof match === "number") {
                    return /* false */0;
                  } else {
                    var variant = match[0];
                    if (variant !== -608348572) {
                      if (variant !== 770176554) {
                        return /* false */0;
                      } else {
                        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("find_proof_at_depth."));
                      }
                    } else {
                      return +(match[1][1] === pl);
                    }
                  }
                }), List.map((function (h) {
                      return /* tuple */[
                              h,
                              Curry._2(Vcs_[/* get_branch */4], vcs, h)
                            ];
                    }), Curry._1(Vcs_[/* branches */3], vcs)));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Pervasives.failwith("find_proof_at_depth");
    } else {
      throw exn;
    }
  }
}

var Expired = Caml_exceptions.create("Stm-ReactTemplate.Vcs_aux.Expired");

function visit(vcs, id) {
  if (Stateid$ReactTemplate.equal(id, Stateid$ReactTemplate.initial)) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Visiting the initial state id."));
  } else if (Stateid$ReactTemplate.equal(id, Stateid$ReactTemplate.dummy)) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Visiting the dummy state id."));
  } else {
    try {
      var match = Curry._2(Vcs_[/* Dag */14][/* from_node */3], Curry._1(Vcs_[/* dag */15], vcs), id);
      var exit = 0;
      var n;
      var x;
      var p;
      var n$1;
      var p$1;
      var n$2;
      var x$1;
      var p$2;
      if (match) {
        var match$1 = match[0];
        var match$2 = match$1[1];
        var n$3 = match$1[0];
        if (typeof match$2 === "number") {
          var match$3 = match[1];
          if (match$3) {
            var match$4 = match$3[0];
            var match$5 = match$4[1];
            var n$4 = match$4[0];
            if (typeof match$5 === "number") {
              exit = 1;
            } else {
              switch (match$5.tag | 0) {
                case 1 : 
                    if (match$3[1]) {
                      exit = 1;
                    } else {
                      return /* record */[
                              /* step : `Fork */[
                                781815138,
                                /* tuple */[
                                  match$5[0],
                                  /* Some */[n$3]
                                ]
                              ],
                              /* next */n$4
                            ];
                    }
                    break;
                case 2 : 
                    if (match$3[1]) {
                      exit = 1;
                    } else {
                      n = n$4;
                      x = match$5[0];
                      p = n$3;
                      exit = 2;
                    }
                    break;
                case 3 : 
                    var match$6 = match$5[0];
                    if (match$6) {
                      if (match$3[1]) {
                        exit = 1;
                      } else {
                        n$2 = n$4;
                        x$1 = match$6[0];
                        p$2 = n$3;
                        exit = 4;
                      }
                    } else if (match$3[1]) {
                      exit = 1;
                    } else {
                      n$1 = n$4;
                      p$1 = n$3;
                      exit = 3;
                    }
                    break;
                default:
                  exit = 1;
              }
            }
          } else {
            exit = 1;
          }
        } else {
          switch (match$2.tag | 0) {
            case 0 : 
                if (match[1]) {
                  exit = 1;
                } else {
                  return /* record */[
                          /* step : `Cmd */[
                            3356250,
                            match$2[0]
                          ],
                          /* next */n$3
                        ];
                }
                break;
            case 1 : 
                var match$7 = match[1];
                var x$2 = match$2[0];
                if (match$7) {
                  var match$8 = match$7[0];
                  if (typeof match$8[1] === "number") {
                    if (match$7[1]) {
                      exit = 1;
                    } else {
                      return /* record */[
                              /* step : `Fork */[
                                781815138,
                                /* tuple */[
                                  x$2,
                                  /* Some */[match$8[0]]
                                ]
                              ],
                              /* next */n$3
                            ];
                    }
                  } else {
                    exit = 1;
                  }
                } else {
                  return /* record */[
                          /* step : `Fork */[
                            781815138,
                            /* tuple */[
                              x$2,
                              /* None */0
                            ]
                          ],
                          /* next */n$3
                        ];
                }
                break;
            case 2 : 
                var match$9 = match[1];
                if (match$9) {
                  var match$10 = match$9[0];
                  if (typeof match$10[1] === "number") {
                    if (match$9[1]) {
                      exit = 1;
                    } else {
                      n = n$3;
                      x = match$2[0];
                      p = match$10[0];
                      exit = 2;
                    }
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                break;
            case 3 : 
                var match$11 = match$2[0];
                if (match$11) {
                  var match$12 = match[1];
                  var x$3 = match$11[0];
                  if (match$12) {
                    var match$13 = match$12[0];
                    if (typeof match$13[1] === "number") {
                      if (match$12[1]) {
                        exit = 1;
                      } else {
                        n$2 = n$3;
                        x$1 = x$3;
                        p$2 = match$13[0];
                        exit = 4;
                      }
                    } else {
                      exit = 1;
                    }
                  } else {
                    return /* record */[
                            /* step : `Sideff */[
                              -417845577,
                              /* tuple */[
                                /* ReplayCommand */[x$3],
                                Stateid$ReactTemplate.dummy
                              ]
                            ],
                            /* next */n$3
                          ];
                  }
                } else {
                  var match$14 = match[1];
                  if (match$14) {
                    var match$15 = match$14[0];
                    if (typeof match$15[1] === "number") {
                      if (match$14[1]) {
                        exit = 1;
                      } else {
                        n$1 = n$3;
                        p$1 = match$15[0];
                        exit = 3;
                      }
                    } else {
                      exit = 1;
                    }
                  } else {
                    exit = 1;
                  }
                }
                break;
            case 4 : 
                if (match[1]) {
                  exit = 1;
                } else {
                  return /* record */[
                          /* step : `Alias */[
                            884916592,
                            match$2[0]
                          ],
                          /* next */n$3
                        ];
                }
                break;
            
          }
        }
      } else {
        exit = 1;
      }
      switch (exit) {
        case 1 : 
            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Malformed VCS at node " + (Stateid$ReactTemplate.to_string(id) + ".")));
        case 2 : 
            return /* record */[
                    /* step : `Qed */[
                      4050672,
                      /* tuple */[
                        x,
                        p
                      ]
                    ],
                    /* next */n
                  ];
        case 3 : 
            return /* record */[
                    /* step : `Sideff */[
                      -417845577,
                      /* tuple */[
                        /* CherryPickEnv */0,
                        p$1
                      ]
                    ],
                    /* next */n$1
                  ];
        case 4 : 
            return /* record */[
                    /* step : `Sideff */[
                      -417845577,
                      /* tuple */[
                        /* ReplayCommand */[x$1],
                        p$2
                      ]
                    ],
                    /* next */n$2
                  ];
        
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw Expired;
      } else {
        throw exn;
      }
    }
  }
}

var empty = Vcs_[1];

var current_branch = Vcs_[2];

var branches = Vcs_[3];

var get_branch = Vcs_[4];

var reset_branch = Vcs_[5];

var branch = Vcs_[6];

var delete_branch = Vcs_[7];

var merge = Vcs_[8];

var commit = Vcs_[9];

var rewrite_merge = Vcs_[10];

var checkout = Vcs_[11];

var set_info = Vcs_[12];

var get_info = Vcs_[13];

var dag = Vcs_[15];

var create_property = Vcs_[16];

var property_of = Vcs_[17];

var delete_property = Vcs_[18];

var gc = Vcs_[19];

var reachable = Vcs_[20];

function print_dag(vcs, _) {
  if (stm_debug[0]) {
    Flags$ReactTemplate.we_are_parsing[0] = /* false */0;
  }
  var fname = "stm_" + Curry._3(Str$ReactTemplate.global_replace, Str$ReactTemplate.regexp(" "), "_", Spawned$ReactTemplate.process_id(/* () */0));
  var string_of_transaction = function (param) {
    var exit = 0;
    var t;
    if (typeof param === "number") {
      return " ";
    } else {
      switch (param.tag | 0) {
        case 0 : 
            t = param[0][/* cast */2];
            exit = 1;
            break;
        case 1 : 
            t = param[0][0];
            exit = 1;
            break;
        case 2 : 
            return Pp$ReactTemplate.string_of_ppcmds(pr_ast(param[0][/* qast */0]));
        case 3 : 
            var match = param[0];
            if (match) {
              var tmp;
              try {
                tmp = Pp$ReactTemplate.string_of_ppcmds(pr_ast(match[0]));
              }
              catch (exn){
                tmp = "ERR";
              }
              return Curry._1(Printf.sprintf(/* Format */[
                              /* String_literal */Block.__(11, [
                                  "Sideff(",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Char_literal */Block.__(12, [
                                          /* ")" */41,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ]),
                              "Sideff(%s)"
                            ]), tmp);
            } else {
              return "EnvChange";
            }
            break;
        case 4 : 
            return Curry._1(Printf.sprintf(/* Format */[
                            /* String_literal */Block.__(11, [
                                "Alias(",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* ")" */41,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ]),
                            "Alias(%s)"
                          ]), Stateid$ReactTemplate.to_string(param[0][0]));
        
      }
    }
    if (exit === 1) {
      try {
        return Pp$ReactTemplate.string_of_ppcmds(pr_ast(t));
      }
      catch (exn$1){
        return "ERR";
      }
    }
    
  };
  var is_green = function (id) {
    var match = Curry._2(get_info, vcs, id);
    if (match) {
      var match$1 = match[0][/* state */2];
      if (typeof match$1 === "number" || !match$1.tag) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
  var is_red = function (id) {
    var match = Curry._2(get_info, vcs, id);
    if (match) {
      var match$1 = match[0][/* state */2];
      if (typeof match$1 === "number" || match$1.tag) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
  var head = Curry._1(current_branch, vcs);
  var heads = List.map((function (x) {
          return /* tuple */[
                  x,
                  Curry._2(get_branch, vcs, x)[/* pos */2]
                ];
        }), Curry._1(branches, vcs));
  var graph = Curry._1(dag, vcs);
  var quote = function (s) {
    return Curry._3(Str$ReactTemplate.global_replace, Str$ReactTemplate.regexp("\n"), "<BR/>", Curry._3(Str$ReactTemplate.global_replace, Str$ReactTemplate.regexp("<"), "&lt;", Curry._3(Str$ReactTemplate.global_replace, Str$ReactTemplate.regexp(">"), "&gt;", Curry._3(Str$ReactTemplate.global_replace, Str$ReactTemplate.regexp("\""), "&quot;", Curry._3(Str$ReactTemplate.global_replace, Str$ReactTemplate.regexp("&"), "&amp;", $$String.sub(s, 0, Caml_primitive.caml_int_min(s.length, 20)))))));
  };
  var f = "/tmp/" + Curry._1(Filename.basename, fname);
  var match_000 = f + ".dot";
  var match_001 = f + ".pdf";
  var fname_dot = match_000;
  var edge = function (tr) {
    return Curry._1(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "<<FONT POINT-SIZE=\"12\" FACE=\"sans\">",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                "</FONT>>",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "<<FONT POINT-SIZE=\"12\" FACE=\"sans\">%s</FONT>>"
                  ]), quote(string_of_transaction(tr)));
  };
  var node_info = function (id) {
    var match = Curry._2(get_info, vcs, id);
    if (match) {
      var info = match[0];
      return Curry._1(Printf.sprintf(/* Format */[
                      /* String_literal */Block.__(11, [
                          "<<FONT POINT-SIZE=\"12\">",
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  "</FONT>",
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      "<<FONT POINT-SIZE=\"12\">%s</FONT>"
                    ]), Stateid$ReactTemplate.to_string(id)) + Curry._2(Printf.sprintf(/* Format */[
                      /* String_literal */Block.__(11, [
                          " <FONT POINT-SIZE=\"11\">r:",
                          /* Int */Block.__(4, [
                              /* Int_d */0,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* String_literal */Block.__(11, [
                                  " g:",
                                  /* Int */Block.__(4, [
                                      /* Int_d */0,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* String_literal */Block.__(11, [
                                          "</FONT>>",
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      " <FONT POINT-SIZE=\"11\">r:%d g:%d</FONT>>"
                    ]), info[/* n_reached */0], info[/* n_goals */1]);
    } else {
      return "";
    }
  };
  var color = function (id) {
    if (is_red(id)) {
      return "red";
    } else if (is_green(id)) {
      return "green";
    } else {
      return "white";
    }
  };
  var nodefmt = function (oc, id) {
    return Curry._3(Printf.fprintf(oc, /* Format */[
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            " [label=",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    ",style=filled,fillcolor=",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */Block.__(11, [
                                            "];\n",
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "%s [label=%s,style=filled,fillcolor=%s];\n"
                  ]), "s" + Stateid$ReactTemplate.to_string(id), node_info(id), color(id));
  };
  var ids = [Stateid$ReactTemplate.$$Set[/* empty */0]];
  var boxes = [/* [] */0];
  Curry._2(Vcs_[/* Dag */14][/* iter */15], graph, (function (from, _, _$1, l) {
          ids[0] = Curry._2(Stateid$ReactTemplate.$$Set[/* add */3], from, ids[0]);
          List.iter((function (box) {
                  boxes[0] = /* :: */[
                    box,
                    boxes[0]
                  ];
                  return /* () */0;
                }), Curry._2(Vcs_[/* Dag */14][/* property_of */13], graph, from));
          return List.iter((function (param) {
                        var dest = param[0];
                        ids[0] = Curry._2(Stateid$ReactTemplate.$$Set[/* add */3], dest, ids[0]);
                        return List.iter((function (box) {
                                      boxes[0] = /* :: */[
                                        box,
                                        boxes[0]
                                      ];
                                      return /* () */0;
                                    }), Curry._2(Vcs_[/* Dag */14][/* property_of */13], graph, dest));
                      }), l);
        }));
  boxes[0] = CList$ReactTemplate.sort_uniquize(Vcs_[/* Dag */14][/* Property */11][/* compare */1], boxes[0]);
  var oc = Pervasives.open_out(fname_dot);
  Pervasives.output_string(oc, "digraph states {\n");
  Curry._2(Vcs_[/* Dag */14][/* iter */15], graph, (function (from, _, _$1, l) {
          return List.iter((function (param) {
                        return Curry._3(Printf.fprintf(oc, /* Format */[
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                " -> ",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* String_literal */Block.__(11, [
                                                        " [xlabel=",
                                                        /* String */Block.__(2, [
                                                            /* No_padding */0,
                                                            /* String_literal */Block.__(11, [
                                                                ",labelfloat=true];\n",
                                                                /* End_of_format */0
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ]),
                                        "%s -> %s [xlabel=%s,labelfloat=true];\n"
                                      ]), "s" + Stateid$ReactTemplate.to_string(from), "s" + Stateid$ReactTemplate.to_string(param[0]), edge(param[1]));
                      }), l);
        }));
  var contains = function (b1, b2) {
    return Curry._2(Stateid$ReactTemplate.$$Set[/* subset */11], Curry._1(Vcs_[/* Dag */14][/* Property */11][/* having_it */4], b2), Curry._1(Vcs_[/* Dag */14][/* Property */11][/* having_it */4], b1));
  };
  var same_box = Vcs_[/* Dag */14][/* Property */11][/* equal */0];
  var outerboxes = function (boxes) {
    return List.filter((function (b) {
                    return 1 - List.exists((function (b1) {
                                  if (Curry._2(same_box, b1, b)) {
                                    return /* false */0;
                                  } else {
                                    return contains(b1, b);
                                  }
                                }), boxes);
                  }))(boxes);
  };
  var rec_print = function (b) {
    boxes[0] = CList$ReactTemplate.remove(same_box, b, boxes[0]);
    var sub_boxes = List.filter((function (param) {
              return contains(b, param);
            }))(outerboxes(boxes[0]));
    Curry._1(Printf.fprintf(oc, /* Format */[
              /* String_literal */Block.__(11, [
                  "subgraph cluster_",
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* String_literal */Block.__(11, [
                          " {\n",
                          /* End_of_format */0
                        ])
                    ])
                ]),
              "subgraph cluster_%s {\n"
            ]), Curry._1(Vcs_[/* Dag */14][/* Property */11][/* to_string */2], b));
    List.iter(rec_print, sub_boxes);
    Curry._2(Stateid$ReactTemplate.$$Set[/* iter */12], (function (id) {
            if (Curry._2(Stateid$ReactTemplate.$$Set[/* mem */2], id, ids[0])) {
              ids[0] = Curry._2(Stateid$ReactTemplate.$$Set[/* remove */5], id, ids[0]);
              return nodefmt(oc, id);
            } else {
              return 0;
            }
          }), Curry._1(Vcs_[/* Dag */14][/* Property */11][/* having_it */4], b));
    var match = Curry._1(Vcs_[/* Dag */14][/* Property */11][/* data */3], b);
    if (match.tag) {
      Curry._2(Printf.fprintf(oc, /* Format */[
                /* String_literal */Block.__(11, [
                    "label=\"",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            " (test:",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    ")\";\n",
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ])
                  ]),
                "label=\"%s (test:%s)\";\n"
              ]), match[1], Stateid$ReactTemplate.to_string(match[0][/* dynamic_switch */2]));
      return Printf.fprintf(oc, /* Format */[
                  /* String_literal */Block.__(11, [
                      "color=red; }\n",
                      /* End_of_format */0
                    ]),
                  "color=red; }\n"
                ]);
    } else {
      return Printf.fprintf(oc, /* Format */[
                  /* String_literal */Block.__(11, [
                      "color=blue; }\n",
                      /* End_of_format */0
                    ]),
                  "color=blue; }\n"
                ]);
    }
  };
  List.iter(rec_print, outerboxes(boxes[0]));
  Curry._2(Stateid$ReactTemplate.$$Set[/* iter */12], (function (param) {
          return nodefmt(oc, param);
        }), ids[0]);
  List.iteri((function (i, param) {
          var b = param[0];
          var shape = Curry._2(Vcs_[/* Branch */0][/* equal */1], head, b) ? "box3d" : "box";
          Curry._2(Printf.fprintf(oc, /* Format */[
                    /* Char_literal */Block.__(12, [
                        /* "b" */98,
                        /* Int */Block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* String_literal */Block.__(11, [
                                " -> ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        ";\n",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "b%d -> %s;\n"
                  ]), i, "s" + Stateid$ReactTemplate.to_string(param[1]));
          return Curry._3(Printf.fprintf(oc, /* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "b" */98,
                              /* Int */Block.__(4, [
                                  /* Int_d */0,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String_literal */Block.__(11, [
                                      " [shape=",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              ",label=\"",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* String_literal */Block.__(11, [
                                                      "\"];\n",
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "b%d [shape=%s,label=\"%s\"];\n"
                        ]), i, shape, Curry._1(Vcs_[/* Branch */0][/* to_string */3], b));
        }), heads);
  Pervasives.output_string(oc, "}\n");
  Pervasives.close_out(oc);
  Caml_sys.caml_sys_system_command("dot -Tpdf -Gcharset=latin1 " + (fname_dot + (" -o" + match_001)));
  return /* () */0;
}

var vcs = [Curry._1(empty, Stateid$ReactTemplate.dummy)];

var doc_type = [/* Interactive */Block.__(2, [Names$ReactTemplate.DirPath[/* make */3](/* [] */0)])];

var ldir = [Names$ReactTemplate.DirPath[/* empty */5]];

function init(dt, id) {
  doc_type[0] = dt;
  vcs[0] = Curry._1(empty, id);
  vcs[0] = Curry._3(set_info, vcs[0], id, /* record */[
        /* n_reached */0,
        /* n_goals */0,
        /* state : Empty */0,
        /* vcs_backup : tuple */[
          /* None */0,
          /* None */0
        ]
      ]);
  return 0;
}

function is_interactive() {
  var match = doc_type[0];
  switch (match.tag | 0) {
    case 0 : 
    case 1 : 
        return /* No */17505;
    case 2 : 
        return /* Yes */4448519;
    
  }
}

function is_vio_doc() {
  var match = doc_type[0];
  switch (match.tag | 0) {
    case 1 : 
        return /* true */1;
    case 0 : 
    case 2 : 
        return /* false */0;
    
  }
}

function checkout$1(head) {
  vcs[0] = Curry._2(checkout, vcs[0], head);
  return /* () */0;
}

function new_node($staropt$star, _) {
  var id = $staropt$star ? $staropt$star[0] : Curry._1(Stateid$ReactTemplate.fresh, /* () */0);
  if (Curry._2(Vcs_[/* get_info */13], vcs[0], id) !== /* None */0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "stm.ml",
            557,
            4
          ]
        ];
  }
  vcs[0] = Curry._3(set_info, vcs[0], id, /* record */[
        /* n_reached */0,
        /* n_goals */0,
        /* state : Empty */0,
        /* vcs_backup : tuple */[
          /* None */0,
          /* None */0
        ]
      ]);
  return id;
}

function merge$1(id, ours, into, branch) {
  vcs[0] = Curry._6(merge, vcs[0], id, ours, /* Noop */0, into, branch);
  return /* () */0;
}

function delete_branch$1(branch) {
  vcs[0] = Curry._2(delete_branch, vcs[0], branch);
  return /* () */0;
}

function reset_branch$1(branch, id) {
  vcs[0] = Curry._3(reset_branch, vcs[0], branch, id);
  return /* () */0;
}

function commit$1(id, t) {
  vcs[0] = Curry._3(commit, vcs[0], id, t);
  return /* () */0;
}

function rewrite_merge$1(id, ours, at, branch) {
  vcs[0] = Curry._6(rewrite_merge, vcs[0], id, ours, /* Noop */0, at, branch);
  return /* () */0;
}

function mk_branch_name(param) {
  var x = param[/* expr */4];
  var match = Vernacprop$ReactTemplate.under_control(x);
  var tmp;
  if (typeof match === "number") {
    tmp = "branch";
  } else {
    switch (match.tag | 0) {
      case 8 : 
          var match$1 = match[1][0][/* v */0];
          tmp = match$1 ? Names$ReactTemplate.Id[/* to_string */7](match$1[0]) : "branch";
          break;
      case 9 : 
          var match$2 = match[1];
          tmp = match$2 && !match$2[1] ? Names$ReactTemplate.Id[/* to_string */7](match$2[0][0][0][/* v */0]) : "branch";
          break;
      default:
        tmp = "branch";
    }
  }
  return Curry._1(Vcs_[/* Branch */0][/* make */0], tmp);
}

var edit_branch = Curry._1(Vcs_[/* Branch */0][/* make */0], "edit");

function branch$1(root, pos, name, kind) {
  vcs[0] = Curry._5(branch, vcs[0], root, pos, name, kind);
  return /* () */0;
}

function get_info$1(id) {
  var match = Curry._2(get_info, vcs[0], id);
  if (match) {
    return match[0];
  } else {
    throw Expired;
  }
}

function set_state(id, s) {
  get_info$1(id)[/* state */2] = s;
  if (async_proofs_is_master(cur_opt[0])) {
    return Curry._1(Hook$ReactTemplate.get(state_ready), id);
  } else {
    return 0;
  }
}

function reached(id) {
  var info = get_info$1(id);
  info[/* n_reached */0] = info[/* n_reached */0] + 1 | 0;
  return /* () */0;
}

function checkout_shallowest_proof_branch() {
  if (List.mem(edit_branch, Curry._1(Vcs_[/* branches */3], vcs[0]))) {
    checkout$1(edit_branch);
    var match = Curry._2(get_branch, vcs[0], edit_branch);
    var match$1 = match[/* kind */0];
    if (typeof match$1 === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "stm.ml",
              596,
              13
            ]
          ];
    } else if (match$1[0] !== 770176554) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "stm.ml",
              596,
              13
            ]
          ];
    } else {
      return Proof_global$ReactTemplate.activate_proof_mode(match$1[1][0]);
    }
  } else {
    var pl = proof_nesting(vcs[0]);
    try {
      var match$2 = find_proof_at_depth(vcs[0], pl);
      var match$3 = match$2[1][/* kind */0];
      var match$4;
      if (typeof match$3 === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "stm.ml",
                601,
                60
              ]
            ];
      } else if (match$3[0] !== -608348572) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "stm.ml",
                601,
                60
              ]
            ];
      } else {
        match$4 = /* tuple */[
          match$2[0],
          match$3[1][0]
        ];
      }
      var mode = match$4[1];
      checkout$1(match$4[0]);
      stm_prerr_endline((function () {
              return "mode:" + mode;
            }));
      return Proof_global$ReactTemplate.activate_proof_mode(mode);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        checkout$1(Vcs_[/* Branch */0][/* master */4]);
        return Proof_global$ReactTemplate.disactivate_current_proof_mode(/* () */0);
      } else {
        throw exn;
      }
    }
  }
}

function propagate_sideff(action) {
  return List.iter((function (b) {
                checkout$1(b);
                var id = new_node(/* None */0, /* () */0);
                return merge$1(id, /* Sideff */Block.__(3, [action]), /* Some */[b], Vcs_[/* Branch */0][/* master */4]);
              }), List.filter((function (b) {
                      return 1 - Curry._2(Vcs_[/* Branch */0][/* equal */1], b, Vcs_[/* Branch */0][/* master */4]);
                    }))(Curry._1(branches, vcs[0])));
}

function visit$1(id) {
  return visit(vcs[0], id);
}

function nodes_in_slice(block_start, block_stop) {
  var aux = function (id) {
    if (Stateid$ReactTemplate.equal(id, block_start)) {
      return /* [] */0;
    } else {
      var match = visit$1(id);
      var match$1 = match[/* step */0];
      var exit = 0;
      if (typeof match$1 === "number") {
        exit = 1;
      } else {
        var variant = match$1[0];
        if (variant !== -417845577) {
          if (variant !== 3356250) {
            if (variant !== 884916592) {
              exit = 1;
            } else {
              return /* :: */[
                      /* tuple */[
                        id,
                        /* Alias */Block.__(4, [match$1[1]])
                      ],
                      aux(match[/* next */1])
                    ];
            }
          } else {
            return /* :: */[
                    /* tuple */[
                      id,
                      /* Cmd */Block.__(0, [match$1[1]])
                    ],
                    aux(match[/* next */1])
                  ];
          }
        } else {
          var match$2 = match$1[1][0];
          if (match$2) {
            return /* :: */[
                    /* tuple */[
                      id,
                      /* Sideff */Block.__(3, [/* ReplayCommand */[match$2[0]]])
                    ],
                    aux(match[/* next */1])
                  ];
          } else {
            exit = 1;
          }
        }
      }
      if (exit === 1) {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot slice from " + (Stateid$ReactTemplate.to_string(block_start) + (" to " + (Stateid$ReactTemplate.to_string(block_stop) + ".")))));
      }
      
    }
  };
  return aux(block_stop);
}

function slice(block_start, block_stop) {
  var l = nodes_in_slice(block_start, block_stop);
  var copy_info = function (v, id) {
    var init = get_info$1(id);
    return Curry._3(Vcs_[/* set_info */12], v, id, /* record */[
                /* n_reached */init[/* n_reached */0],
                /* n_goals */init[/* n_goals */1],
                /* state : Empty */0,
                /* vcs_backup : tuple */[
                  /* None */0,
                  /* None */0
                ]
              ]);
  };
  var copy_info_w_state = function (v, id) {
    var init = get_info$1(id);
    return Curry._3(Vcs_[/* set_info */12], v, id, /* record */[
                /* n_reached */init[/* n_reached */0],
                /* n_goals */init[/* n_goals */1],
                /* state */init[/* state */2],
                /* vcs_backup : tuple */[
                  /* None */0,
                  /* None */0
                ]
              ]);
  };
  var v = Curry._1(Vcs_[/* empty */1], block_start);
  var v$1 = copy_info(v, block_start);
  var v$2 = List.fold_right((function (param, v) {
          var id = param[0];
          var v$1 = Curry._3(Vcs_[/* commit */9], v, id, param[1]);
          return copy_info(v$1, id);
        }), l, v$1);
  var match = get_info$1(block_start)[/* state */2];
  var tmp;
  tmp = typeof match === "number" || !match.tag ? /* false */0 : /* true */1;
  if (!tmp) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "stm.ml",
            655,
            4
          ]
        ];
  }
  var fill = function (_id) {
    while(true) {
      var id = _id;
      var match = get_info$1(id)[/* state */2];
      if (typeof match === "number") {
        _id = visit(v$2, id)[/* next */1];
        continue ;
        
      } else if (match.tag) {
        return copy_info_w_state(v$2, id);
      } else {
        _id = visit(v$2, id)[/* next */1];
        continue ;
        
      }
    };
  };
  var v$3 = fill(block_stop);
  var v$4 = copy_info_w_state(v$3, block_start);
  var nodes = Curry._1(Vcs_[/* Dag */14][/* all_nodes */7], Curry._1(Vcs_[/* dag */15], v$4));
  var props = Curry._3(Stateid$ReactTemplate.$$Set[/* fold */13], (function (n, pl) {
          return Pervasives.$at(Curry._2(Vcs_[/* property_of */17], vcs[0], n), pl);
        }), nodes, /* [] */0);
  var props$1 = CList$ReactTemplate.sort_uniquize(Vcs_[/* Dag */14][/* Property */11][/* compare */1], props);
  return List.fold_left((function (v, p) {
                return Curry._3(Vcs_[/* create_property */16], v, Curry._1(Stateid$ReactTemplate.$$Set[/* elements */19], Curry._1(Vcs_[/* Dag */14][/* Property */11][/* having_it */4], p)), Curry._1(Vcs_[/* Dag */14][/* Property */11][/* data */3], p));
              }), v$4, props$1);
}

function nodes_in_slice$1(block_start, block_stop) {
  return List.rev(List.map((function (prim) {
                    return prim[0];
                  }), nodes_in_slice(block_start, block_stop)));
}

function topo_invariant(l) {
  var all = List.fold_right(Stateid$ReactTemplate.$$Set[/* add */3], l, Stateid$ReactTemplate.$$Set[/* empty */0]);
  return List.for_all((function (x) {
                var props = Curry._2(property_of, vcs[0], x);
                var sets = List.map(Vcs_[/* Dag */14][/* Property */11][/* having_it */4], props);
                return List.for_all((function (s) {
                              if (Curry._2(Stateid$ReactTemplate.$$Set[/* subset */11], s, all)) {
                                return /* true */1;
                              } else {
                                return Curry._2(Stateid$ReactTemplate.$$Set[/* subset */11], all, s);
                              }
                            }), sets);
              }), l);
}

function create_proof_task_box(l, qed, lemma) {
  if (!topo_invariant(l)) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("overlapping boxes."));
  }
  vcs[0] = Curry._3(create_property, vcs[0], l, /* ProofTask */Block.__(0, [/* record */[
            /* lemma */lemma,
            /* qed */qed
          ]]));
  return /* () */0;
}

function create_proof_block(decl, name) {
  var l = nodes_in_slice$1(decl[/* block_start */0], decl[/* block_stop */1]);
  if (!topo_invariant(l)) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("overlapping boxes."));
  }
  vcs[0] = Curry._3(create_property, vcs[0], l, /* ProofBlock */Block.__(1, [
          decl,
          name
        ]));
  return /* () */0;
}

function box_of(id) {
  return List.map(Vcs_[/* Dag */14][/* Property */11][/* data */3], Curry._2(property_of, vcs[0], id));
}

function delete_boxes_of(id) {
  return List.iter((function (x) {
                vcs[0] = Curry._2(delete_property, vcs[0], x);
                return /* () */0;
              }), Curry._2(property_of, vcs[0], id));
}

function proof_task_box_of(id) {
  var match = CList$ReactTemplate.map_filter((function (param) {
          if (param.tag) {
            return /* None */0;
          } else {
            return /* Some */[param[0]];
          }
        }), box_of(id));
  if (match) {
    if (match[1]) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("node with more than 1 proof task box."));
    } else {
      return /* Some */[match[0]];
    }
  } else {
    return /* None */0;
  }
}

function gc$1() {
  var old_vcs = vcs[0];
  var match = Curry._1(gc, old_vcs);
  Curry._2(Stateid$ReactTemplate.$$Set[/* iter */12], (function (id) {
          var match = visit(old_vcs, id)[/* step */0];
          if (typeof match === "number") {
            return /* () */0;
          } else {
            var variant = match[0];
            if (variant !== 3356250) {
              if (variant !== 4050672) {
                return /* () */0;
              } else {
                var match$1 = match[1][0][/* fproof */2];
                if (match$1) {
                  match$1[0][1][0] = /* true */1;
                  return /* () */0;
                } else {
                  return /* () */0;
                }
              }
            } else {
              var match$2 = match[1][/* cqueue */5];
              if (typeof match$2 === "number") {
                return /* () */0;
              } else {
                var variant$1 = match$2[0];
                if (variant$1 !== 211560315) {
                  if (variant$1 !== 664893833) {
                    return /* () */0;
                  } else {
                    match$2[1][0] = /* true */1;
                    return /* () */0;
                  }
                } else {
                  match$2[1][2][0] = /* true */1;
                  return /* () */0;
                }
              }
            }
          }
        }), match[1]);
  vcs[0] = match[0];
  return /* () */0;
}

var m$1 = Mutex$ReactTemplate.create(/* () */0);

var c = Condition$ReactTemplate.create(/* () */0);

var job = [/* None */0];

var worker = [/* None */0];

function set_last_job(j) {
  Mutex$ReactTemplate.lock(m$1);
  job[0] = /* Some */[j];
  Condition$ReactTemplate.signal(c);
  return Mutex$ReactTemplate.unlock(m$1);
}

function get_last_job() {
  Mutex$ReactTemplate.lock(m$1);
  while(Option$ReactTemplate.is_empty(job[0])) {
    Condition$ReactTemplate.wait(c, m$1);
  };
  var match = job[0];
  if (match) {
    job[0] = /* None */0;
    Mutex$ReactTemplate.unlock(m$1);
    return match[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "stm.ml",
            731,
            16
          ]
        ];
  }
}

function run_command() {
  try {
    while(true) {
      Curry._1(get_last_job(/* () */0), /* () */0);
    };
    return /* () */0;
  }
  catch (e){
    return /* () */0;
  }
}

function print($staropt$star, _) {
  var now = $staropt$star ? $staropt$star[0] : /* false */0;
  if (!Flags$ReactTemplate.debug[0] && !now) {
    return /* () */0;
  } else {
    var partial_arg = vcs[0];
    var now$1 = now;
    var job = function (param) {
      return print_dag(partial_arg, param);
    };
    if (now$1) {
      return Curry._1(job, /* () */0);
    } else {
      set_last_job(job);
      if (Option$ReactTemplate.is_empty(worker[0])) {
        worker[0] = /* Some */[Thread$ReactTemplate.create(run_command, /* () */0)];
        return /* () */0;
      } else {
        return 0;
      }
    }
  }
}

function restore(v) {
  vcs[0] = v;
  return /* () */0;
}

var VCS_001 = /* Branch */Vcs_[/* Branch */0];

function state_of_id(_, id) {
  try {
    var match = get_info$1(id)[/* state */2];
    if (typeof match === "number") {
      return /* `Valid */[
              -991566628,
              /* None */0
            ];
    } else if (match.tag) {
      return /* `Valid */[
              -991566628,
              /* Some */[match[0]]
            ];
    } else {
      return /* `Error */[
              106380200,
              match[0][0]
            ];
    }
  }
  catch (exn){
    if (exn === Expired) {
      return /* Expired */-222591099;
    } else {
      throw exn;
    }
  }
}

var cur_id = [Stateid$ReactTemplate.dummy];

var fix_exn_ref = [(function (x) {
      return x;
    })];

function proof_part_of_frozen(param) {
  var st = States$ReactTemplate.summary_of_state(param[/* system */0]);
  return /* tuple */[
          param[/* proof */1],
          Summary$ReactTemplate.project_from_summary(st, Util$ReactTemplate.pi1(summary_pstate)),
          Summary$ReactTemplate.project_from_summary(st, Util$ReactTemplate.pi2(summary_pstate)),
          Summary$ReactTemplate.project_from_summary(st, Util$ReactTemplate.pi3(summary_pstate))
        ];
}

function freeze(marshallable, id) {
  return set_state(id, /* Valid */Block.__(1, [Vernacstate$ReactTemplate.freeze_interp_state(marshallable)]));
}

function freeze_invalid(id, iexn) {
  return set_state(id, /* Error */Block.__(0, [iexn]));
}

function is_cached($staropt$star, id, only_valid) {
  var cache = $staropt$star ? $staropt$star[0] : /* No */17505;
  if (Stateid$ReactTemplate.equal(id, cur_id[0])) {
    try {
      var match = get_info$1(id);
      var match$1 = match[/* state */2];
      if (typeof match$1 === "number") {
        if (cache === /* Yes */4448519) {
          freeze(/* No */17505, id);
          return /* true */1;
        } else if (cache === /* Shallow */841395124) {
          freeze(/* Shallow */841395124, id);
          return /* true */1;
        } else {
          return /* true */1;
        }
      } else {
        return /* true */1;
      }
    }
    catch (exn){
      if (exn === Expired) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  } else {
    try {
      var match$2 = get_info$1(id);
      var match$3 = match$2[/* state */2];
      if (typeof match$3 === "number") {
        return /* false */0;
      } else if (match$3.tag) {
        return /* true */1;
      } else {
        return 1 - only_valid;
      }
    }
    catch (exn$1){
      if (exn$1 === Expired) {
        return /* false */0;
      } else {
        throw exn$1;
      }
    }
  }
}

function install_cached(id) {
  var match = get_info$1(id);
  var match$1 = match[/* state */2];
  if (typeof match$1 === "number") {
    if (is_interactive(/* () */0) === /* No */17505 && Stateid$ReactTemplate.equal(id, cur_id[0])) {
      return /* () */0;
    } else {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("installing a non cached state."));
    }
  } else if (match$1.tag) {
    Vernacstate$ReactTemplate.unfreeze_interp_state(match$1[0]);
    cur_id[0] = id;
    return /* () */0;
  } else {
    cur_id[0] = id;
    return Exninfo$ReactTemplate.iraise(match$1[0]);
  }
}

function get_cached(id) {
  try {
    var match = get_info$1(id);
    var match$1 = match[/* state */2];
    if (typeof match$1 === "number" || !match$1.tag) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("not a cached state."));
    } else {
      return match$1[0];
    }
  }
  catch (exn){
    if (exn === Expired) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("not a cached state (expired)."));
    } else {
      throw exn;
    }
  }
}

function exn_on(id, valid, param) {
  var info = param[1];
  var e = param[0];
  var match = Stateid$ReactTemplate.get(info);
  if (match) {
    return /* tuple */[
            e,
            info
          ];
  } else {
    var loc = Loc$ReactTemplate.get_loc(info);
    var match$1 = call_process_error_once(/* tuple */[
          e,
          info
        ]);
    var info$1 = match$1[1];
    var e$1 = match$1[0];
    execution_error(loc, id, CErrors$ReactTemplate.iprint(/* tuple */[
              e$1,
              info$1
            ]));
    return /* tuple */[
            e$1,
            Stateid$ReactTemplate.add(info$1, valid, id)
          ];
  }
}

function same_env(param, param$1) {
  var s1 = States$ReactTemplate.summary_of_state(param[/* system */0]);
  var e1 = Summary$ReactTemplate.project_from_summary(s1, Global$ReactTemplate.global_env_summary_tag);
  var s2 = States$ReactTemplate.summary_of_state(param$1[/* system */0]);
  var e2 = Summary$ReactTemplate.project_from_summary(s2, Global$ReactTemplate.global_env_summary_tag);
  return +(e1 === e2);
}

function define(safe_id, $staropt$star, $staropt$star$1, $staropt$star$2, f, id) {
  var redefine = $staropt$star ? $staropt$star[0] : /* false */0;
  var cache = $staropt$star$1 ? $staropt$star$1[0] : /* No */17505;
  var feedback_processed = $staropt$star$2 ? $staropt$star$2[0] : /* true */1;
  Feedback$ReactTemplate.feedback(/* None */0, /* Some */[id], /* None */0, /* ProcessingIn */Block.__(0, [Flags$ReactTemplate.async_proofs_worker_id[0]]));
  var str_id = Stateid$ReactTemplate.to_string(id);
  if (is_cached(/* None */0, id, /* false */0) && !redefine) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("defining state "), Pp$ReactTemplate.str(str_id)), Pp$ReactTemplate.str(" twice.")));
  }
  try {
    stm_prerr_endline((function () {
            return "defining " + (str_id + (" (cache=" + (
                        cache === /* Yes */4448519 ? "Y)" : (
                            cache === /* Shallow */841395124 ? "S)" : "N)"
                          )
                      )));
          }));
    var good_id = safe_id ? safe_id[0] : cur_id[0];
    fix_exn_ref[0] = (function (param) {
        return exn_on(id, good_id, param);
      });
    Curry._1(f, /* () */0);
    fix_exn_ref[0] = (function (x) {
        return x;
      });
    if (cache === /* Yes */4448519) {
      freeze(/* No */17505, id);
    } else if (cache === /* Shallow */841395124) {
      freeze(/* Shallow */841395124, id);
    }
    stm_prerr_endline((function () {
            return "setting cur id to " + str_id;
          }));
    cur_id[0] = id;
    if (feedback_processed) {
      Curry._2(Hook$ReactTemplate.get(state_computed), id, /* false */0);
    }
    reached(id);
    if (Proof_global$ReactTemplate.there_are_pending_proofs(/* () */0)) {
      var n = Proof_global$ReactTemplate.get_open_goals(/* () */0);
      get_info$1(id)[/* n_goals */1] = n;
      return /* () */0;
    } else {
      return 0;
    }
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    var match = CErrors$ReactTemplate.push(e);
    var info = match[1];
    var e$1 = match[0];
    var good_id$1 = cur_id[0];
    cur_id[0] = Stateid$ReactTemplate.dummy;
    reached(id);
    var match$1 = Stateid$ReactTemplate.get(info);
    var ie = match$1 ? (
        safe_id ? /* tuple */[
            e$1,
            Stateid$ReactTemplate.add(info, safe_id[0], match$1[0][1])
          ] : /* tuple */[
            e$1,
            info
          ]
      ) : (
        safe_id ? exn_on(id, safe_id[0], /* tuple */[
                e$1,
                info
              ]) : exn_on(id, good_id$1, /* tuple */[
                e$1,
                info
              ])
      );
    if (cache === /* Yes */4448519 || cache === /* Shallow */841395124) {
      freeze_invalid(id, ie);
    }
    Curry._2(Hook$ReactTemplate.get(unreachable_state), id, ie);
    return Exninfo$ReactTemplate.iraise(ie);
  }
}

var init_state = [/* None */0];

function restore_root_state() {
  cur_id[0] = Stateid$ReactTemplate.dummy;
  return Vernacstate$ReactTemplate.unfreeze_interp_state(Option$ReactTemplate.get(init_state[0]));
}

function indent_script_item(param, param$1) {
  var ng = param$1[1];
  var cmd = param$1[0];
  var beginend = param[2];
  var nl = param[1];
  var match = param[0];
  var ngl1 = match[1];
  var ng1 = match[0];
  var ngprev = List.fold_left((function (prim, prim$1) {
          return prim + prim$1 | 0;
        }), ng1, ngl1);
  var new_ngl;
  if (ng > ngprev) {
    new_ngl = /* tuple */[
      (ng - ngprev | 0) + 1 | 0,
      /* :: */[
        ng1 - 1 | 0,
        ngl1
      ]
    ];
  } else if (ng < ngprev) {
    var loop = function (_p) {
      while(true) {
        var p = _p;
        if (p[0] !== 0) {
          return p;
        } else {
          var match = p[1];
          if (match) {
            _p = /* tuple */[
              match[0],
              match[1]
            ];
            continue ;
            
          } else {
            return p;
          }
        }
      };
    };
    new_ngl = loop(/* tuple */[
          ng1 - 1 | 0,
          ngl1
        ]);
  } else {
    new_ngl = /* tuple */[
      ng1,
      ngl1
    ];
  }
  var new_nl = +(ng < ngprev);
  var ind = List.length(ngl1);
  var pred = function (n) {
    return Caml_primitive.caml_int_max(0, n - 1 | 0);
  };
  var match$1 = Vernacprop$ReactTemplate.under_control(cmd);
  var match$2;
  if (typeof match$1 === "number") {
    match$2 = match$1 === 5 ? /* tuple */[
        List.hd(beginend),
        /* false */0,
        List.tl(beginend)
      ] : /* tuple */[
        ind,
        nl,
        beginend
      ];
  } else {
    switch (match$1.tag | 0) {
      case 77 : 
          match$2 = /* tuple */[
            pred(ind),
            nl,
            beginend
          ];
          break;
      case 78 : 
          match$2 = /* tuple */[
            pred(ind),
            nl,
            /* :: */[
              pred(ind),
              beginend
            ]
          ];
          break;
      default:
        match$2 = /* tuple */[
          ind,
          nl,
          beginend
        ];
    }
  }
  var ind$1 = match$2[0];
  var pp = Pp$ReactTemplate.$plus$plus(match$2[1] ? Pp$ReactTemplate.fnl(/* () */0) : Pp$ReactTemplate.mt(/* () */0), Pp$ReactTemplate.hov(ind$1 + 1 | 0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str($$String.make(ind$1, /* " " */32)), Ppvernac$ReactTemplate.pr_vernac(cmd))));
  return /* tuple */[
          new_ngl,
          new_nl,
          match$2[2],
          /* :: */[
            pp,
            param[3]
          ]
        ];
}

function get_script(prf) {
  var match;
  if (prf) {
    var name = prf[0];
    match = /* tuple */[
      Curry._1(current_branch, vcs[0]),
      (function (nl) {
          if (nl) {
            return List.mem(name, nl);
          } else {
            return /* true */1;
          }
        })
    ];
  } else {
    match = /* tuple */[
      VCS_001[/* master */4],
      (function () {
          return /* true */1;
        })
    ];
  }
  var test = match[1];
  var _acc = /* [] */0;
  var _id = Curry._2(get_branch, vcs[0], match[0])[/* pos */2];
  while(true) {
    var id = _id;
    var acc = _acc;
    if (Stateid$ReactTemplate.equal(id, Stateid$ReactTemplate.initial) || Stateid$ReactTemplate.equal(id, Stateid$ReactTemplate.dummy)) {
      return acc;
    } else {
      var view = visit$1(id);
      var match$1 = view[/* step */0];
      var variant = match$1[0];
      if (variant !== 3356250) {
        if (variant >= 781815138) {
          if (variant >= 884916592) {
            _id = match$1[1][0];
            continue ;
            
          } else if (Curry._1(test, match$1[1][0][3])) {
            return acc;
          } else {
            _id = view[/* next */1];
            continue ;
            
          }
        } else if (variant >= 4050672) {
          var match$2 = match$1[1];
          _id = match$2[1];
          _acc = /* :: */[
            /* tuple */[
              match$2[0][/* qast */0][/* expr */4],
              get_info$1(id)[/* n_goals */1]
            ],
            /* [] */0
          ];
          continue ;
          
        } else {
          var match$3 = match$1[1];
          var match$4 = match$3[0];
          if (match$4) {
            _id = view[/* next */1];
            _acc = /* :: */[
              /* tuple */[
                match$4[0][/* expr */4],
                get_info$1(id)[/* n_goals */1]
              ],
              acc
            ];
            continue ;
            
          } else {
            _id = match$3[1];
            continue ;
            
          }
        }
      } else {
        var match$5 = match$1[1];
        _id = view[/* next */1];
        if (match$5[/* ctac */0]) {
          _acc = /* :: */[
            /* tuple */[
              match$5[/* cast */2][/* expr */4],
              get_info$1(id)[/* n_goals */1]
            ],
            acc
          ];
          continue ;
          
        } else {
          continue ;
          
        }
      }
    }
  };
}

function show_script(proof, _) {
  try {
    var prf;
    try {
      prf = proof ? /* Some */[proof[0][0][/* id */0]] : /* Some */[Proof_global$ReactTemplate.get_current_proof_name(/* () */0)];
    }
    catch (exn){
      if (exn === Proof_global$ReactTemplate.NoCurrentProof) {
        prf = /* None */0;
      } else {
        throw exn;
      }
    }
    var cmds = get_script(prf);
    var match = List.fold_left(indent_script_item, /* tuple */[
          /* tuple */[
            1,
            /* [] */0
          ],
          /* false */0,
          /* [] */0,
          /* [] */0
        ], cmds);
    var indented_cmds = List.rev(match[3]);
    return Feedback$ReactTemplate.msg_notice(/* None */0, Pp$ReactTemplate.v(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (x) {
                          return x;
                        }), indented_cmds)));
  }
  catch (exn$1){
    if (exn$1 === Expired) {
      return /* () */0;
    } else {
      throw exn$1;
    }
  }
}

function stm_vernac_interp(proof, route, id, st, param) {
  var loc = param[/* loc */1];
  var verbose = param[/* verbose */0];
  var expr = param[/* expr */4];
  Feedback$ReactTemplate.set_id_for_feedback(route, 0, id);
  var is_filtered_command = function (param) {
    if (typeof param === "number") {
      switch (param) {
        case 0 : 
        case 1 : 
        case 2 : 
            return /* true */1;
        default:
          return /* false */0;
      }
    } else {
      switch (param.tag | 0) {
        case 44 : 
        case 45 : 
        case 46 : 
        case 72 : 
        case 73 : 
        case 74 : 
        case 75 : 
            return /* true */1;
        default:
          return /* false */0;
      }
    }
  };
  var st$1 = st;
  var expr$1 = expr;
  var cmd = Vernacprop$ReactTemplate.under_control(expr$1);
  if (is_filtered_command(cmd)) {
    stm_pperr_endline((function () {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("ignoring "), Ppvernac$ReactTemplate.pr_vernac(expr$1));
          }));
    return st$1;
  } else {
    var exit = 0;
    if (typeof cmd === "number") {
      exit = 1;
    } else if (cmd.tag === 79) {
      var match = cmd[0];
      if (typeof match === "number") {
        if (match !== 1) {
          exit = 1;
        } else {
          show_script(/* None */0, /* () */0);
          return st$1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      stm_pperr_endline((function () {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("interpreting "), Ppvernac$ReactTemplate.pr_vernac(expr$1));
            }));
      try {
        return Vernacentries$ReactTemplate.interp(/* Some */[verbose], proof, st$1, CAst$ReactTemplate.make(loc, expr$1));
      }
      catch (raw_e){
        var e = Js_exn.internalToOCamlException(raw_e);
        var e$1 = CErrors$ReactTemplate.push(e);
        return Exninfo$ReactTemplate.iraise(call_process_error_once(e$1));
      }
    }
    
  }
}

function record() {
  return List.iter((function (current_branch) {
                var mine_001 = Curry._2(get_branch, vcs[0], current_branch);
                var mine = /* tuple */[
                  current_branch,
                  mine_001
                ];
                var info = get_info$1(Curry._2(get_branch, vcs[0], current_branch)[/* pos */2]);
                var others = CList$ReactTemplate.map_filter((function (b) {
                        if (Curry._2(Vcs_[/* Branch */0][/* equal */1], b, current_branch)) {
                          return /* None */0;
                        } else {
                          return /* Some */[/* tuple */[
                                    b,
                                    Curry._2(get_branch, vcs[0], b)
                                  ]];
                        }
                      }), Curry._1(branches, vcs[0]));
                var backup = info[/* vcs_backup */3][0] !== /* None */0 ? info[/* vcs_backup */3][0] : /* Some */[vcs[0]];
                var branches$1 = info[/* vcs_backup */3][1] !== /* None */0 ? info[/* vcs_backup */3][1] : /* Some */[/* record */[
                      /* mine */mine,
                      /* others */others
                    ]];
                info[/* vcs_backup */3] = /* tuple */[
                  backup,
                  branches$1
                ];
                return /* () */0;
              }), /* :: */[
              Curry._1(current_branch, vcs[0]),
              /* :: */[
                VCS_001[/* master */4],
                /* [] */0
              ]
            ]);
}

function backto(oid) {
  var info = get_info$1(oid);
  var match = info[/* vcs_backup */3];
  var match$1 = match[0];
  if (match$1) {
    vcs[0] = match$1[0];
    return /* () */0;
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Backtrack.backto "), Pp$ReactTemplate.str(Stateid$ReactTemplate.to_string(oid))), Pp$ReactTemplate.str(": a state with no vcs_backup.")));
  }
}

function branches_of(id) {
  var info = get_info$1(id);
  var match = info[/* vcs_backup */3];
  var match$1 = match[1];
  if (match$1) {
    return match$1[0];
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Backtrack.branches_of "), Pp$ReactTemplate.str(Stateid$ReactTemplate.to_string(id))), Pp$ReactTemplate.str(": a state with no vcs_backup.")));
  }
}

function fold_until(f, acc, id) {
  var next = function (acc) {
    if (Caml_obj.caml_equal(id, Stateid$ReactTemplate.initial)) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      return fold_until(f, acc, visit$1(id)[/* next */1]);
    }
  };
  var info = get_info$1(id);
  var match = info[/* vcs_backup */3];
  var match$1 = match[0];
  if (match$1) {
    var match$2;
    if (Caml_obj.caml_equal(id, Stateid$ReactTemplate.initial) || Caml_obj.caml_equal(id, Stateid$ReactTemplate.dummy)) {
      match$2 = /* tuple */[
        /* [] */0,
        /* false */0,
        0
      ];
    } else {
      var match$3 = visit$1(id);
      var match$4 = match$3[/* step */0];
      if (typeof match$4 === "number") {
        match$2 = /* tuple */[
          /* [] */0,
          /* false */0,
          0
        ];
      } else {
        var variant = match$4[0];
        if (variant !== 3356250) {
          if (variant !== 781815138) {
            if (variant !== 884916592) {
              match$2 = /* tuple */[
                /* [] */0,
                /* false */0,
                0
              ];
            } else {
              var expr = match$4[1][1][/* expr */4];
              if (Vernacprop$ReactTemplate.has_Fail(expr)) {
                match$2 = /* tuple */[
                  /* [] */0,
                  /* false */0,
                  0
                ];
              } else {
                var match$5 = Vernacprop$ReactTemplate.under_control(expr);
                match$2 = typeof match$5 === "number" ? /* tuple */[
                    /* [] */0,
                    /* false */0,
                    0
                  ] : (
                    match$5.tag === 73 ? /* tuple */[
                        /* [] */0,
                        /* false */0,
                        match$5[0]
                      ] : /* tuple */[
                        /* [] */0,
                        /* false */0,
                        0
                      ]
                  );
              }
            }
          } else {
            match$2 = /* tuple */[
              match$4[1][0][3],
              /* false */0,
              0
            ];
          }
        } else {
          var match$6 = match$4[1];
          match$2 = /* tuple */[
            match$6[/* cids */3],
            match$6[/* ctac */0],
            0
          ];
        }
      }
    }
    var match$7 = Curry._2(f, acc, /* tuple */[
          id,
          match$1[0],
          match$2[0],
          match$2[1],
          match$2[2]
        ]);
    if (match$7[0] >= 926227490) {
      return match$7[1];
    } else {
      return next(match$7[1]);
    }
  } else {
    return next(acc);
  }
}

var undo_costly_in_batch_mode = CWarnings$ReactTemplate.create("undo-batch-mode", "non-interactive", /* None */0, (function (v) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Command "), Ppvernac$ReactTemplate.pr_vernac(v)), Pp$ReactTemplate.str(" is not recommended in batch mode. In particular, going back in the document is not efficient in batch mode due to Coq not caching previous states for memory optimization reasons. If your use is intentional, you may want to disable this warning and pass the \"-async-proofs-cache force\" option to Coq."));
      }));

function undo_vernac_classifier(v) {
  if (is_interactive(/* () */0) === /* No */17505 && Caml_obj.caml_notequal(cur_opt[0][/* async_proofs_cache */2], /* Some */[/* Force */0])) {
    Curry._2(undo_costly_in_batch_mode, /* None */0, v);
  }
  try {
    var e = Vernacprop$ReactTemplate.under_control(v);
    var exit = 0;
    if (typeof e === "number") {
      switch (e) {
        case 0 : 
            return /* tuple */[
                    Stateid$ReactTemplate.initial,
                    /* VtNow */0
                  ];
        case 1 : 
            var head = Curry._1(current_branch, vcs[0]);
            var id = Curry._2(get_branch, vcs[0], head)[/* pos */2];
            var oid = fold_until((function (_, param) {
                    var match = Curry._1(Vcs_[/* branches */3], param[1]);
                    if (match) {
                      if (match[1]) {
                        return /* `Cont */[
                                748545554,
                                /* () */0
                              ];
                      } else {
                        return /* `Stop */[
                                926227490,
                                param[0]
                              ];
                      }
                    } else {
                      return /* `Cont */[
                              748545554,
                              /* () */0
                            ];
                    }
                  }), /* () */0, id);
            return /* tuple */[
                    oid,
                    /* VtLater */1
                  ];
        case 2 : 
            exit = 1;
            break;
        default:
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("incorrect VtMeta classification"));
      }
    } else {
      switch (e.tag | 0) {
        case 44 : 
            var name = e[0][/* v */0];
            var head$1 = Curry._1(current_branch, vcs[0]);
            var id$1 = Curry._2(get_branch, vcs[0], head$1)[/* pos */2];
            try {
              var oid$1 = fold_until((function (b, param) {
                      if (b) {
                        return /* `Stop */[
                                926227490,
                                param[0]
                              ];
                      } else {
                        return /* `Cont */[
                                748545554,
                                List.mem(name, param[2])
                              ];
                      }
                    }), /* false */0, id$1);
              return /* tuple */[
                      oid$1,
                      /* VtNow */0
                    ];
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return /* tuple */[
                        id$1,
                        /* VtNow */0
                      ];
              } else {
                throw exn;
              }
            }
            break;
        case 45 : 
            var head$2 = Curry._1(current_branch, vcs[0]);
            var id$2 = Curry._2(get_branch, vcs[0], head$2)[/* pos */2];
            var oid$2 = fold_until((function (n, param) {
                    if (n) {
                      return /* `Cont */[
                              748545554,
                              n - 1 | 0
                            ];
                    } else {
                      return /* `Stop */[
                              926227490,
                              param[0]
                            ];
                    }
                  }), e[0], id$2);
            return /* tuple */[
                    oid$2,
                    /* VtNow */0
                  ];
        case 73 : 
            var head$3 = Curry._1(current_branch, vcs[0]);
            var id$3 = Curry._2(get_branch, vcs[0], head$3)[/* pos */2];
            var oid$3 = fold_until((function (n, param) {
                    var value = (
                      param[3] ? 1 : 0
                    ) - param[4] | 0;
                    if (n) {
                      return /* `Cont */[
                              748545554,
                              n - value | 0
                            ];
                    } else {
                      return /* `Stop */[
                              926227490,
                              param[0]
                            ];
                    }
                  }), e[0], id$3);
            return /* tuple */[
                    oid$3,
                    /* VtLater */1
                  ];
        case 74 : 
            exit = 1;
            break;
        case 46 : 
        case 75 : 
            return /* tuple */[
                    Stateid$ReactTemplate.of_int(e[0]),
                    /* VtNow */0
                  ];
        default:
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("incorrect VtMeta classification"));
      }
    }
    if (exit === 1) {
      var m;
      m = typeof e === "number" || e.tag !== 74 ? 0 : e[0];
      var head$4 = Curry._1(current_branch, vcs[0]);
      var id$4 = Curry._2(get_branch, vcs[0], head$4)[/* pos */2];
      var match = get_info$1(id$4)[/* vcs_backup */3];
      var match$1 = match[0];
      var vcs$1 = match$1 ? match$1[0] : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Backtrack: tip with no vcs_backup."));
      var match$2;
      try {
        match$2 = find_proof_at_depth(vcs$1, proof_nesting(vcs$1));
      }
      catch (raw_exn){
        var exn$1 = Js_exn.internalToOCamlException(raw_exn);
        if (exn$1[0] === Caml_builtin_exceptions.failure) {
          throw Proof_global$ReactTemplate.NoCurrentProof;
        } else {
          throw exn$1;
        }
      }
      var cb = match$2[0];
      var n = fold_until((function (n, param) {
              if (List.mem(cb, Curry._1(Vcs_[/* branches */3], param[1]))) {
                return /* `Cont */[
                        748545554,
                        n + 1 | 0
                      ];
              } else {
                return /* `Stop */[
                        926227490,
                        n
                      ];
              }
            }), 0, id$4);
      var oid$4 = fold_until((function (n, param) {
              if (n) {
                return /* `Cont */[
                        748545554,
                        n - 1 | 0
                      ];
              } else {
                return /* `Stop */[
                        926227490,
                        param[0]
                      ];
              }
            }), (n - m | 0) - 1 | 0, id$4);
      return /* tuple */[
              oid$4,
              /* VtLater */1
            ];
    }
    
  }
  catch (exn$2){
    if (exn$2 === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["undo_vernac_classifier"], Pp$ReactTemplate.str("Cannot undo"));
    } else {
      throw exn$2;
    }
  }
}

var RemoteException = Caml_exceptions.create("Stm-ReactTemplate.RemoteException");

CErrors$ReactTemplate.register_handler((function (param) {
        if (param[0] === RemoteException) {
          return param[1];
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

var proof_block_delimiters = [/* [] */0];

function register_proof_block_delimiter(name, $$static, dynamic) {
  if (List.mem_assoc(name, proof_block_delimiters[0])) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["STM"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Duplicate block delimiter "), Pp$ReactTemplate.str(name)));
  }
  proof_block_delimiters[0] = /* :: */[
    /* tuple */[
      name,
      /* tuple */[
        $$static,
        dynamic
      ]
    ],
    proof_block_delimiters[0]
  ];
  return /* () */0;
}

function mk_doc_node(id, param) {
  var match = param[/* step */0];
  if (typeof match === "number") {
    return /* None */0;
  } else {
    var variant = match[0];
    if (variant !== -417845577) {
      if (variant !== 3356250) {
        return /* None */0;
      } else {
        var match$1 = match[1];
        var match$2 = match$1[/* cast */2];
        var expr = match$2[/* expr */4];
        if (match$1[/* ctac */0]) {
          return /* Some */[/* record */[
                    /* indentation */match$2[/* indentation */2],
                    /* ast */expr,
                    /* id */id
                  ]];
        } else {
          return /* None */0;
        }
      }
    } else {
      var match$3 = match[1][0];
      if (match$3) {
        var match$4 = match$3[0];
        var expr$1 = match$4[/* expr */4];
        return /* Some */[/* record */[
                  /* indentation */match$4[/* indentation */2],
                  /* ast */expr$1,
                  /* id */id
                ]];
      } else {
        return /* None */0;
      }
    }
  }
}

function prev_node(param) {
  var id = visit$1(param[/* id */2])[/* next */1];
  return mk_doc_node(id, visit$1(id));
}

function cur_node(id) {
  return mk_doc_node(id, visit$1(id));
}

function is_block_name_enabled(name) {
  var match = cur_opt[0][/* async_proofs_tac_error_resilience */7];
  if (typeof match === "number") {
    if (match >= 870530776) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  } else {
    return List.mem(name, match[1]);
  }
}

function detect_proof_block(id, name) {
  var name$1 = name ? name[0] : "indent";
  if (is_block_name_enabled(name$1) && (async_proofs_is_master(cur_opt[0]) || Flags$ReactTemplate.async_proofs_is_worker(/* () */0))) {
    var match = cur_node(id);
    if (match) {
      try {
        var match$1 = List.assoc(name$1, proof_block_delimiters[0]);
        var match$2 = Curry._1(match$1[0], /* record */[
              /* entry_point */match[0],
              /* prev_node */prev_node
            ]);
        if (match$2) {
          return create_proof_block(match$2[0], name$1);
        } else {
          return /* () */0;
        }
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["STM"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unknown proof block delimiter "), Pp$ReactTemplate.str(name$1)));
        } else {
          throw exn;
        }
      }
    } else {
      return /* () */0;
    }
  } else {
    return 0;
  }
}

var Reach = Caml_module.init_mod([
      "/Users/joel/code/reason/planetary-frontend/src/stm.ml",
      2116,
      6
    ], [[0]]);

var Slaves = Caml_module.init_mod([
      "/Users/joel/code/reason/planetary-frontend/src/stm.ml",
      1631,
      6
    ], [[
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]]);

var Partac = Caml_module.init_mod([
      "/Users/joel/code/reason/planetary-frontend/src/stm.ml",
      1960,
      6
    ], [[0]]);

var Query = Caml_module.init_mod([
      "/Users/joel/code/reason/planetary-frontend/src/stm.ml",
      2094,
      6
    ], [[
        0,
        0
      ]]);

function forward_feedback$1(msg) {
  return Curry._1(Hook$ReactTemplate.get(forward_feedback), msg);
}

var name = ["proofworker"];

function extra_env() {
  return async_proofs_workers_extra_env[0];
}

var perspective = [/* [] */0];

function task_match(age, t) {
  if (age) {
    var my_states = age[0];
    if (t.tag) {
      return List.for_all((function (x) {
                    return CList$ReactTemplate.mem_f(Stateid$ReactTemplate.equal, x, my_states);
                  }), t[0]);
    } else {
      return /* false */0;
    }
  } else if (t.tag) {
    return /* false */0;
  } else if (cur_opt[0][/* async_proofs_full */5]) {
    return List.exists((function (x) {
                  return CList$ReactTemplate.mem_f(Stateid$ReactTemplate.equal, x, perspective[0]);
                }), t[0][/* t_states */4]);
  } else {
    return /* true */1;
  }
}

function name_of_task(param) {
  if (param.tag) {
    return "states: " + $$String.concat(",", List.map(Stateid$ReactTemplate.to_string, param[0]));
  } else {
    return "proof: " + param[0][/* t_name */8];
  }
}

function name_of_request(param) {
  if (param.tag) {
    return "states: " + $$String.concat(",", List.map(Stateid$ReactTemplate.to_string, param[0]));
  } else {
    return "proof: " + param[0][/* name */5];
  }
}

function request_of_task(age, param) {
  if (param.tag) {
    return /* Some */[/* ReqStates */Block.__(1, [param[0]])];
  } else {
    var match = param[0];
    var t_stop = match[/* t_stop */2];
    if (age !== /* Fresh */0) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "stm.ml",
              1439,
              8
            ]
          ];
    }
    try {
      return /* Some */[/* ReqBuildProof */Block.__(0, [
                  /* record */[
                    /* exn_info */match[/* t_exn_info */0],
                    /* stop */t_stop,
                    /* document */slice(match[/* t_start */1], t_stop),
                    /* loc */match[/* t_loc */6],
                    /* uuid */match[/* t_uuid */7],
                    /* name */match[/* t_name */8]
                  ],
                  match[/* t_drop */3],
                  match[/* t_states */4]
                ])];
    }
    catch (exn){
      if (exn === Expired) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
  }
}

function use_response(s, t, r) {
  var exit = 0;
  if (s) {
    if (t.tag) {
      switch (r.tag | 0) {
        case 0 : 
        case 1 : 
            exit = 1;
            break;
        case 2 : 
            List.iter((function (param) {
                    var id = param[0];
                    var what = param[1];
                    if (get_info$1(id)[/* state */2] !== /* Empty */0) {
                      return /* () */0;
                    } else {
                      try {
                        if (what[0] >= 1019087344) {
                          var match = what[1];
                          var match$1 = match[1];
                          var ontop = match[0];
                          if (is_cached(/* None */0, ontop, /* true */1)) {
                            var s = get_cached(ontop);
                            var s_000 = /* system */s[/* system */0];
                            var s_001 = /* proof */Proof_global$ReactTemplate.copy_terminators(s[/* proof */1], match$1[0]);
                            var s_002 = /* shallow */s[/* shallow */2];
                            var st = States$ReactTemplate.summary_of_state(s_000);
                            var st$1 = Summary$ReactTemplate.modify_summary(st, Util$ReactTemplate.pi1(summary_pstate), match$1[1]);
                            var st$2 = Summary$ReactTemplate.modify_summary(st$1, Util$ReactTemplate.pi2(summary_pstate), match$1[2]);
                            var s_000$1 = /* system */States$ReactTemplate.replace_summary(s_000, Summary$ReactTemplate.modify_summary(st$2, Util$ReactTemplate.pi3(summary_pstate), match$1[3]));
                            var s_001$1 = s_001;
                            var s_002$1 = s_002;
                            var s$1 = /* record */[
                              s_000$1,
                              s_001$1,
                              s_002$1
                            ];
                            return set_state(id, /* Valid */Block.__(1, [s$1]));
                          } else {
                            return 0;
                          }
                        } else {
                          var s$2 = what[1];
                          var s$3;
                          try {
                            var prev = visit$1(id)[/* next */1];
                            s$3 = is_cached(/* None */0, prev, /* true */1) ? /* record */[
                                /* system */s$2[/* system */0],
                                /* proof */Proof_global$ReactTemplate.copy_terminators(get_cached(prev)[/* proof */1], s$2[/* proof */1]),
                                /* shallow */s$2[/* shallow */2]
                              ] : s$2;
                          }
                          catch (exn){
                            if (exn === Expired) {
                              s$3 = s$2;
                            } else {
                              throw exn;
                            }
                          }
                          return set_state(id, /* Valid */Block.__(1, [s$3]));
                        }
                      }
                      catch (exn$1){
                        if (exn$1 === Expired) {
                          return /* () */0;
                        } else {
                          throw exn$1;
                        }
                      }
                    }
                  }), r[0]);
            return /* End */3455931;
        
      }
    } else {
      exit = 1;
    }
  } else if (t.tag) {
    exit = 1;
  } else {
    var match = t[0];
    var t_assign = match[/* t_assign */5];
    var t_states = match[/* t_states */4];
    switch (r.tag | 0) {
      case 0 : 
          Feedback$ReactTemplate.feedback(/* None */0, /* None */0, /* None */0, /* InProgress */Block.__(1, [-1]));
          Curry._1(t_assign, /* `Val */[
                4298433,
                r[0]
              ]);
          if (cur_opt[0][/* async_proofs_full */5] || match[/* t_drop */3]) {
            return /* `Stay */[
                    926224377,
                    /* tuple */[
                      t_states,
                      /* :: */[
                        /* States */Block.__(1, [t_states]),
                        /* [] */0
                      ]
                    ]
                  ];
          } else {
            return /* End */3455931;
          }
      case 1 : 
          var match$1 = r[0];
          Feedback$ReactTemplate.feedback(/* None */0, /* None */0, /* None */0, /* InProgress */Block.__(1, [-1]));
          var info = Stateid$ReactTemplate.add(Exninfo$ReactTemplate.$$null, match$1[/* e_safe_id */1], match$1[/* e_error_at */0]);
          var e_000 = [
            RemoteException,
            match$1[/* e_msg */2]
          ];
          var e = /* tuple */[
            e_000,
            info
          ];
          Curry._1(t_assign, /* `Exn */[
                3458171,
                e
              ]);
          return /* `Stay */[
                  926224377,
                  /* tuple */[
                    t_states,
                    /* :: */[
                      /* States */Block.__(1, [match$1[/* e_safe_states */3]]),
                      /* [] */0
                    ]
                  ]
                ];
      case 2 : 
          exit = 1;
          break;
      
    }
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "stm.ml",
            1468,
            11
          ]
        ];
  }
  
}

function on_task_cancellation_or_expiration_or_slave_death(param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      return /* () */0;
    } else {
      var match$1 = match[0];
      var start = match$1[/* t_start */1];
      var s = "Worker dies or task expired";
      var info = Stateid$ReactTemplate.add(Exninfo$ReactTemplate.$$null, start, start);
      var e_000 = [
        RemoteException,
        Pp$ReactTemplate.strbrk(s)
      ];
      var e = /* tuple */[
        e_000,
        info
      ];
      Curry._1(match$1[/* t_assign */5], /* `Exn */[
            3458171,
            e
          ]);
      execution_error(/* None */0, start, Pp$ReactTemplate.strbrk(s));
      return Feedback$ReactTemplate.feedback(/* None */0, /* None */0, /* None */0, /* InProgress */Block.__(1, [-1]));
    }
  } else {
    return /* () */0;
  }
}

function build_proof_here(_, drop_pt, param, eop) {
  var valid = param[1];
  var id = param[0];
  return Future$ReactTemplate.create((function (param) {
                return exn_on(id, valid, param);
              }), (function () {
                Unix.gettimeofday(/* () */0);
                if (is_interactive(/* () */0) === /* No */17505) {
                  Curry._3(Reach[/* known_state */0], /* None */0, /* No */17505, eop);
                } else {
                  Curry._3(Reach[/* known_state */0], /* None */0, /* Shallow */841395124, eop);
                }
                var p = Proof_global$ReactTemplate.return_proof(/* Some */[drop_pt], /* () */0);
                if (drop_pt) {
                  Feedback$ReactTemplate.feedback(/* None */0, /* Some */[id], /* None */0, /* Complete */2);
                }
                return p;
              }));
}

function perform_states(query) {
  if (query) {
    var is_tac = function (e) {
      var match = Vernac_classifier$ReactTemplate.classify_vernac(e);
      var tmp = match[0];
      if (typeof tmp === "number" || tmp.tag !== 3) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    };
    var aux = function (id) {
      try {
        var match = visit$1(id);
        return aux(match[/* next */1]);
      }
      catch (exn){
        if (exn === Expired) {
          return id;
        } else {
          throw exn;
        }
      }
    };
    var initial = aux(List.hd(query));
    var get_state = function (seen, id) {
      var prev;
      try {
        var match = visit$1(id);
        var prev$1 = match[/* next */1];
        prev = is_cached(/* None */0, prev$1, /* true */1) && List.mem(prev$1, seen) ? /* Some */[/* tuple */[
              prev$1,
              get_cached(prev$1),
              match[/* step */0]
            ]] : /* None */0;
      }
      catch (exn){
        if (exn === Expired) {
          prev = /* None */0;
        } else {
          throw exn;
        }
      }
      var $$this = is_cached(/* None */0, id, /* true */1) ? /* Some */[get_cached(id)] : /* None */0;
      if ($$this) {
        if (prev) {
          var match$1 = prev[0];
          var match$2 = match$1[2];
          var exit = 0;
          if (typeof match$2 === "number") {
            exit = 1;
          } else if (match$2[0] !== 3356250) {
            exit = 1;
          } else {
            var expr = match$2[1][/* cast */2][/* expr */4];
            var n = $$this[0];
            if (is_tac(expr) && same_env(match$1[1], n)) {
              return /* Some */[/* tuple */[
                        id,
                        /* `ProofOnly */[
                          1019087344,
                          /* tuple */[
                            match$1[0],
                            proof_part_of_frozen(n)
                          ]
                        ]
                      ]];
            } else {
              exit = 1;
            }
          }
          if (exit === 1) {
            Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.str("STM: sending back a fat state"));
            return /* Some */[/* tuple */[
                      id,
                      /* `Full */[
                        782112175,
                        $$this[0]
                      ]
                    ]];
          }
          
        } else {
          return /* Some */[/* tuple */[
                    id,
                    /* `Full */[
                      782112175,
                      $$this[0]
                    ]
                  ]];
        }
      } else {
        return /* None */0;
      }
    };
    var aux$1 = function (seen, _param) {
      while(true) {
        var param = _param;
        if (param) {
          var rest = param[1];
          var id = param[0];
          var match = get_state(seen, id);
          if (match) {
            return /* :: */[
                    match[0],
                    aux$1(/* :: */[
                          id,
                          seen
                        ], rest)
                  ];
          } else {
            _param = rest;
            continue ;
            
          }
        } else {
          return /* [] */0;
        }
      };
    };
    return aux$1(/* :: */[
                initial,
                /* [] */0
              ], query);
  } else {
    return /* [] */0;
  }
}

function perform(param) {
  if (param.tag) {
    return /* RespStates */Block.__(2, [perform_states(param[0])]);
  } else {
    var param$1 = param[0];
    var drop = param[1];
    var my_states = param[2];
    var loc = param$1[/* loc */3];
    var stop = param$1[/* stop */1];
    try {
      vcs[0] = param$1[/* document */2];
      print(/* None */0, /* () */0);
      var wall_clock = Unix.gettimeofday(/* () */0);
      var fp = build_proof_here(loc, drop, param$1[/* exn_info */0], stop);
      var proof = Future$ReactTemplate.force(fp);
      var match_002 = Unix.gettimeofday(/* () */0) - wall_clock;
      var fix_exn = Future$ReactTemplate.fix_exn_of(fp);
      var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
      if (!drop) {
        var checked_proof = Future$ReactTemplate.chain(fp, (function (p) {
                Vernacstate$ReactTemplate.unfreeze_interp_state(st);
                var match = Proof_global$ReactTemplate.close_future_proof(stop, Future$ReactTemplate.from_val(/* Some */[fix_exn], p));
                var terminator = Lemmas$ReactTemplate.standard_proof_terminator(/* [] */0, Lemmas$ReactTemplate.mk_hook((function (_, _$1) {
                            return /* () */0;
                          })));
                var st$1 = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                return stm_vernac_interp(/* Some */[/* tuple */[
                              match[0],
                              terminator
                            ]], /* None */0, stop, st$1, /* record */[
                            /* verbose : false */0,
                            /* loc */loc,
                            /* indentation */0,
                            /* strlen */0,
                            /* expr : VernacExpr */Block.__(0, [
                                /* [] */0,
                                /* VernacEndProof */Block.__(10, [/* Proved */[
                                      /* Opaque */0,
                                      /* None */0
                                    ]])
                              ])
                          ]);
              }));
        Future$ReactTemplate.join(checked_proof);
      }
      Vernacstate$ReactTemplate.unfreeze_interp_state(st);
      return /* RespBuiltProof */Block.__(0, [
                proof,
                match_002
              ]);
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (CErrors$ReactTemplate.noncritical(e) || Caml_obj.caml_equal(e, Caml_builtin_exceptions.stack_overflow)) {
        var match = CErrors$ReactTemplate.push(e);
        var info = match[1];
        var match$1 = Stateid$ReactTemplate.get(info);
        var match$2;
        if (match$1) {
          var match$3 = match$1[0];
          match$2 = /* tuple */[
            match$3[1],
            match$3[0]
          ];
        } else {
          match$2 = /* tuple */[
            Stateid$ReactTemplate.dummy,
            Stateid$ReactTemplate.dummy
          ];
        }
        var e_msg = CErrors$ReactTemplate.iprint(/* tuple */[
              match[0],
              info
            ]);
        stm_pperr_endline((function () {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("failed with the following exception: "), Pp$ReactTemplate.fnl(/* () */0)), e_msg);
              }));
        var e_safe_states = List.filter((function (eta) {
                  return is_cached(/* None */0, eta, /* true */1);
                }))(my_states);
        return /* RespError */Block.__(1, [/* record */[
                    /* e_error_at */match$2[0],
                    /* e_safe_id */match$2[1],
                    /* e_msg */e_msg,
                    /* e_safe_states */e_safe_states
                  ]]);
      } else {
        throw e;
      }
    }
  }
}

function on_marshal_error(s, param) {
  if (param.tag) {
    return Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.strbrk("Marshalling error: " + (s + ". The system state could not be sent to the master process.")));
  } else {
    var match = param[0];
    Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.strbrk("Marshalling error: " + (s + ". The system state could not be sent to the worker process. Falling back to local, lazy, evaluation.")));
    Curry._1(match[/* t_assign */5], /* `Comp */[
          748545327,
          build_proof_here(match[/* t_loc */6], match[/* t_drop */3], match[/* t_exn_info */0], match[/* t_stop */2])
        ]);
    return Feedback$ReactTemplate.feedback(/* None */0, /* None */0, /* None */0, /* InProgress */Block.__(1, [-1]));
  }
}

function forward_feedback$2(msg) {
  return Curry._1(Hook$ReactTemplate.get(forward_feedback), msg);
}

var name$1 = ["tacworker"];

function extra_env$1() {
  return /* array */[];
}

function task_match$1(_, _$1) {
  return /* true */1;
}

function request_of_task$1(age, param) {
  var t_state = param[/* t_state */0];
  try {
    return /* Some */[/* record */[
              /* r_state */t_state,
              /* r_state_fb */param[/* t_state_fb */1],
              /* r_document */age !== /* Fresh */0 ? /* None */0 : /* Some */[slice(t_state, t_state)],
              /* r_ast */param[/* t_ast */3],
              /* r_goal */param[/* t_goal */4],
              /* r_name */param[/* t_name */6]
            ]];
  }
  catch (exn){
    if (exn === Expired) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function use_response$1(_, param, resp) {
  var t_kill = param[/* t_kill */5];
  var t_assign = param[/* t_assign */2];
  if (typeof resp === "number") {
    Curry._1(t_assign, /* `Val */[
          4298433,
          /* None */0
        ]);
    Curry._1(t_kill, /* () */0);
    return /* `Stay */[
            926224377,
            /* tuple */[
              /* () */0,
              /* [] */0
            ]
          ];
  } else if (resp.tag) {
    var e_000 = [
      RemoteException,
      resp[0]
    ];
    var e = /* tuple */[
      e_000,
      Exninfo$ReactTemplate.$$null
    ];
    Curry._1(t_assign, /* `Exn */[
          3458171,
          e
        ]);
    Curry._1(t_kill, /* () */0);
    return /* `Stay */[
            926224377,
            /* tuple */[
              /* () */0,
              /* [] */0
            ]
          ];
  } else {
    Curry._1(t_assign, /* `Val */[
          4298433,
          /* Some */[resp[0]]
        ]);
    return /* `Stay */[
            926224377,
            /* tuple */[
              /* () */0,
              /* [] */0
            ]
          ];
  }
}

function on_marshal_error$1(_, param) {
  stm_pr_err("Fatal marshal error: " + param[/* t_name */6]);
  Pervasives.flush_all(/* () */0);
  return Pervasives.exit(1);
}

function on_task_cancellation_or_expiration_or_slave_death$1(param) {
  if (param) {
    return Curry._1(param[0][/* t_kill */5], /* () */0);
  } else {
    return /* () */0;
  }
}

var command_focus = Proof$ReactTemplate.new_focus_kind(/* () */0);

var focus_cond = Proof$ReactTemplate.no_cond(/* None */0, command_focus);

function perform$1(param) {
  var r_goal = param[/* r_goal */4];
  var r_ast = param[/* r_ast */3];
  var r_state_fb = param[/* r_state_fb */1];
  Option$ReactTemplate.iter(restore, param[/* r_document */2]);
  try {
    Curry._3(Reach[/* known_state */0], /* None */0, /* No */17505, param[/* r_state */0]);
    return stm_purify((function () {
                  var match = Proof$ReactTemplate.proof(Proof_global$ReactTemplate.give_me_the_proof(/* () */0));
                  var sigma0 = match[4];
                  var g = Evd$ReactTemplate.find(sigma0, r_goal);
                  var is_ground = function (c) {
                    return Evarutil$ReactTemplate.is_ground_term(sigma0, EConstr$ReactTemplate.of_constr(c));
                  };
                  var c = Evd$ReactTemplate.evar_concl(g);
                  if (Evarutil$ReactTemplate.is_ground_term(sigma0, EConstr$ReactTemplate.of_constr(c)) && List.for_all(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* for_all */8], is_ground), Evd$ReactTemplate.evar_context(g))) {
                    var i = r_ast[0];
                    Proof_global$ReactTemplate.simple_with_current_proof((function (_, p) {
                            return Proof$ReactTemplate.focus(focus_cond, /* () */0, i, p);
                          }));
                    var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                    stm_vernac_interp(/* None */0, /* None */0, r_state_fb, st, r_ast[1]);
                    var match$1 = Proof$ReactTemplate.proof(Proof_global$ReactTemplate.give_me_the_proof(/* () */0));
                    var sigma = match$1[4];
                    var match$2 = Evd$ReactTemplate.evar_body(Evd$ReactTemplate.find(sigma, r_goal));
                    if (match$2) {
                      var t = EConstr$ReactTemplate.of_constr(match$2[0]);
                      var t$1 = Evarutil$ReactTemplate.nf_evar(sigma, t);
                      if (Evarutil$ReactTemplate.is_ground_term(sigma, t$1)) {
                        var t$2 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](t$1);
                        return /* RespBuiltSubProof */Block.__(0, [/* tuple */[
                                    t$2,
                                    Evd$ReactTemplate.evar_universe_context(sigma)
                                  ]]);
                      } else {
                        return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["STM"], Pp$ReactTemplate.str("The solution is not ground"));
                      }
                    } else {
                      return /* RespNoProgress */0;
                    }
                  } else {
                    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["STM"], Pp$ReactTemplate.strbrk("the par: goal selector supports ground goals only"));
                  }
                }), /* () */0);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      return /* RespError */Block.__(1, [CErrors$ReactTemplate.print(/* None */0, e)]);
    } else {
      throw e;
    }
  }
}

function name_of_task$1(param) {
  return param[/* t_name */6];
}

function name_of_request$1(param) {
  return param[/* r_name */5];
}

var TacTask = /* module */[
  /* name */name$1,
  /* extra_env */extra_env$1,
  /* request_of_task */request_of_task$1,
  /* task_match */task_match$1,
  /* use_response */use_response$1,
  /* on_marshal_error */on_marshal_error$1,
  /* on_task_cancellation_or_expiration_or_slave_death */on_task_cancellation_or_expiration_or_slave_death$1,
  /* forward_feedback */forward_feedback$2,
  /* perform */perform$1,
  /* name_of_task */name_of_task$1,
  /* name_of_request */name_of_request$1
];

var name$2 = ["queryworker"];

function extra_env$2() {
  return /* array */[];
}

function task_match$2(_, _$1) {
  return /* true */1;
}

function request_of_task$2(_, param) {
  var t_where = param[/* t_where */0];
  try {
    return /* Some */[/* record */[
              /* r_where */t_where,
              /* r_for */param[/* t_for */1],
              /* r_what */param[/* t_what */2],
              /* r_doc */slice(t_where, t_where)
            ]];
  }
  catch (exn){
    if (exn === Expired) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function use_response$2(_, _$1, _$2) {
  return /* End */3455931;
}

function on_marshal_error$2(_, _$1) {
  stm_pr_err("Fatal marshal error in query");
  Pervasives.flush_all(/* () */0);
  return Pervasives.exit(1);
}

function on_task_cancellation_or_expiration_or_slave_death$2() {
  return /* () */0;
}

function forward_feedback$3(msg) {
  return Curry._1(Hook$ReactTemplate.get(forward_feedback), msg);
}

function perform$2(param) {
  var r_what = param[/* r_what */2];
  var r_for = param[/* r_for */1];
  vcs[0] = param[/* r_doc */3];
  print(/* None */0, /* () */0);
  Curry._3(Reach[/* known_state */0], /* None */0, /* No */17505, param[/* r_where */0]);
  var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
  try {
    stm_vernac_interp(/* None */0, /* None */0, r_for, st, /* record */[
          /* verbose : true */1,
          /* loc */r_what[/* loc */1],
          /* indentation */r_what[/* indentation */2],
          /* strlen */r_what[/* strlen */3],
          /* expr */r_what[/* expr */4]
        ]);
    return Feedback$ReactTemplate.feedback(/* None */0, /* Some */[r_for], /* None */0, /* Processed */0);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      var e$1 = CErrors$ReactTemplate.push(e);
      var msg = CErrors$ReactTemplate.iprint(e$1);
      return Feedback$ReactTemplate.feedback(/* None */0, /* Some */[r_for], /* None */0, /* Message */Block.__(8, [
                    /* Error */4,
                    /* None */0,
                    msg
                  ]));
    } else {
      throw e;
    }
  }
}

function name_of_task$2(param) {
  return Pp$ReactTemplate.string_of_ppcmds(pr_ast(param[/* t_what */2]));
}

function name_of_request$2(param) {
  return Pp$ReactTemplate.string_of_ppcmds(pr_ast(param[/* r_what */2]));
}

var QueryTask = /* module */[
  /* name */name$2,
  /* extra_env */extra_env$2,
  /* request_of_task */request_of_task$2,
  /* task_match */task_match$2,
  /* use_response */use_response$2,
  /* on_marshal_error */on_marshal_error$2,
  /* on_task_cancellation_or_expiration_or_slave_death */on_task_cancellation_or_expiration_or_slave_death$2,
  /* forward_feedback */forward_feedback$3,
  /* perform */perform$2,
  /* name_of_task */name_of_task$2,
  /* name_of_request */name_of_request$2
];

function async_policy() {
  if (Flags$ReactTemplate.is_universe_polymorphism(/* () */0)) {
    return /* false */0;
  } else if (is_interactive(/* () */0) === /* Yes */4448519) {
    if (async_proofs_is_master(cur_opt[0])) {
      return /* true */1;
    } else {
      return +(cur_opt[0][/* async_proofs_mode */3] === /* APonLazy */1);
    }
  } else if (is_vio_doc(/* () */0)) {
    return /* true */1;
  } else {
    return +(cur_opt[0][/* async_proofs_mode */3] !== /* APoff */0);
  }
}

function delegate() {
  if (is_vio_doc(/* () */0)) {
    return /* true */1;
  } else {
    return cur_opt[0][/* async_proofs_full */5];
  }
}

var warn_deprecated_nested_proofs = CWarnings$ReactTemplate.create("deprecated-nested-proofs", "deprecated", /* None */0, (function () {
        return Pp$ReactTemplate.strbrk("Nested proofs are deprecated and will stop working in a future Coq version");
      }));

function collect_proof(keep, cur, hd, brkind, id) {
  stm_prerr_endline((function () {
          return "Collecting proof ending at " + Stateid$ReactTemplate.to_string(id);
        }));
  var no_name = "";
  var name = function (param) {
    if (param) {
      return Names$ReactTemplate.Id[/* to_string */7](param[0]);
    } else {
      return no_name;
    }
  };
  var is_defined_expr = function (param) {
    if (typeof param === "number") {
      return /* false */0;
    } else if (param.tag === 10) {
      var match = param[0];
      if (match && match[0] !== 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  };
  var is_defined = function (param) {
    var e = param[1][/* expr */4];
    if (is_defined_expr(Vernacprop$ReactTemplate.under_control(e))) {
      return 1 - Vernacprop$ReactTemplate.has_Fail(e);
    } else {
      return /* false */0;
    }
  };
  var proof_using_ast = function (param) {
    if (typeof param === "number" || !(param.tag === 80 && param[1])) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
  var proof_using_ast$1 = function (param) {
    if (param) {
      var v = param[0][1];
      if (proof_using_ast(Vernacprop$ReactTemplate.under_control(v[/* expr */4])) && !Vernacprop$ReactTemplate.has_Fail(v[/* expr */4])) {
        return /* Some */[v];
      } else {
        return /* None */0;
      }
    } else {
      return /* None */0;
    }
  };
  var has_proof_no_using = function (param) {
    if (typeof param === "number" || !(param.tag === 80 && !param[1])) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
  var has_proof_no_using$1 = function (param) {
    if (param) {
      var v = param[0][1];
      if (has_proof_no_using(Vernacprop$ReactTemplate.under_control(v[/* expr */4]))) {
        return 1 - Vernacprop$ReactTemplate.has_Fail(v[/* expr */4]);
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  };
  var too_complex_to_delegate = function (ast) {
    if (typeof ast === "number") {
      return may_pierce_opaque(ast);
    } else {
      switch (ast.tag | 0) {
        case 22 : 
        case 23 : 
        case 32 : 
        case 33 : 
        case 34 : 
        case 35 : 
            return /* true */1;
        default:
          return may_pierce_opaque(ast);
      }
    }
  };
  var parent = function (param) {
    if (param) {
      return param[0][0];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "stm.ml",
              2181,
              50
            ]
          ];
    }
  };
  var is_empty = function (param) {
    if (typeof param === "number") {
      return /* false */0;
    } else {
      var variant = param[0];
      if (variant !== 963342108) {
        if (variant !== 1044269748 || param[1][1]) {
          return /* false */0;
        } else {
          return /* true */1;
        }
      } else if (param[1][1]) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    }
  };
  var collect = function (_last, _accn, _id) {
    while(true) {
      var id = _id;
      var accn = _accn;
      var last = _last;
      var view = visit$1(id);
      var match = view[/* step */0];
      var exit = 0;
      var exit$1 = 0;
      var x;
      if (typeof match === "number") {
        exit = 1;
      } else {
        var variant = match[0];
        if (variant >= 3356251) {
          if (variant !== 781815138) {
            if (variant !== 884916592) {
              exit = 1;
            } else {
              return /* `Sync */[
                      926475899,
                      /* tuple */[
                        no_name,
                        /* Alias */884916592
                      ]
                    ];
            }
          } else {
            var match$1 = match[1][0];
            var hd$prime = match$1[1];
            var exit$2 = 0;
            var match$2 = match$1[3];
            if (match$2) {
              if (match$2[1]) {
                return /* `Sync */[
                        926475899,
                        /* tuple */[
                          no_name,
                          /* MutualProofs */-681057085
                        ]
                      ];
              } else {
                exit$2 = 3;
              }
            } else {
              exit$2 = 3;
            }
            if (exit$2 === 3) {
              if (match$1[2] !== 0) {
                return /* `Sync */[
                        926475899,
                        /* tuple */[
                          no_name,
                          /* Doesn'tGuaranteeOpacity */688719333
                        ]
                      ];
              } else {
                var ids = match$1[3];
                if (proof_using_ast$1(last) !== /* None */0) {
                  if (!(Curry._2(VCS_001[/* equal */1], hd, hd$prime) || Curry._2(VCS_001[/* equal */1], hd, edit_branch))) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "stm.ml",
                            2198,
                            8
                          ]
                        ];
                  }
                  var name$1 = name(ids);
                  return /* `ASync */[
                          608475964,
                          /* tuple */[
                            parent(last),
                            accn,
                            name$1,
                            delegate(name$1)
                          ]
                        ];
                } else if (has_proof_no_using$1(last) && !is_cached(/* None */0, parent(last), /* true */1) && is_vio_doc(/* () */0)) {
                  if (!(Curry._2(VCS_001[/* equal */1], hd, hd$prime) || Curry._2(VCS_001[/* equal */1], hd, edit_branch))) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "stm.ml",
                            2204,
                            8
                          ]
                        ];
                  }
                  var name$2 = name(ids);
                  return /* `MaybeASync */[
                          1044269748,
                          /* tuple */[
                            parent(last),
                            accn,
                            name$2,
                            delegate(name$2)
                          ]
                        ];
                } else {
                  if (!(Curry._2(VCS_001[/* equal */1], hd, hd$prime) || Curry._2(VCS_001[/* equal */1], hd, edit_branch))) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "stm.ml",
                            2214,
                            8
                          ]
                        ];
                  }
                  var name$3 = name(ids);
                  return /* `MaybeASync */[
                          1044269748,
                          /* tuple */[
                            parent(last),
                            accn,
                            name$3,
                            delegate(name$3)
                          ]
                        ];
                }
              }
            }
            
          }
        } else if (variant !== -417845577) {
          if (variant >= 3356250) {
            x = match[1][/* cast */2];
            exit$1 = 2;
          } else {
            exit = 1;
          }
        } else {
          var match$3 = match[1][0];
          if (match$3) {
            x = match$3[0];
            exit$1 = 2;
          } else {
            exit = 1;
          }
        }
      }
      if (exit$1 === 2) {
        if (too_complex_to_delegate(Vernacprop$ReactTemplate.under_control(x[/* expr */4]))) {
          return /* `Sync */[
                  926475899,
                  /* tuple */[
                    no_name,
                    /* Print */-608647155
                  ]
                ];
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        if (typeof match === "number") {
          return /* `Sync */[
                  926475899,
                  /* tuple */[
                    no_name,
                    /* Unknown */785140586
                  ]
                ];
        } else {
          var variant$1 = match[0];
          if (variant$1 !== -417845577) {
            if (variant$1 !== 3356250) {
              return /* `Sync */[
                      926475899,
                      /* tuple */[
                        no_name,
                        /* Unknown */785140586
                      ]
                    ];
            } else {
              _id = view[/* next */1];
              _accn = /* :: */[
                id,
                accn
              ];
              _last = /* Some */[/* tuple */[
                  id,
                  match[1][/* cast */2]
                ]];
              continue ;
              
            }
          } else {
            var match$4 = match[1][0];
            if (match$4) {
              _id = view[/* next */1];
              _accn = /* :: */[
                id,
                accn
              ];
              _last = /* Some */[/* tuple */[
                  id,
                  match$4[0]
                ]];
              continue ;
              
            } else {
              Curry._2(warn_deprecated_nested_proofs, /* None */0, /* () */0);
              return /* `Sync */[
                      926475899,
                      /* tuple */[
                        no_name,
                        /* NestedProof */232333293
                      ]
                    ];
            }
          }
        }
      }
      
    };
  };
  var make_sync = function (why, param) {
    if (param[0] !== 926475899) {
      return /* `Sync */[
              926475899,
              /* tuple */[
                param[1][2],
                why
              ]
            ];
    } else {
      return /* `Sync */[
              926475899,
              /* tuple */[
                param[1][0],
                why
              ]
            ];
    }
  };
  var check_policy = function (rc) {
    if (async_policy(/* () */0)) {
      return rc;
    } else {
      return make_sync(/* Policy */767184914, rc);
    }
  };
  var is_vernac_exact = function (param) {
    if (typeof param === "number" || param.tag !== 11) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
  var match = visit$1(id)[/* step */0];
  var x = cur[1];
  var exit = 0;
  var exit$1 = 0;
  if (typeof match === "number") {
    exit$1 = 2;
  } else if (match[0] !== 781815138) {
    exit$1 = 2;
  } else if (is_vernac_exact(Vernacprop$ReactTemplate.under_control(x[/* expr */4])) && !Vernacprop$ReactTemplate.has_Fail(x[/* expr */4])) {
    return /* `Sync */[
            926475899,
            /* tuple */[
              no_name,
              /* Immediate */-238816303
            ]
          ];
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    var match$1 = brkind[/* kind */0];
    if (typeof match$1 === "number") {
      exit = 1;
    } else if (match$1[0] !== 770176554) {
      exit = 1;
    } else {
      return check_policy(collect(/* Some */[cur], /* [] */0, id));
    }
  }
  if (exit === 1) {
    if (is_defined(cur)) {
      return /* `Sync */[
              926475899,
              /* tuple */[
                no_name,
                /* Transparent */116179762
              ]
            ];
    } else if (keep === /* VtDrop */2) {
      return /* `Sync */[
              926475899,
              /* tuple */[
                no_name,
                /* Aborted */-216426513
              ]
            ];
    } else {
      var rc = collect(/* Some */[cur], /* [] */0, id);
      if (is_empty(rc) || !((keep === /* VtKeep */0 || keep === /* VtKeepAsAxiom */1) && (!is_cached(/* None */0, id, /* true */1) || cur_opt[0][/* async_proofs_full */5]))) {
        return make_sync(/* AlreadyEvaluated */234250067, rc);
      } else {
        return check_policy(rc);
      }
    }
  }
  
}

function string_of_reason(param) {
  if (param >= 232333293) {
    if (param >= 688719333) {
      if (param >= 785140586) {
        if (param >= 884916592) {
          return "contains Undo-like command";
        } else {
          return "unsupported case";
        }
      } else if (param >= 767184914) {
        return "policy";
      } else {
        return "not a simple opaque lemma";
      }
    } else if (param >= 234250067) {
      return "proof already evaluated";
    } else {
      return "contains nested proof";
    }
  } else if (param >= -608647155) {
    if (param >= -216426513) {
      if (param >= 116179762) {
        return "non opaque";
      } else {
        return "aborted proof";
      }
    } else if (param >= -238816303) {
      return "proof term given explicitly";
    } else {
      return "contains Print-like command";
    }
  } else if (param >= -681057085) {
    return "block of mutually recursive proofs";
  } else {
    return "no 'Proof using..', no .aux file, inside a section";
  }
}

function log_processing_async(id, name) {
  var s = Curry._2(Printf.sprintf(/* Format */[
            /* String */Block.__(2, [
                /* No_padding */0,
                /* String_literal */Block.__(11, [
                    ": proof ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            ": asynch",
                            /* End_of_format */0
                          ])
                      ])
                  ])
              ]),
            "%s: proof %s: asynch"
          ]), Stateid$ReactTemplate.to_string(id), name);
  return stm_prerr_debug((function () {
                return "STM: " + s;
              }));
}

function log_processing_sync(id, name, reason) {
  var s = Curry._3(Printf.sprintf(/* Format */[
            /* String */Block.__(2, [
                /* No_padding */0,
                /* String_literal */Block.__(11, [
                    ": proof ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            ": synch (cause: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* ")" */41,
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ])
                  ])
              ]),
            "%s: proof %s: synch (cause: %s)"
          ]), Stateid$ReactTemplate.to_string(id), name, string_of_reason(reason));
  return stm_prerr_debug((function () {
                return "STM: " + s;
              }));
}

var wall_clock_last_fork = [0.0];

function known_state($staropt$star, cache, id) {
  var redefine_qed = $staropt$star ? $staropt$star[0] : /* false */0;
  var resilient_tactic = function (id, blockname, f) {
    if (cur_opt[0][/* async_proofs_tac_error_resilience */7] === /* None */870530776 || async_proofs_is_master(cur_opt[0]) && cur_opt[0][/* async_proofs_mode */3] === /* APoff */0) {
      return Curry._1(f, /* () */0);
    } else {
      try {
        return Curry._1(f, /* () */0);
      }
      catch (raw_e){
        var e = Js_exn.internalToOCamlException(raw_e);
        if (CErrors$ReactTemplate.noncritical(e)) {
          var ie = CErrors$ReactTemplate.push(e);
          var id$1 = id;
          var blockname$1 = blockname;
          var exn = ie;
          detect_proof_block(id$1, blockname$1);
          var boxes = box_of(id$1);
          var valid_boxes = CList$ReactTemplate.map_filter((function (param) {
                  if (param.tag) {
                    var decl = param[0];
                    if (Stateid$ReactTemplate.equal(decl[/* block_stop */1], id$1)) {
                      return /* Some */[/* tuple */[
                                decl,
                                param[1]
                              ]];
                    } else {
                      return /* None */0;
                    }
                  } else {
                    return /* None */0;
                  }
                }), boxes);
          if (List.length(valid_boxes) >= 2) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "stm.ml",
                    2285,
                    4
                  ]
                ];
          }
          if (valid_boxes) {
            var match = List.hd(valid_boxes);
            var name = match[1];
            try {
              var match$1 = List.assoc(name, proof_block_delimiters[0]);
              var match$2 = Curry._2(match$1[1], 0, match[0]);
              if (typeof match$2 === "number") {
                return Exninfo$ReactTemplate.iraise(exn);
              } else {
                var match$3 = match$2[1];
                var goals_to_admit = match$3[/* goals_to_admit */1];
                var tac = Proofview$ReactTemplate.Goal[/* nf_enter */8]((function (gl) {
                        if (CList$ReactTemplate.mem_f(Evar$ReactTemplate.equal, Proofview$ReactTemplate.Goal[/* goal */13](gl), goals_to_admit)) {
                          return Proofview$ReactTemplate.give_up;
                        } else {
                          return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                        }
                      }));
                var match$4 = get_info$1(match$3[/* base_state */0])[/* state */2];
                if (typeof match$4 === "number") {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "stm.ml",
                          2316,
                          18
                        ]
                      ];
                } else if (match$4.tag) {
                  Proof_global$ReactTemplate.unfreeze(match$4[0][/* proof */1]);
                  Proof_global$ReactTemplate.with_current_proof((function (_, p) {
                          Feedback$ReactTemplate.feedback(/* None */0, /* Some */[id$1], /* None */0, /* AddedAxiom */3);
                          return /* tuple */[
                                  Pfedit$ReactTemplate.solve(/* None */0, /* SelectAll */0, /* None */0, tac, p)[0],
                                  /* () */0
                                ];
                        }));
                  var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                  return Option$ReactTemplate.iter((function (expr) {
                                stm_vernac_interp(/* None */0, /* None */0, id$1, st, /* record */[
                                      /* verbose : true */1,
                                      /* loc : None */0,
                                      /* indentation */0,
                                      /* strlen */0,
                                      /* expr */expr
                                    ]);
                                return /* () */0;
                              }), match$3[/* recovery_command */2]);
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "stm.ml",
                          2316,
                          18
                        ]
                      ];
                }
              }
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["STM"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unknown proof block delimiter "), Pp$ReactTemplate.str(name)));
              } else {
                throw exn$1;
              }
            }
          } else {
            return Exninfo$ReactTemplate.iraise(exn);
          }
        } else {
          throw e;
        }
      }
    }
  };
  var resilient_command = function (f, x) {
    if (!cur_opt[0][/* async_proofs_cmd_error_resilience */8] || async_proofs_is_master(cur_opt[0]) && cur_opt[0][/* async_proofs_mode */3] === /* APoff */0) {
      return Curry._1(f, x);
    } else {
      try {
        return Curry._1(f, x);
      }
      catch (raw_e){
        var e = Js_exn.internalToOCamlException(raw_e);
        if (CErrors$ReactTemplate.noncritical(e)) {
          return /* () */0;
        } else {
          throw e;
        }
      }
    }
  };
  var pure_cherry_pick_non_pstate = function (safe_id, id) {
    return stm_purify((function (id) {
                  stm_prerr_endline((function () {
                          return "cherry-pick non pstate " + Stateid$ReactTemplate.to_string(id);
                        }));
                  reach(/* Some */[safe_id], /* None */0, /* None */0, id);
                  var st = Summary$ReactTemplate.freeze_summaries(/* No */17505);
                  var st$1 = Summary$ReactTemplate.remove_from_summary(st, Util$ReactTemplate.pi1(summary_pstate));
                  var st$2 = Summary$ReactTemplate.remove_from_summary(st$1, Util$ReactTemplate.pi2(summary_pstate));
                  var st$3 = Summary$ReactTemplate.remove_from_summary(st$2, Util$ReactTemplate.pi3(summary_pstate));
                  return /* tuple */[
                          st$3,
                          Lib$ReactTemplate.freeze(/* No */17505)
                        ];
                }), id);
  };
  var reach = function (safe_id, $staropt$star, $staropt$star$1, id) {
    var redefine_qed = $staropt$star ? $staropt$star[0] : /* false */0;
    var cache$1 = $staropt$star$1 ? $staropt$star$1[0] : cache;
    stm_prerr_endline((function () {
            return "reaching: " + Stateid$ReactTemplate.to_string(id);
          }));
    if (!redefine_qed && is_cached(/* Some */[cache$1], id, /* false */0)) {
      Curry._2(Hook$ReactTemplate.get(state_computed), id, /* true */1);
      stm_prerr_endline((function () {
              return "reached (cache)";
            }));
      return install_cached(id);
    } else {
      var view = visit$1(id);
      var match = view[/* step */0];
      var variant = match[0];
      var match$1;
      if (variant !== 3356250) {
        if (variant >= 781815138) {
          if (variant >= 884916592) {
            var id$1 = match[1][0];
            match$1 = /* tuple */[
              (function () {
                  reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                  return reach(/* None */0, /* None */0, /* None */0, id$1);
                }),
              cache$1,
              /* true */1
            ];
          } else {
            var match$2 = match[1];
            var match$3 = match$2[1];
            var x = match$2[0][0];
            if (match$3) {
              var prev = match$3[0];
              match$1 = /* tuple */[
                (function () {
                    reach(/* None */0, /* None */0, /* Some */[/* Shallow */841395124], prev);
                    reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                    try {
                      var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                      stm_vernac_interp(/* None */0, /* None */0, id, st, x);
                    }
                    catch (raw_e){
                      var e = Js_exn.internalToOCamlException(raw_e);
                      if (CErrors$ReactTemplate.noncritical(e)) {
                        var match = CErrors$ReactTemplate.push(e);
                        var info = Stateid$ReactTemplate.add(match[1], prev, id);
                        Exninfo$ReactTemplate.iraise(/* tuple */[
                              match[0],
                              info
                            ]);
                      } else {
                        throw e;
                      }
                    }
                    wall_clock_last_fork[0] = Unix.gettimeofday(/* () */0);
                    return /* () */0;
                  }),
                /* Yes */4448519,
                /* true */1
              ];
            } else {
              match$1 = /* tuple */[
                (function () {
                    resilient_command((function (eta) {
                            return reach(/* None */0, /* None */0, /* None */0, eta);
                          }), view[/* next */1]);
                    var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                    stm_vernac_interp(/* None */0, /* None */0, id, st, x);
                    wall_clock_last_fork[0] = Unix.gettimeofday(/* () */0);
                    return /* () */0;
                  }),
                /* Yes */4448519,
                /* true */1
              ];
            }
          }
        } else if (variant >= 4050672) {
          var match$4 = match[1];
          var qed = match$4[0];
          var keep = qed[/* keep */1];
          var x$1 = qed[/* qast */0];
          var eop = match$4[1];
          var brinfo = qed[/* brinfo */4];
          var aux = function (param) {
            var variant = param[0];
            if (variant !== 926475899) {
              if (variant >= 1044269748) {
                var match = param[1];
                var delegate = match[3];
                var name = match[2];
                var nodes = match[1];
                var start = match[0];
                return /* tuple */[
                        (function () {
                            reach(/* None */0, /* None */0, /* Some */[/* Shallow */841395124], start);
                            if (CList$ReactTemplate.is_empty(Environ$ReactTemplate.named_context(Global$ReactTemplate.env(/* () */0)))) {
                              return Curry._1(Util$ReactTemplate.pi1(aux(/* `ASync */[
                                                  608475964,
                                                  /* tuple */[
                                                    start,
                                                    nodes,
                                                    name,
                                                    delegate
                                                  ]
                                                ])), /* () */0);
                            } else {
                              return Curry._1(Util$ReactTemplate.pi1(aux(/* `Sync */[
                                                  926475899,
                                                  /* tuple */[
                                                    name,
                                                    /* NoPU_NoHint_NoES */-1021555955
                                                  ]
                                                ])), /* () */0);
                            }
                          }),
                        redefine_qed ? /* No */17505 : /* Yes */4448519,
                        /* true */1
                      ];
              } else {
                var match$1 = param[1];
                var delegate$1 = match$1[3];
                var name$1 = match$1[2];
                var nodes$1 = match$1[1];
                var block_start = match$1[0];
                return /* tuple */[
                        (function () {
                            if (!(keep === /* VtKeep */0 || keep === /* VtKeepAsAxiom */1)) {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "stm.ml",
                                      2431,
                                      16
                                    ]
                                  ];
                            }
                            var drop_pt = +(keep === /* VtKeepAsAxiom */1);
                            var exn_info = /* tuple */[
                              id,
                              eop
                            ];
                            var loc = x$1[/* loc */1];
                            log_processing_async(id, name$1);
                            create_proof_task_box(nodes$1, id, block_start);
                            var match = qed[/* fproof */2];
                            var match$1 = brinfo[/* kind */0];
                            if (typeof match$1 === "number") {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "stm.ml",
                                      2474,
                                      47
                                    ]
                                  ];
                            } else if (match$1[0] >= 770176554) {
                              if (match) {
                                if (redefine_qed !== /* true */1) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "stm.ml",
                                          2439,
                                          20
                                        ]
                                      ];
                                }
                                if (match$1[1][3] !== keep) {
                                  Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.strbrk("The command closing the proof changed. The kernel cannot take this into account and will " + ((
                                              keep ? "reject " : "not check "
                                            ) + ("the " + ((
                                                  keep ? "incomplete" : "new"
                                                ) + " proof. Reprocess the command declaring the proof's statement to avoid that.")))));
                                }
                                var match$2 = Curry._6(Slaves[/* build_proof */0], loc, drop_pt, exn_info, block_start, eop, name$1);
                                var fp = match$2[0];
                                Future$ReactTemplate.replace(match[0][0], fp);
                                qed[/* fproof */2] = /* Some */[/* tuple */[
                                    fp,
                                    match$2[1]
                                  ]];
                                install_cached(id);
                              } else {
                                throw [
                                      Caml_builtin_exceptions.assert_failure,
                                      [
                                        "stm.ml",
                                        2437,
                                        50
                                      ]
                                    ];
                              }
                            } else if (match) {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "stm.ml",
                                      2455,
                                      53
                                    ]
                                  ];
                            } else {
                              reach(/* None */0, /* None */0, /* Some */[/* Shallow */841395124], block_start);
                              var match$3 = delegate$1 ? Curry._6(Slaves[/* build_proof */0], loc, drop_pt, exn_info, block_start, eop, name$1) : /* tuple */[
                                  build_proof_here(loc, drop_pt, exn_info, eop),
                                  [/* false */0]
                                ];
                              var fp$1 = match$3[0];
                              qed[/* fproof */2] = /* Some */[/* tuple */[
                                  fp$1,
                                  match$3[1]
                                ]];
                              var proof = Proof_global$ReactTemplate.close_future_proof(id, fp$1);
                              if (!delegate$1) {
                                Future$ReactTemplate.compute(fp$1);
                              }
                              reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                              var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                              stm_vernac_interp(/* Some */[proof], /* None */0, id, st, x$1);
                              Feedback$ReactTemplate.feedback(/* None */0, /* Some */[id], /* None */0, /* Incomplete */1);
                            }
                            return Proof_global$ReactTemplate.discard_all(/* () */0);
                          }),
                        redefine_qed ? /* No */17505 : /* Yes */4448519,
                        /* true */1
                      ];
              }
            } else {
              var match$2 = param[1];
              var reason = match$2[1];
              var name$2 = match$2[0];
              if (reason !== -238816303) {
                return /* tuple */[
                        (function () {
                            log_processing_sync(id, name$2, reason);
                            reach(/* None */0, /* None */0, /* None */0, eop);
                            var proof;
                            switch (keep) {
                              case 0 : 
                                  proof = /* Some */[Proof_global$ReactTemplate.close_proof(/* false */0, (function (param) {
                                            return exn_on(id, eop, param);
                                          }))];
                                  break;
                              case 1 : 
                                  var fp = Future$ReactTemplate.from_val(/* None */0, /* tuple */[
                                        /* [] */0,
                                        UState$ReactTemplate.empty
                                      ]);
                                  qed[/* fproof */2] = /* Some */[/* tuple */[
                                      fp,
                                      [/* false */0]
                                    ]];
                                  proof = /* None */0;
                                  break;
                              case 2 : 
                                  proof = /* None */0;
                                  break;
                              
                            }
                            if (keep !== /* VtKeepAsAxiom */1) {
                              reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                            }
                            Unix.gettimeofday(/* () */0);
                            var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                            stm_vernac_interp(proof, /* None */0, id, st, x$1);
                            return Proof_global$ReactTemplate.discard_all(/* () */0);
                          }),
                        /* Yes */4448519,
                        /* true */1
                      ];
              } else {
                return /* tuple */[
                        (function () {
                            reach(/* None */0, /* None */0, /* None */0, eop);
                            var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                            stm_vernac_interp(/* None */0, /* None */0, id, st, x$1);
                            return Proof_global$ReactTemplate.discard_all(/* () */0);
                          }),
                        /* Yes */4448519,
                        /* true */1
                      ];
              }
            }
          };
          match$1 = aux(collect_proof(keep, /* tuple */[
                    view[/* next */1],
                    x$1
                  ], qed[/* brname */3], brinfo, eop));
        } else {
          var match$5 = match[1];
          var match$6 = match$5[0];
          if (match$6) {
            var x$2 = match$6[0];
            match$1 = /* tuple */[
              (function () {
                  reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                  var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                  stm_vernac_interp(/* None */0, /* None */0, id, st, x$2);
                  return update_global_env(/* () */0);
                }),
              cache$1,
              /* true */1
            ];
          } else {
            var origin = match$5[1];
            match$1 = /* tuple */[
              (function () {
                  reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                  var param = pure_cherry_pick_non_pstate(view[/* next */1], origin);
                  Summary$ReactTemplate.unfreeze_summaries(/* Some */[/* true */1], param[0]);
                  Lib$ReactTemplate.unfreeze(param[1]);
                  return update_global_env(/* () */0);
                }),
              cache$1,
              /* true */1
            ];
          }
        }
      } else {
        var match$7 = match[1];
        var exit = 0;
        var match$8 = match$7[/* cqueue */5];
        var cblock = match$7[/* cblock */4];
        var x$3 = match$7[/* cast */2];
        if (typeof match$8 === "number") {
          if (match$8 !== 330881650) {
            exit = 1;
          } else {
            match$1 = /* tuple */[
              (function () {
                  return reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                }),
              cache$1,
              /* true */1
            ];
          }
        } else {
          var variant$1 = match$8[0];
          if (variant$1 !== 211560315) {
            if (variant$1 !== 664893833) {
              exit = 1;
            } else {
              var cancel_switch = match$8[1];
              if (async_proofs_is_master(cur_opt[0])) {
                match$1 = /* tuple */[
                  (function () {
                      reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                      return Curry._4(Query[/* vernac_interp */1], cancel_switch, view[/* next */1], id, x$3);
                    }),
                  cache$1,
                  /* false */0
                ];
              } else {
                exit = 1;
              }
            }
          } else {
            var match$9 = match$8[1];
            var cancel_switch$1 = match$9[2];
            var $$abstract = match$9[1];
            var solve = match$9[0];
            match$1 = /* tuple */[
              (function () {
                  return resilient_tactic(id, cblock, (function () {
                                reach(/* None */0, /* None */0, /* Some */[/* Shallow */841395124], view[/* next */1]);
                                return Curry._7(Partac[/* vernac_interp */0], solve, $$abstract, cancel_switch$1, cur_opt[0][/* async_proofs_n_tacworkers */1], view[/* next */1], id, x$3);
                              }));
                }),
              cache$1,
              /* true */1
            ];
          }
        }
        if (exit === 1) {
          if (match$7[/* ctac */0] !== 0) {
            var cblock$1 = match$7[/* cblock */4];
            var x$4 = match$7[/* cast */2];
            var eff = match$7[/* ceff */1];
            match$1 = /* tuple */[
              (function () {
                  resilient_tactic(id, cblock$1, (function () {
                          reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                          var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                          stm_vernac_interp(/* None */0, /* None */0, id, st, x$4);
                          return /* () */0;
                        }));
                  if (eff) {
                    return update_global_env(/* () */0);
                  } else {
                    return 0;
                  }
                }),
              eff ? /* Yes */4448519 : cache$1,
              /* true */1
            ];
          } else {
            var x$5 = match$7[/* cast */2];
            var eff$1 = match$7[/* ceff */1];
            match$1 = /* tuple */[
              (function () {
                  var match = cur_opt[0][/* async_proofs_mode */3];
                  if (match !== 0) {
                    resilient_command((function (eta) {
                            return reach(/* None */0, /* None */0, /* None */0, eta);
                          }), view[/* next */1]);
                  } else {
                    reach(/* None */0, /* None */0, /* None */0, view[/* next */1]);
                  }
                  var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                  stm_vernac_interp(/* None */0, /* None */0, id, st, x$5);
                  if (eff$1) {
                    return update_global_env(/* () */0);
                  } else {
                    return 0;
                  }
                }),
              eff$1 ? /* Yes */4448519 : cache$1,
              /* true */1
            ];
          }
        }
        
      }
      var cache_step = Caml_obj.caml_equal(cur_opt[0][/* async_proofs_cache */2], /* Some */[/* Force */0]) ? /* Yes */4448519 : match$1[1];
      define(safe_id, /* Some */[redefine_qed], /* Some */[cache_step], /* Some */[match$1[2]], match$1[0], id);
      return stm_prerr_endline((function () {
                    return "reached: " + Stateid$ReactTemplate.to_string(id);
                  }));
    }
  };
  return reach(/* None */0, /* Some */[redefine_qed], /* None */0, id);
}

Caml_module.update_mod([[0]], Reach, /* module */[/* known_state */known_state]);

var TaskQueue = AsyncTaskQueue$ReactTemplate.MakeQueue([
        name,
        extra_env,
        request_of_task,
        task_match,
        use_response,
        on_marshal_error,
        on_task_cancellation_or_expiration_or_slave_death,
        forward_feedback$1,
        perform,
        name_of_task,
        name_of_request
      ])(/* module */[]);

var queue = [/* None */0];

function init$1() {
  if (async_proofs_is_master(cur_opt[0])) {
    queue[0] = /* Some */[Curry._1(TaskQueue[/* create */0], cur_opt[0][/* async_proofs_n_workers */0])];
    return /* () */0;
  } else {
    queue[0] = /* Some */[Curry._1(TaskQueue[/* create */0], 0)];
    return /* () */0;
  }
}

function check_task_aux(extra, name, l, i) {
  var match = List.nth(l, i);
  var drop = match[1];
  var match$1 = match[0];
  var r_name = match$1[/* name */5];
  var stop = match$1[/* stop */1];
  Flags$ReactTemplate.if_verbose((function (eta) {
          return Feedback$ReactTemplate.msg_info(/* None */0, eta);
        }), Pp$ReactTemplate.str(Curry._4(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "Checking task ",
                        /* Int */Block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* String_literal */Block.__(11, [
                                " (",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */Block.__(11, [
                                            ") of ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "Checking task %d (%s%s) of %s"
                  ]), i, r_name, extra, name)));
  vcs[0] = match$1[/* document */2];
  var aux = function (cur) {
    try {
      return aux(visit$1(cur)[/* next */1]);
    }
    catch (exn){
      if (exn === Expired) {
        return cur;
      } else {
        throw exn;
      }
    }
  };
  var start = aux(stop);
  try {
    Curry._3(Reach[/* known_state */0], /* None */0, /* No */17505, stop);
    if (drop) {
      Proof_global$ReactTemplate.return_proof(/* Some */[/* true */1], /* () */0);
      return /* OK_ADMITTED */-49431775;
    } else {
      Proof_global$ReactTemplate.set_terminator(Lemmas$ReactTemplate.standard_proof_terminator(/* [] */0, Lemmas$ReactTemplate.mk_hook((function (_, _$1) {
                      return /* () */0;
                    }))));
      var proof = Proof_global$ReactTemplate.close_proof(/* true */1, (function (x) {
              return x;
            }));
      Curry._3(Reach[/* known_state */0], /* None */0, /* No */17505, start);
      var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
      stm_vernac_interp(/* Some */[proof], /* None */0, stop, st, /* record */[
            /* verbose : false */0,
            /* loc */match$1[/* loc */3],
            /* indentation */0,
            /* strlen */0,
            /* expr : VernacExpr */Block.__(0, [
                /* [] */0,
                /* VernacEndProof */Block.__(10, [/* Proved */[
                      /* Opaque */0,
                      /* None */0
                    ]])
              ])
          ]);
      return /* `OK */[
              17692,
              proof
            ];
    }
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    var match$2 = CErrors$ReactTemplate.push(e);
    var info = match$2[1];
    var e$1 = match$2[0];
    try {
      var match$3 = Stateid$ReactTemplate.get(info);
      if (match$3) {
        var match$4 = visit$1(match$3[0][1]);
        var exit = 0;
        var loc;
        var match$5 = match$4[/* step */0];
        var exit$1 = 0;
        if (typeof match$5 === "number") {
          exit$1 = 2;
        } else {
          var variant = match$5[0];
          if (variant >= 3356251) {
            if (variant !== 4050672) {
              if (variant !== 781815138) {
                exit$1 = 2;
              } else {
                loc = match$5[1][0][0][/* loc */1];
                exit = 1;
              }
            } else {
              loc = match$5[1][0][/* qast */0][/* loc */1];
              exit = 1;
            }
          } else if (variant !== -417845577) {
            if (variant >= 3356250) {
              loc = match$5[1][/* cast */2][/* loc */1];
              exit = 1;
            } else {
              exit$1 = 2;
            }
          } else {
            var match$6 = match$5[1][0];
            if (match$6) {
              loc = match$6[0][/* loc */1];
              exit = 1;
            } else {
              exit$1 = 2;
            }
          }
        }
        if (exit$1 === 2) {
          Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("File "), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str(": proof of ")), Pp$ReactTemplate.str(r_name)), Pp$ReactTemplate.spc(/* () */0)), CErrors$ReactTemplate.iprint(/* tuple */[
                        e$1,
                        info
                      ])));
        }
        if (exit === 1) {
          var match$7 = Option$ReactTemplate.cata(Loc$ReactTemplate.unloc, /* tuple */[
                0,
                0
              ], loc);
          Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("File "), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str(": proof of ")), Pp$ReactTemplate.str(r_name)), Pp$ReactTemplate.str(": chars ")), Pp$ReactTemplate.$$int(match$7[0])), Pp$ReactTemplate.str("-")), Pp$ReactTemplate.$$int(match$7[1])), Pp$ReactTemplate.spc(/* () */0)), CErrors$ReactTemplate.iprint(/* tuple */[
                        e$1,
                        info
                      ])));
        }
        
      } else {
        Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("File "), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str(": proof of ")), Pp$ReactTemplate.str(r_name)), Pp$ReactTemplate.spc(/* () */0)), CErrors$ReactTemplate.iprint(/* tuple */[
                      e$1,
                      info
                    ])));
      }
    }
    catch (raw_e$1){
      var e$2 = Js_exn.internalToOCamlException(raw_e$1);
      Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("unable to print error message: "), Pp$ReactTemplate.str(Printexc.to_string(e$2))));
    }
    if (drop) {
      return /* ERROR_ADMITTED */516410133;
    } else {
      return /* ERROR */-250084440;
    }
  }
}

function check_task(name, l, i) {
  var match = check_task_aux("", name, l, i);
  if (typeof match === "number" && match !== -49431775) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function info_tasks(l) {
  return CList$ReactTemplate.map_i((function (i, param) {
                return /* tuple */[
                        param[0][/* name */5],
                        0.0001,
                        i
                      ];
              }), 0, l);
}

function set_perspective(idl) {
  perspective[0] = idl;
  Curry._1(TaskQueue[/* broadcast */8], Option$ReactTemplate.get(queue[0]));
  var overlap = function (s1, s2) {
    return List.exists((function (x) {
                  return CList$ReactTemplate.mem_f(Stateid$ReactTemplate.equal, x, s2);
                }), s1);
  };
  return Curry._2(TaskQueue[/* set_order */7], Option$ReactTemplate.get(queue[0]), (function (task1, task2) {
                if (!task1.tag && !task2.tag) {
                  var s1 = task1[0][/* t_states */4];
                  var s2 = task2[0][/* t_states */4];
                  var match = overlap(s1, idl);
                  var match$1 = overlap(s2, idl);
                  if (match !== 0) {
                    if (match$1 !== 0) {
                      return 0;
                    } else {
                      return -1;
                    }
                  } else if (match$1 !== 0) {
                    return 1;
                  } else {
                    return 0;
                  }
                } else {
                  return 0;
                }
              }));
}

function build_proof(loc, drop_pt, exn_info, block_start, block_stop, pname) {
  var valid = exn_info[1];
  var id = exn_info[0];
  var cancel_switch = [/* false */0];
  if (Curry._1(TaskQueue[/* n_workers */2], Option$ReactTemplate.get(queue[0]))) {
    var match = Future$ReactTemplate.create_delegate(/* None */0, pname, (function (param) {
            return exn_on(id, valid, param);
          }));
    var f = match[0];
    var t_uuid = Future$ReactTemplate.uuid(f);
    Feedback$ReactTemplate.feedback(/* None */0, /* None */0, /* None */0, /* InProgress */Block.__(1, [1]));
    var task = /* BuildProof */Block.__(0, [/* record */[
          /* t_exn_info */exn_info,
          /* t_start */block_start,
          /* t_stop */block_stop,
          /* t_drop */drop_pt,
          /* t_states */nodes_in_slice$1(block_start, block_stop),
          /* t_assign */match[1],
          /* t_loc */loc,
          /* t_uuid */t_uuid,
          /* t_name */pname
        ]]);
    Curry._3(TaskQueue[/* enqueue_task */3], Option$ReactTemplate.get(queue[0]), task, cancel_switch);
    return /* tuple */[
            f,
            cancel_switch
          ];
  } else if (is_vio_doc(/* () */0)) {
    var match$1 = Future$ReactTemplate.create_delegate(/* Some */[/* true */1], pname, (function (param) {
            return exn_on(id, valid, param);
          }));
    var f$1 = match$1[0];
    var t_uuid$1 = Future$ReactTemplate.uuid(f$1);
    var task$1 = /* BuildProof */Block.__(0, [/* record */[
          /* t_exn_info */exn_info,
          /* t_start */block_start,
          /* t_stop */block_stop,
          /* t_drop */drop_pt,
          /* t_states */nodes_in_slice$1(block_start, block_stop),
          /* t_assign */match$1[1],
          /* t_loc */loc,
          /* t_uuid */t_uuid$1,
          /* t_name */pname
        ]]);
    Curry._3(TaskQueue[/* enqueue_task */3], Option$ReactTemplate.get(queue[0]), task$1, cancel_switch);
    return /* tuple */[
            f$1,
            cancel_switch
          ];
  } else {
    return /* tuple */[
            build_proof_here(loc, drop_pt, exn_info, block_stop),
            cancel_switch
          ];
  }
}

function wait_all_done() {
  return Curry._1(TaskQueue[/* join */4], Option$ReactTemplate.get(queue[0]));
}

function cancel_worker(n) {
  return Curry._2(TaskQueue[/* cancel_worker */6], Option$ReactTemplate.get(queue[0]), n);
}

function dump_snapshot() {
  var tasks = Curry._1(TaskQueue[/* snapshot */9], Option$ReactTemplate.get(queue[0]));
  var reqs = CList$ReactTemplate.map_filter((function (x) {
          var match = request_of_task(/* Fresh */0, x);
          if (match) {
            var match$1 = match[0];
            if (match$1.tag) {
              return /* None */0;
            } else {
              return /* Some */[/* tuple */[
                        match$1[0],
                        match$1[1]
                      ]];
            }
          } else {
            return /* None */0;
          }
        }), tasks);
  stm_prerr_endline((function () {
          return Curry._1(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "dumping ",
                              /* Int */Block.__(4, [
                                  /* Int_d */0,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String_literal */Block.__(11, [
                                      " tasks\n",
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "dumping %d tasks\n"
                        ]), List.length(reqs));
        }));
  return reqs;
}

function reset_task_queue() {
  return Curry._1(TaskQueue[/* clear */10], Option$ReactTemplate.get(queue[0]));
}

Caml_module.update_mod([[
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]], Slaves, /* module */[
      /* build_proof */build_proof,
      /* wait_all_done */wait_all_done,
      /* init */init$1,
      /* dump_snapshot */dump_snapshot,
      /* check_task */check_task,
      /* info_tasks */info_tasks,
      /* cancel_worker */cancel_worker,
      /* reset_task_queue */reset_task_queue,
      /* set_perspective */set_perspective
    ]);

var TaskQueue$1 = AsyncTaskQueue$ReactTemplate.MakeQueue(TacTask)(/* module */[]);

function vernac_interp(solve, $$abstract, cancel_switch, nworkers, safe_id, id, param) {
  var strlen = param[/* strlen */3];
  var indentation = param[/* indentation */2];
  var loc = param[/* loc */1];
  var verbose = param[/* verbose */0];
  var e = param[/* expr */4];
  var find = function (_time, _batch, _fail, _e) {
    while(true) {
      var e = _e;
      var fail = _fail;
      var batch = _batch;
      var time = _time;
      switch (e.tag | 0) {
        case 1 : 
            _e = e[1][/* v */0];
            _batch = e[0];
            _time = /* true */1;
            continue ;
            case 2 : 
            _e = e[1][/* v */0];
            continue ;
            case 0 : 
        case 3 : 
            return /* tuple */[
                    e,
                    time,
                    batch,
                    fail
                  ];
        case 4 : 
            _e = e[0];
            _fail = /* true */1;
            continue ;
            
      }
    };
  };
  var match = find(/* false */0, /* false */0, /* false */0, e);
  var e$1 = match[0];
  var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
  return Vernacentries$ReactTemplate.with_fail(st, match[3], (function () {
                Curry._2(TaskQueue$1[/* with_n_workers */11], nworkers, (function (queue) {
                        return Proof_global$ReactTemplate.with_current_proof((function (_, p) {
                                      var match = Proof$ReactTemplate.proof(p);
                                      var res = CList$ReactTemplate.map_i((function (i, g) {
                                              var match = Future$ReactTemplate.create_delegate(/* None */0, Curry._1(Printf.sprintf(/* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "subgoal ",
                                                                /* Int */Block.__(4, [
                                                                    /* Int_d */0,
                                                                    /* No_padding */0,
                                                                    /* No_precision */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ]),
                                                            "subgoal %d"
                                                          ]), i), (function (param) {
                                                      return exn_on(id, safe_id, param);
                                                    }));
                                              var t_ast_001 = /* record */[
                                                /* verbose */verbose,
                                                /* loc */loc,
                                                /* indentation */indentation,
                                                /* strlen */strlen,
                                                /* expr */e$1
                                              ];
                                              var t_ast = /* tuple */[
                                                i,
                                                t_ast_001
                                              ];
                                              var t_name = Goal$ReactTemplate.uid(g);
                                              Curry._3(TaskQueue$1[/* enqueue_task */3], queue, /* record */[
                                                    /* t_state */safe_id,
                                                    /* t_state_fb */id,
                                                    /* t_assign */match[1],
                                                    /* t_ast */t_ast,
                                                    /* t_goal */g,
                                                    /* t_kill */(function () {
                                                        if (solve) {
                                                          return Curry._1(TaskQueue$1[/* cancel_all */5], queue);
                                                        } else {
                                                          return 0;
                                                        }
                                                      }),
                                                    /* t_name */t_name
                                                  ], cancel_switch);
                                              return /* tuple */[
                                                      g,
                                                      match[0]
                                                    ];
                                            }), 1, match[0]);
                                      Curry._1(TaskQueue$1[/* join */4], queue);
                                      var assign_tac = Proofview$ReactTemplate.Goal[/* nf_enter */8]((function (g) {
                                              var gid = Proofview$ReactTemplate.Goal[/* goal */13](g);
                                              var f;
                                              try {
                                                f = List.assoc(gid, res);
                                              }
                                              catch (exn){
                                                if (exn === Caml_builtin_exceptions.not_found) {
                                                  f = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Partac: wrong focus."));
                                                } else {
                                                  throw exn;
                                                }
                                              }
                                              if (Future$ReactTemplate.is_over(f)) {
                                                var match = Future$ReactTemplate.join(f);
                                                if (match) {
                                                  var match$1 = match[0];
                                                  var uc = match$1[1];
                                                  var pt = match$1[0];
                                                  var match$2 = Pfedit$ReactTemplate.get_current_context(/* () */0);
                                                  var env = match$2[1];
                                                  var sigma = match$2[0];
                                                  stm_pperr_endline((function () {
                                                          return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("g="), Pp$ReactTemplate.$$int(Evar$ReactTemplate.repr(gid))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("t=")), Printer$ReactTemplate.pr_constr_env(env, sigma, pt)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("uc=")), Termops$ReactTemplate.pr_evar_universe_context(uc)));
                                                        }));
                                                  return Curry._1($$abstract ? (function (param) {
                                                                  return Tactics$ReactTemplate.tclABSTRACT(/* None */0, /* None */0, param);
                                                                }) : (function (x) {
                                                                  return x;
                                                                }), Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.V82[/* tactic */0](/* None */0, (function (param) {
                                                                        return Refiner$ReactTemplate.tclPUSHEVARUNIVCONTEXT(uc, param);
                                                                      })), Tactics$ReactTemplate.exact_no_check(EConstr$ReactTemplate.of_constr(pt))));
                                                } else if (solve) {
                                                  return Tacticals$ReactTemplate.New[/* tclSOLVE */32](/* [] */0);
                                                } else {
                                                  return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                                                }
                                              } else if (solve) {
                                                return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("Interrupted by the failure of another goal"));
                                              } else {
                                                return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                                              }
                                            }));
                                      return Proof$ReactTemplate.run_tactic(Global$ReactTemplate.env(/* () */0), assign_tac, p);
                                    }));
                      }));
                return /* () */0;
              }));
}

Caml_module.update_mod([[0]], Partac, /* module */[/* vernac_interp */vernac_interp]);

var TaskQueue$2 = AsyncTaskQueue$ReactTemplate.MakeQueue(QueryTask)(/* module */[]);

var queue$1 = [/* None */0];

function vernac_interp$1(cancel_switch, prev, id, q) {
  if (Curry._1(TaskQueue$2[/* n_workers */2], Option$ReactTemplate.get(queue$1[0])) <= 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "stm.ml",
            2101,
            4
          ]
        ];
  }
  return Curry._3(TaskQueue$2[/* enqueue_task */3], Option$ReactTemplate.get(queue$1[0]), /* record */[
              /* t_where */prev,
              /* t_for */id,
              /* t_what */q
            ], cancel_switch);
}

function init$2() {
  queue$1[0] = /* Some */[Curry._1(TaskQueue$2[/* create */0], cur_opt[0][/* async_proofs_full */5] ? 1 : 0)];
  return /* () */0;
}

Caml_module.update_mod([[
        0,
        0
      ]], Query, /* module */[
      /* init */init$2,
      /* vernac_interp */vernac_interp$1
    ]);

function init_core() {
  if (cur_opt[0][/* async_proofs_mode */3] === /* APon */2) {
    init_state[0] = /* Some */[Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505)];
    return /* () */0;
  } else {
    return 0;
  }
}

function new_doc(param) {
  var doc_type = param[/* doc_type */0];
  var load_objs = function (libs) {
    var rq_file = function (param) {
      var exp = param[2];
      var eta = /* Qualid */Block.__(0, [Libnames$ReactTemplate.qualid_of_string(param[0])]);
      var mp = CAst$ReactTemplate.make(/* None */0, eta);
      var mfrom = Option$ReactTemplate.map((function (fr) {
              var eta = /* Qualid */Block.__(0, [Libnames$ReactTemplate.qualid_of_string(fr)]);
              return CAst$ReactTemplate.make(/* None */0, eta);
            }), param[1]);
      return Flags$ReactTemplate.silently((function (param) {
                    return Vernacentries$ReactTemplate.vernac_require(mfrom, exp, param);
                  }), /* :: */[
                  mp,
                  /* [] */0
                ]);
    };
    return List.iter(rq_file, List.rev(libs));
  };
  cur_opt[0] = param[/* stm_options */2];
  restore_root_state(/* () */0);
  var doc = init(doc_type, Stateid$ReactTemplate.initial);
  switch (doc_type.tag | 0) {
    case 0 : 
    case 1 : 
        throw [
              Caml_builtin_exceptions.match_failure,
              [
                "stm.ml",
                2609,
                2
              ]
            ];
    case 2 : 
        Safe_typing$ReactTemplate.allow_delayed_constants[0] = /* true */1;
        break;
    
  }
  load_objs(param[/* require_libs */1]);
  define(/* None */0, /* Some */[/* true */1], /* Some */[/* Yes */4448519], /* None */0, (function () {
          return /* () */0;
        }), Stateid$ReactTemplate.initial);
  record(/* () */0);
  Curry._1(Slaves[/* init */2], /* () */0);
  if (async_proofs_is_master(cur_opt[0])) {
    stm_prerr_endline((function () {
            return "Initializing workers";
          }));
    Curry._1(Query[/* init */0], /* () */0);
    var match = cur_opt[0][/* async_proofs_private_flags */4];
    var opts = match ? Curry._2(Str$ReactTemplate.split_delim, Str$ReactTemplate.regexp(","), match[0]) : /* [] */0;
    try {
      var env_opt = Str$ReactTemplate.regexp("^extra-env=");
      var env = List.find((function (s) {
              return Curry._3(Str$ReactTemplate.string_match, env_opt, s, 0);
            }), opts);
      async_proofs_workers_extra_env[0] = $$Array.of_list(Curry._2(Str$ReactTemplate.split_delim, Str$ReactTemplate.regexp(";"), Curry._3(Str$ReactTemplate.replace_first, env_opt, "", env)));
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      
    }
  }
  var head = Curry._1(current_branch, vcs[0]);
  return /* tuple */[
          doc,
          Curry._2(get_branch, vcs[0], head)[/* pos */2]
        ];
}

function observe(doc, id) {
  var vcs$1 = vcs[0];
  try {
    Curry._3(Reach[/* known_state */0], /* None */0, is_interactive(/* () */0), id);
    print(/* None */0, /* () */0);
    return doc;
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    var e$1 = CErrors$ReactTemplate.push(e);
    print(/* None */0, /* () */0);
    vcs[0] = vcs$1;
    return Exninfo$ReactTemplate.iraise(e$1);
  }
}

function finish(doc) {
  var head = Curry._1(current_branch, vcs[0]);
  var doc$1 = observe(doc, Curry._2(get_branch, vcs[0], head)[/* pos */2]);
  print(/* None */0, /* () */0);
  var match = Curry._2(get_branch, vcs[0], head);
  var match$1 = match[/* kind */0];
  if (typeof match$1 !== "number") {
    var variant = match$1[0];
    if (variant !== -608348572 && variant !== 770176554) {
      
    } else {
      Proof_global$ReactTemplate.activate_proof_mode(match$1[1][0]);
    }
  }
  return doc$1;
}

function wait(doc) {
  var doc$1 = finish(doc);
  Curry._1(Slaves[/* wait_all_done */1], /* () */0);
  print(/* None */0, /* () */0);
  return doc$1;
}

function join_admitted_proofs(_id) {
  while(true) {
    var id = _id;
    if (Stateid$ReactTemplate.equal(id, Stateid$ReactTemplate.initial)) {
      return /* () */0;
    } else {
      var view = visit$1(id);
      var match = view[/* step */0];
      if (typeof match === "number") {
        _id = view[/* next */1];
        continue ;
        
      } else if (match[0] !== 4050672) {
        _id = view[/* next */1];
        continue ;
        
      } else {
        var match$1 = match[1][0];
        if (match$1[/* keep */1] !== 1) {
          _id = view[/* next */1];
          continue ;
          
        } else {
          var match$2 = match$1[/* fproof */2];
          if (match$2) {
            Future$ReactTemplate.force(match$2[0][0]);
            _id = view[/* next */1];
            continue ;
            
          } else {
            _id = view[/* next */1];
            continue ;
            
          }
        }
      }
    }
  };
}

function join(doc) {
  var doc$1 = wait(doc);
  stm_prerr_endline((function () {
          return "Joining the environment";
        }));
  Global$ReactTemplate.join_safe_environment(/* None */0, /* () */0);
  stm_prerr_endline((function () {
          return "Joining Admitted proofs";
        }));
  var head = Curry._1(current_branch, vcs[0]);
  join_admitted_proofs(Curry._2(get_branch, vcs[0], head)[/* pos */2]);
  print(/* None */0, /* () */0);
  return doc$1;
}

function check_task$1(name, param, i) {
  RemoteCounter$ReactTemplate.restore(param[1]);
  var vcs$1 = vcs[0];
  try {
    var rc = stm_purify(Curry._2(Slaves[/* check_task */4], name, param[0]), i);
    vcs[0] = vcs$1;
    return rc;
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      vcs[0] = vcs$1;
      return /* false */0;
    } else {
      throw e;
    }
  }
}

function info_tasks$1(param) {
  return Curry._1(Slaves[/* info_tasks */5], param[0]);
}

function merge_proof_branch(valid, id, qast, keep, brname) {
  var brinfo = Curry._2(get_branch, vcs[0], brname);
  var qed = function (fproof) {
    return /* record */[
            /* qast */qast,
            /* keep */keep,
            /* fproof */fproof,
            /* brname */brname,
            /* brinfo */brinfo
          ];
  };
  var match = brinfo[/* kind */0];
  if (typeof match === "number") {
    return Exninfo$ReactTemplate.iraise(exn_on(Stateid$ReactTemplate.dummy, valid, /* tuple */[
                    Proof_global$ReactTemplate.NoCurrentProof,
                    Exninfo$ReactTemplate.$$null
                  ]));
  } else if (match[0] >= 770176554) {
    var match$1 = match[1];
    var qed_id = match$1[1];
    var match$2 = visit$1(qed_id);
    var match$3 = match$2[/* step */0];
    var ofp;
    if (typeof match$3 === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "stm.ml",
              2744,
              15
            ]
          ];
    } else if (match$3[0] !== 4050672) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "stm.ml",
              2744,
              15
            ]
          ];
    } else {
      ofp = match$3[1][0][/* fproof */2];
    }
    rewrite_merge$1(qed_id, /* Qed */Block.__(2, [qed(ofp)]), match$1[2], brname);
    delete_branch$1(brname);
    gc$1(/* () */0);
    Curry._3(Reach[/* known_state */0], /* Some */[/* true */1], /* No */17505, qed_id);
    checkout$1(VCS_001[/* master */4]);
    return /* `Unfocus */[
            -831816001,
            qed_id
          ];
  } else {
    checkout$1(VCS_001[/* master */4]);
    var id$1 = new_node(id, /* () */0);
    merge$1(id$1, /* Qed */Block.__(2, [/* record */[
              /* qast */qast,
              /* keep */keep,
              /* fproof : None */0,
              /* brname */brname,
              /* brinfo */brinfo
            ]]), /* None */0, brname);
    delete_branch$1(brname);
    propagate_sideff(/* CherryPickEnv */0);
    return /* Ok */17724;
  }
}

var reset_task_queue$1 = Slaves[/* reset_task_queue */7];

function process_back_meta_command(part_of_script, newtip, head, oid, aast, w) {
  if (part_of_script !== 0) {
    var id = new_node(/* Some */[newtip], /* () */0);
    var match = branches_of(oid);
    var others = match[/* others */1];
    var mine = match[/* mine */0];
    var valid = Curry._2(get_branch, vcs[0], head)[/* pos */2];
    List.iter((function (branch) {
            if (List.mem_assoc(branch, /* :: */[
                    mine,
                    others
                  ])) {
              return 0;
            } else {
              merge_proof_branch(valid, /* None */0, aast, /* VtDrop */2, branch);
              return /* () */0;
            }
          }), Curry._1(branches, vcs[0]));
    checkout_shallowest_proof_branch(/* () */0);
    var head$1 = Curry._1(current_branch, vcs[0]);
    List.iter((function (b) {
            if (Curry._2(VCS_001[/* equal */1], b, head$1)) {
              return 0;
            } else {
              checkout$1(b);
              return commit$1(new_node(/* None */0, /* () */0), /* Alias */Block.__(4, [/* tuple */[
                              oid,
                              aast
                            ]]));
            }
          }), Curry._1(branches, vcs[0]));
    checkout_shallowest_proof_branch(/* () */0);
    commit$1(id, /* Alias */Block.__(4, [/* tuple */[
              oid,
              aast
            ]]));
    record(/* () */0);
    if (!w) {
      finish(0);
    }
    return /* Ok */17724;
  } else if (w !== 0) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("undo classifier: VtMeta + VtLater must imply part_of_script."));
  } else {
    stm_prerr_endline((function () {
            return "undo to state " + Stateid$ReactTemplate.to_string(oid);
          }));
    backto(oid);
    checkout_shallowest_proof_branch(/* () */0);
    Curry._3(Reach[/* known_state */0], /* None */0, is_interactive(/* () */0), oid);
    return /* Ok */17724;
  }
}

function process_transaction($staropt$star, $staropt$star$1, x, c) {
  var expr = x[/* expr */4];
  var newtip = $staropt$star ? $staropt$star[0] : Curry._1(Stateid$ReactTemplate.fresh, /* () */0);
  var part_of_script = $staropt$star$1 ? $staropt$star$1[0] : /* true */1;
  stm_pperr_endline((function () {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{{{ processing: "), pr_ast(x));
        }));
  var vcs$1 = vcs[0];
  try {
    var head = Curry._1(current_branch, vcs[0]);
    checkout$1(head);
    stm_prerr_endline((function () {
            return "  classified as: " + Vernac_classifier$ReactTemplate.string_of_vernac_classification(c);
          }));
    var match = c[0];
    var rc;
    if (typeof match === "number") {
      if (match) {
        if (Caml_obj.caml_equal(Vernacprop$ReactTemplate.under_control(expr), /* VernacToplevelControl */Block.__(82, [CErrors$ReactTemplate.Drop]))) {
          var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
          stm_vernac_interp(/* None */0, /* None */0, Curry._2(get_branch, vcs[0], head)[/* pos */2], st, x);
          rc = /* Ok */17724;
        } else if (c[1] !== 0) {
          rc = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("classifier: VtUnknown must imply VtNow."));
        } else {
          var in_proof = 1 - Curry._2(VCS_001[/* equal */1], head, VCS_001[/* master */4]);
          var id = new_node(/* Some */[newtip], /* () */0);
          var head_id = Curry._2(get_branch, vcs[0], head)[/* pos */2];
          Curry._3(Reach[/* known_state */0], /* None */0, /* Yes */4448519, head_id);
          var step = function () {
            checkout$1(VCS_001[/* master */4]);
            var mid = Curry._2(get_branch, vcs[0], VCS_001[/* master */4])[/* pos */2];
            Curry._3(Reach[/* known_state */0], /* None */0, is_interactive(/* () */0), mid);
            var st = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
            stm_vernac_interp(/* None */0, /* None */0, id, st, x);
            if (!in_proof && Proof_global$ReactTemplate.there_are_pending_proofs(/* () */0)) {
              var bname = mk_branch_name(x);
              var opacity_of_produced_term = function (param) {
                if (typeof param === "number" || !(param.tag === 28 && !(param[0] !== 0 || param[3]))) {
                  return /* Doesn'tGuaranteeOpacity */1;
                } else {
                  return /* GuaranteesOpacity */0;
                }
              };
              commit$1(id, /* Fork */Block.__(1, [/* tuple */[
                        x,
                        bname,
                        opacity_of_produced_term(Vernacprop$ReactTemplate.under_control(x[/* expr */4])),
                        /* [] */0
                      ]]));
              var proof_mode = Proof_global$ReactTemplate.get_default_proof_mode_name(/* () */0);
              branch$1(/* None */0, /* None */0, bname, /* `Proof */[
                    -608348572,
                    /* tuple */[
                      proof_mode,
                      proof_nesting(vcs[0]) + 1 | 0
                    ]
                  ]);
              return Proof_global$ReactTemplate.activate_proof_mode(proof_mode);
            } else {
              commit$1(id, mkTransCmd(x, /* [] */0, in_proof, /* MainQueue */425801336));
              propagate_sideff(/* ReplayCommand */[x]);
              return checkout_shallowest_proof_branch(/* () */0);
            }
          };
          define(/* Some */[head_id], /* None */0, /* Some */[/* Yes */4448519], /* None */0, step, id);
          record(/* () */0);
          rc = /* Ok */17724;
        }
      } else {
        var match$1 = undo_vernac_classifier(expr);
        rc = process_back_meta_command(part_of_script, newtip, head, match$1[0], x, match$1[1]);
      }
    } else {
      switch (match.tag | 0) {
        case 0 : 
            var match$2 = match[0];
            var names = match$2[2];
            var guarantee = match$2[1];
            var mode = match$2[0];
            var id$1 = new_node(/* Some */[newtip], /* () */0);
            var bname = mk_branch_name(x);
            checkout$1(VCS_001[/* master */4]);
            if (Curry._2(VCS_001[/* equal */1], head, VCS_001[/* master */4])) {
              commit$1(id$1, /* Fork */Block.__(1, [/* tuple */[
                        x,
                        bname,
                        guarantee,
                        names
                      ]]));
              branch$1(/* None */0, /* None */0, bname, /* `Proof */[
                    -608348572,
                    /* tuple */[
                      mode,
                      proof_nesting(vcs[0]) + 1 | 0
                    ]
                  ]);
            } else {
              branch$1(/* None */0, /* None */0, bname, /* `Proof */[
                    -608348572,
                    /* tuple */[
                      mode,
                      proof_nesting(vcs[0]) + 1 | 0
                    ]
                  ]);
              merge$1(id$1, /* Fork */Block.__(1, [/* tuple */[
                        x,
                        bname,
                        guarantee,
                        names
                      ]]), /* None */0, head);
            }
            Proof_global$ReactTemplate.activate_proof_mode(mode);
            record(/* () */0);
            if (!c[1]) {
              finish(0);
            }
            rc = /* Ok */17724;
            break;
        case 1 : 
            var in_proof$1 = 1 - Curry._2(VCS_001[/* equal */1], head, VCS_001[/* master */4]);
            var id$2 = new_node(/* Some */[newtip], /* () */0);
            checkout$1(VCS_001[/* master */4]);
            commit$1(id$2, mkTransCmd(x, match[0], in_proof$1, /* MainQueue */425801336));
            var match$3 = Vernacprop$ReactTemplate.under_control(x[/* expr */4]);
            var action;
            action = typeof match$3 === "number" ? /* ReplayCommand */[x] : (
                match$3.tag === 8 ? (
                    match$3[2].tag ? /* CherryPickEnv */0 : /* ReplayCommand */[x]
                  ) : /* ReplayCommand */[x]
              );
            propagate_sideff(action);
            checkout_shallowest_proof_branch(/* () */0);
            record(/* () */0);
            if (!c[1]) {
              finish(0);
            }
            rc = /* Ok */17724;
            break;
        case 2 : 
            var valid = Curry._2(get_branch, vcs[0], head)[/* pos */2];
            var rc$1 = merge_proof_branch(valid, /* Some */[newtip], x, match[0], head);
            checkout_shallowest_proof_branch(/* () */0);
            record(/* () */0);
            if (!c[1]) {
              finish(0);
            }
            rc = rc$1;
            break;
        case 3 : 
            var match$4 = match[0];
            var parallel = match$4[/* parallel */0];
            var id$3 = new_node(/* Some */[newtip], /* () */0);
            var queue;
            if (typeof parallel === "number") {
              queue = /* MainQueue */425801336;
            } else {
              var match$5 = parallel[1];
              queue = /* `TacQueue */[
                211560315,
                /* tuple */[
                  match$5[0],
                  match$5[1],
                  [/* false */0]
                ]
              ];
            }
            commit$1(id$3, mkTransTac(x, match$4[/* proof_block_detection */1], queue));
            record(/* () */0);
            if (!c[1]) {
              finish(0);
            }
            rc = /* Ok */17724;
            break;
        case 4 : 
            var mode$1 = match[0];
            if (c[1] !== 0) {
              rc = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("VtProofMode must be executed VtNow."));
            } else {
              var id$4 = new_node(/* Some */[newtip], /* () */0);
              commit$1(id$4, mkTransCmd(x, /* [] */0, /* false */0, /* MainQueue */425801336));
              List.iter((function (bn) {
                      var match = Curry._2(get_branch, vcs[0], bn);
                      var match$1 = match[/* kind */0];
                      if (typeof match$1 === "number") {
                        return /* () */0;
                      } else if (match$1[0] >= 770176554) {
                        var match$2 = match$1[1];
                        delete_branch$1(bn);
                        return branch$1(/* Some */[match[/* root */1]], /* Some */[match[/* pos */2]], bn, /* `Edit */[
                                    770176554,
                                    /* tuple */[
                                      mode$1,
                                      match$2[1],
                                      match$2[2],
                                      match$2[3],
                                      match$2[4]
                                    ]
                                  ]);
                      } else {
                        delete_branch$1(bn);
                        return branch$1(/* Some */[match[/* root */1]], /* Some */[match[/* pos */2]], bn, /* `Proof */[
                                    -608348572,
                                    /* tuple */[
                                      mode$1,
                                      match$1[1][1]
                                    ]
                                  ]);
                      }
                    }), Curry._1(branches, vcs[0]));
              checkout_shallowest_proof_branch(/* () */0);
              record(/* () */0);
              finish(0);
              rc = /* Ok */17724;
            }
            break;
        case 5 : 
            if (match[0] !== 0) {
              var id$5 = new_node(/* Some */[newtip], /* () */0);
              var queue$1 = cur_opt[0][/* async_proofs_full */5] ? /* `QueryQueue */[
                  664893833,
                  [/* false */0]
                ] : (
                  is_vio_doc(/* () */0) && Curry._2(get_branch, vcs[0], head)[/* kind */0] === /* Master */-273353534 && may_pierce_opaque(Vernacprop$ReactTemplate.under_control(x[/* expr */4])) ? /* SkipQueue */330881650 : /* MainQueue */425801336
                );
              commit$1(id$5, mkTransCmd(x, /* [] */0, /* false */0, queue$1));
              record(/* () */0);
              if (!c[1]) {
                finish(0);
              }
              rc = /* Ok */17724;
            } else if (c[1] !== 0) {
              rc = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("classifier: VtQuery + VtLater must imply part_of_script."));
            } else {
              var head$1 = Curry._1(current_branch, vcs[0]);
              var query_sid = Curry._2(get_branch, vcs[0], head$1)[/* pos */2];
              try {
                var st$1 = Vernacstate$ReactTemplate.freeze_interp_state(/* No */17505);
                stm_vernac_interp(/* None */0, /* Some */[match[1]], query_sid, st$1, x);
              }
              catch (raw_e){
                var e = Js_exn.internalToOCamlException(raw_e);
                var e$1 = CErrors$ReactTemplate.push(e);
                Exninfo$ReactTemplate.iraise(exn_on(query_sid, Stateid$ReactTemplate.dummy, e$1));
              }
              rc = /* Ok */17724;
            }
            break;
        
      }
    }
    var pr_rc = function (rc) {
      if (rc !== 17724) {
        return Pp$ReactTemplate.str("unfocus");
      } else {
        var head = Curry._1(current_branch, vcs[0]);
        return Pp$ReactTemplate.seq(/* :: */[
                    Pp$ReactTemplate.str("newtip ("),
                    /* :: */[
                      Pp$ReactTemplate.str(Stateid$ReactTemplate.to_string(Curry._2(get_branch, vcs[0], head)[/* pos */2])),
                      /* :: */[
                        Pp$ReactTemplate.str(")"),
                        /* [] */0
                      ]
                    ]
                  ]);
      }
    };
    stm_pperr_endline((function () {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("processed with "), pr_rc(rc)), Pp$ReactTemplate.str(" }}}"));
          }));
    print(/* None */0, /* () */0);
    return rc;
  }
  catch (raw_e$1){
    var e$2 = Js_exn.internalToOCamlException(raw_e$1);
    var e$3 = CErrors$ReactTemplate.push(e$2);
    var param = e$3;
    var vcs$2 = vcs$1;
    var info = param[1];
    var e$4 = param[0];
    if (Caml_obj.caml_equal(e$4, CErrors$ReactTemplate.Drop)) {
      return Exninfo$ReactTemplate.iraise(/* tuple */[
                  e$4,
                  info
                ]);
    } else {
      var match$6 = Stateid$ReactTemplate.get(info);
      if (match$6) {
        var id$6 = match$6[0][1];
        stm_prerr_endline((function () {
                return "Failed at state " + Stateid$ReactTemplate.to_string(id$6);
              }));
        vcs[0] = vcs$2;
        print(/* None */0, /* () */0);
        return Exninfo$ReactTemplate.iraise(/* tuple */[
                    e$4,
                    info
                  ]);
      } else {
        vcs[0] = vcs$2;
        print(/* None */0, /* () */0);
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("error with no safe_id attached:"), Pp$ReactTemplate.spc(/* () */0)), CErrors$ReactTemplate.iprint_no_report(/* tuple */[
                                e$4,
                                info
                              ])), Pp$ReactTemplate.str(".")));
      }
    }
  }
}

function get_ast(_, id) {
  var match = visit$1(id);
  var match$1 = match[/* step */0];
  if (typeof match$1 === "number") {
    return /* None */0;
  } else {
    var variant = match$1[0];
    if (variant >= 3356251) {
      if (variant !== 4050672) {
        if (variant !== 781815138) {
          return /* None */0;
        } else {
          var match$2 = match$1[1][0][0];
          var expr = match$2[/* expr */4];
          return /* Some */[Loc$ReactTemplate.tag(match$2[/* loc */1], expr)];
        }
      } else {
        var match$3 = match$1[1][0][/* qast */0];
        var expr$1 = match$3[/* expr */4];
        return /* Some */[Loc$ReactTemplate.tag(match$3[/* loc */1], expr$1)];
      }
    } else if (variant !== -417845577) {
      if (variant >= 3356250) {
        var match$4 = match$1[1][/* cast */2];
        var expr$2 = match$4[/* expr */4];
        return /* Some */[Loc$ReactTemplate.tag(match$4[/* loc */1], expr$2)];
      } else {
        return /* None */0;
      }
    } else {
      var match$5 = match$1[1][0];
      if (match$5) {
        var match$6 = match$5[0];
        var expr$3 = match$6[/* expr */4];
        return /* Some */[Loc$ReactTemplate.tag(match$6[/* loc */1], expr$3)];
      } else {
        return /* None */0;
      }
    }
  }
}

function stop_worker(n) {
  return Curry._1(Slaves[/* cancel_worker */6], n);
}

var End_of_input = Caml_exceptions.create("Stm-ReactTemplate.End_of_input");

function parse_sentence(_, sid, pa) {
  var head = Curry._1(current_branch, vcs[0]);
  var cur_tip = Curry._2(get_branch, vcs[0], head)[/* pos */2];
  var real_tip = cur_id[0];
  if (!Stateid$ReactTemplate.equal(sid, cur_tip)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Stm.parse_sentence"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Currently, the parsing api only supports parsing at the tip of the document."), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("You wanted to parse at: ")), Pp$ReactTemplate.str(Stateid$ReactTemplate.to_string(sid))), Pp$ReactTemplate.str(" but the current tip is: ")), Pp$ReactTemplate.str(Stateid$ReactTemplate.to_string(cur_tip))));
  }
  if (!Stateid$ReactTemplate.equal(sid, real_tip) && Flags$ReactTemplate.debug[0] && stm_debug[0]) {
    Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Warning, the real tip doesn't match the current tip."), Pp$ReactTemplate.str("You wanted to parse at: ")), Pp$ReactTemplate.str(Stateid$ReactTemplate.to_string(sid))), Pp$ReactTemplate.str(" but the real tip is: ")), Pp$ReactTemplate.str(Stateid$ReactTemplate.to_string(real_tip))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("This is usually due to use of Stm.observe to evaluate a state different than the tip. ")), Pp$ReactTemplate.str("All is good if not parsing changes occur between the two states, however if they do, a problem might occur.")));
  }
  return Flags$ReactTemplate.with_option(Flags$ReactTemplate.we_are_parsing, (function () {
                try {
                  var match = Pcoq$ReactTemplate.Gram[/* entry_parse */10](Pcoq$ReactTemplate.main_entry, pa);
                  if (match) {
                    var match$1 = match[0];
                    return CAst$ReactTemplate.make(/* Some */[match$1[0]], match$1[1]);
                  } else {
                    throw End_of_input;
                  }
                }
                catch (raw_e){
                  var e = Js_exn.internalToOCamlException(raw_e);
                  if (CErrors$ReactTemplate.noncritical(e)) {
                    var match$2 = CErrors$ReactTemplate.push(e);
                    return Exninfo$ReactTemplate.iraise(/* tuple */[
                                match$2[0],
                                match$2[1]
                              ]);
                  } else {
                    throw e;
                  }
                }
              }), /* () */0);
}

function ind_len_loc_of_id(sid) {
  if (Stateid$ReactTemplate.equal(sid, Stateid$ReactTemplate.initial)) {
    return /* None */0;
  } else {
    var match = visit$1(sid)[/* step */0];
    if (typeof match === "number") {
      return /* None */0;
    } else if (match[0] !== 3356250) {
      return /* None */0;
    } else {
      var match$1 = match[1];
      if (match$1[/* ctac */0] !== 0) {
        var match$2 = match$1[/* cast */2];
        return /* Some */[/* tuple */[
                  match$2[/* indentation */2],
                  match$2[/* strlen */3],
                  match$2[/* loc */1]
                ]];
      } else {
        return /* None */0;
      }
    }
  }
}

function compute_indentation(loc, sid) {
  return Option$ReactTemplate.cata((function (loc) {
                var len = loc[/* ep */6] - loc[/* bp */5] | 0;
                var match = ind_len_loc_of_id(sid);
                var prev_indent;
                if (match) {
                  var match$1 = match[0];
                  prev_indent = match$1[0] + match$1[1] | 0;
                } else {
                  prev_indent = 0;
                }
                var eff_indent = loc[/* bp */5] - loc[/* bol_pos */2] | 0;
                if (loc[/* bol_pos */2]) {
                  return /* tuple */[
                          eff_indent,
                          len
                        ];
                } else {
                  return /* tuple */[
                          eff_indent + prev_indent | 0,
                          len
                        ];
                }
              }), /* tuple */[
              0,
              0
            ], loc);
}

function add(doc, ontop, newtip, verb, param) {
  var loc = param[/* loc */1];
  var ast = param[/* v */0];
  var head = Curry._1(current_branch, vcs[0]);
  var cur_tip = Curry._2(get_branch, vcs[0], head)[/* pos */2];
  if (!Stateid$ReactTemplate.equal(ontop, cur_tip)) {
    CErrors$ReactTemplate.user_err(loc, /* Some */["Stm.add"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Stm.add called for a different state ("), Pp$ReactTemplate.str(Stateid$ReactTemplate.to_string(ontop))), Pp$ReactTemplate.str(") than the tip: ")), Pp$ReactTemplate.str(Stateid$ReactTemplate.to_string(cur_tip))), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("This is not supported yet, sorry.")));
  }
  var match = compute_indentation(loc, ontop);
  CWarnings$ReactTemplate.set_current_loc(loc);
  var clas = Vernac_classifier$ReactTemplate.classify_vernac(ast);
  var aast = /* record */[
    /* verbose */verb,
    /* loc */loc,
    /* indentation */match[0],
    /* strlen */match[1],
    /* expr */ast
  ];
  var match$1 = process_transaction(newtip, /* None */0, aast, clas);
  if (typeof match$1 === "number") {
    var head$1 = Curry._1(current_branch, vcs[0]);
    return /* tuple */[
            doc,
            Curry._2(get_branch, vcs[0], head$1)[/* pos */2],
            /* NewTip */641153275
          ];
  } else {
    var head$2 = Curry._1(current_branch, vcs[0]);
    return /* tuple */[
            doc,
            match$1[1],
            /* `Unfocus */[
              -831816001,
              Curry._2(get_branch, vcs[0], head$2)[/* pos */2]
            ]
          ];
  }
}

function set_perspective$1(_, id_list) {
  return Curry._1(Slaves[/* set_perspective */8], id_list);
}

function query(doc, at, route, s) {
  return stm_purify((function (s) {
                if (Stateid$ReactTemplate.equal(at, Stateid$ReactTemplate.dummy)) {
                  finish(0);
                } else {
                  Curry._3(Reach[/* known_state */0], /* None */0, /* Yes */4448519, at);
                }
                try {
                  while(true) {
                    var match = parse_sentence(doc, at, s);
                    var loc = match[/* loc */1];
                    var ast = match[/* v */0];
                    var match$1 = compute_indentation(loc, at);
                    CWarnings$ReactTemplate.set_current_loc(loc);
                    var clas = Vernac_classifier$ReactTemplate.classify_vernac(ast);
                    var aast = /* record */[
                      /* verbose : true */1,
                      /* loc */loc,
                      /* indentation */match$1[0],
                      /* strlen */match$1[1],
                      /* expr */ast
                    ];
                    var match$2 = clas[0];
                    var exit = 0;
                    if (typeof match$2 === "number" && match$2 === 0) {
                      process_transaction(/* None */0, /* Some */[/* false */0], aast, /* tuple */[
                            /* VtMeta */0,
                            /* VtNow */0
                          ]);
                    } else {
                      exit = 1;
                    }
                    if (exit === 1) {
                      process_transaction(/* None */0, /* None */0, aast, /* tuple */[
                            /* VtQuery */Block.__(5, [
                                /* false */0,
                                route
                              ]),
                            /* VtNow */0
                          ]);
                    }
                    
                  };
                  return /* () */0;
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn === End_of_input) {
                    return /* () */0;
                  } else {
                    return Exninfo$ReactTemplate.iraise(CErrors$ReactTemplate.push(exn));
                  }
                }
              }), s);
}

function edit_at(doc, id) {
  if (Stateid$ReactTemplate.equal(id, Stateid$ReactTemplate.dummy)) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("edit_at dummy."));
  } else {
    var vcs$1 = vcs[0];
    var on_cur_branch = function (id) {
      var head = Curry._1(current_branch, vcs[0]);
      var _cur = Curry._2(get_branch, vcs[0], head)[/* pos */2];
      while(true) {
        var cur = _cur;
        if (Caml_obj.caml_equal(id, cur)) {
          return /* true */1;
        } else {
          var match = visit$1(cur);
          var match$1 = match[/* step */0];
          if (typeof match$1 === "number") {
            _cur = match[/* next */1];
            continue ;
            
          } else if (match$1[0] !== 781815138) {
            _cur = match[/* next */1];
            continue ;
            
          } else {
            return /* false */0;
          }
        }
      };
    };
    var is_pure = function (id) {
      var match = visit$1(id)[/* step */0];
      if (typeof match === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "stm.ml",
                3126,
                11
              ]
            ];
      } else if (match[0] !== 4050672) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "stm.ml",
                3126,
                11
              ]
            ];
      } else {
        var _id = match[1][1];
        while(true) {
          var id$1 = _id;
          var view = visit$1(id$1);
          var match$1 = view[/* step */0];
          if (typeof match$1 === "number") {
            return /* false */0;
          } else {
            var variant = match$1[0];
            if (variant !== 3356250) {
              if (variant !== 781815138) {
                return /* false */0;
              } else {
                return /* true */1;
              }
            } else {
              _id = view[/* next */1];
              continue ;
              
            }
          }
        };
      }
    };
    var is_ancestor_of_cur_branch = function (id) {
      var head = Curry._1(current_branch, vcs[0]);
      var id$1 = Curry._2(get_branch, vcs[0], head)[/* pos */2];
      return Curry._2(Stateid$ReactTemplate.$$Set[/* mem */2], id, Curry._2(reachable, vcs[0], id$1));
    };
    var has_failed = function (qed_id) {
      var match = visit$1(qed_id);
      var match$1 = match[/* step */0];
      if (typeof match$1 === "number") {
        return /* false */0;
      } else if (match$1[0] !== 4050672) {
        return /* false */0;
      } else {
        var match$2 = match$1[1][0][/* fproof */2];
        if (match$2) {
          return Future$ReactTemplate.is_exn(match$2[0][0]);
        } else {
          return /* false */0;
        }
      }
    };
    var master_for_br = function (_, _tip) {
      while(true) {
        var tip = _tip;
        if (Stateid$ReactTemplate.equal(tip, Stateid$ReactTemplate.initial)) {
          return tip;
        } else {
          var match = visit$1(tip);
          var match$1 = match[/* step */0];
          if (typeof match$1 === "number") {
            _tip = match[/* next */1];
            continue ;
            
          } else {
            var variant = match$1[0];
            if (variant !== -417845577) {
              if (variant !== 4050672) {
                if (variant !== 781815138) {
                  _tip = match[/* next */1];
                  continue ;
                  
                } else {
                  return tip;
                }
              } else {
                return tip;
              }
            } else {
              var match$2 = match$1[1];
              if (match$2[0]) {
                return match$2[1];
              } else {
                return tip;
              }
            }
          }
        }
      };
    };
    var reopen_branch = function (start, _, mode, qed_id, tip, old_branch) {
      var match = visit$1(qed_id);
      var match$1 = match[/* step */0];
      var match$2;
      var exit = 0;
      if (typeof match$1 === "number") {
        exit = 1;
      } else if (match$1[0] !== 4050672) {
        exit = 1;
      } else {
        var match$3 = match$1[1][0];
        var match$4 = match$3[/* fproof */2];
        if (match$4) {
          match$2 = /* tuple */[
            start,
            match$4[0][1],
            match$3[/* keep */1]
          ];
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        match$2 = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("ProofTask not ending with Qed."));
      }
      var master_id = match$2[0];
      branch$1(/* Some */[master_id], /* Some */[id], edit_branch, /* `Edit */[
            770176554,
            /* tuple */[
              mode,
              qed_id,
              master_id,
              match$2[2],
              old_branch
            ]
          ]);
      delete_boxes_of(id);
      match$2[1][0] = /* true */1;
      Curry._3(Reach[/* known_state */0], /* None */0, is_interactive(/* () */0), id);
      checkout_shallowest_proof_branch(/* () */0);
      return /* `Focus */[
              397856696,
              /* record */[
                /* start */master_id,
                /* stop */qed_id,
                /* tip */tip
              ]
            ];
    };
    var no_edit = function (x) {
      if (typeof x === "number" || x[0] !== 770176554) {
        return x;
      } else {
        return /* `Proof */[
                -608348572,
                /* tuple */[
                  x[1][0],
                  1
                ]
              ];
      }
    };
    var backto = function (id, bn) {
      List.iter(delete_branch$1, Curry._1(branches, vcs[0]));
      var ancestors = Curry._2(reachable, vcs[0], id);
      var match = branches_of(id);
      var match$1 = match[/* mine */0];
      var brinfo = match$1[1];
      List.iter((function (param) {
              var match = param[1];
              var root = match[/* root */1];
              var name = param[0];
              if (!Curry._2(VCS_001[/* equal */1], name, VCS_001[/* master */4]) && Curry._2(Stateid$ReactTemplate.$$Set[/* mem */2], root, ancestors)) {
                return branch$1(/* Some */[root], /* Some */[match[/* pos */2]], name, match[/* kind */0]);
              } else {
                return 0;
              }
            }), match[/* others */1]);
      reset_branch$1(VCS_001[/* master */4], master_for_br(brinfo[/* root */1], id));
      branch$1(/* Some */[brinfo[/* root */1]], /* Some */[brinfo[/* pos */2]], Option$ReactTemplate.$$default(match$1[0], bn), no_edit(brinfo[/* kind */0]));
      delete_boxes_of(id);
      gc$1(/* () */0);
      print(/* None */0, /* () */0);
      if (!cur_opt[0][/* async_proofs_full */5]) {
        Curry._3(Reach[/* known_state */0], /* None */0, is_interactive(/* () */0), id);
      }
      checkout_shallowest_proof_branch(/* () */0);
      return /* NewTip */641153275;
    };
    try {
      var focused = List.exists((function (param) {
              return Caml_obj.caml_equal(edit_branch, param);
            }), Curry._1(branches, vcs[0]));
      var match = get_info$1(id)[/* vcs_backup */3][1];
      var branch_info;
      if (match) {
        var match$1 = match[0][/* mine */0];
        var match$2 = match$1[1][/* kind */0];
        if (typeof match$2 === "number") {
          branch_info = /* None */0;
        } else {
          var variant = match$2[0];
          if (variant !== -608348572) {
            if (variant !== 770176554) {
              branch_info = /* None */0;
            } else {
              var match$3 = match$2[1];
              branch_info = /* Some */[/* tuple */[
                  match$3[0],
                  match$3[4]
                ]];
            }
          } else {
            branch_info = /* Some */[/* tuple */[
                match$2[1][0],
                match$1[0]
              ]];
          }
        }
      } else {
        branch_info = /* None */0;
      }
      var match$4 = proof_task_box_of(id);
      var rc;
      var exit = 0;
      if (match$4) {
        if (branch_info) {
          exit = 1;
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "stm.ml",
                  3187,
                  27
                ]
              ];
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (focused !== 0) {
          if (match$4) {
            if (on_cur_branch(id)) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "stm.ml",
                      3194,
                      35
                    ]
                  ];
            } else {
              rc = is_ancestor_of_cur_branch(id) ? backto(id, /* Some */[branch_info[0][1]]) : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot leave an `Edit branch open."));
            }
          } else if (on_cur_branch(id)) {
            reset_branch$1(Curry._1(current_branch, vcs[0]), id);
            Curry._3(Reach[/* known_state */0], /* None */0, is_interactive(/* () */0), id);
            checkout_shallowest_proof_branch(/* () */0);
            rc = /* NewTip */641153275;
          } else {
            rc = is_ancestor_of_cur_branch(id) ? backto(id, /* None */0) : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot leave an `Edit branch open."));
          }
        } else if (match$4) {
          var match$5 = branch_info[0];
          var bn = match$5[1];
          var match$6 = match$4[0];
          var qed_id = match$6[/* qed */1];
          var head = Curry._1(current_branch, vcs[0]);
          var tip = Curry._2(get_branch, vcs[0], head)[/* pos */2];
          rc = has_failed(qed_id) && is_pure(qed_id) && !cur_opt[0][/* async_proofs_never_reopen_branch */6] ? reopen_branch(match$6[/* lemma */0], id, match$5[0], qed_id, tip, bn) : backto(id, /* Some */[bn]);
        } else {
          rc = branch_info ? backto(id, /* Some */[branch_info[0][1]]) : backto(id, /* None */0);
        }
      }
      print(/* None */0, /* () */0);
      return /* tuple */[
              doc,
              rc
            ];
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      var match$7 = CErrors$ReactTemplate.push(e);
      var info = match$7[1];
      var e$1 = match$7[0];
      var match$8 = Stateid$ReactTemplate.get(info);
      if (match$8) {
        var id$1 = match$8[0][1];
        stm_prerr_endline((function () {
                return "Failed at state " + Stateid$ReactTemplate.to_string(id$1);
              }));
        vcs[0] = vcs$1;
        print(/* None */0, /* () */0);
        return Exninfo$ReactTemplate.iraise(/* tuple */[
                    e$1,
                    info
                  ]);
      } else {
        print(/* None */0, /* () */0);
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("edit_at " + (Stateid$ReactTemplate.to_string(id) + ": ")), CErrors$ReactTemplate.print_no_report(e$1)), Pp$ReactTemplate.str(".")));
      }
    }
  }
}

function get_current_state() {
  var head = Curry._1(current_branch, vcs[0]);
  return Curry._2(get_branch, vcs[0], head)[/* pos */2];
}

function get_ldir() {
  return ldir[0];
}

function get_doc() {
  return 0;
}

function current_proof_depth() {
  var head = Curry._1(current_branch, vcs[0]);
  var match = Curry._2(get_branch, vcs[0], head);
  if (typeof match[/* kind */0] === "number") {
    return 0;
  } else {
    var cur = match[/* pos */2];
    var distance = function (root) {
      if (Stateid$ReactTemplate.equal(cur, root)) {
        return 0;
      } else {
        return 1 + distance(visit$1(cur)[/* next */1]) | 0;
      }
    };
    return distance(cur);
  }
}

function unmangle(n) {
  var n$1 = Curry._1(VCS_001[/* to_string */3], n);
  var idx = $$String.index(n$1, /* "_" */95) + 1 | 0;
  return Names$ReactTemplate.Id[/* of_string */5]($$String.sub(n$1, idx, n$1.length - idx | 0));
}

function proofname(b) {
  var match = Curry._2(get_branch, vcs[0], b);
  var match$1 = match[/* kind */0];
  if (typeof match$1 === "number") {
    return /* None */0;
  } else {
    var variant = match$1[0];
    if (variant !== -608348572) {
      if (variant !== 770176554) {
        return /* None */0;
      } else {
        return /* Some */[b];
      }
    } else {
      return /* Some */[b];
    }
  }
}

function get_all_proof_names() {
  return List.map(unmangle, CList$ReactTemplate.map_filter(proofname, Curry._1(branches, vcs[0])));
}

Hook$ReactTemplate.set(Obligations$ReactTemplate.stm_get_fix_exn, (function () {
        return fix_exn_ref[0];
      }));

var AsyncOpts = [default_opts];

var ProofTask = [
  name,
  extra_env,
  request_of_task,
  task_match,
  use_response,
  on_marshal_error,
  on_task_cancellation_or_expiration_or_slave_death,
  forward_feedback$1,
  perform,
  name_of_task,
  name_of_request
];

var state_computed_hook = match[1];

var unreachable_state_hook = match$3[1];

var state_ready_hook = match$1[1];

var forward_feedback_hook = match$2[1];

exports.AsyncOpts = AsyncOpts;
exports.init_core = init_core;
exports.new_doc = new_doc;
exports.parse_sentence = parse_sentence;
exports.End_of_input = End_of_input;
exports.add = add;
exports.query = query;
exports.edit_at = edit_at;
exports.finish = finish;
exports.wait = wait;
exports.observe = observe;
exports.stop_worker = stop_worker;
exports.join = join;
exports.reset_task_queue = reset_task_queue$1;
exports.check_task = check_task$1;
exports.info_tasks = info_tasks$1;
exports.get_current_state = get_current_state;
exports.get_ldir = get_ldir;
exports.get_ast = get_ast;
exports.set_perspective = set_perspective$1;
exports.ProofTask = ProofTask;
exports.TacTask = TacTask;
exports.QueryTask = QueryTask;
exports.DynBlockData = DynBlockData;
exports.register_proof_block_delimiter = register_proof_block_delimiter;
exports.state_computed_hook = state_computed_hook;
exports.unreachable_state_hook = unreachable_state_hook;
exports.state_ready_hook = state_ready_hook;
exports.forward_feedback_hook = forward_feedback_hook;
exports.get_doc = get_doc;
exports.state_of_id = state_of_id;
exports.current_proof_depth = current_proof_depth;
exports.get_all_proof_names = get_all_proof_names;
exports.stm_debug = stm_debug;
/* match Not a pure module */
