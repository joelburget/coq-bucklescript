// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var $$Set = require("bs-platform/lib/js/set.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Exninfo$ReactTemplate = require("./exninfo.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var CEphemeron$ReactTemplate = require("./cEphemeron.bs.js");

var not_ready_msg = [(function (name) {
      return Pp$ReactTemplate.strbrk("The value you are asking for (" + (name + ") is not ready yet. Please wait or pass the \"-async-proofs off\" option to CoqIDE to disable asynchronous script processing and don't pass \"-quick\" to coqc."));
    })];

var not_here_msg = [(function (name) {
      return Pp$ReactTemplate.strbrk("The value you are asking for (" + (name + ") is not available in this process. If you really need this, pass the \"-async-proofs off\" option to CoqIDE to disable asynchronous script processing and don't pass \"-quick\" to coqc."));
    })];

function customize_not_ready_msg(f) {
  not_ready_msg[0] = f;
  return /* () */0;
}

function customize_not_here_msg(f) {
  not_here_msg[0] = f;
  return /* () */0;
}

var NotReady = Caml_exceptions.create("Future-ReactTemplate.NotReady");

var NotHere = Caml_exceptions.create("Future-ReactTemplate.NotHere");

CErrors$ReactTemplate.register_handler((function (param) {
        if (param[0] === NotReady) {
          return Curry._1(not_ready_msg[0], param[1]);
        } else if (param[0] === NotHere) {
          return Curry._1(not_here_msg[0], param[1]);
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

function id(x) {
  console.error("Future: no fix_exn.\nYou have probably created a Future.computation from a value without passing the ~fix_exn argument.  You probably want to chain with an already existing future instead.");
  return x;
}

var count = [0];

var compare = Caml_obj.caml_compare;

function equal(prim, prim$1) {
  return +(prim === prim$1);
}

var UUIDMap = $$Map.Make([compare]);

var UUIDSet = $$Set.Make([compare]);

var unnamed = "unnamed";

function create($staropt$star, $staropt$star$1, f, x) {
  var name = $staropt$star ? $staropt$star[0] : unnamed;
  var uuid = $staropt$star$1 ? $staropt$star$1[0] : (count[0] = count[0] + 1 | 0, count[0]);
  return [/* Ongoing */Block.__(0, [
              name,
              CEphemeron$ReactTemplate.create(/* tuple */[
                    uuid,
                    f,
                    [x]
                  ])
            ])];
}

function get(x) {
  var match = x[0];
  if (match.tag) {
    return /* tuple */[
            unnamed,
            0,
            id,
            [/* Val */Block.__(2, [match[0]])]
          ];
  } else {
    var name = match[0];
    try {
      var match$1 = CEphemeron$ReactTemplate.get(match[1]);
      return /* tuple */[
              name,
              match$1[0],
              match$1[1],
              match$1[2]
            ];
    }
    catch (exn){
      if (exn === CEphemeron$ReactTemplate.InvalidKey) {
        return /* tuple */[
                name,
                0,
                id,
                [/* Exn */Block.__(3, [/* tuple */[
                        [
                          NotHere,
                          name
                        ],
                        Exninfo$ReactTemplate.$$null
                      ]])]
              ];
      } else {
        throw exn;
      }
    }
  }
}

function is_over(kx) {
  var match = get(kx);
  var match$1 = match[3][0];
  switch (match$1.tag | 0) {
    case 0 : 
    case 1 : 
        return /* false */0;
    case 2 : 
    case 3 : 
        return /* true */1;
    
  }
}

function is_val(kx) {
  var match = get(kx);
  var match$1 = match[3][0];
  if (match$1.tag === 2) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_exn(kx) {
  var match = get(kx);
  var match$1 = match[3][0];
  if (match$1.tag === 3) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function peek_val(kx) {
  var match = get(kx);
  var match$1 = match[3][0];
  if (match$1.tag === 2) {
    return /* Some */[match$1[0]];
  } else {
    return /* None */0;
  }
}

function uuid(kx) {
  return get(kx)[1];
}

function from_val($staropt$star, v) {
  var fix_exn = $staropt$star ? $staropt$star[0] : id;
  return create(/* None */0, /* None */0, fix_exn, /* Val */Block.__(2, [v]));
}

function from_here($staropt$star, v) {
  var fix_exn = $staropt$star ? $staropt$star[0] : id;
  return create(/* None */0, /* None */0, fix_exn, /* Val */Block.__(2, [v]));
}

function fix_exn_of(ck) {
  return get(ck)[2];
}

function create_delegate($staropt$star, name, fix_exn) {
  var blocking = $staropt$star ? $staropt$star[0] : /* true */1;
  var match = blocking ? /* tuple */[
      (function () {
          return /* () */0;
        }),
      (function () {
          return /* () */0;
        })
    ] : /* tuple */[
      (function () {
          throw [
                NotReady,
                name
              ];
        }),
      (function () {
          return /* () */0;
        })
    ];
  var signal = match[1];
  var ck = create(/* Some */[name], /* None */0, fix_exn, /* Delegated */Block.__(0, [match[0]]));
  return /* tuple */[
          ck,
          (function (param) {
              var signal$1 = signal;
              var ck$1 = ck;
              var v = param;
              var match = get(ck$1);
              var c = match[3];
              var match$1 = c[0];
              var tmp;
              tmp = match$1.tag ? /* false */0 : /* true */1;
              if (!tmp) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "future.ml",
                        108,
                        4
                      ]
                    ];
              }
              var variant = v[0];
              if (variant !== 4298433) {
                if (variant >= 748545327) {
                  var match$2 = get(v[1]);
                  c[0] = match$2[3][0];
                } else {
                  c[0] = /* Exn */Block.__(3, [Curry._1(match[2], v[1])]);
                }
              } else {
                c[0] = /* Val */Block.__(2, [v[1]]);
              }
              return Curry._1(signal$1, /* () */0);
            })
        ];
}

function compute(ck) {
  while(true) {
    var match = get(ck);
    var c = match[3];
    var match$1 = c[0];
    switch (match$1.tag | 0) {
      case 0 : 
          Curry._1(match$1[0], /* () */0);
          continue ;
          case 1 : 
          try {
            var data = Curry._1(match$1[0], /* () */0);
            c[0] = /* Val */Block.__(2, [data]);
            return /* `Val */[
                    4298433,
                    data
                  ];
          }
          catch (raw_e){
            var e = Js_exn.internalToOCamlException(raw_e);
            var e$1 = CErrors$ReactTemplate.push(e);
            var e$2 = Curry._1(match[2], e$1);
            if (e$2[0][0] === NotReady) {
              return /* `Exn */[
                      3458171,
                      e$2
                    ];
            } else {
              c[0] = /* Exn */Block.__(3, [e$2]);
              return /* `Exn */[
                      3458171,
                      e$2
                    ];
            }
          }
          break;
      case 2 : 
          return /* `Val */[
                  4298433,
                  match$1[0]
                ];
      case 3 : 
          var match$2 = match$1[0];
          return /* `Exn */[
                  3458171,
                  /* tuple */[
                    match$2[0],
                    match$2[1]
                  ]
                ];
      
    }
  };
}

function force(x) {
  var match = compute(x);
  if (match[0] >= 4298433) {
    return match[1];
  } else {
    return Exninfo$ReactTemplate.iraise(match[1]);
  }
}

function chain(ck, f) {
  var match = get(ck);
  var x = match[3][0];
  var tmp;
  var exit = 0;
  switch (x.tag | 0) {
    case 0 : 
    case 1 : 
        exit = 1;
        break;
    case 2 : 
        tmp = /* Val */Block.__(2, [Curry._1(f, x[0])]);
        break;
    case 3 : 
        tmp = x;
        break;
    
  }
  if (exit === 1) {
    tmp = /* Closure */Block.__(1, [(function () {
            return Curry._1(f, force(ck));
          })]);
  }
  return create(/* Some */[match[0]], /* Some */[match[1]], match[2], tmp);
}

function create$1(fix_exn, f) {
  return create(/* None */0, /* None */0, fix_exn, /* Closure */Block.__(1, [f]));
}

function replace(kx, y) {
  var match = get(kx);
  var x = match[3];
  var match$1 = x[0];
  if (match$1.tag === 3) {
    x[0] = /* Closure */Block.__(1, [(function () {
            return force(y);
          })]);
    return /* () */0;
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("A computation can be replaced only if is_exn holds."));
  }
}

function chain$1(x, f) {
  var y = chain(x, f);
  if (is_over(x)) {
    force(y);
  }
  return y;
}

function join(kx) {
  var v = force(kx);
  kx[0] = /* Finished */Block.__(1, [v]);
  return v;
}

function sink(kx) {
  if (is_val(kx)) {
    join(kx);
    return /* () */0;
  } else {
    return 0;
  }
}

function split2(x) {
  return /* tuple */[
          chain$1(x, (function (x) {
                  return x[0];
                })),
          chain$1(x, (function (x) {
                  return x[1];
                }))
        ];
}

function map2(f, x, l) {
  return CList$ReactTemplate.map_i((function (i, y) {
                var xi = chain$1(x, (function (x) {
                        try {
                          return List.nth(x, i);
                        }
                        catch (raw_exn){
                          var exn = Js_exn.internalToOCamlException(raw_exn);
                          if (exn[0] === Caml_builtin_exceptions.failure) {
                            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Future.map2 length mismatch."));
                          } else if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
                            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Future.map2 length mismatch."));
                          } else {
                            throw exn;
                          }
                        }
                      }));
                return Curry._2(f, xi, y);
              }), 0, l);
}

function print(f, kx) {
  var match = get(kx);
  var uid = match[1];
  var name = match[0];
  var uid$1 = uid ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Pp$ReactTemplate.$$int(uid)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str("]")) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("[#:"), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str("]"));
  var match$1 = match[3][0];
  switch (match$1.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Delegated"), uid$1);
    case 1 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Closure"), uid$1);
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("PureVal"), uid$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Curry._1(f, match$1[0])));
    case 3 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Exn"), uid$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.str(Printexc.to_string(match$1[0][0]))));
    
  }
}

var UUID = [
  0,
  compare,
  equal
];

exports.UUID = UUID;
exports.UUIDMap = UUIDMap;
exports.UUIDSet = UUIDSet;
exports.NotReady = NotReady;
exports.create = create$1;
exports.from_val = from_val;
exports.from_here = from_here;
exports.fix_exn_of = fix_exn_of;
exports.create_delegate = create_delegate;
exports.replace = replace;
exports.is_over = is_over;
exports.is_val = is_val;
exports.is_exn = is_exn;
exports.peek_val = peek_val;
exports.uuid = uuid;
exports.chain = chain$1;
exports.force = force;
exports.compute = compute;
exports.join = join;
exports.sink = sink;
exports.split2 = split2;
exports.map2 = map2;
exports.print = print;
exports.customize_not_ready_msg = customize_not_ready_msg;
exports.customize_not_here_msg = customize_not_here_msg;
/*  Not a pure module */
