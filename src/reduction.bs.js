// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Esubst$ReactTemplate = require("./esubst.bs.js");
var UGraph$ReactTemplate = require("./uGraph.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var CClosure$ReactTemplate = require("./cClosure.bs.js");
var CProfile$ReactTemplate = require("../shims/cProfile.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Conv_oracle$ReactTemplate = require("./conv_oracle.bs.js");

function is_empty_stack(_param) {
  while(true) {
    var param = _param;
    if (param) {
      switch (param[0].tag | 0) {
        case 4 : 
        case 5 : 
            _param = param[1];
            continue ;
            default:
          return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function el_stack(el, stk) {
  var n = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (i, z) {
          if (z.tag === 4) {
            return i + z[0] | 0;
          } else {
            return i;
          }
        }), 0, stk);
  return Esubst$ReactTemplate.el_shft(n, el);
}

function compare_stack_shape(stk1, stk2) {
  var compare_rec = function (_bal, _stk1, _stk2) {
    while(true) {
      var stk2 = _stk2;
      var stk1 = _stk1;
      var bal = _bal;
      var exit = 0;
      var exit$1 = 0;
      var exit$2 = 0;
      if (stk1) {
        var match = stk1[0];
        switch (match.tag | 0) {
          case 0 : 
              exit$2 = 3;
              break;
          case 1 : 
              if (stk2) {
                switch (stk2[0].tag | 0) {
                  case 0 : 
                      exit = 1;
                      break;
                  case 1 : 
                      if (bal) {
                        return /* false */0;
                      } else {
                        _stk2 = stk2[1];
                        _stk1 = stk1[1];
                        _bal = 0;
                        continue ;
                        
                      }
                      break;
                  case 2 : 
                  case 3 : 
                      return /* false */0;
                  case 4 : 
                  case 5 : 
                      exit$2 = 3;
                      break;
                  
                }
              } else {
                return /* false */0;
              }
              break;
          case 2 : 
              if (stk2) {
                switch (stk2[0].tag | 0) {
                  case 0 : 
                      exit = 1;
                      break;
                  case 2 : 
                      if (bal) {
                        return /* false */0;
                      } else {
                        _stk2 = stk2[1];
                        _stk1 = stk1[1];
                        _bal = 0;
                        continue ;
                        
                      }
                      break;
                  case 1 : 
                  case 3 : 
                      return /* false */0;
                  case 4 : 
                  case 5 : 
                      exit$2 = 3;
                      break;
                  
                }
              } else {
                return /* false */0;
              }
              break;
          case 3 : 
              if (stk2) {
                var match$1 = stk2[0];
                switch (match$1.tag | 0) {
                  case 0 : 
                      exit = 1;
                      break;
                  case 1 : 
                  case 2 : 
                      return /* false */0;
                  case 3 : 
                      if (bal) {
                        return /* false */0;
                      } else if (compare_rec(0, match[1], match$1[1])) {
                        _stk2 = stk2[1];
                        _stk1 = stk1[1];
                        _bal = 0;
                        continue ;
                        
                      } else {
                        return /* false */0;
                      }
                      break;
                  case 4 : 
                  case 5 : 
                      exit$2 = 3;
                      break;
                  
                }
              } else {
                return /* false */0;
              }
              break;
          case 4 : 
          case 5 : 
              _stk1 = stk1[1];
              continue ;
              
        }
      } else if (stk2) {
        exit$2 = 3;
      } else {
        return +(bal === 0);
      }
      if (exit$2 === 3) {
        if (stk2) {
          switch (stk2[0].tag | 0) {
            case 4 : 
            case 5 : 
                _stk2 = stk2[1];
                continue ;
                default:
              exit$1 = 2;
          }
        } else {
          exit$1 = 2;
        }
      }
      if (exit$1 === 2) {
        if (stk1) {
          _stk1 = stk1[1];
          _bal = bal + stk1[0][0].length | 0;
          continue ;
          
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        var match$2 = stk2[0];
        if (match$2.tag) {
          return /* false */0;
        } else {
          _stk2 = stk2[1];
          _bal = bal - match$2[0].length | 0;
          continue ;
          
        }
      }
      
    };
  };
  return compare_rec(0, stk1, stk2);
}

function zlapp(_v, _s) {
  while(true) {
    var s = _s;
    var v = _v;
    if (s) {
      var match = s[0];
      if (match.tag) {
        return /* :: */[
                /* Zlapp */Block.__(0, [v]),
                s
              ];
      } else {
        _s = s[1];
        _v = Util$ReactTemplate.$$Array[/* append */3](v, match[0]);
        continue ;
        
      }
    } else {
      return /* :: */[
              /* Zlapp */Block.__(0, [v]),
              s
            ];
    }
  };
}

function map_lift(l, v) {
  var len = v.length;
  if (len >= 5) {
    return CArray$ReactTemplate.Fun1[/* map */0]((function (l, t) {
                  return /* tuple */[
                          l,
                          t
                        ];
                }), l, v);
  } else {
    switch (len) {
      case 0 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "reduction.ml",
                  82,
                  10
                ]
              ];
      case 1 : 
          var c0 = v[0];
          return /* array */[/* tuple */[
                    l,
                    c0
                  ]];
      case 2 : 
          var c0$1 = v[0];
          var c1 = v[1];
          return /* array */[
                  /* tuple */[
                    l,
                    c0$1
                  ],
                  /* tuple */[
                    l,
                    c1
                  ]
                ];
      case 3 : 
          var c0$2 = v[0];
          var c1$1 = v[1];
          var c2 = v[2];
          return /* array */[
                  /* tuple */[
                    l,
                    c0$2
                  ],
                  /* tuple */[
                    l,
                    c1$1
                  ],
                  /* tuple */[
                    l,
                    c2
                  ]
                ];
      case 4 : 
          var c0$3 = v[0];
          var c1$2 = v[1];
          var c2$1 = v[2];
          var c3 = v[3];
          return /* array */[
                  /* tuple */[
                    l,
                    c0$3
                  ],
                  /* tuple */[
                    l,
                    c1$2
                  ],
                  /* tuple */[
                    l,
                    c2$1
                  ],
                  /* tuple */[
                    l,
                    c3
                  ]
                ];
      
    }
  }
}

function pure_stack(lfts, stk) {
  var pure_rec = function (lfts, stk) {
    if (stk) {
      var zi = stk[0];
      var match = pure_rec(lfts, stk[1]);
      switch (zi.tag | 0) {
        case 0 : 
            var l = match[0];
            return /* tuple */[
                    l,
                    zlapp(map_lift(l, zi[0]), match[1])
                  ];
        case 1 : 
            var l$1 = match[0];
            var e = zi[3];
            return /* tuple */[
                    l$1,
                    /* :: */[
                      /* Zlcase */Block.__(3, [
                          zi[0],
                          l$1,
                          CClosure$ReactTemplate.mk_clos(e, zi[1]),
                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                  return CClosure$ReactTemplate.mk_clos(e, param);
                                }), zi[2])
                        ]),
                      match[1]
                    ]
                  ];
        case 2 : 
            var l$2 = match[0];
            return /* tuple */[
                    l$2,
                    /* :: */[
                      /* Zlproj */Block.__(1, [
                          zi[2],
                          l$2
                        ]),
                      match[1]
                    ]
                  ];
        case 3 : 
            var l$3 = match[0];
            var match$1 = pure_rec(l$3, zi[1]);
            return /* tuple */[
                    l$3,
                    /* :: */[
                      /* Zlfix */Block.__(2, [
                          /* tuple */[
                            match$1[0],
                            zi[0]
                          ],
                          match$1[1]
                        ]),
                      match[1]
                    ]
                  ];
        case 4 : 
            return /* tuple */[
                    Esubst$ReactTemplate.el_shft(zi[0], match[0]),
                    match[1]
                  ];
        case 5 : 
            return match;
        
      }
    } else {
      return /* tuple */[
              lfts,
              /* [] */0
            ];
    }
  };
  return pure_rec(lfts, stk)[1];
}

function whd_betaiota(env, t) {
  var match = Constr$ReactTemplate.kind(t);
  var exit = 0;
  switch (match.tag | 0) {
    case 9 : 
        var match$1 = Constr$ReactTemplate.kind(match[0]);
        switch (match$1.tag | 0) {
          case 2 : 
          case 3 : 
          case 8 : 
          case 10 : 
          case 11 : 
          case 12 : 
              return t;
          default:
            return CClosure$ReactTemplate.whd_val(CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.betaiota, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(t));
        }
        break;
    case 0 : 
    case 5 : 
    case 8 : 
    case 13 : 
    case 16 : 
        exit = 1;
        break;
    default:
      return t;
  }
  if (exit === 1) {
    return CClosure$ReactTemplate.whd_val(CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.betaiota, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(t));
  }
  
}

function nf_betaiota(env, t) {
  return CClosure$ReactTemplate.norm_val(CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.betaiota, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(t));
}

function whd_betaiotazeta(env, x) {
  var match = Constr$ReactTemplate.kind(x);
  var exit = 0;
  switch (match.tag | 0) {
    case 9 : 
        var match$1 = Constr$ReactTemplate.kind(match[0]);
        switch (match$1.tag | 0) {
          case 2 : 
          case 3 : 
          case 10 : 
          case 11 : 
          case 12 : 
              return x;
          default:
            return CClosure$ReactTemplate.whd_val(CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.betaiotazeta, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(x));
        }
        break;
    case 0 : 
    case 5 : 
    case 8 : 
    case 13 : 
    case 16 : 
        exit = 1;
        break;
    default:
      return x;
  }
  if (exit === 1) {
    return CClosure$ReactTemplate.whd_val(CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.betaiotazeta, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(x));
  }
  
}

function whd_all(env, t) {
  var match = Constr$ReactTemplate.kind(t);
  var exit = 0;
  switch (match.tag | 0) {
    case 9 : 
        var match$1 = Constr$ReactTemplate.kind(match[0]);
        switch (match$1.tag | 0) {
          case 2 : 
          case 3 : 
          case 11 : 
          case 12 : 
              return t;
          default:
            return CClosure$ReactTemplate.whd_val(CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.all, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(t));
        }
        break;
    case 0 : 
    case 1 : 
    case 5 : 
    case 8 : 
    case 10 : 
    case 13 : 
    case 16 : 
        exit = 1;
        break;
    default:
      return t;
  }
  if (exit === 1) {
    return CClosure$ReactTemplate.whd_val(CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.all, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(t));
  }
  
}

function whd_allnolet(env, t) {
  var match = Constr$ReactTemplate.kind(t);
  var exit = 0;
  switch (match.tag | 0) {
    case 9 : 
        var match$1 = Constr$ReactTemplate.kind(match[0]);
        switch (match$1.tag | 0) {
          case 2 : 
          case 3 : 
          case 8 : 
          case 11 : 
          case 12 : 
              return t;
          default:
            return CClosure$ReactTemplate.whd_val(CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.allnolet, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(t));
        }
        break;
    case 0 : 
    case 1 : 
    case 5 : 
    case 10 : 
    case 13 : 
    case 16 : 
        exit = 1;
        break;
    default:
      return t;
  }
  if (exit === 1) {
    return CClosure$ReactTemplate.whd_val(CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.allnolet, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(t));
  }
  
}

var NotConvertible = Caml_exceptions.create("Reduction-ReactTemplate.NotConvertible");

var NotConvertibleVect = Caml_exceptions.create("Reduction-ReactTemplate.NotConvertibleVect");

function is_cumul(param) {
  if (param !== 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function sort_cmp_universes(env, pb, s0, s1, param) {
  var check = param[1];
  return /* tuple */[
          Curry._5(check[/* compare_sorts */0], env, pb, s0, s1, param[0]),
          check
        ];
}

function convert_instances(flex, u, u$prime, param) {
  var check = param[1];
  return /* tuple */[
          Curry._4(check[/* compare_instances */1], flex, u, u$prime, param[0]),
          check
        ];
}

function get_cumulativity_constraints(cv_pb, variance, u, u$prime) {
  if (cv_pb !== 0) {
    return Univ$ReactTemplate.enforce_leq_variance_instances(variance, u, u$prime, Univ$ReactTemplate.Constraint[/* empty */0]);
  } else {
    return Univ$ReactTemplate.enforce_eq_variance_instances(variance, u, u$prime, Univ$ReactTemplate.Constraint[/* empty */0]);
  }
}

function inductive_cumulativity_arguments(param) {
  var mind = param[0];
  return mind[/* mind_nparams */5] + Caml_array.caml_array_get(mind[/* mind_packets */0], param[1])[/* mind_nrealargs */5] | 0;
}

function convert_inductives_gen(cmp_instances, cmp_cumul, cv_pb, param, nargs, u1, u2, s) {
  var mind = param[0];
  var match = mind[/* mind_universes */8];
  switch (match.tag | 0) {
    case 0 : 
        if (!(Univ$ReactTemplate.Instance[/* length */6](u1) === 0 && Univ$ReactTemplate.Instance[/* length */6](u2) === 0)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "reduction.ml",
                  238,
                  4
                ]
              ];
        }
        return s;
    case 1 : 
        return Curry._3(cmp_instances, u1, u2, s);
    case 2 : 
        var num_param_arity = inductive_cumulativity_arguments(/* tuple */[
              mind,
              param[1]
            ]);
        if (num_param_arity !== nargs) {
          return Curry._3(cmp_instances, u1, u2, s);
        } else {
          return Curry._5(cmp_cumul, cv_pb, Univ$ReactTemplate.ACumulativityInfo[/* variance */1](match[0]), u1, u2, s);
        }
    
  }
}

function convert_inductives(cv_pb, ind, nargs, u1, u2, param) {
  var check = param[1];
  return /* tuple */[
          convert_inductives_gen(Curry._1(check[/* compare_instances */1], /* false */0), check[/* compare_cumul_instances */2], cv_pb, ind, nargs, u1, u2, param[0]),
          check
        ];
}

function constructor_cumulativity_arguments(param) {
  var mind = param[0];
  return mind[/* mind_nparams */5] + Caml_array.caml_array_get(Caml_array.caml_array_get(mind[/* mind_packets */0], param[1])[/* mind_consnrealargs */9], param[2] - 1 | 0) | 0;
}

function convert_constructors_gen(cmp_instances, cmp_cumul, param, nargs, u1, u2, s) {
  var mind = param[0];
  var match = mind[/* mind_universes */8];
  switch (match.tag | 0) {
    case 0 : 
        if (!(Univ$ReactTemplate.Instance[/* length */6](u1) === 0 && Univ$ReactTemplate.Instance[/* length */6](u2) === 0)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "reduction.ml",
                  260,
                  4
                ]
              ];
        }
        return s;
    case 1 : 
        return Curry._3(cmp_instances, u1, u2, s);
    case 2 : 
        var num_cnstr_args = constructor_cumulativity_arguments(/* tuple */[
              mind,
              param[1],
              param[2]
            ]);
        if (num_cnstr_args !== nargs) {
          return Curry._3(cmp_instances, u1, u2, s);
        } else {
          var variance = Caml_array.caml_make_vect(Univ$ReactTemplate.Instance[/* length */6](u1), /* Irrelevant */0);
          return Curry._5(cmp_cumul, /* CONV */0, variance, u1, u2, s);
        }
        break;
    
  }
}

function convert_constructors(ctor, nargs, u1, u2, param) {
  var check = param[1];
  return /* tuple */[
          convert_constructors_gen(Curry._1(check[/* compare_instances */1], /* false */0), check[/* compare_cumul_instances */2], ctor, nargs, u1, u2, param[0]),
          check
        ];
}

function conv_table_key(infos, k1, k2, cuniv) {
  if (k1 === k2) {
    return cuniv;
  } else {
    switch (k1.tag | 0) {
      case 0 : 
          var match = k1[0];
          var u = match[1];
          var cst = match[0];
          switch (k2.tag | 0) {
            case 0 : 
                var match$1 = k2[0];
                var u$prime = match$1[1];
                if (Names$ReactTemplate.Constant[/* equal */12](cst, match$1[0])) {
                  if (Univ$ReactTemplate.Instance[/* equal */5](u, u$prime)) {
                    return cuniv;
                  } else {
                    var flex = Environ$ReactTemplate.evaluable_constant(cst, CClosure$ReactTemplate.info_env(infos)) && CClosure$ReactTemplate.RedFlags[/* red_set */15](CClosure$ReactTemplate.info_flags(infos), CClosure$ReactTemplate.RedFlags[/* fCONST */7](cst));
                    return convert_instances(flex, u, u$prime, cuniv);
                  }
                } else {
                  throw NotConvertible;
                }
                break;
            case 1 : 
            case 2 : 
                throw NotConvertible;
            
          }
          break;
      case 1 : 
          switch (k2.tag | 0) {
            case 1 : 
                if (Names$ReactTemplate.Id[/* equal */0](k1[0], k2[0])) {
                  return cuniv;
                } else {
                  throw NotConvertible;
                }
                break;
            case 0 : 
            case 2 : 
                throw NotConvertible;
            
          }
          break;
      case 2 : 
          switch (k2.tag | 0) {
            case 0 : 
            case 1 : 
                throw NotConvertible;
            case 2 : 
                if (k1[0] === k2[0]) {
                  return cuniv;
                } else {
                  throw NotConvertible;
                }
                break;
            
          }
          break;
      
    }
  }
}

function ccnv(cv_pb, l2r, infos, lft1, lft2, term1, term2, cuniv) {
  var _cv_pb = cv_pb;
  var l2r$1 = l2r;
  var infos$1 = infos;
  var _param = /* tuple */[
    lft1,
    /* tuple */[
      term1,
      /* [] */0
    ]
  ];
  var _param$1 = /* tuple */[
    lft2,
    /* tuple */[
      term2,
      /* [] */0
    ]
  ];
  var cuniv$1 = cuniv;
  while(true) {
    var param = _param$1;
    var param$1 = _param;
    var cv_pb$1 = _cv_pb;
    var st2 = param[1];
    var lft2$1 = param[0];
    var st1 = param$1[1];
    var lft1$1 = param$1[0];
    var ninfos = CClosure$ReactTemplate.infos_with_reds(infos$1[/* cnv_inf */0], CClosure$ReactTemplate.betaiotazeta);
    var appr1 = CClosure$ReactTemplate.whd_stack(ninfos, infos$1[/* lft_tab */1], st1[0], st1[1]);
    var v1 = appr1[1];
    var hd1 = appr1[0];
    var appr2 = CClosure$ReactTemplate.whd_stack(ninfos, infos$1[/* rgt_tab */2], st2[0], st2[1]);
    var v2 = appr2[1];
    var hd2 = appr2[0];
    var appr1$1 = /* tuple */[
      lft1$1,
      appr1
    ];
    var appr2$1 = /* tuple */[
      lft2$1,
      appr2
    ];
    var match = CClosure$ReactTemplate.fterm_of(hd1);
    var match$1 = CClosure$ReactTemplate.fterm_of(hd2);
    var exit = 0;
    var exit$1 = 0;
    var exit$2 = 0;
    var exit$3 = 0;
    var exit$4 = 0;
    var exit$5 = 0;
    var exit$6 = 0;
    var exit$7 = 0;
    var exit$8 = 0;
    if (typeof match === "number") {
      exit$8 = 9;
    } else {
      switch (match.tag | 0) {
        case 0 : 
            if (typeof match$1 === "number") {
              exit$2 = 3;
            } else {
              switch (match$1.tag | 0) {
                case 0 : 
                    var el1 = el_stack(lft1$1, v1);
                    var el2 = el_stack(lft2$1, v2);
                    if (Esubst$ReactTemplate.reloc_rel(match[0], el1) === Esubst$ReactTemplate.reloc_rel(match$1[0], el2)) {
                      return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$1);
                    } else {
                      throw NotConvertible;
                    }
                    break;
                case 3 : 
                    exit$4 = 5;
                    break;
                case 7 : 
                    exit$8 = 9;
                    break;
                case 11 : 
                    exit$6 = 7;
                    break;
                case 1 : 
                case 4 : 
                case 8 : 
                case 9 : 
                case 12 : 
                case 14 : 
                    exit$1 = 2;
                    break;
                default:
                  exit$2 = 3;
              }
            }
            break;
        case 1 : 
            if (typeof match$1 === "number") {
              exit$2 = 3;
            } else {
              switch (match$1.tag | 0) {
                case 1 : 
                    var match$2 = Constr$ReactTemplate.kind(match[0]);
                    var match$3 = Constr$ReactTemplate.kind(match$1[0]);
                    switch (match$2.tag | 0) {
                      case 2 : 
                          if (match$3.tag === 2) {
                            if (match$2[0] === match$3[0]) {
                              return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$1);
                            } else {
                              throw NotConvertible;
                            }
                          } else {
                            throw NotConvertible;
                          }
                          break;
                      case 4 : 
                          if (match$3.tag === 4) {
                            if (!(is_empty_stack(v1) && is_empty_stack(v2))) {
                              CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("conversion was given ill-typed terms (Sort)."));
                            }
                            return sort_cmp_universes(CClosure$ReactTemplate.env_of_infos(infos$1[/* cnv_inf */0]), cv_pb$1, match$2[0], match$3[0], cuniv$1);
                          } else {
                            throw NotConvertible;
                          }
                          break;
                      default:
                        throw NotConvertible;
                    }
                    break;
                case 3 : 
                    exit$4 = 5;
                    break;
                case 7 : 
                    exit$8 = 9;
                    break;
                case 11 : 
                    exit$6 = 7;
                    break;
                case 0 : 
                case 4 : 
                case 8 : 
                case 9 : 
                case 12 : 
                case 14 : 
                    exit$1 = 2;
                    break;
                default:
                  exit$2 = 3;
              }
            }
            break;
        case 3 : 
            var fl1 = match[0];
            if (typeof match$1 === "number") {
              exit$5 = 6;
            } else {
              switch (match$1.tag | 0) {
                case 3 : 
                    var fl2 = match$1[0];
                    try {
                      var cuniv$2 = conv_table_key(infos$1[/* cnv_inf */0], fl1, fl2, cuniv$1);
                      return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$2);
                    }
                    catch (raw_exn){
                      var exn = Js_exn.internalToOCamlException(raw_exn);
                      var exit$9 = 0;
                      if (exn === NotConvertible) {
                        exit$9 = 10;
                      } else if (exn[0] === Univ$ReactTemplate.UniverseInconsistency) {
                        exit$9 = 10;
                      } else {
                        throw exn;
                      }
                      if (exit$9 === 10) {
                        var oracle = CClosure$ReactTemplate.oracle_of_infos(infos$1[/* cnv_inf */0]);
                        var match$4;
                        if (Conv_oracle$ReactTemplate.oracle_order(Univ$ReactTemplate.out_punivs, oracle, l2r$1, fl1, fl2)) {
                          var match$5 = CClosure$ReactTemplate.unfold_reference(infos$1[/* cnv_inf */0], infos$1[/* lft_tab */1], fl1);
                          if (match$5) {
                            match$4 = /* tuple */[
                              /* tuple */[
                                lft1$1,
                                /* tuple */[
                                  match$5[0],
                                  v1
                                ]
                              ],
                              appr2$1
                            ];
                          } else {
                            var match$6 = CClosure$ReactTemplate.unfold_reference(infos$1[/* cnv_inf */0], infos$1[/* rgt_tab */2], fl2);
                            if (match$6) {
                              match$4 = /* tuple */[
                                appr1$1,
                                /* tuple */[
                                  lft2$1,
                                  /* tuple */[
                                    match$6[0],
                                    v2
                                  ]
                                ]
                              ];
                            } else {
                              throw NotConvertible;
                            }
                          }
                        } else {
                          var match$7 = CClosure$ReactTemplate.unfold_reference(infos$1[/* cnv_inf */0], infos$1[/* rgt_tab */2], fl2);
                          if (match$7) {
                            match$4 = /* tuple */[
                              appr1$1,
                              /* tuple */[
                                lft2$1,
                                /* tuple */[
                                  match$7[0],
                                  v2
                                ]
                              ]
                            ];
                          } else {
                            var match$8 = CClosure$ReactTemplate.unfold_reference(infos$1[/* cnv_inf */0], infos$1[/* lft_tab */1], fl1);
                            if (match$8) {
                              match$4 = /* tuple */[
                                /* tuple */[
                                  lft1$1,
                                  /* tuple */[
                                    match$8[0],
                                    v1
                                  ]
                                ],
                                appr2$1
                              ];
                            } else {
                              throw NotConvertible;
                            }
                          }
                        }
                        _param$1 = match$4[1];
                        _param = match$4[0];
                        continue ;
                        
                      }
                      
                    }
                    break;
                case 7 : 
                    exit$8 = 9;
                    break;
                case 11 : 
                    exit$6 = 7;
                    break;
                default:
                  exit$5 = 6;
              }
            }
            break;
        case 4 : 
            var match$9 = match[0];
            var u1 = match$9[1];
            var ind1 = match$9[0];
            if (typeof match$1 === "number") {
              exit$2 = 3;
            } else {
              switch (match$1.tag | 0) {
                case 3 : 
                    exit$4 = 5;
                    break;
                case 4 : 
                    var match$10 = match$1[0];
                    var u2 = match$10[1];
                    if (Names$ReactTemplate.eq_ind(ind1, match$10[0])) {
                      if (Univ$ReactTemplate.Instance[/* length */6](u1) === 0 || Univ$ReactTemplate.Instance[/* length */6](u2) === 0) {
                        var cuniv$3 = convert_instances(/* false */0, u1, u2, cuniv$1);
                        return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$3);
                      } else {
                        var mind = Environ$ReactTemplate.lookup_mind(ind1[0], CClosure$ReactTemplate.info_env(infos$1[/* cnv_inf */0]));
                        var nargs = CClosure$ReactTemplate.stack_args_size(v1);
                        if (nargs !== CClosure$ReactTemplate.stack_args_size(v2)) {
                          throw NotConvertible;
                        } else {
                          var cuniv$4 = convert_inductives(cv_pb$1, /* tuple */[
                                mind,
                                ind1[1]
                              ], nargs, u1, u2, cuniv$1);
                          return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$4);
                        }
                      }
                    } else {
                      throw NotConvertible;
                    }
                    break;
                case 7 : 
                    exit$8 = 9;
                    break;
                case 11 : 
                    exit$6 = 7;
                    break;
                case 0 : 
                case 1 : 
                case 8 : 
                case 9 : 
                case 12 : 
                case 14 : 
                    exit$1 = 2;
                    break;
                default:
                  exit$2 = 3;
              }
            }
            break;
        case 5 : 
            var match$11 = match[0];
            var u1$1 = match$11[1];
            var match$12 = match$11[0];
            var j1 = match$12[1];
            var ind1$1 = match$12[0];
            if (typeof match$1 === "number") {
              exit$3 = 4;
            } else {
              switch (match$1.tag | 0) {
                case 3 : 
                    exit$4 = 5;
                    break;
                case 5 : 
                    var match$13 = match$1[0];
                    var u2$1 = match$13[1];
                    var match$14 = match$13[0];
                    if (j1 === match$14[1] && Names$ReactTemplate.eq_ind(ind1$1, match$14[0])) {
                      if (Univ$ReactTemplate.Instance[/* length */6](u1$1) === 0 || Univ$ReactTemplate.Instance[/* length */6](u2$1) === 0) {
                        var cuniv$5 = convert_instances(/* false */0, u1$1, u2$1, cuniv$1);
                        return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$5);
                      } else {
                        var mind$1 = Environ$ReactTemplate.lookup_mind(ind1$1[0], CClosure$ReactTemplate.info_env(infos$1[/* cnv_inf */0]));
                        var nargs$1 = CClosure$ReactTemplate.stack_args_size(v1);
                        if (nargs$1 !== CClosure$ReactTemplate.stack_args_size(v2)) {
                          throw NotConvertible;
                        } else {
                          var cuniv$6 = convert_constructors(/* tuple */[
                                mind$1,
                                ind1$1[1],
                                j1
                              ], nargs$1, u1$1, u2$1, cuniv$1);
                          return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$6);
                        }
                      }
                    } else {
                      throw NotConvertible;
                    }
                    break;
                case 7 : 
                    exit$8 = 9;
                    break;
                case 11 : 
                    exit$6 = 7;
                    break;
                default:
                  exit$3 = 4;
              }
            }
            break;
        case 7 : 
            var c1 = match[1];
            var p1 = match[0];
            var exit$10 = 0;
            if (typeof match$1 === "number") {
              exit$10 = 10;
            } else if (match$1.tag === 7) {
              var c2 = match$1[1];
              var p2 = match$1[0];
              var match$15 = CClosure$ReactTemplate.unfold_projection(infos$1[/* cnv_inf */0], p1);
              if (match$15) {
                _param$1 = appr2$1;
                _param = /* tuple */[
                  lft1$1,
                  /* tuple */[
                    c1,
                    /* :: */[
                      match$15[0],
                      v1
                    ]
                  ]
                ];
                continue ;
                
              } else {
                var match$16 = CClosure$ReactTemplate.unfold_projection(infos$1[/* cnv_inf */0], p2);
                if (match$16) {
                  _param$1 = /* tuple */[
                    lft2$1,
                    /* tuple */[
                      c2,
                      /* :: */[
                        match$16[0],
                        v2
                      ]
                    ]
                  ];
                  _param = appr1$1;
                  continue ;
                  
                } else if (Names$ReactTemplate.Constant[/* equal */12](Names$ReactTemplate.Projection[/* constant */2](p1), Names$ReactTemplate.Projection[/* constant */2](p2)) && compare_stack_shape(v1, v2)) {
                  var el1$1 = el_stack(lft1$1, v1);
                  var el2$1 = el_stack(lft2$1, v2);
                  var u1$2 = ccnv(/* CONV */0, l2r$1, infos$1, el1$1, el2$1, c1, c2, cuniv$1);
                  return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, u1$2);
                } else {
                  throw NotConvertible;
                }
              }
            } else {
              exit$10 = 10;
            }
            if (exit$10 === 10) {
              var match$17 = CClosure$ReactTemplate.unfold_projection(infos$1[/* cnv_inf */0], p1);
              if (match$17) {
                _param$1 = appr2$1;
                _param = /* tuple */[
                  lft1$1,
                  /* tuple */[
                    c1,
                    /* :: */[
                      match$17[0],
                      v1
                    ]
                  ]
                ];
                continue ;
                
              } else if (typeof match$1 === "number") {
                throw NotConvertible;
              } else if (match$1.tag === 3) {
                var match$18 = CClosure$ReactTemplate.unfold_reference(infos$1[/* cnv_inf */0], infos$1[/* rgt_tab */2], match$1[0]);
                if (match$18) {
                  _param$1 = /* tuple */[
                    lft2$1,
                    /* tuple */[
                      match$18[0],
                      v2
                    ]
                  ];
                  _param = appr1$1;
                  continue ;
                  
                } else {
                  throw NotConvertible;
                }
              } else {
                throw NotConvertible;
              }
            }
            break;
        case 8 : 
            var e1 = match[1];
            var match$19 = match[0];
            var match$20 = match$19[1];
            var cl1 = match$20[2];
            var match$21 = match$19[0];
            if (typeof match$1 === "number") {
              exit$2 = 3;
            } else {
              switch (match$1.tag | 0) {
                case 3 : 
                    exit$4 = 5;
                    break;
                case 7 : 
                    exit$8 = 9;
                    break;
                case 8 : 
                    var e2 = match$1[1];
                    var match$22 = match$1[0];
                    var match$23 = match$22[1];
                    var match$24 = match$22[0];
                    if (match$21[1] === match$24[1] && Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
                              return +(prim === prim$1);
                            }), match$21[0], match$24[0])) {
                      var n = cl1.length;
                      var fty1 = Util$ReactTemplate.$$Array[/* map */12]((function(e1){
                          return function (param) {
                            return CClosure$ReactTemplate.mk_clos(e1, param);
                          }
                          }(e1)), match$20[1]);
                      var fty2 = Util$ReactTemplate.$$Array[/* map */12]((function(e2){
                          return function (param) {
                            return CClosure$ReactTemplate.mk_clos(e2, param);
                          }
                          }(e2)), match$23[1]);
                      var partial_arg = Esubst$ReactTemplate.subs_liftn(n, e1);
                      var fcl1 = Util$ReactTemplate.$$Array[/* map */12]((function(partial_arg){
                          return function (param) {
                            return CClosure$ReactTemplate.mk_clos(partial_arg, param);
                          }
                          }(partial_arg)), cl1);
                      var partial_arg$1 = Esubst$ReactTemplate.subs_liftn(n, e2);
                      var fcl2 = Util$ReactTemplate.$$Array[/* map */12]((function(partial_arg$1){
                          return function (param) {
                            return CClosure$ReactTemplate.mk_clos(partial_arg$1, param);
                          }
                          }(partial_arg$1)), match$23[2]);
                      var el1$2 = el_stack(lft1$1, v1);
                      var el2$2 = el_stack(lft2$1, v2);
                      var cuniv$7 = convert_vect(l2r$1, infos$1, el1$2, el2$2, fty1, fty2, cuniv$1);
                      var cuniv$8 = convert_vect(l2r$1, infos$1, Esubst$ReactTemplate.el_liftn(n, el1$2), Esubst$ReactTemplate.el_liftn(n, el2$2), fcl1, fcl2, cuniv$7);
                      return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$8);
                    } else {
                      throw NotConvertible;
                    }
                    break;
                case 11 : 
                    exit$6 = 7;
                    break;
                case 0 : 
                case 1 : 
                case 4 : 
                case 9 : 
                case 12 : 
                case 14 : 
                    exit$1 = 2;
                    break;
                default:
                  exit$2 = 3;
              }
            }
            break;
        case 9 : 
            var e1$1 = match[1];
            var match$25 = match[0];
            var match$26 = match$25[1];
            var cl1$1 = match$26[2];
            if (typeof match$1 === "number") {
              exit$2 = 3;
            } else {
              switch (match$1.tag | 0) {
                case 3 : 
                    exit$4 = 5;
                    break;
                case 7 : 
                    exit$8 = 9;
                    break;
                case 9 : 
                    var match$27 = match$1[0];
                    if (match$25[0] === match$27[0]) {
                      var e2$1 = match$1[1];
                      var match$28 = match$27[1];
                      var n$1 = cl1$1.length;
                      var fty1$1 = Util$ReactTemplate.$$Array[/* map */12]((function(e1$1){
                          return function (param) {
                            return CClosure$ReactTemplate.mk_clos(e1$1, param);
                          }
                          }(e1$1)), match$26[1]);
                      var fty2$1 = Util$ReactTemplate.$$Array[/* map */12]((function(e2$1){
                          return function (param) {
                            return CClosure$ReactTemplate.mk_clos(e2$1, param);
                          }
                          }(e2$1)), match$28[1]);
                      var partial_arg$2 = Esubst$ReactTemplate.subs_liftn(n$1, e1$1);
                      var fcl1$1 = Util$ReactTemplate.$$Array[/* map */12]((function(partial_arg$2){
                          return function (param) {
                            return CClosure$ReactTemplate.mk_clos(partial_arg$2, param);
                          }
                          }(partial_arg$2)), cl1$1);
                      var partial_arg$3 = Esubst$ReactTemplate.subs_liftn(n$1, e2$1);
                      var fcl2$1 = Util$ReactTemplate.$$Array[/* map */12]((function(partial_arg$3){
                          return function (param) {
                            return CClosure$ReactTemplate.mk_clos(partial_arg$3, param);
                          }
                          }(partial_arg$3)), match$28[2]);
                      var el1$3 = el_stack(lft1$1, v1);
                      var el2$3 = el_stack(lft2$1, v2);
                      var cuniv$9 = convert_vect(l2r$1, infos$1, el1$3, el2$3, fty1$1, fty2$1, cuniv$1);
                      var cuniv$10 = convert_vect(l2r$1, infos$1, Esubst$ReactTemplate.el_liftn(n$1, el1$3), Esubst$ReactTemplate.el_liftn(n$1, el2$3), fcl1$1, fcl2$1, cuniv$9);
                      return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$10);
                    } else {
                      throw NotConvertible;
                    }
                    break;
                case 11 : 
                    exit$6 = 7;
                    break;
                case 0 : 
                case 1 : 
                case 4 : 
                case 8 : 
                case 12 : 
                case 14 : 
                    exit$1 = 2;
                    break;
                default:
                  exit$2 = 3;
              }
            }
            break;
        case 11 : 
            if (typeof match$1 === "number") {
              exit$7 = 8;
            } else {
              switch (match$1.tag | 0) {
                case 7 : 
                    exit$8 = 9;
                    break;
                case 11 : 
                    if (!(is_empty_stack(v1) && is_empty_stack(v2))) {
                      CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("conversion was given ill-typed terms (FLambda)."));
                    }
                    var match$29 = CClosure$ReactTemplate.destFLambda(CClosure$ReactTemplate.mk_clos, hd1);
                    var match$30 = CClosure$ReactTemplate.destFLambda(CClosure$ReactTemplate.mk_clos, hd2);
                    var el1$4 = el_stack(lft1$1, v1);
                    var el2$4 = el_stack(lft2$1, v2);
                    var cuniv$11 = ccnv(/* CONV */0, l2r$1, infos$1, el1$4, el2$4, match$29[1], match$30[1], cuniv$1);
                    return ccnv(/* CONV */0, l2r$1, infos$1, Esubst$ReactTemplate.el_lift(el1$4), Esubst$ReactTemplate.el_lift(el2$4), match$29[2], match$30[2], cuniv$11);
                default:
                  exit$7 = 8;
              }
            }
            break;
        case 12 : 
            if (typeof match$1 === "number") {
              exit$2 = 3;
            } else {
              switch (match$1.tag | 0) {
                case 3 : 
                    exit$4 = 5;
                    break;
                case 7 : 
                    exit$8 = 9;
                    break;
                case 11 : 
                    exit$6 = 7;
                    break;
                case 12 : 
                    if (!(is_empty_stack(v1) && is_empty_stack(v2))) {
                      CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("conversion was given ill-typed terms (FProd)."));
                    }
                    var el1$5 = el_stack(lft1$1, v1);
                    var el2$5 = el_stack(lft2$1, v2);
                    var cuniv$12 = ccnv(/* CONV */0, l2r$1, infos$1, el1$5, el2$5, match[1], match$1[1], cuniv$1);
                    return ccnv(cv_pb$1, l2r$1, infos$1, Esubst$ReactTemplate.el_lift(el1$5), Esubst$ReactTemplate.el_lift(el2$5), match[2], match$1[2], cuniv$12);
                case 0 : 
                case 1 : 
                case 4 : 
                case 8 : 
                case 9 : 
                case 14 : 
                    exit$1 = 2;
                    break;
                default:
                  exit$2 = 3;
              }
            }
            break;
        case 14 : 
            var env1 = match[1];
            var match$31 = match[0];
            if (typeof match$1 === "number") {
              exit$2 = 3;
            } else {
              switch (match$1.tag | 0) {
                case 3 : 
                    exit$4 = 5;
                    break;
                case 7 : 
                    exit$8 = 9;
                    break;
                case 11 : 
                    exit$6 = 7;
                    break;
                case 0 : 
                case 1 : 
                case 4 : 
                case 8 : 
                case 9 : 
                case 12 : 
                    exit$1 = 2;
                    break;
                case 14 : 
                    var env2 = match$1[1];
                    var match$32 = match$1[0];
                    if (Evar$ReactTemplate.equal(match$31[0], match$32[0])) {
                      var el1$6 = el_stack(lft1$1, v1);
                      var el2$6 = el_stack(lft2$1, v2);
                      var cuniv$13 = convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, v1, v2, cuniv$1);
                      return convert_vect(l2r$1, infos$1, el1$6, el2$6, Util$ReactTemplate.$$Array[/* map */12]((function(env1){
                                    return function (param) {
                                      return CClosure$ReactTemplate.mk_clos(env1, param);
                                    }
                                    }(env1)), match$31[1]), Util$ReactTemplate.$$Array[/* map */12]((function(env2){
                                    return function (param) {
                                      return CClosure$ReactTemplate.mk_clos(env2, param);
                                    }
                                    }(env2)), match$32[1]), cuniv$13);
                    } else {
                      throw NotConvertible;
                    }
                    break;
                default:
                  exit$2 = 3;
              }
            }
            break;
        default:
          exit$8 = 9;
      }
    }
    if (exit$8 === 9) {
      if (typeof match$1 === "number") {
        exit$7 = 8;
      } else if (match$1.tag === 7) {
        var match$33 = CClosure$ReactTemplate.unfold_projection(infos$1[/* cnv_inf */0], match$1[0]);
        if (match$33) {
          _param$1 = /* tuple */[
            lft2$1,
            /* tuple */[
              match$1[1],
              /* :: */[
                match$33[0],
                v2
              ]
            ]
          ];
          _param = appr1$1;
          continue ;
          
        } else if (typeof match === "number") {
          throw NotConvertible;
        } else if (match.tag === 3) {
          var match$34 = CClosure$ReactTemplate.unfold_reference(infos$1[/* cnv_inf */0], infos$1[/* lft_tab */1], match[0]);
          if (match$34) {
            _param$1 = appr2$1;
            _param = /* tuple */[
              lft1$1,
              /* tuple */[
                match$34[0],
                v1
              ]
            ];
            continue ;
            
          } else {
            throw NotConvertible;
          }
        } else {
          throw NotConvertible;
        }
      } else {
        exit$7 = 8;
      }
    }
    if (exit$7 === 8) {
      if (typeof match === "number") {
        exit$6 = 7;
      } else if (match.tag === 11) {
        if (v1) {
          CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("conversion was given unreduced term (FLambda)."));
        }
        var match$35 = CClosure$ReactTemplate.destFLambda(CClosure$ReactTemplate.mk_clos, hd1);
        _param$1 = /* tuple */[
          Esubst$ReactTemplate.el_lift(lft2$1),
          /* tuple */[
            hd2,
            CClosure$ReactTemplate.eta_expand_stack(v2)
          ]
        ];
        _param = /* tuple */[
          Esubst$ReactTemplate.el_lift(lft1$1),
          /* tuple */[
            match$35[2],
            /* [] */0
          ]
        ];
        _cv_pb = /* CONV */0;
        continue ;
        
      } else {
        exit$6 = 7;
      }
    }
    if (exit$6 === 7) {
      if (typeof match$1 === "number") {
        exit$5 = 6;
      } else if (match$1.tag === 11) {
        if (v2) {
          CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("conversion was given unreduced term (FLambda)."));
        }
        var match$36 = CClosure$ReactTemplate.destFLambda(CClosure$ReactTemplate.mk_clos, hd2);
        _param$1 = /* tuple */[
          Esubst$ReactTemplate.el_lift(lft2$1),
          /* tuple */[
            match$36[2],
            /* [] */0
          ]
        ];
        _param = /* tuple */[
          Esubst$ReactTemplate.el_lift(lft1$1),
          /* tuple */[
            hd1,
            CClosure$ReactTemplate.eta_expand_stack(v1)
          ]
        ];
        _cv_pb = /* CONV */0;
        continue ;
        
      } else {
        exit$5 = 6;
      }
    }
    if (exit$5 === 6) {
      if (typeof match === "number") {
        exit$4 = 5;
      } else if (match.tag === 3) {
        var match$37 = CClosure$ReactTemplate.unfold_reference(infos$1[/* cnv_inf */0], infos$1[/* lft_tab */1], match[0]);
        if (match$37) {
          var all = CClosure$ReactTemplate.RedFlags[/* red_add_transparent */12](CClosure$ReactTemplate.all, CClosure$ReactTemplate.RedFlags[/* red_transparent */13](CClosure$ReactTemplate.info_flags(infos$1[/* cnv_inf */0])));
          var r1 = CClosure$ReactTemplate.whd_stack(CClosure$ReactTemplate.infos_with_reds(infos$1[/* cnv_inf */0], all), infos$1[/* lft_tab */1], match$37[0], v1);
          _param$1 = appr2$1;
          _param = /* tuple */[
            lft1$1,
            r1
          ];
          continue ;
          
        } else if (typeof match$1 === "number") {
          throw NotConvertible;
        } else if (match$1.tag === 5) {
          try {
            var match$38 = CClosure$ReactTemplate.eta_expand_ind_stack(CClosure$ReactTemplate.info_env(infos$1[/* cnv_inf */0]), match$1[0][0][0], hd2, v2, appr1);
            return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, match$38[1], match$38[0], cuniv$1);
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              throw NotConvertible;
            } else {
              throw exn$1;
            }
          }
        } else {
          throw NotConvertible;
        }
      } else {
        exit$4 = 5;
      }
    }
    if (exit$4 === 5) {
      if (typeof match$1 === "number") {
        exit$3 = 4;
      } else if (match$1.tag === 3) {
        var match$39 = CClosure$ReactTemplate.unfold_reference(infos$1[/* cnv_inf */0], infos$1[/* rgt_tab */2], match$1[0]);
        if (match$39) {
          var all$1 = CClosure$ReactTemplate.RedFlags[/* red_add_transparent */12](CClosure$ReactTemplate.all, CClosure$ReactTemplate.RedFlags[/* red_transparent */13](CClosure$ReactTemplate.info_flags(infos$1[/* cnv_inf */0])));
          var r2 = CClosure$ReactTemplate.whd_stack(CClosure$ReactTemplate.infos_with_reds(infos$1[/* cnv_inf */0], all$1), infos$1[/* rgt_tab */2], match$39[0], v2);
          _param$1 = /* tuple */[
            lft2$1,
            r2
          ];
          _param = appr1$1;
          continue ;
          
        } else if (typeof match === "number") {
          throw NotConvertible;
        } else if (match.tag === 5) {
          try {
            var match$40 = CClosure$ReactTemplate.eta_expand_ind_stack(CClosure$ReactTemplate.info_env(infos$1[/* cnv_inf */0]), match[0][0][0], hd1, v1, appr2);
            return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, match$40[0], match$40[1], cuniv$1);
          }
          catch (exn$2){
            if (exn$2 === Caml_builtin_exceptions.not_found) {
              throw NotConvertible;
            } else {
              throw exn$2;
            }
          }
        } else {
          throw NotConvertible;
        }
      } else {
        exit$3 = 4;
      }
    }
    if (exit$3 === 4) {
      if (typeof match === "number") {
        exit$2 = 3;
      } else if (match.tag === 5) {
        try {
          var match$41 = CClosure$ReactTemplate.eta_expand_ind_stack(CClosure$ReactTemplate.info_env(infos$1[/* cnv_inf */0]), match[0][0][0], hd1, v1, appr2);
          return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, match$41[0], match$41[1], cuniv$1);
        }
        catch (exn$3){
          if (exn$3 === Caml_builtin_exceptions.not_found) {
            throw NotConvertible;
          } else {
            throw exn$3;
          }
        }
      } else {
        exit$2 = 3;
      }
    }
    if (exit$2 === 3) {
      if (typeof match$1 === "number") {
        exit = 1;
      } else {
        switch (match$1.tag | 0) {
          case 5 : 
              try {
                var match$42 = CClosure$ReactTemplate.eta_expand_ind_stack(CClosure$ReactTemplate.info_env(infos$1[/* cnv_inf */0]), match$1[0][0][0], hd2, v2, appr1);
                return convert_stacks(l2r$1, infos$1, lft1$1, lft2$1, match$42[1], match$42[0], cuniv$1);
              }
              catch (exn$4){
                if (exn$4 === Caml_builtin_exceptions.not_found) {
                  throw NotConvertible;
                } else {
                  throw exn$4;
                }
              }
              break;
          case 0 : 
          case 1 : 
          case 4 : 
          case 8 : 
          case 9 : 
          case 12 : 
          case 14 : 
              exit$1 = 2;
              break;
          default:
            exit = 1;
        }
      }
    }
    if (exit$1 === 2) {
      if (typeof match === "number") {
        exit = 1;
      } else {
        switch (match.tag | 0) {
          case 2 : 
          case 6 : 
          case 10 : 
          case 13 : 
          case 15 : 
          case 16 : 
              exit = 1;
              break;
          default:
            throw NotConvertible;
        }
      }
    }
    if (exit === 1) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "reduction.ml",
              608,
              70
            ]
          ];
    }
    
  };
}

function convert_stacks(l2r, infos, lft1, lft2, stk1, stk2, cuniv) {
  var f = function (param, param$1, cuniv) {
    return ccnv(/* CONV */0, l2r, infos, param[0], param$1[0], param[1], param$1[1], cuniv);
  };
  var fmind = Names$ReactTemplate.eq_ind;
  var lft1$1 = lft1;
  var stk1$1 = stk1;
  var lft2$1 = lft2;
  var stk2$1 = stk2;
  var cuniv$1 = cuniv;
  var cmp_rec = function (_pstk1, _pstk2, _cuniv) {
    while(true) {
      var cuniv = _cuniv;
      var pstk2 = _pstk2;
      var pstk1 = _pstk1;
      if (pstk1) {
        if (pstk2) {
          var z2 = pstk2[0];
          var z1 = pstk1[0];
          var cu1 = cmp_rec(pstk1[1], pstk2[1], cuniv);
          var exit = 0;
          switch (z1.tag | 0) {
            case 0 : 
                if (z2.tag) {
                  exit = 1;
                } else {
                  return Util$ReactTemplate.$$Array[/* fold_right2 */39](f, z1[0], z2[0], cu1);
                }
                break;
            case 1 : 
                if (z2.tag === 1) {
                  if (Names$ReactTemplate.Constant[/* equal */12](z1[0], z2[0])) {
                    return cu1;
                  } else {
                    throw NotConvertible;
                  }
                } else {
                  exit = 1;
                }
                break;
            case 2 : 
                if (z2.tag === 2) {
                  var cu2 = Curry._3(f, z1[0], z2[0], cu1);
                  _cuniv = cu2;
                  _pstk2 = z2[1];
                  _pstk1 = z1[1];
                  continue ;
                  
                } else {
                  exit = 1;
                }
                break;
            case 3 : 
                if (z2.tag === 3) {
                  var l2 = z2[1];
                  var l1 = z1[1];
                  if (!Curry._2(fmind, z1[0][/* ci_ind */0], z2[0][/* ci_ind */0])) {
                    throw NotConvertible;
                  }
                  var cu2$1 = Curry._3(f, /* tuple */[
                        l1,
                        z1[2]
                      ], /* tuple */[
                        l2,
                        z2[2]
                      ], cu1);
                  return Util$ReactTemplate.$$Array[/* fold_right2 */39]((function(l1,l2){
                            return function (c1, c2) {
                              return Curry._2(f, /* tuple */[
                                          l1,
                                          c1
                                        ], /* tuple */[
                                          l2,
                                          c2
                                        ]);
                            }
                            }(l1,l2)), z1[3], z2[3], cu2$1);
                } else {
                  exit = 1;
                }
                break;
            
          }
          if (exit === 1) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "reduction.ml",
                    311,
                    19
                  ]
                ];
          }
          
        } else {
          return cuniv;
        }
      } else {
        return cuniv;
      }
    };
  };
  if (compare_stack_shape(stk1$1, stk2$1)) {
    return cmp_rec(pure_stack(lft1$1, stk1$1), pure_stack(lft2$1, stk2$1), cuniv$1);
  } else {
    throw NotConvertible;
  }
}

function convert_vect(l2r, infos, lft1, lft2, v1, v2, cuniv) {
  var lv1 = v1.length;
  var lv2 = v2.length;
  if (lv1 === lv2) {
    var _n = 0;
    var _cuniv = cuniv;
    while(true) {
      var cuniv$1 = _cuniv;
      var n = _n;
      if (n >= lv1) {
        return cuniv$1;
      } else {
        var cuniv$2 = ccnv(/* CONV */0, l2r, infos, lft1, lft2, Caml_array.caml_array_get(v1, n), Caml_array.caml_array_get(v2, n), cuniv$1);
        _cuniv = cuniv$2;
        _n = n + 1 | 0;
        continue ;
        
      }
    };
  } else {
    throw NotConvertible;
  }
}

function clos_gen_conv(trans, cv_pb, l2r, evars, env, univs, t1, t2) {
  var reds = CClosure$ReactTemplate.RedFlags[/* red_add_transparent */12](CClosure$ReactTemplate.betaiotazeta, trans);
  var infos = CClosure$ReactTemplate.create_clos_infos(/* Some */[evars], reds, env);
  var infos_001 = /* lft_tab */CClosure$ReactTemplate.create_tab(/* () */0);
  var infos_002 = /* rgt_tab */CClosure$ReactTemplate.create_tab(/* () */0);
  var infos$1 = /* record */[
    /* cnv_inf */infos,
    infos_001,
    infos_002
  ];
  return ccnv(cv_pb, l2r, infos$1, Esubst$ReactTemplate.el_id, Esubst$ReactTemplate.el_id, CClosure$ReactTemplate.inject(t1), CClosure$ReactTemplate.inject(t2), univs);
}

function check_eq(univs, u, u$prime) {
  if (UGraph$ReactTemplate.check_eq(univs, u, u$prime)) {
    return 0;
  } else {
    throw NotConvertible;
  }
}

function check_leq(univs, u, u$prime) {
  if (UGraph$ReactTemplate.check_leq(univs, u, u$prime)) {
    return 0;
  } else {
    throw NotConvertible;
  }
}

function check_sort_cmp_universes(env, pb, s0, s1, univs) {
  if (s0.tag) {
    var u = s0[0];
    if (s1.tag) {
      var u2 = s1[0];
      if (Environ$ReactTemplate.type_in_type(env)) {
        return 0;
      } else if (pb !== 0) {
        return check_leq(univs, u, u2);
      } else {
        return check_eq(univs, u, u2);
      }
    } else {
      throw NotConvertible;
    }
  } else {
    var c1 = s0[0];
    if (s1.tag) {
      var u$1 = s1[0];
      if (Environ$ReactTemplate.type_in_type(env)) {
        return 0;
      } else {
        var u0 = Sorts$ReactTemplate.univ_of_sort(s0);
        if (pb !== 0) {
          return check_leq(univs, u0, u$1);
        } else {
          return check_eq(univs, u0, u$1);
        }
      }
    } else {
      var c2 = s1[0];
      if (is_cumul(pb)) {
        if (c1 !== 0) {
          return /* () */0;
        } else if (c2 !== 0) {
          throw NotConvertible;
        } else {
          return /* () */0;
        }
      } else if (c1 !== c2) {
        throw NotConvertible;
      } else {
        return 0;
      }
    }
  }
}

function checked_sort_cmp_universes(env, pb, s0, s1, univs) {
  check_sort_cmp_universes(env, pb, s0, s1, univs);
  return univs;
}

function check_convert_instances(_, u, u$prime, univs) {
  if (UGraph$ReactTemplate.check_eq_instances(univs, u, u$prime)) {
    return univs;
  } else {
    throw NotConvertible;
  }
}

function check_inductive_instances(cv_pb, variance, u1, u2, univs) {
  var csts = get_cumulativity_constraints(cv_pb, variance, u1, u2);
  if (UGraph$ReactTemplate.check_constraints(csts, univs)) {
    return univs;
  } else {
    throw NotConvertible;
  }
}

var checked_universes = /* record */[
  /* compare_sorts */checked_sort_cmp_universes,
  /* compare_instances */check_convert_instances,
  /* compare_cumul_instances */check_inductive_instances
];

function infer_eq(cuniv, u, u$prime) {
  var univs = cuniv[0];
  if (UGraph$ReactTemplate.check_eq(univs, u, u$prime)) {
    return cuniv;
  } else {
    return /* tuple */[
            univs,
            Univ$ReactTemplate.enforce_eq(u, u$prime, cuniv[1])
          ];
  }
}

function infer_leq(cuniv, u, u$prime) {
  var univs = cuniv[0];
  if (UGraph$ReactTemplate.check_leq(univs, u, u$prime)) {
    return cuniv;
  } else {
    var cstrs$prime = Univ$ReactTemplate.enforce_leq(u, u$prime, cuniv[1]);
    return /* tuple */[
            univs,
            cstrs$prime
          ];
  }
}

function infer_cmp_universes(env, pb, s0, s1, univs) {
  if (s0.tag) {
    var u = s0[0];
    if (s1.tag) {
      var u2 = s1[0];
      if (Environ$ReactTemplate.type_in_type(env)) {
        return univs;
      } else if (pb !== 0) {
        return infer_leq(univs, u, u2);
      } else {
        return infer_eq(univs, u, u2);
      }
    } else {
      throw NotConvertible;
    }
  } else {
    var c1 = s0[0];
    if (s1.tag) {
      var u$1 = s1[0];
      var u0 = Sorts$ReactTemplate.univ_of_sort(s0);
      if (pb !== 0) {
        return infer_leq(univs, u0, u$1);
      } else {
        return infer_eq(univs, u0, u$1);
      }
    } else {
      var c2 = s1[0];
      if (is_cumul(pb)) {
        if (c1 !== 0) {
          return univs;
        } else if (c2 !== 0) {
          throw NotConvertible;
        } else {
          return univs;
        }
      } else if (c1 === c2) {
        return univs;
      } else {
        throw NotConvertible;
      }
    }
  }
}

function infer_convert_instances(flex, u, u$prime, param) {
  var cstrs = param[1];
  var univs = param[0];
  var cstrs$prime;
  if (flex) {
    if (UGraph$ReactTemplate.check_eq_instances(univs, u, u$prime)) {
      cstrs$prime = cstrs;
    } else {
      throw NotConvertible;
    }
  } else {
    cstrs$prime = Univ$ReactTemplate.enforce_eq_instances(u, u$prime)(cstrs);
  }
  return /* tuple */[
          univs,
          cstrs$prime
        ];
}

function infer_inductive_instances(cv_pb, variance, u1, u2, param) {
  var csts = get_cumulativity_constraints(cv_pb, variance, u1, u2);
  return /* tuple */[
          param[0],
          Curry._2(Univ$ReactTemplate.Constraint[/* union */6], csts, param[1])
        ];
}

var inferred_universes = /* record */[
  /* compare_sorts */infer_cmp_universes,
  /* compare_instances */infer_convert_instances,
  /* compare_cumul_instances */infer_inductive_instances
];

function gen_conv(cv_pb, l2r, reds, env, evars, univs, t1, t2) {
  var b = cv_pb === /* CUMUL */1 ? Constr$ReactTemplate.leq_constr_univs(univs, t1, t2) : Constr$ReactTemplate.eq_constr_univs(univs, t1, t2);
  if (b) {
    return /* () */0;
  } else {
    clos_gen_conv(reds, cv_pb, l2r, evars, env, /* tuple */[
          univs,
          checked_universes
        ], t1, t2);
    return /* () */0;
  }
}

function gen_conv$1(cv_pb, $staropt$star, $staropt$star$1, env, $staropt$star$2) {
  var l2r = $staropt$star ? $staropt$star[0] : /* false */0;
  var reds = $staropt$star$1 ? $staropt$star$1[0] : Names$ReactTemplate.full_transparent_state;
  var evars = $staropt$star$2 ? $staropt$star$2[0] : /* tuple */[
      (function () {
          return /* None */0;
        }),
      Environ$ReactTemplate.universes(env)
    ];
  var univs = evars[1];
  var evars$1 = evars[0];
  if (Flags$ReactTemplate.profile) {
    var fconv_universes_key = CProfile$ReactTemplate.declare_profile("trans_fconv_universes");
    return Curry._6(CProfile$ReactTemplate.profile8(fconv_universes_key, gen_conv), cv_pb, l2r, reds, env, evars$1, univs);
  } else {
    return (function (param, param$1) {
        return gen_conv(cv_pb, l2r, reds, env, evars$1, univs, param, param$1);
      });
  }
}

function conv(param, param$1, param$2, param$3) {
  return gen_conv$1(/* CONV */0, param, param$1, param$2, param$3);
}

function conv_leq(param, param$1, param$2, param$3) {
  return gen_conv$1(/* CUMUL */1, param, param$1, param$2, param$3);
}

function generic_conv(cv_pb, l2r, evars, reds, env, univs, t1, t2) {
  return clos_gen_conv(reds, cv_pb, l2r, evars, env, univs, t1, t2)[0];
}

function infer_conv_universes(cv_pb, l2r, evars, reds, env, univs, t1, t2) {
  var match = cv_pb === /* CUMUL */1 ? Constr$ReactTemplate.leq_constr_univs_infer(univs, t1, t2) : Constr$ReactTemplate.eq_constr_univs_infer(univs, t1, t2);
  if (match[0]) {
    return match[1];
  } else {
    var univs_000 = /* tuple */[
      univs,
      Univ$ReactTemplate.Constraint[/* empty */0]
    ];
    var univs$1 = /* tuple */[
      univs_000,
      inferred_universes
    ];
    var match$1 = clos_gen_conv(reds, cv_pb, l2r, evars, env, univs$1, t1, t2);
    return match$1[0][1];
  }
}

var infer_conv_universes$1;

if (Flags$ReactTemplate.profile) {
  var infer_conv_universes_key = CProfile$ReactTemplate.declare_profile("infer_conv_universes");
  infer_conv_universes$1 = CProfile$ReactTemplate.profile8(infer_conv_universes_key, infer_conv_universes);
} else {
  infer_conv_universes$1 = infer_conv_universes;
}

function infer_conv($staropt$star, $staropt$star$1, $staropt$star$2, env, univs, t1, t2) {
  var l2r = $staropt$star ? $staropt$star[0] : /* false */0;
  var evars = $staropt$star$1 ? $staropt$star$1[0] : (function () {
        return /* None */0;
      });
  var ts = $staropt$star$2 ? $staropt$star$2[0] : Names$ReactTemplate.full_transparent_state;
  return Curry._8(infer_conv_universes$1, /* CONV */0, l2r, evars, ts, env, univs, t1, t2);
}

function infer_conv_leq($staropt$star, $staropt$star$1, $staropt$star$2, env, univs, t1, t2) {
  var l2r = $staropt$star ? $staropt$star[0] : /* false */0;
  var evars = $staropt$star$1 ? $staropt$star$1[0] : (function () {
        return /* None */0;
      });
  var ts = $staropt$star$2 ? $staropt$star$2[0] : Names$ReactTemplate.full_transparent_state;
  return Curry._8(infer_conv_universes$1, /* CUMUL */1, l2r, evars, ts, env, univs, t1, t2);
}

var vm_conv = [(function (cv_pb, env) {
      return gen_conv$1(cv_pb, /* None */0, /* None */0, env, /* Some */[/* tuple */[
                    (function () {
                        return /* None */0;
                      }),
                    Environ$ReactTemplate.universes(env)
                  ]]);
    })];

var warn_bytecode_compiler_failed = CWarnings$ReactTemplate.create("bytecode-compiler-failed", "bytecode-compiler", /* None */0, (function () {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Bytecode compiler failed, "), Pp$ReactTemplate.strbrk("falling back to standard conversion"));
      }));

function set_vm_conv(f) {
  vm_conv[0] = f;
  return /* () */0;
}

function vm_conv$1(cv_pb, env, t1, t2) {
  try {
    return Curry._4(vm_conv[0], cv_pb, env, t1, t2);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    var exit = 0;
    if (exn === Caml_builtin_exceptions.not_found) {
      exit = 1;
    } else if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      exit = 1;
    } else {
      throw exn;
    }
    if (exit === 1) {
      warn_bytecode_compiler_failed(/* None */0, /* () */0);
      return Curry._2(gen_conv$1(cv_pb, /* None */0, /* None */0, env, /* None */0), t1, t2);
    }
    
  }
}

function default_conv(cv_pb, _, env, t1, t2) {
  return Curry._2(gen_conv$1(cv_pb, /* None */0, /* None */0, env, /* None */0), t1, t2);
}

function default_conv_leq(param, param$1, param$2, param$3) {
  return default_conv(/* CUMUL */1, param, param$1, param$2, param$3);
}

function beta_applist(c, l) {
  var _subst = /* [] */0;
  var _c = c;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var c$1 = _c;
    var subst = _subst;
    var match = Constr$ReactTemplate.kind(c$1);
    if (match.tag === 7) {
      if (l$1) {
        _l = l$1[1];
        _c = match[2];
        _subst = /* :: */[
          l$1[0],
          subst
        ];
        continue ;
        
      } else {
        return Term$ReactTemplate.applist(/* tuple */[
                    Vars$ReactTemplate.substl(subst, c$1),
                    l$1
                  ]);
      }
    } else {
      return Term$ReactTemplate.applist(/* tuple */[
                  Vars$ReactTemplate.substl(subst, c$1),
                  l$1
                ]);
    }
  };
}

function beta_appvect(c, v) {
  return beta_applist(c, Util$ReactTemplate.$$Array[/* to_list */9](v));
}

function beta_app(c, a) {
  return beta_applist(c, /* :: */[
              a,
              /* [] */0
            ]);
}

function hnf_prod_applist(env, t, nl) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                var env$1 = env;
                var t = param;
                var n = param$1;
                var match = Constr$ReactTemplate.kind(whd_all(env$1, t));
                if (match.tag === 6) {
                  return Vars$ReactTemplate.subst1(n, match[2]);
                } else {
                  return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["hnf_prod_app"], Pp$ReactTemplate.str("Need a product."));
                }
              }), t, nl);
}

function hnf_prod_applist_assum(env, n, c, l) {
  var _n = n;
  var _subst = /* [] */0;
  var _t = c;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var t = _t;
    var subst = _subst;
    var n$1 = _n;
    if (n$1) {
      var match = Constr$ReactTemplate.kind(whd_allnolet(env, t));
      var exit = 0;
      switch (match.tag | 0) {
        case 6 : 
            if (l$1) {
              _l = l$1[1];
              _t = match[2];
              _subst = /* :: */[
                l$1[0],
                subst
              ];
              _n = n$1 - 1 | 0;
              continue ;
              
            } else {
              exit = 1;
            }
            break;
        case 8 : 
            _t = match[3];
            _subst = /* :: */[
              Vars$ReactTemplate.substl(subst, match[1]),
              subst
            ];
            _n = n$1 - 1 | 0;
            continue ;
            default:
          exit = 1;
      }
      if (exit === 1) {
        if (l$1) {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough prod/let's."));
        } else {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough arguments."));
        }
      }
      
    } else if (l$1) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Too many arguments."));
    } else {
      return Vars$ReactTemplate.substl(subst, t);
    }
  };
}

function dest_prod(env) {
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _env = env;
      var _m = partial_arg;
      var _c = param;
      while(true) {
        var c = _c;
        var m = _m;
        var env$1 = _env;
        var t = whd_all(env$1, c);
        var match = Constr$ReactTemplate.kind(t);
        if (match.tag === 6) {
          var d_000 = match[0];
          var d_001 = match[1];
          var d = /* LocalAssum */Block.__(0, [
              d_000,
              d_001
            ]);
          _c = match[2];
          _m = Context$ReactTemplate.Rel[/* add */2](d, m);
          _env = Environ$ReactTemplate.push_rel(d, env$1);
          continue ;
          
        } else {
          return /* tuple */[
                  m,
                  t
                ];
        }
      };
    });
}

function dest_prod_assum(env) {
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _env = env;
      var _l = partial_arg;
      var _ty = param;
      while(true) {
        var ty = _ty;
        var l = _l;
        var env$1 = _env;
        var rty = whd_allnolet(env$1, ty);
        var match = Constr$ReactTemplate.kind(rty);
        switch (match.tag | 0) {
          case 6 : 
              var d_000 = match[0];
              var d_001 = match[1];
              var d = /* LocalAssum */Block.__(0, [
                  d_000,
                  d_001
                ]);
              _ty = match[2];
              _l = Context$ReactTemplate.Rel[/* add */2](d, l);
              _env = Environ$ReactTemplate.push_rel(d, env$1);
              continue ;
              case 8 : 
              var d_000$1 = match[0];
              var d_001$1 = match[1];
              var d_002 = match[2];
              var d$1 = /* LocalDef */Block.__(1, [
                  d_000$1,
                  d_001$1,
                  d_002
                ]);
              _ty = match[3];
              _l = Context$ReactTemplate.Rel[/* add */2](d$1, l);
              _env = Environ$ReactTemplate.push_rel(d$1, env$1);
              continue ;
              default:
            var rty$prime = whd_all(env$1, rty);
            if (Constr$ReactTemplate.equal(rty$prime, rty)) {
              return /* tuple */[
                      l,
                      rty
                    ];
            } else {
              _ty = rty$prime;
              continue ;
              
            }
        }
      };
    });
}

function dest_lam_assum(env) {
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _env = env;
      var _l = partial_arg;
      var _ty = param;
      while(true) {
        var ty = _ty;
        var l = _l;
        var env$1 = _env;
        var rty = whd_allnolet(env$1, ty);
        var match = Constr$ReactTemplate.kind(rty);
        switch (match.tag | 0) {
          case 7 : 
              var d_000 = match[0];
              var d_001 = match[1];
              var d = /* LocalAssum */Block.__(0, [
                  d_000,
                  d_001
                ]);
              _ty = match[2];
              _l = Context$ReactTemplate.Rel[/* add */2](d, l);
              _env = Environ$ReactTemplate.push_rel(d, env$1);
              continue ;
              case 8 : 
              var d_000$1 = match[0];
              var d_001$1 = match[1];
              var d_002 = match[2];
              var d$1 = /* LocalDef */Block.__(1, [
                  d_000$1,
                  d_001$1,
                  d_002
                ]);
              _ty = match[3];
              _l = Context$ReactTemplate.Rel[/* add */2](d$1, l);
              _env = Environ$ReactTemplate.push_rel(d$1, env$1);
              continue ;
              default:
            return /* tuple */[
                    l,
                    rty
                  ];
        }
      };
    });
}

var NotArity = Caml_exceptions.create("Reduction-ReactTemplate.NotArity");

function dest_arity(env, c) {
  var match = dest_prod_assum(env)(c);
  var match$1 = Constr$ReactTemplate.kind(match[1]);
  if (match$1.tag === 4) {
    return /* tuple */[
            match[0],
            match$1[0]
          ];
  } else {
    throw NotArity;
  }
}

function is_arity(env, c) {
  try {
    dest_arity(env, c);
    return /* true */1;
  }
  catch (exn){
    if (exn === NotArity) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

var betazeta_appvect = Term$ReactTemplate.lambda_appvect_assum;

exports.whd_betaiotazeta = whd_betaiotazeta;
exports.whd_all = whd_all;
exports.whd_allnolet = whd_allnolet;
exports.whd_betaiota = whd_betaiota;
exports.nf_betaiota = nf_betaiota;
exports.NotConvertible = NotConvertible;
exports.NotConvertibleVect = NotConvertibleVect;
exports.get_cumulativity_constraints = get_cumulativity_constraints;
exports.inductive_cumulativity_arguments = inductive_cumulativity_arguments;
exports.constructor_cumulativity_arguments = constructor_cumulativity_arguments;
exports.sort_cmp_universes = sort_cmp_universes;
exports.convert_instances = convert_instances;
exports.checked_universes = checked_universes;
exports.inferred_universes = inferred_universes;
exports.conv = conv;
exports.conv_leq = conv_leq;
exports.infer_conv = infer_conv;
exports.infer_conv_leq = infer_conv_leq;
exports.generic_conv = generic_conv;
exports.set_vm_conv = set_vm_conv;
exports.vm_conv = vm_conv$1;
exports.default_conv = default_conv;
exports.default_conv_leq = default_conv_leq;
exports.beta_applist = beta_applist;
exports.beta_appvect = beta_appvect;
exports.beta_app = beta_app;
exports.hnf_prod_applist = hnf_prod_applist;
exports.hnf_prod_applist_assum = hnf_prod_applist_assum;
exports.betazeta_appvect = betazeta_appvect;
exports.dest_prod = dest_prod;
exports.dest_prod_assum = dest_prod_assum;
exports.dest_lam_assum = dest_lam_assum;
exports.NotArity = NotArity;
exports.dest_arity = dest_arity;
exports.is_arity = is_arity;
exports.warn_bytecode_compiler_failed = warn_bytecode_compiler_failed;
/* infer_conv_universes Not a pure module */
