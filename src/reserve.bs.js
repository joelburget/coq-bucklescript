// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Detyping$ReactTemplate = require("./detyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Notation_ops$ReactTemplate = require("./notation_ops.bs.js");

function key_compare(k1, k2) {
  if (k1) {
    if (k2) {
      return Globnames$ReactTemplate.RefOrdered[/* compare */0](k1[0], k2[0]);
    } else {
      return -1;
    }
  } else if (k2) {
    return 1;
  } else {
    return 0;
  }
}

var KeyOrd = /* module */[/* compare */key_compare];

var KeyMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], KeyOrd);

function mem(id, c, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (c === match[1] && Names$ReactTemplate.Id[/* equal */0](id, match[0])) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function add(p, l) {
  if (mem(p[0], p[1], l)) {
    return l;
  } else {
    return /* :: */[
            p,
            l
          ];
  }
}

function find(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var p = param[0];
      if (Curry._2(f, p[0], p[1])) {
        return p;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function keymap_add(key, data, map) {
  var old;
  try {
    old = Curry._2(KeyMap[/* find */21], key, map);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      old = /* [] */0;
    } else {
      throw exn;
    }
  }
  return Curry._3(KeyMap[/* add */3], key, add(data, old), map);
}

var reserve_table = Summary$ReactTemplate.ref(/* None */0, "reserved-type", Names$ReactTemplate.Id[/* Map */10][/* empty */0]);

var reserve_revtable = Summary$ReactTemplate.ref(/* None */0, "reserved-type-rev", KeyMap[/* empty */0]);

function notation_constr_key(param) {
  var exit = 0;
  var ref;
  var args;
  switch (param.tag | 0) {
    case 0 : 
        return /* tuple */[
                /* RefKey */[Globnames$ReactTemplate.canonical_gr(param[0])],
                /* None */0
              ];
    case 2 : 
        var match = param[0];
        if (match.tag) {
          return /* tuple */[
                  /* Oth */0,
                  /* None */0
                ];
        } else {
          return /* tuple */[
                  /* RefKey */[Globnames$ReactTemplate.canonical_gr(match[0])],
                  /* Some */[Curry._1(Util$ReactTemplate.List[/* length */0], param[1])]
                ];
        }
        break;
    case 4 : 
        var match$1 = param[2];
        if (match$1.tag === 2) {
          var match$2 = match$1[0];
          if (match$2.tag) {
            return /* tuple */[
                    /* Oth */0,
                    /* None */0
                  ];
          } else {
            ref = match$2[0];
            args = match$1[1];
            exit = 1;
          }
        } else {
          return /* tuple */[
                  /* Oth */0,
                  /* None */0
                ];
        }
        break;
    case 7 : 
        var match$3 = param[2];
        if (match$3.tag === 2) {
          var match$4 = match$3[0];
          if (match$4.tag) {
            return /* tuple */[
                    /* Oth */0,
                    /* None */0
                  ];
          } else {
            ref = match$4[0];
            args = match$3[1];
            exit = 1;
          }
        } else {
          return /* tuple */[
                  /* Oth */0,
                  /* None */0
                ];
        }
        break;
    default:
      return /* tuple */[
              /* Oth */0,
              /* None */0
            ];
  }
  if (exit === 1) {
    return /* tuple */[
            /* RefKey */[Globnames$ReactTemplate.canonical_gr(ref)],
            /* Some */[Curry._1(Util$ReactTemplate.List[/* length */0], args)]
          ];
  }
  
}

function cache_reserved_type(param) {
  var match = param[1];
  var t = match[1];
  var id = match[0];
  var key = notation_constr_key(t)[0];
  reserve_table[0] = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, t, reserve_table[0]);
  reserve_revtable[0] = keymap_add(key, /* tuple */[
        id,
        t
      ], reserve_revtable[0]);
  return /* () */0;
}

var newrecord = Libobject$ReactTemplate.default_object("RESERVED-TYPE").slice();

var in_reserved = Libobject$ReactTemplate.declare_object((newrecord[/* cache_function */1] = cache_reserved_type, newrecord));

function declare_reserved_type(idl, t) {
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (id) {
                var param = id;
                var t$1 = t;
                var loc = param[/* loc */1];
                var id$1 = param[/* v */0];
                if (!Names$ReactTemplate.Id[/* equal */0](id$1, Nameops$ReactTemplate.root_of_id(id$1))) {
                  CErrors$ReactTemplate.user_err(loc, /* Some */["declare_reserved_type"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id$1), Pp$ReactTemplate.str(" is not reservable: it must have no trailing digits, quote, or _")));
                }
                try {
                  Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$1, reserve_table[0]);
                  CErrors$ReactTemplate.user_err(loc, /* Some */["declare_reserved_type"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id$1), Pp$ReactTemplate.str(" is already bound to a type")));
                }
                catch (exn){
                  if (exn !== Caml_builtin_exceptions.not_found) {
                    throw exn;
                  }
                  
                }
                return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(in_reserved, /* tuple */[
                                id$1,
                                t$1
                              ]));
              }), Curry._1(Util$ReactTemplate.List[/* rev */4], idl));
}

function find_reserved_type(id) {
  return Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], Nameops$ReactTemplate.root_of_id(id), reserve_table[0]);
}

function constr_key(c) {
  try {
    return /* RefKey */[Globnames$ReactTemplate.canonical_gr(Globnames$ReactTemplate.global_of_constr(Constr$ReactTemplate.decompose_app(c)[0]))];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* Oth */0;
    } else {
      throw exn;
    }
  }
}

function revert_reserved_type(t) {
  try {
    var t$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](t);
    var reserved = Curry._2(KeyMap[/* find */21], constr_key(t$1), reserve_revtable[0]);
    var t$2 = EConstr$ReactTemplate.of_constr(t$1);
    var t$3 = Detyping$ReactTemplate.detype(/* Now */0, /* None */0, /* false */0, Names$ReactTemplate.Id[/* Set */9][/* empty */0], Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, t$2);
    var filter = function (_, pat) {
      try {
        Notation_ops$ReactTemplate.match_notation_constr(/* false */0, t$3, /* tuple */[
              /* [] */0,
              pat
            ]);
        return /* true */1;
      }
      catch (exn){
        if (exn === Notation_ops$ReactTemplate.No_match) {
          return /* false */0;
        } else {
          throw exn;
        }
      }
    };
    var match = find(filter, reserved);
    return /* Name */[match[0]];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* Anonymous */0;
    } else if (exn[0] === Caml_builtin_exceptions.failure) {
      return /* Anonymous */0;
    } else {
      throw exn;
    }
  }
}

Namegen$ReactTemplate.set_reserved_typed_name(revert_reserved_type);

exports.declare_reserved_type = declare_reserved_type;
exports.find_reserved_type = find_reserved_type;
/* KeyMap Not a pure module */
