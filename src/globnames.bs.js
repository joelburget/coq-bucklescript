// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var HMap$ReactTemplate = require("./hMap.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Hashset$ReactTemplate = require("./hashset.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");

function isVarRef(param) {
  if (param.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function isConstRef(param) {
  if (param.tag === 1) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isIndRef(param) {
  if (param.tag === 2) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isConstructRef(param) {
  if (param.tag === 3) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function eq_gr(gr1, gr2) {
  if (gr1 === gr2) {
    return /* true */1;
  } else {
    switch (gr1.tag | 0) {
      case 0 : 
          if (gr2.tag) {
            return /* false */0;
          } else {
            return Names$ReactTemplate.Id[/* equal */0](gr1[0], gr2[0]);
          }
          break;
      case 1 : 
          if (gr2.tag === 1) {
            return Names$ReactTemplate.Constant[/* equal */12](gr1[0], gr2[0]);
          } else {
            return /* false */0;
          }
          break;
      case 2 : 
          if (gr2.tag === 2) {
            return Names$ReactTemplate.eq_ind(gr1[0], gr2[0]);
          } else {
            return /* false */0;
          }
          break;
      case 3 : 
          if (gr2.tag === 3) {
            return Names$ReactTemplate.eq_constructor(gr1[0], gr2[0]);
          } else {
            return /* false */0;
          }
          break;
      
    }
  }
}

function destVarRef(param) {
  if (param.tag) {
    return Pervasives.failwith("destVarRef");
  } else {
    return param[0];
  }
}

function destConstRef(param) {
  if (param.tag === 1) {
    return param[0];
  } else {
    return Pervasives.failwith("destConstRef");
  }
}

function destIndRef(param) {
  if (param.tag === 2) {
    return param[0];
  } else {
    return Pervasives.failwith("destIndRef");
  }
}

function destConstructRef(param) {
  if (param.tag === 3) {
    return param[0];
  } else {
    return Pervasives.failwith("destConstructRef");
  }
}

function subst_constructor(subst, ref) {
  var j = ref[1];
  var ind = ref[0];
  var ind$prime = Mod_subst$ReactTemplate.subst_ind(subst, ind);
  if (ind === ind$prime) {
    return /* tuple */[
            ref,
            Constr$ReactTemplate.mkConstruct(ref)
          ];
  } else {
    return /* tuple */[
            /* tuple */[
              ind$prime,
              j
            ],
            Constr$ReactTemplate.mkConstruct(/* tuple */[
                  ind$prime,
                  j
                ])
          ];
  }
}

function subst_global_reference(subst, ref) {
  switch (ref.tag | 0) {
    case 0 : 
        return ref;
    case 1 : 
        var kn = ref[0];
        var kn$prime = Mod_subst$ReactTemplate.subst_constant(subst, kn);
        if (kn === kn$prime) {
          return ref;
        } else {
          return /* ConstRef */Block.__(1, [kn$prime]);
        }
    case 2 : 
        var ind = ref[0];
        var ind$prime = Mod_subst$ReactTemplate.subst_ind(subst, ind);
        if (ind === ind$prime) {
          return ref;
        } else {
          return /* IndRef */Block.__(2, [ind$prime]);
        }
    case 3 : 
        var c = ref[0];
        var match = subst_constructor(subst, c);
        var c$prime = match[0];
        if (c$prime === c) {
          return ref;
        } else {
          return /* ConstructRef */Block.__(3, [c$prime]);
        }
    
  }
}

function subst_global(subst, ref) {
  switch (ref.tag | 0) {
    case 0 : 
        return /* tuple */[
                ref,
                Constr$ReactTemplate.mkVar(ref[0])
              ];
    case 1 : 
        var kn = ref[0];
        var match = Mod_subst$ReactTemplate.subst_con_kn(subst, kn);
        var kn$prime = match[0];
        if (kn === kn$prime) {
          return /* tuple */[
                  ref,
                  Constr$ReactTemplate.mkConst(kn)
                ];
        } else {
          return /* tuple */[
                  /* ConstRef */Block.__(1, [kn$prime]),
                  match[1]
                ];
        }
    case 2 : 
        var ind = ref[0];
        var ind$prime = Mod_subst$ReactTemplate.subst_ind(subst, ind);
        if (ind === ind$prime) {
          return /* tuple */[
                  ref,
                  Constr$ReactTemplate.mkInd(ind)
                ];
        } else {
          return /* tuple */[
                  /* IndRef */Block.__(2, [ind$prime]),
                  Constr$ReactTemplate.mkInd(ind$prime)
                ];
        }
    case 3 : 
        var c = ref[0];
        var match$1 = subst_constructor(subst, c);
        var t = match$1[1];
        var c$prime = match$1[0];
        if (c$prime === c) {
          return /* tuple */[
                  ref,
                  t
                ];
        } else {
          return /* tuple */[
                  /* ConstructRef */Block.__(3, [c$prime]),
                  t
                ];
        }
    
  }
}

function canonical_gr(param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* VarRef */Block.__(0, [param[0]]);
    case 1 : 
        return /* ConstRef */Block.__(1, [Names$ReactTemplate.Constant[/* make1 */1](Names$ReactTemplate.Constant[/* canonical */5](param[0]))]);
    case 2 : 
        var match = param[0];
        return /* IndRef */Block.__(2, [/* tuple */[
                    Names$ReactTemplate.MutInd[/* make1 */1](Names$ReactTemplate.MutInd[/* canonical */5](match[0])),
                    match[1]
                  ]]);
    case 3 : 
        var match$1 = param[0];
        var match$2 = match$1[0];
        return /* ConstructRef */Block.__(3, [/* tuple */[
                    /* tuple */[
                      Names$ReactTemplate.MutInd[/* make1 */1](Names$ReactTemplate.MutInd[/* canonical */5](match$2[0])),
                      match$2[1]
                    ],
                    match$1[1]
                  ]]);
    
  }
}

function global_of_constr(c) {
  var match = Constr$ReactTemplate.kind(c);
  switch (match.tag | 0) {
    case 1 : 
        return /* VarRef */Block.__(0, [match[0]]);
    case 10 : 
        return /* ConstRef */Block.__(1, [match[0][0]]);
    case 11 : 
        return /* IndRef */Block.__(2, [match[0][0]]);
    case 12 : 
        return /* ConstructRef */Block.__(3, [match[0][0]]);
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function is_global(c, t) {
  var match = Constr$ReactTemplate.kind(t);
  switch (c.tag | 0) {
    case 0 : 
        if (match.tag === 1) {
          return Names$ReactTemplate.Id[/* equal */0](c[0], match[0]);
        } else {
          return /* false */0;
        }
        break;
    case 1 : 
        if (match.tag === 10) {
          return Names$ReactTemplate.Constant[/* equal */12](c[0], match[0][0]);
        } else {
          return /* false */0;
        }
        break;
    case 2 : 
        if (match.tag === 11) {
          return Names$ReactTemplate.eq_ind(c[0], match[0][0]);
        } else {
          return /* false */0;
        }
        break;
    case 3 : 
        if (match.tag === 12) {
          return Names$ReactTemplate.eq_constructor(c[0], match[0][0]);
        } else {
          return /* false */0;
        }
        break;
    
  }
}

function printable_constr_of_global(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Constr$ReactTemplate.mkVar(param[0]);
    case 1 : 
        return Constr$ReactTemplate.mkConst(param[0]);
    case 2 : 
        return Constr$ReactTemplate.mkInd(param[0]);
    case 3 : 
        return Constr$ReactTemplate.mkConstruct(param[0]);
    
  }
}

function global_eq_gen(eq_cst, eq_ind, eq_cons, x, y) {
  if (x === y) {
    return /* true */1;
  } else {
    switch (x.tag | 0) {
      case 0 : 
          if (y.tag) {
            return /* false */0;
          } else {
            return Names$ReactTemplate.Id[/* equal */0](x[0], y[0]);
          }
          break;
      case 1 : 
          if (y.tag === 1) {
            return Curry._2(eq_cst, x[0], y[0]);
          } else {
            return /* false */0;
          }
          break;
      case 2 : 
          if (y.tag === 2) {
            return Curry._2(eq_ind, x[0], y[0]);
          } else {
            return /* false */0;
          }
          break;
      case 3 : 
          if (y.tag === 3) {
            return Curry._2(eq_cons, x[0], y[0]);
          } else {
            return /* false */0;
          }
          break;
      
    }
  }
}

function global_ord_gen(ord_cst, ord_ind, ord_cons, x, y) {
  if (x === y) {
    return 0;
  } else {
    switch (x.tag | 0) {
      case 0 : 
          if (y.tag) {
            return -1;
          } else {
            return Curry._2(Names$ReactTemplate.Id[/* compare */1], x[0], y[0]);
          }
          break;
      case 1 : 
          switch (y.tag | 0) {
            case 0 : 
                return 1;
            case 1 : 
                return Curry._2(ord_cst, x[0], y[0]);
            case 2 : 
            case 3 : 
                return -1;
            
          }
          break;
      case 2 : 
          switch (y.tag | 0) {
            case 0 : 
            case 1 : 
                return 1;
            case 2 : 
                return Curry._2(ord_ind, x[0], y[0]);
            case 3 : 
                return -1;
            
          }
          break;
      case 3 : 
          switch (y.tag | 0) {
            case 0 : 
            case 1 : 
            case 2 : 
                return 1;
            case 3 : 
                return Curry._2(ord_cons, x[0], y[0]);
            
          }
          break;
      
    }
  }
}

function global_hash_gen(hash_cst, hash_ind, hash_cons, gr) {
  switch (gr.tag | 0) {
    case 0 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](4, Curry._1(Names$ReactTemplate.Id[/* hash */2], gr[0]));
    case 1 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, Curry._1(hash_cst, gr[0]));
    case 2 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](2, Curry._1(hash_ind, gr[0]));
    case 3 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](3, Curry._1(hash_cons, gr[0]));
    
  }
}

function compare(gr1, gr2) {
  return global_ord_gen(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], Names$ReactTemplate.ind_ord, Names$ReactTemplate.constructor_ord, gr1, gr2);
}

function equal(gr1, gr2) {
  return global_eq_gen(Names$ReactTemplate.Constant[/* CanOrd */9][/* equal */1], Names$ReactTemplate.eq_ind, Names$ReactTemplate.eq_constructor, gr1, gr2);
}

function hash(gr) {
  return global_hash_gen(Names$ReactTemplate.Constant[/* CanOrd */9][/* hash */2], Names$ReactTemplate.ind_hash, Names$ReactTemplate.constructor_hash, gr);
}

var RefOrdered = /* module */[
  /* compare */compare,
  /* equal */equal,
  /* hash */hash
];

function compare$1(gr1, gr2) {
  return global_ord_gen(Names$ReactTemplate.Constant[/* UserOrd */10][/* compare */0], Names$ReactTemplate.ind_user_ord, Names$ReactTemplate.constructor_user_ord, gr1, gr2);
}

function equal$1(gr1, gr2) {
  return global_eq_gen(Names$ReactTemplate.Constant[/* UserOrd */10][/* equal */1], Names$ReactTemplate.eq_user_ind, Names$ReactTemplate.eq_user_constructor, gr1, gr2);
}

function hash$1(gr) {
  return global_hash_gen(Names$ReactTemplate.Constant[/* UserOrd */10][/* hash */2], Names$ReactTemplate.ind_user_hash, Names$ReactTemplate.constructor_user_hash, gr);
}

var RefOrdered_env = /* module */[
  /* compare */compare$1,
  /* equal */equal$1,
  /* hash */hash$1
];

var Refmap = HMap$ReactTemplate.Make([
      compare,
      hash
    ]);

var Refmap_env = HMap$ReactTemplate.Make([
      compare$1,
      hash$1
    ]);

function equal$2(x, y) {
  if (x === y) {
    return /* true */1;
  } else if (x.tag) {
    if (y.tag) {
      return Names$ReactTemplate.KerName[/* equal */9](x[0], y[0]);
    } else {
      return /* false */0;
    }
  } else if (y.tag) {
    return /* false */0;
  } else {
    return equal$1(x[0], y[0]);
  }
}

function compare$2(x, y) {
  if (x === y) {
    return 0;
  } else if (x.tag) {
    if (y.tag) {
      return Names$ReactTemplate.KerName[/* compare */8](x[0], y[0]);
    } else {
      return 1;
    }
  } else if (y.tag) {
    return -1;
  } else {
    return compare$1(x[0], y[0]);
  }
}

function hash$2(param) {
  if (param.tag) {
    return Hashset$ReactTemplate.Combine[/* combinesmall */1](2, Names$ReactTemplate.KerName[/* hash */10](param[0]));
  } else {
    return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, hash$1(param[0]));
  }
}

function encode_mind(dir, id) {
  return Names$ReactTemplate.MutInd[/* make2 */2](/* MPfile */Block.__(0, [dir]), Names$ReactTemplate.Label[/* of_id */5](id));
}

function encode_con(dir, id) {
  return Names$ReactTemplate.Constant[/* make2 */2](/* MPfile */Block.__(0, [dir]), Names$ReactTemplate.Label[/* of_id */5](id));
}

function check_empty_section(dp) {
  if (Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], dp)) {
    return 0;
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Section part should be empty!"));
  }
}

function decode_mind(kn) {
  var dir_of_mp = function (param) {
    switch (param.tag | 0) {
      case 0 : 
          return Names$ReactTemplate.DirPath[/* repr */4](param[0]);
      case 1 : 
          var mbid = param[0];
          var match = Names$ReactTemplate.MBId[/* repr */4](mbid);
          var id = Names$ReactTemplate.MBId[/* to_id */5](mbid);
          return /* :: */[
                  id,
                  Names$ReactTemplate.DirPath[/* repr */4](match[2])
                ];
      case 2 : 
          return /* :: */[
                  Names$ReactTemplate.Label[/* to_id */6](param[1]),
                  dir_of_mp(param[0])
                ];
      
    }
  };
  var match = Names$ReactTemplate.MutInd[/* repr3 */6](kn);
  check_empty_section(match[1]);
  return /* tuple */[
          Names$ReactTemplate.DirPath[/* make */3](dir_of_mp(match[0])),
          Names$ReactTemplate.Label[/* to_id */6](match[2])
        ];
}

function decode_con(kn) {
  var match = Names$ReactTemplate.Constant[/* repr3 */6](kn);
  var mp = match[0];
  check_empty_section(match[1]);
  switch (mp.tag | 0) {
    case 0 : 
        return /* tuple */[
                mp[0],
                Names$ReactTemplate.Label[/* to_id */6](match[2])
              ];
    case 1 : 
    case 2 : 
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("MPfile expected!"));
    
  }
}

function pop_con(con) {
  var match = Names$ReactTemplate.Constant[/* repr3 */6](con);
  return Names$ReactTemplate.Constant[/* make3 */3](match[0], Libnames$ReactTemplate.pop_dirpath(match[1]), match[2]);
}

function pop_kn(kn) {
  var match = Names$ReactTemplate.MutInd[/* repr3 */6](kn);
  return Names$ReactTemplate.MutInd[/* make3 */3](match[0], Libnames$ReactTemplate.pop_dirpath(match[1]), match[2]);
}

function pop_global_reference(param) {
  switch (param.tag | 0) {
    case 0 : 
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("VarRef not poppable."));
    case 1 : 
        return /* ConstRef */Block.__(1, [pop_con(param[0])]);
    case 2 : 
        var match = param[0];
        return /* IndRef */Block.__(2, [/* tuple */[
                    pop_kn(match[0]),
                    match[1]
                  ]]);
    case 3 : 
        var match$1 = param[0];
        var match$2 = match$1[0];
        return /* ConstructRef */Block.__(3, [/* tuple */[
                    /* tuple */[
                      pop_kn(match$2[0]),
                      match$2[1]
                    ],
                    match$1[1]
                  ]]);
    
  }
}

var reference_of_constr = global_of_constr;

var Refset = Refmap[/* Set */24];

var Refmap_000 = Refmap[0];

var Refmap_001 = Refmap[1];

var Refmap_002 = Refmap[2];

var Refmap_003 = Refmap[3];

var Refmap_004 = Refmap[4];

var Refmap_005 = Refmap[5];

var Refmap_006 = Refmap[6];

var Refmap_007 = Refmap[7];

var Refmap_008 = Refmap[8];

var Refmap_009 = Refmap[9];

var Refmap_010 = Refmap[10];

var Refmap_011 = Refmap[11];

var Refmap_012 = Refmap[12];

var Refmap_013 = Refmap[13];

var Refmap_014 = Refmap[14];

var Refmap_015 = Refmap[15];

var Refmap_016 = Refmap[16];

var Refmap_017 = Refmap[17];

var Refmap_018 = Refmap[18];

var Refmap_019 = Refmap[19];

var Refmap_020 = Refmap[20];

var Refmap_021 = Refmap[21];

var Refmap_022 = Refmap[22];

var Refmap_023 = Refmap[23];

var Refmap_024 = Refmap[25];

var Refmap_025 = Refmap[26];

var Refmap_026 = Refmap[27];

var Refmap_027 = Refmap[28];

var Refmap_028 = Refmap[29];

var Refmap_029 = Refmap[30];

var Refmap_030 = Refmap[31];

var Refmap_031 = Refmap[32];

var Refmap_032 = Refmap[33];

var Refmap_033 = Refmap[34];

var Refmap_034 = Refmap[35];

var Refmap_035 = Refmap[36];

var Refmap$1 = [
  Refmap_000,
  Refmap_001,
  Refmap_002,
  Refmap_003,
  Refmap_004,
  Refmap_005,
  Refmap_006,
  Refmap_007,
  Refmap_008,
  Refmap_009,
  Refmap_010,
  Refmap_011,
  Refmap_012,
  Refmap_013,
  Refmap_014,
  Refmap_015,
  Refmap_016,
  Refmap_017,
  Refmap_018,
  Refmap_019,
  Refmap_020,
  Refmap_021,
  Refmap_022,
  Refmap_023,
  Refmap_024,
  Refmap_025,
  Refmap_026,
  Refmap_027,
  Refmap_028,
  Refmap_029,
  Refmap_030,
  Refmap_031,
  Refmap_032,
  Refmap_033,
  Refmap_034,
  Refmap_035
];

var Refset_env = Refmap_env[/* Set */24];

var Refmap_env_000 = Refmap_env[0];

var Refmap_env_001 = Refmap_env[1];

var Refmap_env_002 = Refmap_env[2];

var Refmap_env_003 = Refmap_env[3];

var Refmap_env_004 = Refmap_env[4];

var Refmap_env_005 = Refmap_env[5];

var Refmap_env_006 = Refmap_env[6];

var Refmap_env_007 = Refmap_env[7];

var Refmap_env_008 = Refmap_env[8];

var Refmap_env_009 = Refmap_env[9];

var Refmap_env_010 = Refmap_env[10];

var Refmap_env_011 = Refmap_env[11];

var Refmap_env_012 = Refmap_env[12];

var Refmap_env_013 = Refmap_env[13];

var Refmap_env_014 = Refmap_env[14];

var Refmap_env_015 = Refmap_env[15];

var Refmap_env_016 = Refmap_env[16];

var Refmap_env_017 = Refmap_env[17];

var Refmap_env_018 = Refmap_env[18];

var Refmap_env_019 = Refmap_env[19];

var Refmap_env_020 = Refmap_env[20];

var Refmap_env_021 = Refmap_env[21];

var Refmap_env_022 = Refmap_env[22];

var Refmap_env_023 = Refmap_env[23];

var Refmap_env_024 = Refmap_env[25];

var Refmap_env_025 = Refmap_env[26];

var Refmap_env_026 = Refmap_env[27];

var Refmap_env_027 = Refmap_env[28];

var Refmap_env_028 = Refmap_env[29];

var Refmap_env_029 = Refmap_env[30];

var Refmap_env_030 = Refmap_env[31];

var Refmap_env_031 = Refmap_env[32];

var Refmap_env_032 = Refmap_env[33];

var Refmap_env_033 = Refmap_env[34];

var Refmap_env_034 = Refmap_env[35];

var Refmap_env_035 = Refmap_env[36];

var Refmap_env$1 = [
  Refmap_env_000,
  Refmap_env_001,
  Refmap_env_002,
  Refmap_env_003,
  Refmap_env_004,
  Refmap_env_005,
  Refmap_env_006,
  Refmap_env_007,
  Refmap_env_008,
  Refmap_env_009,
  Refmap_env_010,
  Refmap_env_011,
  Refmap_env_012,
  Refmap_env_013,
  Refmap_env_014,
  Refmap_env_015,
  Refmap_env_016,
  Refmap_env_017,
  Refmap_env_018,
  Refmap_env_019,
  Refmap_env_020,
  Refmap_env_021,
  Refmap_env_022,
  Refmap_env_023,
  Refmap_env_024,
  Refmap_env_025,
  Refmap_env_026,
  Refmap_env_027,
  Refmap_env_028,
  Refmap_env_029,
  Refmap_env_030,
  Refmap_env_031,
  Refmap_env_032,
  Refmap_env_033,
  Refmap_env_034,
  Refmap_env_035
];

var ExtRefOrdered = [
  compare$2,
  equal$2,
  hash$2
];

exports.isVarRef = isVarRef;
exports.isConstRef = isConstRef;
exports.isIndRef = isIndRef;
exports.isConstructRef = isConstructRef;
exports.eq_gr = eq_gr;
exports.canonical_gr = canonical_gr;
exports.destVarRef = destVarRef;
exports.destConstRef = destConstRef;
exports.destIndRef = destIndRef;
exports.destConstructRef = destConstructRef;
exports.is_global = is_global;
exports.subst_constructor = subst_constructor;
exports.subst_global = subst_global;
exports.subst_global_reference = subst_global_reference;
exports.printable_constr_of_global = printable_constr_of_global;
exports.global_of_constr = global_of_constr;
exports.reference_of_constr = reference_of_constr;
exports.RefOrdered = RefOrdered;
exports.RefOrdered_env = RefOrdered_env;
exports.Refset = Refset;
exports.Refmap = Refmap$1;
exports.Refset_env = Refset_env;
exports.Refmap_env = Refmap_env$1;
exports.ExtRefOrdered = ExtRefOrdered;
exports.encode_mind = encode_mind;
exports.decode_mind = decode_mind;
exports.encode_con = encode_con;
exports.decode_con = decode_con;
exports.pop_con = pop_con;
exports.pop_kn = pop_kn;
exports.pop_global_reference = pop_global_reference;
/* Refmap Not a pure module */
