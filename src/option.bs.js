// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

function has_some(param) {
  if (param) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_empty(param) {
  if (param) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function equal(f, x, y) {
  if (x) {
    if (y) {
      return Curry._2(f, x[0], y[0]);
    } else {
      return /* false */0;
    }
  } else if (y) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function compare(f, x, y) {
  if (x) {
    if (y) {
      return Curry._2(f, x[0], y[0]);
    } else {
      return 1;
    }
  } else if (y) {
    return -1;
  } else {
    return 0;
  }
}

function hash(f, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return 0;
  }
}

var IsNone = Caml_exceptions.create("Option-ReactTemplate.IsNone");

function get(param) {
  if (param) {
    return param[0];
  } else {
    throw IsNone;
  }
}

function make(x) {
  return /* Some */[x];
}

function bind(x, f) {
  if (x) {
    return Curry._1(f, x[0]);
  } else {
    return /* None */0;
  }
}

function init(b, x) {
  if (b) {
    return /* Some */[x];
  } else {
    return /* None */0;
  }
}

function flatten(param) {
  if (param) {
    var match = param[0];
    if (match) {
      return /* Some */[match[0]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function append(o1, o2) {
  if (o1) {
    return o1;
  } else {
    return o2;
  }
}

function iter(f, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return /* () */0;
  }
}

var Heterogeneous = Caml_exceptions.create("Option-ReactTemplate.Heterogeneous");

function iter2(f, x, y) {
  if (x) {
    if (y) {
      return Curry._2(f, x[0], y[0]);
    } else {
      throw Heterogeneous;
    }
  } else if (y) {
    throw Heterogeneous;
  } else {
    return /* () */0;
  }
}

function map(f, param) {
  if (param) {
    return /* Some */[Curry._1(f, param[0])];
  } else {
    return /* None */0;
  }
}

function smartmap(f, x) {
  if (x) {
    var y = x[0];
    var y$prime = Curry._1(f, y);
    if (y$prime === y) {
      return x;
    } else {
      return /* Some */[y$prime];
    }
  } else {
    return /* None */0;
  }
}

function fold_left(f, a, param) {
  if (param) {
    return Curry._2(f, a, param[0]);
  } else {
    return a;
  }
}

function fold_left2(f, a, x, y) {
  if (x) {
    if (y) {
      return Curry._3(f, a, x[0], y[0]);
    } else {
      throw Heterogeneous;
    }
  } else if (y) {
    throw Heterogeneous;
  } else {
    return a;
  }
}

function fold_right(f, x, a) {
  if (x) {
    return Curry._2(f, x[0], a);
  } else {
    return a;
  }
}

function fold_left_map(f, a, x) {
  if (x) {
    var match = Curry._2(f, a, x[0]);
    return /* tuple */[
            match[0],
            /* Some */[match[1]]
          ];
  } else {
    return /* tuple */[
            a,
            /* None */0
          ];
  }
}

function fold_right_map(f, x, a) {
  if (x) {
    var match = Curry._2(f, x[0], a);
    return /* tuple */[
            /* Some */[match[0]],
            match[1]
          ];
  } else {
    return /* tuple */[
            /* None */0,
            a
          ];
  }
}

function cata(f, a, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return a;
  }
}

function $$default(a, param) {
  if (param) {
    return param[0];
  } else {
    return a;
  }
}

function lift_right(f, a, param) {
  if (param) {
    return /* Some */[Curry._2(f, a, param[0])];
  } else {
    return /* None */0;
  }
}

function lift_left(f, x, a) {
  if (x) {
    return /* Some */[Curry._2(f, x[0], a)];
  } else {
    return /* None */0;
  }
}

function lift2(f, x, y) {
  if (x && y) {
    return /* Some */[Curry._2(f, x[0], y[0])];
  } else {
    return /* None */0;
  }
}

function cons(x, l) {
  if (x) {
    return /* :: */[
            x[0],
            l
          ];
  } else {
    return l;
  }
}

function flatten$1(param) {
  if (param) {
    return cons(param[0], flatten$1(param[1]));
  } else {
    return /* [] */0;
  }
}

function find(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var x = Curry._1(f, param[0]);
      if (x) {
        return x;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function map$1(f, l) {
  var aux = function (f, l) {
    if (l) {
      var match = Curry._1(f, l[0]);
      if (match) {
        return /* :: */[
                match[0],
                aux(f, l[1])
              ];
      } else {
        throw Pervasives.Exit;
      }
    } else {
      return /* [] */0;
    }
  };
  try {
    return /* Some */[aux(f, l)];
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

var List = /* module */[
  /* cons */cons,
  /* flatten */flatten$1,
  /* find */find,
  /* map */map$1
];

var fold_map = fold_left_map;

var lift = map;

exports.IsNone = IsNone;
exports.has_some = has_some;
exports.is_empty = is_empty;
exports.equal = equal;
exports.compare = compare;
exports.hash = hash;
exports.get = get;
exports.make = make;
exports.bind = bind;
exports.init = init;
exports.flatten = flatten;
exports.append = append;
exports.iter = iter;
exports.Heterogeneous = Heterogeneous;
exports.iter2 = iter2;
exports.map = map;
exports.smartmap = smartmap;
exports.fold_left = fold_left;
exports.fold_left2 = fold_left2;
exports.fold_right = fold_right;
exports.fold_left_map = fold_left_map;
exports.fold_right_map = fold_right_map;
exports.fold_map = fold_map;
exports.cata = cata;
exports.$$default = $$default;
exports.default = $$default;
exports.__esModule = true;
exports.lift = lift;
exports.lift_right = lift_right;
exports.lift_left = lift_left;
exports.lift2 = lift2;
exports.List = List;
/* No side effect */
