// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function Make(funarg) {
  var include = $$Map.Make(funarg);
  var find = include[21];
  var set = function (k, v, s) {
    if (s) {
      var h = s[4];
      var r = s[3];
      var v$prime = s[2];
      var k$prime = s[1];
      var l = s[0];
      var c = Curry._2(funarg[/* compare */0], k, k$prime);
      if (c < 0) {
        var l$prime = set(k, v, l);
        if (l === l$prime) {
          return s;
        } else {
          return /* MNode */[
                  l$prime,
                  k$prime,
                  v$prime,
                  r,
                  h
                ];
        }
      } else if (c) {
        var r$prime = set(k, v, r);
        if (r === r$prime) {
          return s;
        } else {
          return /* MNode */[
                  l,
                  k$prime,
                  v$prime,
                  r$prime,
                  h
                ];
        }
      } else if (v$prime === v) {
        return s;
      } else {
        return /* MNode */[
                l,
                k$prime,
                v,
                r,
                h
              ];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var modify = function (k, f, s) {
    if (s) {
      var h = s[4];
      var r = s[3];
      var v = s[2];
      var k$prime = s[1];
      var l = s[0];
      var c = Curry._2(funarg[/* compare */0], k, k$prime);
      if (c < 0) {
        var l$prime = modify(k, f, l);
        if (l === l$prime) {
          return s;
        } else {
          return /* MNode */[
                  l$prime,
                  k$prime,
                  v,
                  r,
                  h
                ];
        }
      } else if (c) {
        var r$prime = modify(k, f, r);
        if (r === r$prime) {
          return s;
        } else {
          return /* MNode */[
                  l,
                  k$prime,
                  v,
                  r$prime,
                  h
                ];
        }
      } else {
        var v$prime = Curry._2(f, k$prime, v);
        if (v$prime === v) {
          return s;
        } else {
          return /* MNode */[
                  l,
                  k$prime,
                  v$prime,
                  r,
                  h
                ];
        }
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var domain = function (s) {
    if (s) {
      return /* SNode */[
              domain(s[0]),
              s[1],
              domain(s[3]),
              s[4]
            ];
    } else {
      return /* SEmpty */0;
    }
  };
  var bind = function (f, s) {
    if (s) {
      var k = s[1];
      return /* MNode */[
              bind(f, s[0]),
              k,
              Curry._1(f, k),
              bind(f, s[2]),
              s[3]
            ];
    } else {
      return /* MEmpty */0;
    }
  };
  var fold_left = function (f, _s, _accu) {
    while(true) {
      var accu = _accu;
      var s = _s;
      if (s) {
        var accu$1 = Curry._3(f, s[1], s[2], fold_left(f, s[0], accu));
        _accu = accu$1;
        _s = s[3];
        continue ;
        
      } else {
        return accu;
      }
    };
  };
  var fold_right = function (f, _s, _accu) {
    while(true) {
      var accu = _accu;
      var s = _s;
      if (s) {
        var accu$1 = Curry._3(f, s[1], s[2], fold_right(f, s[3], accu));
        _accu = accu$1;
        _s = s[0];
        continue ;
        
      } else {
        return accu;
      }
    };
  };
  var smartmap = function (f, s) {
    if (s) {
      var r = s[3];
      var v = s[2];
      var l = s[0];
      var l$prime = smartmap(f, l);
      var r$prime = smartmap(f, r);
      var v$prime = Curry._1(f, v);
      if (l === l$prime && r === r$prime && v === v$prime) {
        return s;
      } else {
        return /* MNode */[
                l$prime,
                s[1],
                v$prime,
                r$prime,
                s[4]
              ];
      }
    } else {
      return /* MEmpty */0;
    }
  };
  var smartmapi = function (f, s) {
    if (s) {
      var r = s[3];
      var v = s[2];
      var k = s[1];
      var l = s[0];
      var l$prime = smartmapi(f, l);
      var r$prime = smartmapi(f, r);
      var v$prime = Curry._2(f, k, v);
      if (l === l$prime && r === r$prime && v === v$prime) {
        return s;
      } else {
        return /* MNode */[
                l$prime,
                k,
                v$prime,
                r$prime,
                s[4]
              ];
      }
    } else {
      return /* MEmpty */0;
    }
  };
  var height = function (s) {
    if (s) {
      return s[4];
    } else {
      return 0;
    }
  };
  var map = function (f, s) {
    if (s) {
      var match = Curry._2(f, s[1], s[2]);
      return /* MNode */[
              map(f, s[0]),
              match[0],
              match[1],
              map(f, s[3]),
              s[4]
            ];
    } else {
      return /* MEmpty */0;
    }
  };
  var Unsafe = /* module */[/* map */map];
  var include_010 = function (funarg) {
    var fold_left = function (f, s, accu) {
      if (s) {
        var r = s[3];
        var v = s[2];
        var k = s[1];
        return Curry._2(funarg[/* >>= */1], fold_left(f, s[0], accu), (function (accu) {
                      return Curry._2(funarg[/* >>= */1], Curry._3(f, k, v, accu), (function (accu) {
                                    return fold_left(f, r, accu);
                                  }));
                    }));
      } else {
        return Curry._1(funarg[/* return */0], accu);
      }
    };
    var fold_right = function (f, s, accu) {
      if (s) {
        var v = s[2];
        var k = s[1];
        var l = s[0];
        return Curry._2(funarg[/* >>= */1], fold_right(f, s[3], accu), (function (accu) {
                      return Curry._2(funarg[/* >>= */1], Curry._3(f, k, v, accu), (function (accu) {
                                    return fold_right(f, l, accu);
                                  }));
                    }));
      } else {
        return Curry._1(funarg[/* return */0], accu);
      }
    };
    return [
            fold_left,
            fold_left,
            fold_right
          ];
  };
  var get = function (k, m) {
    try {
      return Curry._2(find, k, m);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cMap.ml",
                219,
                47
              ]
            ];
      } else {
        throw exn;
      }
    }
  };
  return [
          include[0],
          include[1],
          include[2],
          include[3],
          include[4],
          include[5],
          include[6],
          include[7],
          include[8],
          include[9],
          include[10],
          include[11],
          include[12],
          include[13],
          include[14],
          include[15],
          include[16],
          include[17],
          include[18],
          include[19],
          include[20],
          find,
          include[22],
          include[23],
          get,
          set,
          modify,
          domain,
          bind,
          fold_left,
          fold_right,
          smartmap,
          smartmapi,
          height,
          Unsafe,
          include_010
        ];
}

exports.Make = Make;
/* No side effect */
