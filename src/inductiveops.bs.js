// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Typeops$ReactTemplate = require("./typeops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");

function type_of_inductive(env, param) {
  var ind = param[0];
  var specif = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  Typeops$ReactTemplate.check_hyps_inclusion(env, Constr$ReactTemplate.mkInd, ind, specif[0][/* mind_hyps */4]);
  return Inductive$ReactTemplate.type_of_inductive(env, /* tuple */[
              specif,
              param[1]
            ]);
}

function type_of_constructor(env, param) {
  var cstr = param[0];
  var specif = Inductive$ReactTemplate.lookup_mind_specif(env, Names$ReactTemplate.inductive_of_constructor(cstr));
  Typeops$ReactTemplate.check_hyps_inclusion(env, Constr$ReactTemplate.mkConstruct, cstr, specif[0][/* mind_hyps */4]);
  return Inductive$ReactTemplate.type_of_constructor(/* tuple */[
              cstr,
              param[1]
            ], specif);
}

function type_of_constructors(env, indu) {
  var specif = Inductive$ReactTemplate.lookup_mind_specif(env, indu[0]);
  return Inductive$ReactTemplate.type_of_constructors(indu, specif);
}

function arities_of_constructors(env, indu) {
  var specif = Inductive$ReactTemplate.lookup_mind_specif(env, indu[0]);
  return Inductive$ReactTemplate.arities_of_constructors(indu, specif);
}

function make_ind_family(param) {
  return /* tuple */[
          param[0],
          param[1]
        ];
}

function dest_ind_family(param) {
  return /* tuple */[
          param[0],
          param[1]
        ];
}

function map_ind_family(f, param) {
  return /* tuple */[
          param[0],
          Curry._2(Util$ReactTemplate.List[/* map */10], f, param[1])
        ];
}

function liftn_inductive_family(n, d) {
  return (function (param) {
      return map_ind_family((function (param) {
                    return Vars$ReactTemplate.liftn(n, d, param);
                  }), param);
    });
}

function lift_inductive_family(n) {
  return (function (param) {
      return map_ind_family((function (param) {
                    return Vars$ReactTemplate.liftn(n, 1, param);
                  }), param);
    });
}

function substnl_ind_family(l, n) {
  return (function (param) {
      return map_ind_family((function (param) {
                    return Vars$ReactTemplate.substnl(l, n, param);
                  }), param);
    });
}

function make_ind_type(param) {
  return /* IndType */[
          param[0],
          param[1]
        ];
}

function dest_ind_type(param) {
  return /* tuple */[
          param[0],
          param[1]
        ];
}

function map_inductive_type(f, param) {
  var f$prime = function (c) {
    return EConstr$ReactTemplate.Unsafe[/* to_constr */0](Curry._1(f, EConstr$ReactTemplate.of_constr(c)));
  };
  return /* IndType */[
          map_ind_family(f$prime, param[0]),
          Curry._2(Util$ReactTemplate.List[/* map */10], f, param[1])
        ];
}

function liftn_inductive_type(n, d) {
  var partial_arg = EConstr$ReactTemplate.Vars[/* liftn */1];
  var partial_arg$1 = function (param) {
    return partial_arg(n, d, param);
  };
  return (function (param) {
      return map_inductive_type(partial_arg$1, param);
    });
}

function lift_inductive_type(n) {
  return liftn_inductive_type(n, 1);
}

function substnl_ind_type(l, n) {
  var partial_arg = EConstr$ReactTemplate.Vars[/* substnl */2];
  var partial_arg$1 = function (param) {
    return partial_arg(l, n, param);
  };
  return (function (param) {
      return map_inductive_type(partial_arg$1, param);
    });
}

function mkAppliedInd(param) {
  var match = param[0];
  var ind = Util$ReactTemplate.on_snd(EConstr$ReactTemplate.EInstance[/* make */0], match[0]);
  return EConstr$ReactTemplate.applist(/* tuple */[
              EConstr$ReactTemplate.mkIndU(ind),
              Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, match[1]), param[1])
            ]);
}

function mis_is_recursive_subset(listind, rarg) {
  var one_is_rec = function (rvec) {
    return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (ra) {
                  var match = Declareops$ReactTemplate.dest_recarg(ra);
                  if (typeof match === "number" || match.tag) {
                    return /* false */0;
                  } else {
                    return Curry._2(Int$ReactTemplate.List[/* mem */0], match[0][1], listind);
                  }
                }), rvec);
  };
  return Util$ReactTemplate.$$Array[/* exists */24](one_is_rec, Declareops$ReactTemplate.dest_subterms(rarg));
}

function mis_is_recursive(param) {
  return mis_is_recursive_subset(Curry._2(Util$ReactTemplate.List[/* interval */55], 0, param[1][/* mind_ntypes */3] - 1 | 0), param[2][/* mind_recargs */11]);
}

function mis_nf_constructor_type(param, j) {
  var mip = param[2];
  var match = param[0];
  var u = match[1];
  var ind = match[0];
  var specif = mip[/* mind_nf_lc */8];
  var ntypes = param[1][/* mind_ntypes */3];
  var nconstr = mip[/* mind_consnames */3].length;
  var make_Ik = function (k) {
    return Constr$ReactTemplate.mkIndU(/* tuple */[
                /* tuple */[
                  ind[0],
                  (ntypes - k | 0) - 1 | 0
                ],
                u
              ]);
  };
  if (j > nconstr) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough constructors in the type."));
  }
  return Vars$ReactTemplate.substl(Curry._2(Util$ReactTemplate.List[/* init */46], ntypes, make_Ik), Vars$ReactTemplate.subst_instance_constr(u, Caml_array.caml_array_get(specif, j - 1 | 0)));
}

function nconstructors(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  return match[1][/* mind_consnames */3].length;
}

function nconstructors_env(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return match[1][/* mind_consnames */3].length;
}

function constructors_nrealargs(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  return match[1][/* mind_consnrealargs */9];
}

function constructors_nrealargs_env(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return match[1][/* mind_consnrealargs */9];
}

function constructors_nrealdecls(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  return match[1][/* mind_consnrealdecls */10];
}

function constructors_nrealdecls_env(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return match[1][/* mind_consnrealdecls */10];
}

function constructor_nallargs(param) {
  var match = Global$ReactTemplate.lookup_inductive(param[0]);
  return Caml_array.caml_array_get(match[1][/* mind_consnrealargs */9], param[1] - 1 | 0) + match[0][/* mind_nparams */5] | 0;
}

function constructor_nallargs_env(env, param) {
  var match = param[0];
  var mib = Environ$ReactTemplate.lookup_mind(match[0], env);
  var mip = Caml_array.caml_array_get(mib[/* mind_packets */0], match[1]);
  return Caml_array.caml_array_get(mip[/* mind_consnrealargs */9], param[1] - 1 | 0) + mib[/* mind_nparams */5] | 0;
}

function constructor_nalldecls(param) {
  var match = Global$ReactTemplate.lookup_inductive(param[0]);
  return Caml_array.caml_array_get(match[1][/* mind_consnrealdecls */10], param[1] - 1 | 0) + Curry._1(Context$ReactTemplate.Rel[/* length */3], match[0][/* mind_params_ctxt */7]) | 0;
}

function constructor_nalldecls_env(env, param) {
  var match = param[0];
  var mib = Environ$ReactTemplate.lookup_mind(match[0], env);
  var mip = Caml_array.caml_array_get(mib[/* mind_packets */0], match[1]);
  return Caml_array.caml_array_get(mip[/* mind_consnrealdecls */10], param[1] - 1 | 0) + Curry._1(Context$ReactTemplate.Rel[/* length */3], mib[/* mind_params_ctxt */7]) | 0;
}

function constructor_nrealargs(param) {
  var match = Global$ReactTemplate.lookup_inductive(param[0]);
  return Caml_array.caml_array_get(match[1][/* mind_consnrealargs */9], param[1] - 1 | 0);
}

function constructor_nrealargs_env(env, param) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, param[0]);
  return Caml_array.caml_array_get(match[1][/* mind_consnrealargs */9], param[1] - 1 | 0);
}

function constructor_nrealdecls(param) {
  var match = Global$ReactTemplate.lookup_inductive(param[0]);
  return Caml_array.caml_array_get(match[1][/* mind_consnrealdecls */10], param[1] - 1 | 0);
}

function constructor_nrealdecls_env(env, param) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, param[0]);
  return Caml_array.caml_array_get(match[1][/* mind_consnrealdecls */10], param[1] - 1 | 0);
}

function inductive_nrealargs(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  return match[1][/* mind_nrealargs */5];
}

function inductive_nrealargs_env(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return match[1][/* mind_nrealargs */5];
}

function inductive_nrealdecls(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  return match[1][/* mind_nrealdecls */6];
}

function inductive_nrealdecls_env(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return match[1][/* mind_nrealdecls */6];
}

function inductive_nallargs(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  return match[0][/* mind_nparams */5] + match[1][/* mind_nrealargs */5] | 0;
}

function inductive_nallargs_env(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return match[0][/* mind_nparams */5] + match[1][/* mind_nrealargs */5] | 0;
}

function inductive_nparams(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  return match[0][/* mind_nparams */5];
}

function inductive_nparams_env(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return match[0][/* mind_nparams */5];
}

function inductive_nparamdecls(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  return Curry._1(Context$ReactTemplate.Rel[/* length */3], match[0][/* mind_params_ctxt */7]);
}

function inductive_nparamdecls_env(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return Curry._1(Context$ReactTemplate.Rel[/* length */3], match[0][/* mind_params_ctxt */7]);
}

function inductive_nalldecls(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  return Curry._1(Context$ReactTemplate.Rel[/* length */3], match[0][/* mind_params_ctxt */7]) + match[1][/* mind_nrealdecls */6] | 0;
}

function inductive_nalldecls_env(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return Curry._1(Context$ReactTemplate.Rel[/* length */3], match[0][/* mind_params_ctxt */7]) + match[1][/* mind_nrealdecls */6] | 0;
}

function inductive_paramdecls(param) {
  var match = Global$ReactTemplate.lookup_inductive(param[0]);
  return Inductive$ReactTemplate.inductive_paramdecls(/* tuple */[
              match[0],
              param[1]
            ]);
}

function inductive_paramdecls_env(env, param) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, param[0]);
  return Inductive$ReactTemplate.inductive_paramdecls(/* tuple */[
              match[0],
              param[1]
            ]);
}

function inductive_alldecls(param) {
  var match = Global$ReactTemplate.lookup_inductive(param[0]);
  return Vars$ReactTemplate.subst_instance_context(param[1], match[1][/* mind_arity_ctxt */1]);
}

function inductive_alldecls_env(env, param) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, param[0]);
  return Vars$ReactTemplate.subst_instance_context(param[1], match[1][/* mind_arity_ctxt */1]);
}

function constructor_has_local_defs(param) {
  var j = param[1];
  var match = Global$ReactTemplate.lookup_inductive(param[0]);
  var mip = match[1];
  var mib = match[0];
  var l1 = Caml_array.caml_array_get(mip[/* mind_consnrealdecls */10], j - 1 | 0) + Curry._1(Context$ReactTemplate.Rel[/* length */3], mib[/* mind_params_ctxt */7]) | 0;
  var l2 = Declareops$ReactTemplate.recarg_length(mip[/* mind_recargs */11], j) + mib[/* mind_nparams */5] | 0;
  return +(l1 !== l2);
}

function inductive_has_local_defs(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  var mip = match[1];
  var mib = match[0];
  var l1 = Curry._1(Context$ReactTemplate.Rel[/* length */3], mib[/* mind_params_ctxt */7]) + mip[/* mind_nrealdecls */6] | 0;
  var l2 = mib[/* mind_nparams */5] + mip[/* mind_nrealargs */5] | 0;
  return +(l1 !== l2);
}

function allowed_sorts(env, ind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  return match[1][/* mind_kelim */7];
}

function projection_nparams_env(env, p) {
  return Environ$ReactTemplate.lookup_projection(p, env)[/* proj_npars */1];
}

function projection_nparams(p) {
  var env = Global$ReactTemplate.env(/* () */0);
  return Environ$ReactTemplate.lookup_projection(p, env)[/* proj_npars */1];
}

function has_dependent_elim(mib) {
  var match = mib[/* mind_record */1];
  if (match && match[0]) {
    return +(mib[/* mind_finite */2] === /* BiFinite */2);
  } else {
    return /* true */1;
  }
}

function make_case_info(env, ind, style) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  var mip = match[1];
  var ind_tags = Context$ReactTemplate.Rel[/* to_tags */11](Curry._2(Util$ReactTemplate.List[/* firstn */104], mip[/* mind_nrealdecls */6], mip[/* mind_arity_ctxt */1]));
  var cstr_tags = Util$ReactTemplate.$$Array[/* map2 */49]((function (c, n) {
          var match = Term$ReactTemplate.decompose_prod_assum(c);
          return Context$ReactTemplate.Rel[/* to_tags */11](Curry._2(Util$ReactTemplate.List[/* firstn */104], n, match[0]));
        }), mip[/* mind_nf_lc */8], mip[/* mind_consnrealdecls */10]);
  var print_info = /* record */[
    /* ind_tags */ind_tags,
    /* cstr_tags */cstr_tags,
    /* style */style
  ];
  return /* record */[
          /* ci_ind */ind,
          /* ci_npar */match[0][/* mind_nparams */5],
          /* ci_cstr_ndecls */mip[/* mind_consnrealdecls */10],
          /* ci_cstr_nargs */mip[/* mind_consnrealargs */9],
          /* ci_pp_info */print_info
        ];
}

function lift_constructor(n, cs) {
  var partial_arg = cs[/* cs_nargs */2] + 1 | 0;
  return /* record */[
          /* cs_cstr */cs[/* cs_cstr */0],
          /* cs_params */Curry._2(Util$ReactTemplate.List[/* map */10], Vars$ReactTemplate.lift(n), cs[/* cs_params */1]),
          /* cs_nargs */cs[/* cs_nargs */2],
          /* cs_args */Termops$ReactTemplate.lift_rel_context(n)(cs[/* cs_args */3]),
          /* cs_concl_realargs */Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                  return Vars$ReactTemplate.liftn(n, partial_arg, param);
                }), cs[/* cs_concl_realargs */4])
        ];
}

function instantiate_params(t, params, sign) {
  var nnonrecpar = Context$ReactTemplate.Rel[/* nhyps */5](sign) - Curry._1(Util$ReactTemplate.List[/* length */0], params) | 0;
  var match = Termops$ReactTemplate.context_chop(nnonrecpar, sign);
  var sign$1 = match[1];
  var match$1 = Term$ReactTemplate.decompose_prod_n_assum(Curry._1(Context$ReactTemplate.Rel[/* length */3], sign$1))(t);
  var subst = Vars$ReactTemplate.subst_of_rel_context_instance(sign$1, params);
  return Vars$ReactTemplate.substl(subst, match$1[1]);
}

function get_constructor(param, j) {
  var params = param[3];
  var mip = param[2];
  var mib = param[1];
  var indu = param[0];
  var u = indu[1];
  if (j > mip[/* mind_consnames */3].length) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "inductiveops.ml",
            328,
            2
          ]
        ];
  }
  var typi = mis_nf_constructor_type(/* tuple */[
        indu,
        mib,
        mip
      ], j);
  var ctx = Vars$ReactTemplate.subst_instance_context(u, mib[/* mind_params_ctxt */7]);
  var typi$1 = instantiate_params(typi, params, ctx);
  var match = Term$ReactTemplate.decompose_prod_assum(typi$1);
  var args = match[0];
  var match$1 = Constr$ReactTemplate.decompose_app(match[1]);
  var vargs = Curry._2(Util$ReactTemplate.List[/* skipn */107], Curry._1(Util$ReactTemplate.List[/* length */0], params), match$1[1]);
  return /* record */[
          /* cs_cstr : tuple */[
            Names$ReactTemplate.ith_constructor_of_inductive(indu[0], j),
            u
          ],
          /* cs_params */params,
          /* cs_nargs */Curry._1(Context$ReactTemplate.Rel[/* length */3], args),
          /* cs_args */args,
          /* cs_concl_realargs */Util$ReactTemplate.$$Array[/* of_list */10](vargs)
        ];
}

function get_constructors(env, param) {
  var params = param[1];
  var ind = param[0];
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind[0]);
  var mip = match[1];
  var mib = match[0];
  return Util$ReactTemplate.$$Array[/* init */0](mip[/* mind_consnames */3].length, (function (j) {
                return get_constructor(/* tuple */[
                            ind,
                            mib,
                            mip,
                            params
                          ], j + 1 | 0);
              }));
}

function get_projections(env, param) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, param[0][0]);
  var match$1 = match[0][/* mind_record */1];
  if (match$1) {
    var match$2 = match$1[0];
    if (match$2) {
      return /* Some */[match$2[0][1]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function make_case_or_project(env, sigma, indf, ci, pred, c, branches) {
  var projs = get_projections(env, indf);
  if (projs) {
    var ps = projs[0];
    if (branches.length !== 1) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "inductiveops.ml",
              358,
              5
            ]
          ];
    }
    var match = EConstr$ReactTemplate.destLambda(sigma, pred);
    var match$1 = dest_ind_family(indf);
    var ind = match$1[0][0];
    var match$2 = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
    if (!EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, match[2]) && !has_dependent_elim(match$2[0])) {
      CErrors$ReactTemplate.user_err(/* None */0, /* Some */["make_case_or_project"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Dependent case analysis not allowed"), Pp$ReactTemplate.str(" on inductive type ")), Names$ReactTemplate.MutInd[/* print */15](ind[0])));
    }
    var branch = Caml_array.caml_array_get(branches, 0);
    var match$3 = EConstr$ReactTemplate.decompose_lam_n_assum(sigma, ps.length, branch);
    var match$4 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, param) {
            var subst = param[1];
            var i = param[0];
            if (decl.tag) {
              return /* tuple */[
                      i,
                      /* :: */[
                        EConstr$ReactTemplate.Vars[/* substl */3](subst, decl[1]),
                        subst
                      ]
                    ];
            } else {
              var t = EConstr$ReactTemplate.mkProj(/* tuple */[
                    Names$ReactTemplate.Projection[/* make */0](Caml_array.caml_array_get(ps, i), /* true */1),
                    c
                  ]);
              return /* tuple */[
                      i + 1 | 0,
                      /* :: */[
                        t,
                        subst
                      ]
                    ];
            }
          }), match$3[0], /* tuple */[
          0,
          /* [] */0
        ]);
    return EConstr$ReactTemplate.Vars[/* substl */3](match$4[1], match$3[1]);
  } else {
    return EConstr$ReactTemplate.mkCase(/* tuple */[
                ci,
                pred,
                c,
                branches
              ]);
  }
}

function substnl_rel_context(subst, n, sign) {
  var aux = function (n, param) {
    if (param) {
      return /* :: */[
              Vars$ReactTemplate.substnl_decl(subst, n, param[0]),
              aux(n + 1 | 0, param[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  return Curry._1(Util$ReactTemplate.List[/* rev */4], aux(n, Curry._1(Util$ReactTemplate.List[/* rev */4], sign)));
}

function get_arity(env, param) {
  var params = param[1];
  var match = param[0];
  var u = match[1];
  var match$1 = Inductive$ReactTemplate.lookup_mind_specif(env, match[0]);
  var mip = match$1[1];
  var mib = match$1[0];
  var nparams = Curry._1(Util$ReactTemplate.List[/* length */0], params);
  var parsign;
  if (nparams === mib[/* mind_nparams */5]) {
    parsign = mib[/* mind_params_ctxt */7];
  } else {
    if (nparams !== mib[/* mind_nparams_rec */6]) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "inductiveops.ml",
              402,
              6
            ]
          ];
    }
    var nnonrecparamdecls = mib[/* mind_nparams */5] - mib[/* mind_nparams_rec */6] | 0;
    parsign = Termops$ReactTemplate.context_chop(nnonrecparamdecls, mib[/* mind_params_ctxt */7])[1];
  }
  var parsign$1 = Vars$ReactTemplate.subst_instance_context(u, parsign);
  var arproperlength = Curry._1(Util$ReactTemplate.List[/* length */0], mip[/* mind_arity_ctxt */1]) - Curry._1(Util$ReactTemplate.List[/* length */0], parsign$1) | 0;
  var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], arproperlength, mip[/* mind_arity_ctxt */1]);
  var subst = Vars$ReactTemplate.subst_of_rel_context_instance(parsign$1, params);
  var arsign = Vars$ReactTemplate.subst_instance_context(u, match$2[0]);
  return /* tuple */[
          substnl_rel_context(subst, 0, arsign),
          Inductive$ReactTemplate.inductive_sort_family(mip)
        ];
}

function build_dependent_constructor(cs) {
  return Term$ReactTemplate.applist(/* tuple */[
              Constr$ReactTemplate.mkConstructU(cs[/* cs_cstr */0]),
              Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* map */10], Vars$ReactTemplate.lift(cs[/* cs_nargs */2]), cs[/* cs_params */1]), Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, cs[/* cs_args */3]))
            ]);
}

function build_dependent_inductive(env, indf) {
  var match = get_arity(env, indf);
  var arsign = match[0];
  var nrealargs = Curry._1(Util$ReactTemplate.List[/* length */0], arsign);
  return Term$ReactTemplate.applist(/* tuple */[
              Constr$ReactTemplate.mkIndU(indf[0]),
              Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* map */10], Vars$ReactTemplate.lift(nrealargs), indf[1]), Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, arsign))
            ]);
}

function make_arity_signature(env, sigma, dep, indf) {
  var match = get_arity(env, indf);
  var arsign = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
          return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
        }), match[0]);
  if (dep) {
    return Namegen$ReactTemplate.name_context(env, sigma, /* :: */[
                /* LocalAssum */Block.__(0, [
                    /* Anonymous */0,
                    EConstr$ReactTemplate.of_constr(build_dependent_inductive(env, indf))
                  ]),
                arsign
              ]);
  } else {
    return arsign;
  }
}

function make_arity(env, sigma, dep, indf, s) {
  return EConstr$ReactTemplate.it_mkProd_or_LetIn(EConstr$ReactTemplate.mkSort(s), make_arity_signature(env, sigma, dep, indf));
}

function build_branch_type(env, sigma, dep, p, cs) {
  var base = Term$ReactTemplate.appvect(/* tuple */[
        Vars$ReactTemplate.lift(cs[/* cs_nargs */2])(p),
        cs[/* cs_concl_realargs */4]
      ]);
  if (dep) {
    return EConstr$ReactTemplate.Unsafe[/* to_constr */0](Namegen$ReactTemplate.it_mkProd_or_LetIn_name(env, sigma, EConstr$ReactTemplate.of_constr(Term$ReactTemplate.applist(/* tuple */[
                            base,
                            /* :: */[
                              build_dependent_constructor(cs),
                              /* [] */0
                            ]
                          ])), Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
                          return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
                        }), cs[/* cs_args */3])));
  } else {
    return Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, base, cs[/* cs_args */3]);
  }
}

function extract_mrectype(sigma, t) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
  if (match$1.tag === 11) {
    return /* tuple */[
            match$1[0],
            match[1]
          ];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_mrectype_vect(env, sigma, c) {
  var match = Termops$ReactTemplate.decompose_app_vect(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, c));
  var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
  if (match$1.tag === 11) {
    return /* tuple */[
            match$1[0],
            match[1]
          ];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_mrectype(env, sigma, c) {
  var match = find_mrectype_vect(env, sigma, c);
  return /* tuple */[
          match[0],
          Util$ReactTemplate.$$Array[/* to_list */9](match[1])
        ];
}

function find_rectype(env, sigma, c) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, c));
  var l = match[1];
  var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
  if (match$1.tag === 11) {
    var match$2 = match$1[0];
    var ind = match$2[0];
    var match$3 = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
    var mib = match$3[0];
    if (mib[/* mind_nparams */5] > Curry._1(Util$ReactTemplate.List[/* length */0], l)) {
      throw Caml_builtin_exceptions.not_found;
    }
    var l$1 = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.Unsafe[/* to_constr */0], l);
    var match$4 = Curry._2(Util$ReactTemplate.List[/* chop */99], mib[/* mind_nparams */5], l$1);
    var indu_001 = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$2[1]);
    var indu = /* tuple */[
      ind,
      indu_001
    ];
    return /* IndType */[
            /* tuple */[
              indu,
              match$4[0]
            ],
            Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, match$4[1])
          ];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_inductive(env, sigma, c) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, c));
  var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
  if (match$1.tag === 11) {
    var ind = match$1[0];
    if (Inductive$ReactTemplate.lookup_mind_specif(env, ind[0])[0][/* mind_finite */2] !== /* CoFinite */1) {
      var l = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.Unsafe[/* to_constr */0], match[1]);
      return /* tuple */[
              ind,
              l
            ];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_coinductive(env, sigma, c) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, c));
  var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
  if (match$1.tag === 11) {
    var ind = match$1[0];
    if (Inductive$ReactTemplate.lookup_mind_specif(env, ind[0])[0][/* mind_finite */2] === /* CoFinite */1) {
      var l = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.Unsafe[/* to_constr */0], match[1]);
      return /* tuple */[
              ind,
              l
            ];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function is_elim_predicate_explicitly_dependent(env, sigma, pred, indf) {
  var match = get_arity(env, indf);
  var env$1 = env;
  var sigma$1 = sigma;
  var pred$1 = pred;
  var arsign = match[0];
  var _env = env$1;
  var _pval = EConstr$ReactTemplate.of_constr(pred$1);
  var _arsign = arsign;
  while(true) {
    var arsign$1 = _arsign;
    var pval = _pval;
    var env$2 = _env;
    var pv$prime = Reductionops$ReactTemplate.whd_all(env$2)(sigma$1, pval);
    var match$1 = EConstr$ReactTemplate.kind(sigma$1, pv$prime);
    if (match$1.tag === 7) {
      var na = match$1[0];
      if (arsign$1) {
        if (arsign$1[0].tag) {
          if (na) {
            return /* true */1;
          } else {
            return /* false */0;
          }
        } else {
          _arsign = arsign$1[1];
          _pval = match$1[2];
          _env = Termops$ReactTemplate.push_rel_assum(/* tuple */[
                na,
                match$1[1]
              ], env$2);
          continue ;
          
        }
      } else if (na) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Non eta-expanded dep-expanded \"match\" predicate."));
    }
  };
}

function set_pattern_names(env, sigma, ind, brv) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
  var mib = match[0];
  var arities = Util$ReactTemplate.$$Array[/* map */12]((function (c) {
          return Curry._1(Context$ReactTemplate.Rel[/* length */3], Term$ReactTemplate.prod_assum(c)) - mib[/* mind_nparams */5] | 0;
        }), match[1][/* mind_nf_lc */8]);
  return Util$ReactTemplate.$$Array[/* map2 */49]((function (param, param$1) {
                var env$1 = env;
                var sigma$1 = sigma;
                var n = param;
                var brty = param$1;
                var match = EConstr$ReactTemplate.decompose_prod_n_assum(sigma$1, n, brty);
                return EConstr$ReactTemplate.Unsafe[/* to_constr */0](Namegen$ReactTemplate.it_mkProd_or_LetIn_name(env$1, sigma$1, match[1], match[0]));
              }), arities, brv);
}

function type_case_branches_with_names(env, sigma, indspec, p, c) {
  var ind = indspec[0];
  var args = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.Unsafe[/* to_constr */0], indspec[1]);
  var specif = Inductive$ReactTemplate.lookup_mind_specif(env, ind[0]);
  var nparams = specif[0][/* mind_nparams */5];
  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], nparams, args);
  var params = match[0];
  var lbrty = Inductive$ReactTemplate.build_branches_type(ind, specif, params, p);
  var conclty = Term$ReactTemplate.lambda_appvect_assum(specif[1][/* mind_nrealdecls */6] + 1 | 0, p, Util$ReactTemplate.$$Array[/* of_list */10](Util$ReactTemplate.$at(match[1], /* :: */[
                c,
                /* [] */0
              ])));
  if (is_elim_predicate_explicitly_dependent(env, sigma, p, /* tuple */[
          ind,
          params
        ])) {
    return /* tuple */[
            set_pattern_names(env, sigma, ind[0], Util$ReactTemplate.$$Array[/* map */12](EConstr$ReactTemplate.of_constr, lbrty)),
            conclty
          ];
  } else {
    return /* tuple */[
            lbrty,
            conclty
          ];
  }
}

function arity_of_case_predicate(env, param, dep, k) {
  var params = param[1];
  var ind = param[0];
  var match = get_arity(env, /* tuple */[
        ind,
        params
      ]);
  var mind = build_dependent_inductive(env, /* tuple */[
        ind,
        params
      ]);
  var concl = dep ? Term$ReactTemplate.mkArrow(mind, Constr$ReactTemplate.mkSort(k)) : Constr$ReactTemplate.mkSort(k);
  return Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, concl, match[0]);
}

function instantiate_universes(env, evdref, scl, is, param) {
  var sign = param[0];
  var exit = 0;
  if (sign) {
    var d = sign[0];
    if (d.tag) {
      return /* :: */[
              d,
              instantiate_universes(env, evdref, scl, is, /* tuple */[
                    sign[1],
                    param[1]
                  ])
            ];
    } else {
      var match = param[1];
      if (match) {
        var match$1 = match[0];
        if (match$1) {
          var l = match$1[0];
          var match$2 = Reduction$ReactTemplate.dest_arity(env, d[1]);
          var u = Univ$ReactTemplate.Universe[/* make */3](l);
          var s;
          if (Univ$ReactTemplate.univ_level_mem(l, is)) {
            s = scl;
          } else {
            var match$3 = Evd$ReactTemplate.new_sort_variable(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible, evdref[0]);
            var s$1 = match$3[1];
            var evm = Evd$ReactTemplate.set_leq_sort(env, match$3[0], s$1, Sorts$ReactTemplate.sort_of_univ(u));
            evdref[0] = evm;
            s = s$1;
          }
          return /* :: */[
                  /* LocalAssum */Block.__(0, [
                      d[0],
                      Term$ReactTemplate.mkArity(/* tuple */[
                            match$2[0],
                            s
                          ])
                    ]),
                  instantiate_universes(env, evdref, scl, is, /* tuple */[
                        sign[1],
                        match[1]
                      ])
                ];
        } else {
          return /* :: */[
                  d,
                  instantiate_universes(env, evdref, scl, is, /* tuple */[
                        sign[1],
                        param[1][1]
                      ])
                ];
        }
      } else {
        exit = 1;
      }
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (param[1]) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "inductiveops.ml",
              617,
              13
            ]
          ];
    } else {
      return sign;
    }
  }
  
}

function type_of_inductive_knowing_conclusion(env, sigma, param, conclty) {
  var mip = param[0][1];
  var match = mip[/* mind_arity */2];
  if (match.tag) {
    var ar = match[0];
    var match$1 = Reductionops$ReactTemplate.splay_arity(env, sigma, conclty);
    var scl = EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match$1[1]);
    var ctx = Curry._1(Util$ReactTemplate.List[/* rev */4], mip[/* mind_arity_ctxt */1]);
    var evdref = [sigma];
    var ctx$1 = instantiate_universes(env, evdref, scl, ar[/* template_level */1], /* tuple */[
          ctx,
          ar[/* template_param_levels */0]
        ]);
    return /* tuple */[
            evdref[0],
            EConstr$ReactTemplate.of_constr(Term$ReactTemplate.mkArity(/* tuple */[
                      Curry._1(Util$ReactTemplate.List[/* rev */4], ctx$1),
                      scl
                    ]))
          ];
  } else {
    return /* tuple */[
            sigma,
            EConstr$ReactTemplate.of_constr(Vars$ReactTemplate.subst_instance_constr(param[1], match[0][/* mind_user_arity */0]))
          ];
  }
}

function type_of_projection_knowing_arg(env, sigma, p, c, ty) {
  var c$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](c);
  var match;
  try {
    match = find_rectype(env, sigma, ty);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "type_of_projection_knowing_arg_type: not an inductive type"
          ];
    } else {
      throw exn;
    }
  }
  var match$1 = dest_ind_family(match[0]);
  return Vars$ReactTemplate.substl(/* :: */[
              c$1,
              Curry._1(Util$ReactTemplate.List[/* rev */4], match$1[1])
            ], Typeops$ReactTemplate.type_of_projection_constant(env, /* tuple */[
                  p,
                  match$1[0][1]
                ]));
}

function control_only_guard(env, sigma, c) {
  var check_fix_cofix = function (e, c) {
    var match = Constr$ReactTemplate.kind(EConstr$ReactTemplate.to_constr(sigma, c));
    switch (match.tag | 0) {
      case 14 : 
          return Inductive$ReactTemplate.check_fix(e, match[0]);
      case 15 : 
          return Inductive$ReactTemplate.check_cofix(e, match[0]);
      default:
        return /* () */0;
    }
  };
  var iter = function (env, c) {
    check_fix_cofix(env, c);
    return Termops$ReactTemplate.iter_constr_with_full_binders(sigma, EConstr$ReactTemplate.push_rel, iter, env, c);
  };
  return iter(env, c);
}

exports.type_of_inductive = type_of_inductive;
exports.type_of_constructor = type_of_constructor;
exports.type_of_constructors = type_of_constructors;
exports.arities_of_constructors = arities_of_constructors;
exports.make_ind_family = make_ind_family;
exports.dest_ind_family = dest_ind_family;
exports.map_ind_family = map_ind_family;
exports.liftn_inductive_family = liftn_inductive_family;
exports.lift_inductive_family = lift_inductive_family;
exports.substnl_ind_family = substnl_ind_family;
exports.make_ind_type = make_ind_type;
exports.dest_ind_type = dest_ind_type;
exports.map_inductive_type = map_inductive_type;
exports.liftn_inductive_type = liftn_inductive_type;
exports.lift_inductive_type = lift_inductive_type;
exports.substnl_ind_type = substnl_ind_type;
exports.mkAppliedInd = mkAppliedInd;
exports.mis_is_recursive_subset = mis_is_recursive_subset;
exports.mis_is_recursive = mis_is_recursive;
exports.mis_nf_constructor_type = mis_nf_constructor_type;
exports.nconstructors = nconstructors;
exports.nconstructors_env = nconstructors_env;
exports.constructors_nrealargs = constructors_nrealargs;
exports.constructors_nrealargs_env = constructors_nrealargs_env;
exports.constructors_nrealdecls = constructors_nrealdecls;
exports.constructors_nrealdecls_env = constructors_nrealdecls_env;
exports.inductive_nrealargs = inductive_nrealargs;
exports.inductive_nrealargs_env = inductive_nrealargs_env;
exports.inductive_nrealdecls = inductive_nrealdecls;
exports.inductive_nrealdecls_env = inductive_nrealdecls_env;
exports.inductive_nallargs = inductive_nallargs;
exports.inductive_nallargs_env = inductive_nallargs_env;
exports.inductive_nalldecls = inductive_nalldecls;
exports.inductive_nalldecls_env = inductive_nalldecls_env;
exports.inductive_nparams = inductive_nparams;
exports.inductive_nparams_env = inductive_nparams_env;
exports.inductive_nparamdecls = inductive_nparamdecls;
exports.inductive_nparamdecls_env = inductive_nparamdecls_env;
exports.inductive_paramdecls = inductive_paramdecls;
exports.inductive_paramdecls_env = inductive_paramdecls_env;
exports.inductive_alldecls = inductive_alldecls;
exports.inductive_alldecls_env = inductive_alldecls_env;
exports.constructor_nallargs = constructor_nallargs;
exports.constructor_nallargs_env = constructor_nallargs_env;
exports.constructor_nalldecls = constructor_nalldecls;
exports.constructor_nalldecls_env = constructor_nalldecls_env;
exports.constructor_nrealargs = constructor_nrealargs;
exports.constructor_nrealargs_env = constructor_nrealargs_env;
exports.constructor_nrealdecls = constructor_nrealdecls;
exports.constructor_nrealdecls_env = constructor_nrealdecls_env;
exports.constructor_has_local_defs = constructor_has_local_defs;
exports.inductive_has_local_defs = inductive_has_local_defs;
exports.allowed_sorts = allowed_sorts;
exports.has_dependent_elim = has_dependent_elim;
exports.projection_nparams = projection_nparams;
exports.projection_nparams_env = projection_nparams_env;
exports.type_of_projection_knowing_arg = type_of_projection_knowing_arg;
exports.lift_constructor = lift_constructor;
exports.get_constructor = get_constructor;
exports.get_constructors = get_constructors;
exports.get_projections = get_projections;
exports.get_arity = get_arity;
exports.build_dependent_constructor = build_dependent_constructor;
exports.build_dependent_inductive = build_dependent_inductive;
exports.make_arity_signature = make_arity_signature;
exports.make_arity = make_arity;
exports.build_branch_type = build_branch_type;
exports.extract_mrectype = extract_mrectype;
exports.find_mrectype = find_mrectype;
exports.find_mrectype_vect = find_mrectype_vect;
exports.find_rectype = find_rectype;
exports.find_inductive = find_inductive;
exports.find_coinductive = find_coinductive;
exports.arity_of_case_predicate = arity_of_case_predicate;
exports.type_case_branches_with_names = type_case_branches_with_names;
exports.make_case_info = make_case_info;
exports.make_case_or_project = make_case_or_project;
exports.type_of_inductive_knowing_conclusion = type_of_inductive_knowing_conclusion;
exports.control_only_guard = control_only_guard;
/* Pp-ReactTemplate Not a pure module */
