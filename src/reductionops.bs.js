// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var UState$ReactTemplate = require("./uState.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var CClosure$ReactTemplate = require("./cClosure.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var Conv_oracle$ReactTemplate = require("./conv_oracle.bs.js");

var Elimconst = Caml_exceptions.create("Reductionops-ReactTemplate.Elimconst");

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"Generate weak constraints between Irrelevant universes",
      /* optkey : :: */[
        "Cumulativity",
        /* :: */[
          "Weak",
          /* :: */[
            "Constraints",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return 1 - UState$ReactTemplate.drop_weak_constraints[0];
        }),
      /* optwrite */(function (a) {
          UState$ReactTemplate.drop_weak_constraints[0] = 1 - a;
          return /* () */0;
        })
    ]);

var ConstrMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], [Constr$ReactTemplate.compare]);

var constant_effect_table = Summary$ReactTemplate.ref(/* None */0, "reduction-side-effect", ConstrMap[/* empty */0]);

var effect_table = Summary$ReactTemplate.ref(/* None */0, "reduction-function-effect", Util$ReactTemplate.$$String[/* Map */39][/* empty */0]);

function reduction_effect_hook(env, sigma, termkey, c) {
  try {
    var funkey = Curry._2(ConstrMap[/* find */21], termkey, constant_effect_table[0]);
    var effect = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], funkey, effect_table[0]);
    var tag = c.tag | 0;
    return Curry._3(effect, env, sigma, tag === 250 ? c[0] : (
                  tag === 246 ? CamlinternalLazy.force_lazy_block(c) : c
                ));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function cache_reduction_effect(param) {
  var match = param[1];
  constant_effect_table[0] = Curry._3(ConstrMap[/* add */3], match[0], match[1], constant_effect_table[0]);
  return /* () */0;
}

function subst_reduction_effect(param) {
  var match = param[1];
  return /* tuple */[
          Mod_subst$ReactTemplate.subst_mps(param[0], match[0]),
          match[1]
        ];
}

var init = Libobject$ReactTemplate.default_object("REDUCTION-EFFECT");

var inReductionEffect = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_reduction_effect,
      /* load_function */init[/* load_function */2],
      /* open_function */(function (i, o) {
          if (i === 1) {
            return cache_reduction_effect(o);
          } else {
            return 0;
          }
        }),
      /* classify_function */(function (o) {
          return /* Substitute */Block.__(0, [o]);
        }),
      /* subst_function */subst_reduction_effect,
      /* discharge_function */init[/* discharge_function */6],
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

function declare_reduction_effect(funkey, f) {
  if (Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* mem */2], funkey, effect_table[0])) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot redeclare effect function "), Pp$ReactTemplate.qstring(funkey)), Pp$ReactTemplate.str(".")));
  }
  effect_table[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], funkey, f, effect_table[0]);
  return /* () */0;
}

function set_reduction_effect(x, funkey) {
  var termkey = Universes$ReactTemplate.constr_of_global(x);
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inReductionEffect, /* tuple */[
                  termkey,
                  funkey
                ]));
}

var table = Summary$ReactTemplate.ref(/* None */0, "reductionbehaviour", Globnames$ReactTemplate.Refmap[/* empty */0]);

function load(_, param) {
  var match = param[1][1];
  table[0] = Curry._3(Globnames$ReactTemplate.Refmap[/* add */3], match[0], match[1], table[0]);
  return /* () */0;
}

function cache(o) {
  return load(1, o);
}

function classify(o) {
  if (o[0]) {
    return /* Substitute */Block.__(0, [o]);
  } else {
    return /* Dispose */0;
  }
}

function subst(param) {
  var orig = param[1][1];
  var r = orig[0];
  var r$prime = Globnames$ReactTemplate.subst_global(param[0], r)[0];
  return /* tuple */[
          /* ReqLocal */0,
          r === r$prime ? orig : /* tuple */[
              r$prime,
              orig[1]
            ]
        ];
}

function discharge(param) {
  var match = param[1];
  var match$1 = match[0];
  if (match$1) {
    var gr = match$1[0];
    if (gr.tag === 1) {
      var b = match[1][1];
      var b$1;
      if (Lib$ReactTemplate.is_in_section(gr)) {
        var vars = Lib$ReactTemplate.variable_section_segment_of_reference(gr);
        var extra = Curry._1(Util$ReactTemplate.List[/* length */0], vars);
        var nargs$prime = b[/* b_nargs */0] === Pervasives.max_int ? Pervasives.max_int : (
            b[/* b_nargs */0] < 0 ? b[/* b_nargs */0] : b[/* b_nargs */0] + extra | 0
          );
        var recargs$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                return extra + param | 0;
              }), b[/* b_recargs */1]);
        b$1 = /* record */[
          /* b_nargs */nargs$prime,
          /* b_recargs */recargs$prime,
          /* b_dont_expose_case */b[/* b_dont_expose_case */2]
        ];
      } else {
        b$1 = b;
      }
      var c = Lib$ReactTemplate.discharge_con(gr[0]);
      return /* Some */[/* tuple */[
                /* ReqGlobal */[
                  /* ConstRef */Block.__(1, [c]),
                  match$1[1]
                ],
                /* tuple */[
                  /* ConstRef */Block.__(1, [c]),
                  b$1
                ]
              ]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function rebuild(param) {
  var x = param[1];
  if (x[0].tag === 1) {
    return /* tuple */[
            param[0],
            x
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "reductionops.ml",
            142,
            11
          ]
        ];
  }
}

var init$1 = Libobject$ReactTemplate.default_object("REDUCTIONBEHAVIOUR");

var inRedBehaviour = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$1[/* object_name */0],
      /* cache_function */cache,
      /* load_function */load,
      /* open_function */init$1[/* open_function */3],
      /* classify_function */classify,
      /* subst_function */subst,
      /* discharge_function */discharge,
      /* rebuild_function */rebuild
    ]);

function set(local, r, req) {
  var flags = req[2];
  var nargs = Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionNeverUnfold */1012736563, flags) ? Pervasives.max_int : req[1];
  var behaviour_001 = /* b_recargs */req[0];
  var behaviour_002 = /* b_dont_expose_case */Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionDontExposeCase */-1020251784, flags);
  var behaviour = /* record */[
    /* b_nargs */nargs,
    behaviour_001,
    behaviour_002
  ];
  var req$1 = local ? /* ReqLocal */0 : /* ReqGlobal */[
      r,
      req
    ];
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inRedBehaviour, /* tuple */[
                  req$1,
                  /* tuple */[
                    r,
                    behaviour
                  ]
                ]));
}

function get(r) {
  try {
    var b = Curry._2(Globnames$ReactTemplate.Refmap[/* find */21], r, table[0]);
    var flags = b[/* b_nargs */0] === Pervasives.max_int ? /* :: */[
        /* ReductionNeverUnfold */1012736563,
        /* [] */0
      ] : (
        b[/* b_dont_expose_case */2] ? /* :: */[
            /* ReductionDontExposeCase */-1020251784,
            /* [] */0
          ] : /* [] */0
      );
    return /* Some */[/* tuple */[
              b[/* b_recargs */1],
              b[/* b_nargs */0] === Pervasives.max_int ? -1 : b[/* b_nargs */0],
              flags
            ]];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function print(ref) {
  var partial_arg = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var pr_global = function (param) {
    return Nametab$ReactTemplate.pr_global_env(partial_arg, param);
  };
  var match = get(ref);
  if (match) {
    var match$1 = match[0];
    var flags = match$1[2];
    var nargs = match$1[1];
    var recargs = match$1[0];
    var never = Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionNeverUnfold */1012736563, flags);
    var nomatch = Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionDontExposeCase */-1020251784, flags);
    var pp_nomatch = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), nomatch ? Pp$ReactTemplate.str("but avoid exposing match constructs") : Pp$ReactTemplate.str(""));
    var pp_recargs = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("when the ")), Pp$ReactTemplate.pr_enum((function (x) {
                            return Pp$ReactTemplate.pr_nth(x + 1 | 0);
                          }), recargs)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], Curry._1(Util$ReactTemplate.List[/* length */0], recargs), " argument"))), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], Curry._1(Util$ReactTemplate.List[/* length */0], recargs) >= 2 ? 1 : 2, " evaluate"))), Pp$ReactTemplate.str(" to a constructor"));
    var pp_nargs = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("when applied to ")), Pp$ReactTemplate.$$int(nargs)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], nargs, " argument")));
    return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The reduction tactics "), never !== 0 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("never unfold "), Curry._1(pr_global, ref)) : (
                      recargs ? (
                          nargs < 0 || nargs <= Curry._3(Util$ReactTemplate.List[/* fold_left */13], Caml_obj.caml_max, 0, recargs) ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("unfold "), Curry._1(pr_global, ref)), pp_recargs), pp_nomatch) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("unfold "), Curry._1(pr_global, ref)), pp_recargs), Pp$ReactTemplate.str(" and")), pp_nargs), pp_nomatch)
                        ) : (
                          nargs !== 0 ? (
                              nargs > 0 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("unfold "), Curry._1(pr_global, ref)), pp_nargs), pp_nomatch) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("unfold "), Curry._1(pr_global, ref)), pp_nomatch)
                            ) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("always unfold "), Curry._1(pr_global, ref))
                        )
                    )));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function add_param(h, cst_l) {
  var append2cst = function (param) {
    var match = param[2];
    var params = param[1];
    var c = param[0];
    if (match) {
      var q = match[1];
      var match$1 = match[0];
      var t = match$1[1];
      var i = match$1[0];
      if (i === (t.length - 1 | 0)) {
        return /* tuple */[
                c,
                params,
                q
              ];
      } else {
        return /* tuple */[
                c,
                params,
                /* :: */[
                  /* tuple */[
                    i + 1 | 0,
                    t
                  ],
                  q
                ]
              ];
      }
    } else {
      return /* tuple */[
              c,
              /* :: */[
                h,
                params
              ],
              /* [] */0
            ];
    }
  };
  var l = Curry._2(Util$ReactTemplate.List[/* map */10], append2cst, cst_l);
  if (l) {
    var q = l[1];
    if (q && !q[0][2]) {
      return q;
    } else {
      return l;
    }
  } else {
    return l;
  }
}

function add_args(cl) {
  return Curry._1(Util$ReactTemplate.List[/* map */10], (function (param) {
                return /* tuple */[
                        param[0],
                        param[1],
                        /* :: */[
                          /* tuple */[
                            0,
                            cl
                          ],
                          param[2]
                        ]
                      ];
              }));
}

function add_cst(cst, l) {
  if (l) {
    if (l[0][2]) {
      return /* :: */[
              /* tuple */[
                cst,
                /* [] */0,
                /* [] */0
              ],
              l
            ];
    } else {
      return l;
    }
  } else {
    return /* :: */[
            /* tuple */[
              cst,
              /* [] */0,
              /* [] */0
            ],
            l
          ];
  }
}

function best_cst(param) {
  if (param) {
    var match = param[0];
    if (match[2]) {
      return /* None */0;
    } else {
      return /* Some */[/* tuple */[
                match[0],
                match[1]
              ]];
    }
  } else {
    return /* None */0;
  }
}

function reference(sigma, t) {
  var match = best_cst(t);
  if (match) {
    var c = match[0][0];
    if (EConstr$ReactTemplate.isConst(sigma, c)) {
      return /* Some */[EConstr$ReactTemplate.destConst(sigma, c)[0]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function best_replace(sigma, d, cst_l, c) {
  var reconstruct_head = Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (t, param) {
          var args = param[1];
          var i = param[0];
          return EConstr$ReactTemplate.mkApp(/* tuple */[
                      t,
                      Util$ReactTemplate.$$Array[/* sub */5](args, i, args.length - i | 0)
                    ]);
        }));
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, t) {
                return Termops$ReactTemplate.replace_term(sigma, Curry._2(reconstruct_head, d, param[2]), EConstr$ReactTemplate.applist(/* tuple */[
                                param[0],
                                Curry._1(Util$ReactTemplate.List[/* rev */4], param[1])
                              ]), t);
              }), cst_l, c);
}

function pr(l) {
  var p_c = Termops$ReactTemplate.print_constr;
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_semicolon, (function (param) {
                return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), Termops$ReactTemplate.print_constr(param[0])), Pp$ReactTemplate.str(")")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.pr_sequence(p_c, param[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("(args:")), Pp$ReactTemplate.pr_sequence((function (param) {
                                          var el = param[1];
                                          var i = param[0];
                                          return Pp$ReactTemplate.prvect_with_sep(Pp$ReactTemplate.spc, p_c, Util$ReactTemplate.$$Array[/* sub */5](el, i, el.length - i | 0));
                                        }), param[2])), Pp$ReactTemplate.str(")")));
              }), l);
}

function pr_app_node(pr, param) {
  var i = param[0];
  return Pp$ReactTemplate.surround(Pp$ReactTemplate.prvect_with_sep(Pp$ReactTemplate.pr_comma, pr, Util$ReactTemplate.$$Array[/* sub */5](param[1], i, (param[2] - i | 0) + 1 | 0)));
}

function pr_member(pr_c, member) {
  var pr_c$1 = function (x) {
    return Pp$ReactTemplate.hov(1, Curry._1(pr_c, x));
  };
  switch (member.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("ZApp"), pr_app_node(pr_c$1, member[0]));
    case 1 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("ZCase("), Pp$ReactTemplate.prvect_with_sep(Pp$ReactTemplate.pr_bar, pr_c$1, member[2])), Pp$ReactTemplate.str(")"));
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("ZProj("), Pp$ReactTemplate.$$int(member[0])), Pp$ReactTemplate.pr_comma(/* () */0)), Pp$ReactTemplate.$$int(member[1])), Pp$ReactTemplate.pr_comma(/* () */0)), Names$ReactTemplate.Constant[/* print */16](Names$ReactTemplate.Projection[/* constant */2](member[2]))), Pp$ReactTemplate.str(")"));
    case 3 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("ZFix("), Termops$ReactTemplate.pr_fix(pr_c$1, member[0])), Pp$ReactTemplate.pr_comma(/* () */0)), pr$1(pr_c$1, member[1])), Pp$ReactTemplate.str(")"));
    case 4 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("ZCst("), pr_cst_member(pr_c$1, member[0])), Pp$ReactTemplate.pr_comma(/* () */0)), Pp$ReactTemplate.$$int(member[1])), Pp$ReactTemplate.pr_comma(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_semicolon, Pp$ReactTemplate.$$int, member[2])), Pp$ReactTemplate.pr_comma(/* () */0)), pr$1(pr_c$1, member[3])), Pp$ReactTemplate.str(")"));
    
  }
}

function pr$1(pr_c, l) {
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_semicolon, (function (x) {
                return Pp$ReactTemplate.hov(1, pr_member(pr_c, x));
              }), l);
}

function pr_cst_member(_, c) {
  if (c.tag) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(".("), Names$ReactTemplate.Constant[/* print */16](Names$ReactTemplate.Projection[/* constant */2](c[0]))), Pp$ReactTemplate.str(")"));
  } else {
    var match = c[0];
    var u = match[1];
    var c$1 = match[0];
    if (Univ$ReactTemplate.Instance[/* is_empty */1](u)) {
      return Names$ReactTemplate.Constant[/* print */16](c$1);
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), Names$ReactTemplate.Constant[/* print */16](c$1)), Pp$ReactTemplate.str(", ")), Univ$ReactTemplate.Instance[/* pr */11](Univ$ReactTemplate.Level[/* pr */9], /* None */0)(u)), Pp$ReactTemplate.str(")"));
    }
  }
}

function append_app(v, s) {
  var le = v.length;
  if (le) {
    return /* :: */[
            /* App */Block.__(0, [/* tuple */[
                  0,
                  v,
                  le - 1 | 0
                ]]),
            s
          ];
  } else {
    return s;
  }
}

function decomp_node(param, sk) {
  var j = param[2];
  var l = param[1];
  var i = param[0];
  if (i < j) {
    return /* tuple */[
            Caml_array.caml_array_get(l, i),
            /* :: */[
              /* App */Block.__(0, [/* tuple */[
                    i + 1 | 0,
                    l,
                    j
                  ]]),
              sk
            ]
          ];
  } else {
    return /* tuple */[
            Caml_array.caml_array_get(l, i),
            sk
          ];
  }
}

function decomp(param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      return /* None */0;
    } else {
      return /* Some */[decomp_node(match[0], param[1])];
    }
  } else {
    return /* None */0;
  }
}

function decomp_node_last(param, sk) {
  var j = param[2];
  var l = param[1];
  var i = param[0];
  if (i < j) {
    return /* tuple */[
            Caml_array.caml_array_get(l, j),
            /* :: */[
              /* App */Block.__(0, [/* tuple */[
                    i,
                    l,
                    j - 1 | 0
                  ]]),
              sk
            ]
          ];
  } else {
    return /* tuple */[
            Caml_array.caml_array_get(l, j),
            sk
          ];
  }
}

function equal(f, f_fix, sk1, sk2) {
  var equal_cst_member = function (x, y) {
    if (x.tag) {
      if (y.tag) {
        return Names$ReactTemplate.Constant[/* equal */12](Names$ReactTemplate.Projection[/* constant */2](x[0]), Names$ReactTemplate.Projection[/* constant */2](y[0]));
      } else {
        return /* false */0;
      }
    } else {
      var match = x[0];
      if (y.tag) {
        return /* false */0;
      } else {
        var match$1 = y[0];
        if (Names$ReactTemplate.Constant[/* equal */12](match[0], match$1[0])) {
          return Univ$ReactTemplate.Instance[/* equal */5](match[1], match$1[1]);
        } else {
          return /* false */0;
        }
      }
    }
  };
  var equal_rec = function (_sk1, _sk2) {
    while(true) {
      var sk2 = _sk2;
      var sk1 = _sk1;
      if (sk1) {
        var match = sk1[0];
        switch (match.tag | 0) {
          case 0 : 
              if (sk2) {
                var match$1 = sk2[0];
                if (match$1.tag) {
                  return /* false */0;
                } else {
                  var match$2 = decomp_node_last(match[0], sk1[1]);
                  var match$3 = decomp_node_last(match$1[0], sk2[1]);
                  if (Curry._2(f, match$2[0], match$3[0])) {
                    _sk2 = match$3[1];
                    _sk1 = match$2[1];
                    continue ;
                    
                  } else {
                    return /* false */0;
                  }
                }
              } else {
                return /* false */0;
              }
              break;
          case 1 : 
              if (sk2) {
                var match$4 = sk2[0];
                if (match$4.tag === 1) {
                  if (Curry._2(f, match[1], match$4[1])) {
                    if (CArray$ReactTemplate.equal(Curry.__2(f), match[2], match$4[2])) {
                      _sk2 = sk2[1];
                      _sk1 = sk1[1];
                      continue ;
                      
                    } else {
                      return /* false */0;
                    }
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
              break;
          case 2 : 
              if (sk2) {
                var match$5 = sk2[0];
                if (match$5.tag === 2) {
                  if (match[0] === match$5[0]) {
                    if (match[1] === match$5[1]) {
                      if (Names$ReactTemplate.Constant[/* equal */12](Names$ReactTemplate.Projection[/* constant */2](match[2]), Names$ReactTemplate.Projection[/* constant */2](match$5[2]))) {
                        _sk2 = sk2[1];
                        _sk1 = sk1[1];
                        continue ;
                        
                      } else {
                        return /* false */0;
                      }
                    } else {
                      return /* false */0;
                    }
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
              break;
          case 3 : 
              if (sk2) {
                var match$6 = sk2[0];
                if (match$6.tag === 3) {
                  if (Curry._2(f_fix, match[0], match$6[0])) {
                    if (equal_rec(Curry._1(Util$ReactTemplate.List[/* rev */4], match[1]), Curry._1(Util$ReactTemplate.List[/* rev */4], match$6[1]))) {
                      _sk2 = sk2[1];
                      _sk1 = sk1[1];
                      continue ;
                      
                    } else {
                      return /* false */0;
                    }
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
              break;
          case 4 : 
              if (sk2) {
                var match$7 = sk2[0];
                if (match$7.tag === 4) {
                  if (equal_cst_member(match[0], match$7[0])) {
                    if (equal_rec(Curry._1(Util$ReactTemplate.List[/* rev */4], match[3]), Curry._1(Util$ReactTemplate.List[/* rev */4], match$7[3]))) {
                      _sk2 = sk2[1];
                      _sk1 = sk1[1];
                      continue ;
                      
                    } else {
                      return /* false */0;
                    }
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
              break;
          
        }
      } else if (sk2) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    };
  };
  return equal_rec(Curry._1(Util$ReactTemplate.List[/* rev */4], sk1), Curry._1(Util$ReactTemplate.List[/* rev */4], sk2));
}

function compare_shape(stk1, stk2) {
  var compare_rec = function (_bal, _stk1, _stk2) {
    while(true) {
      var stk2 = _stk2;
      var stk1 = _stk1;
      var bal = _bal;
      var exit = 0;
      if (stk1) {
        var match = stk1[0];
        switch (match.tag | 0) {
          case 0 : 
              var match$1 = match[0];
              _stk1 = stk1[1];
              _bal = ((bal + match$1[2] | 0) + 1 | 0) - match$1[0] | 0;
              continue ;
              case 1 : 
              if (stk2) {
                switch (stk2[0].tag | 0) {
                  case 0 : 
                      exit = 1;
                      break;
                  case 1 : 
                      if (bal) {
                        return /* false */0;
                      } else {
                        _stk2 = stk2[1];
                        _stk1 = stk1[1];
                        _bal = 0;
                        continue ;
                        
                      }
                      break;
                  default:
                    return /* false */0;
                }
              } else {
                return /* false */0;
              }
              break;
          case 2 : 
              if (stk2) {
                switch (stk2[0].tag | 0) {
                  case 0 : 
                      exit = 1;
                      break;
                  case 2 : 
                      if (bal) {
                        return /* false */0;
                      } else {
                        _stk2 = stk2[1];
                        _stk1 = stk1[1];
                        _bal = 0;
                        continue ;
                        
                      }
                      break;
                  default:
                    return /* false */0;
                }
              } else {
                return /* false */0;
              }
              break;
          case 3 : 
              if (stk2) {
                var match$2 = stk2[0];
                switch (match$2.tag | 0) {
                  case 0 : 
                      exit = 1;
                      break;
                  case 3 : 
                      if (bal) {
                        return /* false */0;
                      } else if (compare_rec(0, match[1], match$2[1])) {
                        _stk2 = stk2[1];
                        _stk1 = stk1[1];
                        _bal = 0;
                        continue ;
                        
                      } else {
                        return /* false */0;
                      }
                      break;
                  default:
                    return /* false */0;
                }
              } else {
                return /* false */0;
              }
              break;
          case 4 : 
              if (stk2) {
                var match$3 = stk2[0];
                switch (match$3.tag | 0) {
                  case 0 : 
                      exit = 1;
                      break;
                  case 4 : 
                      if (bal) {
                        return /* false */0;
                      } else if (compare_rec(0, match[3], match$3[3])) {
                        _stk2 = stk2[1];
                        _stk1 = stk1[1];
                        _bal = 0;
                        continue ;
                        
                      } else {
                        return /* false */0;
                      }
                      break;
                  default:
                    return /* false */0;
                }
              } else {
                return /* false */0;
              }
              break;
          
        }
      } else if (stk2) {
        exit = 1;
      } else {
        return +(bal === 0);
      }
      if (exit === 1) {
        var match$4 = stk2[0];
        if (match$4.tag) {
          return /* false */0;
        } else {
          var match$5 = match$4[0];
          _stk2 = stk2[1];
          _bal = ((bal - match$5[2] | 0) - 1 | 0) + match$5[0] | 0;
          continue ;
          
        }
      }
      
    };
  };
  return compare_rec(0, stk1, stk2);
}

var IncompatibleFold2 = Caml_exceptions.create("Reductionops-ReactTemplate.Stack.IncompatibleFold2");

function fold2(f, o, sk1, sk2) {
  var aux = function (_o, _sk1, _sk2) {
    while(true) {
      var sk2 = _sk2;
      var sk1 = _sk1;
      var o = _o;
      if (sk1) {
        var match = sk1[0];
        switch (match.tag | 0) {
          case 0 : 
              if (sk2) {
                var match$1 = sk2[0];
                if (match$1.tag) {
                  throw IncompatibleFold2;
                } else {
                  var match$2 = decomp_node_last(match[0], sk1[1]);
                  var match$3 = decomp_node_last(match$1[0], sk2[1]);
                  _sk2 = match$3[1];
                  _sk1 = match$2[1];
                  _o = Curry._3(f, o, match$2[0], match$3[0]);
                  continue ;
                  
                }
              } else {
                throw IncompatibleFold2;
              }
              break;
          case 1 : 
              if (sk2) {
                var match$4 = sk2[0];
                if (match$4.tag === 1) {
                  _sk2 = sk2[1];
                  _sk1 = sk1[1];
                  _o = Util$ReactTemplate.$$Array[/* fold_left2 */40](f, Curry._3(f, o, match[1], match$4[1]), match[2], match$4[2]);
                  continue ;
                  
                } else {
                  throw IncompatibleFold2;
                }
              } else {
                throw IncompatibleFold2;
              }
              break;
          case 2 : 
              if (sk2) {
                if (sk2[0].tag === 2) {
                  _sk2 = sk2[1];
                  _sk1 = sk1[1];
                  continue ;
                  
                } else {
                  throw IncompatibleFold2;
                }
              } else {
                throw IncompatibleFold2;
              }
              break;
          case 3 : 
              var match$5 = match[0][1];
              if (sk2) {
                var match$6 = sk2[0];
                if (match$6.tag === 3) {
                  var match$7 = match$6[0][1];
                  var o$prime = aux(Util$ReactTemplate.$$Array[/* fold_left2 */40](f, Util$ReactTemplate.$$Array[/* fold_left2 */40](f, o, match$5[2], match$7[2]), match$5[1], match$7[1]), Curry._1(Util$ReactTemplate.List[/* rev */4], match[1]), Curry._1(Util$ReactTemplate.List[/* rev */4], match$6[1]));
                  _sk2 = sk2[1];
                  _sk1 = sk1[1];
                  _o = o$prime;
                  continue ;
                  
                } else {
                  throw IncompatibleFold2;
                }
              } else {
                throw IncompatibleFold2;
              }
              break;
          case 4 : 
              if (sk2) {
                var match$8 = sk2[0];
                if (match$8.tag === 4) {
                  var o$prime$1 = aux(o, Curry._1(Util$ReactTemplate.List[/* rev */4], match[3]), Curry._1(Util$ReactTemplate.List[/* rev */4], match$8[3]));
                  _sk2 = sk2[1];
                  _sk1 = sk1[1];
                  _o = o$prime$1;
                  continue ;
                  
                } else {
                  throw IncompatibleFold2;
                }
              } else {
                throw IncompatibleFold2;
              }
              break;
          
        }
      } else if (sk2) {
        throw IncompatibleFold2;
      } else {
        return o;
      }
    };
  };
  return aux(o, Curry._1(Util$ReactTemplate.List[/* rev */4], sk1), Curry._1(Util$ReactTemplate.List[/* rev */4], sk2));
}

function map(f, x) {
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (e) {
                switch (e.tag | 0) {
                  case 0 : 
                      var match = e[0];
                      var i = match[0];
                      var le = (match[2] - i | 0) + 1 | 0;
                      return /* App */Block.__(0, [/* tuple */[
                                  0,
                                  Util$ReactTemplate.$$Array[/* map */12](f, Util$ReactTemplate.$$Array[/* sub */5](match[1], i, le)),
                                  le - 1 | 0
                                ]]);
                  case 1 : 
                      return /* Case */Block.__(1, [
                                e[0],
                                Curry._1(f, e[1]),
                                Util$ReactTemplate.$$Array[/* map */12](f, e[2]),
                                e[3]
                              ]);
                  case 2 : 
                      return e;
                  case 3 : 
                      var match$1 = e[0];
                      var match$2 = match$1[1];
                      return /* Fix */Block.__(3, [
                                /* tuple */[
                                  match$1[0],
                                  /* tuple */[
                                    match$2[0],
                                    Util$ReactTemplate.$$Array[/* map */12](f, match$2[1]),
                                    Util$ReactTemplate.$$Array[/* map */12](f, match$2[2])
                                  ]
                                ],
                                map(f, e[1]),
                                e[2]
                              ]);
                  case 4 : 
                      return /* Cst */Block.__(4, [
                                e[0],
                                e[1],
                                e[2],
                                map(f, e[3]),
                                e[4]
                              ]);
                  
                }
              }), x);
}

function append_app_list(l, s) {
  var a = Util$ReactTemplate.$$Array[/* of_list */10](l);
  return append_app(a, s);
}

function args_size(param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      return 0;
    } else {
      var match$1 = match[0];
      return ((match$1[2] + 1 | 0) - match$1[0] | 0) + args_size(param[1]) | 0;
    }
  } else {
    return 0;
  }
}

function strip_app(s) {
  var _out = /* [] */0;
  var _s = s;
  while(true) {
    var s$1 = _s;
    var out = _out;
    if (s$1) {
      var e = s$1[0];
      if (e.tag) {
        return /* tuple */[
                Curry._1(Util$ReactTemplate.List[/* rev */4], out),
                s$1
              ];
      } else {
        _s = s$1[1];
        _out = /* :: */[
          e,
          out
        ];
        continue ;
        
      }
    } else {
      return /* tuple */[
              Curry._1(Util$ReactTemplate.List[/* rev */4], out),
              s$1
            ];
    }
  };
}

function strip_n_app(n, s) {
  var _n = n;
  var _out = /* [] */0;
  var _s = s;
  while(true) {
    var s$1 = _s;
    var out = _out;
    var n$1 = _n;
    if (s$1) {
      var e = s$1[0];
      if (e.tag) {
        return /* None */0;
      } else {
        var s$2 = s$1[1];
        var match = e[0];
        var j = match[2];
        var a = match[1];
        var i = match[0];
        var nb = (j - i | 0) + 1 | 0;
        if (n$1 >= nb) {
          _s = s$2;
          _out = /* :: */[
            e,
            out
          ];
          _n = n$1 - nb | 0;
          continue ;
          
        } else {
          var p = i + n$1 | 0;
          return /* Some */[/* tuple */[
                    CList$ReactTemplate.rev(n$1 ? /* :: */[
                            /* App */Block.__(0, [/* tuple */[
                                  i,
                                  a,
                                  p - 1 | 0
                                ]]),
                            out
                          ] : out),
                    Caml_array.caml_array_get(a, p),
                    j > p ? /* :: */[
                        /* App */Block.__(0, [/* tuple */[
                              p + 1 | 0,
                              a,
                              j
                            ]]),
                        s$2
                      ] : s$2
                  ]];
        }
      }
    } else {
      return /* None */0;
    }
  };
}

function not_purely_applicative(args) {
  return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                if (param.tag) {
                  return /* true */1;
                } else {
                  return /* false */0;
                }
              }), args);
}

function will_expose_iota(args) {
  return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                var exit = 0;
                var l;
                switch (param.tag | 0) {
                  case 0 : 
                      return /* false */0;
                  case 1 : 
                  case 2 : 
                      l = param[3];
                      exit = 1;
                      break;
                  case 3 : 
                      l = param[2];
                      exit = 1;
                      break;
                  case 4 : 
                      l = param[4];
                      exit = 1;
                      break;
                  
                }
                if (exit === 1) {
                  if (CList$ReactTemplate.is_empty(l)) {
                    return /* true */1;
                  } else {
                    return /* false */0;
                  }
                }
                
              }), args);
}

function list_of_app_stack(s) {
  var aux = function (s) {
    if (s) {
      var match = s[0];
      if (match.tag) {
        return /* tuple */[
                /* [] */0,
                s
              ];
      } else {
        var match$1 = match[0];
        var i = match$1[0];
        var match$2 = aux(s[1]);
        var a$prime = Util$ReactTemplate.$$Array[/* sub */5](match$1[1], i, (match$1[2] - i | 0) + 1 | 0);
        return /* tuple */[
                Util$ReactTemplate.$$Array[/* fold_right */16]((function (x, y) {
                        return /* :: */[
                                x,
                                y
                              ];
                      }), a$prime, match$2[0]),
                match$2[1]
              ];
      }
    } else {
      return /* tuple */[
              /* [] */0,
              s
            ];
    }
  };
  var match = aux(s);
  var init = match[1] ? /* false */0 : /* true */1;
  return Option$ReactTemplate.init(init, match[0]);
}

function assign(s, p, c) {
  var match = strip_n_app(p, s);
  if (match) {
    var match$1 = match[0];
    return Util$ReactTemplate.$at(match$1[0], /* :: */[
                /* App */Block.__(0, [/* tuple */[
                      0,
                      /* array */[c],
                      0
                    ]]),
                match$1[2]
              ]);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "reductionops.ml",
            533,
            14
          ]
        ];
  }
}

function tail(n0, s0) {
  var _n = n0;
  var _s = s0;
  while(true) {
    var s = _s;
    var n = _n;
    if (n) {
      if (s) {
        var match = s[0];
        if (match.tag) {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "Reductionops.Stack.tail"
              ];
        } else {
          var s$1 = s[1];
          var match$1 = match[0];
          var j = match$1[2];
          var i = match$1[0];
          var nb = (j - i | 0) + 1 | 0;
          if (n >= nb) {
            _s = s$1;
            _n = n - nb | 0;
            continue ;
            
          } else {
            var p = i + n | 0;
            if (j >= p) {
              return /* :: */[
                      /* App */Block.__(0, [/* tuple */[
                            p,
                            match$1[1],
                            j
                          ]]),
                      s$1
                    ];
            } else {
              return s$1;
            }
          }
        }
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Reductionops.Stack.tail"
            ];
      }
    } else {
      return s;
    }
  };
}

function nth(s, p) {
  var match = strip_n_app(p, s);
  if (match) {
    return match[0][1];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function best_state(sigma, s, l) {
  var sk = s[1];
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                var _sk = sk;
                var def = param;
                var _param = param$1;
                while(true) {
                  var param$2 = _param;
                  var sk$1 = _sk;
                  var match = param$2[2];
                  var params = param$2[1];
                  var cst = param$2[0];
                  if (match) {
                    var q = match[1];
                    var match$1 = match[0];
                    var t = match$1[1];
                    var i = match$1[0];
                    var match$2 = decomp(sk$1);
                    if (match$2) {
                      var match$3 = match$2[0];
                      var sk$prime = match$3[1];
                      if (EConstr$ReactTemplate.eq_constr(sigma, match$3[0], Caml_array.caml_array_get(t, i))) {
                        if (i === (t.length - 1 | 0)) {
                          _param = /* tuple */[
                            cst,
                            params,
                            q
                          ];
                          _sk = sk$prime;
                          continue ;
                          
                        } else {
                          _param = /* tuple */[
                            cst,
                            params,
                            /* :: */[
                              /* tuple */[
                                i + 1 | 0,
                                t
                              ],
                              q
                            ]
                          ];
                          _sk = sk$prime;
                          continue ;
                          
                        }
                      } else {
                        return def;
                      }
                    } else {
                      return def;
                    }
                  } else {
                    return /* tuple */[
                            cst,
                            append_app_list(Curry._1(Util$ReactTemplate.List[/* rev */4], params), sk$1)
                          ];
                  }
                };
              }), s, l);
}

function constr_of_cst_member(f, sk) {
  if (f.tag) {
    var match = decomp(sk);
    if (match) {
      var match$1 = match[0];
      return /* tuple */[
              EConstr$ReactTemplate.mkProj(/* tuple */[
                    f[0],
                    match$1[0]
                  ]),
              match$1[1]
            ];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "reductionops.ml",
              572,
              16
            ]
          ];
    }
  } else {
    var match$2 = f[0];
    return /* tuple */[
            EConstr$ReactTemplate.mkConstU(/* tuple */[
                  match$2[0],
                  EConstr$ReactTemplate.EInstance[/* make */0](match$2[1])
                ]),
            sk
          ];
  }
}

function zip($staropt$star, sigma, s) {
  var refold = $staropt$star ? $staropt$star[0] : /* false */0;
  var _param = s;
  while(true) {
    var param = _param;
    var match = param[1];
    var f = param[0];
    if (match) {
      var match$1 = match[0];
      switch (match$1.tag | 0) {
        case 0 : 
            var match$2 = match$1[0];
            var j = match$2[2];
            var a = match$2[1];
            var i = match$2[0];
            var a$prime = i === 0 && j === (a.length - 1 | 0) ? a : Util$ReactTemplate.$$Array[/* sub */5](a, i, (j - i | 0) + 1 | 0);
            _param = /* tuple */[
              EConstr$ReactTemplate.mkApp(/* tuple */[
                    f,
                    a$prime
                  ]),
              match[1]
            ];
            continue ;
            case 1 : 
            var s$1 = match[1];
            var br = match$1[2];
            var rt = match$1[1];
            var ci = match$1[0];
            if (refold) {
              _param = best_state(sigma, /* tuple */[
                    EConstr$ReactTemplate.mkCase(/* tuple */[
                          ci,
                          rt,
                          f,
                          br
                        ]),
                    s$1
                  ], match$1[3]);
              continue ;
              
            } else {
              _param = /* tuple */[
                EConstr$ReactTemplate.mkCase(/* tuple */[
                      ci,
                      rt,
                      f,
                      br
                    ]),
                s$1
              ];
              continue ;
              
            }
            break;
        case 2 : 
            var s$2 = match[1];
            var p = match$1[2];
            if (refold) {
              _param = best_state(sigma, /* tuple */[
                    EConstr$ReactTemplate.mkProj(/* tuple */[
                          p,
                          f
                        ]),
                    s$2
                  ], match$1[3]);
              continue ;
              
            } else {
              _param = /* tuple */[
                EConstr$ReactTemplate.mkProj(/* tuple */[
                      p,
                      f
                    ]),
                s$2
              ];
              continue ;
              
            }
            break;
        case 3 : 
            var s$3 = match[1];
            var st = match$1[1];
            var fix = match$1[0];
            if (refold) {
              _param = best_state(sigma, /* tuple */[
                    EConstr$ReactTemplate.mkFix(fix),
                    Util$ReactTemplate.$at(st, append_app(/* array */[f], s$3))
                  ], match$1[2]);
              continue ;
              
            } else {
              _param = /* tuple */[
                EConstr$ReactTemplate.mkFix(fix),
                Util$ReactTemplate.$at(st, append_app(/* array */[f], s$3))
              ];
              continue ;
              
            }
            break;
        case 4 : 
            var s$4 = match[1];
            var params = match$1[3];
            var cst = match$1[0];
            if (refold) {
              _param = best_state(sigma, constr_of_cst_member(cst, Util$ReactTemplate.$at(params, append_app(/* array */[f], s$4))), match$1[4]);
              continue ;
              
            } else {
              _param = constr_of_cst_member(cst, Util$ReactTemplate.$at(params, append_app(/* array */[f], s$4)));
              continue ;
              
            }
            break;
        
      }
    } else {
      return f;
    }
  };
}

function pr_state(param) {
  var pr$2 = Termops$ReactTemplate.print_constr;
  return Pp$ReactTemplate.h(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Termops$ReactTemplate.print_constr(param[0]), Pp$ReactTemplate.str("|")), Pp$ReactTemplate.cut(/* () */0)), pr$1(pr$2, param[1])));
}

function safe_meta_value(sigma, ev) {
  try {
    return /* Some */[Evd$ReactTemplate.meta_value(sigma, ev)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function strong(whdfun, env, sigma, t) {
  var strongrec = function (env, t) {
    return Termops$ReactTemplate.map_constr_with_full_binders(sigma, EConstr$ReactTemplate.push_rel, strongrec, env, Curry._3(whdfun, env, sigma, t));
  };
  return strongrec(env, t);
}

function local_strong(whdfun, sigma) {
  var strongrec = function (t) {
    return EConstr$ReactTemplate.map(sigma, strongrec, Curry._2(whdfun, sigma, t));
  };
  return strongrec;
}

function strong_prodspine(redfun, sigma, c) {
  var x = Curry._2(redfun, sigma, c);
  var match = EConstr$ReactTemplate.kind(sigma, x);
  if (match.tag === 6) {
    return EConstr$ReactTemplate.mkProd(/* tuple */[
                match[0],
                match[1],
                strong_prodspine(redfun, sigma, match[2])
              ]);
  } else {
    return x;
  }
}

var eta = Curry._1(CClosure$ReactTemplate.RedFlags[/* mkflags */14], /* :: */[
      CClosure$ReactTemplate.RedFlags[/* fETA */2],
      /* [] */0
    ]);

function apply_subst(recfun, env, sigma, refold, cst_l, t, stack) {
  var _env = env;
  var _cst_l = cst_l;
  var _t = t;
  var _stack = stack;
  while(true) {
    var stack$1 = _stack;
    var t$1 = _t;
    var cst_l$1 = _cst_l;
    var env$1 = _env;
    var match = decomp(stack$1);
    var match$1 = EConstr$ReactTemplate.kind(sigma, t$1);
    var exit = 0;
    if (match) {
      if (match$1.tag === 7) {
        var match$2 = match[0];
        var h = match$2[0];
        var cst_l$prime = refold ? add_param(h, cst_l$1) : cst_l$1;
        _stack = match$2[1];
        _t = match$1[2];
        _cst_l = cst_l$prime;
        _env = /* :: */[
          h,
          env$1
        ];
        continue ;
        
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return Curry._3(recfun, sigma, cst_l$1, /* tuple */[
                  EConstr$ReactTemplate.Vars[/* substl */3](env$1, t$1),
                  stack$1
                ]);
    }
    
  };
}

function stacklam(recfun, env, sigma, t, stack) {
  return apply_subst((function (_, _$1, s) {
                return Curry._1(recfun, s);
              }), env, sigma, /* false */0, /* [] */0, t, stack);
}

function beta_applist(sigma, param) {
  var zip$1 = function (s) {
    return zip(/* None */0, sigma, s);
  };
  return stacklam(zip$1, /* [] */0, sigma, param[0], append_app_list(param[1], /* [] */0));
}

function reducible_mind_case(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 12 : 
    case 15 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function magicaly_constant_of_fixbody(env, sigma, reference, bd, param) {
  if (param) {
    try {
      var match = Names$ReactTemplate.Constant[/* repr3 */6](reference);
      var cst = Names$ReactTemplate.Constant[/* make3 */3](match[0], match[1], Names$ReactTemplate.Label[/* of_id */5](param[0]));
      var match$1 = Universes$ReactTemplate.fresh_constant_instance(env, cst);
      var match$2 = match$1[0];
      var u = match$2[1];
      var cst$1 = match$2[0];
      var match$3 = Environ$ReactTemplate.constant_opt_value_in(env, /* tuple */[
            cst$1,
            u
          ]);
      if (match$3) {
        var csts = EConstr$ReactTemplate.eq_constr_universes(env, sigma, EConstr$ReactTemplate.of_constr(match$3[0]), bd);
        if (csts) {
          var subst = Curry._3(Universes$ReactTemplate.Constraints[/* fold */13], (function (cst, acc) {
                  var match;
                  var exit = 0;
                  switch (cst.tag | 0) {
                    case 0 : 
                    case 1 : 
                        exit = 1;
                        break;
                    case 2 : 
                    case 3 : 
                        match = /* tuple */[
                          cst[0],
                          cst[1]
                        ];
                        break;
                    
                  }
                  if (exit === 1) {
                    match = /* tuple */[
                      Option$ReactTemplate.get(Univ$ReactTemplate.Universe[/* level */8](cst[0])),
                      Option$ReactTemplate.get(Univ$ReactTemplate.Universe[/* level */8](cst[1]))
                    ];
                  }
                  return Curry._3(Univ$ReactTemplate.LMap[/* add */3], match[0], match[1], acc);
                }), csts[0], Univ$ReactTemplate.LMap[/* empty */0]);
          var inst = Univ$ReactTemplate.Instance[/* subst_fn */10]((function (u) {
                  return Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, subst);
                }), u);
          return EConstr$ReactTemplate.mkConstU(/* tuple */[
                      cst$1,
                      EConstr$ReactTemplate.EInstance[/* make */0](inst)
                    ]);
        } else {
          return bd;
        }
      } else {
        return bd;
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return bd;
      } else {
        throw exn;
      }
    }
  } else {
    return bd;
  }
}

function contract_cofix(env, sigma, reference, param) {
  var typedbodies = param[1];
  var bodies = typedbodies[2];
  var names = typedbodies[0];
  var bodynum = param[0];
  var nbodies = bodies.length;
  var make_Fi = function (j) {
    var ind = (nbodies - j | 0) - 1 | 0;
    if (bodynum === ind) {
      return EConstr$ReactTemplate.mkCoFix(/* tuple */[
                  ind,
                  typedbodies
                ]);
    } else {
      var bd = EConstr$ReactTemplate.mkCoFix(/* tuple */[
            ind,
            typedbodies
          ]);
      if (env && reference) {
        return magicaly_constant_of_fixbody(env[0], sigma, reference[0], bd, Caml_array.caml_array_get(names, ind));
      } else {
        return bd;
      }
    }
  };
  var closure = Curry._2(Util$ReactTemplate.List[/* init */46], nbodies, make_Fi);
  return EConstr$ReactTemplate.Vars[/* substl */3](closure, Caml_array.caml_array_get(bodies, bodynum));
}

function reduce_mind_case(sigma, mia) {
  var match = EConstr$ReactTemplate.kind(sigma, mia[/* mconstr */1]);
  switch (match.tag | 0) {
    case 12 : 
        var real_cargs = Curry._2(Util$ReactTemplate.List[/* skipn */107], mia[/* mci */2][/* ci_npar */1], mia[/* mcargs */3]);
        return EConstr$ReactTemplate.applist(/* tuple */[
                    Caml_array.caml_array_get(mia[/* mlf */4], match[0][0][1] - 1 | 0),
                    real_cargs
                  ]);
    case 15 : 
        var cofix_def = contract_cofix(/* None */0, sigma, /* None */0, match[0]);
        return EConstr$ReactTemplate.mkCase(/* tuple */[
                    mia[/* mci */2],
                    mia[/* mP */0],
                    EConstr$ReactTemplate.applist(/* tuple */[
                          cofix_def,
                          mia[/* mcargs */3]
                        ]),
                    mia[/* mlf */4]
                  ]);
    default:
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "reductionops.ml",
              769,
              11
            ]
          ];
  }
}

function contract_fix(env, sigma, reference, param) {
  var typedbodies = param[1];
  var names = typedbodies[0];
  var match = param[0];
  var bodynum = match[1];
  var recindices = match[0];
  var nbodies = recindices.length;
  var make_Fi = function (j) {
    var ind = (nbodies - j | 0) - 1 | 0;
    if (bodynum === ind) {
      return EConstr$ReactTemplate.mkFix(/* tuple */[
                  /* tuple */[
                    recindices,
                    ind
                  ],
                  typedbodies
                ]);
    } else {
      var bd = EConstr$ReactTemplate.mkFix(/* tuple */[
            /* tuple */[
              recindices,
              ind
            ],
            typedbodies
          ]);
      if (env && reference) {
        return magicaly_constant_of_fixbody(env[0], sigma, reference[0], bd, Caml_array.caml_array_get(names, ind));
      } else {
        return bd;
      }
    }
  };
  var closure = Curry._2(Util$ReactTemplate.List[/* init */46], nbodies, make_Fi);
  return EConstr$ReactTemplate.Vars[/* substl */3](closure, Caml_array.caml_array_get(typedbodies[2], bodynum));
}

function fix_recarg(param, stack) {
  var match = param[0];
  var bodynum = match[1];
  var recindices = match[0];
  if (!(0 <= bodynum && bodynum < recindices.length)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "reductionops.ml",
            808,
            2
          ]
        ];
  }
  var recargnum = Caml_array.caml_array_get(recindices, bodynum);
  try {
    return /* Some */[/* tuple */[
              recargnum,
              nth(stack, recargnum)
            ]];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

var debug_RAKAM = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"Print states of the Reductionops abstract machine",
      /* optkey : :: */[
        "Debug",
        /* :: */[
          "RAKAM",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return debug_RAKAM[0];
        }),
      /* optwrite */(function (a) {
          debug_RAKAM[0] = a;
          return /* () */0;
        })
    ]);

function equal_stacks(sigma, param, param$1) {
  var f_equal = function (x, y) {
    return EConstr$ReactTemplate.eq_constr(sigma, x, y);
  };
  var eq_fix = function (a, b) {
    var y = EConstr$ReactTemplate.mkFix(b);
    var x = EConstr$ReactTemplate.mkFix(a);
    return EConstr$ReactTemplate.eq_constr(sigma, x, y);
  };
  if (equal(f_equal, eq_fix, param[1], param$1[1])) {
    return EConstr$ReactTemplate.eq_constr(sigma, param[0], param$1[0]);
  } else {
    return /* false */0;
  }
}

function whd_state_gen(csts, refold, tactic_mode, flags, env, sigma) {
  var whrec = function (_cst_l, _param) {
    while(true) {
      var param = _param;
      var cst_l = _cst_l;
      var stack = param[1];
      var x = param[0];
      if (debug_RAKAM[0]) {
        var pr$2 = Termops$ReactTemplate.print_constr;
        Feedback$ReactTemplate.msg_notice(/* None */0, Pp$ReactTemplate.h(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("<<"), Termops$ReactTemplate.print_constr(x)), Pp$ReactTemplate.str("|")), Pp$ReactTemplate.cut(/* () */0)), pr(cst_l)), Pp$ReactTemplate.str("|")), Pp$ReactTemplate.cut(/* () */0)), pr$1(pr$2, stack)), Pp$ReactTemplate.str(">>"))));
      }
      var c0 = EConstr$ReactTemplate.kind(sigma, x);
      var fold = (function(cst_l,stack,c0){
      return function fold() {
        if (debug_RAKAM[0]) {
          Feedback$ReactTemplate.msg_notice(/* None */0, Pp$ReactTemplate.str("<><><><><>"));
        }
        return /* tuple */[
                /* tuple */[
                  EConstr$ReactTemplate.of_kind(c0),
                  stack
                ],
                cst_l
              ];
      }
      }(cst_l,stack,c0));
      switch (c0.tag | 0) {
        case 0 : 
            var n = c0[0];
            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fDELTA */1])) {
              var match = EConstr$ReactTemplate.lookup_rel(n, env);
              if (match.tag) {
                _param = /* tuple */[
                  EConstr$ReactTemplate.Vars[/* lift */0](n, match[1]),
                  stack
                ];
                _cst_l = /* [] */0;
                continue ;
                
              } else {
                return fold(/* () */0);
              }
            } else {
              return fold(/* () */0);
            }
            break;
        case 1 : 
            var id = c0[0];
            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fVAR */8](id))) {
              var match$1 = EConstr$ReactTemplate.lookup_named(id, env);
              if (match$1.tag) {
                _param = /* tuple */[
                  match$1[1],
                  stack
                ];
                _cst_l = refold ? add_cst(EConstr$ReactTemplate.mkVar(id), cst_l) : cst_l;
                continue ;
                
              } else {
                return fold(/* () */0);
              }
            } else {
              return fold(/* () */0);
            }
            break;
        case 2 : 
            var match$2 = safe_meta_value(sigma, c0[0]);
            if (match$2) {
              _param = /* tuple */[
                EConstr$ReactTemplate.of_constr(match$2[0]),
                stack
              ];
              continue ;
              
            } else {
              return fold(/* () */0);
            }
            break;
        case 3 : 
            return fold(/* () */0);
        case 5 : 
            _param = /* tuple */[
              c0[0],
              stack
            ];
            continue ;
            case 7 : 
            var match$3 = decomp(stack);
            if (match$3) {
              if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fBETA */0])) {
                return apply_subst((function () {
                              return whrec;
                            }), /* [] */0, sigma, refold, cst_l, x, stack);
              } else {
                return fold(/* () */0);
              }
            } else if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fETA */2])) {
              var env$prime = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      c0[0],
                      c0[1]
                    ]), env);
              var whrec$prime = whd_state_gen(/* None */0, refold, tactic_mode, flags, env$prime, sigma);
              var match$4 = EConstr$ReactTemplate.kind(sigma, zip(/* Some */[refold], sigma, Curry._1(whrec$prime, /* tuple */[
                              c0[2],
                              /* [] */0
                            ])[0]));
              if (match$4.tag === 9) {
                var cl = match$4[1];
                var f = match$4[0];
                var napp = cl.length;
                if (napp > 0) {
                  var match$5 = Curry._1(whrec$prime, /* tuple */[
                        Util$ReactTemplate.$$Array[/* last */34](cl),
                        /* [] */0
                      ]);
                  var match$6 = match$5[0];
                  var match$7 = EConstr$ReactTemplate.kind(sigma, match$6[0]);
                  if (match$7.tag) {
                    return fold(/* () */0);
                  } else if (match$7[0] !== 1) {
                    return fold(/* () */0);
                  } else if (match$6[1]) {
                    return fold(/* () */0);
                  } else {
                    var lc = Util$ReactTemplate.$$Array[/* sub */5](cl, 0, napp - 1 | 0);
                    var u = napp === 1 ? f : EConstr$ReactTemplate.mkApp(/* tuple */[
                            f,
                            lc
                          ]);
                    if (EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, u)) {
                      return /* tuple */[
                              /* tuple */[
                                Termops$ReactTemplate.pop(u),
                                /* [] */0
                              ],
                              /* [] */0
                            ];
                    } else {
                      return fold(/* () */0);
                    }
                  }
                } else {
                  return fold(/* () */0);
                }
              } else {
                return fold(/* () */0);
              }
            } else {
              return fold(/* () */0);
            }
            break;
        case 8 : 
            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fZETA */6])) {
              return apply_subst((function () {
                            return whrec;
                          }), /* :: */[
                          c0[1],
                          /* [] */0
                        ], sigma, refold, cst_l, c0[3], stack);
            } else {
              return fold(/* () */0);
            }
        case 9 : 
            var cl$1 = c0[1];
            _param = /* tuple */[
              c0[0],
              append_app(cl$1, stack)
            ];
            _cst_l = refold ? Curry._1(add_args(cl$1), cst_l) : cst_l;
            continue ;
            case 10 : 
            var $$const = c0[0];
            var c = $$const[0];
            reduction_effect_hook(env, sigma, EConstr$ReactTemplate.to_constr(sigma, x), Block.__(246, [(function(x,stack){
                    return function () {
                      return EConstr$ReactTemplate.to_constr(sigma, zip(/* None */0, sigma, /* tuple */[
                                      x,
                                      stack
                                    ]));
                    }
                    }(x,stack))]));
            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fCONST */7](c))) {
              var u$prime = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, $$const[1]);
              var match$8 = Environ$ReactTemplate.constant_opt_value_in(env, /* tuple */[
                    c,
                    u$prime
                  ]);
              if (match$8) {
                var body = EConstr$ReactTemplate.of_constr(match$8[0]);
                if (tactic_mode) {
                  var match$9 = get(/* ConstRef */Block.__(1, [c]));
                  if (match$9) {
                    var match$10 = match$9[0];
                    var flags$1 = match$10[2];
                    var nargs = match$10[1];
                    var recargs = match$10[0];
                    if (Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionNeverUnfold */1012736563, flags$1) || nargs > 0 && args_size(stack) < nargs) {
                      return fold(/* () */0);
                    } else if (Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionDontExposeCase */-1020251784, flags$1)) {
                      var match$11 = strip_app(stack);
                      var app_sk = match$11[0];
                      var match$12 = whrec(add_cst(EConstr$ReactTemplate.mkConstU($$const), cst_l), /* tuple */[
                            body,
                            app_sk
                          ]);
                      var match$13 = match$12[0];
                      var sk$prime = match$13[1];
                      var tm$prime = match$13[0];
                      var is_case = function (_x) {
                        while(true) {
                          var x = _x;
                          var match = EConstr$ReactTemplate.kind(sigma, x);
                          switch (match.tag | 0) {
                            case 7 : 
                                _x = match[2];
                                continue ;
                                case 8 : 
                                _x = match[3];
                                continue ;
                                case 5 : 
                            case 9 : 
                                _x = match[0];
                                continue ;
                                case 13 : 
                                return /* true */1;
                            default:
                              return /* false */0;
                          }
                        };
                      };
                      if (equal_stacks(sigma, /* tuple */[
                              x,
                              app_sk
                            ], /* tuple */[
                              tm$prime,
                              sk$prime
                            ]) || will_expose_iota(sk$prime) || is_case(tm$prime)) {
                        return fold(/* () */0);
                      } else {
                        _param = /* tuple */[
                          tm$prime,
                          Util$ReactTemplate.$at(sk$prime, match$11[1])
                        ];
                        _cst_l = match$12[1];
                        continue ;
                        
                      }
                    } else if (recargs) {
                      var curr = recargs[0];
                      var match$14 = strip_n_app(curr, stack);
                      if (match$14) {
                        var match$15 = match$14[0];
                        _param = /* tuple */[
                          match$15[1],
                          /* :: */[
                            /* Cst */Block.__(4, [
                                /* Cst_const */Block.__(0, [/* tuple */[
                                      $$const[0],
                                      u$prime
                                    ]]),
                                curr,
                                recargs[1],
                                match$15[0],
                                cst_l
                              ]),
                            match$15[2]
                          ]
                        ];
                        _cst_l = /* [] */0;
                        continue ;
                        
                      } else {
                        return fold(/* () */0);
                      }
                    } else {
                      _param = /* tuple */[
                        body,
                        stack
                      ];
                      continue ;
                      
                    }
                  } else {
                    _param = /* tuple */[
                      body,
                      stack
                    ];
                    _cst_l = add_cst(EConstr$ReactTemplate.mkConstU($$const), cst_l);
                    continue ;
                    
                  }
                } else {
                  _param = /* tuple */[
                    body,
                    stack
                  ];
                  _cst_l = refold ? add_cst(EConstr$ReactTemplate.mkConstU($$const), cst_l) : cst_l;
                  continue ;
                  
                }
              } else {
                return fold(/* () */0);
              }
            } else {
              return fold(/* () */0);
            }
            break;
        case 12 : 
            var use_match = CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fMATCH */3]);
            var use_fix = CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fFIX */4]);
            if (use_match || use_fix) {
              var match$16 = strip_app(stack);
              var match$17 = match$16[1];
              var args = match$16[0];
              if (match$17) {
                var match$18 = match$17[0];
                switch (match$18.tag | 0) {
                  case 0 : 
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "reductionops.ml",
                              1043,
                              32
                            ]
                          ];
                  case 1 : 
                      if (use_match) {
                        _param = /* tuple */[
                          Caml_array.caml_array_get(match$18[2], c0[0][0][1] - 1 | 0),
                          Util$ReactTemplate.$at(tail(match$18[0][/* ci_npar */1], args), match$17[1])
                        ];
                        _cst_l = /* [] */0;
                        continue ;
                        
                      } else {
                        return fold(/* () */0);
                      }
                      break;
                  case 2 : 
                      if (use_match) {
                        _param = /* tuple */[
                          nth(args, match$18[0] + match$18[1] | 0),
                          match$17[1]
                        ];
                        _cst_l = /* [] */0;
                        continue ;
                        
                      } else {
                        return fold(/* () */0);
                      }
                      break;
                  case 3 : 
                      if (use_fix) {
                        var x$prime = zip(/* None */0, sigma, /* tuple */[
                              x,
                              args
                            ]);
                        var out_sk = Util$ReactTemplate.$at(match$18[1], append_app(/* array */[x$prime], match$17[1]));
                        var recfun = whrec;
                        var env$1 = env;
                        var sigma$1 = sigma;
                        var refold$1 = refold;
                        var cst_l$1 = match$18[2];
                        var fix = match$18[0];
                        var sk = out_sk;
                        var env$2 = refold$1 ? /* Some */[env$1] : /* None */0;
                        var raw_answer = contract_fix(env$2, sigma$1, reference(sigma$1, cst_l$1), fix);
                        return apply_subst((function(recfun,refold$1,cst_l$1,fix){
                                  return function (sigma, x, param) {
                                    var t = param[0];
                                    var t$prime = refold$1 ? best_replace(sigma, EConstr$ReactTemplate.mkFix(fix), cst_l$1, t) : t;
                                    return Curry._2(recfun, x, /* tuple */[
                                                t$prime,
                                                param[1]
                                              ]);
                                  }
                                  }(recfun,refold$1,cst_l$1,fix)), /* [] */0, sigma$1, refold$1, /* [] */0, raw_answer, sk);
                      } else {
                        return fold(/* () */0);
                      }
                      break;
                  case 4 : 
                      var s$prime$prime = match$17[1];
                      var cst_l$2 = match$18[4];
                      var s$prime = match$18[3];
                      var remains = match$18[2];
                      var $$const$1 = match$18[0];
                      var x$prime$1 = zip(/* None */0, sigma, /* tuple */[
                            x,
                            args
                          ]);
                      if (remains) {
                        var next = remains[0];
                        var match$19 = strip_n_app((next - match$18[1] | 0) - 1 | 0, s$prime$prime);
                        if (match$19) {
                          var match$20 = match$19[0];
                          _param = /* tuple */[
                            match$20[1],
                            /* :: */[
                              /* Cst */Block.__(4, [
                                  $$const$1,
                                  next,
                                  remains[1],
                                  Util$ReactTemplate.$at(s$prime, append_app(/* array */[x$prime$1], match$20[0])),
                                  cst_l$2
                                ]),
                              match$20[2]
                            ]
                          ];
                          _cst_l = /* [] */0;
                          continue ;
                          
                        } else {
                          return fold(/* () */0);
                        }
                      } else if ($$const$1.tag) {
                        var p = $$const$1[0];
                        var pb = Environ$ReactTemplate.lookup_projection(p, env);
                        var npars = pb[/* proj_npars */1];
                        var narg = pb[/* proj_arg */2];
                        var stack$1 = Util$ReactTemplate.$at(s$prime, append_app(/* array */[x$prime$1], s$prime$prime));
                        var match$21 = strip_n_app(0, stack$1);
                        if (match$21) {
                          var match$22 = match$21[0];
                          _param = /* tuple */[
                            match$22[1],
                            /* :: */[
                              /* Proj */Block.__(2, [
                                  npars,
                                  narg,
                                  p,
                                  cst_l$2
                                ]),
                              match$22[2]
                            ]
                          ];
                          _cst_l = /* [] */0;
                          continue ;
                          
                        } else {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                [
                                  "reductionops.ml",
                                  1033,
                                  12
                                ]
                              ];
                        }
                      } else {
                        var $$const$2 = $$const$1[0];
                        var match$23 = Environ$ReactTemplate.constant_opt_value_in(env, $$const$2);
                        if (match$23) {
                          var const_000 = $$const$2[0];
                          var const_001 = EConstr$ReactTemplate.EInstance[/* make */0]($$const$2[1]);
                          var $$const$3 = /* tuple */[
                            const_000,
                            const_001
                          ];
                          var body$1 = EConstr$ReactTemplate.of_constr(match$23[0]);
                          _param = /* tuple */[
                            body$1,
                            Util$ReactTemplate.$at(s$prime, append_app(/* array */[x$prime$1], s$prime$prime))
                          ];
                          _cst_l = refold ? add_cst(EConstr$ReactTemplate.mkConstU($$const$3), cst_l$2) : cst_l$2;
                          continue ;
                          
                        } else {
                          return fold(/* () */0);
                        }
                      }
                      break;
                  
                }
              } else {
                return fold(/* () */0);
              }
            } else {
              return fold(/* () */0);
            }
            break;
        case 13 : 
            _param = /* tuple */[
              c0[2],
              /* :: */[
                /* Case */Block.__(1, [
                    c0[0],
                    c0[1],
                    c0[3],
                    cst_l
                  ]),
                stack
              ]
            ];
            _cst_l = /* [] */0;
            continue ;
            case 14 : 
            var f$1 = c0[0];
            var match$24 = f$1[0];
            var match$25 = strip_n_app(Caml_array.caml_array_get(match$24[0], match$24[1]), stack);
            if (match$25) {
              var match$26 = match$25[0];
              _param = /* tuple */[
                match$26[1],
                /* :: */[
                  /* Fix */Block.__(3, [
                      f$1,
                      match$26[0],
                      cst_l
                    ]),
                  match$26[2]
                ]
              ];
              _cst_l = /* [] */0;
              continue ;
              
            } else {
              return fold(/* () */0);
            }
            break;
        case 15 : 
            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fCOFIX */5])) {
              var match$27 = strip_app(stack);
              var match$28 = match$27[1];
              if (match$28) {
                var exit = 0;
                switch (match$28[0].tag | 0) {
                  case 1 : 
                  case 2 : 
                      exit = 1;
                      break;
                  default:
                    return fold(/* () */0);
                }
                if (exit === 1) {
                  var recfun$1 = whrec;
                  var env$3 = env;
                  var sigma$2 = sigma;
                  var refold$2 = refold;
                  var cst_l$3 = cst_l;
                  var cofix = c0[0];
                  var sk$1 = stack;
                  var env$4 = refold$2 ? /* Some */[env$3] : /* None */0;
                  var raw_answer$1 = contract_cofix(env$4, sigma$2, reference(sigma$2, cst_l$3), cofix);
                  return apply_subst((function(recfun$1,refold$2,cst_l$3,cofix){
                            return function (sigma, x, param) {
                              var t = param[0];
                              var t$prime = refold$2 ? best_replace(sigma, EConstr$ReactTemplate.mkCoFix(cofix), cst_l$3, t) : t;
                              return Curry._2(recfun$1, x, /* tuple */[
                                          t$prime,
                                          param[1]
                                        ]);
                            }
                            }(recfun$1,refold$2,cst_l$3,cofix)), /* [] */0, sigma$2, refold$2, /* [] */0, raw_answer$1, sk$1);
                }
                
              } else {
                return fold(/* () */0);
              }
            } else {
              return fold(/* () */0);
            }
            break;
        case 16 : 
            var c$1 = c0[1];
            var p$1 = c0[0];
            if (CClosure$ReactTemplate.RedFlags[/* red_projection */16](flags, p$1)) {
              var pb$1 = Environ$ReactTemplate.lookup_projection(p$1, env);
              var kn = Names$ReactTemplate.Projection[/* constant */2](p$1);
              var npars$1 = pb$1[/* proj_npars */1];
              var arg = pb$1[/* proj_arg */2];
              if (tactic_mode) {
                var match$29 = get(/* ConstRef */Block.__(1, [kn]));
                if (match$29) {
                  var match$30 = match$29[0];
                  var nargs$1 = match$30[1];
                  if (Curry._2(Util$ReactTemplate.List[/* mem */24], /* ReductionNeverUnfold */1012736563, match$30[2]) || nargs$1 > 0 && args_size(stack) < (nargs$1 - (npars$1 + 1 | 0) | 0)) {
                    return fold(/* () */0);
                  } else {
                    var recargs$1 = Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function(npars$1){
                        return function (x) {
                          var idx = x - npars$1 | 0;
                          if (idx < 0) {
                            return /* None */0;
                          } else {
                            return /* Some */[idx];
                          }
                        }
                        }(npars$1)), match$30[0]);
                    if (recargs$1) {
                      var remains$1 = recargs$1[1];
                      var curr$1 = recargs$1[0];
                      if (curr$1) {
                        var match$31 = strip_n_app(curr$1, stack);
                        if (match$31) {
                          var match$32 = match$31[0];
                          _param = /* tuple */[
                            match$32[1],
                            /* :: */[
                              /* Cst */Block.__(4, [
                                  /* Cst_proj */Block.__(1, [p$1]),
                                  curr$1,
                                  remains$1,
                                  append_app(/* array */[c$1], match$32[0]),
                                  cst_l
                                ]),
                              match$32[2]
                            ]
                          ];
                          _cst_l = /* [] */0;
                          continue ;
                          
                        } else {
                          return fold(/* () */0);
                        }
                      } else {
                        _param = /* tuple */[
                          c$1,
                          /* :: */[
                            /* Cst */Block.__(4, [
                                /* Cst_proj */Block.__(1, [p$1]),
                                curr$1,
                                remains$1,
                                /* [] */0,
                                cst_l
                              ]),
                            stack
                          ]
                        ];
                        _cst_l = /* [] */0;
                        continue ;
                        
                      }
                    } else {
                      var stack$prime_001 = /* :: */[
                        /* Proj */Block.__(2, [
                            npars$1,
                            arg,
                            p$1,
                            cst_l
                          ]),
                        stack
                      ];
                      var stack$prime = /* tuple */[
                        c$1,
                        stack$prime_001
                      ];
                      _param = stack$prime;
                      _cst_l = /* [] */0;
                      continue ;
                      
                    }
                  }
                } else {
                  var stack$prime_001$1 = /* :: */[
                    /* Proj */Block.__(2, [
                        npars$1,
                        arg,
                        p$1,
                        cst_l
                      ]),
                    stack
                  ];
                  var stack$prime$1 = /* tuple */[
                    c$1,
                    stack$prime_001$1
                  ];
                  var match$33 = whrec(/* [] */0, stack$prime$1);
                  var stack$prime$prime = match$33[0];
                  if (equal_stacks(sigma, stack$prime$1, stack$prime$prime)) {
                    return fold(/* () */0);
                  } else {
                    return /* tuple */[
                            stack$prime$prime,
                            match$33[1]
                          ];
                  }
                }
              } else {
                var stack$prime_001$2 = /* :: */[
                  /* Proj */Block.__(2, [
                      npars$1,
                      arg,
                      p$1,
                      /* [] */0
                    ]),
                  stack
                ];
                var stack$prime$2 = /* tuple */[
                  c$1,
                  stack$prime_001$2
                ];
                _param = stack$prime$2;
                _cst_l = /* [] */0;
                continue ;
                
              }
            } else {
              return fold(/* () */0);
            }
            break;
        default:
          return fold(/* () */0);
      }
    };
  };
  return (function (xs) {
      var res = whrec(Option$ReactTemplate.$$default(/* [] */0, csts), xs);
      if (tactic_mode) {
        return /* tuple */[
                best_state(sigma, res[0], res[1]),
                /* [] */0
              ];
      } else {
        return res;
      }
    });
}

function local_whd_state_gen(flags, sigma) {
  var whrec = function (_param) {
    while(true) {
      var param = _param;
      var stack = param[1];
      var x = param[0];
      var c0 = EConstr$ReactTemplate.kind(sigma, x);
      var s_000 = EConstr$ReactTemplate.of_kind(c0);
      var s = /* tuple */[
        s_000,
        stack
      ];
      switch (c0.tag | 0) {
        case 2 : 
            var match = safe_meta_value(sigma, c0[0]);
            if (match) {
              _param = /* tuple */[
                EConstr$ReactTemplate.of_constr(match[0]),
                stack
              ];
              continue ;
              
            } else {
              return s;
            }
            break;
        case 3 : 
            return s;
        case 5 : 
            _param = /* tuple */[
              c0[0],
              stack
            ];
            continue ;
            case 7 : 
            var c = c0[2];
            var match$1 = decomp(stack);
            if (match$1) {
              var match$2 = match$1[0];
              if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fBETA */0])) {
                return stacklam(whrec, /* :: */[
                            match$2[0],
                            /* [] */0
                          ], sigma, c, match$2[1]);
              } else {
                return s;
              }
            } else if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fETA */2])) {
              var match$3 = EConstr$ReactTemplate.kind(sigma, zip(/* None */0, sigma, whrec(/* tuple */[
                            c,
                            /* [] */0
                          ])));
              if (match$3.tag === 9) {
                var cl = match$3[1];
                var f = match$3[0];
                var napp = cl.length;
                if (napp > 0) {
                  var match$4 = whrec(/* tuple */[
                        Util$ReactTemplate.$$Array[/* last */34](cl),
                        /* [] */0
                      ]);
                  var match$5 = EConstr$ReactTemplate.kind(sigma, match$4[0]);
                  if (match$5.tag) {
                    return s;
                  } else if (match$5[0] !== 1) {
                    return s;
                  } else if (match$4[1]) {
                    return s;
                  } else {
                    var lc = Util$ReactTemplate.$$Array[/* sub */5](cl, 0, napp - 1 | 0);
                    var u = napp === 1 ? f : EConstr$ReactTemplate.mkApp(/* tuple */[
                            f,
                            lc
                          ]);
                    if (EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, u)) {
                      return /* tuple */[
                              Termops$ReactTemplate.pop(u),
                              /* [] */0
                            ];
                    } else {
                      return s;
                    }
                  }
                } else {
                  return s;
                }
              } else {
                return s;
              }
            } else {
              return s;
            }
            break;
        case 8 : 
            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fZETA */6])) {
              return stacklam(whrec, /* :: */[
                          c0[1],
                          /* [] */0
                        ], sigma, c0[3], stack);
            } else {
              return s;
            }
        case 9 : 
            _param = /* tuple */[
              c0[0],
              append_app(c0[1], stack)
            ];
            continue ;
            case 12 : 
            var use_match = CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fMATCH */3]);
            var use_fix = CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fFIX */4]);
            if (use_match || use_fix) {
              var match$6 = strip_app(stack);
              var match$7 = match$6[1];
              var args = match$6[0];
              if (match$7) {
                var match$8 = match$7[0];
                switch (match$8.tag | 0) {
                  case 1 : 
                      if (use_match) {
                        _param = /* tuple */[
                          Caml_array.caml_array_get(match$8[2], c0[0][0][1] - 1 | 0),
                          Util$ReactTemplate.$at(tail(match$8[0][/* ci_npar */1], args), match$7[1])
                        ];
                        continue ;
                        
                      } else {
                        return s;
                      }
                      break;
                  case 2 : 
                      if (use_match) {
                        _param = /* tuple */[
                          nth(args, match$8[0] + match$8[1] | 0),
                          match$7[1]
                        ];
                        continue ;
                        
                      } else {
                        return s;
                      }
                      break;
                  case 3 : 
                      if (use_fix) {
                        var x$prime = zip(/* None */0, sigma, /* tuple */[
                              x,
                              args
                            ]);
                        _param = /* tuple */[
                          contract_fix(/* None */0, sigma, /* None */0, match$8[0]),
                          Util$ReactTemplate.$at(match$8[1], append_app(/* array */[x$prime], match$7[1]))
                        ];
                        continue ;
                        
                      } else {
                        return s;
                      }
                      break;
                  case 0 : 
                  case 4 : 
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "reductionops.ml",
                              1124,
                              44
                            ]
                          ];
                  
                }
              } else {
                return s;
              }
            } else {
              return s;
            }
            break;
        case 13 : 
            _param = /* tuple */[
              c0[2],
              /* :: */[
                /* Case */Block.__(1, [
                    c0[0],
                    c0[1],
                    c0[3],
                    /* [] */0
                  ]),
                stack
              ]
            ];
            continue ;
            case 14 : 
            var f$1 = c0[0];
            var match$9 = f$1[0];
            var match$10 = strip_n_app(Caml_array.caml_array_get(match$9[0], match$9[1]), stack);
            if (match$10) {
              var match$11 = match$10[0];
              _param = /* tuple */[
                match$11[1],
                /* :: */[
                  /* Fix */Block.__(3, [
                      f$1,
                      match$11[0],
                      /* [] */0
                    ]),
                  match$11[2]
                ]
              ];
              continue ;
              
            } else {
              return s;
            }
            break;
        case 15 : 
            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fCOFIX */5])) {
              var match$12 = strip_app(stack);
              var match$13 = match$12[1];
              if (match$13) {
                var exit = 0;
                switch (match$13[0].tag | 0) {
                  case 1 : 
                  case 2 : 
                      exit = 1;
                      break;
                  default:
                    return s;
                }
                if (exit === 1) {
                  _param = /* tuple */[
                    contract_cofix(/* None */0, sigma, /* None */0, c0[0]),
                    stack
                  ];
                  continue ;
                  
                }
                
              } else {
                return s;
              }
            } else {
              return s;
            }
            break;
        case 16 : 
            var p = c0[0];
            if (CClosure$ReactTemplate.RedFlags[/* red_projection */16](flags, p)) {
              var pb = Environ$ReactTemplate.lookup_projection(p, Global$ReactTemplate.env(/* () */0));
              _param = /* tuple */[
                c0[1],
                /* :: */[
                  /* Proj */Block.__(2, [
                      pb[/* proj_npars */1],
                      pb[/* proj_arg */2],
                      p,
                      /* [] */0
                    ]),
                  stack
                ]
              ];
              continue ;
              
            } else {
              return s;
            }
            break;
        default:
          return s;
      }
    };
  };
  return whrec;
}

function raw_whd_state_gen(flags, env) {
  return (function (sigma, s) {
      return whd_state_gen(/* None */0, /* false */0, /* false */0, flags, env, sigma)(s)[0];
    });
}

function stack_red_of_state_red(f) {
  return (function (sigma, x) {
      return EConstr$ReactTemplate.decompose_app(sigma, zip(/* None */0, sigma, Curry._2(f, sigma, /* tuple */[
                          x,
                          /* [] */0
                        ])));
    });
}

function iterate_whd_gen(refold, flags, env, sigma, s) {
  var aux = function (t) {
    var match = whd_state_gen(/* None */0, refold, /* false */0, flags, env, sigma)(/* tuple */[
          t,
          /* [] */0
        ]);
    var match$1 = match[0];
    var whd_sk = map(aux, match$1[1]);
    return zip(/* Some */[refold], sigma, /* tuple */[
                match$1[0],
                whd_sk
              ]);
  };
  return aux(s);
}

function red_of_state_red(f, sigma, x) {
  return zip(/* None */0, sigma, Curry._2(f, sigma, /* tuple */[
                  x,
                  /* [] */0
                ]));
}

function whd_nored_state(param) {
  return local_whd_state_gen(CClosure$ReactTemplate.nored, param);
}

var whd_nored_stack = stack_red_of_state_red(whd_nored_state);

function whd_nored(param, param$1) {
  return red_of_state_red(whd_nored_state, param, param$1);
}

function whd_beta_state(param) {
  return local_whd_state_gen(CClosure$ReactTemplate.beta, param);
}

var whd_beta_stack = stack_red_of_state_red(whd_beta_state);

function whd_beta(param, param$1) {
  return red_of_state_red(whd_beta_state, param, param$1);
}

function whd_betalet_state(param) {
  return local_whd_state_gen(CClosure$ReactTemplate.betazeta, param);
}

var whd_betalet_stack = stack_red_of_state_red(whd_betalet_state);

function whd_betalet(param, param$1) {
  return red_of_state_red(whd_betalet_state, param, param$1);
}

function whd_delta_state(e) {
  return raw_whd_state_gen(CClosure$ReactTemplate.delta, e);
}

function whd_delta_stack(env) {
  return stack_red_of_state_red(whd_delta_state(env));
}

function whd_delta(env) {
  var partial_arg = whd_delta_state(env);
  return (function (param, param$1) {
      return red_of_state_red(partial_arg, param, param$1);
    });
}

function whd_betadeltazeta_state(e) {
  return raw_whd_state_gen(CClosure$ReactTemplate.betadeltazeta, e);
}

function whd_betadeltazeta_stack(env) {
  return stack_red_of_state_red(whd_betadeltazeta_state(env));
}

function whd_betadeltazeta(env) {
  var partial_arg = whd_betadeltazeta_state(env);
  return (function (param, param$1) {
      return red_of_state_red(partial_arg, param, param$1);
    });
}

function whd_betaiota_state(param) {
  return local_whd_state_gen(CClosure$ReactTemplate.betaiota, param);
}

var whd_betaiota_stack = stack_red_of_state_red(whd_betaiota_state);

function whd_betaiota(param, param$1) {
  return red_of_state_red(whd_betaiota_state, param, param$1);
}

function whd_betaiotazeta_state(param) {
  return local_whd_state_gen(CClosure$ReactTemplate.betaiotazeta, param);
}

var whd_betaiotazeta_stack = stack_red_of_state_red(whd_betaiotazeta_state);

function whd_betaiotazeta(param, param$1) {
  return red_of_state_red(whd_betaiotazeta_state, param, param$1);
}

function whd_all_state(env) {
  return raw_whd_state_gen(CClosure$ReactTemplate.all, env);
}

function whd_all_stack(env) {
  return stack_red_of_state_red(whd_all_state(env));
}

function whd_all(env) {
  var partial_arg = whd_all_state(env);
  return (function (param, param$1) {
      return red_of_state_red(partial_arg, param, param$1);
    });
}

function whd_allnolet_state(env) {
  return raw_whd_state_gen(CClosure$ReactTemplate.allnolet, env);
}

function whd_allnolet_stack(env) {
  return stack_red_of_state_red(whd_allnolet_state(env));
}

function whd_allnolet(env) {
  var partial_arg = whd_allnolet_state(env);
  return (function (param, param$1) {
      return red_of_state_red(partial_arg, param, param$1);
    });
}

function shrink_eta(c) {
  return zip(/* None */0, Evd$ReactTemplate.empty, local_whd_state_gen(eta, Evd$ReactTemplate.empty)(/* tuple */[
                  c,
                  /* [] */0
                ]));
}

function whd_zeta_state(param) {
  return local_whd_state_gen(CClosure$ReactTemplate.zeta, param);
}

var whd_zeta_stack = stack_red_of_state_red(whd_zeta_state);

function whd_zeta(param, param$1) {
  return red_of_state_red(whd_zeta_state, param, param$1);
}

function clos_norm_flags(flgs, env, sigma, t) {
  try {
    var evars = function (ev) {
      return Evarutil$ReactTemplate.safe_evar_value(sigma, ev);
    };
    return EConstr$ReactTemplate.of_constr(CClosure$ReactTemplate.norm_val(CClosure$ReactTemplate.create_clos_infos(/* Some */[evars], flgs, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(EConstr$ReactTemplate.Unsafe[/* to_constr */0](t))));
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.is_anomaly(e)) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Tried to normalize ill-typed term"));
    } else {
      throw e;
    }
  }
}

function clos_whd_flags(flgs, env, sigma, t) {
  try {
    var evars = function (ev) {
      return Evarutil$ReactTemplate.safe_evar_value(sigma, ev);
    };
    return EConstr$ReactTemplate.of_constr(CClosure$ReactTemplate.whd_val(CClosure$ReactTemplate.create_clos_infos(/* Some */[evars], flgs, env), CClosure$ReactTemplate.create_tab(/* () */0), CClosure$ReactTemplate.inject(EConstr$ReactTemplate.Unsafe[/* to_constr */0](t))));
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.is_anomaly(e)) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Tried to normalize ill-typed term"));
    } else {
      throw e;
    }
  }
}

function nf_beta(param, param$1, param$2) {
  return clos_norm_flags(CClosure$ReactTemplate.beta, param, param$1, param$2);
}

function nf_betaiota(param, param$1, param$2) {
  return clos_norm_flags(CClosure$ReactTemplate.betaiota, param, param$1, param$2);
}

function nf_betaiotazeta(param, param$1, param$2) {
  return clos_norm_flags(CClosure$ReactTemplate.betaiotazeta, param, param$1, param$2);
}

function nf_all(env, sigma) {
  return (function (param) {
      return clos_norm_flags(CClosure$ReactTemplate.all, env, sigma, param);
    });
}

function is_transparent(e, k) {
  var match = Conv_oracle$ReactTemplate.get_strategy(Environ$ReactTemplate.oracle(e))(k);
  if (typeof match === "number" && match !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function pb_is_equal(pb) {
  return +(pb === /* CONV */0);
}

function pb_equal() {
  return /* CONV */0;
}

function report_anomaly(e) {
  var msg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Conversion test raised an anomaly:"), Pp$ReactTemplate.spc(/* () */0)), CErrors$ReactTemplate.print(/* None */0, e));
  var e$1 = [
    CErrors$ReactTemplate.UserError,
    /* None */0,
    msg
  ];
  return Util$ReactTemplate.iraise(CErrors$ReactTemplate.push(e$1));
}

function f_conv(l2r, reds, env, evars, x, y) {
  var inj = EConstr$ReactTemplate.Unsafe[/* to_constr */0];
  return Curry._2(Reduction$ReactTemplate.conv(l2r, reds, env, evars), Curry._1(inj, x), Curry._1(inj, y));
}

function f_conv_leq(l2r, reds, env, evars, x, y) {
  var inj = EConstr$ReactTemplate.Unsafe[/* to_constr */0];
  return Curry._2(Reduction$ReactTemplate.conv_leq(l2r, reds, env, evars), Curry._1(inj, x), Curry._1(inj, y));
}

function test_trans_conversion(f, reds, env, sigma, x, y) {
  try {
    var evars = function (ev) {
      return Evarutil$ReactTemplate.safe_evar_value(sigma, ev);
    };
    Curry._6(f, /* None */0, /* Some */[reds], env, /* Some */[/* tuple */[
            evars,
            Evd$ReactTemplate.universes(sigma)
          ]], x, y);
    return /* true */1;
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (e === Reduction$ReactTemplate.NotConvertible) {
      return /* false */0;
    } else if (CErrors$ReactTemplate.is_anomaly(e)) {
      return report_anomaly(e);
    } else {
      throw e;
    }
  }
}

function is_conv($staropt$star, env, sigma) {
  var reds = $staropt$star ? $staropt$star[0] : Names$ReactTemplate.full_transparent_state;
  return (function (param, param$1) {
      return test_trans_conversion(f_conv, reds, env, sigma, param, param$1);
    });
}

function is_conv_leq($staropt$star, env, sigma) {
  var reds = $staropt$star ? $staropt$star[0] : Names$ReactTemplate.full_transparent_state;
  return (function (param, param$1) {
      return test_trans_conversion(f_conv_leq, reds, env, sigma, param, param$1);
    });
}

function is_fconv($staropt$star, param) {
  var reds = $staropt$star ? $staropt$star[0] : Names$ReactTemplate.full_transparent_state;
  if (param !== 0) {
    var partial_arg = /* Some */[reds];
    return (function (param, param$1) {
        return is_conv_leq(partial_arg, param, param$1);
      });
  } else {
    var partial_arg$1 = /* Some */[reds];
    return (function (param, param$1) {
        return is_conv(partial_arg$1, param, param$1);
      });
  }
}

function check_conv($staropt$star, $staropt$star$1, env, sigma, x, y) {
  var pb = $staropt$star ? $staropt$star[0] : /* CUMUL */1;
  var ts = $staropt$star$1 ? $staropt$star$1[0] : Names$ReactTemplate.full_transparent_state;
  var f = pb !== 0 ? f_conv_leq : f_conv;
  try {
    Curry._6(f, /* None */0, /* Some */[ts], env, /* Some */[/* tuple */[
            (function (param) {
                return Evarutil$ReactTemplate.safe_evar_value(sigma, param);
              }),
            Evd$ReactTemplate.universes(sigma)
          ]], x, y);
    return /* true */1;
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (e === Reduction$ReactTemplate.NotConvertible) {
      return /* false */0;
    } else if (e[0] === Univ$ReactTemplate.UniverseInconsistency) {
      return /* false */0;
    } else if (CErrors$ReactTemplate.is_anomaly(e)) {
      return report_anomaly(e);
    } else {
      throw e;
    }
  }
}

function sigma_compare_sorts(env, pb, s0, s1, sigma) {
  if (pb !== 0) {
    return Evd$ReactTemplate.set_leq_sort(env, sigma, s0, s1);
  } else {
    return Evd$ReactTemplate.set_eq_sort(env, sigma, s0, s1);
  }
}

function sigma_compare_instances(flex, i0, i1, sigma) {
  try {
    return Evd$ReactTemplate.set_eq_instances(/* Some */[flex], sigma, i0, i1);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn === Evd$ReactTemplate.UniversesDiffer) {
      throw Reduction$ReactTemplate.NotConvertible;
    } else if (exn[0] === Univ$ReactTemplate.UniverseInconsistency) {
      throw Reduction$ReactTemplate.NotConvertible;
    } else {
      throw exn;
    }
  }
}

function sigma_check_inductive_instances(cv_pb, variance, u1, u2, sigma) {
  var match = Evarutil$ReactTemplate.compare_cumulative_instances(cv_pb, variance, u1, u2, sigma);
  if (match.tag) {
    throw Reduction$ReactTemplate.NotConvertible;
  } else {
    return match[0];
  }
}

var sigma_univ_state = /* record */[
  /* compare_sorts */sigma_compare_sorts,
  /* compare_instances */sigma_compare_instances,
  /* compare_cumul_instances */sigma_check_inductive_instances
];

function infer_conv_gen(conv_fun, $staropt$star, $staropt$star$1, $staropt$star$2, env, sigma, x, y) {
  var catch_incon = $staropt$star ? $staropt$star[0] : /* true */1;
  var pb = $staropt$star$1 ? $staropt$star$1[0] : /* CUMUL */1;
  var ts = $staropt$star$2 ? $staropt$star$2[0] : Names$ReactTemplate.full_transparent_state;
  try {
    var ans = pb === /* CUMUL */1 ? EConstr$ReactTemplate.leq_constr_universes(env, sigma, x, y) : EConstr$ReactTemplate.eq_constr_universes(env, sigma, x, y);
    var ans$1;
    if (ans) {
      try {
        ans$1 = /* Some */[Evd$ReactTemplate.add_universe_constraints(sigma, ans[0])];
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Univ$ReactTemplate.UniverseInconsistency) {
          ans$1 = /* None */0;
        } else if (exn === Evd$ReactTemplate.UniversesDiffer) {
          ans$1 = /* None */0;
        } else {
          throw exn;
        }
      }
    } else {
      ans$1 = /* None */0;
    }
    var match = ans$1 ? /* tuple */[
        /* true */1,
        ans$1[0]
      ] : /* tuple */[
        /* false */0,
        sigma
      ];
    var sigma$1 = match[1];
    if (match[0]) {
      return /* tuple */[
              sigma$1,
              /* true */1
            ];
    } else {
      var x$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](x);
      var y$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](y);
      var sigma$prime = Curry._8(conv_fun, pb, /* false */0, sigma$1, ts, env, /* tuple */[
            sigma$1,
            sigma_univ_state
          ], x$1, y$1);
      return /* tuple */[
              sigma$prime,
              /* true */1
            ];
    }
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (e === Reduction$ReactTemplate.NotConvertible) {
      return /* tuple */[
              sigma,
              /* false */0
            ];
    } else if (e[0] === Univ$ReactTemplate.UniverseInconsistency) {
      if (catch_incon) {
        return /* tuple */[
                sigma,
                /* false */0
              ];
      } else if (CErrors$ReactTemplate.is_anomaly(e)) {
        return report_anomaly(e);
      } else {
        throw e;
      }
    } else if (CErrors$ReactTemplate.is_anomaly(e)) {
      return report_anomaly(e);
    } else {
      throw e;
    }
  }
}

function infer_conv(param, param$1, param$2, param$3, param$4, param$5, param$6) {
  return infer_conv_gen((function (pb, l2r, sigma) {
                return (function (param, param$1, param$2, param$3, param$4) {
                    return Reduction$ReactTemplate.generic_conv(pb, l2r, (function (param) {
                                  return Evarutil$ReactTemplate.safe_evar_value(sigma, param);
                                }), param, param$1, param$2, param$3, param$4);
                  });
              }), param, param$1, param$2, param$3, param$4, param$5, param$6);
}

var arg = /* Some */[Names$ReactTemplate.full_transparent_state];

var vm_infer_conv = [(function (param) {
      var partial_arg = /* Some */[/* true */1];
      return (function (param$1, param$2, param$3, param$4) {
          return infer_conv(partial_arg, param, arg, param$1, param$2, param$3, param$4);
        });
    })];

function set_vm_infer_conv(f) {
  vm_infer_conv[0] = f;
  return /* () */0;
}

function vm_infer_conv$1($staropt$star, env, t1, t2) {
  var pb = $staropt$star ? $staropt$star[0] : /* CUMUL */1;
  return Curry._4(vm_infer_conv[0], /* Some */[pb], env, t1, t2);
}

function whd_meta(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 2) {
    try {
      return EConstr$ReactTemplate.of_constr(Evd$ReactTemplate.meta_value(sigma, match[0]));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return c;
      } else {
        throw exn;
      }
    }
  } else {
    return c;
  }
}

var default_plain_instance_ident = Names$ReactTemplate.Id[/* of_string */5]("H");

function plain_instance(sigma, s, c) {
  var irec = function (n, u) {
    var match = EConstr$ReactTemplate.kind(sigma, u);
    var exit = 0;
    switch (match.tag | 0) {
      case 2 : 
          try {
            return EConstr$ReactTemplate.Vars[/* lift */0](n, Curry._2(Evd$ReactTemplate.Metamap[/* find */21], match[0], s));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return u;
            } else {
              throw exn;
            }
          }
          break;
      case 5 : 
          var m = match[0];
          if (EConstr$ReactTemplate.isMeta(sigma, m)) {
            try {
              return EConstr$ReactTemplate.Vars[/* lift */0](n, Curry._2(Evd$ReactTemplate.Metamap[/* find */21], EConstr$ReactTemplate.destMeta(sigma, m), s));
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                return u;
              } else {
                throw exn$1;
              }
            }
          } else {
            exit = 1;
          }
          break;
      case 9 : 
          var f = match[0];
          if (EConstr$ReactTemplate.isCast(sigma, f)) {
            var match$1 = EConstr$ReactTemplate.destCast(sigma, f);
            var f$1 = match$1[0];
            var l$prime = CArray$ReactTemplate.Fun1[/* smartmap */1](irec, n, match[1]);
            var match$2 = EConstr$ReactTemplate.kind(sigma, f$1);
            if (match$2.tag === 2) {
              try {
                var g = Curry._2(Evd$ReactTemplate.Metamap[/* find */21], match$2[0], s);
                var match$3 = EConstr$ReactTemplate.kind(sigma, g);
                if (match$3.tag === 9) {
                  var l$prime$1 = CArray$ReactTemplate.Fun1[/* smartmap */1](EConstr$ReactTemplate.Vars[/* lift */0], 1, l$prime);
                  return EConstr$ReactTemplate.mkLetIn(/* tuple */[
                              /* Name */[default_plain_instance_ident],
                              g,
                              match$1[2],
                              EConstr$ReactTemplate.mkApp(/* tuple */[
                                    EConstr$ReactTemplate.mkRel(1),
                                    l$prime$1
                                  ])
                            ]);
                } else {
                  return EConstr$ReactTemplate.mkApp(/* tuple */[
                              g,
                              l$prime
                            ]);
                }
              }
              catch (exn$2){
                if (exn$2 === Caml_builtin_exceptions.not_found) {
                  return EConstr$ReactTemplate.mkApp(/* tuple */[
                              f$1,
                              l$prime
                            ]);
                } else {
                  throw exn$2;
                }
              }
            } else {
              return EConstr$ReactTemplate.mkApp(/* tuple */[
                          irec(n, f$1),
                          l$prime
                        ]);
            }
          } else {
            exit = 1;
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      return EConstr$ReactTemplate.map_with_binders(sigma, (function (prim) {
                    return prim + 1 | 0;
                  }), irec, n, u);
    }
    
  };
  if (Curry._1(Evd$ReactTemplate.Metamap[/* is_empty */1], s)) {
    return c;
  } else {
    return irec(0, c);
  }
}

function instance(sigma, s, c) {
  return local_strong(whd_betaiota, sigma)(plain_instance(sigma, s, c));
}

function hnf_prod_app(env, sigma, t, n) {
  var match = EConstr$ReactTemplate.kind(sigma, whd_all(env)(sigma, t));
  if (match.tag === 6) {
    return EConstr$ReactTemplate.Vars[/* subst1 */4](n, match[2]);
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["hnf_prod_app"], Pp$ReactTemplate.str("Need a product."));
  }
}

function hnf_prod_appvect(env, sigma, t, nl) {
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (acc, t) {
                return hnf_prod_app(env, sigma, acc, t);
              }), t, nl);
}

function hnf_prod_applist(env, sigma, t, nl) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, t) {
                return hnf_prod_app(env, sigma, acc, t);
              }), t, nl);
}

function hnf_lam_app(env, sigma, t, n) {
  var match = EConstr$ReactTemplate.kind(sigma, whd_all(env)(sigma, t));
  if (match.tag === 7) {
    return EConstr$ReactTemplate.Vars[/* subst1 */4](n, match[2]);
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["hnf_lam_app"], Pp$ReactTemplate.str("Need an abstraction."));
  }
}

function hnf_lam_appvect(env, sigma, t, nl) {
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (acc, t) {
                return hnf_lam_app(env, sigma, acc, t);
              }), t, nl);
}

function hnf_lam_applist(env, sigma, t, nl) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, t) {
                return hnf_lam_app(env, sigma, acc, t);
              }), t, nl);
}

function splay_prod(env, sigma) {
  return (function (param) {
      var _env = env;
      var _m = /* [] */0;
      var _c = param;
      while(true) {
        var c = _c;
        var m = _m;
        var env$1 = _env;
        var t = whd_all(env$1)(sigma, c);
        var match = EConstr$ReactTemplate.kind(sigma, t);
        if (match.tag === 6) {
          var a = match[1];
          var n = match[0];
          _c = match[2];
          _m = /* :: */[
            /* tuple */[
              n,
              a
            ],
            m
          ];
          _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  n,
                  a
                ]), env$1);
          continue ;
          
        } else {
          return /* tuple */[
                  m,
                  t
                ];
        }
      };
    });
}

function splay_lam(env, sigma) {
  return (function (param) {
      var _env = env;
      var _m = /* [] */0;
      var _c = param;
      while(true) {
        var c = _c;
        var m = _m;
        var env$1 = _env;
        var t = whd_all(env$1)(sigma, c);
        var match = EConstr$ReactTemplate.kind(sigma, t);
        if (match.tag === 7) {
          var a = match[1];
          var n = match[0];
          _c = match[2];
          _m = /* :: */[
            /* tuple */[
              n,
              a
            ],
            m
          ];
          _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  n,
                  a
                ]), env$1);
          continue ;
          
        } else {
          return /* tuple */[
                  m,
                  t
                ];
        }
      };
    });
}

function splay_prod_assum(env, sigma) {
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _env = env;
      var _l = partial_arg;
      var _c = param;
      while(true) {
        var c = _c;
        var l = _l;
        var env$1 = _env;
        var t = whd_allnolet(env$1)(sigma, c);
        var match = EConstr$ReactTemplate.kind(sigma, t);
        switch (match.tag | 0) {
          case 5 : 
              _c = match[0];
              continue ;
              case 6 : 
              var t$1 = match[1];
              var x = match[0];
              _c = match[2];
              _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                      x,
                      t$1
                    ]), l);
              _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      x,
                      t$1
                    ]), env$1);
              continue ;
              case 8 : 
              var t$2 = match[2];
              var b = match[1];
              var x$1 = match[0];
              _c = match[3];
              _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                      x$1,
                      b,
                      t$2
                    ]), l);
              _env = EConstr$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                      x$1,
                      b,
                      t$2
                    ]), env$1);
              continue ;
              default:
            var t$prime = whd_all(env$1)(sigma, t);
            if (EConstr$ReactTemplate.eq_constr(sigma, t, t$prime)) {
              return /* tuple */[
                      l,
                      t
                    ];
            } else {
              _c = t$prime;
              continue ;
              
            }
        }
      };
    });
}

function splay_arity(env, sigma, c) {
  var match = splay_prod(env, sigma)(c);
  var match$1 = EConstr$ReactTemplate.kind(sigma, match[1]);
  if (match$1.tag === 4) {
    return /* tuple */[
            match[0],
            match$1[0]
          ];
  } else {
    return CErrors$ReactTemplate.invalid_arg(/* None */0, "splay_arity");
  }
}

function sort_of_arity(env, sigma, c) {
  return splay_arity(env, sigma, c)[1];
}

function splay_prod_n(env, sigma, n) {
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _env = env;
      var _m = n;
      var _ln = partial_arg;
      var _c = param;
      while(true) {
        var c = _c;
        var ln = _ln;
        var m = _m;
        var env$1 = _env;
        if (m) {
          var match = EConstr$ReactTemplate.kind(sigma, whd_all(env$1)(sigma, c));
          if (match.tag === 6) {
            var a = match[1];
            var n$1 = match[0];
            _c = match[2];
            _ln = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                    n$1,
                    a
                  ]), ln);
            _m = m - 1 | 0;
            _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                    n$1,
                    a
                  ]), env$1);
            continue ;
            
          } else {
            return CErrors$ReactTemplate.invalid_arg(/* None */0, "splay_prod_n");
          }
        } else {
          return /* tuple */[
                  ln,
                  c
                ];
        }
      };
    });
}

function splay_lam_n(env, sigma, n) {
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _env = env;
      var _m = n;
      var _ln = partial_arg;
      var _c = param;
      while(true) {
        var c = _c;
        var ln = _ln;
        var m = _m;
        var env$1 = _env;
        if (m) {
          var match = EConstr$ReactTemplate.kind(sigma, whd_all(env$1)(sigma, c));
          if (match.tag === 7) {
            var a = match[1];
            var n$1 = match[0];
            _c = match[2];
            _ln = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                    n$1,
                    a
                  ]), ln);
            _m = m - 1 | 0;
            _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                    n$1,
                    a
                  ]), env$1);
            continue ;
            
          } else {
            return CErrors$ReactTemplate.invalid_arg(/* None */0, "splay_lam_n");
          }
        } else {
          return /* tuple */[
                  ln,
                  c
                ];
        }
      };
    });
}

function is_sort(env, sigma, t) {
  var match = EConstr$ReactTemplate.kind(sigma, whd_all(env)(sigma, t));
  if (match.tag === 4) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function whd_betaiota_deltazeta_for_iota_state(ts, env, sigma, csts, s) {
  var _csts = csts;
  var _s = s;
  while(true) {
    var s$1 = _s;
    var csts$1 = _csts;
    var match = whd_state_gen(/* Some */[csts$1], /* false */0, /* false */0, CClosure$ReactTemplate.betaiota, env, sigma)(s$1);
    var csts$prime = match[1];
    var s$2 = match[0];
    var t = s$2[0];
    var match$1 = strip_app(s$2[1]);
    var stack$prime = match$1[1];
    var args = match$1[0];
    if (stack$prime) {
      var match$2 = stack$prime[0];
      switch (match$2.tag | 0) {
        case 1 : 
            var match$3 = whd_state_gen(/* Some */[csts$prime], /* false */0, /* false */0, CClosure$ReactTemplate.RedFlags[/* red_add_transparent */12](CClosure$ReactTemplate.all, ts), env, sigma)(/* tuple */[
                  t,
                  args
                ]);
            var match$4 = match$3[0];
            var t_o = match$4[0];
            if (reducible_mind_case(sigma, t_o)) {
              _s = /* tuple */[
                t_o,
                Util$ReactTemplate.$at(match$4[1], stack$prime)
              ];
              _csts = match$3[1];
              continue ;
              
            } else {
              return /* tuple */[
                      s$2,
                      csts$prime
                    ];
            }
            break;
        case 2 : 
            var match$5 = whd_state_gen(/* Some */[csts$prime], /* false */0, /* false */0, CClosure$ReactTemplate.RedFlags[/* red_add_transparent */12](CClosure$ReactTemplate.all, ts), env, sigma)(/* tuple */[
                  t,
                  args
                ]);
            var match$6 = match$5[0];
            if (EConstr$ReactTemplate.isConstruct(sigma, match$6[0])) {
              _s = /* tuple */[
                nth(match$6[1], match$2[0] + match$2[1] | 0),
                stack$prime[1]
              ];
              _csts = /* [] */0;
              continue ;
              
            } else {
              return /* tuple */[
                      s$2,
                      csts$prime
                    ];
            }
            break;
        case 3 : 
            var match$7 = whd_state_gen(/* Some */[csts$prime], /* false */0, /* false */0, CClosure$ReactTemplate.RedFlags[/* red_add_transparent */12](CClosure$ReactTemplate.all, ts), env, sigma)(/* tuple */[
                  t,
                  args
                ]);
            var match$8 = match$7[0];
            var t_o$1 = match$8[0];
            if (EConstr$ReactTemplate.isConstruct(sigma, t_o$1)) {
              _s = /* tuple */[
                t_o$1,
                Util$ReactTemplate.$at(match$8[1], stack$prime)
              ];
              _csts = match$7[1];
              continue ;
              
            } else {
              return /* tuple */[
                      s$2,
                      csts$prime
                    ];
            }
            break;
        case 0 : 
        case 4 : 
            return /* tuple */[
                    s$2,
                    csts$prime
                  ];
        
      }
    } else {
      return /* tuple */[
              s$2,
              csts$prime
            ];
    }
  };
}

function find_conclusion(env, sigma) {
  return (function (param) {
      var _env = env;
      var _c = param;
      while(true) {
        var c = _c;
        var env$1 = _env;
        var t = whd_all(env$1)(sigma, c);
        var t$1 = EConstr$ReactTemplate.kind(sigma, t);
        var exit = 0;
        switch (t$1.tag | 0) {
          case 6 : 
          case 7 : 
              exit = 1;
              break;
          default:
            return t$1;
        }
        if (exit === 1) {
          _c = t$1[2];
          _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  t$1[0],
                  t$1[1]
                ]), env$1);
          continue ;
          
        }
        
      };
    });
}

function is_arity(env, sigma, c) {
  var match = find_conclusion(env, sigma)(c);
  if (match.tag === 4) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function meta_instance(sigma, b) {
  var fm = b[/* freemetas */1];
  if (Curry._1(Evd$ReactTemplate.Metaset[/* is_empty */1], fm)) {
    return b[/* rebus */0];
  } else {
    var c_sigma = Curry._2(Evd$ReactTemplate.Metamap[/* bind */28], (function (mv) {
            var evd = sigma;
            var mv$1 = mv;
            var valrec = function (mv) {
              var match = Evd$ReactTemplate.meta_opt_fvalue(evd, mv);
              if (match) {
                var b = match[0][0];
                var metas = Curry._2(Evd$ReactTemplate.Metamap[/* bind */28], valrec, b[/* freemetas */1]);
                return instance(evd, metas, EConstr$ReactTemplate.of_constr(b[/* rebus */0]));
              } else {
                return EConstr$ReactTemplate.mkMeta(mv);
              }
            };
            return valrec(mv$1);
          }), fm);
    return instance(sigma, c_sigma, b[/* rebus */0]);
  }
}

function nf_meta(sigma, c) {
  var c$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](c);
  var cl = Evd$ReactTemplate.mk_freelisted(c$1);
  return meta_instance(sigma, /* record */[
              /* rebus */EConstr$ReactTemplate.of_constr(cl[/* rebus */0]),
              /* freemetas */cl[/* freemetas */1]
            ]);
}

function meta_reducible_instance(evd, b) {
  var fm = b[/* freemetas */1];
  var fold = function (mv, accu) {
    var fvalue;
    try {
      fvalue = Evd$ReactTemplate.meta_opt_fvalue(evd, mv);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        fvalue = /* None */0;
      } else {
        throw exn;
      }
    }
    if (fvalue) {
      var match = fvalue[0];
      return Curry._3(Evd$ReactTemplate.Metamap[/* add */3], mv, /* tuple */[
                  match[0][/* rebus */0],
                  match[1][1]
                ], accu);
    } else {
      return accu;
    }
  };
  var metas = Curry._3(Evd$ReactTemplate.Metaset[/* fold */13], fold, fm, Evd$ReactTemplate.Metamap[/* empty */0]);
  var irec = function (_u) {
    while(true) {
      var u = _u;
      var u$1 = whd_betaiota(Evd$ReactTemplate.empty, u);
      var match = EConstr$ReactTemplate.kind(evd, u$1);
      switch (match.tag | 0) {
        case 2 : 
            try {
              var match$1 = Curry._2(Evd$ReactTemplate.Metamap[/* find */21], match[0], metas);
              var g = EConstr$ReactTemplate.of_constr(match$1[0]);
              var is_coerce = match$1[1] !== 0 ? /* false */0 : /* true */1;
              if (is_coerce) {
                return u$1;
              } else {
                return irec(g);
              }
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return u$1;
              } else {
                throw exn;
              }
            }
            break;
        case 9 : 
            var l = match[1];
            var f = match[0];
            if (EConstr$ReactTemplate.isMeta(evd, Termops$ReactTemplate.strip_outer_cast(evd, f))) {
              var m = EConstr$ReactTemplate.destMeta(evd, Termops$ReactTemplate.strip_outer_cast(evd, f));
              var match$2;
              try {
                var match$3 = Curry._2(Evd$ReactTemplate.Metamap[/* find */21], m, metas);
                var g$1 = EConstr$ReactTemplate.of_constr(match$3[0]);
                var is_coerce$1 = match$3[1] !== 0 ? /* false */0 : /* true */1;
                match$2 = EConstr$ReactTemplate.isLambda(evd, g$1) || !is_coerce$1 ? /* Some */[g$1] : /* None */0;
              }
              catch (exn$1){
                if (exn$1 === Caml_builtin_exceptions.not_found) {
                  match$2 = /* None */0;
                } else {
                  throw exn$1;
                }
              }
              if (match$2) {
                _u = EConstr$ReactTemplate.mkApp(/* tuple */[
                      match$2[0],
                      l
                    ]);
                continue ;
                
              } else {
                return EConstr$ReactTemplate.mkApp(/* tuple */[
                            f,
                            Util$ReactTemplate.$$Array[/* map */12](irec, l)
                          ]);
              }
            } else {
              return EConstr$ReactTemplate.map(evd, irec, u$1);
            }
            break;
        case 13 : 
            var bl = match[3];
            var c = match[2];
            var p = match[1];
            var ci = match[0];
            if (EConstr$ReactTemplate.isMeta(evd, Termops$ReactTemplate.strip_outer_cast(evd, c))) {
              var m$1 = EConstr$ReactTemplate.destMeta(evd, Termops$ReactTemplate.strip_outer_cast(evd, c));
              var match$4;
              try {
                var match$5 = Curry._2(Evd$ReactTemplate.Metamap[/* find */21], m$1, metas);
                var g$2 = EConstr$ReactTemplate.of_constr(match$5[0]);
                var is_coerce$2 = match$5[1] !== 0 ? /* false */0 : /* true */1;
                match$4 = EConstr$ReactTemplate.isConstruct(evd, g$2) || !is_coerce$2 ? /* Some */[g$2] : /* None */0;
              }
              catch (exn$2){
                if (exn$2 === Caml_builtin_exceptions.not_found) {
                  match$4 = /* None */0;
                } else {
                  throw exn$2;
                }
              }
              if (match$4) {
                _u = EConstr$ReactTemplate.mkCase(/* tuple */[
                      ci,
                      p,
                      match$4[0],
                      bl
                    ]);
                continue ;
                
              } else {
                return EConstr$ReactTemplate.mkCase(/* tuple */[
                            ci,
                            irec(p),
                            c,
                            Util$ReactTemplate.$$Array[/* map */12](irec, bl)
                          ]);
              }
            } else {
              return EConstr$ReactTemplate.map(evd, irec, u$1);
            }
            break;
        case 16 : 
            var c$1 = match[1];
            var p$1 = match[0];
            if (EConstr$ReactTemplate.isMeta(evd, c$1) || EConstr$ReactTemplate.isCast(evd, c$1) && EConstr$ReactTemplate.isMeta(evd, Util$ReactTemplate.pi1(EConstr$ReactTemplate.destCast(evd, c$1)))) {
              var m$2;
              try {
                m$2 = EConstr$ReactTemplate.destMeta(evd, c$1);
              }
              catch (exn$3){
                m$2 = EConstr$ReactTemplate.destMeta(evd, Util$ReactTemplate.pi1(EConstr$ReactTemplate.destCast(evd, c$1)));
              }
              var match$6;
              try {
                var match$7 = Curry._2(Evd$ReactTemplate.Metamap[/* find */21], m$2, metas);
                var g$3 = EConstr$ReactTemplate.of_constr(match$7[0]);
                var is_coerce$3 = match$7[1] !== 0 ? /* false */0 : /* true */1;
                match$6 = EConstr$ReactTemplate.isConstruct(evd, g$3) || !is_coerce$3 ? /* Some */[g$3] : /* None */0;
              }
              catch (exn$4){
                if (exn$4 === Caml_builtin_exceptions.not_found) {
                  match$6 = /* None */0;
                } else {
                  throw exn$4;
                }
              }
              if (match$6) {
                _u = EConstr$ReactTemplate.mkProj(/* tuple */[
                      p$1,
                      match$6[0]
                    ]);
                continue ;
                
              } else {
                return EConstr$ReactTemplate.mkProj(/* tuple */[
                            p$1,
                            c$1
                          ]);
              }
            } else {
              return EConstr$ReactTemplate.map(evd, irec, u$1);
            }
            break;
        default:
          return EConstr$ReactTemplate.map(evd, irec, u$1);
      }
    };
  };
  if (Curry._1(Evd$ReactTemplate.Metaset[/* is_empty */1], fm)) {
    return b[/* rebus */0];
  } else {
    return irec(b[/* rebus */0]);
  }
}

function head_unfold_under_prod(ts, env, sigma, c) {
  var unfold = function (param) {
    var u = param[1];
    var cst = param[0];
    var cstu_001 = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, u);
    var cstu = /* tuple */[
      cst,
      cstu_001
    ];
    if (Curry._2(Names$ReactTemplate.Cpred[/* mem */4], cst, ts[1])) {
      var match = Environ$ReactTemplate.constant_opt_value_in(env, cstu);
      if (match) {
        return EConstr$ReactTemplate.of_constr(match[0]);
      } else {
        return EConstr$ReactTemplate.mkConstU(/* tuple */[
                    cst,
                    u
                  ]);
      }
    } else {
      return EConstr$ReactTemplate.mkConstU(/* tuple */[
                  cst,
                  u
                ]);
    }
  };
  var aux = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 6) {
      return EConstr$ReactTemplate.mkProd(/* tuple */[
                  match[0],
                  aux(match[1]),
                  aux(match[2])
                ]);
    } else {
      var match$1 = Termops$ReactTemplate.decompose_app_vect(sigma, c);
      var match$2 = EConstr$ReactTemplate.kind(sigma, match$1[0]);
      if (match$2.tag === 10) {
        var sigma$1 = sigma;
        var param = /* tuple */[
          unfold(match$2[0]),
          match$1[1]
        ];
        var zip$1 = function (s) {
          return zip(/* None */0, sigma$1, s);
        };
        return stacklam(zip$1, /* [] */0, sigma$1, param[0], append_app(param[1], /* [] */0));
      } else {
        return c;
      }
    }
  };
  return aux(c);
}

function betazetaevar_applist(sigma, n, c, l) {
  var _n = n;
  var _env = /* [] */0;
  var _t = c;
  var _stack = l;
  while(true) {
    var stack = _stack;
    var t = _t;
    var env = _env;
    var n$1 = _n;
    if (n$1) {
      var match = EConstr$ReactTemplate.kind(sigma, t);
      switch (match.tag | 0) {
        case 3 : 
            return EConstr$ReactTemplate.applist(/* tuple */[
                        EConstr$ReactTemplate.Vars[/* substl */3](env, t),
                        stack
                      ]);
        case 7 : 
            if (stack) {
              _stack = stack[1];
              _t = match[2];
              _env = /* :: */[
                stack[0],
                env
              ];
              _n = n$1 - 1 | 0;
              continue ;
              
            } else {
              return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough lambda/let's."));
            }
            break;
        case 8 : 
            _t = match[3];
            _env = /* :: */[
              EConstr$ReactTemplate.Vars[/* substl */3](env, match[1]),
              env
            ];
            _n = n$1 - 1 | 0;
            continue ;
            default:
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough lambda/let's."));
      }
    } else {
      return EConstr$ReactTemplate.applist(/* tuple */[
                  EConstr$ReactTemplate.Vars[/* substl */3](env, t),
                  stack
                ]);
    }
  };
}

var ReductionBehaviour = [
  set,
  get,
  print
];

var Cst_stack = [
  /* [] */0,
  add_param,
  add_args,
  add_cst,
  best_cst,
  best_replace,
  reference,
  pr
];

var Stack = [
  pr_app_node,
  pr$1,
  /* [] */0,
  CList$ReactTemplate.is_empty,
  append_app,
  decomp,
  decomp_node_last,
  compare_shape,
  IncompatibleFold2,
  fold2,
  map,
  append_app_list,
  strip_app,
  strip_n_app,
  not_purely_applicative,
  list_of_app_stack,
  assign,
  args_size,
  tail,
  nth,
  best_state,
  zip
];

var nf_evar = Evarutil$ReactTemplate.nf_evar;

var whd_evar = Evarutil$ReactTemplate.whd_evar;

var safe_evar_value = Evarutil$ReactTemplate.safe_evar_value;

exports.Elimconst = Elimconst;
exports.ReductionBehaviour = ReductionBehaviour;
exports.declare_reduction_effect = declare_reduction_effect;
exports.set_reduction_effect = set_reduction_effect;
exports.reduction_effect_hook = reduction_effect_hook;
exports.Cst_stack = Cst_stack;
exports.Stack = Stack;
exports.pr_state = pr_state;
exports.strong = strong;
exports.local_strong = local_strong;
exports.strong_prodspine = strong_prodspine;
exports.stacklam = stacklam;
exports.whd_state_gen = whd_state_gen;
exports.iterate_whd_gen = iterate_whd_gen;
exports.clos_norm_flags = clos_norm_flags;
exports.clos_whd_flags = clos_whd_flags;
exports.nf_beta = nf_beta;
exports.nf_betaiota = nf_betaiota;
exports.nf_betaiotazeta = nf_betaiotazeta;
exports.nf_all = nf_all;
exports.nf_evar = nf_evar;
exports.whd_evar = whd_evar;
exports.whd_nored = whd_nored;
exports.whd_beta = whd_beta;
exports.whd_betaiota = whd_betaiota;
exports.whd_betaiotazeta = whd_betaiotazeta;
exports.whd_all = whd_all;
exports.whd_allnolet = whd_allnolet;
exports.whd_betalet = whd_betalet;
exports.whd_nored_stack = whd_nored_stack;
exports.whd_beta_stack = whd_beta_stack;
exports.whd_betaiota_stack = whd_betaiota_stack;
exports.whd_betaiotazeta_stack = whd_betaiotazeta_stack;
exports.whd_all_stack = whd_all_stack;
exports.whd_allnolet_stack = whd_allnolet_stack;
exports.whd_betalet_stack = whd_betalet_stack;
exports.whd_nored_state = whd_nored_state;
exports.whd_beta_state = whd_beta_state;
exports.whd_betaiota_state = whd_betaiota_state;
exports.whd_betaiotazeta_state = whd_betaiotazeta_state;
exports.whd_all_state = whd_all_state;
exports.whd_allnolet_state = whd_allnolet_state;
exports.whd_betalet_state = whd_betalet_state;
exports.whd_delta_stack = whd_delta_stack;
exports.whd_delta_state = whd_delta_state;
exports.whd_delta = whd_delta;
exports.whd_betadeltazeta_stack = whd_betadeltazeta_stack;
exports.whd_betadeltazeta_state = whd_betadeltazeta_state;
exports.whd_betadeltazeta = whd_betadeltazeta;
exports.whd_zeta_stack = whd_zeta_stack;
exports.whd_zeta_state = whd_zeta_state;
exports.whd_zeta = whd_zeta;
exports.shrink_eta = shrink_eta;
exports.safe_evar_value = safe_evar_value;
exports.beta_applist = beta_applist;
exports.hnf_prod_app = hnf_prod_app;
exports.hnf_prod_appvect = hnf_prod_appvect;
exports.hnf_prod_applist = hnf_prod_applist;
exports.hnf_lam_app = hnf_lam_app;
exports.hnf_lam_appvect = hnf_lam_appvect;
exports.hnf_lam_applist = hnf_lam_applist;
exports.splay_prod = splay_prod;
exports.splay_lam = splay_lam;
exports.splay_arity = splay_arity;
exports.sort_of_arity = sort_of_arity;
exports.splay_prod_n = splay_prod_n;
exports.splay_lam_n = splay_lam_n;
exports.splay_prod_assum = splay_prod_assum;
exports.reducible_mind_case = reducible_mind_case;
exports.reduce_mind_case = reduce_mind_case;
exports.find_conclusion = find_conclusion;
exports.is_arity = is_arity;
exports.is_sort = is_sort;
exports.contract_fix = contract_fix;
exports.fix_recarg = fix_recarg;
exports.is_transparent = is_transparent;
exports.pb_is_equal = pb_is_equal;
exports.pb_equal = pb_equal;
exports.is_conv = is_conv;
exports.is_conv_leq = is_conv_leq;
exports.is_fconv = is_fconv;
exports.check_conv = check_conv;
exports.infer_conv = infer_conv;
exports.set_vm_infer_conv = set_vm_infer_conv;
exports.vm_infer_conv = vm_infer_conv$1;
exports.infer_conv_gen = infer_conv_gen;
exports.whd_meta = whd_meta;
exports.plain_instance = plain_instance;
exports.instance = instance;
exports.head_unfold_under_prod = head_unfold_under_prod;
exports.betazetaevar_applist = betazetaevar_applist;
exports.whd_betaiota_deltazeta_for_iota_state = whd_betaiota_deltazeta_for_iota_state;
exports.meta_instance = meta_instance;
exports.nf_meta = nf_meta;
exports.meta_reducible_instance = meta_reducible_instance;
/*  Not a pure module */
