// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Vars$ReactTemplate = require("../src/vars.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var UState$ReactTemplate = require("../src/uState.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Impargs$ReactTemplate = require("../src/impargs.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Printer$ReactTemplate = require("../src/printer.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Classops$ReactTemplate = require("../src/classops.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Notation$ReactTemplate = require("../src/notation.bs.js");
var Printmod$ReactTemplate = require("./printmod.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Libobject$ReactTemplate = require("../src/libobject.bs.js");
var Mod_subst$ReactTemplate = require("../src/mod_subst.bs.js");
var Recordops$ReactTemplate = require("../src/recordops.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Declareops$ReactTemplate = require("../src/declareops.bs.js");
var Syntax_def$ReactTemplate = require("../src/syntax_def.bs.js");
var Conv_oracle$ReactTemplate = require("../src/conv_oracle.bs.js");
var Opaqueproof$ReactTemplate = require("../src/opaqueproof.bs.js");
var Safe_typing$ReactTemplate = require("../src/safe_typing.bs.js");
var Smartlocate$ReactTemplate = require("../shims/smartlocate.bs.js");
var Typeclasses$ReactTemplate = require("../src/typeclasses.bs.js");
var Constrextern$ReactTemplate = require("../src/constrextern.bs.js");
var Notation_ops$ReactTemplate = require("../src/notation_ops.bs.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");
var Arguments_renaming$ReactTemplate = require("../src/arguments_renaming.bs.js");

var print_closed_sections = [/* false */0];

function pr_infos_list(l) {
  return Pp$ReactTemplate.v(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.cut, (function (x) {
                    return x;
                  }), l));
}

function with_line_skip(l) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
    return Pp$ReactTemplate.mt(/* () */0);
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.fnl(/* () */0)), pr_infos_list(l));
  }
}

var blankline = Pp$ReactTemplate.mt(/* () */0);

function add_colon(prefix) {
  if (Pp$ReactTemplate.ismt(prefix)) {
    return Pp$ReactTemplate.mt(/* () */0);
  } else {
    return Pp$ReactTemplate.$plus$plus(prefix, Pp$ReactTemplate.str(": "));
  }
}

function int_or_no(n) {
  if (n) {
    return Pp$ReactTemplate.$$int(n);
  } else {
    return Pp$ReactTemplate.str("no");
  }
}

function print_ref(reduce, ref, udecl) {
  var match = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), ref);
  var typ = Vars$ReactTemplate.subst_instance_constr(Univ$ReactTemplate.AUContext[/* instance */3](match[1]), match[0]);
  var typ$1 = EConstr$ReactTemplate.of_constr(typ);
  var typ$2;
  if (reduce) {
    var match$1 = Reductionops$ReactTemplate.splay_prod_assum(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty)(typ$1);
    typ$2 = EConstr$ReactTemplate.it_mkProd_or_LetIn(match$1[1], match$1[0]);
  } else {
    typ$2 = typ$1;
  }
  var univs = Global$ReactTemplate.universes_of_global(ref);
  var variance;
  var exit = 0;
  var ind;
  switch (ref.tag | 0) {
    case 0 : 
    case 1 : 
        variance = /* None */0;
        break;
    case 2 : 
        ind = ref[0][0];
        exit = 1;
        break;
    case 3 : 
        ind = ref[0][0][0];
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    var mind = Environ$ReactTemplate.lookup_mind(ind, Global$ReactTemplate.env(/* () */0));
    var match$2 = mind[/* mind_universes */8];
    switch (match$2.tag | 0) {
      case 0 : 
      case 1 : 
          variance = /* None */0;
          break;
      case 2 : 
          variance = /* Some */[Univ$ReactTemplate.ACumulativityInfo[/* variance */1](match$2[0])];
          break;
      
    }
  }
  var inst = Univ$ReactTemplate.AUContext[/* instance */3](univs);
  var univs$1 = Univ$ReactTemplate.UContext[/* make */0](/* tuple */[
        inst,
        Univ$ReactTemplate.AUContext[/* instantiate */6](inst, univs)
      ]);
  var env = Global$ReactTemplate.env(/* () */0);
  var bl = Universes$ReactTemplate.universe_binders_with_opt_names(ref, Util$ReactTemplate.$$Array[/* to_list */9](Univ$ReactTemplate.Instance[/* to_array */3](inst)), udecl);
  var sigma = Evd$ReactTemplate.from_ctx(UState$ReactTemplate.of_binders(bl));
  var inst$1 = Global$ReactTemplate.is_polymorphic(ref) ? Printer$ReactTemplate.pr_universe_instance(sigma, univs$1) : Pp$ReactTemplate.mt(/* () */0);
  return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(ref), inst$1), Pp$ReactTemplate.str(" :")), Pp$ReactTemplate.spc(/* () */0)), Printer$ReactTemplate.pr_letype_env(env, sigma, typ$2)), Printer$ReactTemplate.pr_universe_ctx(sigma, variance, univs$1)));
}

function pr_impl_name(imp) {
  return Names$ReactTemplate.Id[/* print */8](Impargs$ReactTemplate.name_of_implicit(imp));
}

function print_impargs_by_name(max, impls) {
  if (impls) {
    var n = Curry._1(Util$ReactTemplate.List[/* length */0], impls);
    return /* :: */[
            Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], n, "Argument")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, pr_impl_name, impls)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(Curry._1(Util$ReactTemplate.$$String[/* conjugate_verb_to_be */34], n))), Pp$ReactTemplate.str(" implicit")), max ? Pp$ReactTemplate.strbrk(" and maximally inserted") : Pp$ReactTemplate.mt(/* () */0))),
            /* [] */0
          ];
  } else {
    return /* [] */0;
  }
}

function print_one_impargs_list(l) {
  var imps = Curry._2(Util$ReactTemplate.List[/* filter */27], Impargs$ReactTemplate.is_status_implicit, l);
  var maximps = Curry._2(Util$ReactTemplate.List[/* filter */27], Impargs$ReactTemplate.maximal_insertion_of, imps);
  var nonmaximps = Curry._3(Util$ReactTemplate.List[/* subtract */53], Caml_obj.caml_equal, imps, maximps);
  return Util$ReactTemplate.$at(print_impargs_by_name(/* false */0, nonmaximps), print_impargs_by_name(/* true */1, maximps));
}

function print_impargs_list(prefix, l) {
  var l$1 = Impargs$ReactTemplate.extract_impargs_data(l);
  return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    var imps = param[1];
                    var cond = param[0];
                    if (cond) {
                      var match = cond[0];
                      var n2 = match[1];
                      var n1 = match[0];
                      return /* :: */[
                              Pp$ReactTemplate.v(2, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.cut, (function (x) {
                                          return x;
                                        }), /* :: */[
                                        Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.ismt(prefix) ? Pp$ReactTemplate.str("When") : Pp$ReactTemplate.$plus$plus(prefix, Pp$ReactTemplate.str(", when")), Pp$ReactTemplate.str(" applied to ")), n1 === n2 ? int_or_no(n2) : (
                                                        n1 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(n1), Pp$ReactTemplate.str(" to ")), int_or_no(n2)) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("no more than "), Pp$ReactTemplate.$$int(n2))
                                                      )), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], n2, " argument"))), Pp$ReactTemplate.str(":")),
                                        /* :: */[
                                          Pp$ReactTemplate.v(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.cut, (function (x) {
                                                      return x;
                                                    }), Curry._2(Util$ReactTemplate.List[/* exists */21], Impargs$ReactTemplate.is_status_implicit, imps) ? print_one_impargs_list(imps) : /* :: */[
                                                      Pp$ReactTemplate.str("No implicit arguments"),
                                                      /* [] */0
                                                    ])),
                                          /* [] */0
                                        ]
                                      ])),
                              /* [] */0
                            ];
                    } else {
                      return Curry._2(Util$ReactTemplate.List[/* map */10], (function (pp) {
                                    return Pp$ReactTemplate.$plus$plus(add_colon(prefix), pp);
                                  }), print_one_impargs_list(imps));
                    }
                  }), l$1));
}

function print_renames_list(prefix, l) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
    return /* [] */0;
  } else {
    return /* :: */[
            Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(add_colon(prefix), Pp$ReactTemplate.str("Arguments are renamed to ")), Pp$ReactTemplate.hv(2, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, (function (x) {
                            return x;
                          }), Curry._2(Util$ReactTemplate.List[/* map */10], Nameops$ReactTemplate.Name[/* print */7], l)))),
            /* [] */0
          ];
  }
}

function need_expansion(impl, ref) {
  var match = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), ref);
  var ctx = Term$ReactTemplate.prod_assum(match[0]);
  var nprods = Curry._2(Util$ReactTemplate.List[/* count */76], Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], ctx);
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], impl)) {
    return /* false */0;
  } else if (Curry._1(Util$ReactTemplate.List[/* length */0], impl) >= nprods) {
    var match$1 = Curry._2(Util$ReactTemplate.List[/* chop */99], nprods, impl);
    return Curry._2(Util$ReactTemplate.List[/* exists */21], Impargs$ReactTemplate.is_status_implicit, match$1[1]);
  } else {
    return /* false */0;
  }
}

function print_impargs(ref) {
  var ref$1 = Curry._2(Smartlocate$ReactTemplate.smart_global, /* None */0, ref);
  var impl = Impargs$ReactTemplate.implicits_of_global(ref$1);
  var has_impl = 1 - Curry._1(Util$ReactTemplate.List[/* is_empty */45], impl);
  return pr_infos_list(Util$ReactTemplate.$at(/* :: */[
                  print_ref(need_expansion(Impargs$ReactTemplate.select_impargs_size(0, impl), ref$1), ref$1, /* None */0),
                  /* :: */[
                    blankline,
                    /* [] */0
                  ]
                ], has_impl ? print_impargs_list(Pp$ReactTemplate.mt(/* () */0), impl) : /* :: */[
                    Pp$ReactTemplate.str("No implicit arguments"),
                    /* [] */0
                  ]));
}

function print_argument_scopes(prefix, l) {
  var exit = 0;
  if (l) {
    var match = l[0];
    if (match) {
      if (l[1]) {
        exit = 1;
      } else {
        return /* :: */[
                Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(add_colon(prefix), Pp$ReactTemplate.str("Argument scope is [")), Pp$ReactTemplate.str(match[0])), Pp$ReactTemplate.str("]")),
                /* [] */0
              ];
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (Curry._2(Util$ReactTemplate.List[/* for_all */20], Option$ReactTemplate.is_empty, l)) {
      return /* [] */0;
    } else {
      return /* :: */[
              Pp$ReactTemplate.$plus$plus(add_colon(prefix), Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Argument scopes are"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("[")), Pp$ReactTemplate.pr_sequence((function (param) {
                                      if (param) {
                                        return Pp$ReactTemplate.str(param[0]);
                                      } else {
                                        return Pp$ReactTemplate.str("_");
                                      }
                                    }), l)), Pp$ReactTemplate.str("]")))),
              /* [] */0
            ];
    }
  }
  
}

function opacity(env, param) {
  switch (param.tag | 0) {
    case 0 : 
        var v = param[0];
        if (Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* is_local_def */6], Environ$ReactTemplate.lookup_named(v, env))) {
          return /* Some */[/* TransparentMaybeOpacified */[Conv_oracle$ReactTemplate.get_strategy(Environ$ReactTemplate.oracle(env))(/* VarKey */Block.__(1, [v]))]];
        } else {
          return /* None */0;
        }
    case 1 : 
        var cst = param[0];
        var cb = Environ$ReactTemplate.lookup_constant(cst, env);
        var match = cb[/* const_body */1];
        switch (match.tag | 0) {
          case 0 : 
              return /* None */0;
          case 1 : 
              return /* Some */[/* TransparentMaybeOpacified */[Conv_oracle$ReactTemplate.get_strategy(Environ$ReactTemplate.oracle(env))(/* ConstKey */Block.__(0, [cst]))]];
          case 2 : 
              return /* Some */[/* FullyOpaque */0];
          
        }
        break;
    case 2 : 
    case 3 : 
        return /* None */0;
    
  }
}

function print_opacity(ref) {
  var match = opacity(Global$ReactTemplate.env(/* () */0), ref);
  if (match) {
    var s = match[0];
    var tmp;
    if (s) {
      var lev = s[0];
      var exit = 0;
      if (typeof lev === "number" && lev !== 0) {
        tmp = Pp$ReactTemplate.str("basically transparent but considered opaque for reduction");
      } else {
        exit = 1;
      }
      if (exit === 1) {
        tmp = Conv_oracle$ReactTemplate.is_transparent(lev) ? Pp$ReactTemplate.str("transparent") : (
            typeof lev === "number" ? Pp$ReactTemplate.str("transparent (with minimal expansion weight)") : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("transparent (with expansion weight "), Pp$ReactTemplate.$$int(lev[0])), Pp$ReactTemplate.str(")"))
          );
      }
      
    } else {
      tmp = Pp$ReactTemplate.str("opaque");
    }
    return /* :: */[
            Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(ref), Pp$ReactTemplate.str(" is ")), tmp),
            /* [] */0
          ];
  } else {
    return /* [] */0;
  }
}

function print_if_is_coercion(ref) {
  if (Classops$ReactTemplate.coercion_exists(ref)) {
    return /* :: */[
            Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(ref), Pp$ReactTemplate.str(" is a coercion")),
            /* [] */0
          ];
  } else {
    return /* [] */0;
  }
}

function print_polymorphism(ref) {
  var poly = Global$ReactTemplate.is_polymorphic(ref);
  var template_poly = Global$ReactTemplate.is_template_polymorphic(ref);
  if (Flags$ReactTemplate.is_universe_polymorphism(/* () */0) || poly || template_poly) {
    return /* :: */[
            Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(ref), Pp$ReactTemplate.str(" is ")), Pp$ReactTemplate.str(poly ? "universe polymorphic" : (
                        template_poly ? "template universe polymorphic" : "not universe polymorphic"
                      ))),
            /* [] */0
          ];
  } else {
    return /* [] */0;
  }
}

function print_type_in_type(ref) {
  var unsafe = Global$ReactTemplate.is_type_in_type(ref);
  if (unsafe) {
    return /* :: */[
            Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(ref), Pp$ReactTemplate.str(" relies on an unsafe universe hierarchy")),
            /* [] */0
          ];
  } else {
    return /* [] */0;
  }
}

function print_primitive_record(recflag, mipv, param) {
  if (param) {
    if (param[0]) {
      var eta = recflag >= 2 ? Pp$ReactTemplate.str(" with eta conversion") : Pp$ReactTemplate.str(" without eta conversion");
      return /* :: */[
              Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](Caml_array.caml_array_get(mipv, 0)[/* mind_typename */0]), Pp$ReactTemplate.str(" has primitive projections")), eta), Pp$ReactTemplate.str(".")),
              /* [] */0
            ];
    } else {
      return /* [] */0;
    }
  } else {
    return /* [] */0;
  }
}

function print_primitive(ref) {
  if (ref.tag === 2) {
    var match = Global$ReactTemplate.lookup_inductive(ref[0]);
    var mib = match[0];
    return print_primitive_record(mib[/* mind_finite */2], mib[/* mind_packets */0], mib[/* mind_record */1]);
  } else {
    return /* [] */0;
  }
}

function print_name_infos(ref) {
  var impls = Impargs$ReactTemplate.implicits_of_global(ref);
  var scopes = Notation$ReactTemplate.find_arguments_scope(ref);
  var renames;
  try {
    renames = Arguments_renaming$ReactTemplate.arguments_names(ref);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      renames = /* [] */0;
    } else {
      throw exn;
    }
  }
  var type_info_for_implicit = need_expansion(Impargs$ReactTemplate.select_impargs_size(0, impls), ref) ? /* :: */[
      Pp$ReactTemplate.str("Expanded type for implicit arguments"),
      /* :: */[
        print_ref(/* true */1, ref, /* None */0),
        /* :: */[
          blankline,
          /* [] */0
        ]
      ]
    ] : /* [] */0;
  return Util$ReactTemplate.$at(print_polymorphism(ref), Util$ReactTemplate.$at(print_type_in_type(ref), Util$ReactTemplate.$at(print_primitive(ref), Util$ReactTemplate.$at(type_info_for_implicit, Util$ReactTemplate.$at(print_renames_list(Pp$ReactTemplate.mt(/* () */0), renames), Util$ReactTemplate.$at(print_impargs_list(Pp$ReactTemplate.mt(/* () */0), impls), Util$ReactTemplate.$at(print_argument_scopes(Pp$ReactTemplate.mt(/* () */0), scopes), print_if_is_coercion(ref))))))));
}

function print_id_args_data(test, pr, id, l) {
  if (Curry._2(Util$ReactTemplate.List[/* exists */21], test, l)) {
    return Curry._2(pr, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("For "), Names$ReactTemplate.Id[/* print */8](id)), l);
  } else {
    return /* [] */0;
  }
}

function print_args_data_of_inductive_ids(get, test, pr, sp, mipv) {
  return Curry._1(Util$ReactTemplate.List[/* flatten */8], Util$ReactTemplate.$$Array[/* to_list */9](Util$ReactTemplate.$$Array[/* mapi */14]((function (i, mip) {
                        return Util$ReactTemplate.$at(print_id_args_data(test, pr, mip[/* mind_typename */0], Curry._1(get, /* IndRef */Block.__(2, [/* tuple */[
                                                sp,
                                                i
                                              ]]))), Curry._1(Util$ReactTemplate.List[/* flatten */8], Util$ReactTemplate.$$Array[/* to_list */9](Util$ReactTemplate.$$Array[/* mapi */14]((function (j, idc) {
                                                  return print_id_args_data(test, pr, idc, Curry._1(get, /* ConstructRef */Block.__(3, [/* tuple */[
                                                                      /* tuple */[
                                                                        sp,
                                                                        i
                                                                      ],
                                                                      j + 1 | 0
                                                                    ]])));
                                                }), mip[/* mind_consnames */3]))));
                      }), mipv)));
}

function print_inductive_implicit_args(param, param$1) {
  return print_args_data_of_inductive_ids(Impargs$ReactTemplate.implicits_of_global, (function (l) {
                return 1 - Curry._1(Util$ReactTemplate.List[/* is_empty */45], Impargs$ReactTemplate.positions_of_implicits(l));
              }), print_impargs_list, param, param$1);
}

function print_inductive_renames(param, param$1) {
  return print_args_data_of_inductive_ids((function (r) {
                try {
                  return Arguments_renaming$ReactTemplate.arguments_names(r);
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return /* [] */0;
                  } else {
                    throw exn;
                  }
                }
              }), (function (param) {
                return +(/* Anonymous */0 !== param);
              }), print_renames_list, param, param$1);
}

function print_inductive_argument_scopes(param, param$1) {
  return print_args_data_of_inductive_ids(Notation$ReactTemplate.find_arguments_scope, Option$ReactTemplate.has_some, print_argument_scopes, param, param$1);
}

var locatable_map = [Util$ReactTemplate.$$String[/* Map */39][/* empty */0]];

function register_locatable(name, f) {
  locatable_map[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], name, /* Locatable */[f], locatable_map[0]);
  return /* () */0;
}

var ObjFound = Caml_exceptions.create("Prettyp-ReactTemplate.ObjFound");

function locate_any_name(ref) {
  var match = Libnames$ReactTemplate.qualid_of_reference(ref);
  var qid = match[/* v */0];
  try {
    return /* Term */Block.__(0, [Nametab$ReactTemplate.locate(qid)]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      try {
        return /* Syntactic */Block.__(2, [Nametab$ReactTemplate.locate_syndef(qid)]);
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          try {
            return /* Dir */Block.__(1, [Nametab$ReactTemplate.locate_dir(qid)]);
          }
          catch (exn$2){
            if (exn$2 === Caml_builtin_exceptions.not_found) {
              try {
                return /* ModuleType */Block.__(3, [Nametab$ReactTemplate.locate_modtype(qid)]);
              }
              catch (exn$3){
                if (exn$3 === Caml_builtin_exceptions.not_found) {
                  var iter = function (_, param) {
                    var info = param[0];
                    var match = Curry._1(info[/* locate */0], qid);
                    if (match) {
                      throw [
                            ObjFound,
                            /* Other */Block.__(4, [
                                match[0],
                                info
                              ])
                          ];
                    } else {
                      return /* () */0;
                    }
                  };
                  try {
                    Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* iter */9], iter, locatable_map[0]);
                    return /* Undefined */Block.__(5, [qid]);
                  }
                  catch (raw_exn){
                    var exn$4 = Js_exn.internalToOCamlException(raw_exn);
                    if (exn$4[0] === ObjFound) {
                      return exn$4[1];
                    } else {
                      throw exn$4;
                    }
                  }
                } else {
                  throw exn$3;
                }
              }
            } else {
              throw exn$2;
            }
          }
        } else {
          throw exn$1;
        }
      }
    } else {
      throw exn;
    }
  }
}

function pr_located_qualid(param) {
  switch (param.tag | 0) {
    case 0 : 
        var ref = param[0];
        var ref_str;
        switch (ref.tag | 0) {
          case 0 : 
              ref_str = "Variable";
              break;
          case 1 : 
              ref_str = "Constant";
              break;
          case 2 : 
              ref_str = "Inductive";
              break;
          case 3 : 
              ref_str = "Constructor";
              break;
          
        }
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(ref_str), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_path(Nametab$ReactTemplate.path_of_global(ref)));
    case 1 : 
        var dir = param[0];
        var match;
        switch (dir.tag | 0) {
          case 0 : 
              match = /* tuple */[
                "Open Module",
                dir[0][/* obj_dir */0]
              ];
              break;
          case 1 : 
              match = /* tuple */[
                "Open Module Type",
                dir[0][/* obj_dir */0]
              ];
              break;
          case 2 : 
              match = /* tuple */[
                "Open Section",
                dir[0][/* obj_dir */0]
              ];
              break;
          case 3 : 
              match = /* tuple */[
                "Module",
                dir[0][/* obj_dir */0]
              ];
              break;
          case 4 : 
              match = /* tuple */[
                "Closed Section",
                dir[0]
              ];
              break;
          
        }
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(match[0]), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.DirPath[/* print */10](match[1]));
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_path(Nametab$ReactTemplate.path_of_syndef(param[0])));
    case 3 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Module Type"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_path(Nametab$ReactTemplate.path_of_modtype(param[0])));
    case 4 : 
        return Curry._1(param[1][/* name */3], param[0]);
    case 5 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Libnames$ReactTemplate.pr_qualid(param[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("not a defined object."));
    
  }
}

function canonize_ref(param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* None */0;
    case 1 : 
        var c = param[0];
        var kn = Names$ReactTemplate.Constant[/* canonical */5](c);
        if (Names$ReactTemplate.KerName[/* equal */9](Names$ReactTemplate.Constant[/* user */4](c), kn)) {
          return /* None */0;
        } else {
          return /* Some */[/* ConstRef */Block.__(1, [Names$ReactTemplate.Constant[/* make1 */1](kn)])];
        }
    case 2 : 
        var match = param[0];
        var ind = match[0];
        var kn$1 = Names$ReactTemplate.MutInd[/* canonical */5](ind);
        if (Names$ReactTemplate.KerName[/* equal */9](Names$ReactTemplate.MutInd[/* user */4](ind), kn$1)) {
          return /* None */0;
        } else {
          return /* Some */[/* IndRef */Block.__(2, [/* tuple */[
                        Names$ReactTemplate.MutInd[/* make1 */1](kn$1),
                        match[1]
                      ]])];
        }
    case 3 : 
        var match$1 = param[0];
        var match$2 = match$1[0];
        var ind$1 = match$2[0];
        var kn$2 = Names$ReactTemplate.MutInd[/* canonical */5](ind$1);
        if (Names$ReactTemplate.KerName[/* equal */9](Names$ReactTemplate.MutInd[/* user */4](ind$1), kn$2)) {
          return /* None */0;
        } else {
          return /* Some */[/* ConstructRef */Block.__(3, [/* tuple */[
                        /* tuple */[
                          Names$ReactTemplate.MutInd[/* make1 */1](kn$2),
                          match$2[1]
                        ],
                        match$1[1]
                      ]])];
        }
    
  }
}

function display_alias(param) {
  if (param.tag) {
    return Pp$ReactTemplate.mt(/* () */0);
  } else {
    var match = canonize_ref(param[0]);
    if (match) {
      var q$prime = Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], match[0]);
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("(alias of ")), Libnames$ReactTemplate.pr_qualid(q$prime)), Pp$ReactTemplate.str(")"));
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  }
}

function locate_term(qid) {
  var expand = function (param) {
    if (param.tag) {
      var kn = param[0];
      return /* tuple */[
              /* Syntactic */Block.__(2, [kn]),
              Nametab$ReactTemplate.shortest_qualid_of_syndef(Names$ReactTemplate.Id[/* Set */9][/* empty */0], kn)
            ];
    } else {
      var ref = param[0];
      return /* tuple */[
              /* Term */Block.__(0, [ref]),
              Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], ref)
            ];
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* map */10], expand, Nametab$ReactTemplate.locate_extended_all(qid));
}

function locate_module(qid) {
  var all = Nametab$ReactTemplate.locate_extended_all_dir(qid);
  var map = function (dir) {
    switch (dir.tag | 0) {
      case 0 : 
          return /* Some */[/* tuple */[
                    /* Dir */Block.__(1, [dir]),
                    qid
                  ]];
      case 3 : 
          return /* Some */[/* tuple */[
                    /* Dir */Block.__(1, [dir]),
                    Nametab$ReactTemplate.shortest_qualid_of_module(dir[0][/* obj_mp */1])
                  ]];
      default:
        return /* None */0;
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* map_filter */62], map, all);
}

function locate_modtype(qid) {
  var all = Nametab$ReactTemplate.locate_extended_all_modtype(qid);
  var map = function (mp) {
    return /* tuple */[
            /* ModuleType */Block.__(3, [mp]),
            Nametab$ReactTemplate.shortest_qualid_of_modtype(mp)
          ];
  };
  var modtypes = Curry._2(Util$ReactTemplate.List[/* map */10], map, all);
  var all$1 = Nametab$ReactTemplate.locate_extended_all_dir(qid);
  var map$1 = function (dir) {
    if (dir.tag === 1) {
      return /* Some */[/* tuple */[
                /* Dir */Block.__(1, [dir]),
                qid
              ]];
    } else {
      return /* None */0;
    }
  };
  return Util$ReactTemplate.$at(modtypes, Curry._2(Util$ReactTemplate.List[/* map_filter */62], map$1, all$1));
}

function locate_other(s, qid) {
  var match = Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], s, locatable_map[0]);
  var info = match[0];
  var ans = Curry._1(info[/* locate_all */1], qid);
  var map = function (obj) {
    return /* tuple */[
            /* Other */Block.__(4, [
                obj,
                info
              ]),
            Curry._1(info[/* shortest_qualid */2], obj)
          ];
  };
  return Curry._2(Util$ReactTemplate.List[/* map */10], map, ans);
}

function print_located_qualid(name, flags, ref) {
  var match = Libnames$ReactTemplate.qualid_of_reference(ref);
  var qid = match[/* v */0];
  var located;
  if (typeof flags === "number") {
    switch (flags) {
      case 0 : 
          located = locate_term(qid);
          break;
      case 1 : 
          located = Util$ReactTemplate.$at(locate_modtype(qid), locate_module(qid));
          break;
      case 2 : 
          located = Util$ReactTemplate.$at(locate_term(qid), Util$ReactTemplate.$at(locate_modtype(qid), Util$ReactTemplate.$at(locate_module(qid), Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* fold */10], (function (s, _, accu) {
                              return Util$ReactTemplate.$at(locate_other(s, qid), accu);
                            }), locatable_map[0], /* [] */0))));
          break;
      
    }
  } else {
    located = locate_other(flags[0], qid);
  }
  if (located) {
    return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (param) {
                  var oqid = param[1];
                  var o = param[0];
                  return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_located_qualid(o), Libnames$ReactTemplate.qualid_eq(oqid, qid) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("(shorter name to refer to it in current context is ")), Libnames$ReactTemplate.pr_qualid(oqid)), Pp$ReactTemplate.str(")"))), display_alias(o)));
                }), located);
  } else {
    var match$1 = Libnames$ReactTemplate.repr_qualid(qid);
    if (Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], match$1[0])) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No "), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str(" of basename")), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](match$1[1]));
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No "), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str(" of suffix")), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_qualid(qid));
    }
  }
}

function print_located_term(ref) {
  return print_located_qualid("term", /* LocTerm */0, ref);
}

function print_located_other(s, ref) {
  return print_located_qualid(s, /* LocOther */[s], ref);
}

function print_located_module(ref) {
  return print_located_qualid("module", /* LocModule */1, ref);
}

function print_located_qualid$1(ref) {
  return print_located_qualid("object", /* LocAny */2, ref);
}

function gallina_print_typed_value_in_env(env, sigma, param) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_leconstr_env(env, sigma, param[0]), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("     : ")), Printer$ReactTemplate.pr_letype_env(env, sigma, param[1]));
}

function gallina_print_named_decl(env, sigma, param) {
  if (param.tag) {
    var env$1 = env;
    var sigma$1 = sigma;
    var name = Names$ReactTemplate.Id[/* to_string */7](param[0]);
    var body = param[1];
    var typ = param[2];
    var pbody = Printer$ReactTemplate.pr_lconstr_env(env$1, sigma$1, body);
    var ptyp = Printer$ReactTemplate.pr_ltype_env(env$1, sigma$1, typ);
    var pbody$1 = Constr$ReactTemplate.isCast(body) ? Pp$ReactTemplate.surround(pbody) : pbody;
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("*** ["), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str(" ")), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":="), Pp$ReactTemplate.brk(/* tuple */[
                                                    1,
                                                    2
                                                  ])), pbody$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.brk(/* tuple */[
                                    1,
                                    2
                                  ])), ptyp))), Pp$ReactTemplate.str("]"));
  } else {
    var env$2 = env;
    var sigma$2 = sigma;
    var name$1 = Names$ReactTemplate.Id[/* to_string */7](param[0]);
    var typ$1 = param[1];
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("*** ["), Pp$ReactTemplate.str(name$1)), Pp$ReactTemplate.str(" : ")), Printer$ReactTemplate.pr_ltype_env(env$2, sigma$2, typ$1)), Pp$ReactTemplate.str("]"));
  }
}

function assumptions_for_print(lna) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], Termops$ReactTemplate.add_name, lna, Termops$ReactTemplate.empty_names_context);
}

function gallina_print_inductive(sp, udecl) {
  var env = Global$ReactTemplate.env(/* () */0);
  var mib = Environ$ReactTemplate.lookup_mind(sp, env);
  var mipv = mib[/* mind_packets */0];
  return Pp$ReactTemplate.$plus$plus(Printmod$ReactTemplate.pr_mutual_inductive_body(env, sp, mib, udecl), with_line_skip(Util$ReactTemplate.$at(print_primitive_record(mib[/* mind_finite */2], mipv, mib[/* mind_record */1]), Util$ReactTemplate.$at(print_inductive_renames(sp, mipv), Util$ReactTemplate.$at(print_inductive_implicit_args(sp, mipv), print_inductive_argument_scopes(sp, mipv))))));
}

function print_named_decl(env, sigma, id) {
  return Pp$ReactTemplate.$plus$plus(gallina_print_named_decl(env, sigma, Global$ReactTemplate.lookup_named(id)), Pp$ReactTemplate.fnl(/* () */0));
}

function gallina_print_section_variable(env, sigma, id) {
  return Pp$ReactTemplate.$plus$plus(print_named_decl(env, sigma, id), with_line_skip(print_name_infos(/* VarRef */Block.__(0, [id]))));
}

function print_body(env, evd, param) {
  if (param) {
    return Printer$ReactTemplate.pr_lconstr_env(env, evd, param[0]);
  } else {
    return Pp$ReactTemplate.str("<no body>");
  }
}

function print_typed_body(env, evd, param) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(print_body(env, evd, param[0]), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("     : ")), Printer$ReactTemplate.pr_ltype_env(env, evd, param[1]));
}

function print_instance(sigma, cb) {
  if (Declareops$ReactTemplate.constant_is_polymorphic(cb)) {
    var univs = Declareops$ReactTemplate.constant_polymorphic_context(cb);
    var inst = Univ$ReactTemplate.AUContext[/* instance */3](univs);
    var univs$1 = Univ$ReactTemplate.UContext[/* make */0](/* tuple */[
          inst,
          Univ$ReactTemplate.AUContext[/* instantiate */6](inst, univs)
        ]);
    return Printer$ReactTemplate.pr_universe_instance(sigma, univs$1);
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function print_constant(with_values, sep, sp, udecl) {
  var cb = Global$ReactTemplate.lookup_constant(sp);
  var val_0 = Global$ReactTemplate.body_of_constant_body(cb);
  var match = cb[/* const_universes */4];
  var typ;
  if (match.tag) {
    var inst = Univ$ReactTemplate.AUContext[/* instance */3](match[0]);
    typ = Vars$ReactTemplate.subst_instance_constr(inst, cb[/* const_type */2]);
  } else {
    typ = cb[/* const_type */2];
  }
  var otab = Global$ReactTemplate.opaque_tables(/* () */0);
  var match$1 = cb[/* const_body */1];
  var match$2;
  var exit = 0;
  switch (match$1.tag | 0) {
    case 0 : 
    case 1 : 
        exit = 1;
        break;
    case 2 : 
        var body_uctxs = Opaqueproof$ReactTemplate.force_constraints(otab, match$1[0]);
        var match$3 = cb[/* const_universes */4];
        if (match$3.tag) {
          var ctx = match$3[0];
          if (!Univ$ReactTemplate.ContextSet[/* is_empty */1](body_uctxs)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "prettyp.ml",
                    591,
                    8
                  ]
                ];
          }
          var inst$1 = Univ$ReactTemplate.AUContext[/* instance */3](ctx);
          match$2 = /* tuple */[
            /* Polymorphic_const_entry */Block.__(1, [Univ$ReactTemplate.UContext[/* make */0](/* tuple */[
                      inst$1,
                      Univ$ReactTemplate.AUContext[/* instantiate */6](inst$1, ctx)
                    ])]),
            Util$ReactTemplate.$$Array[/* to_list */9](Univ$ReactTemplate.Instance[/* to_array */3](inst$1))
          ];
        } else {
          match$2 = /* tuple */[
            /* Monomorphic_const_entry */Block.__(0, [Univ$ReactTemplate.ContextSet[/* union */6](body_uctxs, match$3[0])]),
            /* [] */0
          ];
        }
        break;
    
  }
  if (exit === 1) {
    var match$4 = cb[/* const_universes */4];
    if (match$4.tag) {
      var ctx$1 = match$4[0];
      var inst$2 = Univ$ReactTemplate.AUContext[/* instance */3](ctx$1);
      match$2 = /* tuple */[
        /* Polymorphic_const_entry */Block.__(1, [Univ$ReactTemplate.UContext[/* make */0](/* tuple */[
                  inst$2,
                  Univ$ReactTemplate.AUContext[/* instantiate */6](inst$2, ctx$1)
                ])]),
        Util$ReactTemplate.$$Array[/* to_list */9](Univ$ReactTemplate.Instance[/* to_array */3](inst$2))
      ];
    } else {
      match$2 = /* tuple */[
        /* Monomorphic_const_entry */Block.__(0, [match$4[0]]),
        /* [] */0
      ];
    }
  }
  var univs = match$2[0];
  var ctx$2 = UState$ReactTemplate.of_binders(Universes$ReactTemplate.universe_binders_with_opt_names(/* ConstRef */Block.__(1, [sp]), match$2[1], udecl));
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_ctx(ctx$2);
  var tmp;
  if (val_0) {
    var match$5 = val_0[0];
    var c = Vars$ReactTemplate.subst_instance_constr(Univ$ReactTemplate.AUContext[/* instance */3](match$5[1]), match$5[0]);
    tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(/* ConstRef */Block.__(1, [sp])), print_instance(sigma, cb)), Pp$ReactTemplate.str(sep)), Pp$ReactTemplate.cut(/* () */0)), with_values ? print_typed_body(env, sigma, /* tuple */[
                    /* Some */[c],
                    typ
                  ]) : Printer$ReactTemplate.pr_ltype_env(env, sigma, typ)), Printer$ReactTemplate.pr_constant_universes(sigma, univs));
  } else {
    tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("*** [ "), Printer$ReactTemplate.pr_global(/* ConstRef */Block.__(1, [sp]))), print_instance(sigma, cb)), Pp$ReactTemplate.str(" : ")), Pp$ReactTemplate.cut(/* () */0)), Printer$ReactTemplate.pr_ltype_env(env, sigma, typ)), Pp$ReactTemplate.str(" ]")), Printer$ReactTemplate.pr_constant_universes(sigma, univs));
  }
  return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_polymorphic(Declareops$ReactTemplate.constant_is_polymorphic(cb)), tmp));
}

function gallina_print_constant_with_infos(sp, udecl) {
  return Pp$ReactTemplate.$plus$plus(print_constant(/* true */1, " = ", sp, udecl), with_line_skip(print_name_infos(/* ConstRef */Block.__(1, [sp]))));
}

function gallina_print_syntactic_def(env, kn) {
  var qid = Nametab$ReactTemplate.shortest_qualid_of_syndef(Names$ReactTemplate.Id[/* Set */9][/* empty */0], kn);
  var match = Syntax_def$ReactTemplate.search_syntactic_definition(kn);
  var c = Notation_ops$ReactTemplate.glob_constr_of_notation_constr(/* None */0, match[1]);
  return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(4, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation "), Libnames$ReactTemplate.pr_qualid(qid)), Pp$ReactTemplate.prlist((function (id) {
                                            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Names$ReactTemplate.Id[/* print */8](id));
                                          }), Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                                return prim[0];
                                              }), match[0]))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":="))), Pp$ReactTemplate.spc(/* () */0)), Constrextern$ReactTemplate.without_specific_symbols(/* :: */[
                        /* SynDefRule */Block.__(1, [kn]),
                        /* [] */0
                      ])((function (param) {
                        return Printer$ReactTemplate.pr_glob_constr_env(env, param);
                      }), c)));
}

function gallina_print_library_entry(env, sigma, with_values, ent) {
  var pr_name = function (param) {
    return Names$ReactTemplate.Id[/* print */8](Libnames$ReactTemplate.basename(param[0]));
  };
  var match = ent[1];
  var oname = ent[0];
  switch (match.tag | 0) {
    case 0 : 
        var env$1 = env;
        var sigma$1 = sigma;
        var with_values$1 = with_values;
        var param = /* tuple */[
          oname,
          match[0]
        ];
        var oname$1 = param[0];
        var kn = oname$1[1];
        var sep = with_values$1 ? " = " : " : ";
        var tag = Libobject$ReactTemplate.object_tag(param[1]);
        switch (tag) {
          case "CONSTANT" : 
              return /* Some */[print_constant(with_values$1, sep, Names$ReactTemplate.Constant[/* make1 */1](kn), /* None */0)];
          case "INDUCTIVE" : 
              return /* Some */[gallina_print_inductive(Names$ReactTemplate.MutInd[/* make1 */1](kn), /* None */0)];
          case "MODULE" : 
              var match$1 = Names$ReactTemplate.KerName[/* repr */2](kn);
              return /* Some */[Printmod$ReactTemplate.print_module(with_values$1, /* MPdot */Block.__(2, [
                              match$1[0],
                              match$1[2]
                            ]))];
          case "MODULE TYPE" : 
              var match$2 = Names$ReactTemplate.KerName[/* repr */2](kn);
              return /* Some */[Printmod$ReactTemplate.print_modtype(/* MPdot */Block.__(2, [
                              match$2[0],
                              match$2[2]
                            ]))];
          case "VARIABLE" : 
              try {
                return /* Some */[print_named_decl(env$1, sigma$1, Libnames$ReactTemplate.basename(oname$1[0]))];
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return /* None */0;
                } else {
                  throw exn;
                }
              }
              break;
          default:
            return /* None */0;
        }
    case 1 : 
        return /* Some */[Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" >>>>>>> Library "), Names$ReactTemplate.DirPath[/* print */10](match[0][/* obj_dir */0]))];
    case 2 : 
        return /* Some */[Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" >>>>>>> Module "), pr_name(oname))];
    case 3 : 
        return /* Some */[Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" >>>>>>> Closed Module "), pr_name(oname))];
    case 4 : 
        return /* Some */[Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" >>>>>>> Section "), pr_name(oname))];
    case 5 : 
        return /* Some */[Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" >>>>>>> Closed Section "), pr_name(oname))];
    
  }
}

function gallina_print_context(env, sigma, with_values) {
  var prec = function (n, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var rest = param[1];
        if (Option$ReactTemplate.is_empty(n) || Option$ReactTemplate.get(n) > 0) {
          var match = gallina_print_library_entry(env, sigma, with_values, param[0]);
          if (match) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(prec(Option$ReactTemplate.map((function (param) {
                                      return -1 + param | 0;
                                    }), n), rest), match[0]), Pp$ReactTemplate.fnl(/* () */0));
          } else {
            _param = rest;
            continue ;
            
          }
        } else {
          return Pp$ReactTemplate.mt(/* () */0);
        }
      } else {
        return Pp$ReactTemplate.mt(/* () */0);
      }
    };
  };
  return prec;
}

function gallina_print_eval(red_fun, env, sigma, _, param) {
  var ntrm = Curry._3(red_fun, env, sigma, param[/* uj_val */0]);
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("     = "), gallina_print_typed_value_in_env(env, sigma, /* tuple */[
                  ntrm,
                  param[/* uj_type */1]
                ]));
}

var default_object_pr = /* record */[
  /* print_inductive */gallina_print_inductive,
  /* print_constant_with_infos */gallina_print_constant_with_infos,
  /* print_section_variable */gallina_print_section_variable,
  /* print_syntactic_def */gallina_print_syntactic_def,
  /* print_module */Printmod$ReactTemplate.print_module,
  /* print_modtype */Printmod$ReactTemplate.print_modtype,
  /* print_named_decl */gallina_print_named_decl,
  /* print_library_entry */gallina_print_library_entry,
  /* print_context */gallina_print_context,
  /* print_typed_value_in_env */gallina_print_typed_value_in_env,
  /* print_eval */gallina_print_eval
];

var object_pr = [default_object_pr];

function set_object_pr(param) {
  object_pr[0] = param;
  return /* () */0;
}

function print_library_entry(x) {
  return Curry._1(object_pr[0][/* print_library_entry */7], x);
}

function print_context(x) {
  return Curry._1(object_pr[0][/* print_context */8], x);
}

function print_eval(x) {
  return Curry._1(object_pr[0][/* print_eval */10], x);
}

function print_judgment(env, sigma, param) {
  return Curry._3(object_pr[0][/* print_typed_value_in_env */9], env, sigma, /* tuple */[
              param[/* uj_val */0],
              param[/* uj_type */1]
            ]);
}

function print_safe_judgment(env, sigma, j) {
  var trm = Safe_typing$ReactTemplate.j_val(j);
  var typ = Safe_typing$ReactTemplate.j_type(j);
  var trm$1 = EConstr$ReactTemplate.of_constr(trm);
  var typ$1 = EConstr$ReactTemplate.of_constr(typ);
  return Curry._3(object_pr[0][/* print_typed_value_in_env */9], env, sigma, /* tuple */[
              trm$1,
              typ$1
            ]);
}

function print_full_context(env, sigma) {
  return Curry._4(print_context(env), sigma, /* true */1, /* None */0, Lib$ReactTemplate.contents(/* () */0));
}

function print_full_context_typ(env, sigma) {
  return Curry._4(print_context(env), sigma, /* false */0, /* None */0, Lib$ReactTemplate.contents(/* () */0));
}

function print_full_pure_context(env, sigma) {
  var prec = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0];
        var match$1 = match[1];
        var kn = match[0][1];
        if (match$1.tag) {
          _param = param[1];
          continue ;
          
        } else {
          var match$2 = Libobject$ReactTemplate.object_tag(match$1[0]);
          var pp;
          switch (match$2) {
            case "CONSTANT" : 
                var con = Global$ReactTemplate.constant_of_delta_kn(kn);
                var cb = Global$ReactTemplate.lookup_constant(con);
                var typ = cb[/* const_type */2];
                var match$3 = cb[/* const_body */1];
                var tmp;
                switch (match$3.tag | 0) {
                  case 0 : 
                      tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Parameter "), Printer$ReactTemplate.pr_global(/* ConstRef */Block.__(1, [con]))), Pp$ReactTemplate.str(" : ")), Pp$ReactTemplate.cut(/* () */0)), Printer$ReactTemplate.pr_ltype_env(env, sigma, typ));
                      break;
                  case 1 : 
                      tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Definition "), Printer$ReactTemplate.pr_global(/* ConstRef */Block.__(1, [con]))), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str("  : ")), Printer$ReactTemplate.pr_ltype_env(env, sigma, typ)), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str(" := ")), Printer$ReactTemplate.pr_lconstr_env(env, sigma, Mod_subst$ReactTemplate.force_constr(match$3[0])));
                      break;
                  case 2 : 
                      tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Theorem "), Printer$ReactTemplate.pr_global(/* ConstRef */Block.__(1, [con]))), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str(" : ")), Printer$ReactTemplate.pr_ltype_env(env, sigma, typ)), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("Proof ")), Printer$ReactTemplate.pr_lconstr_env(env, sigma, Opaqueproof$ReactTemplate.force_proof(Global$ReactTemplate.opaque_tables(/* () */0), match$3[0])));
                      break;
                  
                }
                pp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, tmp), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.fnl(/* () */0));
                break;
            case "INDUCTIVE" : 
                var mind = Global$ReactTemplate.mind_of_delta_kn(kn);
                var mib = Global$ReactTemplate.lookup_mind(mind);
                pp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printmod$ReactTemplate.pr_mutual_inductive_body(Global$ReactTemplate.env(/* () */0), mind, mib, /* None */0), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.fnl(/* () */0));
                break;
            case "MODULE" : 
                var match$4 = Names$ReactTemplate.KerName[/* repr */2](kn);
                pp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._2(object_pr[0][/* print_module */4], /* true */1, /* MPdot */Block.__(2, [
                                    match$4[0],
                                    match$4[2]
                                  ])), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.fnl(/* () */0));
                break;
            case "MODULE TYPE" : 
                var match$5 = Names$ReactTemplate.KerName[/* repr */2](kn);
                pp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(object_pr[0][/* print_modtype */5], /* MPdot */Block.__(2, [
                                    match$5[0],
                                    match$5[2]
                                  ])), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.fnl(/* () */0));
                break;
            default:
              pp = Pp$ReactTemplate.mt(/* () */0);
          }
          return Pp$ReactTemplate.$plus$plus(prec(param[1]), pp);
        }
      } else {
        return Pp$ReactTemplate.mt(/* () */0);
      }
    };
  };
  return prec(Lib$ReactTemplate.contents(/* () */0));
}

function read_sec_context(r) {
  var qid = Libnames$ReactTemplate.qualid_of_reference(r);
  var dir;
  try {
    dir = Nametab$ReactTemplate.locate_section(qid[/* v */0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      dir = CErrors$ReactTemplate.user_err(qid[/* loc */1], /* Some */["read_sec_context"], Pp$ReactTemplate.str("Unknown section."));
    } else {
      throw exn;
    }
  }
  var get_cxt = function (_in_cxt, _param) {
    while(true) {
      var param = _param;
      var in_cxt = _in_cxt;
      if (param) {
        var hd = param[0];
        var match = hd[1];
        switch (match.tag | 0) {
          case 4 : 
              if (Curry._2(Names$ReactTemplate.DirPath[/* equal */0], dir, match[0][/* obj_dir */0])) {
                return /* :: */[
                        hd,
                        in_cxt
                      ];
              } else {
                _param = param[1];
                _in_cxt = /* :: */[
                  hd,
                  in_cxt
                ];
                continue ;
                
              }
              break;
          case 5 : 
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot print the contents of a closed section."));
          default:
            _param = param[1];
            _in_cxt = /* :: */[
              hd,
              in_cxt
            ];
            continue ;
            
        }
      } else {
        return /* [] */0;
      }
    };
  };
  var cxt = Lib$ReactTemplate.contents(/* () */0);
  return Curry._1(Util$ReactTemplate.List[/* rev */4], get_cxt(/* [] */0, cxt));
}

function print_sec_context(env, sigma, sec) {
  return Curry._4(print_context(env), sigma, /* true */1, /* None */0, read_sec_context(sec));
}

function print_sec_context_typ(env, sigma, sec) {
  return Curry._4(print_context(env), sigma, /* false */0, /* None */0, read_sec_context(sec));
}

function maybe_error_reject_univ_decl(na, udecl) {
  if (udecl) {
    if (na.tag) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["reject_univ_decl"], Pp$ReactTemplate.str("This object does not support universe names."));
    } else if (na[0].tag) {
      return /* () */0;
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["reject_univ_decl"], Pp$ReactTemplate.str("This object does not support universe names."));
    }
  } else {
    return /* () */0;
  }
}

function print_any_name(env, sigma, na, udecl) {
  maybe_error_reject_univ_decl(na, udecl);
  switch (na.tag | 0) {
    case 0 : 
        var match = na[0];
        switch (match.tag | 0) {
          case 0 : 
              return Curry._3(object_pr[0][/* print_section_variable */2], env, sigma, match[0]);
          case 1 : 
              return Curry._2(object_pr[0][/* print_constant_with_infos */1], match[0], udecl);
          case 2 : 
              return Curry._2(object_pr[0][/* print_inductive */0], match[0][0], udecl);
          case 3 : 
              return Curry._2(object_pr[0][/* print_inductive */0], match[0][0][0], udecl);
          
        }
        break;
    case 1 : 
        var match$1 = na[0];
        if (match$1.tag === 3) {
          var match$2 = match$1[0];
          return Curry._2(object_pr[0][/* print_module */4], Printmod$ReactTemplate.printable_body(match$2[/* obj_dir */0]), match$2[/* obj_mp */1]);
        } else {
          return Pp$ReactTemplate.mt(/* () */0);
        }
        break;
    case 2 : 
        return Curry._2(object_pr[0][/* print_syntactic_def */3], env, na[0]);
    case 3 : 
        return Curry._1(object_pr[0][/* print_modtype */5], na[0]);
    case 4 : 
        return Curry._1(na[1][/* print */4], na[0]);
    case 5 : 
        var qid = na[0];
        try {
          var match$3 = Libnames$ReactTemplate.repr_qualid(qid);
          if (!Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], match$3[0])) {
            throw Caml_builtin_exceptions.not_found;
          }
          return Curry._3(object_pr[0][/* print_named_decl */6], env, sigma, Global$ReactTemplate.lookup_named(match$3[1]));
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["print_name"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Libnames$ReactTemplate.pr_qualid(qid), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("not a defined object.")));
          } else {
            throw exn;
          }
        }
        break;
    
  }
}

function print_name(env, sigma, na, udecl) {
  var match = na[/* v */0];
  if (match.tag) {
    var match$1 = match[0];
    return print_any_name(env, sigma, /* Term */Block.__(0, [Notation$ReactTemplate.interp_notation_as_global_reference(na[/* loc */1], (function () {
                          return /* true */1;
                        }), match$1[0], match$1[1])]), udecl);
  } else {
    return print_any_name(env, sigma, locate_any_name(match[0]), udecl);
  }
}

function print_opaque_name(env, sigma, qid) {
  var gr = Nametab$ReactTemplate.$$global(qid);
  switch (gr.tag | 0) {
    case 0 : 
        return Curry._3(object_pr[0][/* print_named_decl */6], env, sigma, Environ$ReactTemplate.lookup_named(gr[0], env));
    case 1 : 
        var cst = gr[0];
        var cb = Global$ReactTemplate.lookup_constant(cst);
        if (Declareops$ReactTemplate.constant_has_body(cb)) {
          return Curry._2(object_pr[0][/* print_constant_with_infos */1], cst, /* None */0);
        } else {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not a defined constant."));
        }
    case 2 : 
        return Curry._2(object_pr[0][/* print_inductive */0], gr[0][0], /* None */0);
    case 3 : 
        var match = Global$ReactTemplate.type_of_global_in_context(env, gr);
        var inst = Univ$ReactTemplate.AUContext[/* instance */3](match[1]);
        var ty = Vars$ReactTemplate.subst_instance_constr(inst, match[0]);
        var ty$1 = EConstr$ReactTemplate.of_constr(ty);
        var x = /* tuple */[
          EConstr$ReactTemplate.mkConstruct(gr[0]),
          ty$1
        ];
        return Curry._3(object_pr[0][/* print_typed_value_in_env */9], Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, x);
    
  }
}

function print_about_any(_, env, _$1, k, udecl) {
  maybe_error_reject_univ_decl(k, udecl);
  switch (k.tag | 0) {
    case 0 : 
        var ref = k[0];
        var rb = Reductionops$ReactTemplate.ReductionBehaviour[/* print */2](ref);
        return pr_infos_list(Util$ReactTemplate.$at(/* :: */[
                        print_ref(/* false */0, ref, udecl),
                        /* :: */[
                          blankline,
                          print_name_infos(ref)
                        ]
                      ], Util$ReactTemplate.$at(Pp$ReactTemplate.ismt(rb) ? /* [] */0 : /* :: */[
                              rb,
                              /* [] */0
                            ], Util$ReactTemplate.$at(print_opacity(ref), /* :: */[
                                Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Expands to: "), pr_located_qualid(k))),
                                /* [] */0
                              ]))));
    case 2 : 
        var kn = k[0];
        var match = Syntax_def$ReactTemplate.search_syntactic_definition(kn);
        if (!match[0]) {
          1 - match[1].tag;
        }
        return Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._2(object_pr[0][/* print_syntactic_def */3], env, kn), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Expands to: "), pr_located_qualid(k)))));
    case 4 : 
        return Pp$ReactTemplate.hov(0, Curry._1(k[1][/* about */5], k[0]));
    default:
      return Pp$ReactTemplate.hov(0, pr_located_qualid(k));
  }
}

function print_about(env, sigma, na, udecl) {
  var match = na[/* v */0];
  if (match.tag) {
    var loc = na[/* loc */1];
    var match$1 = match[0];
    return print_about_any(loc, env, sigma, /* Term */Block.__(0, [Notation$ReactTemplate.interp_notation_as_global_reference(loc, (function () {
                          return /* true */1;
                        }), match$1[0], match$1[1])]), udecl);
  } else {
    return print_about_any(na[/* loc */1], env, sigma, locate_any_name(match[0]), udecl);
  }
}

function inspect(env, sigma, depth) {
  return Curry._4(print_context(env), sigma, /* false */0, /* Some */[depth], Lib$ReactTemplate.contents(/* () */0));
}

function print_coercion_value(env, sigma, v) {
  return Printer$ReactTemplate.pr_lconstr_env(env, sigma, Classops$ReactTemplate.get_coercion_value(v));
}

function print_class(i) {
  var match = Classops$ReactTemplate.class_info_from_index(i);
  return Classops$ReactTemplate.pr_class(match[0]);
}

function print_path(env, sigma, param) {
  var match = param[0];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_semicolon, (function (param) {
                                            return print_coercion_value(env, sigma, param);
                                          }), param[1]))), Pp$ReactTemplate.str("] : "))), print_class(match[0])), Pp$ReactTemplate.str(" >-> ")), print_class(match[1]));
}

Classops$ReactTemplate.install_path_printer(print_path);

function print_graph(env, sigma) {
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (param) {
                return print_path(env, sigma, param);
              }), Classops$ReactTemplate.inheritance_graph(/* () */0));
}

function print_classes() {
  return Pp$ReactTemplate.pr_sequence(Classops$ReactTemplate.pr_class, Classops$ReactTemplate.classes(/* () */0));
}

function print_coercions(env, sigma) {
  return Pp$ReactTemplate.pr_sequence((function (param) {
                return print_coercion_value(env, sigma, param);
              }), Classops$ReactTemplate.coercions(/* () */0));
}

function index_of_class(cl) {
  try {
    return Classops$ReactTemplate.class_info(cl)[0];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["index_of_class"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Classops$ReactTemplate.pr_class(cl), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("not a defined class.")));
    } else {
      throw exn;
    }
  }
}

function print_path_between(env, sigma, cls, clt) {
  var i = index_of_class(cls);
  var j = index_of_class(clt);
  var p;
  try {
    p = Classops$ReactTemplate.lookup_path_between_class(/* tuple */[
          i,
          j
        ]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      p = CErrors$ReactTemplate.user_err(/* None */0, /* Some */["index_cl_of_id"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No path between "), Classops$ReactTemplate.pr_class(cls)), Pp$ReactTemplate.str(" and ")), Classops$ReactTemplate.pr_class(clt)), Pp$ReactTemplate.str(".")));
    } else {
      throw exn;
    }
  }
  return print_path(env, sigma, /* tuple */[
              /* tuple */[
                i,
                j
              ],
              p
            ]);
}

function print_canonical_projections(env, sigma) {
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (param) {
                var match = param[0];
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Recordops$ReactTemplate.pr_cs_pattern(match[1]), Pp$ReactTemplate.str(" <- ")), Printer$ReactTemplate.pr_global(match[0])), Pp$ReactTemplate.str(" ( ")), Printer$ReactTemplate.pr_lconstr_env(env, sigma, param[1][/* o_DEF */0])), Pp$ReactTemplate.str(" )"));
              }), Recordops$ReactTemplate.canonical_projections(/* () */0));
}

function print_typeclasses() {
  var env = Global$ReactTemplate.env(/* () */0);
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (param) {
                var t = param;
                return print_ref(/* false */0, t[/* cl_impl */1], /* None */0);
              }), Typeclasses$ReactTemplate.typeclasses(/* () */0));
}

function pr_instance(_, i) {
  var match = Typeclasses$ReactTemplate.hint_priority(i);
  return Pp$ReactTemplate.$plus$plus(print_ref(/* false */0, Typeclasses$ReactTemplate.instance_impl(i), /* None */0), match ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("|")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(match[0])) : Pp$ReactTemplate.mt(/* () */0));
}

function print_all_instances() {
  var env = Global$ReactTemplate.env(/* () */0);
  var inst = Typeclasses$ReactTemplate.all_instances(/* () */0);
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (param) {
                return pr_instance(env, param);
              }), inst);
}

function print_instances(r) {
  var env = Global$ReactTemplate.env(/* () */0);
  var inst = Typeclasses$ReactTemplate.instances(r);
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (param) {
                return pr_instance(env, param);
              }), inst);
}

exports.assumptions_for_print = assumptions_for_print;
exports.print_closed_sections = print_closed_sections;
exports.print_context = print_context;
exports.print_library_entry = print_library_entry;
exports.print_full_context = print_full_context;
exports.print_full_context_typ = print_full_context_typ;
exports.print_full_pure_context = print_full_pure_context;
exports.print_sec_context = print_sec_context;
exports.print_sec_context_typ = print_sec_context_typ;
exports.print_judgment = print_judgment;
exports.print_safe_judgment = print_safe_judgment;
exports.print_eval = print_eval;
exports.print_name = print_name;
exports.print_opaque_name = print_opaque_name;
exports.print_about = print_about;
exports.print_impargs = print_impargs;
exports.print_graph = print_graph;
exports.print_classes = print_classes;
exports.print_coercions = print_coercions;
exports.print_path_between = print_path_between;
exports.print_canonical_projections = print_canonical_projections;
exports.print_typeclasses = print_typeclasses;
exports.print_instances = print_instances;
exports.print_all_instances = print_all_instances;
exports.inspect = inspect;
exports.register_locatable = register_locatable;
exports.print_located_qualid = print_located_qualid$1;
exports.print_located_term = print_located_term;
exports.print_located_module = print_located_module;
exports.print_located_other = print_located_other;
exports.set_object_pr = set_object_pr;
exports.default_object_pr = default_object_pr;
/* blankline Not a pure module */
