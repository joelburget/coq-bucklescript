// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Miscops$ReactTemplate = require("./miscops.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Smartlocate$ReactTemplate = require("../shims/smartlocate.bs.js");

function binding_kind_eq(bk1, bk2) {
  if (bk1 !== 0) {
    if (bk2 !== 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (bk2 !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function abstraction_kind_eq(ak1, ak2) {
  if (ak1 !== 0) {
    if (ak2 !== 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (ak2 !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function binder_kind_eq(b1, b2) {
  if (b1.tag) {
    if (b2.tag) {
      var b2$1 = b2[2];
      if (binding_kind_eq(b1[0], b2[0]) && binding_kind_eq(b1[1], b2[1])) {
        if (b1[2]) {
          return b2$1;
        } else {
          return 1 - b2$1;
        }
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  } else if (b2.tag) {
    return /* false */0;
  } else {
    return binding_kind_eq(b1[0], b2[0]);
  }
}

function names_of_local_assums(bl) {
  return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    switch (param.tag | 0) {
                      case 0 : 
                          return param[0];
                      case 1 : 
                      case 2 : 
                          return /* [] */0;
                      
                    }
                  }), bl));
}

function names_of_local_binders(bl) {
  return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    switch (param.tag | 0) {
                      case 0 : 
                          return param[0];
                      case 1 : 
                          return /* :: */[
                                  param[0],
                                  /* [] */0
                                ];
                      case 2 : 
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                [
                                  "constrexpr_ops.ml",
                                  47,
                                  98
                                ]
                              ];
                      
                    }
                  }), bl));
}

function prim_token_eq(t1, t2) {
  if (t1.tag) {
    if (t2.tag) {
      return +(t1[0] === t2[0]);
    } else {
      return /* false */0;
    }
  } else if (!t2.tag && t1[0] === t2[0]) {
    return +(t1[1] === t2[1]);
  } else {
    return /* false */0;
  }
}

function explicitation_eq(ex1, ex2) {
  if (ex1.tag) {
    if (ex2.tag) {
      return Names$ReactTemplate.Id[/* equal */0](ex1[0], ex2[0]);
    } else {
      return /* false */0;
    }
  } else if (!ex2.tag && ex1[0] === ex2[0]) {
    return Option$ReactTemplate.equal(Names$ReactTemplate.Id[/* equal */0], ex1[1], ex2[1]);
  } else {
    return /* false */0;
  }
}

function eq_ast(f, param, param$1) {
  return Curry._2(f, param[/* v */0], param$1[/* v */0]);
}

function cases_pattern_expr_eq(_p1, _p2) {
  while(true) {
    var p2 = _p2;
    var p1 = _p1;
    if (p1[/* v */0] === p2[/* v */0]) {
      return /* true */1;
    } else {
      var match = p1[/* v */0];
      var match$1 = p2[/* v */0];
      switch (match.tag | 0) {
        case 0 : 
            if (match$1.tag) {
              return /* false */0;
            } else if (eq_ast(Nameops$ReactTemplate.Name[/* equal */4], match[1], match$1[1])) {
              _p2 = match$1[0];
              _p1 = match[0];
              continue ;
              
            } else {
              return /* false */0;
            }
            break;
        case 1 : 
            if (match$1.tag === 1 && Libnames$ReactTemplate.eq_reference(match[0], match$1[0]) && Option$ReactTemplate.equal(Curry._1(Util$ReactTemplate.List[/* equal */44], cases_pattern_expr_eq), match[1], match$1[1])) {
              return Curry._3(Util$ReactTemplate.List[/* equal */44], cases_pattern_expr_eq, match[2], match$1[2]);
            } else {
              return /* false */0;
            }
            break;
        case 2 : 
            if (match$1.tag === 2) {
              return Option$ReactTemplate.equal(Libnames$ReactTemplate.eq_reference, match[0], match$1[0]);
            } else {
              return /* false */0;
            }
            break;
        case 3 : 
            if (match$1.tag === 3) {
              return Curry._3(Util$ReactTemplate.List[/* equal */44], cases_pattern_expr_eq, match[0], match$1[0]);
            } else {
              return /* false */0;
            }
            break;
        case 4 : 
            if (match$1.tag === 4 && match[0] === match$1[0] && cases_pattern_notation_substitution_eq(match[1], match$1[1])) {
              return Curry._3(Util$ReactTemplate.List[/* equal */44], cases_pattern_expr_eq, match[2], match$1[2]);
            } else {
              return /* false */0;
            }
            break;
        case 5 : 
            if (match$1.tag === 5) {
              return prim_token_eq(match[0], match$1[0]);
            } else {
              return /* false */0;
            }
            break;
        case 6 : 
            if (match$1.tag === 6) {
              var equal = function (param, param$1) {
                if (Libnames$ReactTemplate.eq_reference(param[0], param$1[0])) {
                  return cases_pattern_expr_eq(param[1], param$1[1]);
                } else {
                  return /* false */0;
                }
              };
              return Curry._3(Util$ReactTemplate.List[/* equal */44], equal, match[0], match$1[0]);
            } else {
              return /* false */0;
            }
            break;
        case 7 : 
            if (match$1.tag === 7) {
              if (match[0] === match$1[0]) {
                _p2 = match$1[1];
                _p1 = match[1];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 8 : 
            return /* false */0;
        
      }
    }
  };
}

function cases_pattern_notation_substitution_eq(param, param$1) {
  if (Curry._3(Util$ReactTemplate.List[/* equal */44], cases_pattern_expr_eq, param[0], param$1[0])) {
    return Curry._3(Util$ReactTemplate.List[/* equal */44], Curry._1(Util$ReactTemplate.List[/* equal */44], cases_pattern_expr_eq), param[1], param$1[1]);
  } else {
    return /* false */0;
  }
}

function constr_expr_eq(_e1, _e2) {
  while(true) {
    var e2 = _e2;
    var e1 = _e1;
    if (e1[/* v */0] === e2[/* v */0]) {
      return /* true */1;
    } else {
      var match = e1[/* v */0];
      var match$1 = e2[/* v */0];
      switch (match.tag | 0) {
        case 0 : 
            if (!match$1.tag && Libnames$ReactTemplate.eq_reference(match[0], match$1[0])) {
              var u1 = match[1];
              var u2 = match$1[1];
              if (u1) {
                if (u2) {
                  return Caml_obj.caml_equal(u1[0], u2[0]);
                } else {
                  return /* false */0;
                }
              } else if (u2) {
                return /* false */0;
              } else {
                return /* true */1;
              }
            } else {
              return /* false */0;
            }
            break;
        case 1 : 
            if (match$1.tag === 1 && eq_ast(Names$ReactTemplate.Id[/* equal */0], match[0], match$1[0])) {
              return Curry._3(Util$ReactTemplate.List[/* equal */44], fix_expr_eq, match[1], match$1[1]);
            } else {
              return /* false */0;
            }
            break;
        case 2 : 
            if (match$1.tag === 2 && eq_ast(Names$ReactTemplate.Id[/* equal */0], match[0], match$1[0])) {
              return Curry._3(Util$ReactTemplate.List[/* equal */44], cofix_expr_eq, match[1], match$1[1]);
            } else {
              return /* false */0;
            }
            break;
        case 3 : 
            if (match$1.tag === 3) {
              if (Curry._3(Util$ReactTemplate.List[/* equal */44], local_binder_eq, match[0], match$1[0])) {
                _e2 = match$1[1];
                _e1 = match[1];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 4 : 
            if (match$1.tag === 4) {
              if (Curry._3(Util$ReactTemplate.List[/* equal */44], local_binder_eq, match[0], match$1[0])) {
                _e2 = match$1[1];
                _e1 = match[1];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 5 : 
            if (match$1.tag === 5) {
              if (eq_ast(Nameops$ReactTemplate.Name[/* equal */4], match[0], match$1[0])) {
                if (constr_expr_eq(match[1], match$1[1])) {
                  if (Option$ReactTemplate.equal(constr_expr_eq, match[2], match$1[2])) {
                    _e2 = match$1[3];
                    _e1 = match[3];
                    continue ;
                    
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 6 : 
            var match$2 = match[0];
            if (match$1.tag === 6) {
              var match$3 = match$1[0];
              if (Option$ReactTemplate.equal((function (prim, prim$1) {
                        return +(prim === prim$1);
                      }), match$2[0], match$3[0]) && Libnames$ReactTemplate.eq_reference(match$2[1], match$3[1])) {
                return Curry._3(Util$ReactTemplate.List[/* equal */44], constr_expr_eq, match[1], match$1[1]);
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 7 : 
            var match$4 = match[0];
            if (match$1.tag === 7) {
              var match$5 = match$1[0];
              if (Option$ReactTemplate.equal((function (prim, prim$1) {
                        return +(prim === prim$1);
                      }), match$4[0], match$5[0]) && constr_expr_eq(match$4[1], match$5[1])) {
                return Curry._3(Util$ReactTemplate.List[/* equal */44], args_eq, match[1], match$1[1]);
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 8 : 
            if (match$1.tag === 8) {
              var field_eq = function (param, param$1) {
                if (Libnames$ReactTemplate.eq_reference(param[0], param$1[0])) {
                  return constr_expr_eq(param[1], param$1[1]);
                } else {
                  return /* false */0;
                }
              };
              return Curry._3(Util$ReactTemplate.List[/* equal */44], field_eq, match[0], match$1[0]);
            } else {
              return /* false */0;
            }
            break;
        case 9 : 
            if (match$1.tag === 9 && Option$ReactTemplate.equal(constr_expr_eq, match[1], match$1[1]) && Curry._3(Util$ReactTemplate.List[/* equal */44], case_expr_eq, match[2], match$1[2])) {
              return Curry._3(Util$ReactTemplate.List[/* equal */44], branch_expr_eq, match[3], match$1[3]);
            } else {
              return /* false */0;
            }
            break;
        case 10 : 
            var match$6 = match[1];
            if (match$1.tag === 10) {
              var match$7 = match$1[1];
              var partial_arg = Nameops$ReactTemplate.Name[/* equal */4];
              if (Curry._3(Util$ReactTemplate.List[/* equal */44], (function(partial_arg){
                    return function (param, param$1) {
                      return eq_ast(partial_arg, param, param$1);
                    }
                    }(partial_arg)), match[0], match$1[0])) {
                var partial_arg$1 = Nameops$ReactTemplate.Name[/* equal */4];
                if (Option$ReactTemplate.equal((function(partial_arg$1){
                      return function (param, param$1) {
                        return eq_ast(partial_arg$1, param, param$1);
                      }
                      }(partial_arg$1)), match$6[0], match$7[0])) {
                  if (Option$ReactTemplate.equal(constr_expr_eq, match$6[1], match$7[1])) {
                    if (constr_expr_eq(match[2], match$1[2])) {
                      _e2 = match$1[3];
                      _e1 = match[3];
                      continue ;
                      
                    } else {
                      return /* false */0;
                    }
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 11 : 
            var match$8 = match[1];
            if (match$1.tag === 11) {
              var match$9 = match$1[1];
              if (constr_expr_eq(match[0], match$1[0])) {
                var partial_arg$2 = Nameops$ReactTemplate.Name[/* equal */4];
                if (Option$ReactTemplate.equal((function(partial_arg$2){
                      return function (param, param$1) {
                        return eq_ast(partial_arg$2, param, param$1);
                      }
                      }(partial_arg$2)), match$8[0], match$9[0])) {
                  if (Option$ReactTemplate.equal(constr_expr_eq, match$8[1], match$9[1])) {
                    if (constr_expr_eq(match[2], match$1[2])) {
                      _e2 = match$1[3];
                      _e1 = match[3];
                      continue ;
                      
                    } else {
                      return /* false */0;
                    }
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 12 : 
            if (match$1.tag === 12) {
              return /* true */1;
            } else {
              return /* false */0;
            }
            break;
        case 13 : 
            if (match$1.tag === 13) {
              return Names$ReactTemplate.Id[/* equal */0](match[0], match$1[0]);
            } else {
              return /* false */0;
            }
            break;
        case 14 : 
            if (match$1.tag === 14 && Names$ReactTemplate.Id[/* equal */0](match[0], match$1[0])) {
              return Curry._3(Util$ReactTemplate.List[/* equal */44], instance_eq, match[1], match$1[1]);
            } else {
              return /* false */0;
            }
            break;
        case 15 : 
            if (match$1.tag === 15) {
              return Miscops$ReactTemplate.glob_sort_eq(match[0], match$1[0]);
            } else {
              return /* false */0;
            }
            break;
        case 16 : 
            if (match$1.tag === 16 && constr_expr_eq(match[0], match$1[0])) {
              var c1 = match[1];
              var c2 = match$1[1];
              if (typeof c1 === "number") {
                if (typeof c2 === "number") {
                  return /* true */1;
                } else {
                  return /* false */0;
                }
              } else if (c1.tag) {
                if (typeof c2 === "number" || !c2.tag) {
                  return /* false */0;
                } else {
                  return constr_expr_eq(c1[0], c2[0]);
                }
              } else if (typeof c2 === "number" || c2.tag) {
                return /* false */0;
              } else {
                return constr_expr_eq(c1[0], c2[0]);
              }
            } else {
              return /* false */0;
            }
            break;
        case 17 : 
            if (match$1.tag === 17 && match[0] === match$1[0]) {
              var param = match[1];
              var param$1 = match$1[1];
              if (Curry._3(Util$ReactTemplate.List[/* equal */44], constr_expr_eq, param[0], param$1[0]) && Curry._3(Util$ReactTemplate.List[/* equal */44], Curry._1(Util$ReactTemplate.List[/* equal */44], constr_expr_eq), param[1], param$1[1]) && Curry._3(Util$ReactTemplate.List[/* equal */44], cases_pattern_expr_eq, param[2], param$1[2])) {
                return Curry._3(Util$ReactTemplate.List[/* equal */44], Curry._1(Util$ReactTemplate.List[/* equal */44], local_binder_eq), param[3], param$1[3]);
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 18 : 
            if (match$1.tag === 18) {
              if (binding_kind_eq(match[0], match$1[0])) {
                if (Option$ReactTemplate.equal(abstraction_kind_eq, match[1], match$1[1])) {
                  _e2 = match$1[2];
                  _e1 = match[2];
                  continue ;
                  
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 19 : 
            if (match$1.tag === 19) {
              return prim_token_eq(match[0], match$1[0]);
            } else {
              return /* false */0;
            }
            break;
        case 20 : 
            if (match$1.tag === 20) {
              if (match[0] === match$1[0]) {
                _e2 = match$1[1];
                _e1 = match[1];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 21 : 
            if (match$1.tag === 21) {
              if (Libnames$ReactTemplate.eq_reference(match[0], match$1[0])) {
                _e2 = match$1[1];
                _e1 = match[1];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        
      }
    }
  };
}

function args_eq(param, param$1) {
  if (Option$ReactTemplate.equal((function (param, param$1) {
            return eq_ast(explicitation_eq, param, param$1);
          }), param[1], param$1[1])) {
    return constr_expr_eq(param[0], param$1[0]);
  } else {
    return /* false */0;
  }
}

function case_expr_eq(param, param$1) {
  if (constr_expr_eq(param[0], param$1[0])) {
    var partial_arg = Nameops$ReactTemplate.Name[/* equal */4];
    if (Option$ReactTemplate.equal((function (param, param$1) {
              return eq_ast(partial_arg, param, param$1);
            }), param[1], param$1[1])) {
      return Option$ReactTemplate.equal(cases_pattern_expr_eq, param[2], param$1[2]);
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function branch_expr_eq(param, param$1) {
  var match = param$1[/* v */0];
  var match$1 = param[/* v */0];
  if (Curry._3(Util$ReactTemplate.List[/* equal */44], Curry._1(Util$ReactTemplate.List[/* equal */44], cases_pattern_expr_eq), match$1[0], match[0])) {
    return constr_expr_eq(match$1[1], match[1]);
  } else {
    return /* false */0;
  }
}

function fix_expr_eq(param, param$1) {
  var match = param$1[1];
  var match$1 = param[1];
  if (eq_ast(Names$ReactTemplate.Id[/* equal */0], param[0], param$1[0])) {
    var partial_arg = Names$ReactTemplate.Id[/* equal */0];
    if (Option$ReactTemplate.equal((function (param, param$1) {
              return eq_ast(partial_arg, param, param$1);
            }), match$1[0], match[0]) && recursion_order_expr_eq(match$1[1], match[1]) && Curry._3(Util$ReactTemplate.List[/* equal */44], local_binder_eq, param[2], param$1[2]) && constr_expr_eq(param[3], param$1[3])) {
      return constr_expr_eq(param[4], param$1[4]);
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function cofix_expr_eq(param, param$1) {
  if (eq_ast(Names$ReactTemplate.Id[/* equal */0], param[0], param$1[0]) && Curry._3(Util$ReactTemplate.List[/* equal */44], local_binder_eq, param[1], param$1[1]) && constr_expr_eq(param[2], param$1[2])) {
    return constr_expr_eq(param[3], param$1[3]);
  } else {
    return /* false */0;
  }
}

function recursion_order_expr_eq(r1, r2) {
  if (typeof r1 === "number") {
    if (typeof r2 === "number") {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (r1.tag) {
    if (typeof r2 === "number" || !r2.tag || !constr_expr_eq(r1[0], r2[0])) {
      return /* false */0;
    } else {
      return Option$ReactTemplate.equal(constr_expr_eq, r1[1], r2[1]);
    }
  } else if (typeof r2 === "number" || r2.tag) {
    return /* false */0;
  } else {
    return constr_expr_eq(r1[0], r2[0]);
  }
}

function local_binder_eq(l1, l2) {
  switch (l1.tag | 0) {
    case 0 : 
        switch (l2.tag | 0) {
          case 0 : 
              var partial_arg = Nameops$ReactTemplate.Name[/* equal */4];
              if (Curry._3(Util$ReactTemplate.List[/* equal */44], (function (param, param$1) {
                        return eq_ast(partial_arg, param, param$1);
                      }), l1[0], l2[0])) {
                return constr_expr_eq(l1[2], l2[2]);
              } else {
                return /* false */0;
              }
          case 1 : 
          case 2 : 
              return /* false */0;
          
        }
        break;
    case 1 : 
        switch (l2.tag | 0) {
          case 1 : 
              if (eq_ast(Nameops$ReactTemplate.Name[/* equal */4], l1[0], l2[0]) && constr_expr_eq(l1[1], l2[1])) {
                return Option$ReactTemplate.equal(constr_expr_eq, l1[2], l2[2]);
              } else {
                return /* false */0;
              }
          case 0 : 
          case 2 : 
              return /* false */0;
          
        }
        break;
    case 2 : 
        return /* false */0;
    
  }
}

function instance_eq(param, param$1) {
  if (Names$ReactTemplate.Id[/* equal */0](param[0], param$1[0])) {
    return constr_expr_eq(param[1], param$1[1]);
  } else {
    return /* false */0;
  }
}

function constr_loc(c) {
  return c[/* loc */1];
}

function cases_pattern_expr_loc(cp) {
  return cp[/* loc */1];
}

function local_binder_loc(param) {
  switch (param.tag | 0) {
    case 0 : 
        var match = param[0];
        if (match) {
          return Loc$ReactTemplate.merge_opt(match[0][/* loc */1], param[2][/* loc */1]);
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "constrexpr_ops.ml",
                  254,
                  28
                ]
              ];
        }
        break;
    case 1 : 
        var match$1 = param[2];
        var b = param[1];
        var loc = param[0][/* loc */1];
        if (match$1) {
          return Loc$ReactTemplate.merge_opt(loc, Loc$ReactTemplate.merge_opt(b[/* loc */1], match$1[0][/* loc */1]));
        } else {
          return Loc$ReactTemplate.merge_opt(loc, b[/* loc */1]);
        }
    case 2 : 
        return param[0][/* loc */1];
    
  }
}

function local_binders_loc(bll) {
  if (bll) {
    return Loc$ReactTemplate.merge_opt(local_binder_loc(bll[0]), local_binder_loc(Curry._1(Util$ReactTemplate.List[/* last */105], bll)));
  } else {
    return /* None */0;
  }
}

function is_constructor(id) {
  try {
    return Globnames$ReactTemplate.isConstructRef(Curry._1(Smartlocate$ReactTemplate.global_of_extended_global, Nametab$ReactTemplate.locate_extended(Libnames$ReactTemplate.qualid_of_ident(id))));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function cases_pattern_fold_names(f, a, _pt) {
  while(true) {
    var pt = _pt;
    var match = pt[/* v */0];
    switch (match.tag | 0) {
      case 0 : 
          return Nameops$ReactTemplate.Name[/* fold_right */10](f, match[1][/* v */0], cases_pattern_fold_names(f, a, match[0]));
      case 1 : 
          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                        return cases_pattern_fold_names(f, param, param$1);
                      }), Option$ReactTemplate.fold_left(Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                                return cases_pattern_fold_names(f, param, param$1);
                              })), a, match[1]), match[2]);
      case 2 : 
          var match$1 = match[0];
          if (match$1) {
            var match$2 = match$1[0][/* v */0];
            if (match$2.tag) {
              var id = match$2[0];
              if (is_constructor(id)) {
                return a;
              } else {
                return Curry._2(f, id, a);
              }
            } else {
              return a;
            }
          } else {
            return a;
          }
          break;
      case 3 : 
          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                        return cases_pattern_fold_names(f, param, param$1);
                      }), a, match[0]);
      case 4 : 
          var match$3 = match[1];
          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                        return cases_pattern_fold_names(f, param, param$1);
                      }), Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                            return cases_pattern_fold_names(f, param, param$1);
                          }), a, Util$ReactTemplate.$at(match$3[0], Curry._1(Util$ReactTemplate.List[/* flatten */8], match$3[1]))), match[2]);
      case 5 : 
          return a;
      case 6 : 
          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
                        return cases_pattern_fold_names(f, acc, param[1]);
                      }), a, match[0]);
      case 7 : 
          _pt = match[1];
          continue ;
          case 8 : 
          return CErrors$ReactTemplate.user_err(match[0][/* loc */1], /* Some */["cases_pattern_fold_names"], Pp$ReactTemplate.strbrk("Casts are not supported here."));
      
    }
  };
}

var partial_arg = Names$ReactTemplate.Id[/* Set */9][/* empty */0];

var partial_arg$1 = Names$ReactTemplate.Id[/* Set */9][/* add */3];

function ids_of_pattern(param) {
  return cases_pattern_fold_names(partial_arg$1, partial_arg, param);
}

var partial_arg$2 = Names$ReactTemplate.Id[/* Set */9][/* add */3];

var ids_of_pattern_list = Curry._2(Util$ReactTemplate.List[/* fold_left */13], Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
            return cases_pattern_fold_names(partial_arg$2, param, param$1);
          })), Names$ReactTemplate.Id[/* Set */9][/* empty */0]);

function ids_of_cases_indtype(p) {
  return cases_pattern_fold_names(Names$ReactTemplate.Id[/* Set */9][/* add */3], Names$ReactTemplate.Id[/* Set */9][/* empty */0], p);
}

function ids_of_cases_tomatch(tms) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, l) {
                var partial_arg = Names$ReactTemplate.Id[/* Set */9][/* add */3];
                var partial_arg$1 = Nameops$ReactTemplate.Name[/* fold_right */10];
                var partial_arg$2 = function (param, param$1) {
                  return partial_arg$1(partial_arg, param, param$1);
                };
                return Option$ReactTemplate.fold_right((function (t, ids) {
                              return cases_pattern_fold_names(Names$ReactTemplate.Id[/* Set */9][/* add */3], ids, t);
                            }), param[2], Option$ReactTemplate.fold_right((function (param) {
                                  return CAst$ReactTemplate.with_val(partial_arg$2, param);
                                }), param[1], l));
              }), tms, Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
}

function fold_local_binders(g, f, n, acc, b, param) {
  if (param) {
    var match = param[0];
    switch (match.tag | 0) {
      case 0 : 
          var nal = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return param[/* v */0];
                }), match[0]);
          var partial_arg = Nameops$ReactTemplate.Name[/* fold_right */10];
          var n$prime = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                  return partial_arg(g, param, param$1);
                }), nal, n);
          return Curry._3(f, n, fold_local_binders(g, f, n$prime, acc, b, param[1]), match[2]);
      case 1 : 
          return Option$ReactTemplate.fold_left(Curry._1(f, n), Curry._3(f, n, fold_local_binders(g, f, Nameops$ReactTemplate.Name[/* fold_right */10](g, match[0][/* v */0], n), acc, b, param[1]), match[1]), match[2]);
      case 2 : 
          var match$1 = match[0][/* v */0];
          var acc$1 = fold_local_binders(g, f, cases_pattern_fold_names(g, n, match$1[0]), acc, b, param[1]);
          return Option$ReactTemplate.fold_left(Curry._1(f, n), acc$1, match$1[1]);
      
    }
  } else {
    return Curry._3(f, n, acc, b);
  }
}

function fold_constr_expr_with_binders(g, f, n, acc) {
  return (function (param) {
      return CAst$ReactTemplate.with_val((function (param) {
                    var exit = 0;
                    switch (param.tag | 0) {
                      case 1 : 
                          var l = param[1];
                          var n$prime = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param) {
                                  return Curry._1(g, param[0][/* v */0]);
                                }), l, n);
                          return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, acc) {
                                        var lb = param[2];
                                        return fold_local_binders(g, f, n$prime, fold_local_binders(g, f, n, acc, param[3], lb), param[4], lb);
                                      }), l, acc);
                      case 2 : 
                          Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.strbrk("Capture check in multiple binders not done"));
                          return acc;
                      case 3 : 
                      case 4 : 
                          exit = 1;
                          break;
                      case 5 : 
                          return Curry._3(f, Nameops$ReactTemplate.Name[/* fold_right */10](g, param[0][/* v */0], n), Option$ReactTemplate.fold_left(Curry._1(f, n), Curry._3(f, n, acc, param[1]), param[2]), param[3]);
                      case 6 : 
                          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], Curry._1(f, n), acc, param[1]);
                      case 7 : 
                          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], Curry._1(f, n), Curry._3(f, n, acc, param[0][1]), Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                            return prim[0];
                                          }), param[1]));
                      case 8 : 
                          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
                                        return Curry._3(f, n, acc, param[1]);
                                      }), acc, param[0]);
                      case 9 : 
                          var al = param[2];
                          var ids = ids_of_cases_tomatch(al);
                          var acc$1 = Option$ReactTemplate.fold_left(Curry._1(f, Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], g, ids, n)), acc, param[1]);
                          var acc$2 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], Curry._1(f, n), acc$1, Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      return param[0];
                                    }), al));
                          return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, acc) {
                                        var match = param[/* v */0];
                                        var ids = Curry._1(ids_of_pattern_list, match[0]);
                                        return Curry._3(f, Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], g, ids, n), acc, match[1]);
                                      }), param[3], acc$2);
                      case 10 : 
                          var partial_arg = Nameops$ReactTemplate.Name[/* fold_right */10];
                          var partial_arg$1 = function (param, param$1) {
                            return partial_arg(g, param, param$1);
                          };
                          var n$prime$1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param) {
                                  return CAst$ReactTemplate.with_val(partial_arg$1, param);
                                }), param[0], n);
                          var partial_arg$2 = Nameops$ReactTemplate.Name[/* fold_right */10];
                          var partial_arg$3 = function (param, param$1) {
                            return partial_arg$2(g, param, param$1);
                          };
                          return Curry._3(f, Option$ReactTemplate.fold_right((function (param) {
                                            return CAst$ReactTemplate.with_val(partial_arg$3, param);
                                          }), param[1][0], n$prime$1), Curry._3(f, n, acc, param[2]), param[3]);
                      case 11 : 
                          var match = param[1];
                          var acc$3 = Curry._3(f, n, Curry._3(f, n, Curry._3(f, n, acc, param[2]), param[3]), param[0]);
                          var partial_arg$4 = Nameops$ReactTemplate.Name[/* fold_right */10];
                          var partial_arg$5 = function (param, param$1) {
                            return partial_arg$4(g, param, param$1);
                          };
                          return Option$ReactTemplate.fold_left(Curry._1(f, Option$ReactTemplate.fold_right((function (param) {
                                                return CAst$ReactTemplate.with_val(partial_arg$5, param);
                                              }), match[0], n)), acc$3, match[1]);
                      case 16 : 
                          var match$1 = param[1];
                          var a = param[0];
                          if (typeof match$1 === "number") {
                            return Curry._3(f, n, acc, a);
                          } else {
                            return Curry._3(f, n, Curry._3(f, n, acc, a), match$1[0]);
                          }
                      case 17 : 
                          var match$2 = param[1];
                          var acc$4 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], Curry._1(f, n), acc, Util$ReactTemplate.$at(match$2[0], Curry._1(Util$ReactTemplate.List[/* flatten */8], match$2[1])));
                          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, bl) {
                                        return fold_local_binders(g, f, n, acc, CAst$ReactTemplate.make(/* None */0, /* CHole */Block.__(12, [
                                                          /* None */0,
                                                          /* IntroAnonymous */0,
                                                          /* None */0
                                                        ])), bl);
                                      }), acc$4, match$2[3]);
                      case 18 : 
                          return Curry._3(f, n, acc, param[2]);
                      case 20 : 
                      case 21 : 
                          return Curry._3(f, n, acc, param[1]);
                      default:
                        return acc;
                    }
                    if (exit === 1) {
                      return fold_local_binders(g, f, n, acc, param[1], param[0]);
                    }
                    
                  }), param);
    });
}

function free_vars_of_constr_expr(c) {
  var aux = function (bdvars, l, c) {
    var match = c[/* v */0];
    var exit = 0;
    if (match.tag) {
      exit = 1;
    } else {
      var match$1 = match[0][/* v */0];
      if (match$1.tag) {
        var id = match$1[0];
        if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], id, bdvars)) {
          return l;
        } else {
          return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, l);
        }
      } else {
        exit = 1;
      }
    }
    if (exit === 1) {
      return fold_constr_expr_with_binders((function (a, l) {
                      return /* :: */[
                              a,
                              l
                            ];
                    }), aux, bdvars, l)(c);
    }
    
  };
  return aux(/* [] */0, Names$ReactTemplate.Id[/* Set */9][/* empty */0], c);
}

function occur_var_constr_expr(id, c) {
  return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, free_vars_of_constr_expr(c));
}

function map_binder(g, e, nal) {
  var partial_arg = Nameops$ReactTemplate.Name[/* fold_right */10];
  var partial_arg$1 = function (param, param$1) {
    return partial_arg(g, param, param$1);
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param) {
                return CAst$ReactTemplate.with_val(partial_arg$1, param);
              }), nal, e);
}

function map_local_binders(f, g, e, bl) {
  var h = function (param, param$1) {
    var bl = param[1];
    var e = param[0];
    switch (param$1.tag | 0) {
      case 0 : 
          var nal = param$1[0];
          return /* tuple */[
                  map_binder(g, e, nal),
                  /* :: */[
                    /* CLocalAssum */Block.__(0, [
                        nal,
                        param$1[1],
                        Curry._2(f, e, param$1[2])
                      ]),
                    bl
                  ]
                ];
      case 1 : 
          var cna = param$1[0];
          return /* tuple */[
                  Nameops$ReactTemplate.Name[/* fold_right */10](g, cna[/* v */0], e),
                  /* :: */[
                    /* CLocalDef */Block.__(1, [
                        cna,
                        Curry._2(f, e, param$1[1]),
                        Option$ReactTemplate.map(Curry._1(f, e), param$1[2])
                      ]),
                    bl
                  ]
                ];
      case 2 : 
          var match = param$1[0];
          var match$1 = match[/* v */0];
          var pat = match$1[0];
          var ids = Curry._1(ids_of_pattern, pat);
          return /* tuple */[
                  Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], g, ids, e),
                  /* :: */[
                    /* CLocalPattern */Block.__(2, [CAst$ReactTemplate.make(match[/* loc */1], /* tuple */[
                              pat,
                              Option$ReactTemplate.map(Curry._1(f, e), match$1[1])
                            ])]),
                    bl
                  ]
                ];
      
    }
  };
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], h, /* tuple */[
        e,
        /* [] */0
      ], bl);
  return /* tuple */[
          match[0],
          Curry._1(Util$ReactTemplate.List[/* rev */4], match[1])
        ];
}

function map_constr_expr_with_binders(g, f, e) {
  return (function (param) {
      return CAst$ReactTemplate.map((function (x) {
                    switch (x.tag | 0) {
                      case 1 : 
                          var dl = x[1];
                          return /* CFix */Block.__(1, [
                                    x[0],
                                    Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                            var match = map_local_binders(f, g, e, param[2]);
                                            var e$prime = match[0];
                                            var t$prime = Curry._2(f, e$prime, param[3]);
                                            var e$prime$prime = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (e, param) {
                                                    return Curry._2(g, param[0][/* v */0], e);
                                                  }), e$prime, dl);
                                            var d$prime = Curry._2(f, e$prime$prime, param[4]);
                                            return /* tuple */[
                                                    param[0],
                                                    param[1],
                                                    match[1],
                                                    t$prime,
                                                    d$prime
                                                  ];
                                          }), dl)
                                  ]);
                      case 2 : 
                          var dl$1 = x[1];
                          return /* CCoFix */Block.__(2, [
                                    x[0],
                                    Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                            var match = map_local_binders(f, g, e, param[1]);
                                            var e$prime = match[0];
                                            var t$prime = Curry._2(f, e$prime, param[2]);
                                            var e$prime$prime = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (e, param) {
                                                    return Curry._2(g, param[0][/* v */0], e);
                                                  }), e$prime, dl$1);
                                            var d$prime = Curry._2(f, e$prime$prime, param[3]);
                                            return /* tuple */[
                                                    param[0],
                                                    match[1],
                                                    t$prime,
                                                    d$prime
                                                  ];
                                          }), dl$1)
                                  ]);
                      case 3 : 
                          var match = map_local_binders(f, g, e, x[0]);
                          return /* CProdN */Block.__(3, [
                                    match[1],
                                    Curry._2(f, match[0], x[1])
                                  ]);
                      case 4 : 
                          var match$1 = map_local_binders(f, g, e, x[0]);
                          return /* CLambdaN */Block.__(4, [
                                    match$1[1],
                                    Curry._2(f, match$1[0], x[1])
                                  ]);
                      case 5 : 
                          var na = x[0];
                          return /* CLetIn */Block.__(5, [
                                    na,
                                    Curry._2(f, e, x[1]),
                                    Option$ReactTemplate.map(Curry._1(f, e), x[2]),
                                    Curry._2(f, Nameops$ReactTemplate.Name[/* fold_right */10](g, na[/* v */0], e), x[3])
                                  ]);
                      case 6 : 
                          return /* CAppExpl */Block.__(6, [
                                    x[0],
                                    Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(f, e), x[1])
                                  ]);
                      case 7 : 
                          var match$2 = x[0];
                          return /* CApp */Block.__(7, [
                                    /* tuple */[
                                      match$2[0],
                                      Curry._2(f, e, match$2[1])
                                    ],
                                    Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                            return /* tuple */[
                                                    Curry._2(f, e, param[0]),
                                                    param[1]
                                                  ];
                                          }), x[1])
                                  ]);
                      case 8 : 
                          return /* CRecord */Block.__(8, [Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                            return /* tuple */[
                                                    param[0],
                                                    Curry._2(f, e, param[1])
                                                  ];
                                          }), x[0])]);
                      case 9 : 
                          var a = x[2];
                          var bl = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                  var match = param[/* v */0];
                                  var patl = match[0];
                                  var ids = Curry._1(ids_of_pattern_list, patl);
                                  return CAst$ReactTemplate.make(param[/* loc */1], /* tuple */[
                                              patl,
                                              Curry._2(f, Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], g, ids, e), match[1])
                                            ]);
                                }), x[3]);
                          var ids = ids_of_cases_tomatch(a);
                          var po = Option$ReactTemplate.map(Curry._1(f, Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], g, ids, e)), x[1]);
                          return /* CCases */Block.__(9, [
                                    x[0],
                                    po,
                                    Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                            return /* tuple */[
                                                    Curry._2(f, e, param[0]),
                                                    param[1],
                                                    param[2]
                                                  ];
                                          }), a),
                                    bl
                                  ]);
                      case 10 : 
                          var match$3 = x[1];
                          var ona = match$3[0];
                          var nal = x[0];
                          var partial_arg = Nameops$ReactTemplate.Name[/* fold_right */10];
                          var partial_arg$1 = function (param, param$1) {
                            return partial_arg(g, param, param$1);
                          };
                          var e$prime = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param) {
                                  return CAst$ReactTemplate.with_val(partial_arg$1, param);
                                }), nal, e);
                          var partial_arg$2 = Nameops$ReactTemplate.Name[/* fold_right */10];
                          var partial_arg$3 = function (param, param$1) {
                            return partial_arg$2(g, param, param$1);
                          };
                          var e$prime$prime = Option$ReactTemplate.fold_right((function (param) {
                                  return CAst$ReactTemplate.with_val(partial_arg$3, param);
                                }), ona, e);
                          return /* CLetTuple */Block.__(10, [
                                    nal,
                                    /* tuple */[
                                      ona,
                                      Option$ReactTemplate.map(Curry._1(f, e$prime$prime), match$3[1])
                                    ],
                                    Curry._2(f, e, x[2]),
                                    Curry._2(f, e$prime, x[3])
                                  ]);
                      case 11 : 
                          var match$4 = x[1];
                          var ona$1 = match$4[0];
                          var partial_arg$4 = Nameops$ReactTemplate.Name[/* fold_right */10];
                          var partial_arg$5 = function (param, param$1) {
                            return partial_arg$4(g, param, param$1);
                          };
                          var e$prime$1 = Option$ReactTemplate.fold_right((function (param) {
                                  return CAst$ReactTemplate.with_val(partial_arg$5, param);
                                }), ona$1, e);
                          return /* CIf */Block.__(11, [
                                    Curry._2(f, e, x[0]),
                                    /* tuple */[
                                      ona$1,
                                      Option$ReactTemplate.map(Curry._1(f, e$prime$1), match$4[1])
                                    ],
                                    Curry._2(f, e, x[2]),
                                    Curry._2(f, e, x[3])
                                  ]);
                      case 16 : 
                          return /* CCast */Block.__(16, [
                                    Curry._2(f, e, x[0]),
                                    Miscops$ReactTemplate.map_cast_type(Curry._1(f, e), x[1])
                                  ]);
                      case 17 : 
                          var match$5 = x[1];
                          return /* CNotation */Block.__(17, [
                                    x[0],
                                    /* tuple */[
                                      Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(f, e), match$5[0]),
                                      Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Util$ReactTemplate.List[/* map */10], Curry._1(f, e)), match$5[1]),
                                      match$5[2],
                                      Curry._2(Util$ReactTemplate.List[/* map */10], (function (bl) {
                                              return map_local_binders(f, g, e, bl)[1];
                                            }), match$5[3])
                                    ]
                                  ]);
                      case 18 : 
                          return /* CGeneralization */Block.__(18, [
                                    x[0],
                                    x[1],
                                    Curry._2(f, e, x[2])
                                  ]);
                      case 20 : 
                          return /* CDelimiters */Block.__(20, [
                                    x[0],
                                    Curry._2(f, e, x[1])
                                  ]);
                      case 21 : 
                          return /* CProj */Block.__(21, [
                                    x[0],
                                    Curry._2(f, e, x[1])
                                  ]);
                      default:
                        return x;
                    }
                  }), param);
    });
}

function replace_vars_constr_expr(l, x) {
  var match = x[/* v */0];
  var exit = 0;
  if (match.tag) {
    exit = 1;
  } else {
    var match$1 = match[0][/* v */0];
    if (match$1.tag) {
      var loc = x[/* loc */1];
      try {
        return CAst$ReactTemplate.make(loc, /* CRef */Block.__(0, [
                      CAst$ReactTemplate.make(loc, /* Ident */Block.__(1, [Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match$1[0], l)])),
                      match[1]
                    ]));
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return x;
        } else {
          throw exn;
        }
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    return map_constr_expr_with_binders(Names$ReactTemplate.Id[/* Map */10][/* remove */5], replace_vars_constr_expr, l)(x);
  }
  
}

function locs_of_notation(loc, locs, _) {
  var unloc = function (loc) {
    return Option$ReactTemplate.cata(Loc$ReactTemplate.unloc, /* tuple */[
                0,
                0
              ], loc);
  };
  var match = unloc(loc);
  var el = match[1];
  var locs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], unloc, locs);
  var aux = function (_pos, _param) {
    while(true) {
      var param = _param;
      var pos = _pos;
      if (param) {
        var l = param[1];
        var match = param[0];
        var ea = match[1];
        var ba = match[0];
        if (pos === ba) {
          _param = l;
          _pos = ea;
          continue ;
          
        } else {
          return /* :: */[
                  /* tuple */[
                    pos,
                    ba
                  ],
                  aux(ea, l)
                ];
        }
      } else if (pos === el) {
        return /* [] */0;
      } else {
        return /* :: */[
                /* tuple */[
                  pos,
                  el
                ],
                /* [] */0
              ];
      }
    };
  };
  return aux(match[0], Curry._2(Util$ReactTemplate.List[/* sort */38], (function (l1, l2) {
                    return l1[0] - l2[0] | 0;
                  }), locs$1));
}

function ntn_loc(loc, param) {
  var partial_arg = Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* map */10], constr_loc, Util$ReactTemplate.$at(param[0], Curry._1(Util$ReactTemplate.List[/* flatten */8], param[1]))), Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* map */10], cases_pattern_expr_loc, param[2]), Curry._2(Util$ReactTemplate.List[/* map */10], local_binders_loc, param[3])));
  return (function (param) {
      return locs_of_notation(loc, partial_arg, param);
    });
}

function patntn_loc(loc, param) {
  var partial_arg = Curry._2(Util$ReactTemplate.List[/* map */10], cases_pattern_expr_loc, Util$ReactTemplate.$at(param[0], Curry._1(Util$ReactTemplate.List[/* flatten */8], param[1])));
  return (function (param) {
      return locs_of_notation(loc, partial_arg, param);
    });
}

function error_invalid_pattern_notation(loc, _) {
  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("Invalid notation for pattern."));
}

function split_at_annot(bl, na) {
  var names = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return param[/* v */0];
        }), names_of_local_assums(bl));
  if (na) {
    var match = na[0];
    var loc = match[/* loc */1];
    var id = match[/* v */0];
    var _acc = /* [] */0;
    var _param = bl;
    while(true) {
      var param = _param;
      var acc = _acc;
      if (param) {
        var x = param[0];
        switch (x.tag | 0) {
          case 0 : 
              var rest = param[1];
              var t = x[2];
              var k = x[1];
              var test = function (param) {
                var na = param[/* v */0];
                if (na) {
                  return Names$ReactTemplate.Id[/* equal */0](id, na[0]);
                } else {
                  return /* false */0;
                }
              };
              var match$1 = Curry._2(Util$ReactTemplate.List[/* split_when */102], test, x[0]);
              var r = match$1[1];
              var l = match$1[0];
              if (r) {
                var ans = l ? /* :: */[
                    /* CLocalAssum */Block.__(0, [
                        l,
                        k,
                        t
                      ]),
                    acc
                  ] : acc;
                return /* tuple */[
                        Curry._1(Util$ReactTemplate.List[/* rev */4], ans),
                        /* :: */[
                          /* CLocalAssum */Block.__(0, [
                              r,
                              k,
                              t
                            ]),
                          rest
                        ]
                      ];
              } else {
                _param = rest;
                _acc = /* :: */[
                  x,
                  acc
                ];
                continue ;
                
              }
              break;
          case 1 : 
              if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], /* Name */[id], x[0][/* v */0])) {
                return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" must be a proper parameter and not a local definition.")));
              } else {
                _param = param[1];
                _acc = /* :: */[
                  x,
                  acc
                ];
                continue ;
                
              }
              break;
          case 2 : 
              return Loc$ReactTemplate.raise(loc, [
                          Stream.$$Error,
                          "pattern with quote not allowed after fix"
                        ]);
          
        }
      } else {
        return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No parameter named "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(".")));
      }
    };
  } else if (names) {
    return /* tuple */[
            /* [] */0,
            bl
          ];
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("A fixpoint needs at least one parameter."));
  }
}

function mkIdentC(id) {
  var eta = /* Ident */Block.__(1, [id]);
  var eta_000 = CAst$ReactTemplate.make(/* None */0, eta);
  var eta$1 = /* CRef */Block.__(0, [
      eta_000,
      /* None */0
    ]);
  return CAst$ReactTemplate.make(/* None */0, eta$1);
}

function mkRefC(r) {
  var eta = /* CRef */Block.__(0, [
      r,
      /* None */0
    ]);
  return CAst$ReactTemplate.make(/* None */0, eta);
}

function mkCastC(param) {
  var eta_000 = param[0];
  var eta_001 = param[1];
  var eta = /* CCast */Block.__(16, [
      eta_000,
      eta_001
    ]);
  return CAst$ReactTemplate.make(/* None */0, eta);
}

function mkLambdaC(param) {
  var eta_000 = /* :: */[
    /* CLocalAssum */Block.__(0, [
        param[0],
        param[1],
        param[2]
      ]),
    /* [] */0
  ];
  var eta_001 = param[3];
  var eta = /* CLambdaN */Block.__(4, [
      eta_000,
      eta_001
    ]);
  return CAst$ReactTemplate.make(/* None */0, eta);
}

function mkLetInC(param) {
  var eta_000 = param[0];
  var eta_001 = param[1];
  var eta_002 = param[2];
  var eta_003 = param[3];
  var eta = /* CLetIn */Block.__(5, [
      eta_000,
      eta_001,
      eta_002,
      eta_003
    ]);
  return CAst$ReactTemplate.make(/* None */0, eta);
}

function mkProdC(param) {
  var eta_000 = /* :: */[
    /* CLocalAssum */Block.__(0, [
        param[0],
        param[1],
        param[2]
      ]),
    /* [] */0
  ];
  var eta_001 = param[3];
  var eta = /* CProdN */Block.__(3, [
      eta_000,
      eta_001
    ]);
  return CAst$ReactTemplate.make(/* None */0, eta);
}

function mkAppC(param) {
  var f = param[0];
  var l = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
          return /* tuple */[
                  x,
                  /* None */0
                ];
        }), param[1]);
  var match = f[/* v */0];
  if (match.tag === 7) {
    var eta_000 = match[0];
    var eta_001 = Util$ReactTemplate.$at(match[1], l);
    var eta = /* CApp */Block.__(7, [
        eta_000,
        eta_001
      ]);
    return CAst$ReactTemplate.make(/* None */0, eta);
  } else {
    var eta_000$1 = /* tuple */[
      /* None */0,
      f
    ];
    var eta$1 = /* CApp */Block.__(7, [
        eta_000$1,
        l
      ]);
    return CAst$ReactTemplate.make(/* None */0, eta$1);
  }
}

function mkCProdN(loc, bll, c) {
  return CAst$ReactTemplate.make(loc, /* CProdN */Block.__(3, [
                bll,
                c
              ]));
}

function mkCLambdaN(loc, bll, c) {
  return CAst$ReactTemplate.make(loc, /* CLambdaN */Block.__(4, [
                bll,
                c
              ]));
}

function coerce_reference_to_id(param) {
  return CAst$ReactTemplate.with_loc_val((function (loc, param) {
                if (param.tag) {
                  return param[0];
                } else {
                  return CErrors$ReactTemplate.user_err(loc, /* Some */["coerce_reference_to_id"], Pp$ReactTemplate.str("This expression should be a simple identifier."));
                }
              }), param);
}

function coerce_to_id(param) {
  var match = param[/* v */0];
  var exit = 0;
  if (match.tag) {
    exit = 1;
  } else {
    var match$1 = match[0][/* v */0];
    if (match$1.tag) {
      if (match[1]) {
        exit = 1;
      } else {
        return CAst$ReactTemplate.make(param[/* loc */1], match$1[0]);
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    return CErrors$ReactTemplate.user_err(param[/* loc */1], /* Some */["coerce_to_id"], Pp$ReactTemplate.str("This expression should be a simple identifier."));
  }
  
}

function coerce_to_name(param) {
  var match = param[/* v */0];
  var exit = 0;
  switch (match.tag | 0) {
    case 0 : 
        var match$1 = match[0][/* v */0];
        if (match$1.tag) {
          if (match[1]) {
            exit = 1;
          } else {
            return CAst$ReactTemplate.make(param[/* loc */1], /* Name */[match$1[0]]);
          }
        } else {
          exit = 1;
        }
        break;
    case 12 : 
        if (match[0]) {
          exit = 1;
        } else if (typeof match[1] === "number") {
          if (match[2]) {
            exit = 1;
          } else {
            return CAst$ReactTemplate.make(param[/* loc */1], /* Anonymous */0);
          }
        } else {
          exit = 1;
        }
        break;
    default:
      exit = 1;
  }
  if (exit === 1) {
    return CErrors$ReactTemplate.user_err(param[/* loc */1], /* Some */["coerce_to_name"], Pp$ReactTemplate.str("This expression should be a name."));
  }
  
}

function mkCPatOr(loc, disjpat) {
  if (disjpat) {
    if (disjpat[1]) {
      return CAst$ReactTemplate.make(loc, /* CPatOr */Block.__(3, [disjpat]));
    } else {
      return disjpat[0];
    }
  } else {
    return CAst$ReactTemplate.make(loc, /* CPatOr */Block.__(3, [disjpat]));
  }
}

function mkAppPattern(loc, p, lp) {
  var match = p[/* v */0];
  var tmp;
  switch (match.tag | 0) {
    case 1 : 
        var l1 = match[1];
        tmp = l1 ? /* CPatCstr */Block.__(1, [
              match[0],
              l1,
              Util$ReactTemplate.$at(match[2], lp)
            ]) : CErrors$ReactTemplate.user_err(p[/* loc */1], /* Some */["compound_pattern"], Pp$ReactTemplate.str("Nested applications not supported."));
        break;
    case 2 : 
        var match$1 = match[0];
        tmp = match$1 ? /* CPatCstr */Block.__(1, [
              match$1[0],
              /* None */0,
              lp
            ]) : CErrors$ReactTemplate.user_err(p[/* loc */1], /* Some */["compound_pattern"], Pp$ReactTemplate.str("Such pattern cannot have arguments."));
        break;
    case 4 : 
        tmp = /* CPatNotation */Block.__(4, [
            match[0],
            match[1],
            Util$ReactTemplate.$at(match[2], lp)
          ]);
        break;
    default:
      tmp = CErrors$ReactTemplate.user_err(p[/* loc */1], /* Some */["compound_pattern"], Pp$ReactTemplate.str("Such pattern cannot have arguments."));
  }
  return CAst$ReactTemplate.make(loc, tmp);
}

function coerce_to_cases_pattern_expr(c) {
  return CAst$ReactTemplate.map_with_loc((function (loc, param) {
                var exit = 0;
                switch (param.tag | 0) {
                  case 0 : 
                      if (param[1]) {
                        exit = 1;
                      } else {
                        return /* CPatAtom */Block.__(2, [/* Some */[param[0]]]);
                      }
                      break;
                  case 5 : 
                      var match = param[0];
                      var match$1 = match[/* v */0];
                      if (match$1) {
                        if (param[2]) {
                          exit = 1;
                        } else {
                          var match$2 = param[3][/* v */0];
                          if (match$2.tag) {
                            exit = 1;
                          } else {
                            var match$3 = match$2[0][/* v */0];
                            var id = match$1[0];
                            if (match$3.tag) {
                              if (match$2[1]) {
                                exit = 1;
                              } else if (Names$ReactTemplate.Id[/* equal */0](id, match$3[0])) {
                                return /* CPatAlias */Block.__(0, [
                                          coerce_to_cases_pattern_expr(param[1]),
                                          CAst$ReactTemplate.make(match[/* loc */1], /* Name */[id])
                                        ]);
                              } else {
                                exit = 1;
                              }
                            } else {
                              exit = 1;
                            }
                          }
                        }
                      } else {
                        exit = 1;
                      }
                      break;
                  case 6 : 
                      var match$4 = param[0];
                      if (match$4[0]) {
                        exit = 1;
                      } else {
                        return /* CPatCstr */Block.__(1, [
                                  match$4[1],
                                  /* Some */[Curry._2(Util$ReactTemplate.List[/* map */10], coerce_to_cases_pattern_expr, param[1])],
                                  /* [] */0
                                ]);
                      }
                      break;
                  case 7 : 
                      var match$5 = param[0];
                      if (match$5[0]) {
                        exit = 1;
                      } else {
                        var args = param[1];
                        if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
                                  return +(param[1] === /* None */0);
                                }), args)) {
                          return mkAppPattern(/* None */0, coerce_to_cases_pattern_expr(match$5[1]), Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                              return coerce_to_cases_pattern_expr(param[0]);
                                            }), args))[/* v */0];
                        } else {
                          exit = 1;
                        }
                      }
                      break;
                  case 8 : 
                      return /* CPatRecord */Block.__(6, [Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                        return /* tuple */[
                                                param[0],
                                                coerce_to_cases_pattern_expr(param[1])
                                              ];
                                      }), param[0])]);
                  case 12 : 
                      if (param[0]) {
                        exit = 1;
                      } else if (typeof param[1] === "number") {
                        if (param[2]) {
                          exit = 1;
                        } else {
                          return /* CPatAtom */Block.__(2, [/* None */0]);
                        }
                      } else {
                        exit = 1;
                      }
                      break;
                  case 16 : 
                      var match$6 = param[1];
                      if (typeof match$6 === "number") {
                        exit = 1;
                      } else if (match$6.tag) {
                        exit = 1;
                      } else {
                        return /* CPatCast */Block.__(8, [
                                  coerce_to_cases_pattern_expr(param[0]),
                                  match$6[0]
                                ]);
                      }
                      break;
                  case 17 : 
                      var match$7 = param[1];
                      if (match$7[2]) {
                        exit = 1;
                      } else if (match$7[3]) {
                        exit = 1;
                      } else {
                        return /* CPatNotation */Block.__(4, [
                                  param[0],
                                  /* tuple */[
                                    Curry._2(Util$ReactTemplate.List[/* map */10], coerce_to_cases_pattern_expr, match$7[0]),
                                    Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Util$ReactTemplate.List[/* map */10], coerce_to_cases_pattern_expr), match$7[1])
                                  ],
                                  /* [] */0
                                ]);
                      }
                      break;
                  case 19 : 
                      return /* CPatPrim */Block.__(5, [param[0]]);
                  case 20 : 
                      return /* CPatDelimiters */Block.__(7, [
                                param[0],
                                coerce_to_cases_pattern_expr(param[1])
                              ]);
                  default:
                    exit = 1;
                }
                if (exit === 1) {
                  return CErrors$ReactTemplate.user_err(loc, /* Some */["coerce_to_cases_pattern_expr"], Pp$ReactTemplate.str("This expression should be coercible to a pattern."));
                }
                
              }), c);
}

var asymmetric_patterns = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"no parameters in constructors",
      /* optkey : :: */[
        "Asymmetric",
        /* :: */[
          "Patterns",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return asymmetric_patterns[0];
        }),
      /* optwrite */(function (a) {
          asymmetric_patterns[0] = a;
          return /* () */0;
        })
    ]);

function abstract_constr_expr(c, bl) {
  return mkCLambdaN(local_binders_loc(bl), bl, c);
}

function prod_constr_expr(c, bl) {
  return mkCProdN(local_binders_loc(bl), bl, c);
}

var default_binder_kind = /* Default */Block.__(0, [/* Explicit */0]);

exports.explicitation_eq = explicitation_eq;
exports.constr_expr_eq = constr_expr_eq;
exports.local_binder_eq = local_binder_eq;
exports.binding_kind_eq = binding_kind_eq;
exports.binder_kind_eq = binder_kind_eq;
exports.constr_loc = constr_loc;
exports.cases_pattern_expr_loc = cases_pattern_expr_loc;
exports.local_binders_loc = local_binders_loc;
exports.mkIdentC = mkIdentC;
exports.mkRefC = mkRefC;
exports.mkAppC = mkAppC;
exports.mkCastC = mkCastC;
exports.mkLambdaC = mkLambdaC;
exports.mkLetInC = mkLetInC;
exports.mkProdC = mkProdC;
exports.mkCLambdaN = mkCLambdaN;
exports.mkCProdN = mkCProdN;
exports.mkCPatOr = mkCPatOr;
exports.mkAppPattern = mkAppPattern;
exports.abstract_constr_expr = abstract_constr_expr;
exports.prod_constr_expr = prod_constr_expr;
exports.coerce_reference_to_id = coerce_reference_to_id;
exports.coerce_to_id = coerce_to_id;
exports.coerce_to_name = coerce_to_name;
exports.coerce_to_cases_pattern_expr = coerce_to_cases_pattern_expr;
exports.default_binder_kind = default_binder_kind;
exports.names_of_local_binders = names_of_local_binders;
exports.names_of_local_assums = names_of_local_assums;
exports.fold_constr_expr_with_binders = fold_constr_expr_with_binders;
exports.map_constr_expr_with_binders = map_constr_expr_with_binders;
exports.replace_vars_constr_expr = replace_vars_constr_expr;
exports.ids_of_cases_indtype = ids_of_cases_indtype;
exports.free_vars_of_constr_expr = free_vars_of_constr_expr;
exports.occur_var_constr_expr = occur_var_constr_expr;
exports.split_at_annot = split_at_annot;
exports.ntn_loc = ntn_loc;
exports.patntn_loc = patntn_loc;
exports.error_invalid_pattern_notation = error_invalid_pattern_notation;
exports.asymmetric_patterns = asymmetric_patterns;
/* ids_of_pattern_list Not a pure module */
