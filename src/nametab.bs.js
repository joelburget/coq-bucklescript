// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var HMap$ReactTemplate = require("./hMap.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");

var GlobalizationError = Caml_exceptions.create("Nametab-ReactTemplate.GlobalizationError");

function error_global_not_found(param) {
  return Loc$ReactTemplate.raise(param[/* loc */1], [
              GlobalizationError,
              param[/* v */0]
            ]);
}

function Make(U) {
  return (function (E) {
      var warn_masking_absolute = CWarnings$ReactTemplate.create("masking-absolute-name", "deprecated", /* None */0, (function (n) {
              return Pp$ReactTemplate.str("Trying to mask the absolute name \"" + (Curry._1(U[/* to_string */1], n) + "\"!"));
            }));
      var empty_tree_001 = /* map */Names$ReactTemplate.ModIdmap[/* empty */0];
      var empty_tree = /* record */[
        /* path : Nothing */0,
        empty_tree_001
      ];
      var empty = Names$ReactTemplate.Id[/* Map */10][/* empty */0];
      var push_until = function (uname, o, level, tree, param) {
        if (param) {
          var path = param[1];
          var modid = param[0];
          var modify = function (_, mc) {
            return push_until(uname, o, level - 1 | 0, mc, path);
          };
          var map;
          try {
            map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              var ptab = modify(/* () */0, empty_tree);
              map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
            } else {
              throw exn;
            }
          }
          var $$this;
          if (level <= 0) {
            var match = tree[/* path */0];
            if (typeof match === "number") {
              $$this = /* Relative */Block.__(0, [
                  uname,
                  o
                ]);
            } else if (match.tag) {
              Curry._2(warn_masking_absolute, /* None */0, match[0]);
              $$this = tree[/* path */0];
            } else {
              $$this = /* Relative */Block.__(0, [
                  uname,
                  o
                ]);
            }
          } else {
            $$this = tree[/* path */0];
          }
          return /* record */[
                  /* path */$$this,
                  /* map */map
                ];
        } else {
          var match$1 = tree[/* path */0];
          if (typeof match$1 === "number") {
            return /* record */[
                    /* path : Absolute */Block.__(1, [
                        uname,
                        o
                      ]),
                    /* map */tree[/* map */1]
                  ];
          } else if (match$1.tag) {
            var uname$prime = match$1[0];
            if (Curry._2(E[/* equal */0], match$1[1], o)) {
              if (!Curry._2(U[/* equal */0], uname, uname$prime)) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "nametab.ml",
                        137,
                        2
                      ]
                    ];
              }
              return tree;
            } else {
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot mask the absolute name \"" + (Curry._1(U[/* to_string */1], uname$prime) + "\"!")));
            }
          } else {
            return /* record */[
                    /* path : Absolute */Block.__(1, [
                        uname,
                        o
                      ]),
                    /* map */tree[/* map */1]
                  ];
          }
        }
      };
      var push_exactly = function (uname, o, level, tree, param) {
        if (param) {
          var path = param[1];
          var modid = param[0];
          if (level) {
            var modify = function (_, mc) {
              return push_exactly(uname, o, level - 1 | 0, mc, path);
            };
            var map;
            try {
              map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                var ptab = modify(/* () */0, empty_tree);
                map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
              } else {
                throw exn;
              }
            }
            return /* record */[
                    /* path */tree[/* path */0],
                    /* map */map
                  ];
          } else {
            var match = tree[/* path */0];
            var $$this;
            if (typeof match === "number") {
              $$this = /* Relative */Block.__(0, [
                  uname,
                  o
                ]);
            } else if (match.tag) {
              Curry._2(warn_masking_absolute, /* None */0, match[0]);
              $$this = tree[/* path */0];
            } else {
              $$this = /* Relative */Block.__(0, [
                  uname,
                  o
                ]);
            }
            return /* record */[
                    /* path */$$this,
                    /* map */tree[/* map */1]
                  ];
          }
        } else {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Prefix longer than path! Impossible!"));
        }
      };
      var push = function (visibility, uname, o, tab) {
        var match = Curry._1(U[/* repr */2], uname);
        var dir = match[1];
        var id = match[0];
        var modify = function (_, ptab) {
          if (visibility.tag) {
            return push_exactly(uname, o, visibility[0] - 1 | 0, ptab, dir);
          } else {
            return push_until(uname, o, visibility[0] - 1 | 0, ptab, dir);
          }
        };
        try {
          return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* modify */26], id, modify, tab);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            var ptab = modify(/* () */0, empty_tree);
            return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, ptab, tab);
          } else {
            throw exn;
          }
        }
      };
      var search = function (_tree, _param) {
        while(true) {
          var param = _param;
          var tree = _tree;
          if (param) {
            _param = param[1];
            _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], param[0], tree[/* map */1]);
            continue ;
            
          } else {
            return tree[/* path */0];
          }
        };
      };
      var find_node = function (qid, tab) {
        var match = Libnames$ReactTemplate.repr_qualid(qid);
        return search(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[1], tab), Names$ReactTemplate.DirPath[/* repr */4](match[0]));
      };
      var locate = function (qid, tab) {
        var match = find_node(qid, tab);
        if (typeof match === "number") {
          throw Caml_builtin_exceptions.not_found;
        } else {
          return match[1];
        }
      };
      var user_name = function (qid, tab) {
        var match = find_node(qid, tab);
        if (typeof match === "number") {
          throw Caml_builtin_exceptions.not_found;
        } else {
          return match[0];
        }
      };
      var find = function (uname, tab) {
        var match = Curry._1(U[/* repr */2], uname);
        var match$1 = search(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[0], tab), match[1]);
        if (typeof match$1 === "number") {
          throw Caml_builtin_exceptions.not_found;
        } else if (match$1.tag) {
          return match$1[1];
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
      };
      var exists = function (uname, tab) {
        try {
          find(uname, tab);
          return /* true */1;
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return /* false */0;
          } else {
            throw exn;
          }
        }
      };
      var shortest_qualid = function (ctx, uname, tab) {
        var match = Curry._1(U[/* repr */2], uname);
        var id = match[0];
        var hidden = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, ctx);
        var find_uname = function (_pos, _dir, _tree) {
          while(true) {
            var tree = _tree;
            var dir = _dir;
            var pos = _pos;
            var is_empty = pos ? /* false */0 : /* true */1;
            var match = tree[/* path */0];
            var exit = 0;
            if (typeof match === "number") {
              exit = 1;
            } else if (Curry._2(U[/* equal */0], match[0], uname) && !(is_empty && hidden)) {
              return Curry._1(Util$ReactTemplate.List[/* rev */4], pos);
            } else {
              exit = 1;
            }
            if (exit === 1) {
              if (dir) {
                var id = dir[0];
                _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], id, tree[/* map */1]);
                _dir = dir[1];
                _pos = /* :: */[
                  id,
                  pos
                ];
                continue ;
                
              } else {
                throw Caml_builtin_exceptions.not_found;
              }
            }
            
          };
        };
        var ptab = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, tab);
        var found_dir = find_uname(/* [] */0, match[1], ptab);
        return Libnames$ReactTemplate.make_qualid(Names$ReactTemplate.DirPath[/* make */3](found_dir), id);
      };
      var push_node = function (node, l) {
        if (typeof node === "number") {
          return l;
        } else {
          var o = node[1];
          if (Curry._3(Util$ReactTemplate.List[/* mem_f */47], E[/* equal */0], o, l)) {
            return l;
          } else {
            return /* :: */[
                    o,
                    l
                  ];
          }
        }
      };
      var flatten_idmap = function (tab, l) {
        var f = function (_, tree, l) {
          return flatten_idmap(tree[/* map */1], push_node(tree[/* path */0], l));
        };
        return Curry._3(Names$ReactTemplate.ModIdmap[/* fold */10], f, tab, l);
      };
      var find_prefixes = function (qid, tab) {
        try {
          var match = Libnames$ReactTemplate.repr_qualid(qid);
          var _tree = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[1], tab);
          var _param = Names$ReactTemplate.DirPath[/* repr */4](match[0]);
          while(true) {
            var param = _param;
            var tree = _tree;
            if (param) {
              _param = param[1];
              _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], param[0], tree[/* map */1]);
              continue ;
              
            } else {
              return Curry._1(Util$ReactTemplate.List[/* rev */4], flatten_idmap(tree[/* map */1], push_node(tree[/* path */0], /* [] */0)));
            }
          };
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return /* [] */0;
          } else {
            throw exn;
          }
        }
      };
      return /* module */[
              /* empty */empty,
              /* push */push,
              /* locate */locate,
              /* find */find,
              /* exists */exists,
              /* user_name */user_name,
              /* shortest_qualid */shortest_qualid,
              /* find_prefixes */find_prefixes
            ];
    });
}

function repr(sp) {
  var match = Libnames$ReactTemplate.repr_path(sp);
  return /* tuple */[
          match[1],
          Names$ReactTemplate.DirPath[/* repr */4](match[0])
        ];
}

var E = [Globnames$ReactTemplate.ExtRefOrdered[1]];

var warn_masking_absolute = CWarnings$ReactTemplate.create("masking-absolute-name", "deprecated", /* None */0, (function (n) {
        return Pp$ReactTemplate.str("Trying to mask the absolute name \"" + (Libnames$ReactTemplate.string_of_path(n) + "\"!"));
      }));

var empty_tree_001 = /* map */Names$ReactTemplate.ModIdmap[/* empty */0];

var empty_tree = /* record */[
  /* path : Nothing */0,
  empty_tree_001
];

var empty = Names$ReactTemplate.Id[/* Map */10][/* empty */0];

function push_until(uname, o, level, tree, param) {
  if (param) {
    var path = param[1];
    var modid = param[0];
    var modify = function (_, mc) {
      return push_until(uname, o, level - 1 | 0, mc, path);
    };
    var map;
    try {
      map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var ptab = modify(/* () */0, empty_tree);
        map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
      } else {
        throw exn;
      }
    }
    var $$this;
    if (level <= 0) {
      var match = tree[/* path */0];
      if (typeof match === "number") {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      } else if (match.tag) {
        Curry._2(warn_masking_absolute, /* None */0, match[0]);
        $$this = tree[/* path */0];
      } else {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      }
    } else {
      $$this = tree[/* path */0];
    }
    return /* record */[
            /* path */$$this,
            /* map */map
          ];
  } else {
    var match$1 = tree[/* path */0];
    var exit = 0;
    if (typeof match$1 === "number") {
      exit = 1;
    } else if (match$1.tag) {
      var uname$prime = match$1[0];
      if (Curry._2(E[/* equal */0], match$1[1], o)) {
        if (!Libnames$ReactTemplate.eq_full_path(uname, uname$prime)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "nametab.ml",
                  137,
                  2
                ]
              ];
        }
        return tree;
      } else {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot mask the absolute name \"" + (Libnames$ReactTemplate.string_of_path(uname$prime) + "\"!")));
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* record */[
              /* path : Absolute */Block.__(1, [
                  uname,
                  o
                ]),
              /* map */tree[/* map */1]
            ];
    }
    
  }
}

function push_exactly(uname, o, level, tree, param) {
  if (param) {
    var path = param[1];
    var modid = param[0];
    if (level) {
      var modify = function (_, mc) {
        return push_exactly(uname, o, level - 1 | 0, mc, path);
      };
      var map;
      try {
        map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var ptab = modify(/* () */0, empty_tree);
          map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
        } else {
          throw exn;
        }
      }
      return /* record */[
              /* path */tree[/* path */0],
              /* map */map
            ];
    } else {
      var match = tree[/* path */0];
      var $$this;
      if (typeof match === "number") {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      } else if (match.tag) {
        Curry._2(warn_masking_absolute, /* None */0, match[0]);
        $$this = tree[/* path */0];
      } else {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      }
      return /* record */[
              /* path */$$this,
              /* map */tree[/* map */1]
            ];
    }
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Prefix longer than path! Impossible!"));
  }
}

function push(visibility, uname, o, tab) {
  var match = repr(uname);
  var dir = match[1];
  var id = match[0];
  var modify = function (_, ptab) {
    if (visibility.tag) {
      return push_exactly(uname, o, visibility[0] - 1 | 0, ptab, dir);
    } else {
      return push_until(uname, o, visibility[0] - 1 | 0, ptab, dir);
    }
  };
  try {
    return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* modify */26], id, modify, tab);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var ptab = modify(/* () */0, empty_tree);
      return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, ptab, tab);
    } else {
      throw exn;
    }
  }
}

function search(_tree, _param) {
  while(true) {
    var param = _param;
    var tree = _tree;
    if (param) {
      _param = param[1];
      _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], param[0], tree[/* map */1]);
      continue ;
      
    } else {
      return tree[/* path */0];
    }
  };
}

function find_node(qid, tab) {
  var match = Libnames$ReactTemplate.repr_qualid(qid);
  return search(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[1], tab), Names$ReactTemplate.DirPath[/* repr */4](match[0]));
}

function find(uname, tab) {
  var match = repr(uname);
  var match$1 = search(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[0], tab), match[1]);
  if (typeof match$1 === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else if (match$1.tag) {
    return match$1[1];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function exists(uname, tab) {
  try {
    find(uname, tab);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function shortest_qualid(ctx, uname, tab) {
  var match = repr(uname);
  var id = match[0];
  var hidden = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, ctx);
  var find_uname = function (_pos, _dir, _tree) {
    while(true) {
      var tree = _tree;
      var dir = _dir;
      var pos = _pos;
      var is_empty = pos ? /* false */0 : /* true */1;
      var match = tree[/* path */0];
      var exit = 0;
      var exit$1 = 0;
      var u;
      if (typeof match === "number") {
        exit = 1;
      } else {
        u = match[0];
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        if (Libnames$ReactTemplate.eq_full_path(u, uname) && !(is_empty && hidden)) {
          return Curry._1(Util$ReactTemplate.List[/* rev */4], pos);
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        if (dir) {
          var id = dir[0];
          _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], id, tree[/* map */1]);
          _dir = dir[1];
          _pos = /* :: */[
            id,
            pos
          ];
          continue ;
          
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
      }
      
    };
  };
  var ptab = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, tab);
  var found_dir = find_uname(/* [] */0, match[1], ptab);
  return Libnames$ReactTemplate.make_qualid(Names$ReactTemplate.DirPath[/* make */3](found_dir), id);
}

function push_node(node, l) {
  var exit = 0;
  var o;
  if (typeof node === "number") {
    return l;
  } else {
    o = node[1];
    exit = 1;
  }
  if (exit === 1) {
    if (Curry._3(Util$ReactTemplate.List[/* mem_f */47], E[/* equal */0], o, l)) {
      return l;
    } else {
      return /* :: */[
              o,
              l
            ];
    }
  }
  
}

function flatten_idmap(tab, l) {
  var f = function (_, tree, l) {
    return flatten_idmap(tree[/* map */1], push_node(tree[/* path */0], l));
  };
  return Curry._3(Names$ReactTemplate.ModIdmap[/* fold */10], f, tab, l);
}

function find_prefixes(qid, tab) {
  try {
    var match = Libnames$ReactTemplate.repr_qualid(qid);
    var _tree = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[1], tab);
    var _param = Names$ReactTemplate.DirPath[/* repr */4](match[0]);
    while(true) {
      var param = _param;
      var tree = _tree;
      if (param) {
        _param = param[1];
        _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], param[0], tree[/* map */1]);
        continue ;
        
      } else {
        return Curry._1(Util$ReactTemplate.List[/* rev */4], flatten_idmap(tree[/* map */1], push_node(tree[/* path */0], /* [] */0)));
      }
    };
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

var E$1 = [Names$ReactTemplate.ModPath[1]];

var warn_masking_absolute$1 = CWarnings$ReactTemplate.create("masking-absolute-name", "deprecated", /* None */0, (function (n) {
        return Pp$ReactTemplate.str("Trying to mask the absolute name \"" + (Libnames$ReactTemplate.string_of_path(n) + "\"!"));
      }));

var empty_tree_001$1 = /* map */Names$ReactTemplate.ModIdmap[/* empty */0];

var empty_tree$1 = /* record */[
  /* path : Nothing */0,
  empty_tree_001$1
];

var empty$1 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];

function push_until$1(uname, o, level, tree, param) {
  if (param) {
    var path = param[1];
    var modid = param[0];
    var modify = function (_, mc) {
      return push_until$1(uname, o, level - 1 | 0, mc, path);
    };
    var map;
    try {
      map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var ptab = modify(/* () */0, empty_tree$1);
        map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
      } else {
        throw exn;
      }
    }
    var $$this;
    if (level <= 0) {
      var match = tree[/* path */0];
      if (typeof match === "number") {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      } else if (match.tag) {
        Curry._2(warn_masking_absolute$1, /* None */0, match[0]);
        $$this = tree[/* path */0];
      } else {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      }
    } else {
      $$this = tree[/* path */0];
    }
    return /* record */[
            /* path */$$this,
            /* map */map
          ];
  } else {
    var match$1 = tree[/* path */0];
    var exit = 0;
    if (typeof match$1 === "number") {
      exit = 1;
    } else if (match$1.tag) {
      var uname$prime = match$1[0];
      if (Curry._2(E$1[/* equal */0], match$1[1], o)) {
        if (!Libnames$ReactTemplate.eq_full_path(uname, uname$prime)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "nametab.ml",
                  137,
                  2
                ]
              ];
        }
        return tree;
      } else {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot mask the absolute name \"" + (Libnames$ReactTemplate.string_of_path(uname$prime) + "\"!")));
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* record */[
              /* path : Absolute */Block.__(1, [
                  uname,
                  o
                ]),
              /* map */tree[/* map */1]
            ];
    }
    
  }
}

function push_exactly$1(uname, o, level, tree, param) {
  if (param) {
    var path = param[1];
    var modid = param[0];
    if (level) {
      var modify = function (_, mc) {
        return push_exactly$1(uname, o, level - 1 | 0, mc, path);
      };
      var map;
      try {
        map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var ptab = modify(/* () */0, empty_tree$1);
          map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
        } else {
          throw exn;
        }
      }
      return /* record */[
              /* path */tree[/* path */0],
              /* map */map
            ];
    } else {
      var match = tree[/* path */0];
      var $$this;
      if (typeof match === "number") {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      } else if (match.tag) {
        Curry._2(warn_masking_absolute$1, /* None */0, match[0]);
        $$this = tree[/* path */0];
      } else {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      }
      return /* record */[
              /* path */$$this,
              /* map */tree[/* map */1]
            ];
    }
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Prefix longer than path! Impossible!"));
  }
}

function push$1(visibility, uname, o, tab) {
  var match = repr(uname);
  var dir = match[1];
  var id = match[0];
  var modify = function (_, ptab) {
    if (visibility.tag) {
      return push_exactly$1(uname, o, visibility[0] - 1 | 0, ptab, dir);
    } else {
      return push_until$1(uname, o, visibility[0] - 1 | 0, ptab, dir);
    }
  };
  try {
    return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* modify */26], id, modify, tab);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var ptab = modify(/* () */0, empty_tree$1);
      return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, ptab, tab);
    } else {
      throw exn;
    }
  }
}

function search$1(_tree, _param) {
  while(true) {
    var param = _param;
    var tree = _tree;
    if (param) {
      _param = param[1];
      _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], param[0], tree[/* map */1]);
      continue ;
      
    } else {
      return tree[/* path */0];
    }
  };
}

function find_node$1(qid, tab) {
  var match = Libnames$ReactTemplate.repr_qualid(qid);
  return search$1(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[1], tab), Names$ReactTemplate.DirPath[/* repr */4](match[0]));
}

function find$1(uname, tab) {
  var match = repr(uname);
  var match$1 = search$1(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[0], tab), match[1]);
  if (typeof match$1 === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else if (match$1.tag) {
    return match$1[1];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function push_node$1(node, l) {
  var exit = 0;
  var o;
  if (typeof node === "number") {
    return l;
  } else {
    o = node[1];
    exit = 1;
  }
  if (exit === 1) {
    if (Curry._3(Util$ReactTemplate.List[/* mem_f */47], E$1[/* equal */0], o, l)) {
      return l;
    } else {
      return /* :: */[
              o,
              l
            ];
    }
  }
  
}

function flatten_idmap$1(tab, l) {
  var f = function (_, tree, l) {
    return flatten_idmap$1(tree[/* map */1], push_node$1(tree[/* path */0], l));
  };
  return Curry._3(Names$ReactTemplate.ModIdmap[/* fold */10], f, tab, l);
}

var the_ccitab = [empty];

var the_modtypetab = [empty$1];

var equal = Names$ReactTemplate.DirPath[0];

var to_string = Names$ReactTemplate.DirPath[7];

function repr$1(dir) {
  var match = Names$ReactTemplate.DirPath[/* repr */4](dir);
  if (match) {
    return /* tuple */[
            match[0],
            match[1]
          ];
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Empty dirpath."));
  }
}

var GlobDir = /* module */[/* equal */Libnames$ReactTemplate.eq_global_dir_reference];

var DirTab = (function (E) {
      var warn_masking_absolute = CWarnings$ReactTemplate.create("masking-absolute-name", "deprecated", /* None */0, (function (n) {
              return Pp$ReactTemplate.str("Trying to mask the absolute name \"" + (Curry._1(to_string, n) + "\"!"));
            }));
      var empty_tree_001 = /* map */Names$ReactTemplate.ModIdmap[/* empty */0];
      var empty_tree = /* record */[
        /* path : Nothing */0,
        empty_tree_001
      ];
      var empty = Names$ReactTemplate.Id[/* Map */10][/* empty */0];
      var push_until = function (uname, o, level, tree, param) {
        if (param) {
          var path = param[1];
          var modid = param[0];
          var modify = function (_, mc) {
            return push_until(uname, o, level - 1 | 0, mc, path);
          };
          var map;
          try {
            map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              var ptab = modify(/* () */0, empty_tree);
              map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
            } else {
              throw exn;
            }
          }
          var $$this;
          if (level <= 0) {
            var match = tree[/* path */0];
            if (typeof match === "number") {
              $$this = /* Relative */Block.__(0, [
                  uname,
                  o
                ]);
            } else if (match.tag) {
              Curry._2(warn_masking_absolute, /* None */0, match[0]);
              $$this = tree[/* path */0];
            } else {
              $$this = /* Relative */Block.__(0, [
                  uname,
                  o
                ]);
            }
          } else {
            $$this = tree[/* path */0];
          }
          return /* record */[
                  /* path */$$this,
                  /* map */map
                ];
        } else {
          var match$1 = tree[/* path */0];
          var exit = 0;
          if (typeof match$1 === "number") {
            exit = 1;
          } else if (match$1.tag) {
            var uname$prime = match$1[0];
            if (Curry._2(E[/* equal */0], match$1[1], o)) {
              if (!Curry._2(equal, uname, uname$prime)) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "nametab.ml",
                        137,
                        2
                      ]
                    ];
              }
              return tree;
            } else {
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot mask the absolute name \"" + (Curry._1(to_string, uname$prime) + "\"!")));
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            return /* record */[
                    /* path : Absolute */Block.__(1, [
                        uname,
                        o
                      ]),
                    /* map */tree[/* map */1]
                  ];
          }
          
        }
      };
      var push_exactly = function (uname, o, level, tree, param) {
        if (param) {
          var path = param[1];
          var modid = param[0];
          if (level) {
            var modify = function (_, mc) {
              return push_exactly(uname, o, level - 1 | 0, mc, path);
            };
            var map;
            try {
              map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                var ptab = modify(/* () */0, empty_tree);
                map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
              } else {
                throw exn;
              }
            }
            return /* record */[
                    /* path */tree[/* path */0],
                    /* map */map
                  ];
          } else {
            var match = tree[/* path */0];
            var $$this;
            if (typeof match === "number") {
              $$this = /* Relative */Block.__(0, [
                  uname,
                  o
                ]);
            } else if (match.tag) {
              Curry._2(warn_masking_absolute, /* None */0, match[0]);
              $$this = tree[/* path */0];
            } else {
              $$this = /* Relative */Block.__(0, [
                  uname,
                  o
                ]);
            }
            return /* record */[
                    /* path */$$this,
                    /* map */tree[/* map */1]
                  ];
          }
        } else {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Prefix longer than path! Impossible!"));
        }
      };
      var push = function (visibility, uname, o, tab) {
        var match = repr$1(uname);
        var dir = match[1];
        var id = match[0];
        var modify = function (_, ptab) {
          if (visibility.tag) {
            return push_exactly(uname, o, visibility[0] - 1 | 0, ptab, dir);
          } else {
            return push_until(uname, o, visibility[0] - 1 | 0, ptab, dir);
          }
        };
        try {
          return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* modify */26], id, modify, tab);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            var ptab = modify(/* () */0, empty_tree);
            return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, ptab, tab);
          } else {
            throw exn;
          }
        }
      };
      var search = function (_tree, _param) {
        while(true) {
          var param = _param;
          var tree = _tree;
          if (param) {
            _param = param[1];
            _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], param[0], tree[/* map */1]);
            continue ;
            
          } else {
            return tree[/* path */0];
          }
        };
      };
      var find_node = function (qid, tab) {
        var match = Libnames$ReactTemplate.repr_qualid(qid);
        return search(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[1], tab), Names$ReactTemplate.DirPath[/* repr */4](match[0]));
      };
      var locate = function (qid, tab) {
        var match = find_node(qid, tab);
        if (typeof match === "number") {
          throw Caml_builtin_exceptions.not_found;
        } else {
          return match[1];
        }
      };
      var user_name = function (qid, tab) {
        var match = find_node(qid, tab);
        if (typeof match === "number") {
          throw Caml_builtin_exceptions.not_found;
        } else {
          return match[0];
        }
      };
      var find = function (uname, tab) {
        var match = repr$1(uname);
        var match$1 = search(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[0], tab), match[1]);
        if (typeof match$1 === "number") {
          throw Caml_builtin_exceptions.not_found;
        } else if (match$1.tag) {
          return match$1[1];
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
      };
      var exists = function (uname, tab) {
        try {
          find(uname, tab);
          return /* true */1;
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return /* false */0;
          } else {
            throw exn;
          }
        }
      };
      var shortest_qualid = function (ctx, uname, tab) {
        var match = repr$1(uname);
        var id = match[0];
        var hidden = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, ctx);
        var find_uname = function (_pos, _dir, _tree) {
          while(true) {
            var tree = _tree;
            var dir = _dir;
            var pos = _pos;
            var is_empty = pos ? /* false */0 : /* true */1;
            var match = tree[/* path */0];
            var exit = 0;
            var exit$1 = 0;
            var u;
            if (typeof match === "number") {
              exit = 1;
            } else {
              u = match[0];
              exit$1 = 2;
            }
            if (exit$1 === 2) {
              if (Curry._2(equal, u, uname) && !(is_empty && hidden)) {
                return Curry._1(Util$ReactTemplate.List[/* rev */4], pos);
              } else {
                exit = 1;
              }
            }
            if (exit === 1) {
              if (dir) {
                var id = dir[0];
                _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], id, tree[/* map */1]);
                _dir = dir[1];
                _pos = /* :: */[
                  id,
                  pos
                ];
                continue ;
                
              } else {
                throw Caml_builtin_exceptions.not_found;
              }
            }
            
          };
        };
        var ptab = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, tab);
        var found_dir = find_uname(/* [] */0, match[1], ptab);
        return Libnames$ReactTemplate.make_qualid(Names$ReactTemplate.DirPath[/* make */3](found_dir), id);
      };
      var push_node = function (node, l) {
        var exit = 0;
        var o;
        if (typeof node === "number") {
          return l;
        } else {
          o = node[1];
          exit = 1;
        }
        if (exit === 1) {
          if (Curry._3(Util$ReactTemplate.List[/* mem_f */47], E[/* equal */0], o, l)) {
            return l;
          } else {
            return /* :: */[
                    o,
                    l
                  ];
          }
        }
        
      };
      var flatten_idmap = function (tab, l) {
        var f = function (_, tree, l) {
          return flatten_idmap(tree[/* map */1], push_node(tree[/* path */0], l));
        };
        return Curry._3(Names$ReactTemplate.ModIdmap[/* fold */10], f, tab, l);
      };
      var find_prefixes = function (qid, tab) {
        try {
          var match = Libnames$ReactTemplate.repr_qualid(qid);
          var _tree = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[1], tab);
          var _param = Names$ReactTemplate.DirPath[/* repr */4](match[0]);
          while(true) {
            var param = _param;
            var tree = _tree;
            if (param) {
              _param = param[1];
              _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], param[0], tree[/* map */1]);
              continue ;
              
            } else {
              return Curry._1(Util$ReactTemplate.List[/* rev */4], flatten_idmap(tree[/* map */1], push_node(tree[/* path */0], /* [] */0)));
            }
          };
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return /* [] */0;
          } else {
            throw exn;
          }
        }
      };
      return /* module */[
              /* empty */empty,
              /* push */push,
              /* locate */locate,
              /* find */find,
              /* exists */exists,
              /* user_name */user_name,
              /* shortest_qualid */shortest_qualid,
              /* find_prefixes */find_prefixes
            ];
    })(GlobDir);

var the_dirtab = [DirTab[/* empty */0]];

function equal$1(param, param$1) {
  if (Curry._2(Names$ReactTemplate.DirPath[/* equal */0], param[0], param$1[0])) {
    return +(param[1] === param$1[1]);
  } else {
    return /* false */0;
  }
}

var warn_masking_absolute$2 = CWarnings$ReactTemplate.create("masking-absolute-name", "deprecated", /* None */0, (function (n) {
        return Pp$ReactTemplate.str("Trying to mask the absolute name \"" + (Libnames$ReactTemplate.string_of_path(n) + "\"!"));
      }));

var empty_tree_001$2 = /* map */Names$ReactTemplate.ModIdmap[/* empty */0];

var empty_tree$2 = /* record */[
  /* path : Nothing */0,
  empty_tree_001$2
];

var empty$2 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];

function push_until$2(uname, o, level, tree, param) {
  if (param) {
    var path = param[1];
    var modid = param[0];
    var modify = function (_, mc) {
      return push_until$2(uname, o, level - 1 | 0, mc, path);
    };
    var map;
    try {
      map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var ptab = modify(/* () */0, empty_tree$2);
        map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
      } else {
        throw exn;
      }
    }
    var $$this;
    if (level <= 0) {
      var match = tree[/* path */0];
      if (typeof match === "number") {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      } else if (match.tag) {
        Curry._2(warn_masking_absolute$2, /* None */0, match[0]);
        $$this = tree[/* path */0];
      } else {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      }
    } else {
      $$this = tree[/* path */0];
    }
    return /* record */[
            /* path */$$this,
            /* map */map
          ];
  } else {
    var match$1 = tree[/* path */0];
    var exit = 0;
    if (typeof match$1 === "number") {
      exit = 1;
    } else if (match$1.tag) {
      var uname$prime = match$1[0];
      if (equal$1(match$1[1], o)) {
        if (!Libnames$ReactTemplate.eq_full_path(uname, uname$prime)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "nametab.ml",
                  137,
                  2
                ]
              ];
        }
        return tree;
      } else {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot mask the absolute name \"" + (Libnames$ReactTemplate.string_of_path(uname$prime) + "\"!")));
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* record */[
              /* path : Absolute */Block.__(1, [
                  uname,
                  o
                ]),
              /* map */tree[/* map */1]
            ];
    }
    
  }
}

function push_exactly$2(uname, o, level, tree, param) {
  if (param) {
    var path = param[1];
    var modid = param[0];
    if (level) {
      var modify = function (_, mc) {
        return push_exactly$2(uname, o, level - 1 | 0, mc, path);
      };
      var map;
      try {
        map = Curry._3(Names$ReactTemplate.ModIdmap[/* modify */26], modid, modify, tree[/* map */1]);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var ptab = modify(/* () */0, empty_tree$2);
          map = Curry._3(Names$ReactTemplate.ModIdmap[/* add */3], modid, ptab, tree[/* map */1]);
        } else {
          throw exn;
        }
      }
      return /* record */[
              /* path */tree[/* path */0],
              /* map */map
            ];
    } else {
      var match = tree[/* path */0];
      var $$this;
      if (typeof match === "number") {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      } else if (match.tag) {
        Curry._2(warn_masking_absolute$2, /* None */0, match[0]);
        $$this = tree[/* path */0];
      } else {
        $$this = /* Relative */Block.__(0, [
            uname,
            o
          ]);
      }
      return /* record */[
              /* path */$$this,
              /* map */tree[/* map */1]
            ];
    }
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Prefix longer than path! Impossible!"));
  }
}

function push$2(visibility, uname, o, tab) {
  var match = repr(uname);
  var dir = match[1];
  var id = match[0];
  var modify = function (_, ptab) {
    if (visibility.tag) {
      return push_exactly$2(uname, o, visibility[0] - 1 | 0, ptab, dir);
    } else {
      return push_until$2(uname, o, visibility[0] - 1 | 0, ptab, dir);
    }
  };
  try {
    return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* modify */26], id, modify, tab);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var ptab = modify(/* () */0, empty_tree$2);
      return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, ptab, tab);
    } else {
      throw exn;
    }
  }
}

function search$2(_tree, _param) {
  while(true) {
    var param = _param;
    var tree = _tree;
    if (param) {
      _param = param[1];
      _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], param[0], tree[/* map */1]);
      continue ;
      
    } else {
      return tree[/* path */0];
    }
  };
}

function find_node$2(qid, tab) {
  var match = Libnames$ReactTemplate.repr_qualid(qid);
  return search$2(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[1], tab), Names$ReactTemplate.DirPath[/* repr */4](match[0]));
}

function find$2(uname, tab) {
  var match = repr(uname);
  var match$1 = search$2(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[0], tab), match[1]);
  if (typeof match$1 === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else if (match$1.tag) {
    return match$1[1];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

var the_univtab = [empty$2];

var Globrevtab = HMap$ReactTemplate.Make([
      Globnames$ReactTemplate.ExtRefOrdered[0],
      Globnames$ReactTemplate.ExtRefOrdered[2]
    ]);

var the_globrevtab = [Globrevtab[/* empty */0]];

var the_modrevtab = [Names$ReactTemplate.MPmap[/* empty */0]];

var the_modtyperevtab = [Names$ReactTemplate.MPmap[/* empty */0]];

function hash(param) {
  return param[1] + Names$ReactTemplate.DirPath[/* hash */2](param[0]) | 0;
}

function compare(param, param$1) {
  var c = Caml_primitive.caml_int_compare(param[1], param$1[1]);
  if (c) {
    return c;
  } else {
    return Curry._2(Names$ReactTemplate.DirPath[/* compare */1], param[0], param$1[0]);
  }
}

var UnivIdMap = HMap$ReactTemplate.Make([
      compare,
      hash
    ]);

var the_univrevtab = [UnivIdMap[/* empty */0]];

function push_xref(visibility, sp, xref) {
  if (visibility.tag) {
    if (exists(sp, the_ccitab[0])) {
      var xref$1 = find(sp, the_ccitab[0]);
      var exit = 0;
      if (xref$1.tag) {
        exit = 1;
      } else if (xref$1[0].tag) {
        the_ccitab[0] = push(visibility, sp, xref$1, the_ccitab[0]);
        return /* () */0;
      } else {
        exit = 1;
      }
      if (exit === 1) {
        the_ccitab[0] = push(visibility, sp, xref, the_ccitab[0]);
        return /* () */0;
      }
      
    } else {
      the_ccitab[0] = push(visibility, sp, xref, the_ccitab[0]);
      return /* () */0;
    }
  } else {
    the_ccitab[0] = push(visibility, sp, xref, the_ccitab[0]);
    the_globrevtab[0] = Curry._3(Globrevtab[/* add */3], xref, sp, the_globrevtab[0]);
    return /* () */0;
  }
}

function push_cci(visibility, sp, ref) {
  return push_xref(visibility, sp, /* TrueGlobal */Block.__(0, [ref]));
}

function push_syndef(visibility, sp, kn) {
  return push_xref(visibility, sp, /* SynDef */Block.__(1, [kn]));
}

function push_modtype(vis, sp, kn) {
  the_modtypetab[0] = push$1(vis, sp, kn, the_modtypetab[0]);
  the_modtyperevtab[0] = Curry._3(Names$ReactTemplate.MPmap[/* add */3], kn, sp, the_modtyperevtab[0]);
  return /* () */0;
}

function push_dir(vis, dir, dir_ref) {
  the_dirtab[0] = Curry._4(DirTab[/* push */1], vis, dir, dir_ref, the_dirtab[0]);
  if (dir_ref.tag === 3) {
    the_modrevtab[0] = Curry._3(Names$ReactTemplate.MPmap[/* add */3], dir_ref[0][/* obj_mp */1], dir, the_modrevtab[0]);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function push_universe(vis, sp, univ) {
  the_univtab[0] = push$2(vis, sp, univ, the_univtab[0]);
  the_univrevtab[0] = Curry._3(UnivIdMap[/* add */3], univ, sp, the_univrevtab[0]);
  return /* () */0;
}

function locate_extended(qid) {
  var qid$1 = qid;
  var tab = the_ccitab[0];
  var match = find_node(qid$1, tab);
  if (typeof match === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else {
    return match[1];
  }
}

function locate(qid) {
  var match = locate_extended(qid);
  if (match.tag) {
    throw Caml_builtin_exceptions.not_found;
  } else {
    return match[0];
  }
}

function full_name_cci(qid) {
  var qid$1 = qid;
  var tab = the_ccitab[0];
  var match = find_node(qid$1, tab);
  if (typeof match === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else {
    return match[0];
  }
}

function locate_syndef(qid) {
  var match = locate_extended(qid);
  if (match.tag) {
    return match[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function locate_modtype(qid) {
  var qid$1 = qid;
  var tab = the_modtypetab[0];
  var match = find_node$1(qid$1, tab);
  if (typeof match === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else {
    return match[1];
  }
}

function full_name_modtype(qid) {
  var qid$1 = qid;
  var tab = the_modtypetab[0];
  var match = find_node$1(qid$1, tab);
  if (typeof match === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else {
    return match[0];
  }
}

function locate_universe(qid) {
  var qid$1 = qid;
  var tab = the_univtab[0];
  var match = find_node$2(qid$1, tab);
  if (typeof match === "number") {
    throw Caml_builtin_exceptions.not_found;
  } else {
    return match[1];
  }
}

function locate_dir(qid) {
  return Curry._2(DirTab[/* locate */2], qid, the_dirtab[0]);
}

function locate_module(qid) {
  var match = locate_dir(qid);
  if (match.tag === 3) {
    return match[0][/* obj_mp */1];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function full_name_module(qid) {
  var match = locate_dir(qid);
  if (match.tag === 3) {
    return match[0][/* obj_dir */0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function locate_section(qid) {
  var match = locate_dir(qid);
  switch (match.tag | 0) {
    case 2 : 
        return match[0][/* obj_dir */0];
    case 4 : 
        return match[0];
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function locate_all(qid) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (a, l) {
                if (a.tag) {
                  return l;
                } else {
                  return /* :: */[
                          a[0],
                          l
                        ];
                }
              }), find_prefixes(qid, the_ccitab[0]), /* [] */0);
}

function locate_extended_all(qid) {
  return find_prefixes(qid, the_ccitab[0]);
}

function locate_extended_all_dir(qid) {
  return Curry._2(DirTab[/* find_prefixes */7], qid, the_dirtab[0]);
}

function locate_extended_all_modtype(qid) {
  var qid$1 = qid;
  var tab = the_modtypetab[0];
  try {
    var match = Libnames$ReactTemplate.repr_qualid(qid$1);
    var _tree = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], match[1], tab);
    var _param = Names$ReactTemplate.DirPath[/* repr */4](match[0]);
    while(true) {
      var param = _param;
      var tree = _tree;
      if (param) {
        _param = param[1];
        _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], param[0], tree[/* map */1]);
        continue ;
        
      } else {
        return Curry._1(Util$ReactTemplate.List[/* rev */4], flatten_idmap$1(tree[/* map */1], push_node$1(tree[/* path */0], /* [] */0)));
      }
    };
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

function locate_constant(qid) {
  var match = locate_extended(qid);
  if (match.tag) {
    throw Caml_builtin_exceptions.not_found;
  } else {
    var match$1 = match[0];
    if (match$1.tag === 1) {
      return match$1[0];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  }
}

function global_of_path(sp) {
  var match = find(sp, the_ccitab[0]);
  if (match.tag) {
    throw Caml_builtin_exceptions.not_found;
  } else {
    return match[0];
  }
}

function extended_global_of_path(sp) {
  return find(sp, the_ccitab[0]);
}

function $$global(lr) {
  var qid = Libnames$ReactTemplate.qualid_of_reference(lr);
  var v = qid[/* v */0];
  try {
    var match = locate_extended(v);
    if (match.tag) {
      return CErrors$ReactTemplate.user_err(qid[/* loc */1], /* Some */["global"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unexpected reference to a notation: "), Libnames$ReactTemplate.pr_qualid(v)));
    } else {
      return match[0];
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return error_global_not_found(qid);
    } else {
      throw exn;
    }
  }
}

function exists_cci(sp) {
  return exists(sp, the_ccitab[0]);
}

function exists_dir(dir) {
  return Curry._2(DirTab[/* exists */4], dir, the_dirtab[0]);
}

function exists_modtype(sp) {
  var uname = sp;
  var tab = the_modtypetab[0];
  try {
    find$1(uname, tab);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function exists_universe(kn) {
  var uname = kn;
  var tab = the_univtab[0];
  try {
    find$2(uname, tab);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function path_of_global(ref) {
  if (ref.tag) {
    return Curry._2(Globrevtab[/* find */21], /* TrueGlobal */Block.__(0, [ref]), the_globrevtab[0]);
  } else {
    return Libnames$ReactTemplate.make_path(Names$ReactTemplate.DirPath[/* empty */5], ref[0]);
  }
}

function dirpath_of_global(ref) {
  return Libnames$ReactTemplate.repr_path(path_of_global(ref))[0];
}

function basename_of_global(ref) {
  return Libnames$ReactTemplate.repr_path(path_of_global(ref))[1];
}

function path_of_syndef(kn) {
  return Curry._2(Globrevtab[/* find */21], /* SynDef */Block.__(1, [kn]), the_globrevtab[0]);
}

function dirpath_of_module(mp) {
  return Curry._2(Names$ReactTemplate.MPmap[/* find */21], mp, the_modrevtab[0]);
}

function path_of_modtype(mp) {
  return Curry._2(Names$ReactTemplate.MPmap[/* find */21], mp, the_modtyperevtab[0]);
}

function path_of_universe(mp) {
  return Curry._2(UnivIdMap[/* find */21], mp, the_univrevtab[0]);
}

function shortest_qualid_of_global(ctx, ref) {
  if (ref.tag) {
    var sp = Curry._2(Globrevtab[/* find */21], /* TrueGlobal */Block.__(0, [ref]), the_globrevtab[0]);
    return shortest_qualid(ctx, sp, the_ccitab[0]);
  } else {
    return Libnames$ReactTemplate.make_qualid(Names$ReactTemplate.DirPath[/* empty */5], ref[0]);
  }
}

function shortest_qualid_of_syndef(ctx, kn) {
  var sp = path_of_syndef(kn);
  return shortest_qualid(ctx, sp, the_ccitab[0]);
}

function shortest_qualid_of_module(mp) {
  var dir = Curry._2(Names$ReactTemplate.MPmap[/* find */21], mp, the_modrevtab[0]);
  return Curry._3(DirTab[/* shortest_qualid */6], Names$ReactTemplate.Id[/* Set */9][/* empty */0], dir, the_dirtab[0]);
}

function shortest_qualid_of_modtype(kn) {
  var sp = Curry._2(Names$ReactTemplate.MPmap[/* find */21], kn, the_modtyperevtab[0]);
  var ctx = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var uname = sp;
  var tab = the_modtypetab[0];
  var match = repr(uname);
  var id = match[0];
  var hidden = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, ctx);
  var find_uname = function (_pos, _dir, _tree) {
    while(true) {
      var tree = _tree;
      var dir = _dir;
      var pos = _pos;
      var is_empty = pos ? /* false */0 : /* true */1;
      var match = tree[/* path */0];
      var exit = 0;
      var exit$1 = 0;
      var u;
      if (typeof match === "number") {
        exit = 1;
      } else {
        u = match[0];
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        if (Libnames$ReactTemplate.eq_full_path(u, uname) && !(is_empty && hidden)) {
          return Curry._1(Util$ReactTemplate.List[/* rev */4], pos);
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        if (dir) {
          var id = dir[0];
          _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], id, tree[/* map */1]);
          _dir = dir[1];
          _pos = /* :: */[
            id,
            pos
          ];
          continue ;
          
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
      }
      
    };
  };
  var ptab = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, tab);
  var found_dir = find_uname(/* [] */0, match[1], ptab);
  return Libnames$ReactTemplate.make_qualid(Names$ReactTemplate.DirPath[/* make */3](found_dir), id);
}

function shortest_qualid_of_universe(kn) {
  var sp = Curry._2(UnivIdMap[/* find */21], kn, the_univrevtab[0]);
  var ctx = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var uname = sp;
  var tab = the_univtab[0];
  var match = repr(uname);
  var id = match[0];
  var hidden = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, ctx);
  var find_uname = function (_pos, _dir, _tree) {
    while(true) {
      var tree = _tree;
      var dir = _dir;
      var pos = _pos;
      var is_empty = pos ? /* false */0 : /* true */1;
      var match = tree[/* path */0];
      var exit = 0;
      var exit$1 = 0;
      var u;
      if (typeof match === "number") {
        exit = 1;
      } else {
        u = match[0];
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        if (Libnames$ReactTemplate.eq_full_path(u, uname) && !(is_empty && hidden)) {
          return Curry._1(Util$ReactTemplate.List[/* rev */4], pos);
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        if (dir) {
          var id = dir[0];
          _tree = Curry._2(Names$ReactTemplate.ModIdmap[/* find */21], id, tree[/* map */1]);
          _dir = dir[1];
          _pos = /* :: */[
            id,
            pos
          ];
          continue ;
          
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
      }
      
    };
  };
  var ptab = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, tab);
  var found_dir = find_uname(/* [] */0, match[1], ptab);
  return Libnames$ReactTemplate.make_qualid(Names$ReactTemplate.DirPath[/* make */3](found_dir), id);
}

function pr_global_env(env, ref) {
  try {
    return Libnames$ReactTemplate.pr_qualid(shortest_qualid_of_global(env, ref));
  }
  catch (e){
    if (e === Caml_builtin_exceptions.not_found) {
      if (Flags$ReactTemplate.debug[0]) {
        Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.str("pr_global_env not found"));
      }
      throw e;
    } else {
      throw e;
    }
  }
}

function global_inductive(lr) {
  var ref = $$global(lr);
  if (ref.tag === 2) {
    return ref[0];
  } else {
    return CErrors$ReactTemplate.user_err(lr[/* loc */1], /* Some */["global_inductive"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Libnames$ReactTemplate.pr_reference(lr), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is not an inductive type")));
  }
}

function freeze() {
  return /* tuple */[
          the_ccitab[0],
          the_dirtab[0],
          the_modtypetab[0],
          the_univtab[0],
          the_globrevtab[0],
          the_modrevtab[0],
          the_modtyperevtab[0],
          the_univrevtab[0]
        ];
}

function unfreeze(param) {
  the_ccitab[0] = param[0];
  the_dirtab[0] = param[1];
  the_modtypetab[0] = param[2];
  the_univtab[0] = param[3];
  the_globrevtab[0] = param[4];
  the_modrevtab[0] = param[5];
  the_modtyperevtab[0] = param[6];
  the_univrevtab[0] = param[7];
  return /* () */0;
}

Summary$ReactTemplate.declare_summary("names", /* record */[
      /* freeze_function */freeze,
      /* unfreeze_function */unfreeze,
      /* init_function */Summary$ReactTemplate.nop
    ]);

var push$3 = push_cci;

var exists_section = exists_dir;

var exists_module = exists_dir;

var extended_locate = locate_extended;

var absolute_reference = global_of_path;

exports.GlobalizationError = GlobalizationError;
exports.error_global_not_found = error_global_not_found;
exports.push = push$3;
exports.push_modtype = push_modtype;
exports.push_dir = push_dir;
exports.push_syndef = push_syndef;
exports.UnivIdMap = UnivIdMap;
exports.push_universe = push_universe;
exports.locate = locate;
exports.locate_extended = locate_extended;
exports.locate_constant = locate_constant;
exports.locate_syndef = locate_syndef;
exports.locate_modtype = locate_modtype;
exports.locate_dir = locate_dir;
exports.locate_module = locate_module;
exports.locate_section = locate_section;
exports.locate_universe = locate_universe;
exports.$$global = $$global;
exports.global_inductive = global_inductive;
exports.locate_all = locate_all;
exports.locate_extended_all = locate_extended_all;
exports.locate_extended_all_dir = locate_extended_all_dir;
exports.locate_extended_all_modtype = locate_extended_all_modtype;
exports.global_of_path = global_of_path;
exports.extended_global_of_path = extended_global_of_path;
exports.exists_cci = exists_cci;
exports.exists_modtype = exists_modtype;
exports.exists_dir = exists_dir;
exports.exists_section = exists_section;
exports.exists_module = exists_module;
exports.exists_universe = exists_universe;
exports.full_name_cci = full_name_cci;
exports.full_name_modtype = full_name_modtype;
exports.full_name_module = full_name_module;
exports.path_of_syndef = path_of_syndef;
exports.path_of_global = path_of_global;
exports.dirpath_of_module = dirpath_of_module;
exports.path_of_modtype = path_of_modtype;
exports.path_of_universe = path_of_universe;
exports.dirpath_of_global = dirpath_of_global;
exports.basename_of_global = basename_of_global;
exports.pr_global_env = pr_global_env;
exports.shortest_qualid_of_global = shortest_qualid_of_global;
exports.shortest_qualid_of_syndef = shortest_qualid_of_syndef;
exports.shortest_qualid_of_modtype = shortest_qualid_of_modtype;
exports.shortest_qualid_of_module = shortest_qualid_of_module;
exports.shortest_qualid_of_universe = shortest_qualid_of_universe;
exports.extended_locate = extended_locate;
exports.absolute_reference = absolute_reference;
exports.Make = Make;
/* warn_masking_absolute Not a pure module */
