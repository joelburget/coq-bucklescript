// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Dyn$ReactTemplate = require("./dyn.bs.js");
var Store$ReactTemplate = require("./store.bs.js");
var Genarg$ReactTemplate = require("./genarg.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var TacStore = Store$ReactTemplate.Make(/* module */[]);

var ValT = Dyn$ReactTemplate.Make(/* module */[]);

var eq = ValT[/* eq */1];

var repr = ValT[/* repr */2];

var create = ValT[/* create */0];

function pr(t) {
  return Pp$ReactTemplate.str(Curry._1(repr, t));
}

var typ_list = Curry._1(ValT[/* create */0], "list");

var typ_opt = Curry._1(ValT[/* create */0], "option");

var typ_pair = Curry._1(ValT[/* create */0], "pair");

function inject(tag, x) {
  switch (tag.tag | 0) {
    case 0 : 
        return /* Dyn */[
                tag[0],
                x
              ];
    case 1 : 
        var tag$1 = tag[0];
        return /* Dyn */[
                typ_list,
                List.map((function (x) {
                        return inject(tag$1, x);
                      }), x)
              ];
    case 2 : 
        var tag$2 = tag[0];
        return /* Dyn */[
                typ_opt,
                Option$ReactTemplate.map((function (x) {
                        return inject(tag$2, x);
                      }), x)
              ];
    case 3 : 
        return /* Dyn */[
                typ_pair,
                /* tuple */[
                  inject(tag[0], x[0]),
                  inject(tag[1], x[1])
                ]
              ];
    
  }
}

function $$default() {
  return /* None */0;
}

var ValReprObj = /* module */[
  /* name */"valrepr",
  /* default */$$default
];

var ValRepr = Genarg$ReactTemplate.Register(ValReprObj);

function val_tag(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Curry._1(ValRepr[/* obj */1], /* ExtraArg */Block.__(0, [param[0]]));
    case 1 : 
        return /* List */Block.__(1, [val_tag(param[0])]);
    case 2 : 
        return /* Opt */Block.__(2, [val_tag(param[0])]);
    case 3 : 
        return /* Pair */Block.__(3, [
                  val_tag(param[0]),
                  val_tag(param[1])
                ]);
    
  }
}

function val_tag$1(param) {
  return val_tag(param[0]);
}

function register_val0(wit, tag) {
  var tag$1;
  if (tag) {
    tag$1 = tag[0];
  } else {
    var name;
    if (wit.tag) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "geninterp.ml",
              76,
              11
            ]
          ];
    } else {
      name = Curry._1(Genarg$ReactTemplate.ArgT[/* repr */1], wit[0]);
    }
    tag$1 = /* Base */Block.__(0, [Curry._1(create, name)]);
  }
  return Curry._2(ValRepr[/* register0 */0], wit, tag$1);
}

function $$default$1() {
  return /* None */0;
}

var InterpObj = /* module */[
  /* name */"interp",
  /* default */$$default$1
];

var Interp = Genarg$ReactTemplate.Register(InterpObj);

var interp = Interp[/* obj */1];

var register_interp0 = Interp[/* register0 */0];

var Val = [
  create,
  eq,
  repr,
  pr,
  typ_list,
  typ_opt,
  typ_pair,
  inject
];

var ValTMap = ValT[/* Map */4];

exports.Val = Val;
exports.ValTMap = ValTMap;
exports.val_tag = val_tag$1;
exports.register_val0 = register_val0;
exports.TacStore = TacStore;
exports.interp = interp;
exports.register_interp0 = register_interp0;
/* TacStore Not a pure module */
