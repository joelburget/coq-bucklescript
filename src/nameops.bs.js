// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Char = require("bs-platform/lib/js/char.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function pr_id(id) {
  return Names$ReactTemplate.Id[/* print */8](id);
}

function cut_ident(skip_quote, s) {
  var s$1 = Names$ReactTemplate.Id[/* to_string */7](s);
  var slen = s$1.length;
  var _n = slen;
  var _n$prime = slen;
  while(true) {
    var n$prime = _n$prime;
    var n = _n;
    if (n) {
      var c = Caml_string.get(s$1, n - 1 | 0);
      if (c === /* "0" */48 && n !== slen) {
        _n = n - 1 | 0;
        continue ;
        
      } else if (/* "0" */48 <= c && c <= /* "9" */57) {
        _n$prime = n - 1 | 0;
        _n = n - 1 | 0;
        continue ;
        
      } else if (skip_quote && (c === /* "'" */39 || c === /* "_" */95)) {
        _n$prime = n - 1 | 0;
        _n = n - 1 | 0;
        continue ;
        
      } else {
        return n$prime;
      }
    } else {
      return slen;
    }
  };
}

function repr_ident(s) {
  var numstart = cut_ident(/* false */0, s);
  var s$1 = Names$ReactTemplate.Id[/* to_string */7](s);
  var slen = s$1.length;
  if (numstart === slen) {
    return /* tuple */[
            s$1,
            /* None */0
          ];
  } else {
    return /* tuple */[
            Curry._3(Util$ReactTemplate.$$String[/* sub */3], s$1, 0, numstart),
            /* Some */[Caml_format.caml_int_of_string(Curry._3(Util$ReactTemplate.$$String[/* sub */3], s$1, numstart, slen - numstart | 0))]
          ];
  }
}

function make_ident(sa, param) {
  if (param) {
    var n = param[0];
    var c = Caml_string.get(sa, sa.length - 1 | 0);
    return Names$ReactTemplate.Id[/* of_string */5](c < /* "0" */48 || c > /* "9" */57 ? sa + Pervasives.string_of_int(n) : sa + ("_" + Pervasives.string_of_int(n)));
  } else {
    return Names$ReactTemplate.Id[/* of_string */5](sa);
  }
}

function root_of_id(id) {
  var suffixstart = cut_ident(/* true */1, id);
  return Names$ReactTemplate.Id[/* of_string */5](Curry._3(Util$ReactTemplate.$$String[/* sub */3], Names$ReactTemplate.Id[/* to_string */7](id), 0, suffixstart));
}

function increment_subscript(id) {
  var id$1 = Names$ReactTemplate.Id[/* to_string */7](id);
  var len = id$1.length;
  var add = function (_carrypos) {
    while(true) {
      var carrypos = _carrypos;
      var c = Caml_string.get(id$1, carrypos);
      if (Util$ReactTemplate.is_digit(c)) {
        if (c === /* "9" */57) {
          if (carrypos <= 0) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "nameops.ml",
                    88,
                    1
                  ]
                ];
          }
          _carrypos = carrypos - 1 | 0;
          continue ;
          
        } else {
          var newid = Bytes.of_string(id$1);
          Bytes.fill(newid, carrypos + 1 | 0, (len - 1 | 0) - carrypos | 0, /* "0" */48);
          newid[carrypos] = Char.chr(c + 1 | 0);
          return newid;
        }
      } else {
        var newid$1 = Bytes.of_string(id$1 + "0");
        if (carrypos < (len - 1 | 0)) {
          Bytes.fill(newid$1, carrypos + 1 | 0, (len - 1 | 0) - carrypos | 0, /* "0" */48);
          newid$1[carrypos + 1 | 0] = /* "1" */49;
        }
        return newid$1;
      }
    };
  };
  return Names$ReactTemplate.Id[/* of_bytes */4](add(len - 1 | 0));
}

function has_subscript(id) {
  var id$1 = Names$ReactTemplate.Id[/* to_string */7](id);
  return Util$ReactTemplate.is_digit(Caml_string.get(id$1, id$1.length - 1 | 0));
}

function forget_subscript(id) {
  var numstart = cut_ident(/* false */0, id);
  var newid = Bytes.make(numstart + 1 | 0, /* "0" */48);
  Curry._5(Util$ReactTemplate.$$String[/* blit */5], Names$ReactTemplate.Id[/* to_string */7](id), 0, newid, 0, numstart);
  return Names$ReactTemplate.Id[/* of_bytes */4](newid);
}

function add_suffix(id, s) {
  return Names$ReactTemplate.Id[/* of_string */5](Names$ReactTemplate.Id[/* to_string */7](id) + s);
}

function add_prefix(s, id) {
  return Names$ReactTemplate.Id[/* of_string */5](s + Names$ReactTemplate.Id[/* to_string */7](id));
}

function atompart_of_id(id) {
  return repr_ident(id)[0];
}

var print = Names$ReactTemplate.Name[7];

var IsAnonymous = Caml_exceptions.create("Nameops-ReactTemplate.Name.IsAnonymous");

function fold_left(f, a, param) {
  if (param) {
    return Curry._2(f, a, param[0]);
  } else {
    return a;
  }
}

function fold_right(f, na, a) {
  if (na) {
    return Curry._2(f, na[0], a);
  } else {
    return a;
  }
}

function iter(f, na) {
  return fold_right((function (x, _) {
                return Curry._1(f, x);
              }), na, /* () */0);
}

function map(f, param) {
  if (param) {
    return /* Name */[Curry._1(f, param[0])];
  } else {
    return /* Anonymous */0;
  }
}

function fold_left_map(f, a, param) {
  if (param) {
    var match = Curry._2(f, a, param[0]);
    return /* tuple */[
            match[0],
            /* Name */[match[1]]
          ];
  } else {
    return /* tuple */[
            a,
            /* Anonymous */0
          ];
  }
}

function fold_right_map(f, na, a) {
  if (na) {
    var match = Curry._2(f, na[0], a);
    return /* tuple */[
            /* Name */[match[0]],
            match[1]
          ];
  } else {
    return /* tuple */[
            /* Anonymous */0,
            a
          ];
  }
}

function get_id(param) {
  if (param) {
    return param[0];
  } else {
    throw IsAnonymous;
  }
}

function pick(na1, na2) {
  if (na1) {
    return na1;
  } else {
    return na2;
  }
}

function cons(na, l) {
  if (na) {
    return /* :: */[
            na[0],
            l
          ];
  } else {
    return l;
  }
}

function to_option(param) {
  if (param) {
    return /* Some */[param[0]];
  } else {
    return /* None */0;
  }
}

var Name_000 = /* mk_name */Names$ReactTemplate.Name[0];

var Name_001 = /* is_anonymous */Names$ReactTemplate.Name[1];

var Name_002 = /* is_name */Names$ReactTemplate.Name[2];

var Name_003 = /* compare */Names$ReactTemplate.Name[3];

var Name_004 = /* equal */Names$ReactTemplate.Name[4];

var Name_005 = /* hash */Names$ReactTemplate.Name[5];

var Name_006 = /* hcons */Names$ReactTemplate.Name[6];

var Name = /* module */[
  Name_000,
  Name_001,
  Name_002,
  Name_003,
  Name_004,
  Name_005,
  Name_006,
  /* print */print,
  /* IsAnonymous */IsAnonymous,
  /* fold_left */fold_left,
  /* fold_right */fold_right,
  /* iter */iter,
  /* map */map,
  /* fold_left_map */fold_left_map,
  /* fold_right_map */fold_right_map,
  /* get_id */get_id,
  /* pick */pick,
  /* cons */cons,
  /* to_option */to_option
];

function pr_lab(l) {
  return Names$ReactTemplate.Label[/* print */7](l);
}

var pr_meta = Pp$ReactTemplate.$$int;

var string_of_meta = Pervasives.string_of_int;

var out_name = get_id;

var name_fold = fold_right;

var name_iter = iter;

var name_app = map;

var name_fold_map = fold_left_map;

var name_max = pick;

var name_cons = cons;

var pr_name = print;

var default_library = Libnames$ReactTemplate.default_library;

var coq_root = Libnames$ReactTemplate.coq_root;

var coq_string = Libnames$ReactTemplate.coq_string;

var default_root_prefix = Libnames$ReactTemplate.default_root_prefix;

exports.make_ident = make_ident;
exports.repr_ident = repr_ident;
exports.atompart_of_id = atompart_of_id;
exports.root_of_id = root_of_id;
exports.add_suffix = add_suffix;
exports.add_prefix = add_prefix;
exports.has_subscript = has_subscript;
exports.increment_subscript = increment_subscript;
exports.forget_subscript = forget_subscript;
exports.Name = Name;
exports.pr_meta = pr_meta;
exports.string_of_meta = string_of_meta;
exports.out_name = out_name;
exports.name_fold = name_fold;
exports.name_iter = name_iter;
exports.name_app = name_app;
exports.name_fold_map = name_fold_map;
exports.name_max = name_max;
exports.name_cons = name_cons;
exports.pr_name = pr_name;
exports.pr_id = pr_id;
exports.pr_lab = pr_lab;
exports.default_library = default_library;
exports.coq_root = coq_root;
exports.coq_string = coq_string;
exports.default_root_prefix = default_root_prefix;
/* Pp-ReactTemplate Not a pure module */
