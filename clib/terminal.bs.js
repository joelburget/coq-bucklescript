// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Unix = require("bs-platform/lib/js/unix.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function set(o1, o2) {
  if (o1 && !o2) {
    return o1;
  } else {
    return o2;
  }
}

function make(fg_color, bg_color, bold, italic, underline, negative, style, prefix, suffix, _) {
  var st = style ? style[0] : /* record */[
      /* fg_color : None */0,
      /* bg_color : None */0,
      /* bold : None */0,
      /* italic : None */0,
      /* underline : None */0,
      /* negative : None */0,
      /* prefix : None */0,
      /* suffix : None */0
    ];
  return /* record */[
          /* fg_color */set(st[/* fg_color */0], fg_color),
          /* bg_color */set(st[/* bg_color */1], bg_color),
          /* bold */set(st[/* bold */2], bold),
          /* italic */set(st[/* italic */3], italic),
          /* underline */set(st[/* underline */4], underline),
          /* negative */set(st[/* negative */5], negative),
          /* prefix */set(st[/* prefix */6], prefix),
          /* suffix */set(st[/* suffix */7], suffix)
        ];
}

function merge(s1, s2) {
  return /* record */[
          /* fg_color */set(s1[/* fg_color */0], s2[/* fg_color */0]),
          /* bg_color */set(s1[/* bg_color */1], s2[/* bg_color */1]),
          /* bold */set(s1[/* bold */2], s2[/* bold */2]),
          /* italic */set(s1[/* italic */3], s2[/* italic */3]),
          /* underline */set(s1[/* underline */4], s2[/* underline */4]),
          /* negative */set(s1[/* negative */5], s2[/* negative */5]),
          /* prefix */set(s1[/* prefix */6], s2[/* prefix */6]),
          /* suffix */set(s1[/* suffix */7], s2[/* suffix */7])
        ];
}

function base_color(param) {
  if (param >= 48188276) {
    if (param < 462924962) {
      if (param >= 386268928) {
        if (param !== 400246435) {
          if (param >= 386268929) {
            if (param >= 462924961) {
              return 9;
            } else {
              return Pervasives.invalid_arg("base_color");
            }
          } else {
            return 7;
          }
        } else {
          return 2;
        }
      } else if (param !== 242322953) {
        if (param >= 48188277) {
          return Pervasives.invalid_arg("base_color");
        } else {
          return 3;
        }
      } else {
        return 5;
      }
    } else if (param >= 735709851) {
      if (param !== 747441443) {
        if (param !== 853544351) {
          return Pervasives.invalid_arg("base_color");
        } else {
          return 0;
        }
      } else {
        return 6;
      }
    } else if (param !== 582072093) {
      if (param >= 735709850) {
        return 4;
      } else {
        return Pervasives.invalid_arg("base_color");
      }
    } else {
      return 3;
    }
  } else if (param >= -945061238) {
    if (param >= -415907045) {
      if (param !== 4093233) {
        if (param !== 37390870) {
          return Pervasives.invalid_arg("base_color");
        } else {
          return 0;
        }
      } else {
        return 1;
      }
    } else if (param !== -572123672) {
      if (param >= -415907046) {
        return 2;
      } else {
        return Pervasives.invalid_arg("base_color");
      }
    } else {
      return 1;
    }
  } else if (param >= -1047393139) {
    if (param !== -960670144) {
      if (param >= -945061239) {
        return 7;
      } else {
        return Pervasives.invalid_arg("base_color");
      }
    } else {
      return 5;
    }
  } else if (param !== -1059124733) {
    if (param >= -1047393140) {
      return 6;
    } else {
      return Pervasives.invalid_arg("base_color");
    }
  } else {
    return 4;
  }
}

function extended_color(off, param) {
  if (typeof param === "number") {
    return Pervasives.invalid_arg("extended_color");
  } else {
    var variant = param[0];
    if (variant !== 4093677) {
      if (variant !== 1006818034) {
        return Pervasives.invalid_arg("extended_color");
      } else {
        return /* :: */[
                off + 8 | 0,
                /* :: */[
                  5,
                  /* :: */[
                    param[1],
                    /* [] */0
                  ]
                ]
              ];
      }
    } else {
      var match = param[1];
      return /* :: */[
              off + 8 | 0,
              /* :: */[
                2,
                /* :: */[
                  match[0],
                  /* :: */[
                    match[1],
                    /* :: */[
                      match[2],
                      /* [] */0
                    ]
                  ]
                ]
              ]
            ];
    }
  }
}

function is_light(param) {
  if (param >= -572123671) {
    if (param >= 37390871) {
      if (param !== 386268928 && param !== 582072093) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    } else if (param !== -415907046 && param < 37390870) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  } else if (param >= -1047393139) {
    if (param !== -960670144 && param < -572123672) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  } else if (param !== -1059124733 && param < -1047393140) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function is_extended(param) {
  if (typeof param === "number") {
    return /* false */0;
  } else {
    var variant = param[0];
    if (variant !== 4093677 && variant !== 1006818034) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  }
}

function repr(st) {
  var match = st[/* fg_color */0];
  var fg;
  if (match) {
    var c = match[0];
    fg = is_light(c) ? /* :: */[
        90 + base_color(c) | 0,
        /* [] */0
      ] : (
        is_extended(c) ? extended_color(30, c) : /* :: */[
            30 + base_color(c) | 0,
            /* [] */0
          ]
      );
  } else {
    fg = /* [] */0;
  }
  var match$1 = st[/* bg_color */1];
  var bg;
  if (match$1) {
    var c$1 = match$1[0];
    bg = is_light(c$1) ? /* :: */[
        100 + base_color(c$1) | 0,
        /* [] */0
      ] : (
        is_extended(c$1) ? extended_color(40, c$1) : /* :: */[
            40 + base_color(c$1) | 0,
            /* [] */0
          ]
      );
  } else {
    bg = /* [] */0;
  }
  var match$2 = st[/* bold */2];
  var bold = match$2 ? (
      match$2[0] !== 0 ? /* :: */[
          1,
          /* [] */0
        ] : /* :: */[
          22,
          /* [] */0
        ]
    ) : /* [] */0;
  var match$3 = st[/* italic */3];
  var italic = match$3 ? (
      match$3[0] !== 0 ? /* :: */[
          3,
          /* [] */0
        ] : /* :: */[
          23,
          /* [] */0
        ]
    ) : /* [] */0;
  var match$4 = st[/* underline */4];
  var underline = match$4 ? (
      match$4[0] !== 0 ? /* :: */[
          4,
          /* [] */0
        ] : /* :: */[
          24,
          /* [] */0
        ]
    ) : /* [] */0;
  var match$5 = st[/* negative */5];
  var negative = match$5 ? (
      match$5[0] !== 0 ? /* :: */[
          7,
          /* [] */0
        ] : /* :: */[
          27,
          /* [] */0
        ]
    ) : /* [] */0;
  return Pervasives.$at(fg, Pervasives.$at(bg, Pervasives.$at(bold, Pervasives.$at(italic, Pervasives.$at(underline, negative)))));
}

function $$eval(st) {
  var tags = repr(st);
  var tags$1 = List.map(Pervasives.string_of_int, tags);
  return Curry._1(Printf.sprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "\x1b[",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* "m" */109,
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "\x1b[%sm"
                ]), $$String.concat(";", tags$1));
}

function has_style(t) {
  if (Unix.isatty(t)) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function split(c, s) {
  var len = s.length;
  var split$1 = function (n) {
    try {
      var pos = $$String.index_from(s, n, c);
      var dir = $$String.sub(s, n, pos - n | 0);
      return /* :: */[
              dir,
              split$1(pos + 1 | 0)
            ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* :: */[
                $$String.sub(s, n, len - n | 0),
                /* [] */0
              ];
      } else {
        throw exn;
      }
    }
  };
  if (len) {
    return split$1(0);
  } else {
    return /* [] */0;
  }
}

function check_char(i) {
  if (i < 0 || i > 255) {
    return Pervasives.invalid_arg("check_char");
  } else {
    return 0;
  }
}

function parse_color(off, rem) {
  if (off > 9 || off < 0) {
    return Pervasives.invalid_arg("parse_color");
  } else {
    switch (off) {
      case 0 : 
          return /* tuple */[
                  /* BLACK */853544351,
                  rem
                ];
      case 1 : 
          return /* tuple */[
                  /* RED */4093233,
                  rem
                ];
      case 2 : 
          return /* tuple */[
                  /* GREEN */400246435,
                  rem
                ];
      case 3 : 
          return /* tuple */[
                  /* YELLOW */48188276,
                  rem
                ];
      case 4 : 
          return /* tuple */[
                  /* BLUE */735709850,
                  rem
                ];
      case 5 : 
          return /* tuple */[
                  /* MAGENTA */242322953,
                  rem
                ];
      case 6 : 
          return /* tuple */[
                  /* CYAN */747441443,
                  rem
                ];
      case 7 : 
          return /* tuple */[
                  /* WHITE */-945061239,
                  rem
                ];
      case 8 : 
          if (rem) {
            var match = rem[0];
            if (match !== 2) {
              if (match !== 5) {
                return Pervasives.invalid_arg("parse_color");
              } else {
                var match$1 = rem[1];
                if (match$1) {
                  var i = match$1[0];
                  check_char(i);
                  return /* tuple */[
                          /* `INDEX */[
                            1006818034,
                            i
                          ],
                          match$1[1]
                        ];
                } else {
                  return Pervasives.invalid_arg("parse_color");
                }
              }
            } else {
              var match$2 = rem[1];
              if (match$2) {
                var match$3 = match$2[1];
                if (match$3) {
                  var match$4 = match$3[1];
                  if (match$4) {
                    var b = match$4[0];
                    var g = match$3[0];
                    var r = match$2[0];
                    check_char(r);
                    check_char(g);
                    check_char(b);
                    return /* tuple */[
                            /* `RGB */[
                              4093677,
                              /* tuple */[
                                r,
                                g,
                                b
                              ]
                            ],
                            match$4[1]
                          ];
                  } else {
                    return Pervasives.invalid_arg("parse_color");
                  }
                } else {
                  return Pervasives.invalid_arg("parse_color");
                }
              } else {
                return Pervasives.invalid_arg("parse_color");
              }
            }
          } else {
            return Pervasives.invalid_arg("parse_color");
          }
          break;
      case 9 : 
          return /* tuple */[
                  /* DEFAULT */462924961,
                  rem
                ];
      
    }
  }
}

function set_light(param) {
  if (param >= 242322954) {
    if (param >= 735709851) {
      if (param !== 747441443) {
        if (param !== 853544351) {
          return Pervasives.invalid_arg("parse_color");
        } else {
          return /* LIGHT_BLACK */37390870;
        }
      } else {
        return /* LIGHT_CYAN */-1047393140;
      }
    } else if (param !== 400246435) {
      if (param >= 735709850) {
        return /* LIGHT_BLUE */-1059124733;
      } else {
        return Pervasives.invalid_arg("parse_color");
      }
    } else {
      return /* LIGHT_GREEN */-415907046;
    }
  } else if (param >= 4093234) {
    if (param !== 48188276) {
      if (param >= 242322953) {
        return /* LIGHT_MAGENTA */-960670144;
      } else {
        return Pervasives.invalid_arg("parse_color");
      }
    } else {
      return /* LIGHT_YELLOW */582072093;
    }
  } else if (param !== -945061239) {
    if (param >= 4093233) {
      return /* LIGHT_RED */-572123672;
    } else {
      return Pervasives.invalid_arg("parse_color");
    }
  } else {
    return /* LIGHT_WHITE */386268928;
  }
}

function parse_style(_style, _param) {
  while(true) {
    var param = _param;
    var style = _style;
    if (param) {
      var code = param[0];
      var exit = 0;
      if (code > 27 || code < 0) {
        exit = 1;
      } else {
        switch (code) {
          case 0 : 
              var style$1 = merge(style, /* record */[
                    /* fg_color : Some */[/* DEFAULT */462924961],
                    /* bg_color : Some */[/* DEFAULT */462924961],
                    /* bold : Some */[/* false */0],
                    /* italic : Some */[/* false */0],
                    /* underline : Some */[/* false */0],
                    /* negative : Some */[/* false */0],
                    /* prefix : None */0,
                    /* suffix : None */0
                  ]);
              _param = param[1];
              _style = style$1;
              continue ;
              case 1 : 
              var style$2 = make(/* None */0, /* None */0, /* Some */[/* true */1], /* None */0, /* None */0, /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
              _param = param[1];
              _style = style$2;
              continue ;
              case 3 : 
              var style$3 = make(/* None */0, /* None */0, /* None */0, /* Some */[/* true */1], /* None */0, /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
              _param = param[1];
              _style = style$3;
              continue ;
              case 4 : 
              var style$4 = make(/* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* true */1], /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
              _param = param[1];
              _style = style$4;
              continue ;
              case 7 : 
              var style$5 = make(/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* true */1], /* Some */[style], /* None */0, /* None */0, /* () */0);
              _param = param[1];
              _style = style$5;
              continue ;
              case 22 : 
              var style$6 = make(/* None */0, /* None */0, /* Some */[/* false */0], /* None */0, /* None */0, /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
              _param = param[1];
              _style = style$6;
              continue ;
              case 23 : 
              var style$7 = make(/* None */0, /* None */0, /* None */0, /* Some */[/* false */0], /* None */0, /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
              _param = param[1];
              _style = style$7;
              continue ;
              case 24 : 
              var style$8 = make(/* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* false */0], /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
              _param = param[1];
              _style = style$8;
              continue ;
              case 2 : 
          case 5 : 
          case 6 : 
          case 8 : 
          case 9 : 
          case 10 : 
          case 11 : 
          case 12 : 
          case 13 : 
          case 14 : 
          case 15 : 
          case 16 : 
          case 17 : 
          case 18 : 
          case 19 : 
          case 20 : 
          case 21 : 
          case 25 : 
          case 26 : 
              exit = 1;
              break;
          case 27 : 
              var style$9 = make(/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* false */0], /* Some */[style], /* None */0, /* None */0, /* () */0);
              _param = param[1];
              _style = style$9;
              continue ;
              
        }
      }
      if (exit === 1) {
        var rem = param[1];
        if (30 <= code && code < 40) {
          var match = parse_color(code % 10, rem);
          var style$10 = make(/* Some */[match[0]], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
          _param = match[1];
          _style = style$10;
          continue ;
          
        } else if (40 <= code && code < 50) {
          var match$1 = parse_color(code % 10, rem);
          var style$11 = make(/* None */0, /* Some */[match$1[0]], /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
          _param = match$1[1];
          _style = style$11;
          continue ;
          
        } else if (90 <= code && code < 100) {
          var match$2 = parse_color(code % 10, rem);
          var style$12 = make(/* Some */[set_light(match$2[0])], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
          _param = match$2[1];
          _style = style$12;
          continue ;
          
        } else if (100 <= code && code < 110) {
          var match$3 = parse_color(code % 10, rem);
          var style$13 = make(/* None */0, /* Some */[set_light(match$3[0])], /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[style], /* None */0, /* None */0, /* () */0);
          _param = match$3[1];
          _style = style$13;
          continue ;
          
        } else {
          _param = rem;
          continue ;
          
        }
      }
      
    } else {
      return style;
    }
  };
}

function parse(s) {
  var defs = split(/* ":" */58, s);
  var fold = function (accu, s) {
    var match = split(/* "=" */61, s);
    if (match) {
      var match$1 = match[1];
      if (match$1) {
        if (match$1[1]) {
          return accu;
        } else {
          var attrs = split(/* ";" */59, match$1[0]);
          try {
            var attrs$1 = List.map(Caml_format.caml_int_of_string, attrs);
            var attrs$2 = parse_style(make(/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* () */0), attrs$1);
            return /* :: */[
                    /* tuple */[
                      match[0],
                      attrs$2
                    ],
                    accu
                  ];
          }
          catch (exn){
            return accu;
          }
        }
      } else {
        return accu;
      }
    } else {
      return accu;
    }
  };
  return List.fold_left(fold, /* [] */0, defs);
}

var reset = "\x1b[0m";

exports.make = make;
exports.merge = merge;
exports.repr = repr;
exports.$$eval = $$eval;
exports.reset = reset;
exports.has_style = has_style;
exports.parse = parse;
/* Unix Not a pure module */
