// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Set = require("bs-platform/lib/js/set.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");

function Make(funarg) {
  var EltSet = $$Set.Make(funarg);
  var elements = function (param) {
    return /* tuple */[
            param[0],
            Curry._1(EltSet[/* elements */19], param[1])
          ];
  };
  var empty_001 = EltSet[/* empty */0];
  var empty = /* tuple */[
    /* false */0,
    empty_001
  ];
  var full_001 = EltSet[/* empty */0];
  var full = /* tuple */[
    /* true */1,
    full_001
  ];
  var is_empty = function (param) {
    if (param[0]) {
      return /* false */0;
    } else {
      return Curry._1(EltSet[/* is_empty */1], param[1]);
    }
  };
  var is_full = function (param) {
    if (param[0]) {
      return Curry._1(EltSet[/* is_empty */1], param[1]);
    } else {
      return /* false */0;
    }
  };
  var mem = function (x, param) {
    var s = param[1];
    if (param[0]) {
      return 1 - Curry._2(EltSet[/* mem */2], x, s);
    } else {
      return Curry._2(EltSet[/* mem */2], x, s);
    }
  };
  var singleton = function (x) {
    return /* tuple */[
            /* false */0,
            Curry._1(EltSet[/* singleton */4], x)
          ];
  };
  var add = function (x, param) {
    var s = param[1];
    var b = param[0];
    if (b) {
      return /* tuple */[
              b,
              Curry._2(EltSet[/* remove */5], x, s)
            ];
    } else {
      return /* tuple */[
              b,
              Curry._2(EltSet[/* add */3], x, s)
            ];
    }
  };
  var remove = function (x, param) {
    var s = param[1];
    var b = param[0];
    if (b) {
      return /* tuple */[
              b,
              Curry._2(EltSet[/* add */3], x, s)
            ];
    } else {
      return /* tuple */[
              b,
              Curry._2(EltSet[/* remove */5], x, s)
            ];
    }
  };
  var complement = function (param) {
    return /* tuple */[
            1 - param[0],
            param[1]
          ];
  };
  var union = function (s1, s2) {
    if (s1[0] !== 0) {
      var n1 = s1[1];
      if (s2[0] !== 0) {
        return /* tuple */[
                /* true */1,
                Curry._2(EltSet[/* inter */7], n1, s2[1])
              ];
      } else {
        return /* tuple */[
                /* true */1,
                Curry._2(EltSet[/* diff */8], n1, s2[1])
              ];
      }
    } else {
      var p1 = s1[1];
      if (s2[0] !== 0) {
        return /* tuple */[
                /* true */1,
                Curry._2(EltSet[/* diff */8], s2[1], p1)
              ];
      } else {
        return /* tuple */[
                /* false */0,
                Curry._2(EltSet[/* union */6], p1, s2[1])
              ];
      }
    }
  };
  var inter = function (s1, s2) {
    return complement(union(complement(s1), complement(s2)));
  };
  var diff = function (s1, s2) {
    return inter(s1, complement(s2));
  };
  var subset = function (s1, s2) {
    if (s1[0] !== 0) {
      if (s2[0] !== 0) {
        return Curry._2(EltSet[/* subset */11], s2[1], s1[1]);
      } else {
        return /* false */0;
      }
    } else {
      var p1 = s1[1];
      if (s2[0] !== 0) {
        return Curry._1(EltSet[/* is_empty */1], Curry._2(EltSet[/* inter */7], p1, s2[1]));
      } else {
        return Curry._2(EltSet[/* subset */11], p1, s2[1]);
      }
    }
  };
  var equal = function (param, param$1) {
    if (Caml_obj.caml_equal(param[0], param$1[0])) {
      return Curry._2(EltSet[/* equal */10], param[1], param$1[1]);
    } else {
      return /* false */0;
    }
  };
  return [
          empty,
          full,
          is_empty,
          is_full,
          mem,
          singleton,
          add,
          remove,
          union,
          inter,
          diff,
          complement,
          equal,
          subset,
          elements
        ];
}

exports.Make = Make;
/* No side effect */
