// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Vars$ReactTemplate = require("../src/vars.bs.js");
var Class$ReactTemplate = require("./class.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Declare$ReactTemplate = require("../src/declare.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Impargs$ReactTemplate = require("../src/impargs.bs.js");
var Univops$ReactTemplate = require("../src/univops.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Pretyping$ReactTemplate = require("../src/pretyping.bs.js");
var Univdecls$ReactTemplate = require("../src/univdecls.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var DeclareDef$ReactTemplate = require("./declareDef.bs.js");
var Typeclasses$ReactTemplate = require("../src/typeclasses.bs.js");
var Constrintern$ReactTemplate = require("../src/constrintern.bs.js");
var Proof_global$ReactTemplate = require("../src/proof_global.bs.js");
var Constrexpr_ops$ReactTemplate = require("../src/constrexpr_ops.bs.js");

var axiom_into_instance = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"automatically declare axioms whose type is a typeclass as instances",
      /* optkey : :: */[
        "Typeclasses",
        /* :: */[
          "Axioms",
          /* :: */[
            "Are",
            /* :: */[
              "Instances",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */(function () {
          return axiom_into_instance[0];
        }),
      /* optwrite */(function (param) {
          axiom_into_instance[0] = param;
          return /* () */0;
        })
    ]);

function should_axiom_into_instance(param) {
  if (param !== 0) {
    return axiom_into_instance[0];
  } else {
    return /* true */1;
  }
}

function declare_assumption(is_coe, param, param$1, pl, imps, impl, nl, param$2) {
  var ident = param$2[/* v */0];
  var ctx = param$1[1];
  var c = param$1[0];
  var kind = param[2];
  var p = param[1];
  var local = param[0];
  var exit = 0;
  if (local !== 0) {
    exit = 1;
  } else if (Lib$ReactTemplate.sections_are_opened(/* () */0)) {
    var ctx$1;
    ctx$1 = ctx.tag ? Univ$ReactTemplate.ContextSet[/* of_context */14](ctx[0]) : ctx[0];
    var decl_000 = Lib$ReactTemplate.cwd(/* () */0);
    var decl_001 = /* SectionLocalAssum */Block.__(1, [
        /* tuple */[
          c,
          ctx$1
        ],
        p,
        impl
      ]);
    var decl_002 = /* IsAssumption */Block.__(0, [kind]);
    var decl = /* tuple */[
      decl_000,
      decl_001,
      decl_002
    ];
    Declare$ReactTemplate.declare_variable(ident, decl);
    Declare$ReactTemplate.assumption_message(ident);
    if (!Flags$ReactTemplate.quiet[0] && Proof_global$ReactTemplate.there_are_pending_proofs(/* () */0)) {
      Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Variable"), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](ident)), Pp$ReactTemplate.strbrk(" is not visible from current goals")));
    }
    var r = /* VarRef */Block.__(0, [ident]);
    Typeclasses$ReactTemplate.declare_instance(/* None */0, /* true */1, r);
    if (is_coe) {
      Class$ReactTemplate.try_add_new_coercion(r, /* true */1, /* false */0);
    }
    return /* tuple */[
            r,
            Univ$ReactTemplate.Instance[/* empty */0],
            /* true */1
          ];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var do_instance = should_axiom_into_instance(local);
    var local$1 = DeclareDef$ReactTemplate.get_locality(ident, "axiom", local);
    var inl = typeof nl === "number" ? (
        nl !== 0 ? /* Some */[Flags$ReactTemplate.get_inline_level(/* () */0)] : /* None */0
      ) : /* Some */[nl[0]];
    var decl_000$1 = /* ParameterEntry */Block.__(1, [/* tuple */[
          /* None */0,
          /* tuple */[
            c,
            ctx
          ],
          inl
        ]]);
    var decl_001$1 = /* IsAssumption */Block.__(0, [kind]);
    var decl$1 = /* tuple */[
      decl_000$1,
      decl_001$1
    ];
    var kn = Declare$ReactTemplate.declare_constant(/* None */0, /* Some */[local$1], ident, /* None */0, decl$1);
    var gr = /* ConstRef */Block.__(1, [kn]);
    Impargs$ReactTemplate.maybe_declare_manual_implicits(/* false */0, gr, /* None */0, imps);
    Declare$ReactTemplate.declare_univ_binders(gr, pl);
    Declare$ReactTemplate.assumption_message(ident);
    if (do_instance) {
      Typeclasses$ReactTemplate.declare_instance(/* None */0, /* false */0, gr);
    }
    if (is_coe) {
      Class$ReactTemplate.try_add_new_coercion(gr, local$1, p);
    }
    var inst;
    inst = ctx.tag ? Univ$ReactTemplate.UContext[/* instance */3](ctx[0]) : Univ$ReactTemplate.Instance[/* empty */0];
    return /* tuple */[
            gr,
            inst,
            Lib$ReactTemplate.is_modtype_strict(/* () */0)
          ];
  }
  
}

function interp_assumption(sigma, env, impls, bl, c) {
  var c$1 = Constrexpr_ops$ReactTemplate.mkCProdN(Constrexpr_ops$ReactTemplate.local_binders_loc(bl), bl, c);
  var match = Constrintern$ReactTemplate.interp_type_evars_impls(env, sigma, /* Some */[impls], c$1);
  var match$1 = match[1];
  return /* tuple */[
          match[0],
          /* tuple */[
            match$1[0],
            match$1[1]
          ]
        ];
}

var empty_uctx = /* Monomorphic_const_entry */Block.__(0, [Univ$ReactTemplate.ContextSet[/* empty */0]]);

function next_uctx(uctx) {
  if (uctx.tag) {
    return uctx;
  } else {
    return empty_uctx;
  }
}

function declare_assumptions(idl, is_coe, k, param, pl, imps, nl) {
  var c = param[0];
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, id) {
          var uctx = param[2];
          var match = declare_assumption(is_coe, k, /* tuple */[
                c,
                uctx
              ], pl, imps, /* false */0, nl, id);
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      match[0],
                      match[1]
                    ],
                    param[0]
                  ],
                  match[2] && param[1],
                  next_uctx(uctx)
                ];
        }), /* tuple */[
        /* [] */0,
        /* true */1,
        param[1]
      ], idl);
  return /* tuple */[
          Curry._1(Util$ReactTemplate.List[/* rev */4], match[0]),
          match[1]
        ];
}

function maybe_error_many_udecls(param) {
  if (param[1]) {
    return CErrors$ReactTemplate.user_err(param[0][/* loc */1], /* Some */["many_universe_declarations"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("When declaring multiple axioms in one command, "), Pp$ReactTemplate.str("only the first is allowed a universe binder ")), Pp$ReactTemplate.str("(which will be shared by the whole block).")));
  } else {
    return /* () */0;
  }
}

function process_assumptions_udecls(kind, l) {
  var match;
  if (l) {
    var match$1 = l[0][1][0];
    if (match$1) {
      var match$2 = match$1[0];
      Curry._2(Util$ReactTemplate.List[/* iter */9], maybe_error_many_udecls, match$1[1]);
      Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
              return Curry._2(Util$ReactTemplate.List[/* iter */9], maybe_error_many_udecls, param[1][0]);
            }), l[1]);
      match = /* tuple */[
        match$2[1],
        match$2[0]
      ];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "comAssumption.ml",
              125,
              30
            ]
          ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "comAssumption.ml",
            125,
            30
          ]
        ];
  }
  var udecl = match[0];
  if (!kind[0]) {
    if (udecl) {
      if (Lib$ReactTemplate.sections_are_opened(/* () */0)) {
        var loc = match[1][/* loc */1];
        var msg = Pp$ReactTemplate.str("Section variables cannot be polymorphic.");
        CErrors$ReactTemplate.user_err(loc, /* None */0, msg);
      }
      
    }
    
  }
  return /* tuple */[
          udecl,
          Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  var match = param[1];
                  return /* tuple */[
                          param[0],
                          /* tuple */[
                            Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                    return prim[0];
                                  }), match[0]),
                            match[1]
                          ]
                        ];
                }), l)
        ];
}

function do_assumptions(kind, nl, l) {
  var env = Global$ReactTemplate.env(/* () */0);
  var match = process_assumptions_udecls(kind, l);
  var l$1 = match[1];
  var match$1 = Univdecls$ReactTemplate.interp_univ_decl_opt(env, match[0]);
  var l$2 = Util$ReactTemplate.pi2(kind) ? Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, acc) {
            var match = param[1];
            var c = match[1];
            var is_coe = param[0];
            return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (id, acc) {
                          return /* :: */[
                                  /* tuple */[
                                    is_coe,
                                    /* tuple */[
                                      /* :: */[
                                        id,
                                        /* [] */0
                                      ],
                                      c
                                    ]
                                  ],
                                  acc
                                ];
                        }), match[0], acc);
          }), l$1, /* [] */0) : l$1;
  var match$2 = Curry._3(Util$ReactTemplate.List[/* fold_left_map */116], (function (param, param$1) {
          var match = param$1[1];
          var idl = match[0];
          var ienv = param[2];
          var env = param[1];
          var match$1 = interp_assumption(param[0], env, ienv, /* [] */0, match[1]);
          var match$2 = match$1[1];
          var imps = match$2[1];
          var t = match$2[0];
          var sigma = match$1[0];
          var env$1 = EConstr$ReactTemplate.push_named_context(Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                      return /* LocalAssum */Block.__(0, [
                                param[/* v */0],
                                t
                              ]);
                    }), idl), env);
          var ienv$1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, ienv) {
                  var impls = Constrintern$ReactTemplate.compute_internalization_data(env$1, sigma, /* Variable */2, t, imps);
                  return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], param[/* v */0], impls, ienv);
                }), idl, ienv);
          return /* tuple */[
                  /* tuple */[
                    sigma,
                    env$1,
                    ienv$1
                  ],
                  /* tuple */[
                    /* tuple */[
                      param$1[0],
                      idl
                    ],
                    t,
                    imps
                  ]
                ];
        }), /* tuple */[
        match$1[0],
        env,
        Constrintern$ReactTemplate.empty_internalization_env
      ], l$2);
  var sigma = Pretyping$ReactTemplate.solve_remaining_evars(Pretyping$ReactTemplate.all_and_fail_flags, env, match$2[0][0], Evd$ReactTemplate.empty);
  var sigma$1 = Evd$ReactTemplate.minimize_universes(sigma);
  var match$3 = Curry._3(Util$ReactTemplate.List[/* fold_left_map */116], (function (uvars, param) {
          var t = EConstr$ReactTemplate.to_constr(sigma$1, param[1]);
          var uvars$1 = Curry._2(Univ$ReactTemplate.LSet[/* union */6], uvars, Univops$ReactTemplate.universes_of_constr(env, t));
          return /* tuple */[
                  uvars$1,
                  /* tuple */[
                    param[0],
                    t,
                    param[2]
                  ]
                ];
        }), Univ$ReactTemplate.LSet[/* empty */0], match$2[1]);
  var sigma$2 = Evd$ReactTemplate.restrict_universe_context(sigma$1, match$3[0]);
  var uctx = Evd$ReactTemplate.check_univ_decl(Util$ReactTemplate.pi2(kind), sigma$2, match$1[1]);
  var ubinders = Evd$ReactTemplate.universe_binders(sigma$2);
  return Util$ReactTemplate.pi2(Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                    var match = param$1[0];
                    var idl = match[1];
                    var uctx = param[2];
                    var subst = param[0];
                    var t = Vars$ReactTemplate.replace_vars(subst, param$1[1]);
                    var match$1 = declare_assumptions(idl, match[0], kind, /* tuple */[
                          t,
                          uctx
                        ], ubinders, param$1[2], nl);
                    var subst$prime = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param, param$1) {
                            return /* tuple */[
                                    param[/* v */0],
                                    Universes$ReactTemplate.constr_of_global_univ(/* tuple */[
                                          param$1[0],
                                          param$1[1]
                                        ])
                                  ];
                          }), idl, match$1[0]);
                    return /* tuple */[
                            Util$ReactTemplate.$at(subst$prime, subst),
                            match$1[1] && param[1],
                            next_uctx(uctx)
                          ];
                  }), /* tuple */[
                  /* [] */0,
                  /* true */1,
                  uctx
                ], match$3[1]));
}

exports.do_assumptions = do_assumptions;
exports.declare_assumption = declare_assumption;
/*  Not a pure module */
