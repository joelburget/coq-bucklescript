// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Monad$ReactTemplate = require("./monad.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Store$ReactTemplate = require("./store.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var UGraph$ReactTemplate = require("./uGraph.bs.js");
var UState$ReactTemplate = require("./uState.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var Safe_typing$ReactTemplate = require("./safe_typing.bs.js");

function equal(l1, l2) {
  if (l1) {
    if (l2) {
      var _l1 = l1[0];
      var _l2 = l2[0];
      while(true) {
        var l2$1 = _l2;
        var l1$1 = _l1;
        if (l1$1) {
          if (l2$1) {
            var h2 = l2$1[0];
            if (l1$1[0] ? h2 : 1 - h2) {
              _l2 = l2$1[1];
              _l1 = l1$1[1];
              continue ;
              
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
        } else if (l2$1) {
          return /* false */0;
        } else {
          return /* true */1;
        }
      };
    } else {
      return /* false */0;
    }
  } else if (l2) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function is_identity(_param) {
  while(true) {
    var param = _param;
    if (param) {
      if (param[0] !== 0) {
        _param = param[1];
        continue ;
        
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function normalize(f) {
  if (is_identity(f)) {
    return /* None */0;
  } else {
    return /* Some */[f];
  }
}

function filter_list(f, l) {
  if (f) {
    return CList$ReactTemplate.filter_with(f[0], l);
  } else {
    return l;
  }
}

function filter_array(f, v) {
  if (f) {
    return CArray$ReactTemplate.filter_with(f[0], v);
  } else {
    return v;
  }
}

function extend(_n, _l) {
  while(true) {
    var l = _l;
    var n = _n;
    if (n) {
      _l = /* :: */[
        /* true */1,
        l
      ];
      _n = n - 1 | 0;
      continue ;
      
    } else {
      return l;
    }
  };
}

function extend$1(n, param) {
  if (param) {
    return /* Some */[extend(n, param[0])];
  } else {
    return /* None */0;
  }
}

function compose(f1, f2) {
  if (f1) {
    if (f2) {
      return normalize(CList$ReactTemplate.filter_with(f1[0], f2[0]));
    } else {
      return /* None */0;
    }
  } else {
    return f2;
  }
}

function apply_subfilter_array(filter, subfilter) {
  if (filter) {
    var len = subfilter.length;
    var fold = function (b, param) {
      var ans = param[1];
      var i = param[0];
      if (b) {
        if (0 > i) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "evd.ml",
                  97,
                  17
                ]
              ];
        }
        return /* tuple */[
                i - 1 | 0,
                /* :: */[
                  subfilter[i],
                  ans
                ]
              ];
      } else {
        return /* tuple */[
                i,
                /* :: */[
                  /* false */0,
                  ans
                ]
              ];
      }
    };
    return /* Some */[Curry._3(Util$ReactTemplate.List[/* fold_right */14], fold, filter[0], /* tuple */[
                    len - 1 | 0,
                    /* [] */0
                  ])[1]];
  } else {
    return /* Some */[Util$ReactTemplate.$$Array[/* to_list */9](subfilter)];
  }
}

function apply_subfilter(filter, subfilter) {
  return apply_subfilter_array(filter, Util$ReactTemplate.$$Array[/* of_list */10](subfilter));
}

function restrict_upon(f, len, p) {
  var newfilter = Util$ReactTemplate.$$Array[/* init */0](len, p);
  if (Util$ReactTemplate.$$Array[/* for_all */26]((function (id) {
            return id;
          }), newfilter)) {
    return /* None */0;
  } else {
    return /* Some */[apply_subfilter_array(f, newfilter)];
  }
}

function map_along(f, flt, l) {
  return normalize(flt ? Curry._3(Util$ReactTemplate.List[/* map2 */16], f, flt[0], l) : Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                      return Curry._2(f, /* true */1, x);
                    }), l));
}

var make = normalize;

function repr(f) {
  return f;
}

var Filter = /* module */[
  /* equal */equal,
  /* identity : None */0,
  /* filter_list */filter_list,
  /* filter_array */filter_array,
  /* extend */extend$1,
  /* compose */compose,
  /* apply_subfilter */apply_subfilter,
  /* restrict_upon */restrict_upon,
  /* map_along */map_along,
  /* make */make,
  /* repr */repr
];

var Store = Store$ReactTemplate.Make(/* module */[]);

function string_of_existential(evk) {
  return "?X" + Pervasives.string_of_int(Evar$ReactTemplate.repr(evk));
}

function make_evar(hyps, ccl) {
  return /* record */[
          /* evar_concl */ccl,
          /* evar_hyps */hyps,
          /* evar_body : Evar_empty */0,
          /* evar_filter : None */0,
          /* evar_source */Loc$ReactTemplate.tag(/* None */0, /* InternalHole */0),
          /* evar_candidates : None */0,
          /* evar_extra */Store[/* empty */0]
        ];
}

function instance_mismatch() {
  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Signature and its instance do not match."));
}

function evar_concl(evi) {
  return evi[/* evar_concl */0];
}

function evar_filter(evi) {
  return evi[/* evar_filter */3];
}

function evar_body(evi) {
  return evi[/* evar_body */2];
}

function evar_context(evi) {
  return Environ$ReactTemplate.named_context_of_val(evi[/* evar_hyps */1]);
}

function evar_filtered_context(evi) {
  return filter_list(evi[/* evar_filter */3], Environ$ReactTemplate.named_context_of_val(evi[/* evar_hyps */1]));
}

function evar_hyps(evi) {
  return evi[/* evar_hyps */1];
}

function evar_filtered_hyps(evi) {
  var match = evi[/* evar_filter */3];
  if (match) {
    var make_hyps = function (_filter, _ctxt) {
      while(true) {
        var ctxt = _ctxt;
        var filter = _filter;
        if (filter) {
          if (filter[0] !== 0) {
            if (ctxt) {
              var hyps = make_hyps(filter[1], ctxt[1]);
              return Environ$ReactTemplate.push_named_context_val(ctxt[0], hyps);
            } else {
              return instance_mismatch(/* () */0);
            }
          } else if (ctxt) {
            _ctxt = ctxt[1];
            _filter = filter[1];
            continue ;
            
          } else {
            return instance_mismatch(/* () */0);
          }
        } else if (ctxt) {
          return instance_mismatch(/* () */0);
        } else {
          return Environ$ReactTemplate.empty_named_context_val;
        }
      };
    };
    return make_hyps(match[0], Environ$ReactTemplate.named_context_of_val(evi[/* evar_hyps */1]));
  } else {
    return evi[/* evar_hyps */1];
  }
}

function evar_env(evi) {
  return Global$ReactTemplate.env_of_context(evi[/* evar_hyps */1]);
}

function evar_filtered_env(evi) {
  var match = evi[/* evar_filter */3];
  if (match) {
    var make_env = function (_filter, _ctxt) {
      while(true) {
        var ctxt = _ctxt;
        var filter = _filter;
        if (filter) {
          if (filter[0] !== 0) {
            if (ctxt) {
              var env = make_env(filter[1], ctxt[1]);
              return Environ$ReactTemplate.push_named(ctxt[0], env);
            } else {
              return instance_mismatch(/* () */0);
            }
          } else if (ctxt) {
            _ctxt = ctxt[1];
            _filter = filter[1];
            continue ;
            
          } else {
            return instance_mismatch(/* () */0);
          }
        } else if (ctxt) {
          return instance_mismatch(/* () */0);
        } else {
          return Environ$ReactTemplate.reset_context(Global$ReactTemplate.env(/* () */0));
        }
      };
    };
    return make_env(match[0], Environ$ReactTemplate.named_context_of_val(evi[/* evar_hyps */1]));
  } else {
    return Global$ReactTemplate.env_of_context(evi[/* evar_hyps */1]);
  }
}

function map_evar_body(f, param) {
  if (param) {
    return /* Evar_defined */[Curry._1(f, param[0])];
  } else {
    return /* Evar_empty */0;
  }
}

function map_evar_info(f, evi) {
  return /* record */[
          /* evar_concl */Curry._1(f, evi[/* evar_concl */0]),
          /* evar_hyps */Environ$ReactTemplate.map_named_val(f, evi[/* evar_hyps */1]),
          /* evar_body */map_evar_body(f, evi[/* evar_body */2]),
          /* evar_filter */evi[/* evar_filter */3],
          /* evar_source */evi[/* evar_source */4],
          /* evar_candidates */Option$ReactTemplate.map(Curry._1(Util$ReactTemplate.List[/* map */10], f), evi[/* evar_candidates */5]),
          /* evar_extra */evi[/* evar_extra */6]
        ];
}

var NotInstantiatedEvar = Caml_exceptions.create("Evd-ReactTemplate.NotInstantiatedEvar");

function evar_instance_array(test_id, info, args) {
  var len = args.length;
  var instrec = function (_filter, _ctxt, _i) {
    while(true) {
      var i = _i;
      var ctxt = _ctxt;
      var filter = _filter;
      if (filter) {
        if (filter[0] !== 0) {
          if (ctxt) {
            var ctxt$1 = ctxt[1];
            var d = ctxt[0];
            var filter$1 = filter[1];
            if (i < len) {
              var c = args[i];
              if (Curry._2(test_id, d, c)) {
                _i = i + 1 | 0;
                _ctxt = ctxt$1;
                _filter = filter$1;
                continue ;
                
              } else {
                return /* :: */[
                        /* tuple */[
                          Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d),
                          c
                        ],
                        instrec(filter$1, ctxt$1, i + 1 | 0)
                      ];
              }
            } else {
              return instance_mismatch(/* () */0);
            }
          } else {
            return instance_mismatch(/* () */0);
          }
        } else if (ctxt) {
          _ctxt = ctxt[1];
          _filter = filter[1];
          continue ;
          
        } else {
          return instance_mismatch(/* () */0);
        }
      } else if (ctxt || i !== len) {
        return instance_mismatch(/* () */0);
      } else {
        return /* [] */0;
      }
    };
  };
  var match = info[/* evar_filter */3];
  if (match) {
    return instrec(match[0], Environ$ReactTemplate.named_context_of_val(info[/* evar_hyps */1]), 0);
  } else {
    var map = function (i, d) {
      if (i < len) {
        var c = args[i];
        if (Curry._2(test_id, d, c)) {
          return /* None */0;
        } else {
          return /* Some */[/* tuple */[
                    Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d),
                    c
                  ]];
        }
      } else {
        return instance_mismatch(/* () */0);
      }
    };
    return Curry._2(Util$ReactTemplate.List[/* map_filter_i */63], map, Environ$ReactTemplate.named_context_of_val(info[/* evar_hyps */1]));
  }
}

function make_evar_instance_array(info, args) {
  var partial_arg = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
  return evar_instance_array((function (param) {
                return Util$ReactTemplate.$percent$great(partial_arg, Constr$ReactTemplate.isVarId, param);
              }), info, args);
}

function instantiate_evar_array(info, c, args) {
  var inst = make_evar_instance_array(info, args);
  if (inst) {
    return Vars$ReactTemplate.replace_vars(inst, c);
  } else {
    return c;
  }
}

function metavars_of(c) {
  var collrec = function (acc, c) {
    var match = Constr$ReactTemplate.kind(c);
    if (match.tag === 2) {
      return Curry._2(Int$ReactTemplate.$$Set[/* add */3], match[0], acc);
    } else {
      return Constr$ReactTemplate.fold(collrec, acc, c);
    }
  };
  return collrec(Int$ReactTemplate.$$Set[/* empty */0], c);
}

function mk_freelisted(c) {
  return /* record */[
          /* rebus */c,
          /* freemetas */metavars_of(c)
        ];
}

function map_fl(f, cfl) {
  return /* record */[
          /* rebus */Curry._1(f, cfl[/* rebus */0]),
          /* freemetas */cfl[/* freemetas */1]
        ];
}

function eq_instance_constraint(c1, c2) {
  return +(c1 === c2);
}

function map_clb(f, param) {
  if (param.tag) {
    var match = param[1];
    return /* Clval */Block.__(1, [
              param[0],
              /* tuple */[
                map_fl(f, match[0]),
                match[1]
              ],
              map_fl(f, param[2])
            ]);
  } else {
    return /* Cltyp */Block.__(0, [
              param[0],
              map_fl(f, param[1])
            ]);
  }
}

function clb_name(param) {
  if (param.tag) {
    return /* tuple */[
            param[0],
            /* true */1
          ];
  } else {
    return /* tuple */[
            param[0],
            /* false */0
          ];
  }
}

var empty_000 = Evar$ReactTemplate.$$Map[/* empty */0];

var empty_001 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];

var empty = /* tuple */[
  empty_000,
  empty_001
];

function add_name_undefined(naming, evk, evi, evar_names) {
  if (Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], evk, evar_names[0])) {
    return evar_names;
  } else {
    var id = naming;
    var evk$1 = evk;
    var names = evar_names;
    if (id) {
      var id$1 = id[0];
      var idtoev = names[1];
      if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id$1, idtoev)) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Already an existential evar of name "), Names$ReactTemplate.Id[/* print */8](id$1)));
      }
      return /* tuple */[
              Curry._3(Evar$ReactTemplate.$$Map[/* add */3], evk$1, id$1, names[0]),
              Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id$1, evk$1, idtoev)
            ];
    } else {
      return names;
    }
  }
}

function remove_name_defined(evk, names) {
  var evtoid = names[0];
  var id;
  try {
    id = /* Some */[Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk, evtoid)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      id = /* None */0;
    } else {
      throw exn;
    }
  }
  if (id) {
    return /* tuple */[
            Curry._2(Evar$ReactTemplate.$$Map[/* remove */5], evk, evtoid),
            Curry._2(Names$ReactTemplate.Id[/* Map */10][/* remove */5], id[0], names[1])
          ];
  } else {
    return names;
  }
}

function rename(evk, id, param) {
  var idtoev = param[1];
  var evtoid = param[0];
  var id$prime;
  try {
    id$prime = /* Some */[Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk, evtoid)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      id$prime = /* None */0;
    } else {
      throw exn;
    }
  }
  if (id$prime) {
    if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id, idtoev)) {
      CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Evar name already in use."));
    }
    return /* tuple */[
            Curry._3(Evar$ReactTemplate.$$Map[/* set */25], evk, id, evtoid),
            Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, evk, Curry._2(Names$ReactTemplate.Id[/* Map */10][/* remove */5], id$prime[0], idtoev))
          ];
  } else {
    return /* tuple */[
            Curry._3(Evar$ReactTemplate.$$Map[/* add */3], evk, id, evtoid),
            Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, evk, idtoev)
          ];
  }
}

function reassign_name_defined(evk, evk$prime, names) {
  var evtoid = names[0];
  var id;
  try {
    id = /* Some */[Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk, evtoid)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      id = /* None */0;
    } else {
      throw exn;
    }
  }
  if (id) {
    var id$1 = id[0];
    return /* tuple */[
            Curry._3(Evar$ReactTemplate.$$Map[/* add */3], evk$prime, id$1, Curry._2(Evar$ReactTemplate.$$Map[/* remove */5], evk, evtoid)),
            Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id$1, evk$prime, Curry._2(Names$ReactTemplate.Id[/* Map */10][/* remove */5], id$1, names[1]))
          ];
  } else {
    return names;
  }
}

function rename$1(evk, id, evd) {
  var newrecord = evd.slice();
  newrecord[/* evar_names */2] = rename(evk, id, evd[/* evar_names */2]);
  return newrecord;
}

function add_with_name(name, d, e, i) {
  var match = i[/* evar_body */2];
  if (match) {
    var evar_names = remove_name_defined(e, d[/* evar_names */2]);
    var newrecord = d.slice();
    newrecord[/* defn_evars */0] = Curry._3(Evar$ReactTemplate.$$Map[/* add */3], e, i, d[/* defn_evars */0]);
    newrecord[/* evar_names */2] = evar_names;
    return newrecord;
  } else {
    var evar_names$1 = add_name_undefined(name, e, i, d[/* evar_names */2]);
    var newrecord$1 = d.slice();
    newrecord$1[/* undf_evars */1] = Curry._3(Evar$ReactTemplate.$$Map[/* add */3], e, i, d[/* undf_evars */1]);
    newrecord$1[/* evar_names */2] = evar_names$1;
    return newrecord$1;
  }
}

function add(d, e, i) {
  return add_with_name(/* None */0, d, e, i);
}

var match = Summary$ReactTemplate.ref_tag(/* None */0, "evar counter", 0);

var evar_ctr = match[0];

function new_untyped_evar() {
  evar_ctr[0] = evar_ctr[0] + 1 | 0;
  return Evar$ReactTemplate.unsafe_of_int(evar_ctr[0]);
}

function new_evar(evd, name, evi) {
  var evk = new_untyped_evar(/* () */0);
  var evd$1 = add_with_name(name, evd, evk, evi);
  return /* tuple */[
          evd$1,
          evk
        ];
}

function remove(d, e) {
  var undf_evars = Curry._2(Evar$ReactTemplate.$$Map[/* remove */5], e, d[/* undf_evars */1]);
  var defn_evars = Curry._2(Evar$ReactTemplate.$$Map[/* remove */5], e, d[/* defn_evars */0]);
  var match = d[/* principal_future_goal */9];
  var principal_future_goal = match && !Evar$ReactTemplate.equal(e, match[0]) ? d[/* principal_future_goal */9] : /* None */0;
  var future_goals = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (e$prime) {
          return 1 - Evar$ReactTemplate.equal(e, e$prime);
        }), d[/* future_goals */8]);
  var future_goals_status = Curry._2(Evar$ReactTemplate.$$Map[/* remove */5], e, d[/* future_goals_status */10]);
  return /* record */[
          /* defn_evars */defn_evars,
          /* undf_evars */undf_evars,
          /* evar_names */d[/* evar_names */2],
          /* universes */d[/* universes */3],
          /* conv_pbs */d[/* conv_pbs */4],
          /* last_mods */d[/* last_mods */5],
          /* metas */d[/* metas */6],
          /* effects */d[/* effects */7],
          /* future_goals */future_goals,
          /* principal_future_goal */principal_future_goal,
          /* future_goals_status */future_goals_status,
          /* extras */d[/* extras */11]
        ];
}

function find(d, e) {
  try {
    return Curry._2(Evar$ReactTemplate.$$Map[/* find */21], e, d[/* undf_evars */1]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Curry._2(Evar$ReactTemplate.$$Map[/* find */21], e, d[/* defn_evars */0]);
    } else {
      throw exn;
    }
  }
}

function find_undefined(d, e) {
  return Curry._2(Evar$ReactTemplate.$$Map[/* find */21], e, d[/* undf_evars */1]);
}

function mem(d, e) {
  if (Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], e, d[/* undf_evars */1])) {
    return /* true */1;
  } else {
    return Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], e, d[/* defn_evars */0]);
  }
}

function undefined_map(d) {
  return d[/* undf_evars */1];
}

function drop_all_defined(d) {
  var newrecord = d.slice();
  newrecord[/* defn_evars */0] = Evar$ReactTemplate.$$Map[/* empty */0];
  return newrecord;
}

function fold(f, d, a) {
  return Curry._3(Evar$ReactTemplate.$$Map[/* fold */10], f, d[/* defn_evars */0], Curry._3(Evar$ReactTemplate.$$Map[/* fold */10], f, d[/* undf_evars */1], a));
}

function fold_undefined(f, d, a) {
  return Curry._3(Evar$ReactTemplate.$$Map[/* fold */10], f, d[/* undf_evars */1], a);
}

function raw_map(f, d) {
  var f$1 = function (evk, info) {
    var ans = Curry._2(f, evk, info);
    var match = info[/* evar_body */2];
    var match$1 = ans[/* evar_body */2];
    if (match) {
      if (match$1) {
        
      } else {
        CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unrespectful mapping function."));
      }
    } else if (match$1) {
      CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unrespectful mapping function."));
    }
    return ans;
  };
  var defn_evars = Curry._2(Evar$ReactTemplate.$$Map[/* smartmapi */32], f$1, d[/* defn_evars */0]);
  var undf_evars = Curry._2(Evar$ReactTemplate.$$Map[/* smartmapi */32], f$1, d[/* undf_evars */1]);
  var newrecord = d.slice();
  newrecord[/* defn_evars */0] = defn_evars;
  newrecord[/* undf_evars */1] = undf_evars;
  return newrecord;
}

function raw_map_undefined(f, d) {
  var f$1 = function (evk, info) {
    var ans = Curry._2(f, evk, info);
    var match = ans[/* evar_body */2];
    if (match) {
      CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unrespectful mapping function."));
    }
    return ans;
  };
  var newrecord = d.slice();
  newrecord[/* undf_evars */1] = Curry._2(Evar$ReactTemplate.$$Map[/* smartmapi */32], f$1, d[/* undf_evars */1]);
  return newrecord;
}

function is_defined(d, e) {
  return Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], e, d[/* defn_evars */0]);
}

function is_undefined(d, e) {
  return Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], e, d[/* undf_evars */1]);
}

function existential_value(d, param) {
  var info = find(d, param[0]);
  var match = info[/* evar_body */2];
  if (match) {
    return instantiate_evar_array(info, match[0], param[1]);
  } else {
    throw NotInstantiatedEvar;
  }
}

function existential_opt_value(d, ev) {
  try {
    return /* Some */[existential_value(d, ev)];
  }
  catch (exn){
    if (exn === NotInstantiatedEvar) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function existential_type(d, param) {
  var n = param[0];
  var info;
  try {
    info = find(d, n);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      info = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Evar "), Pp$ReactTemplate.str(string_of_existential(n))), Pp$ReactTemplate.str(" was not declared.")));
    } else {
      throw exn;
    }
  }
  return instantiate_evar_array(info, info[/* evar_concl */0], param[1]);
}

function add_constraints(d, c) {
  var newrecord = d.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.add_constraints(d[/* universes */3], c);
  return newrecord;
}

function add_universe_constraints(d, c) {
  var newrecord = d.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.add_universe_constraints(d[/* universes */3], c);
  return newrecord;
}

function is_empty(d) {
  if (Curry._1(Evar$ReactTemplate.$$Map[/* is_empty */1], d[/* defn_evars */0]) && Curry._1(Evar$ReactTemplate.$$Map[/* is_empty */1], d[/* undf_evars */1]) && Curry._1(Util$ReactTemplate.List[/* is_empty */45], d[/* conv_pbs */4])) {
    return Curry._1(Int$ReactTemplate.$$Map[/* is_empty */1], d[/* metas */6]);
  } else {
    return /* false */0;
  }
}

function cmap(f, evd) {
  var newrecord = evd.slice();
  newrecord[/* defn_evars */0] = Curry._2(Evar$ReactTemplate.$$Map[/* map */22], (function (param) {
          return map_evar_info(f, param);
        }), evd[/* defn_evars */0]);
  newrecord[/* undf_evars */1] = Curry._2(Evar$ReactTemplate.$$Map[/* map */22], (function (param) {
          return map_evar_info(f, param);
        }), evd[/* undf_evars */1]);
  newrecord[/* metas */6] = Curry._2(Int$ReactTemplate.$$Map[/* map */22], (function (param) {
          return map_clb(f, param);
        }), evd[/* metas */6]);
  return newrecord;
}

function create_evar_defs(sigma) {
  var newrecord = sigma.slice();
  newrecord[/* conv_pbs */4] = /* [] */0;
  newrecord[/* last_mods */5] = Evar$ReactTemplate.$$Set[/* empty */0];
  newrecord[/* metas */6] = Int$ReactTemplate.$$Map[/* empty */0];
  return newrecord;
}

var empty_000$1 = /* defn_evars */Evar$ReactTemplate.$$Map[/* empty */0];

var empty_001$1 = /* undf_evars */Evar$ReactTemplate.$$Map[/* empty */0];

var empty_005 = /* last_mods */Evar$ReactTemplate.$$Set[/* empty */0];

var empty_006 = /* metas */Int$ReactTemplate.$$Map[/* empty */0];

var empty_010 = /* future_goals_status */Evar$ReactTemplate.$$Map[/* empty */0];

var empty_011 = /* extras */Store[/* empty */0];

var empty$1 = /* record */[
  empty_000$1,
  empty_001$1,
  /* evar_names */empty,
  /* universes */UState$ReactTemplate.empty,
  /* conv_pbs : [] */0,
  empty_005,
  empty_006,
  /* effects */Safe_typing$ReactTemplate.empty_private_constants,
  /* future_goals : [] */0,
  /* principal_future_goal : None */0,
  empty_010,
  empty_011
];

function from_env(e) {
  var newrecord = empty$1.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.make(Environ$ReactTemplate.universes(e));
  return newrecord;
}

function from_ctx(ctx) {
  var newrecord = empty$1.slice();
  newrecord[/* universes */3] = ctx;
  return newrecord;
}

function has_undefined(evd) {
  return 1 - Curry._1(Evar$ReactTemplate.$$Map[/* is_empty */1], evd[/* undf_evars */1]);
}

function evars_reset_evd($staropt$star, $staropt$star$1, evd, d) {
  var with_conv_pbs = $staropt$star ? $staropt$star[0] : /* false */0;
  var with_univs = $staropt$star$1 ? $staropt$star$1[0] : /* true */1;
  var conv_pbs = with_conv_pbs ? evd[/* conv_pbs */4] : d[/* conv_pbs */4];
  var last_mods = with_conv_pbs ? evd[/* last_mods */5] : d[/* last_mods */5];
  var universes = with_univs ? UState$ReactTemplate.union(evd[/* universes */3], d[/* universes */3]) : evd[/* universes */3];
  var newrecord = evd.slice();
  newrecord[/* universes */3] = universes;
  newrecord[/* conv_pbs */4] = conv_pbs;
  newrecord[/* last_mods */5] = last_mods;
  newrecord[/* metas */6] = d[/* metas */6];
  return newrecord;
}

function merge_universe_context(evd, uctx$prime) {
  var newrecord = evd.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.union(evd[/* universes */3], uctx$prime);
  return newrecord;
}

function set_universe_context(evd, uctx$prime) {
  var newrecord = evd.slice();
  newrecord[/* universes */3] = uctx$prime;
  return newrecord;
}

function add_conv_pb($staropt$star, pb, d) {
  var tail = $staropt$star ? $staropt$star[0] : /* false */0;
  if (tail) {
    var newrecord = d.slice();
    newrecord[/* conv_pbs */4] = Util$ReactTemplate.$at(d[/* conv_pbs */4], /* :: */[
          pb,
          /* [] */0
        ]);
    return newrecord;
  } else {
    var newrecord$1 = d.slice();
    newrecord$1[/* conv_pbs */4] = /* :: */[
      pb,
      d[/* conv_pbs */4]
    ];
    return newrecord$1;
  }
}

function evar_source(evk, d) {
  return find(d, evk)[/* evar_source */4];
}

function evar_ident(evk, evd) {
  var evk$1 = evk;
  var param = evd[/* evar_names */2];
  try {
    return /* Some */[Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk$1, param[0])];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function evar_key(id, evd) {
  var id$1 = id;
  var param = evd[/* evar_names */2];
  return Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$1, param[1]);
}

var restricted = Curry._1(Store[/* field */5], /* () */0);

function define_aux(dorestrict, def, undef, evk, body) {
  var oldinfo;
  try {
    oldinfo = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk, undef);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      oldinfo = Curry._2(Evar$ReactTemplate.$$Map[/* mem */2], evk, def) ? CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Evd.define"], Pp$ReactTemplate.str("cannot define an evar twice.")) : CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Evd.define"], Pp$ReactTemplate.str("cannot define undeclared evar."));
    } else {
      throw exn;
    }
  }
  if (oldinfo[/* evar_body */2] !== /* Evar_empty */0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "evd.ml",
            637,
            11
          ]
        ];
  }
  var evar_extra = dorestrict ? Curry._3(Store[/* set */1], oldinfo[/* evar_extra */6], restricted, dorestrict[0]) : oldinfo[/* evar_extra */6];
  var newinfo_000 = /* evar_concl */oldinfo[/* evar_concl */0];
  var newinfo_001 = /* evar_hyps */oldinfo[/* evar_hyps */1];
  var newinfo_002 = /* evar_body : Evar_defined */[body];
  var newinfo_003 = /* evar_filter */oldinfo[/* evar_filter */3];
  var newinfo_004 = /* evar_source */oldinfo[/* evar_source */4];
  var newinfo_005 = /* evar_candidates */oldinfo[/* evar_candidates */5];
  var newinfo = /* record */[
    newinfo_000,
    newinfo_001,
    newinfo_002,
    newinfo_003,
    newinfo_004,
    newinfo_005,
    /* evar_extra */evar_extra
  ];
  return /* tuple */[
          Curry._3(Evar$ReactTemplate.$$Map[/* add */3], evk, newinfo, def),
          Curry._2(Evar$ReactTemplate.$$Map[/* remove */5], evk, undef)
        ];
}

function define(evk, body, evd) {
  var match = define_aux(/* None */0, evd[/* defn_evars */0], evd[/* undf_evars */1], evk, body);
  var match$1 = evd[/* conv_pbs */4];
  var last_mods = match$1 ? Curry._2(Evar$ReactTemplate.$$Set[/* add */3], evk, evd[/* last_mods */5]) : evd[/* last_mods */5];
  var evar_names = remove_name_defined(evk, evd[/* evar_names */2]);
  var newrecord = evd.slice();
  newrecord[/* defn_evars */0] = match[0];
  newrecord[/* undf_evars */1] = match[1];
  newrecord[/* evar_names */2] = evar_names;
  newrecord[/* last_mods */5] = last_mods;
  return newrecord;
}

function is_restricted_evar(evi) {
  return Curry._2(Store[/* get */2], evi[/* evar_extra */6], restricted);
}

function restrict(evk, filter, candidates, src, evd) {
  var evk$prime = new_untyped_evar(/* () */0);
  var evar_info = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk, evd[/* undf_evars */1]);
  var evar_info$prime_000 = /* evar_concl */evar_info[/* evar_concl */0];
  var evar_info$prime_001 = /* evar_hyps */evar_info[/* evar_hyps */1];
  var evar_info$prime_002 = /* evar_body */evar_info[/* evar_body */2];
  var evar_info$prime_004 = /* evar_source */src ? src[0] : evar_info[/* evar_source */4];
  var evar_info$prime_006 = /* evar_extra */evar_info[/* evar_extra */6];
  var evar_info$prime = /* record */[
    evar_info$prime_000,
    evar_info$prime_001,
    evar_info$prime_002,
    /* evar_filter */filter,
    evar_info$prime_004,
    /* evar_candidates */candidates,
    evar_info$prime_006
  ];
  var match = evd[/* conv_pbs */4];
  var last_mods = match ? Curry._2(Evar$ReactTemplate.$$Set[/* add */3], evk, evd[/* last_mods */5]) : evd[/* last_mods */5];
  var evar_names = reassign_name_defined(evk, evk$prime, evd[/* evar_names */2]);
  var ctxt = filter_list(filter, Environ$ReactTemplate.named_context_of_val(evar_info[/* evar_hyps */1]));
  var partial_arg = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
  var id_inst = Util$ReactTemplate.$$Array[/* map_of_list */45]((function (param) {
          return Util$ReactTemplate.$percent$great(partial_arg, Constr$ReactTemplate.mkVar, param);
        }), ctxt);
  var body = Constr$ReactTemplate.mkEvar(/* tuple */[
        evk$prime,
        id_inst
      ]);
  var match$1 = define_aux(/* Some */[evk$prime], evd[/* defn_evars */0], evd[/* undf_evars */1], evk, body);
  var newrecord = evd.slice();
  return /* tuple */[
          (newrecord[/* defn_evars */0] = match$1[0], newrecord[/* undf_evars */1] = Curry._3(Evar$ReactTemplate.$$Map[/* add */3], evk$prime, evar_info$prime, match$1[1]), newrecord[/* evar_names */2] = evar_names, newrecord[/* last_mods */5] = last_mods, newrecord),
          evk$prime
        ];
}

function downcast(evk, ccl, evd) {
  var evar_info = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk, evd[/* undf_evars */1]);
  var newrecord = evar_info.slice();
  newrecord[/* evar_concl */0] = ccl;
  var newrecord$1 = evd.slice();
  newrecord$1[/* undf_evars */1] = Curry._3(Evar$ReactTemplate.$$Map[/* add */3], evk, newrecord, evd[/* undf_evars */1]);
  return newrecord$1;
}

function extract_conv_pbs(evd, p) {
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, pb) {
          var pbs1 = param[1];
          var pbs = param[0];
          if (Curry._1(p, pb)) {
            return /* tuple */[
                    /* :: */[
                      pb,
                      pbs
                    ],
                    pbs1
                  ];
          } else {
            return /* tuple */[
                    pbs,
                    /* :: */[
                      pb,
                      pbs1
                    ]
                  ];
          }
        }), /* tuple */[
        /* [] */0,
        /* [] */0
      ], evd[/* conv_pbs */4]);
  var newrecord = evd.slice();
  return /* tuple */[
          (newrecord[/* conv_pbs */4] = match[1], newrecord[/* last_mods */5] = Evar$ReactTemplate.$$Set[/* empty */0], newrecord),
          match[0]
        ];
}

function extract_changed_conv_pbs(evd, p) {
  return extract_conv_pbs(evd, (function (pb) {
                return Curry._2(p, evd[/* last_mods */5], pb);
              }));
}

function extract_all_conv_pbs(evd) {
  return extract_conv_pbs(evd, (function () {
                return /* true */1;
              }));
}

function loc_of_conv_pb(evd, param) {
  var match = Constr$ReactTemplate.kind(Constr$ReactTemplate.decompose_app(param[2])[0]);
  if (match.tag === 3) {
    return find(evd, match[0][0])[/* evar_source */4][0];
  } else {
    var match$1 = Constr$ReactTemplate.kind(Constr$ReactTemplate.decompose_app(param[3])[0]);
    if (match$1.tag === 3) {
      return find(evd, match$1[0][0])[/* evar_source */4][0];
    } else {
      return /* None */0;
    }
  }
}

function evars_of_term(c) {
  var evrec = function (acc, c) {
    var match = Constr$ReactTemplate.kind(c);
    if (match.tag === 3) {
      var match$1 = match[0];
      return Curry._2(Evar$ReactTemplate.$$Set[/* add */3], match$1[0], Util$ReactTemplate.$$Array[/* fold_left */15](evrec, acc, match$1[1]));
    } else {
      return Constr$ReactTemplate.fold(evrec, acc, c);
    }
  };
  return evrec(Evar$ReactTemplate.$$Set[/* empty */0], c);
}

function evars_of_named_context(nc) {
  return Context$ReactTemplate.Named[/* fold_outside */9](Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* fold_constr */15], (function (constr, s) {
                    return Curry._2(Evar$ReactTemplate.$$Set[/* union */6], s, evars_of_term(constr));
                  })), nc, Evar$ReactTemplate.$$Set[/* empty */0]);
}

function evars_of_filtered_evar_info(evi) {
  var match = evi[/* evar_body */2];
  return Curry._2(Evar$ReactTemplate.$$Set[/* union */6], evars_of_term(evi[/* evar_concl */0]), Curry._2(Evar$ReactTemplate.$$Set[/* union */6], match ? evars_of_term(match[0]) : Evar$ReactTemplate.$$Set[/* empty */0], evars_of_named_context(evar_filtered_context(evi))));
}

var univ_flexible = /* UnivFlexible */[/* false */0];

function evar_universe_context(d) {
  return d[/* universes */3];
}

function universe_context_set(d) {
  return UState$ReactTemplate.context_set(d[/* universes */3]);
}

function to_universe_context(evd) {
  return UState$ReactTemplate.context(evd[/* universes */3]);
}

function const_univ_entry(poly, evd) {
  return UState$ReactTemplate.const_univ_entry(poly, evd[/* universes */3]);
}

function ind_univ_entry(poly, evd) {
  return UState$ReactTemplate.ind_univ_entry(poly, evd[/* universes */3]);
}

function check_univ_decl(poly, evd, decl) {
  return UState$ReactTemplate.check_univ_decl(poly, evd[/* universes */3], decl);
}

function restrict_universe_context(evd, vars) {
  var newrecord = evd.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.restrict(evd[/* universes */3], vars);
  return newrecord;
}

function universe_subst(evd) {
  return UState$ReactTemplate.subst(evd[/* universes */3]);
}

function merge_context_set(loc, $staropt$star, rigid, evd, ctx$prime) {
  var sideff = $staropt$star ? $staropt$star[0] : /* false */0;
  var newrecord = evd.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.merge(loc, sideff, rigid, evd[/* universes */3], ctx$prime);
  return newrecord;
}

function merge_universe_subst(evd, subst) {
  var newrecord = evd.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.merge_subst(evd[/* universes */3], subst);
  return newrecord;
}

function with_context_set(loc, rigid, d, param) {
  return /* tuple */[
          merge_context_set(loc, /* None */0, rigid, d, param[1]),
          param[0]
        ];
}

function new_univ_level_variable(loc, name, rigid, evd) {
  var match = UState$ReactTemplate.new_univ_variable(loc, rigid, name, evd[/* universes */3]);
  var newrecord = evd.slice();
  return /* tuple */[
          (newrecord[/* universes */3] = match[0], newrecord),
          match[1]
        ];
}

function new_univ_variable(loc, name, rigid, evd) {
  var match = UState$ReactTemplate.new_univ_variable(loc, rigid, name, evd[/* universes */3]);
  var newrecord = evd.slice();
  return /* tuple */[
          (newrecord[/* universes */3] = match[0], newrecord),
          Univ$ReactTemplate.Universe[/* make */3](match[1])
        ];
}

function new_sort_variable(loc, name, rigid, d) {
  var match = new_univ_variable(loc, name, rigid, d);
  return /* tuple */[
          match[0],
          /* Type */Block.__(1, [match[1]])
        ];
}

function add_global_univ(d, u) {
  var newrecord = d.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.add_global_univ(d[/* universes */3], u);
  return newrecord;
}

function make_flexible_variable(evd, algebraic, u) {
  var newrecord = evd.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.make_flexible_variable(evd[/* universes */3], algebraic, u);
  return newrecord;
}

function fresh_sort_in_family(loc, $staropt$star, env, evd, s) {
  var rigid = $staropt$star ? $staropt$star[0] : univ_flexible;
  return with_context_set(loc, rigid, evd, Universes$ReactTemplate.fresh_sort_in_family(env, s));
}

function fresh_constant_instance(loc, env, evd, c) {
  return with_context_set(loc, univ_flexible, evd, Universes$ReactTemplate.fresh_constant_instance(env, c));
}

function fresh_inductive_instance(loc, env, evd, i) {
  return with_context_set(loc, univ_flexible, evd, Universes$ReactTemplate.fresh_inductive_instance(env, i));
}

function fresh_constructor_instance(loc, env, evd, c) {
  return with_context_set(loc, univ_flexible, evd, Universes$ReactTemplate.fresh_constructor_instance(env, c));
}

function fresh_global(loc, $staropt$star, names, env, evd, gr) {
  var rigid = $staropt$star ? $staropt$star[0] : univ_flexible;
  return with_context_set(loc, rigid, evd, Universes$ReactTemplate.fresh_global_instance(names, env, gr));
}

function whd_sort_variable(_, t) {
  return t;
}

function is_sort_variable(evd, s) {
  return UState$ReactTemplate.is_sort_variable(evd[/* universes */3], s);
}

function is_flexible_level(evd, l) {
  var uctx = evd[/* universes */3];
  return Curry._2(Univ$ReactTemplate.LMap[/* mem */2], l, UState$ReactTemplate.subst(uctx));
}

function is_eq_sort(s1, s2) {
  if (Sorts$ReactTemplate.equal(s1, s2)) {
    return /* None */0;
  } else {
    var u1 = Sorts$ReactTemplate.univ_of_sort(s1);
    var u2 = Sorts$ReactTemplate.univ_of_sort(s2);
    if (Univ$ReactTemplate.Universe[/* equal */1](u1, u2)) {
      return /* None */0;
    } else {
      return /* Some */[/* tuple */[
                u1,
                u2
              ]];
    }
  }
}

function universe_rigidity(evd, l) {
  var uctx = evd[/* universes */3];
  if (Curry._2(Univ$ReactTemplate.LSet[/* mem */2], l, Univ$ReactTemplate.ContextSet[/* levels */16](UState$ReactTemplate.context_set(uctx)))) {
    return /* UnivFlexible */[Curry._2(Univ$ReactTemplate.LSet[/* mem */2], l, UState$ReactTemplate.algebraics(uctx))];
  } else {
    return /* UnivRigid */0;
  }
}

function normalize_universe(evd) {
  return Universes$ReactTemplate.normalize_universe_opt_subst([UState$ReactTemplate.subst(evd[/* universes */3])]);
}

function normalize_universe_instance(evd, l) {
  var vars = [UState$ReactTemplate.subst(evd[/* universes */3])];
  var partial_arg = Universes$ReactTemplate.normalize_univ_variable_opt_subst(vars);
  var normalize = function (param) {
    return Universes$ReactTemplate.level_subst_of(partial_arg, param);
  };
  return Univ$ReactTemplate.Instance[/* subst_fn */10](normalize, l);
}

function normalize_sort(evars, s) {
  if (s.tag) {
    var u = s[0];
    var u$prime = normalize_universe(evars)(u);
    if (u$prime === u) {
      return s;
    } else {
      return /* Type */Block.__(1, [u$prime]);
    }
  } else {
    return s;
  }
}

function set_eq_sort(env, d, s1, s2) {
  var s1$1 = normalize_sort(d, s1);
  var s2$1 = normalize_sort(d, s2);
  var match = is_eq_sort(s1$1, s2$1);
  if (match) {
    var match$1 = match[0];
    if (Environ$ReactTemplate.type_in_type(env)) {
      return d;
    } else {
      return add_universe_constraints(d, Curry._1(Universes$ReactTemplate.Constraints[/* singleton */4], /* UEq */Block.__(1, [
                        match$1[0],
                        match$1[1]
                      ])));
    }
  } else {
    return d;
  }
}

function set_eq_level(d, u1, u2) {
  return add_constraints(d, Univ$ReactTemplate.enforce_eq_level(u1, u2, Univ$ReactTemplate.Constraint[/* empty */0]));
}

function set_leq_level(d, u1, u2) {
  return add_constraints(d, Univ$ReactTemplate.enforce_leq_level(u1, u2, Univ$ReactTemplate.Constraint[/* empty */0]));
}

function set_eq_instances($staropt$star, d, u1, u2) {
  var flex = $staropt$star ? $staropt$star[0] : /* false */0;
  return add_universe_constraints(d, Universes$ReactTemplate.enforce_eq_instances_univs(flex, u1, u2, Universes$ReactTemplate.Constraints[/* empty */0]));
}

function set_leq_sort(env, evd, s1, s2) {
  var s1$1 = normalize_sort(evd, s1);
  var s2$1 = normalize_sort(evd, s2);
  var match = is_eq_sort(s1$1, s2$1);
  if (match) {
    var match$1 = match[0];
    if (Environ$ReactTemplate.type_in_type(env)) {
      return evd;
    } else {
      return add_universe_constraints(evd, Curry._1(Universes$ReactTemplate.Constraints[/* singleton */4], /* ULe */Block.__(0, [
                        match$1[0],
                        match$1[1]
                      ])));
    }
  } else {
    return evd;
  }
}

function check_eq(evd, s, s$prime) {
  return UGraph$ReactTemplate.check_eq(UState$ReactTemplate.ugraph(evd[/* universes */3]), s, s$prime);
}

function check_leq(evd, s, s$prime) {
  return UGraph$ReactTemplate.check_leq(UState$ReactTemplate.ugraph(evd[/* universes */3]), s, s$prime);
}

function fix_undefined_variables(evd) {
  var newrecord = evd.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.fix_undefined_variables(evd[/* universes */3]);
  return newrecord;
}

function refresh_undefined_universes(evd) {
  var match = UState$ReactTemplate.refresh_undefined_univ_variables(evd[/* universes */3]);
  var subst = match[1];
  var newrecord = evd.slice();
  var evd$prime = cmap((function (param) {
          return Vars$ReactTemplate.subst_univs_level_constr(subst, param);
        }), (newrecord[/* universes */3] = match[0], newrecord));
  return /* tuple */[
          evd$prime,
          subst
        ];
}

function nf_univ_variables(evd) {
  var match = UState$ReactTemplate.normalize_variables(evd[/* universes */3]);
  var newrecord = evd.slice();
  newrecord[/* universes */3] = match[1];
  return /* tuple */[
          newrecord,
          match[0]
        ];
}

function minimize_universes(evd) {
  var match = UState$ReactTemplate.normalize_variables(evd[/* universes */3]);
  var uctx$prime = UState$ReactTemplate.minimize(match[1]);
  var newrecord = evd.slice();
  newrecord[/* universes */3] = uctx$prime;
  return newrecord;
}

function universe_of_name(evd, s) {
  return UState$ReactTemplate.universe_of_name(evd[/* universes */3], s);
}

function universe_binders(evd) {
  return UState$ReactTemplate.universe_binders(evd[/* universes */3]);
}

function universes(evd) {
  return UState$ReactTemplate.ugraph(evd[/* universes */3]);
}

function update_sigma_env(evd, env) {
  var newrecord = evd.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.update_sigma_env(evd[/* universes */3], env);
  return newrecord;
}

function emit_side_effects(eff, evd) {
  var newrecord = evd.slice();
  newrecord[/* universes */3] = UState$ReactTemplate.emit_side_effects(eff, evd[/* universes */3]);
  newrecord[/* effects */7] = Safe_typing$ReactTemplate.concat_private(eff, evd[/* effects */7]);
  return newrecord;
}

function drop_side_effects(evd) {
  var newrecord = evd.slice();
  newrecord[/* effects */7] = Safe_typing$ReactTemplate.empty_private_constants;
  return newrecord;
}

function eval_side_effects(evd) {
  return evd[/* effects */7];
}

function declare_future_goal(tag, evk, evd) {
  var newrecord = evd.slice();
  newrecord[/* future_goals */8] = /* :: */[
    evk,
    evd[/* future_goals */8]
  ];
  newrecord[/* future_goals_status */10] = Option$ReactTemplate.fold_right(Curry._1(Evar$ReactTemplate.$$Map[/* add */3], evk), tag, evd[/* future_goals_status */10]);
  return newrecord;
}

function declare_principal_goal(tag, evk, evd) {
  var match = evd[/* principal_future_goal */9];
  if (match) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Only one main subgoal per instantiation."));
  } else {
    var newrecord = evd.slice();
    newrecord[/* future_goals */8] = /* :: */[
      evk,
      evd[/* future_goals */8]
    ];
    newrecord[/* principal_future_goal */9] = /* Some */[evk];
    newrecord[/* future_goals_status */10] = Option$ReactTemplate.fold_right(Curry._1(Evar$ReactTemplate.$$Map[/* add */3], evk), tag, evd[/* future_goals_status */10]);
    return newrecord;
  }
}

function future_goals(evd) {
  return evd[/* future_goals */8];
}

function principal_future_goal(evd) {
  return evd[/* principal_future_goal */9];
}

function save_future_goals(evd) {
  return /* tuple */[
          evd[/* future_goals */8],
          evd[/* principal_future_goal */9],
          evd[/* future_goals_status */10]
        ];
}

function reset_future_goals(evd) {
  var newrecord = evd.slice();
  newrecord[/* future_goals */8] = /* [] */0;
  newrecord[/* principal_future_goal */9] = /* None */0;
  newrecord[/* future_goals_status */10] = Evar$ReactTemplate.$$Map[/* empty */0];
  return newrecord;
}

function restore_future_goals(evd, param) {
  var newrecord = evd.slice();
  newrecord[/* future_goals */8] = param[0];
  newrecord[/* principal_future_goal */9] = param[1];
  newrecord[/* future_goals_status */10] = param[2];
  return newrecord;
}

function fold_future_goals(f, sigma, param) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], f, sigma, param[0]);
}

function map_filter_future_goals(f, param) {
  return /* tuple */[
          Curry._2(Util$ReactTemplate.List[/* map_filter */62], f, param[0]),
          Option$ReactTemplate.bind(param[1], f),
          param[2]
        ];
}

function filter_future_goals(f, param) {
  return /* tuple */[
          Curry._2(Util$ReactTemplate.List[/* filter */27], f, param[0]),
          Option$ReactTemplate.bind(param[1], (function (a) {
                  if (Curry._1(f, a)) {
                    return /* Some */[a];
                  } else {
                    return /* None */0;
                  }
                })),
          param[2]
        ];
}

function dispatch_future_goals_gen(distinguish_shelf, param) {
  var map = param[2];
  var aux = function (_acc, _param) {
    while(true) {
      var param = _param;
      var acc = _acc;
      if (param) {
        var evk = param[0];
        var givenup = acc[2];
        var shelf = acc[1];
        var comb = acc[0];
        var acc$1;
        try {
          var match = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk, map);
          if (match !== 0) {
            acc$1 = /* tuple */[
              comb,
              shelf,
              /* :: */[
                evk,
                givenup
              ]
            ];
          } else if (distinguish_shelf) {
            acc$1 = /* tuple */[
              comb,
              /* :: */[
                evk,
                shelf
              ],
              givenup
            ];
          } else {
            throw Caml_builtin_exceptions.not_found;
          }
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            acc$1 = /* tuple */[
              /* :: */[
                evk,
                comb
              ],
              shelf,
              givenup
            ];
          } else {
            throw exn;
          }
        }
        _param = param[1];
        _acc = acc$1;
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  var match = aux(/* tuple */[
        /* [] */0,
        /* [] */0,
        /* [] */0
      ], param[0]);
  return /* tuple */[
          match[0],
          match[1],
          match[2],
          param[1]
        ];
}

function dispatch_future_goals(param) {
  return dispatch_future_goals_gen(/* true */1, param);
}

function extract_given_up_future_goals(goals) {
  var match = dispatch_future_goals_gen(/* false */0, goals);
  return /* tuple */[
          match[0],
          match[2]
        ];
}

function shelve_on_future_goals(shelved, param) {
  return /* tuple */[
          Util$ReactTemplate.$at(shelved, param[0]),
          param[1],
          Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (evk) {
                  return Curry._2(Evar$ReactTemplate.$$Map[/* add */3], evk, /* ToShelve */0);
                }), shelved, param[2])
        ];
}

function set_metas(evd, metas) {
  return /* record */[
          /* defn_evars */evd[/* defn_evars */0],
          /* undf_evars */evd[/* undf_evars */1],
          /* evar_names */evd[/* evar_names */2],
          /* universes */evd[/* universes */3],
          /* conv_pbs */evd[/* conv_pbs */4],
          /* last_mods */evd[/* last_mods */5],
          /* metas */metas,
          /* effects */evd[/* effects */7],
          /* future_goals */evd[/* future_goals */8],
          /* principal_future_goal */evd[/* principal_future_goal */9],
          /* future_goals_status */evd[/* future_goals_status */10],
          /* extras */evd[/* extras */11]
        ];
}

function meta_list(evd) {
  var m = evd[/* metas */6];
  return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], (function (n, v, l) {
                return /* :: */[
                        /* tuple */[
                          n,
                          v
                        ],
                        l
                      ];
              }), m, /* [] */0);
}

function undefined_metas(evd) {
  var filter = function (param) {
    if (param[1].tag) {
      return /* None */0;
    } else {
      return /* Some */[param[0]];
    }
  };
  var m = Curry._2(Util$ReactTemplate.List[/* map_filter */62], filter, meta_list(evd));
  return Curry._2(Util$ReactTemplate.List[/* sort */38], Caml_primitive.caml_int_compare, m);
}

function map_metas_fvalue(f, evd) {
  var map = function (x) {
    if (x.tag) {
      var match = x[1];
      var c = Curry._1(f, match[0][/* rebus */0]);
      return /* Clval */Block.__(1, [
                x[0],
                /* tuple */[
                  /* record */[
                    /* rebus */c,
                    /* freemetas */metavars_of(c)
                  ],
                  match[1]
                ],
                x[2]
              ]);
    } else {
      return x;
    }
  };
  return set_metas(evd, Curry._2(Int$ReactTemplate.$$Map[/* smartmap */31], map, evd[/* metas */6]));
}

function map_metas(f, evd) {
  var map = function (cl) {
    return map_clb(f, cl);
  };
  return set_metas(evd, Curry._2(Int$ReactTemplate.$$Map[/* smartmap */31], map, evd[/* metas */6]));
}

function meta_opt_fvalue(evd, mv) {
  var match = Int$ReactTemplate.$$Map[/* find */21](mv, evd[/* metas */6]);
  if (match.tag) {
    return /* Some */[match[1]];
  } else {
    return /* None */0;
  }
}

function meta_defined(evd, mv) {
  var match = Int$ReactTemplate.$$Map[/* find */21](mv, evd[/* metas */6]);
  if (match.tag) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function try_meta_fvalue(evd, mv) {
  var match = Int$ReactTemplate.$$Map[/* find */21](mv, evd[/* metas */6]);
  if (match.tag) {
    return match[1];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function meta_fvalue(evd, mv) {
  try {
    return try_meta_fvalue(evd, mv);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["meta_fvalue"], Pp$ReactTemplate.str("meta has no value."));
    } else {
      throw exn;
    }
  }
}

function meta_value(evd, mv) {
  return try_meta_fvalue(evd, mv)[0][/* rebus */0];
}

function meta_ftype(evd, mv) {
  var match = Int$ReactTemplate.$$Map[/* find */21](mv, evd[/* metas */6]);
  if (match.tag) {
    return match[2];
  } else {
    return match[1];
  }
}

function meta_type(evd, mv) {
  return meta_ftype(evd, mv)[/* rebus */0];
}

function meta_declare(mv, v, $staropt$star, evd) {
  var name = $staropt$star ? $staropt$star[0] : /* Anonymous */0;
  var metas = Curry._3(Int$ReactTemplate.$$Map[/* add */3], mv, /* Cltyp */Block.__(0, [
          name,
          /* record */[
            /* rebus */v,
            /* freemetas */metavars_of(v)
          ]
        ]), evd[/* metas */6]);
  return set_metas(evd, metas);
}

function meta_assign(mv, param, evd) {
  var pb = param[1];
  var v = param[0];
  var modify = function (_, param) {
    if (param.tag) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["meta_assign"], Pp$ReactTemplate.str("already defined."));
    } else {
      return /* Clval */Block.__(1, [
                param[0],
                /* tuple */[
                  /* record */[
                    /* rebus */v,
                    /* freemetas */metavars_of(v)
                  ],
                  pb
                ],
                param[1]
              ]);
    }
  };
  var metas = Curry._3(Int$ReactTemplate.$$Map[/* modify */26], mv, modify, evd[/* metas */6]);
  return set_metas(evd, metas);
}

function meta_reassign(mv, param, evd) {
  var pb = param[1];
  var v = param[0];
  var modify = function (_, param) {
    if (param.tag) {
      return /* Clval */Block.__(1, [
                param[0],
                /* tuple */[
                  /* record */[
                    /* rebus */v,
                    /* freemetas */metavars_of(v)
                  ],
                  pb
                ],
                param[2]
              ]);
    } else {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["meta_reassign"], Pp$ReactTemplate.str("not yet defined."));
    }
  };
  var metas = Curry._3(Int$ReactTemplate.$$Map[/* modify */26], mv, modify, evd[/* metas */6]);
  return set_metas(evd, metas);
}

function meta_name(evd, mv) {
  try {
    return clb_name(Int$ReactTemplate.$$Map[/* find */21](mv, evd[/* metas */6]))[0];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* Anonymous */0;
    } else {
      throw exn;
    }
  }
}

function clear_metas(evd) {
  var newrecord = evd.slice();
  newrecord[/* metas */6] = Int$ReactTemplate.$$Map[/* empty */0];
  return newrecord;
}

function meta_merge($staropt$star, evd1, evd2) {
  var with_univs = $staropt$star ? $staropt$star[0] : /* true */1;
  var metas = Curry._3(Int$ReactTemplate.$$Map[/* fold */10], Int$ReactTemplate.$$Map[/* add */3], evd1[/* metas */6], evd2[/* metas */6]);
  var universes = with_univs ? UState$ReactTemplate.union(evd2[/* universes */3], evd1[/* universes */3]) : evd2[/* universes */3];
  var newrecord = evd2.slice();
  newrecord[/* universes */3] = universes;
  newrecord[/* metas */6] = metas;
  return newrecord;
}

function retract_coercible_metas(evd) {
  var mc = [/* [] */0];
  var map = function (n, v) {
    if (v.tag) {
      var match = v[1];
      var s = match[1];
      if (s[0] >= 2 && s[1] === 0) {
        mc[0] = /* :: */[
          /* tuple */[
            n,
            match[0][/* rebus */0],
            s
          ],
          mc[0]
        ];
        return /* Cltyp */Block.__(0, [
                  v[0],
                  v[2]
                ]);
      } else {
        return v;
      }
    } else {
      return v;
    }
  };
  var metas = Curry._2(Int$ReactTemplate.$$Map[/* smartmapi */32], map, evd[/* metas */6]);
  return /* tuple */[
          mc[0],
          set_metas(evd, metas)
        ];
}

function evar_source_of_meta(mv, evd) {
  var match = meta_name(evd, mv);
  if (match) {
    var eta = /* VarInstance */Block.__(7, [match[0]]);
    return Loc$ReactTemplate.tag(/* None */0, eta);
  } else {
    return Loc$ReactTemplate.tag(/* None */0, /* GoalEvar */1);
  }
}

function dependent_evar_ident(ev, evd) {
  var evi = find(evd, ev);
  var match = evi[/* evar_source */4];
  var match$1 = match[1];
  if (typeof match$1 === "number" || match$1.tag !== 7) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not an evar resulting of a dependent binding."));
  } else {
    return match$1[0];
  }
}

function get_extra_data(evd) {
  return evd[/* extras */11];
}

function set_extra_data(extras, evd) {
  var newrecord = evd.slice();
  newrecord[/* extras */11] = extras;
  return newrecord;
}

function sig_it(x) {
  return x[/* it */0];
}

function sig_sig(x) {
  return x[/* sigma */1];
}

function on_sig(s, f) {
  var match = Curry._1(f, s[/* sigma */1]);
  return /* tuple */[
          /* record */[
            /* it */s[/* it */0],
            /* sigma */match[0]
          ],
          match[1]
        ];
}

function $$return(a, s) {
  return /* tuple */[
          s,
          a
        ];
}

function $great$great$eq(x, f, s) {
  var match = Curry._1(x, s);
  return Curry._2(f, match[1], match[0]);
}

function $great$great(x, y, s) {
  var match = Curry._1(x, s);
  return Curry._1(y, match[0]);
}

function map(f, x, s) {
  return Util$ReactTemplate.on_snd(f, Curry._1(x, s));
}

var MonadR = Monad$ReactTemplate.Make(/* module */[
      /* return */$$return,
      /* >>= */$great$great$eq,
      /* >> */$great$great,
      /* map */map
    ]);

function $$return$1(a, s) {
  return /* tuple */[
          a,
          s
        ];
}

function $great$great$eq$1(x, f, s) {
  var match = Curry._1(x, s);
  return Curry._2(f, match[0], match[1]);
}

function $great$great$1(x, y, s) {
  var match = Curry._1(x, s);
  return Curry._1(y, match[1]);
}

function map$1(f, x, s) {
  return Util$ReactTemplate.on_fst(f, Curry._1(x, s));
}

var Monad = Monad$ReactTemplate.Make(/* module */[
      /* return */$$return$1,
      /* >>= */$great$great$eq$1,
      /* >> */$great$great$1,
      /* map */map$1
    ]);

function make_evar_universe_context(e, l) {
  var g = Environ$ReactTemplate.universes(e);
  if (l) {
    return UState$ReactTemplate.make_with_initial_binders(g, l[0]);
  } else {
    return UState$ReactTemplate.make(g);
  }
}

var is_evar = mem;

var UniversesDiffer = UState$ReactTemplate.UniversesDiffer;

var Metaset = Int$ReactTemplate.$$Set;

var Metamap = Int$ReactTemplate.$$Map;

var univ_rigid = /* UnivRigid */0;

var univ_flexible_alg = /* UnivFlexible */[/* true */1];

var evar_universe_context_set = UState$ReactTemplate.context_set;

var evar_universe_context_constraints = UState$ReactTemplate.constraints;

var evar_context_universe_context = UState$ReactTemplate.context;

var evar_universe_context_of = UState$ReactTemplate.of_context_set;

var empty_evar_universe_context = UState$ReactTemplate.empty;

var union_evar_universe_context = UState$ReactTemplate.union;

var evar_universe_context_subst = UState$ReactTemplate.subst;

var constrain_variables = UState$ReactTemplate.constrain_variables;

var evar_universe_context_of_binders = UState$ReactTemplate.of_binders;

var add_constraints_context = UState$ReactTemplate.add_constraints;

var normalize_evar_universe_context_variables = UState$ReactTemplate.normalize_variables;

var normalize_evar_universe_context = UState$ReactTemplate.minimize;

var abstract_undefined_variables = UState$ReactTemplate.abstract_undefined_variables;

var nf_constraints = minimize_universes;

var evar_counter_summary_tag = match[1];

exports.string_of_existential = string_of_existential;
exports.Filter = Filter;
exports.Store = Store;
exports.make_evar = make_evar;
exports.evar_concl = evar_concl;
exports.evar_context = evar_context;
exports.evar_filtered_context = evar_filtered_context;
exports.evar_hyps = evar_hyps;
exports.evar_filtered_hyps = evar_filtered_hyps;
exports.evar_body = evar_body;
exports.evar_filter = evar_filter;
exports.evar_env = evar_env;
exports.evar_filtered_env = evar_filtered_env;
exports.map_evar_body = map_evar_body;
exports.map_evar_info = map_evar_info;
exports.empty = empty$1;
exports.from_env = from_env;
exports.from_ctx = from_ctx;
exports.is_empty = is_empty;
exports.has_undefined = has_undefined;
exports.new_evar = new_evar;
exports.add = add;
exports.find = find;
exports.find_undefined = find_undefined;
exports.remove = remove;
exports.mem = mem;
exports.fold = fold;
exports.fold_undefined = fold_undefined;
exports.raw_map = raw_map;
exports.raw_map_undefined = raw_map_undefined;
exports.define = define;
exports.cmap = cmap;
exports.is_evar = is_evar;
exports.is_defined = is_defined;
exports.is_undefined = is_undefined;
exports.add_constraints = add_constraints;
exports.undefined_map = undefined_map;
exports.drop_all_defined = drop_all_defined;
exports.NotInstantiatedEvar = NotInstantiatedEvar;
exports.existential_value = existential_value;
exports.existential_type = existential_type;
exports.existential_opt_value = existential_opt_value;
exports.evar_instance_array = evar_instance_array;
exports.instantiate_evar_array = instantiate_evar_array;
exports.evars_reset_evd = evars_reset_evd;
exports.restrict = restrict;
exports.is_restricted_evar = is_restricted_evar;
exports.downcast = downcast;
exports.evar_source = evar_source;
exports.evar_ident = evar_ident;
exports.rename = rename$1;
exports.evar_key = evar_key;
exports.evar_source_of_meta = evar_source_of_meta;
exports.dependent_evar_ident = dependent_evar_ident;
exports.emit_side_effects = emit_side_effects;
exports.eval_side_effects = eval_side_effects;
exports.drop_side_effects = drop_side_effects;
exports.declare_future_goal = declare_future_goal;
exports.declare_principal_goal = declare_principal_goal;
exports.future_goals = future_goals;
exports.principal_future_goal = principal_future_goal;
exports.save_future_goals = save_future_goals;
exports.reset_future_goals = reset_future_goals;
exports.restore_future_goals = restore_future_goals;
exports.fold_future_goals = fold_future_goals;
exports.map_filter_future_goals = map_filter_future_goals;
exports.filter_future_goals = filter_future_goals;
exports.dispatch_future_goals = dispatch_future_goals;
exports.extract_given_up_future_goals = extract_given_up_future_goals;
exports.shelve_on_future_goals = shelve_on_future_goals;
exports.whd_sort_variable = whd_sort_variable;
exports.UniversesDiffer = UniversesDiffer;
exports.add_universe_constraints = add_universe_constraints;
exports.get_extra_data = get_extra_data;
exports.set_extra_data = set_extra_data;
exports.sig_it = sig_it;
exports.sig_sig = sig_sig;
exports.on_sig = on_sig;
exports.MonadR = MonadR;
exports.Monad = Monad;
exports.Metaset = Metaset;
exports.Metamap = Metamap;
exports.metavars_of = metavars_of;
exports.mk_freelisted = mk_freelisted;
exports.map_fl = map_fl;
exports.eq_instance_constraint = eq_instance_constraint;
exports.add_conv_pb = add_conv_pb;
exports.extract_changed_conv_pbs = extract_changed_conv_pbs;
exports.extract_all_conv_pbs = extract_all_conv_pbs;
exports.loc_of_conv_pb = loc_of_conv_pb;
exports.evars_of_term = evars_of_term;
exports.evars_of_named_context = evars_of_named_context;
exports.evars_of_filtered_evar_info = evars_of_filtered_evar_info;
exports.meta_list = meta_list;
exports.meta_defined = meta_defined;
exports.meta_value = meta_value;
exports.meta_fvalue = meta_fvalue;
exports.meta_opt_fvalue = meta_opt_fvalue;
exports.meta_type = meta_type;
exports.meta_ftype = meta_ftype;
exports.meta_name = meta_name;
exports.meta_declare = meta_declare;
exports.meta_assign = meta_assign;
exports.meta_reassign = meta_reassign;
exports.clear_metas = clear_metas;
exports.meta_merge = meta_merge;
exports.undefined_metas = undefined_metas;
exports.map_metas_fvalue = map_metas_fvalue;
exports.map_metas = map_metas;
exports.retract_coercible_metas = retract_coercible_metas;
exports.univ_rigid = univ_rigid;
exports.univ_flexible = univ_flexible;
exports.univ_flexible_alg = univ_flexible_alg;
exports.evar_universe_context_set = evar_universe_context_set;
exports.evar_universe_context_constraints = evar_universe_context_constraints;
exports.evar_context_universe_context = evar_context_universe_context;
exports.evar_universe_context_of = evar_universe_context_of;
exports.empty_evar_universe_context = empty_evar_universe_context;
exports.union_evar_universe_context = union_evar_universe_context;
exports.evar_universe_context_subst = evar_universe_context_subst;
exports.constrain_variables = constrain_variables;
exports.evar_universe_context_of_binders = evar_universe_context_of_binders;
exports.make_evar_universe_context = make_evar_universe_context;
exports.restrict_universe_context = restrict_universe_context;
exports.universe_of_name = universe_of_name;
exports.universe_binders = universe_binders;
exports.add_constraints_context = add_constraints_context;
exports.normalize_evar_universe_context_variables = normalize_evar_universe_context_variables;
exports.normalize_evar_universe_context = normalize_evar_universe_context;
exports.new_univ_level_variable = new_univ_level_variable;
exports.new_univ_variable = new_univ_variable;
exports.new_sort_variable = new_sort_variable;
exports.add_global_univ = add_global_univ;
exports.universe_rigidity = universe_rigidity;
exports.make_flexible_variable = make_flexible_variable;
exports.is_sort_variable = is_sort_variable;
exports.is_flexible_level = is_flexible_level;
exports.normalize_universe = normalize_universe;
exports.normalize_universe_instance = normalize_universe_instance;
exports.set_leq_sort = set_leq_sort;
exports.set_eq_sort = set_eq_sort;
exports.set_eq_level = set_eq_level;
exports.set_leq_level = set_leq_level;
exports.set_eq_instances = set_eq_instances;
exports.check_eq = check_eq;
exports.check_leq = check_leq;
exports.evar_universe_context = evar_universe_context;
exports.universe_context_set = universe_context_set;
exports.universe_subst = universe_subst;
exports.universes = universes;
exports.to_universe_context = to_universe_context;
exports.const_univ_entry = const_univ_entry;
exports.ind_univ_entry = ind_univ_entry;
exports.check_univ_decl = check_univ_decl;
exports.merge_universe_context = merge_universe_context;
exports.set_universe_context = set_universe_context;
exports.merge_context_set = merge_context_set;
exports.merge_universe_subst = merge_universe_subst;
exports.with_context_set = with_context_set;
exports.nf_univ_variables = nf_univ_variables;
exports.abstract_undefined_variables = abstract_undefined_variables;
exports.fix_undefined_variables = fix_undefined_variables;
exports.refresh_undefined_universes = refresh_undefined_universes;
exports.minimize_universes = minimize_universes;
exports.nf_constraints = nf_constraints;
exports.update_sigma_env = update_sigma_env;
exports.fresh_sort_in_family = fresh_sort_in_family;
exports.fresh_constant_instance = fresh_constant_instance;
exports.fresh_inductive_instance = fresh_inductive_instance;
exports.fresh_constructor_instance = fresh_constructor_instance;
exports.fresh_global = fresh_global;
exports.evar_counter_summary_tag = evar_counter_summary_tag;
exports.create_evar_defs = create_evar_defs;
/* Store Not a pure module */
