// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Dag$ReactTemplate = require("./dag.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var CString$ReactTemplate = require("./cString.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function Make(funarg) {
  var Dag = Dag$ReactTemplate.Make(funarg);
  var bid = [0];
  var make = function (s) {
    bid[0] = bid[0] + 1 | 0;
    return Pervasives.string_of_int(bid[0]) + ("_" + s);
  };
  var equal = function (prim, prim$1) {
    return +(prim === prim$1);
  };
  var to_string = function (s) {
    return s;
  };
  var master = "master";
  var Branch = /* module */[
    /* make */make,
    /* equal */equal,
    /* compare */CString$ReactTemplate.compare,
    /* to_string */to_string,
    /* master */master
  ];
  var BranchMap = $$Map.Make([CString$ReactTemplate.compare]);
  var empty = function (root) {
    return /* record */[
            /* cur_branch */master,
            /* heads */Curry._2(BranchMap[/* singleton */4], master, /* record */[
                  /* kind : Master */-273353534,
                  /* root */root,
                  /* pos */root
                ]),
            /* dag */Dag[/* empty */1]
          ];
  };
  var add_node = function (vcs, id, edges) {
    if (CList$ReactTemplate.is_empty(edges)) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "vcs.ml",
              112,
              2
            ]
          ];
    }
    return /* record */[
            /* cur_branch */vcs[/* cur_branch */0],
            /* heads */vcs[/* heads */1],
            /* dag */List.fold_left((function (g, param) {
                    return Curry._4(Dag[/* add_edge */2], g, id, param[0], param[1]);
                  }), vcs[/* dag */2], edges)
          ];
  };
  var get_branch = function (vcs, head) {
    try {
      return Curry._2(BranchMap[/* find */21], head, vcs[/* heads */1]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("head "), Pp$ReactTemplate.str(head)), Pp$ReactTemplate.str(" not found.")));
      } else {
        throw exn;
      }
    }
  };
  var reset_branch = function (vcs, head, id) {
    var map = function (name, h) {
      if (name === head) {
        return /* record */[
                /* kind */h[/* kind */0],
                /* root */h[/* root */1],
                /* pos */id
              ];
      } else {
        return h;
      }
    };
    return /* record */[
            /* cur_branch */vcs[/* cur_branch */0],
            /* heads */Curry._2(BranchMap[/* mapi */23], map, vcs[/* heads */1]),
            /* dag */vcs[/* dag */2]
          ];
  };
  var current_branch = function (vcs) {
    return vcs[/* cur_branch */0];
  };
  var branch = function (vcs, $staropt$star, $staropt$star$1, name, kind) {
    var root = $staropt$star ? $staropt$star[0] : get_branch(vcs, vcs[/* cur_branch */0])[/* pos */2];
    var pos = $staropt$star$1 ? $staropt$star$1[0] : root;
    return /* record */[
            /* cur_branch */name,
            /* heads */Curry._3(BranchMap[/* add */3], name, /* record */[
                  /* kind */kind,
                  /* root */root,
                  /* pos */pos
                ], vcs[/* heads */1]),
            /* dag */vcs[/* dag */2]
          ];
  };
  var delete_branch = function (vcs, name) {
    if (master === name) {
      return vcs;
    } else {
      var filter = function (n, _) {
        return +(n !== name);
      };
      return /* record */[
              /* cur_branch */vcs[/* cur_branch */0],
              /* heads */Curry._2(BranchMap[/* filter */13], filter, vcs[/* heads */1]),
              /* dag */vcs[/* dag */2]
            ];
    }
  };
  var merge = function (vcs, id, tr1, tr2, $staropt$star, name) {
    var into = $staropt$star ? $staropt$star[0] : vcs[/* cur_branch */0];
    if (name === into) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "vcs.ml",
              141,
              2
            ]
          ];
    }
    var br_id = get_branch(vcs, name)[/* pos */2];
    var cur_id = get_branch(vcs, into)[/* pos */2];
    var vcs$1 = add_node(vcs, id, /* :: */[
          /* tuple */[
            tr1,
            cur_id
          ],
          /* :: */[
            /* tuple */[
              tr2,
              br_id
            ],
            /* [] */0
          ]
        ]);
    return reset_branch(vcs$1, into, id);
  };
  var rewrite_merge = function (vcs, id, tr1, tr2, cur_id, name) {
    var br_id = get_branch(vcs, name)[/* pos */2];
    var old_edges = List.map((function (prim) {
            return prim[0];
          }), Curry._2(Dag[/* from_node */3], vcs[/* dag */2], id));
    var vcs$1 = List.fold_left((function (param, param$1) {
            var id$1 = id;
            var vcs = param;
            var tgt = param$1;
            return /* record */[
                    /* cur_branch */vcs[/* cur_branch */0],
                    /* heads */vcs[/* heads */1],
                    /* dag */Curry._3(Dag[/* del_edge */5], vcs[/* dag */2], id$1, tgt)
                  ];
          }), vcs, old_edges);
    return add_node(vcs$1, id, /* :: */[
                /* tuple */[
                  tr1,
                  cur_id
                ],
                /* :: */[
                  /* tuple */[
                    tr2,
                    br_id
                  ],
                  /* [] */0
                ]
              ]);
  };
  var commit = function (vcs, id, tr) {
    var vcs$1 = add_node(vcs, id, /* :: */[
          /* tuple */[
            tr,
            get_branch(vcs, vcs[/* cur_branch */0])[/* pos */2]
          ],
          /* [] */0
        ]);
    return reset_branch(vcs$1, vcs$1[/* cur_branch */0], id);
  };
  var checkout = function (vcs, name) {
    return /* record */[
            /* cur_branch */name,
            /* heads */vcs[/* heads */1],
            /* dag */vcs[/* dag */2]
          ];
  };
  var set_info = function (vcs, id, info) {
    return /* record */[
            /* cur_branch */vcs[/* cur_branch */0],
            /* heads */vcs[/* heads */1],
            /* dag */Curry._3(Dag[/* set_info */9], vcs[/* dag */2], id, info)
          ];
  };
  var get_info = function (vcs, id) {
    return Curry._2(Dag[/* get_info */8], vcs[/* dag */2], id);
  };
  var create_property = function (vcs, l, i) {
    return /* record */[
            /* cur_branch */vcs[/* cur_branch */0],
            /* heads */vcs[/* heads */1],
            /* dag */Curry._3(Dag[/* create_property */12], vcs[/* dag */2], l, i)
          ];
  };
  var property_of = function (vcs, i) {
    return Curry._2(Dag[/* property_of */13], vcs[/* dag */2], i);
  };
  var delete_property = function (vcs, c) {
    return /* record */[
            /* cur_branch */vcs[/* cur_branch */0],
            /* heads */vcs[/* heads */1],
            /* dag */Curry._2(Dag[/* del_property */14], vcs[/* dag */2], c)
          ];
  };
  var branches = function (vcs) {
    return Curry._3(BranchMap[/* fold */10], (function (x, _, accu) {
                  return /* :: */[
                          x,
                          accu
                        ];
                }), vcs[/* heads */1], /* [] */0);
  };
  var dag = function (vcs) {
    return vcs[/* dag */2];
  };
  var closure = function (s, d, n) {
    var l;
    try {
      l = Curry._2(Dag[/* from_node */3], d, n);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        l = /* [] */0;
      } else {
        throw exn;
      }
    }
    return List.fold_left((function (s, param) {
                  var n$prime = param[0];
                  if (Curry._2(Dag[/* NodeSet */0][/* mem */2], n$prime, s)) {
                    return s;
                  } else {
                    return closure(s, d, n$prime);
                  }
                }), Curry._2(Dag[/* NodeSet */0][/* add */3], n, s), l);
  };
  var reachable = function (vcs, i) {
    return closure(Dag[/* NodeSet */0][/* empty */0], vcs[/* dag */2], i);
  };
  var gc = function (vcs) {
    var alive = Curry._3(BranchMap[/* fold */10], (function (_, param, s) {
            return closure(s, vcs[/* dag */2], param[/* pos */2]);
          }), vcs[/* heads */1], Dag[/* NodeSet */0][/* empty */0]);
    var dead = Curry._2(Dag[/* NodeSet */0][/* diff */8], Curry._1(Dag[/* all_nodes */7], vcs[/* dag */2]), alive);
    return /* tuple */[
            /* record */[
              /* cur_branch */vcs[/* cur_branch */0],
              /* heads */vcs[/* heads */1],
              /* dag */Curry._2(Dag[/* del_nodes */6], vcs[/* dag */2], dead)
            ],
            dead
          ];
  };
  return [
          Branch,
          empty,
          current_branch,
          branches,
          get_branch,
          reset_branch,
          branch,
          delete_branch,
          merge,
          commit,
          rewrite_merge,
          checkout,
          set_info,
          get_info,
          Dag,
          dag,
          create_property,
          property_of,
          delete_property,
          gc,
          reachable
        ];
}

exports.Make = Make;
/* Pp-ReactTemplate Not a pure module */
