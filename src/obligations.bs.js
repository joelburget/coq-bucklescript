// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Hook$ReactTemplate = require("./hook.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Decls$ReactTemplate = require("./decls.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Hints$ReactTemplate = require("../tactics/hints.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Coqlib$ReactTemplate = require("../library/coqlib.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Lemmas$ReactTemplate = require("./lemmas.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Pfedit$ReactTemplate = require("./pfedit.bs.js");
var UState$ReactTemplate = require("./uState.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Declare$ReactTemplate = require("./declare.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Printer$ReactTemplate = require("./printer.bs.js");
var Program$ReactTemplate = require("./program.bs.js");
var Refiner$ReactTemplate = require("./refiner.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Univops$ReactTemplate = require("./univops.bs.js");
var CClosure$ReactTemplate = require("./cClosure.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Locality$ReactTemplate = require("../vernac/locality.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Pretyping$ReactTemplate = require("./pretyping.bs.js");
var Proofview$ReactTemplate = require("./proofview.bs.js");
var Tacticals$ReactTemplate = require("../tactics/tacticals.bs.js");
var Univdecls$ReactTemplate = require("./univdecls.bs.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var CEphemeron$ReactTemplate = require("./cEphemeron.bs.js");
var DeclareDef$ReactTemplate = require("../vernac/declareDef.bs.js");
var ExplainErr$ReactTemplate = require("./explainErr.bs.js");
var Metasyntax$ReactTemplate = require("../vernac/metasyntax.bs.js");
var Safe_typing$ReactTemplate = require("./safe_typing.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Proof_global$ReactTemplate = require("./proof_global.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("./pretype_errors.bs.js");

var match = Hook$ReactTemplate.make(/* None */0, /* () */0);

var get_fix_exn = match[0];

function succfix(param) {
  return /* tuple */[
          param[0] + 1 | 0,
          Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                  return prim + 1 | 0;
                }), param[1])
        ];
}

function check_evars(env, evm) {
  return Curry._2(Evar$ReactTemplate.$$Map[/* iter */9], (function (key, _) {
                var match = Evd$ReactTemplate.evar_source(key, evm);
                var k = match[1];
                var exit = 0;
                if (typeof k === "number") {
                  exit = 1;
                } else {
                  switch (k.tag | 0) {
                    case 0 : 
                        if (k[2] !== 0) {
                          exit = 1;
                        } else {
                          return /* () */0;
                        }
                        break;
                    case 3 : 
                        return /* () */0;
                    default:
                      exit = 1;
                  }
                }
                if (exit === 1) {
                  return Pretype_errors$ReactTemplate.error_unsolvable_implicit(match[0], env, evm, key, /* None */0);
                }
                
              }), Evd$ReactTemplate.undefined_map(evm));
}

function subst_evar_constr(evs, _, idf, t) {
  var seen = [Int$ReactTemplate.$$Set[/* empty */0]];
  var transparent = [Names$ReactTemplate.Id[/* Set */9][/* empty */0]];
  var evar_info = function (id) {
    return Curry._3(Util$ReactTemplate.List[/* assoc_f */125], Evar$ReactTemplate.equal, id, evs);
  };
  var substrec = function (param, c) {
    var fixrels = param[1];
    var depth = param[0];
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 3 : 
          var match$1 = match[0];
          var k = match$1[0];
          var match$2;
          try {
            match$2 = evar_info(k);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              match$2 = CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["eterm"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("existential variable "), Pp$ReactTemplate.$$int(Evar$ReactTemplate.repr(k))), Pp$ReactTemplate.str(" not found.")));
            } else {
              throw exn;
            }
          }
          var chop = match$2[/* ev_chop */3];
          var match$3 = match$2[/* ev_name */0];
          var idstr = match$3[1];
          seen[0] = Curry._2(Int$ReactTemplate.$$Set[/* add */3], match$3[0], seen[0]);
          var n = chop ? chop[0] : 0;
          var match$4 = Curry._2(Util$ReactTemplate.List[/* chop */99], n, Curry._1(Util$ReactTemplate.List[/* rev */4], Util$ReactTemplate.$$Array[/* to_list */9](match$1[1])));
          var args = Curry._1(Util$ReactTemplate.List[/* rev */4], match$4[1]);
          var aux = function (_hyps, _args, _acc) {
            while(true) {
              var acc = _acc;
              var args = _args;
              var hyps = _hyps;
              if (hyps) {
                if (hyps[0].tag) {
                  if (args) {
                    _args = args[1];
                    _hyps = hyps[1];
                    continue ;
                    
                  } else {
                    return acc;
                  }
                } else if (args) {
                  _acc = /* :: */[
                    substrec(/* tuple */[
                          depth,
                          fixrels
                        ], args[0]),
                    acc
                  ];
                  _args = args[1];
                  _hyps = hyps[1];
                  continue ;
                  
                } else {
                  return acc;
                }
              } else {
                return acc;
              }
            };
          };
          var args$1 = aux(match$2[/* ev_hyps */1], args, /* [] */0);
          if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (x) {
                    var match = Constr$ReactTemplate.kind(x);
                    if (match.tag) {
                      return /* false */0;
                    } else {
                      return Curry._2(Int$ReactTemplate.List[/* mem */0], match[0], fixrels);
                    }
                  }), args$1)) {
            transparent[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], idstr, transparent[0]);
          }
          return Constr$ReactTemplate.mkApp(/* tuple */[
                      Curry._1(idf, idstr),
                      Util$ReactTemplate.$$Array[/* of_list */10](args$1)
                    ]);
      case 14 : 
          return Constr$ReactTemplate.map_with_binders(succfix, substrec, /* tuple */[
                      depth,
                      /* :: */[
                        1,
                        fixrels
                      ]
                    ], c);
      default:
        return Constr$ReactTemplate.map_with_binders(succfix, substrec, /* tuple */[
                    depth,
                    fixrels
                  ], c);
    }
  };
  var t$prime = substrec(/* tuple */[
        0,
        /* [] */0
      ], t);
  return /* tuple */[
          t$prime,
          seen[0],
          transparent[0]
        ];
}

function subst_vars(acc, _, t) {
  var var_index = function (id) {
    return Curry._3(Util$ReactTemplate.List[/* index */77], Names$ReactTemplate.Id[/* equal */0], id, acc);
  };
  var substrec = function (depth, c) {
    var match = Constr$ReactTemplate.kind(c);
    if (match.tag === 1) {
      try {
        return Constr$ReactTemplate.mkRel(depth + var_index(match[0]) | 0);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return c;
        } else {
          throw exn;
        }
      }
    } else {
      return Constr$ReactTemplate.map_with_binders((function (prim) {
                    return prim + 1 | 0;
                  }), substrec, depth, c);
    }
  };
  return substrec(0, t);
}

function etype_of_evar(evs, hyps, concl) {
  var aux = function (acc, n, param) {
    if (param) {
      var decl = param[0];
      var match = subst_evar_constr(evs, n, Constr$ReactTemplate.mkVar, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl));
      var t$prime$prime = subst_vars(acc, 0, match[0]);
      var match$1 = aux(/* :: */[
            Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl),
            acc
          ], n + 1 | 0, param[1]);
      var rest = match$1[0];
      var s$prime = Curry._2(Int$ReactTemplate.$$Set[/* union */6], match[1], match$1[1]);
      var trans$prime = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], match[2], match$1[2]);
      if (decl.tag) {
        var match$2 = subst_evar_constr(evs, n, Constr$ReactTemplate.mkVar, decl[1]);
        var c$prime = subst_vars(acc, 0, match$2[0]);
        return /* tuple */[
                Term$ReactTemplate.mkNamedProd_or_LetIn(/* LocalDef */Block.__(1, [
                        decl[0],
                        c$prime,
                        t$prime$prime
                      ]), rest),
                Curry._2(Int$ReactTemplate.$$Set[/* union */6], match$2[1], s$prime),
                Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], match$2[2], trans$prime)
              ];
      } else {
        return /* tuple */[
                Term$ReactTemplate.mkNamedProd_or_LetIn(/* LocalAssum */Block.__(0, [
                        decl[0],
                        t$prime$prime
                      ]), rest),
                s$prime,
                trans$prime
              ];
      }
    } else {
      var match$3 = subst_evar_constr(evs, n, Constr$ReactTemplate.mkVar, concl);
      return /* tuple */[
              subst_vars(acc, 0, match$3[0]),
              match$3[1],
              match$3[2]
            ];
    }
  };
  return aux(/* [] */0, 0, Curry._1(Util$ReactTemplate.List[/* rev */4], hyps));
}

function trunc_named_context(n, ctx) {
  var len = Curry._1(Util$ReactTemplate.List[/* length */0], ctx);
  return Curry._2(Util$ReactTemplate.List[/* firstn */104], len - n | 0, ctx);
}

function chop_product(_n, _t) {
  while(true) {
    var t = _t;
    var n = _n;
    if (n) {
      var match = Constr$ReactTemplate.kind(t);
      if (match.tag === 6) {
        var b = match[2];
        if (Vars$ReactTemplate.noccurn(1, b)) {
          _t = Vars$ReactTemplate.lift(-1)(b);
          _n = n - 1 | 0;
          continue ;
          
        } else {
          return /* None */0;
        }
      } else {
        return /* None */0;
      }
    } else {
      return /* Some */[t];
    }
  };
}

function evar_dependencies(evm, oev) {
  var one_step = function (deps) {
    return Curry._3(Evar$ReactTemplate.$$Set[/* fold */13], (function (ev, s) {
                  var evi = Evd$ReactTemplate.find(evm, ev);
                  var deps$prime = Evd$ReactTemplate.evars_of_filtered_evar_info(evi);
                  if (Curry._2(Evar$ReactTemplate.$$Set[/* mem */2], oev, deps$prime)) {
                    return CErrors$ReactTemplate.invalid_arg(/* None */0, "Ill-formed evar map: cycle detected for evar " + Pp$ReactTemplate.string_of_ppcmds(Evar$ReactTemplate.print(oev)));
                  } else {
                    return Curry._2(Evar$ReactTemplate.$$Set[/* union */6], deps$prime, s);
                  }
                }), deps, deps);
  };
  var _deps = Curry._1(Evar$ReactTemplate.$$Set[/* singleton */4], oev);
  while(true) {
    var deps = _deps;
    var deps$prime = one_step(deps);
    if (Curry._2(Evar$ReactTemplate.$$Set[/* equal */10], deps, deps$prime)) {
      return deps;
    } else {
      _deps = deps$prime;
      continue ;
      
    }
  };
}

function move_after(obl, l) {
  var aux = function (restdeps, param) {
    if (param) {
      var tl = param[1];
      var obl$prime = param[0];
      var restdeps$prime = Curry._2(Evar$ReactTemplate.$$Set[/* remove */5], obl$prime[0], restdeps);
      if (Curry._1(Evar$ReactTemplate.$$Set[/* is_empty */1], restdeps$prime)) {
        return /* :: */[
                obl$prime,
                /* :: */[
                  obl,
                  tl
                ]
              ];
      } else {
        return /* :: */[
                obl$prime,
                aux(restdeps$prime, tl)
              ];
      }
    } else {
      return /* :: */[
              obl,
              /* [] */0
            ];
    }
  };
  return aux(Curry._2(Evar$ReactTemplate.$$Set[/* remove */5], obl[0], obl[2]), l);
}

function sort_dependencies(evl) {
  var _l = evl;
  var _found = Evar$ReactTemplate.$$Set[/* empty */0];
  var _list = /* [] */0;
  while(true) {
    var list = _list;
    var found = _found;
    var l = _l;
    if (l) {
      var tl = l[1];
      var obl = l[0];
      var found$prime = Curry._2(Evar$ReactTemplate.$$Set[/* union */6], found, Curry._1(Evar$ReactTemplate.$$Set[/* singleton */4], obl[0]));
      if (Curry._2(Evar$ReactTemplate.$$Set[/* subset */11], obl[2], found$prime)) {
        _list = /* :: */[
          obl,
          list
        ];
        _found = found$prime;
        _l = tl;
        continue ;
        
      } else {
        _l = move_after(obl, tl);
        continue ;
        
      }
    } else {
      return Curry._1(Util$ReactTemplate.List[/* rev */4], list);
    }
  };
}

function eterm_obligations(env, name, evm, fs, status, t, ty) {
  var nc = Environ$ReactTemplate.named_context(env);
  var nc_len = Curry._1(Context$ReactTemplate.Named[/* length */3], nc);
  var evm$1 = Evarutil$ReactTemplate.nf_evar_map_undefined(evm);
  var evl = Evarutil$ReactTemplate.non_instantiated(evm$1);
  var evl$1 = Curry._1(Evar$ReactTemplate.$$Map[/* bindings */16], evl);
  var evl$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var id = param[0];
          return /* tuple */[
                  id,
                  param[1],
                  evar_dependencies(evm$1, id)
                ];
        }), evl$1);
  var sevl = sort_dependencies(evl$2);
  var evl$3 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[0],
                  param[1]
                ];
        }), sevl);
  var i = [-1];
  var evn = Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (param) {
          i[0] = i[0] + 1 | 0;
          return /* tuple */[
                  param[0],
                  /* tuple */[
                    i[0],
                    Names$ReactTemplate.Id[/* of_string */5](Names$ReactTemplate.Id[/* to_string */7](name) + ("_obligation_" + Pervasives.string_of_int(i[0] + 1 | 0)))
                  ],
                  param[1]
                ];
        }), evl$3);
  var evts = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, l) {
          var ev = param[2];
          var match = param[1];
          var id = param[0];
          var hyps = Evd$ReactTemplate.evar_filtered_context(ev);
          var hyps$1 = trunc_named_context(nc_len, hyps);
          var match$1 = etype_of_evar(l, hyps$1, ev[/* evar_concl */0]);
          var evtyp = match$1[0];
          var match$2 = chop_product(fs, evtyp);
          var match$3 = match$2 ? /* tuple */[
              match$2[0],
              trunc_named_context(fs, hyps$1),
              fs
            ] : /* tuple */[
              evtyp,
              hyps$1,
              0
            ];
          var chop = match$3[2];
          var match$4 = Evd$ReactTemplate.evar_source(id, evm$1);
          var k = match$4[1];
          var status$1;
          var exit = 0;
          if (typeof k === "number" || k.tag !== 3) {
            exit = 1;
          } else {
            status$1 = k[0];
          }
          if (exit === 1) {
            status$1 = status ? status[0] : /* Define */[1 - Program$ReactTemplate.get_proofs_transparency(/* () */0)];
          }
          var match$5 = status$1 ? (
              status$1[0] !== 0 ? (
                  chop !== fs ? /* tuple */[
                      /* true */1,
                      /* Define */[/* false */0],
                      /* None */0
                    ] : /* tuple */[
                      /* false */0,
                      status$1,
                      /* Some */[chop]
                    ]
                ) : /* tuple */[
                  /* false */0,
                  status$1,
                  /* None */0
                ]
            ) : /* tuple */[
              /* false */0,
              status$1,
              /* None */0
            ];
          var info_000 = /* ev_name : tuple */[
            match[0],
            match[1]
          ];
          var info_001 = /* ev_hyps */match$3[1];
          var info_002 = /* ev_status : tuple */[
            match$5[0],
            match$5[1]
          ];
          var info_003 = /* ev_chop */match$5[2];
          var info_004 = /* ev_src : tuple */[
            match$4[0],
            k
          ];
          var info_005 = /* ev_typ */match$3[0];
          var info_007 = /* ev_deps */match$1[1];
          var info = /* record */[
            info_000,
            info_001,
            info_002,
            info_003,
            info_004,
            info_005,
            /* ev_tac : None */0,
            info_007
          ];
          return /* :: */[
                  /* tuple */[
                    id,
                    info
                  ],
                  l
                ];
        }), evn, /* [] */0);
  var match = subst_evar_constr(evts, 0, Constr$ReactTemplate.mkVar, t);
  var transparent = match[2];
  var match$1 = subst_evar_constr(evts, 0, Constr$ReactTemplate.mkVar, ty);
  var evars = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var info = param[1];
          var match = info[/* ev_status */2];
          var status = match[1];
          var force_status = match[0];
          var name = info[/* ev_name */0][1];
          var match$1 = status ? (
              status[0] !== 0 ? (
                  Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], name, transparent) ? /* tuple */[
                      /* true */1,
                      /* Define */[/* false */0]
                    ] : /* tuple */[
                      force_status,
                      status
                    ]
                ) : /* tuple */[
                  force_status,
                  status
                ]
            ) : /* tuple */[
              force_status,
              status
            ];
          return /* tuple */[
                  name,
                  info[/* ev_typ */5],
                  info[/* ev_src */4],
                  /* tuple */[
                    match$1[0],
                    match$1[1]
                  ],
                  info[/* ev_deps */7],
                  info[/* ev_tac */6]
                ];
        }), evts);
  var evnames = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[0],
                  param[1][/* ev_name */0][1]
                ];
        }), evts);
  var evmap = function (f, c) {
    return Util$ReactTemplate.pi1(subst_evar_constr(evts, 0, f, c));
  };
  return /* tuple */[
          Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(Util$ReactTemplate.List[/* rev */4], evars)),
          /* tuple */[
            evnames,
            evmap
          ],
          match[0],
          match$1[0]
        ];
}

function hide_obligation(param) {
  var md = /* :: */[
    "Program",
    /* :: */[
      "Tactics",
      /* [] */0
    ]
  ];
  var name = "obligation";
  Coqlib$ReactTemplate.check_required_library(/* :: */[
        "Coq",
        md
      ]);
  return Universes$ReactTemplate.constr_of_global(Coqlib$ReactTemplate.coq_reference("Obligations", md, name));
}

function reduce(c) {
  return EConstr$ReactTemplate.Unsafe[/* to_constr */0](Reductionops$ReactTemplate.clos_norm_flags(CClosure$ReactTemplate.betaiota, Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(c)));
}

var NoObligations = Caml_exceptions.create("Obligations-ReactTemplate.NoObligations");

function explain_no_obligations(param) {
  if (param) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No obligations for program "), Names$ReactTemplate.Id[/* print */8](param[0]));
  } else {
    return Pp$ReactTemplate.str("No obligations remaining");
  }
}

function get_info(x) {
  try {
    return CEphemeron$ReactTemplate.get(x);
  }
  catch (exn){
    if (exn === CEphemeron$ReactTemplate.InvalidKey) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Program obligation can't be accessed by a worker."));
    } else {
      throw exn;
    }
  }
}

var default_tactic = [Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0)];

var hide_obligations = [/* false */0];

function set_hide_obligations(param) {
  hide_obligations[0] = param;
  return /* () */0;
}

function get_hide_obligations() {
  return hide_obligations[0];
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"Hidding of Program obligations",
      /* optkey : :: */[
        "Hide",
        /* :: */[
          "Obligations",
          /* [] */0
        ]
      ],
      /* optread */get_hide_obligations,
      /* optwrite */set_hide_obligations
    ]);

var shrink_obligations = [/* true */1];

function set_shrink_obligations(param) {
  shrink_obligations[0] = param;
  return /* () */0;
}

function get_shrink_obligations() {
  return shrink_obligations[0];
}

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : true */1,
      /* optname */"Shrinking of Program obligations",
      /* optkey : :: */[
        "Shrink",
        /* :: */[
          "Obligations",
          /* [] */0
        ]
      ],
      /* optread */get_shrink_obligations,
      /* optwrite */set_shrink_obligations
    ]);

function evar_of_obligation(o) {
  return Evd$ReactTemplate.make_evar(Global$ReactTemplate.named_context_val(/* () */0), o[/* obl_type */1]);
}

function get_obligation_body(expand, obl) {
  var match = obl[/* obl_body */3];
  if (match) {
    var c = match[0];
    if (expand && obl[/* obl_status */4][1] === /* Expand */0) {
      if (c.tag) {
        return /* Some */[c[0]];
      } else {
        return /* Some */[Environ$ReactTemplate.constant_value_in(Global$ReactTemplate.env(/* () */0), c[0])];
      }
    } else if (c.tag) {
      return /* Some */[c[0]];
    } else {
      return /* Some */[Constr$ReactTemplate.mkConstU(c[0])];
    }
  } else {
    return /* None */0;
  }
}

function obl_substitution(expand, obls, deps) {
  return Curry._3(Int$ReactTemplate.$$Set[/* fold */13], (function (x, acc) {
                var xobl = Caml_array.caml_array_get(obls, x);
                var match = get_obligation_body(expand, xobl);
                if (match) {
                  return /* :: */[
                          /* tuple */[
                            xobl[/* obl_name */0],
                            /* tuple */[
                              xobl[/* obl_type */1],
                              match[0]
                            ]
                          ],
                          acc
                        ];
                } else {
                  return acc;
                }
              }), deps, /* [] */0);
}

function subst_deps(expand, obls, deps, t) {
  var osubst = obl_substitution(expand, obls, deps);
  return Vars$ReactTemplate.replace_vars(Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return /* tuple */[
                            param[0],
                            param[1][1]
                          ];
                  }), osubst), t);
}

function prod_app(_t, n) {
  while(true) {
    var t = _t;
    var match = Constr$ReactTemplate.kind(EConstr$ReactTemplate.Unsafe[/* to_constr */0](Termops$ReactTemplate.strip_outer_cast(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(t))));
    switch (match.tag | 0) {
      case 6 : 
          return Vars$ReactTemplate.subst1(n, match[2]);
      case 8 : 
          _t = Vars$ReactTemplate.subst1(match[1], match[3]);
          continue ;
          default:
        return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["prod_app"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Needed a product, but didn't find one"), Pp$ReactTemplate.fnl(/* () */0)));
    }
  };
}

function prod_applist(t, nL) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], prod_app, t, nL);
}

function replace_appvars(subst) {
  var aux = function (c) {
    var match = Constr$ReactTemplate.decompose_app(c);
    var f = match[0];
    if (Constr$ReactTemplate.isVar(f)) {
      try {
        var c$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                return Constr$ReactTemplate.map(aux, param);
              }), match[1]);
        var match$1 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], Constr$ReactTemplate.destVar(f), subst);
        return Constr$ReactTemplate.mkApp(/* tuple */[
                    Util$ReactTemplate.delayed_force(hide_obligation),
                    /* array */[
                      prod_applist(match$1[0], c$prime),
                      Term$ReactTemplate.applistc(match$1[1], c$prime)
                    ]
                  ]);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return Constr$ReactTemplate.map(aux, c);
        } else {
          throw exn;
        }
      }
    } else {
      return Constr$ReactTemplate.map(aux, c);
    }
  };
  return (function (param) {
      return Constr$ReactTemplate.map(aux, param);
    });
}

function subst_deps_obl(obls, obl) {
  var t$prime = subst_deps(/* true */1, obls, obl[/* obl_deps */5], obl[/* obl_type */1]);
  var newrecord = obl.slice();
  newrecord[/* obl_type */1] = t$prime;
  return newrecord;
}

function map_replace(k, v, m) {
  return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], k, CEphemeron$ReactTemplate.create(v), Curry._2(Names$ReactTemplate.Id[/* Map */10][/* remove */5], k, m));
}

function map_keys(m) {
  return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], (function (k, _, l) {
                return /* :: */[
                        k,
                        l
                      ];
              }), m, /* [] */0);
}

var match$1 = Summary$ReactTemplate.ref_tag(/* None */0, "program-tcc-table", Names$ReactTemplate.Id[/* Map */10][/* empty */0]);

var from_prg = match$1[0];

function close(sec) {
  if (Curry._1(Names$ReactTemplate.Id[/* Map */10][/* is_empty */1], from_prg[0])) {
    return 0;
  } else {
    var keys = map_keys(from_prg[0]);
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unsolved obligations when closing "), Pp$ReactTemplate.str(sec)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (x) {
                              return Names$ReactTemplate.Id[/* print */8](x);
                            }), keys)), Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(Curry._1(Util$ReactTemplate.List[/* length */0], keys) === 1 ? " has " : " have "), Pp$ReactTemplate.str("unsolved obligations"))));
  }
}

var init = Libobject$ReactTemplate.default_object("Program state");

var input = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */(function (param) {
          from_prg[0] = param[1];
          return /* () */0;
        }),
      /* load_function */(function (_, param) {
          from_prg[0] = param[1];
          return /* () */0;
        }),
      /* open_function */init[/* open_function */3],
      /* classify_function */(function () {
          close("module");
          return /* Dispose */0;
        }),
      /* subst_function */init[/* subst_function */5],
      /* discharge_function */(function () {
          close("section");
          return /* None */0;
        }),
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

function progmap_remove(prg) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(input, Curry._2(Names$ReactTemplate.Id[/* Map */10][/* remove */5], prg[/* prg_name */0], from_prg[0])));
}

function progmap_add(n, prg) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(input, Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], n, prg, from_prg[0])));
}

function progmap_replace(prg$prime) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(input, map_replace(prg$prime[/* prg_name */0], prg$prime, from_prg[0])));
}

function intset_to(n) {
  if (n !== -1) {
    return Curry._2(Int$ReactTemplate.$$Set[/* add */3], n, intset_to(n - 1 | 0));
  } else {
    return Int$ReactTemplate.$$Set[/* empty */0];
  }
}

function subst_body(expand, prg) {
  var match = prg[/* prg_obligations */5];
  var obls = match[0];
  var ints = intset_to(obls.length - 1 | 0);
  var expand$1 = expand;
  var obls$1 = obls;
  var ints$1 = ints;
  var prg$1 = prg;
  var subst = obl_substitution(expand$1, obls$1, ints$1);
  if (hide_obligations[0]) {
    return /* tuple */[
            replace_appvars(subst)(prg$1[/* prg_body */1]),
            replace_appvars(subst)(prg$1[/* prg_type */2])
          ];
  } else {
    var subst$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            return /* tuple */[
                    param[0],
                    param[1][1]
                  ];
          }), subst);
    return /* tuple */[
            Vars$ReactTemplate.replace_vars(subst$prime, prg$1[/* prg_body */1]),
            Vars$ReactTemplate.replace_vars(subst$prime, prg$1[/* prg_type */2])
          ];
  }
}

function declare_definition(prg) {
  var match = subst_body(/* true */1, prg);
  var nf = Universes$ReactTemplate.nf_evars_and_universes_opt_subst((function () {
          return /* None */0;
        }), UState$ReactTemplate.subst(prg[/* prg_ctx */3]));
  var opaque = prg[/* prg_opaque */13];
  var fix_exn = Curry._1(Hook$ReactTemplate.get(get_fix_exn), /* () */0);
  var typ = Curry._1(nf, match[1]);
  var body = Curry._1(nf, match[0]);
  var env = Global$ReactTemplate.env(/* () */0);
  var uvars = Curry._2(Univ$ReactTemplate.LSet[/* union */6], Univops$ReactTemplate.universes_of_constr(env, typ), Univops$ReactTemplate.universes_of_constr(env, body));
  var uctx = UState$ReactTemplate.restrict(prg[/* prg_ctx */3], uvars);
  var univs = UState$ReactTemplate.check_univ_decl(Util$ReactTemplate.pi2(prg[/* prg_kind */10]), uctx, prg[/* prg_univdecl */4]);
  var ce = Declare$ReactTemplate.definition_entry(/* Some */[fix_exn], /* Some */[opaque], /* None */0, /* Some */[typ], /* Some */[univs], /* None */0, body);
  progmap_remove(prg);
  var ubinders = UState$ReactTemplate.universe_binders(uctx);
  return DeclareDef$ReactTemplate.declare_definition(prg[/* prg_name */0], prg[/* prg_kind */10], ce, ubinders, prg[/* prg_implicits */8], Lemmas$ReactTemplate.mk_hook((function (l, r) {
                    Curry._1(Lemmas$ReactTemplate.call_hook(fix_exn, prg[/* prg_hook */12], l, r), uctx);
                    return r;
                  })));
}

function lam_index(n, _t, _acc) {
  while(true) {
    var acc = _acc;
    var t = _t;
    var match = Constr$ReactTemplate.kind(t);
    if (match.tag === 7) {
      var match$1 = match[0];
      if (match$1) {
        if (Names$ReactTemplate.Id[/* equal */0](n, match$1[0])) {
          return acc;
        } else {
          _acc = acc + 1 | 0;
          _t = match[2];
          continue ;
          
        }
      } else {
        _acc = acc + 1 | 0;
        _t = match[2];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function compute_possible_guardness_evidences(param, fixbody, fixtype) {
  var n = param[0];
  if (n) {
    return /* :: */[
            lam_index(n[0][/* v */0], fixbody, 0),
            /* [] */0
          ];
  } else {
    var m = Termops$ReactTemplate.nb_prod(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(fixtype));
    var ctx = Term$ReactTemplate.decompose_prod_n_assum(m)(fixtype)[0];
    return Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, _) {
                  return i;
                }), 0, ctx);
  }
}

function mk_proof(c) {
  return /* tuple */[
          /* tuple */[
            c,
            Univ$ReactTemplate.ContextSet[/* empty */0]
          ],
          Safe_typing$ReactTemplate.empty_private_constants
        ];
}

function declare_mutual_definition(l) {
  var len = Curry._1(Util$ReactTemplate.List[/* length */0], l);
  var first = Curry._1(Util$ReactTemplate.List[/* hd */1], l);
  var match = Curry._1(Util$ReactTemplate.List[/* split3 */103], Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
              var match = subst_body(/* true */1, x);
              var term = Reductionops$ReactTemplate.splay_lam_n(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, len)(EConstr$ReactTemplate.of_constr(match[0]))[1];
              var typ = Reductionops$ReactTemplate.splay_prod_n(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, len)(EConstr$ReactTemplate.of_constr(match[1]))[1];
              var term$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](term);
              var typ$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](typ);
              return /* tuple */[
                      Curry._1(x[/* prg_reduce */11], term$1),
                      Curry._1(x[/* prg_reduce */11], typ$1),
                      x[/* prg_implicits */8]
                    ];
            }), l));
  var fixtypes = match[1];
  var fixdefs = match[0];
  var fixkind = Option$ReactTemplate.get(first[/* prg_fixkind */7]);
  var arrrec = Util$ReactTemplate.$$Array[/* of_list */10](fixtypes);
  var recvec = Util$ReactTemplate.$$Array[/* of_list */10](fixdefs);
  var fixdecls_000 = Util$ReactTemplate.$$Array[/* of_list */10](Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
              return /* Name */[x[/* prg_name */0]];
            }), l));
  var fixdecls = /* tuple */[
    fixdecls_000,
    arrrec,
    recvec
  ];
  var match$1 = first[/* prg_kind */10];
  var poly = match$1[1];
  var local = match$1[0];
  var fixnames = first[/* prg_deps */6];
  var opaque = first[/* prg_opaque */13];
  var kind = fixkind !== /* IsCoFixpoint */0 ? /* Fixpoint */5 : /* CoFixpoint */6;
  var match$2;
  if (fixkind) {
    var possible_indexes = Curry._4(Util$ReactTemplate.List[/* map3 */69], compute_possible_guardness_evidences, fixkind[0], fixdefs, fixtypes);
    var indexes = Pretyping$ReactTemplate.search_guard(/* None */0, Global$ReactTemplate.env(/* () */0), possible_indexes, fixdecls);
    match$2 = /* tuple */[
      /* Some */[indexes],
      Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, _) {
              return mk_proof(Constr$ReactTemplate.mkFix(/* tuple */[
                              /* tuple */[
                                indexes,
                                i
                              ],
                              fixdecls
                            ]));
            }), 0, l)
    ];
  } else {
    match$2 = /* tuple */[
      /* None */0,
      Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, _) {
              return mk_proof(Constr$ReactTemplate.mkCoFix(/* tuple */[
                              i,
                              fixdecls
                            ]));
            }), 0, l)
    ];
  }
  var univs = UState$ReactTemplate.const_univ_entry(poly, first[/* prg_ctx */3]);
  var fix_exn = Curry._1(Hook$ReactTemplate.get(get_fix_exn), /* () */0);
  var partial_arg = /* tuple */[
    local,
    poly,
    kind
  ];
  var partial_arg$1 = /* Some */[opaque];
  var kns = Curry._5(Util$ReactTemplate.List[/* map4 */70], (function (param, param$1, param$2, param$3) {
          return DeclareDef$ReactTemplate.declare_fix(partial_arg$1, partial_arg, Universes$ReactTemplate.empty_binders, univs, param, param$1, param$2, param$3);
        }), fixnames, match$2[1], fixtypes, match[2]);
  var partial_arg$2 = Global$ReactTemplate.env(/* () */0);
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
          return Metasyntax$ReactTemplate.add_notation_interpretation(partial_arg$2, param);
        }), first[/* prg_notations */9]);
  Declare$ReactTemplate.recursive_message(+(fixkind !== /* IsCoFixpoint */0), match$2[0], fixnames);
  var gr = Curry._1(Util$ReactTemplate.List[/* hd */1], kns);
  var kn;
  if (gr.tag === 1) {
    kn = gr[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "obligations.ml",
            562,
            52
          ]
        ];
  }
  Curry._1(Lemmas$ReactTemplate.call_hook(fix_exn, first[/* prg_hook */12], local, gr), first[/* prg_ctx */3]);
  Curry._2(Util$ReactTemplate.List[/* iter */9], progmap_remove, l);
  return kn;
}

function decompose_lam_prod(c, ty) {
  var _ctx = Context$ReactTemplate.Rel[/* empty */1];
  var _c = c;
  var _ty = ty;
  while(true) {
    var ty$1 = _ty;
    var c$1 = _c;
    var ctx = _ctx;
    var match = Constr$ReactTemplate.kind(c$1);
    var match$1 = Constr$ReactTemplate.kind(ty$1);
    var exit = 0;
    var exit$1 = 0;
    switch (match.tag | 0) {
      case 7 : 
          switch (match$1.tag | 0) {
            case 6 : 
                var ctx$prime = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                        match[0],
                        match$1[1]
                      ]), ctx);
                _ty = match$1[2];
                _c = match[2];
                _ctx = ctx$prime;
                continue ;
                case 8 : 
                exit$1 = 2;
                break;
            default:
              return /* tuple */[
                      ctx,
                      c$1,
                      ty$1
                    ];
          }
          break;
      case 8 : 
          if (match$1.tag === 8) {
            var t$prime = match$1[2];
            var b$prime = match$1[1];
            if (Constr$ReactTemplate.equal(match[1], b$prime) && Constr$ReactTemplate.equal(match[2], t$prime)) {
              var ctx$prime$1 = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                      match[0],
                      b$prime,
                      t$prime
                    ]), ctx);
              _ty = match$1[3];
              _c = match[3];
              _ctx = ctx$prime$1;
              continue ;
              
            } else {
              exit$1 = 2;
            }
          } else {
            exit = 1;
          }
          break;
      default:
        exit$1 = 2;
    }
    if (exit$1 === 2) {
      if (match$1.tag === 8) {
        var ctx$prime$2 = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                match$1[0],
                match$1[1],
                match$1[2]
              ]), ctx);
        _ty = match$1[3];
        _c = Vars$ReactTemplate.lift(1)(c$1);
        _ctx = ctx$prime$2;
        continue ;
        
      } else {
        exit = 1;
      }
    }
    if (exit === 1) {
      switch (match.tag | 0) {
        case 5 : 
            _c = match[0];
            continue ;
            case 8 : 
            var ctx$prime$3 = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                    match[0],
                    match[1],
                    match[2]
                  ]), ctx);
            _ty = Vars$ReactTemplate.lift(1)(ty$1);
            _c = match[3];
            _ctx = ctx$prime$3;
            continue ;
            default:
          return /* tuple */[
                  ctx,
                  c$1,
                  ty$1
                ];
      }
    }
    
  };
}

function shrink_body(c, ty) {
  var match;
  if (ty) {
    var match$1 = decompose_lam_prod(c, ty[0]);
    match = /* tuple */[
      match$1[0],
      match$1[1],
      /* Some */[match$1[2]]
    ];
  } else {
    var match$2 = Term$ReactTemplate.decompose_lam_assum(c);
    match = /* tuple */[
      match$2[0],
      match$2[1],
      /* None */0
    ];
  }
  var ctx = match[0];
  var match$3 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, decl) {
          var args = param[3];
          var i = param[2];
          var ty = param[1];
          var b = param[0];
          if (Vars$ReactTemplate.noccurn(1, b) && Option$ReactTemplate.cata((function (param) {
                    return Vars$ReactTemplate.noccurn(1, param);
                  }), /* true */1, ty)) {
            return /* tuple */[
                    Vars$ReactTemplate.subst1(Constr$ReactTemplate.mkProp, b),
                    Option$ReactTemplate.map((function (param) {
                            return Vars$ReactTemplate.subst1(Constr$ReactTemplate.mkProp, param);
                          }), ty),
                    i + 1 | 0,
                    args
                  ];
          } else {
            var args$1 = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], decl) ? /* :: */[
                Constr$ReactTemplate.mkRel(i),
                args
              ] : args;
            return /* tuple */[
                    Term$ReactTemplate.mkLambda_or_LetIn(decl, b),
                    Option$ReactTemplate.map((function (param) {
                            return Term$ReactTemplate.mkProd_or_LetIn(decl, param);
                          }), ty),
                    i + 1 | 0,
                    args$1
                  ];
          }
        }), /* tuple */[
        match[1],
        match[2],
        1,
        /* [] */0
      ], ctx);
  return /* tuple */[
          ctx,
          match$3[0],
          match$3[1],
          Util$ReactTemplate.$$Array[/* of_list */10](match$3[3])
        ];
}

function unfold_entry(cst) {
  return /* HintsUnfoldEntry */Block.__(3, [/* :: */[
              /* EvalConstRef */Block.__(1, [cst]),
              /* [] */0
            ]]);
}

function add_hint(local, prg, cst) {
  return Hints$ReactTemplate.add_hints(local, /* :: */[
              Names$ReactTemplate.Id[/* to_string */7](prg[/* prg_name */0]),
              /* [] */0
            ], unfold_entry(cst));
}

function it_mkLambda_or_LetIn_or_clean(t, ctx) {
  var fold = function (t, decl) {
    if (Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], decl) || !Vars$ReactTemplate.noccurn(1, t)) {
      return Term$ReactTemplate.mkLambda_or_LetIn(decl, t);
    } else {
      return Vars$ReactTemplate.subst1(Constr$ReactTemplate.mkProp, t);
    }
  };
  return Curry._1(Context$ReactTemplate.Rel[/* fold_inside */9](fold, t), ctx);
}

function declare_obligation(prg, obl, body, ty, uctx) {
  var body$1 = Curry._1(prg[/* prg_reduce */11], body);
  var ty$1 = Option$ReactTemplate.map(prg[/* prg_reduce */11], ty);
  var match = obl[/* obl_status */4];
  var match$1 = match[1];
  if (match$1) {
    var opaque = 1 - match[0] && match$1[0];
    var poly = Util$ReactTemplate.pi2(prg[/* prg_kind */10]);
    var match$2 = shrink_obligations[0] && !poly ? shrink_body(body$1, ty$1) : /* tuple */[
        /* [] */0,
        body$1,
        ty$1,
        /* array */[]
      ];
    var body_000 = /* tuple */[
      match$2[1],
      Univ$ReactTemplate.ContextSet[/* empty */0]
    ];
    var body$2 = /* tuple */[
      body_000,
      Safe_typing$ReactTemplate.empty_private_constants
    ];
    var ce_000 = /* const_entry_body */Future$ReactTemplate.from_val(/* Some */[(function (x) {
              return x;
            })], body$2);
    var ce_003 = /* const_entry_type */match$2[2];
    var ce = /* record */[
      ce_000,
      /* const_entry_secctx : None */0,
      /* const_entry_feedback : None */0,
      ce_003,
      /* const_entry_universes */uctx,
      /* const_entry_opaque */opaque,
      /* const_entry_inline_code : false */0
    ];
    var constant = Declare$ReactTemplate.declare_constant(/* None */0, /* Some */[/* true */1], obl[/* obl_name */0], /* None */0, /* tuple */[
          /* DefinitionEntry */Block.__(0, [ce]),
          /* IsProof */Block.__(2, [/* Property */4])
        ]);
    if (!opaque) {
      add_hint(Locality$ReactTemplate.make_section_locality(/* None */0), prg, constant);
    }
    Declare$ReactTemplate.definition_message(obl[/* obl_name */0]);
    var body$3;
    body$3 = uctx.tag ? /* Some */[/* DefinedObl */Block.__(0, [/* tuple */[
              constant,
              Univ$ReactTemplate.UContext[/* instance */3](uctx[0])
            ]])] : /* Some */[/* TermObl */Block.__(1, [it_mkLambda_or_LetIn_or_clean(Constr$ReactTemplate.mkApp(/* tuple */[
                      Constr$ReactTemplate.mkConst(constant),
                      match$2[3]
                    ]), match$2[0])])];
    var newrecord = obl.slice();
    return /* tuple */[
            /* true */1,
            (newrecord[/* obl_body */3] = body$3, newrecord)
          ];
  } else {
    var newrecord$1 = obl.slice();
    return /* tuple */[
            /* false */0,
            (newrecord$1[/* obl_body */3] = /* Some */[/* TermObl */Block.__(1, [body$1])], newrecord$1)
          ];
  }
}

function init_prog_info($staropt$star, sign, n, udecl, b, t, ctx, deps, fixkind, notations, obls, impls, kind, reduce, hook) {
  var opaque = $staropt$star ? $staropt$star[0] : /* false */0;
  var match;
  if (b) {
    match = /* tuple */[
      Util$ReactTemplate.$$Array[/* mapi */14]((function (_, param) {
              return /* record */[
                      /* obl_name */param[0],
                      /* obl_type */param[1],
                      /* obl_location */param[2],
                      /* obl_body : None */0,
                      /* obl_status */param[3],
                      /* obl_deps */param[4],
                      /* obl_tac */param[5]
                    ];
            }), obls),
      b[0]
    ];
  } else {
    if (obls.length !== 0) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "obligations.ml",
              666,
              1
            ]
          ];
    }
    var n$1 = Nameops$ReactTemplate.add_suffix(n, "_obligation");
    match = /* tuple */[
      /* array */[/* record */[
          /* obl_name */n$1,
          /* obl_type */t,
          /* obl_location */Loc$ReactTemplate.tag(/* None */0, /* InternalHole */0),
          /* obl_body : None */0,
          /* obl_status : tuple */[
            /* false */0,
            /* Expand */0
          ],
          /* obl_deps */Int$ReactTemplate.$$Set[/* empty */0],
          /* obl_tac : None */0
        ]],
      Constr$ReactTemplate.mkVar(n$1)
    ];
  }
  var obls$prime = match[0];
  var ctx$1 = UState$ReactTemplate.make_flexible_nonalgebraic(ctx);
  return /* record */[
          /* prg_name */n,
          /* prg_body */match[1],
          /* prg_type */Curry._1(reduce, t),
          /* prg_ctx */ctx$1,
          /* prg_univdecl */udecl,
          /* prg_obligations : tuple */[
            obls$prime,
            obls$prime.length
          ],
          /* prg_deps */deps,
          /* prg_fixkind */fixkind,
          /* prg_implicits */impls,
          /* prg_notations */notations,
          /* prg_kind */kind,
          /* prg_reduce */reduce,
          /* prg_hook */hook,
          /* prg_opaque */opaque,
          /* prg_sign */sign
        ];
}

function map_cardinal(m) {
  var i = [0];
  Curry._2(Names$ReactTemplate.Id[/* Map */10][/* iter */9], (function (_, v) {
          if (CEphemeron$ReactTemplate.get(v)[/* prg_obligations */5][1] > 0) {
            i[0] = i[0] + 1 | 0;
            return /* () */0;
          } else {
            return 0;
          }
        }), m);
  return i[0];
}

var Found = Caml_exceptions.create("Obligations-ReactTemplate.Found");

function map_first(m) {
  try {
    Curry._2(Names$ReactTemplate.Id[/* Map */10][/* iter */9], (function (_, v) {
            if (CEphemeron$ReactTemplate.get(v)[/* prg_obligations */5][1] > 0) {
              throw [
                    Found,
                    v
                  ];
            } else {
              return 0;
            }
          }), m);
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "obligations.ml",
            703,
            4
          ]
        ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Found) {
      return exn[1];
    } else {
      throw exn;
    }
  }
}

function get_prog(name) {
  var prg_infos = from_prg[0];
  if (name) {
    var n = name[0];
    try {
      return get_info(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], n, prg_infos));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              NoObligations,
              /* Some */[n]
            ];
      } else {
        throw exn;
      }
    }
  } else {
    var n$1 = map_cardinal(prg_infos);
    if (n$1 !== 0) {
      if (n$1 !== 1) {
        var progs = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], Curry._1(Names$ReactTemplate.Id[/* Map */10][/* domain */27], prg_infos));
        var prog = Curry._1(Util$ReactTemplate.List[/* hd */1], progs);
        var progs$1 = Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Names$ReactTemplate.Id[/* print */8], progs);
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("More than one program with unsolved obligations: "), progs$1), Pp$ReactTemplate.str("; use the \"of\" clause to specify, as in \"Obligation 1 of ")), Names$ReactTemplate.Id[/* print */8](prog)), Pp$ReactTemplate.str("\"")));
      } else {
        return get_info(map_first(prg_infos));
      }
    } else {
      throw [
            NoObligations,
            /* None */0
          ];
    }
  }
}

function get_any_prog() {
  var prg_infos = from_prg[0];
  var n = map_cardinal(prg_infos);
  if (n > 0) {
    return get_info(map_first(prg_infos));
  } else {
    throw [
          NoObligations,
          /* None */0
        ];
  }
}

function get_prog_err(n) {
  try {
    return get_prog(n);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === NoObligations) {
      var cmd = explain_no_obligations(exn[1]);
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], cmd);
    } else {
      throw exn;
    }
  }
}

function get_any_prog_err() {
  try {
    return get_any_prog(/* () */0);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === NoObligations) {
      var cmd = explain_no_obligations(exn[1]);
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], cmd);
    } else {
      throw exn;
    }
  }
}

function all_programs() {
  return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], (function (_, p, l) {
                return /* :: */[
                        p,
                        l
                      ];
              }), from_prg[0], /* [] */0);
}

function obligations_message(rem) {
  if (rem > 0) {
    if (rem === 1) {
      return Flags$ReactTemplate.if_verbose((function (eta) {
                    return Feedback$ReactTemplate.msg_info(/* None */0, eta);
                  }), Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(rem), Pp$ReactTemplate.str(" obligation remaining")));
    } else {
      return Flags$ReactTemplate.if_verbose((function (eta) {
                    return Feedback$ReactTemplate.msg_info(/* None */0, eta);
                  }), Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(rem), Pp$ReactTemplate.str(" obligations remaining")));
    }
  } else {
    return Flags$ReactTemplate.if_verbose((function (eta) {
                  return Feedback$ReactTemplate.msg_info(/* None */0, eta);
                }), Pp$ReactTemplate.str("No more obligations remaining"));
  }
}

function update_obls(prg, obls, rem) {
  var newrecord = prg.slice();
  newrecord[/* prg_obligations */5] = /* tuple */[
    obls,
    rem
  ];
  progmap_replace(newrecord);
  obligations_message(rem);
  if (rem > 0) {
    return /* Remain */Block.__(0, [rem]);
  } else {
    var l = newrecord[/* prg_deps */6];
    if (l) {
      var progs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
              return get_info(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x, from_prg[0]));
            }), newrecord[/* prg_deps */6]);
      if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (x) {
                var prg = x;
                return +(prg[/* prg_obligations */5][1] === 0);
              }), progs)) {
        var kn = declare_mutual_definition(progs);
        return /* Defined */Block.__(1, [/* ConstRef */Block.__(1, [kn])]);
      } else {
        return /* Dependent */0;
      }
    } else {
      var kn$1 = declare_definition(newrecord);
      progmap_remove(newrecord);
      return /* Defined */Block.__(1, [kn$1]);
    }
  }
}

function is_defined(obls, x) {
  return 1 - Option$ReactTemplate.is_empty(Caml_array.caml_array_get(obls, x)[/* obl_body */3]);
}

function deps_remaining(obls, deps) {
  return Curry._3(Int$ReactTemplate.$$Set[/* fold */13], (function (x, acc) {
                if (is_defined(obls, x)) {
                  return acc;
                } else {
                  return /* :: */[
                          x,
                          acc
                        ];
                }
              }), deps, /* [] */0);
}

function dependencies(obls, n) {
  var res = [Int$ReactTemplate.$$Set[/* empty */0]];
  Util$ReactTemplate.$$Array[/* iteri */13]((function (i, obl) {
          if (i !== n && Curry._2(Int$ReactTemplate.$$Set[/* mem */2], n, obl[/* obl_deps */5])) {
            res[0] = Curry._2(Int$ReactTemplate.$$Set[/* add */3], i, res[0]);
            return /* () */0;
          } else {
            return 0;
          }
        }), obls);
  return res[0];
}

function kind_of_obligation(poly, o) {
  if (o) {
    if (o[0] !== 0) {
      return /* tuple */[
              /* Local */1,
              poly,
              /* Proof */Block.__(1, [/* Lemma */1])
            ];
    } else {
      return /* tuple */[
              /* Local */1,
              poly,
              /* DefinitionBody */Block.__(0, [/* Definition */0])
            ];
    }
  } else {
    return /* tuple */[
            /* Local */1,
            poly,
            /* DefinitionBody */Block.__(0, [/* Definition */0])
          ];
  }
}

var not_transp_msg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Obligation should be transparent but was declared opaque."), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("Use 'Defined' instead."));

function string_of_list(sep, f, param) {
  if (param) {
    var tl = param[1];
    var x = param[0];
    if (tl) {
      return Curry._1(f, x) + (sep + string_of_list(sep, f, tl));
    } else {
      return Curry._1(f, x);
    }
  } else {
    return "";
  }
}

function solve_by_tac(name, evi, t, poly, ctx) {
  var concl = EConstr$ReactTemplate.of_constr(evi[/* evar_concl */0]);
  var match = Pfedit$ReactTemplate.build_constant_by_tactic(name, ctx, evi[/* evar_hyps */1], /* Some */[/* tuple */[
          /* Local */1,
          poly,
          /* DefinitionBody */Block.__(0, [/* Definition */0])
        ]], concl, Tacticals$ReactTemplate.New[/* tclCOMPLETE */31](t));
  var env = Global$ReactTemplate.env(/* () */0);
  var entry = Safe_typing$ReactTemplate.inline_private_constants_in_definition_entry(env, match[0]);
  var match$1 = Future$ReactTemplate.force(entry[/* const_entry_body */0]);
  var body = match$1[0];
  var ctx$prime = Evd$ReactTemplate.merge_context_set(/* None */0, /* Some */[/* true */1], Evd$ReactTemplate.univ_rigid, Evd$ReactTemplate.from_ctx(match[2]), body[1]);
  Inductiveops$ReactTemplate.control_only_guard(env, ctx$prime, EConstr$ReactTemplate.of_constr(body[0]));
  return /* tuple */[
          body[0],
          entry[/* const_entry_type */3],
          Evd$ReactTemplate.evar_universe_context(ctx$prime)
        ];
}

function auto_solve_obligations(n, oblset, tac) {
  Flags$ReactTemplate.if_verbose((function (eta) {
          return Feedback$ReactTemplate.msg_info(/* None */0, eta);
        }), Pp$ReactTemplate.str("Solving obligations automatically..."));
  try {
    return solve_prg_obligations(get_prog_err(n), oblset, tac);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === NoObligations) {
      return /* Dependent */0;
    } else {
      throw exn;
    }
  }
}

function solve_obligation_by_tac(prg, obls, i, tac) {
  var obl = Caml_array.caml_array_get(obls, i);
  var match = obl[/* obl_body */3];
  if (match) {
    return /* None */0;
  } else {
    try {
      if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], deps_remaining(obls, obl[/* obl_deps */5]))) {
        var obl$1 = subst_deps_obl(obls, obl);
        var tac$1;
        if (tac) {
          tac$1 = tac[0];
        } else {
          var match$1 = obl$1[/* obl_tac */6];
          tac$1 = match$1 ? match$1[0] : default_tactic[0];
        }
        var evd = Evd$ReactTemplate.from_ctx(prg[/* prg_ctx */3]);
        var evd$1 = Evd$ReactTemplate.update_sigma_env(evd, Global$ReactTemplate.env(/* () */0));
        var match$2 = solve_by_tac(obl$1[/* obl_name */0], evar_of_obligation(obl$1), tac$1, Util$ReactTemplate.pi2(prg[/* prg_kind */10]), Evd$ReactTemplate.evar_universe_context(evd$1));
        var ctx = match$2[2];
        var uctx = Util$ReactTemplate.pi2(prg[/* prg_kind */10]) ? /* Polymorphic_const_entry */Block.__(1, [UState$ReactTemplate.context(ctx)]) : /* Monomorphic_const_entry */Block.__(0, [UState$ReactTemplate.context_set(ctx)]);
        var newrecord = prg.slice();
        newrecord[/* prg_ctx */3] = ctx;
        var match$3 = declare_obligation(newrecord, obl$1, match$2[0], match$2[1], uctx);
        Caml_array.caml_array_set(obls, i, match$3[1]);
        if (match$3[0] && !Util$ReactTemplate.pi2(newrecord[/* prg_kind */10])) {
          var evd$2 = Evd$ReactTemplate.from_env(Global$ReactTemplate.env(/* () */0));
          var evd$3 = Evd$ReactTemplate.merge_universe_subst(evd$2, Evd$ReactTemplate.universe_subst(Evd$ReactTemplate.from_ctx(ctx)));
          var ctx$prime = Evd$ReactTemplate.evar_universe_context(evd$3);
          var newrecord$1 = newrecord.slice();
          return /* Some */[(newrecord$1[/* prg_ctx */3] = ctx$prime, newrecord$1)];
        } else {
          return /* Some */[newrecord];
        }
      } else {
        return /* None */0;
      }
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (CErrors$ReactTemplate.noncritical(e)) {
        var match$4 = CErrors$ReactTemplate.push(e);
        var e$1 = match$4[0];
        if (e$1[0] === Refiner$ReactTemplate.FailError) {
          var s = e$1[2];
          var tag = s.tag | 0;
          return CErrors$ReactTemplate.user_err(obl[/* obl_location */2][0], /* Some */["solve_obligation"], tag === 250 ? s[0] : (
                        tag === 246 ? CamlinternalLazy.force_lazy_block(s) : s
                      ));
        } else {
          return /* None */0;
        }
      } else {
        throw e;
      }
    }
  }
}

function solve_prg_obligations(prg, oblset, tac) {
  var match = prg[/* prg_obligations */5];
  var obls = match[0];
  var rem = [match[1]];
  var obls$prime = Util$ReactTemplate.$$Array[/* copy */6](obls);
  var set = [Int$ReactTemplate.$$Set[/* empty */0]];
  var p = oblset ? (set[0] = oblset[0], (function (i) {
          return Curry._2(Int$ReactTemplate.$$Set[/* mem */2], i, set[0]);
        })) : (function () {
        return /* true */1;
      });
  var prgref = [prg];
  Util$ReactTemplate.$$Array[/* iteri */13]((function (i, _) {
          if (Curry._1(p, i)) {
            var match = solve_obligation_by_tac(prgref[0], obls$prime, i, tac);
            if (match) {
              prgref[0] = match[0];
              var deps = dependencies(obls, i);
              set[0] = Curry._2(Int$ReactTemplate.$$Set[/* union */6], set[0], deps);
              rem[0] = rem[0] - 1 | 0;
              return /* () */0;
            } else {
              return /* () */0;
            }
          } else {
            return 0;
          }
        }), obls$prime);
  return update_obls(prgref[0], obls$prime, rem[0]);
}

function solve_obligation(prg, num, tac) {
  var user_num = num + 1 | 0;
  var match = prg[/* prg_obligations */5];
  var obls = match[0];
  var obl = Caml_array.caml_array_get(obls, num);
  var remaining = deps_remaining(obls, obl[/* obl_deps */5]);
  if (!Option$ReactTemplate.is_empty(obl[/* obl_body */3])) {
    var cmd = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Obligation"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(user_num)), Pp$ReactTemplate.str("already")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("solved."));
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], cmd);
  }
  if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], remaining)) {
    var cmd$1 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Obligation "), Pp$ReactTemplate.$$int(user_num)), Pp$ReactTemplate.str(" depends on obligation(s) ")), Pp$ReactTemplate.str(string_of_list(", ", (function (x) {
                    return Pervasives.string_of_int(x + 1 | 0);
                  }), remaining)));
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], cmd$1);
  }
  var obl$1 = subst_deps_obl(obls, obl);
  var kind = kind_of_obligation(Util$ReactTemplate.pi2(prg[/* prg_kind */10]), obl$1[/* obl_status */4][1]);
  var evd = Evd$ReactTemplate.from_ctx(prg[/* prg_ctx */3]);
  var evd$1 = Evd$ReactTemplate.update_sigma_env(evd, Global$ReactTemplate.env(/* () */0));
  var auto = function (n, tac, oblset) {
    return auto_solve_obligations(n, /* Some */[oblset], tac);
  };
  var terminator = function (guard, hook) {
    var partial_arg = prg[/* prg_name */0];
    return Proof_global$ReactTemplate.make_terminator((function (param) {
                  var name = partial_arg;
                  var num$1 = num;
                  var guard$1 = guard;
                  var hook$1 = hook;
                  var auto$1 = auto;
                  var pf = param;
                  var term = Lemmas$ReactTemplate.universe_proof_terminator(guard$1, hook$1);
                  if (pf.tag) {
                    var opq = pf[0];
                    var match = Pfedit$ReactTemplate.cook_this_proof(pf[2]);
                    var match$1 = match[1];
                    var env = Global$ReactTemplate.env(/* () */0);
                    var entry = Safe_typing$ReactTemplate.inline_private_constants_in_definition_entry(env, match$1[0]);
                    var ty = entry[/* const_entry_type */3];
                    var match$2 = Future$ReactTemplate.force(entry[/* const_entry_body */0]);
                    var match$3 = match$2[0];
                    var body = match$3[0];
                    var sigma = Evd$ReactTemplate.from_ctx(match$1[1]);
                    var sigma$1 = Evd$ReactTemplate.merge_context_set(/* None */0, /* Some */[/* true */1], Evd$ReactTemplate.univ_rigid, sigma, match$3[1]);
                    Inductiveops$ReactTemplate.control_only_guard(Global$ReactTemplate.env(/* () */0), sigma$1, EConstr$ReactTemplate.of_constr(body));
                    var prg = get_info(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], name, from_prg[0]));
                    var body$1 = EConstr$ReactTemplate.to_constr(sigma$1, EConstr$ReactTemplate.of_constr(body));
                    var ty$1 = Option$ReactTemplate.map((function (x) {
                            return EConstr$ReactTemplate.to_constr(sigma$1, EConstr$ReactTemplate.of_constr(x));
                          }), ty);
                    var ctx = Evd$ReactTemplate.evar_universe_context(sigma$1);
                    var match$4 = prg[/* prg_obligations */5];
                    var rem = match$4[1];
                    var obls = match$4[0];
                    var obl = Caml_array.caml_array_get(obls, num$1);
                    var match$5 = obl[/* obl_status */4];
                    var status;
                    var exit = 0;
                    var status$1 = match$5[1];
                    if (status$1) {
                      if (status$1[0] !== 0) {
                        if (opq !== 0) {
                          status = /* Define */[/* false */0];
                        } else {
                          exit = 1;
                        }
                      } else if (opq !== 0) {
                        status = status$1;
                      } else {
                        exit = 1;
                      }
                    } else if (opq !== 0) {
                      if (opq !== 0) {
                        status = status$1;
                      } else {
                        exit = 1;
                      }
                    } else {
                      status = CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], not_transp_msg);
                    }
                    if (exit === 1) {
                      status = match$5[0] !== 0 ? CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], not_transp_msg) : /* Define */[/* true */1];
                    }
                    var newrecord = obl.slice();
                    newrecord[/* obl_status */4] = /* tuple */[
                      /* false */0,
                      status
                    ];
                    var ctx$1 = Util$ReactTemplate.pi2(prg[/* prg_kind */10]) ? ctx : UState$ReactTemplate.union(prg[/* prg_ctx */3], ctx);
                    var uctx = UState$ReactTemplate.const_univ_entry(Util$ReactTemplate.pi2(prg[/* prg_kind */10]), ctx$1);
                    var match$6 = declare_obligation(prg, newrecord, body$1, ty$1, uctx);
                    var obls$1 = Util$ReactTemplate.$$Array[/* copy */6](obls);
                    Caml_array.caml_array_set(obls$1, num$1, match$6[1]);
                    var prg_ctx = Util$ReactTemplate.pi2(prg[/* prg_kind */10]) ? UState$ReactTemplate.union(prg[/* prg_ctx */3], ctx$1) : UState$ReactTemplate.make(Global$ReactTemplate.universes(/* () */0));
                    var newrecord$1 = prg.slice();
                    newrecord$1[/* prg_ctx */3] = prg_ctx;
                    try {
                      update_obls(newrecord$1, obls$1, rem - 1 | 0);
                      if ((rem - 1 | 0) > 0) {
                        var deps = dependencies(obls$1, num$1);
                        if (Curry._1(Int$ReactTemplate.$$Set[/* is_empty */1], deps)) {
                          return 0;
                        } else {
                          Curry._3(auto$1, /* Some */[name], /* None */0, deps);
                          return /* () */0;
                        }
                      } else {
                        return 0;
                      }
                    }
                    catch (raw_e){
                      var e = Js_exn.internalToOCamlException(raw_e);
                      if (CErrors$ReactTemplate.noncritical(e)) {
                        var e$1 = CErrors$ReactTemplate.push(e);
                        var cmd = CErrors$ReactTemplate.iprint(ExplainErr$ReactTemplate.process_vernac_interp_error(/* None */0, e$1));
                        return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], cmd);
                      } else {
                        throw e;
                      }
                    }
                  } else {
                    return Curry._1(Proof_global$ReactTemplate.apply_terminator(term), pf);
                  }
                }));
  };
  var hook = function (ctx) {
    return Lemmas$ReactTemplate.mk_hook((function (param, param$1) {
                  var prg$1 = prg;
                  var obl$2 = obl$1;
                  var num$1 = num;
                  var auto$1 = auto;
                  var ctx$prime = ctx;
                  var gr = param$1;
                  var match = prg$1[/* prg_obligations */5];
                  var rem = match[1];
                  var cst;
                  if (gr.tag === 1) {
                    cst = gr[0];
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "obligations.ml",
                            893,
                            53
                          ]
                        ];
                  }
                  var transparent = Environ$ReactTemplate.evaluable_constant(cst, Global$ReactTemplate.env(/* () */0));
                  var match$1 = obl$2[/* obl_status */4];
                  if (match$1[0] !== 0) {
                    var match$2 = match$1[1];
                    if (match$2) {
                      if (match$2[0] !== 0 && !transparent) {
                        CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], not_transp_msg);
                      }
                      
                    } else if (transparent) {
                      
                    } else {
                      CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], not_transp_msg);
                    }
                  }
                  var ctx$prime$1 = ctx$prime ? ctx$prime[0] : prg$1[/* prg_ctx */3];
                  var match$3;
                  if (Util$ReactTemplate.pi2(prg$1[/* prg_kind */10])) {
                    var uctx = UState$ReactTemplate.context(ctx$prime$1);
                    match$3 = /* tuple */[
                      Univ$ReactTemplate.UContext[/* instance */3](uctx),
                      ctx$prime$1
                    ];
                  } else {
                    var evd = Evd$ReactTemplate.from_env(Global$ReactTemplate.env(/* () */0));
                    var ctx$prime$2 = Evd$ReactTemplate.merge_universe_subst(evd, Evd$ReactTemplate.universe_subst(Evd$ReactTemplate.from_ctx(ctx$prime$1)));
                    match$3 = /* tuple */[
                      Univ$ReactTemplate.Instance[/* empty */0],
                      Evd$ReactTemplate.evar_universe_context(ctx$prime$2)
                    ];
                  }
                  var newrecord = obl$2.slice();
                  newrecord[/* obl_body */3] = /* Some */[/* DefinedObl */Block.__(0, [/* tuple */[
                          cst,
                          match$3[0]
                        ]])];
                  if (transparent) {
                    add_hint(/* true */1, prg$1, cst);
                  }
                  var obls = Util$ReactTemplate.$$Array[/* copy */6](match[0]);
                  Caml_array.caml_array_set(obls, num$1, newrecord);
                  var newrecord$1 = prg$1.slice();
                  newrecord$1[/* prg_ctx */3] = match$3[1];
                  try {
                    update_obls(newrecord$1, obls, rem - 1 | 0);
                  }
                  catch (raw_e){
                    var e = Js_exn.internalToOCamlException(raw_e);
                    if (CErrors$ReactTemplate.noncritical(e)) {
                      var e$1 = CErrors$ReactTemplate.push(e);
                      var cmd = CErrors$ReactTemplate.iprint(ExplainErr$ReactTemplate.process_vernac_interp_error(/* None */0, e$1));
                      CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], cmd);
                    } else {
                      throw e;
                    }
                  }
                  if ((rem - 1 | 0) > 0) {
                    var deps = dependencies(obls, num$1);
                    if (Curry._1(Int$ReactTemplate.$$Set[/* is_empty */1], deps)) {
                      return 0;
                    } else {
                      Curry._3(auto$1, /* Some */[newrecord$1[/* prg_name */0]], /* None */0, deps);
                      return /* () */0;
                    }
                  } else {
                    return 0;
                  }
                }));
  };
  Lemmas$ReactTemplate.start_proof_univs(obl$1[/* obl_name */0], /* None */0, kind, evd$1, /* Some */[terminator], /* Some */[prg[/* prg_sign */14]], EConstr$ReactTemplate.of_constr(obl$1[/* obl_type */1]), /* None */0, /* None */0, hook);
  Pfedit$ReactTemplate.by(default_tactic[0]);
  return Option$ReactTemplate.iter(Proof_global$ReactTemplate.set_endline_tactic, tac);
}

function solve_obligations(n, tac) {
  var prg = get_prog_err(n);
  return solve_prg_obligations(prg, /* None */0, tac);
}

function obligation(param, tac) {
  var num = param[0] - 1 | 0;
  var prg = get_prog_err(param[1]);
  var match = prg[/* prg_obligations */5];
  var obls = match[0];
  if (num < obls.length) {
    var obl = Caml_array.caml_array_get(obls, num);
    var match$1 = obl[/* obl_body */3];
    if (match$1) {
      var cmd = Pp$ReactTemplate.str("Obligation already solved");
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], cmd);
    } else {
      return solve_obligation(prg, num, tac);
    }
  } else {
    var s = Curry._1(Printf.sprintf(/* Format */[
              /* String_literal */Block.__(11, [
                  "Unknown obligation number ",
                  /* Int */Block.__(4, [
                      /* Int_i */3,
                      /* No_padding */0,
                      /* No_precision */0,
                      /* End_of_format */0
                    ])
                ]),
              "Unknown obligation number %i"
            ]), num + 1 | 0);
    var cmd$1 = Pp$ReactTemplate.str(s);
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Program"], cmd$1);
  }
}

function solve_all_obligations(tac) {
  return Curry._2(Names$ReactTemplate.Id[/* Map */10][/* iter */9], (function (_, v) {
                solve_prg_obligations(get_info(v), /* None */0, tac);
                return /* () */0;
              }), from_prg[0]);
}

function try_solve_obligation(n, prg, tac) {
  var prg$1 = get_prog(prg);
  var match = prg$1[/* prg_obligations */5];
  var obls$prime = Util$ReactTemplate.$$Array[/* copy */6](match[0]);
  var match$1 = solve_obligation_by_tac(prg$1, obls$prime, n, tac);
  if (match$1) {
    update_obls(match$1[0], obls$prime, match[1] - 1 | 0);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function try_solve_obligations(n, tac) {
  try {
    solve_obligations(n, tac);
    return /* () */0;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === NoObligations) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function show_obligations($staropt$star, n) {
  var msg = $staropt$star ? $staropt$star[0] : /* true */1;
  var progs;
  if (n) {
    var n$1 = n[0];
    try {
      progs = /* :: */[
        Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], n$1, from_prg[0]),
        /* [] */0
      ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              NoObligations,
              /* Some */[n$1]
            ];
      } else {
        throw exn;
      }
    }
  } else {
    progs = all_programs(/* () */0);
  }
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (x) {
                var $staropt$star = /* Some */[msg];
                var prg = get_info(x);
                var msg$1 = $staropt$star ? $staropt$star[0] : /* true */1;
                var n = prg[/* prg_name */0];
                var match = prg[/* prg_obligations */5];
                var obls = match[0];
                var showed = [5];
                if (msg$1) {
                  Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$$int(match[1]), Pp$ReactTemplate.str(" obligation(s) remaining: ")));
                }
                return Util$ReactTemplate.$$Array[/* iteri */13]((function (i, x) {
                              var match = x[/* obl_body */3];
                              if (match) {
                                return /* () */0;
                              } else if (showed[0] > 0) {
                                showed[0] = showed[0] - 1 | 0;
                                var x$1 = subst_deps_obl(obls, x);
                                return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Obligation"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(i + 1 | 0)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of")), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](n)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_constr_env(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, x$1[/* obl_type */1]), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)))));
                              } else {
                                return 0;
                              }
                            }), obls);
              }), progs);
}

function show_term(n) {
  var prg = get_prog_err(n);
  var n$1 = prg[/* prg_name */0];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](n$1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), Printer$ReactTemplate.pr_constr_env(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, prg[/* prg_type */2])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":=")), Pp$ReactTemplate.fnl(/* () */0)), Printer$ReactTemplate.pr_constr_env(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, prg[/* prg_body */1]));
}

function add_definition(n, term, t, ctx, $staropt$star, $staropt$star$1, $staropt$star$2, tactic, $staropt$star$3, $staropt$star$4, $staropt$star$5, obls) {
  var univdecl = $staropt$star ? $staropt$star[0] : Univdecls$ReactTemplate.default_univ_decl;
  var implicits = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var kind = $staropt$star$2 ? $staropt$star$2[0] : /* tuple */[
      /* Global */2,
      /* false */0,
      /* Definition */0
    ];
  var reduce$1 = $staropt$star$3 ? $staropt$star$3[0] : reduce;
  var hook = $staropt$star$4 ? $staropt$star$4[0] : Lemmas$ReactTemplate.mk_hook((function (_, _$1, _$2) {
            return /* () */0;
          }));
  var opaque = $staropt$star$5 ? $staropt$star$5[0] : /* false */0;
  var sign = Decls$ReactTemplate.initialize_named_context_for_proof(/* () */0);
  var info = Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](n), Pp$ReactTemplate.str(" has type-checked"));
  var prg = init_prog_info(/* Some */[opaque], sign, n, univdecl, term, t, ctx, /* [] */0, /* None */0, /* [] */0, obls, implicits, kind, reduce$1, hook);
  var match = prg[/* prg_obligations */5];
  var obls$1 = match[0];
  if (obls$1.length) {
    var len = obls$1.length;
    Flags$ReactTemplate.if_verbose((function (eta) {
            return Feedback$ReactTemplate.msg_info(/* None */0, eta);
          }), Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(info, Pp$ReactTemplate.str(", generating ")), Pp$ReactTemplate.$$int(len)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], len, " obligation"))));
    progmap_add(n, CEphemeron$ReactTemplate.create(prg));
    var res = auto_solve_obligations(/* Some */[n], /* None */0, tactic);
    if (typeof res === "number") {
      return res;
    } else if (res.tag) {
      return res;
    } else {
      Flags$ReactTemplate.if_verbose((function () {
              return show_obligations(/* Some */[/* false */0], /* Some */[n]);
            }), /* () */0);
      return res;
    }
  } else {
    Flags$ReactTemplate.if_verbose((function (eta) {
            return Feedback$ReactTemplate.msg_info(/* None */0, eta);
          }), Pp$ReactTemplate.$plus$plus(info, Pp$ReactTemplate.str(".")));
    var cst = declare_definition(prg);
    return /* Defined */Block.__(1, [cst]);
  }
}

function add_mutual_definitions(l, ctx, $staropt$star, tactic, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, notations, fixkind) {
  var univdecl = $staropt$star ? $staropt$star[0] : Univdecls$ReactTemplate.default_univ_decl;
  var kind = $staropt$star$1 ? $staropt$star$1[0] : /* tuple */[
      /* Global */2,
      /* false */0,
      /* Definition */0
    ];
  var reduce$1 = $staropt$star$2 ? $staropt$star$2[0] : reduce;
  var hook = $staropt$star$3 ? $staropt$star$3[0] : Lemmas$ReactTemplate.mk_hook((function (_, _$1, _$2) {
            return /* () */0;
          }));
  var opaque = $staropt$star$4 ? $staropt$star$4[0] : /* false */0;
  var sign = Decls$ReactTemplate.initialize_named_context_for_proof(/* () */0);
  var deps = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return param[0];
        }), l);
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
          var n = param[0];
          var prg = init_prog_info(/* Some */[opaque], sign, n, univdecl, /* Some */[param[1]], param[2], ctx, deps, /* Some */[fixkind], notations, param[4], param[3], kind, reduce$1, hook);
          return progmap_add(n, CEphemeron$ReactTemplate.create(prg));
        }), l);
  Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (finished, x) {
          if (finished) {
            return finished;
          } else {
            var res = auto_solve_obligations(/* Some */[x], /* None */0, tactic);
            if (typeof res === "number" || !res.tag) {
              return /* false */0;
            } else {
              return /* true */1;
            }
          }
        }), /* false */0, deps);
  return /* () */0;
}

function admit_prog(prg) {
  var match = prg[/* prg_obligations */5];
  var obls = Util$ReactTemplate.$$Array[/* copy */6](match[0]);
  Util$ReactTemplate.$$Array[/* iteri */13]((function (i, x) {
          var match = x[/* obl_body */3];
          if (match) {
            return /* () */0;
          } else {
            var x$1 = subst_deps_obl(obls, x);
            var ctx = /* Monomorphic_const_entry */Block.__(0, [UState$ReactTemplate.context_set(prg[/* prg_ctx */3])]);
            var kn = Declare$ReactTemplate.declare_constant(/* None */0, /* Some */[/* true */1], x$1[/* obl_name */0], /* None */0, /* tuple */[
                  /* ParameterEntry */Block.__(1, [/* tuple */[
                        /* None */0,
                        /* tuple */[
                          x$1[/* obl_type */1],
                          ctx
                        ],
                        /* None */0
                      ]]),
                  /* IsAssumption */Block.__(0, [/* Conjectural */2])
                ]);
            Declare$ReactTemplate.assumption_message(x$1[/* obl_name */0]);
            var newrecord = x$1.slice();
            return Caml_array.caml_array_set(obls, i, (newrecord[/* obl_body */3] = /* Some */[/* DefinedObl */Block.__(0, [/* tuple */[
                                kn,
                                Univ$ReactTemplate.Instance[/* empty */0]
                              ]])], newrecord));
          }
        }), obls);
  update_obls(prg, obls, 0);
  return /* () */0;
}

function admit_obligations(n) {
  if (n) {
    return admit_prog(get_prog_err(n));
  } else {
    var _param = /* () */0;
    while(true) {
      var prg;
      try {
        prg = /* Some */[get_any_prog(/* () */0)];
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === NoObligations) {
          prg = /* None */0;
        } else {
          throw exn;
        }
      }
      if (prg) {
        admit_prog(prg[0]);
        _param = /* () */0;
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  }
}

function next_obligation(n, tac) {
  var prg = n ? get_prog_err(n) : get_any_prog_err(/* () */0);
  var match = prg[/* prg_obligations */5];
  var obls = match[0];
  var is_open = function (_, x) {
    if (Option$ReactTemplate.is_empty(x[/* obl_body */3])) {
      return Curry._1(Util$ReactTemplate.List[/* is_empty */45], deps_remaining(obls, x[/* obl_deps */5]));
    } else {
      return /* false */0;
    }
  };
  var match$1 = Util$ReactTemplate.$$Array[/* findi */31](is_open, obls);
  var i = match$1 ? match$1[0] : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Could not find a solvable obligation."));
  return solve_obligation(prg, i, tac);
}

function init_program() {
  Coqlib$ReactTemplate.check_required_library(Coqlib$ReactTemplate.datatypes_module_name);
  Coqlib$ReactTemplate.check_required_library(/* :: */[
        "Coq",
        /* :: */[
          "Init",
          /* :: */[
            "Specif",
            /* [] */0
          ]
        ]
      ]);
  return Coqlib$ReactTemplate.check_required_library(/* :: */[
              "Coq",
              /* :: */[
                "Program",
                /* :: */[
                  "Tactics",
                  /* [] */0
                ]
              ]
            ]);
}

function set_program_mode(c) {
  if (c && !Flags$ReactTemplate.program_mode[0]) {
    init_program(/* () */0);
    Flags$ReactTemplate.program_mode[0] = /* true */1;
    return /* () */0;
  } else {
    return 0;
  }
}

var stm_get_fix_exn = match[1];

var program_tcc_summary_tag = match$1[1];

exports.stm_get_fix_exn = stm_get_fix_exn;
exports.check_evars = check_evars;
exports.evar_dependencies = evar_dependencies;
exports.sort_dependencies = sort_dependencies;
exports.eterm_obligations = eterm_obligations;
exports.default_tactic = default_tactic;
exports.add_definition = add_definition;
exports.add_mutual_definitions = add_mutual_definitions;
exports.obligation = obligation;
exports.next_obligation = next_obligation;
exports.solve_obligations = solve_obligations;
exports.solve_all_obligations = solve_all_obligations;
exports.try_solve_obligation = try_solve_obligation;
exports.try_solve_obligations = try_solve_obligations;
exports.show_obligations = show_obligations;
exports.show_term = show_term;
exports.admit_obligations = admit_obligations;
exports.NoObligations = NoObligations;
exports.explain_no_obligations = explain_no_obligations;
exports.set_program_mode = set_program_mode;
exports.program_tcc_summary_tag = program_tcc_summary_tag;
/* match Not a pure module */
