// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Heads$ReactTemplate = require("./heads.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Typing$ReactTemplate = require("./typing.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Program$ReactTemplate = require("./program.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Classops$ReactTemplate = require("./classops.bs.js");
var Evarconv$ReactTemplate = require("./evarconv.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Evardefine$ReactTemplate = require("./evardefine.bs.js");
var Typeclasses$ReactTemplate = require("./typeclasses.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("./pretype_errors.bs.js");

var use_typeclasses_for_conversion = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"use typeclass resolution during conversion",
      /* optkey : :: */[
        "Typeclass",
        /* :: */[
          "Resolution",
          /* :: */[
            "For",
            /* :: */[
              "Conversion",
              /* [] */0
            ]
          ]
        ]
      ],
      /* optread */(function () {
          return use_typeclasses_for_conversion[0];
        }),
      /* optwrite */(function (b) {
          use_typeclasses_for_conversion[0] = b;
          return /* () */0;
        })
    ]);

var NoCoercion = Caml_exceptions.create("Coercion-ReactTemplate.NoCoercion");

var NoCoercionNoUnifier = Caml_exceptions.create("Coercion-ReactTemplate.NoCoercionNoUnifier");

function apply_coercion_args(env, evd, check, isproj, argl, funj) {
  var evdref = [evd];
  var apply_rec = function (_acc, _typ, _param) {
    while(true) {
      var param = _param;
      var typ = _typ;
      var acc = _acc;
      if (param) {
        var h = param[0];
        var match = EConstr$ReactTemplate.kind(evdref[0], Reductionops$ReactTemplate.whd_all(env)(evdref[0], typ));
        if (match.tag === 6) {
          if (check && !Evarconv$ReactTemplate.e_cumul(env, /* None */0, evdref, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, evdref[0], h), match[1])) {
            throw NoCoercion;
          }
          _param = param[1];
          _typ = EConstr$ReactTemplate.Vars[/* subst1 */4](h, match[2]);
          _acc = /* :: */[
            h,
            acc
          ];
          continue ;
          
        } else {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("apply_coercion_args."));
        }
      } else if (isproj) {
        var cst = EConstr$ReactTemplate.destConst(evdref[0], Environ$ReactTemplate.j_val(funj))[0];
        var p = Names$ReactTemplate.Projection[/* make */0](cst, /* false */0);
        var pb = Environ$ReactTemplate.lookup_projection(p, env);
        var args = Curry._2(Util$ReactTemplate.List[/* skipn */107], pb[/* proj_npars */1], argl);
        var match$1;
        if (args) {
          match$1 = /* tuple */[
            args[0],
            args[1]
          ];
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "coercion.ml",
                  60,
                  57
                ]
              ];
        }
        return /* record */[
                /* uj_val */EConstr$ReactTemplate.applist(/* tuple */[
                      EConstr$ReactTemplate.mkProj(/* tuple */[
                            p,
                            match$1[0]
                          ]),
                      match$1[1]
                    ]),
                /* uj_type */typ
              ];
      } else {
        return /* record */[
                /* uj_val */EConstr$ReactTemplate.applist(/* tuple */[
                      Environ$ReactTemplate.j_val(funj),
                      argl
                    ]),
                /* uj_type */typ
              ];
      }
    };
  };
  var res = apply_rec(/* [] */0, funj[/* uj_type */1], argl);
  return /* tuple */[
          evdref[0],
          res
        ];
}

function inh_pattern_coerce_to(loc, env, pat, ind1, ind2) {
  var p = Classops$ReactTemplate.lookup_pattern_path_between(env, /* tuple */[
        ind1,
        ind2
      ]);
  var loc$1 = loc;
  var pat$1 = pat;
  var p$1 = p;
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (pat, param) {
                var n = param[1];
                var f = function (i) {
                  if (i < n) {
                    return DAst$ReactTemplate.make(loc$1, /* PatVar */Block.__(0, [/* Anonymous */0]));
                  } else {
                    return pat;
                  }
                };
                return DAst$ReactTemplate.make(loc$1, /* PatCstr */Block.__(1, [
                              param[0],
                              Curry._2(Util$ReactTemplate.List[/* init */46], n + 1 | 0, f),
                              /* Anonymous */0
                            ]));
              }), pat$1, p$1);
}

function make_existential(loc, $staropt$star, na, env, evdref, c) {
  var opaque = $staropt$star ? $staropt$star[0] : 1 - Program$ReactTemplate.get_proofs_transparency(/* () */0);
  var src = Loc$ReactTemplate.tag(loc, /* QuestionMark */Block.__(3, [
          /* Define */[opaque],
          na
        ]));
  return Evarutil$ReactTemplate.e_new_evar(env, evdref, /* Some */[src], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, c);
}

function app_opt(_, evdref, f, t) {
  return Reductionops$ReactTemplate.whd_betaiota(evdref[0], Util$ReactTemplate.app_opt(f, t));
}

function pair_of_array(a) {
  return /* tuple */[
          Caml_array.caml_array_get(a, 0),
          Caml_array.caml_array_get(a, 1)
        ];
}

function disc_subset(sigma, x) {
  var match = EConstr$ReactTemplate.kind(sigma, x);
  if (match.tag === 9) {
    var l = match[1];
    var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
    if (match$1.tag === 11) {
      var len = l.length;
      var sigty = Util$ReactTemplate.delayed_force(Program$ReactTemplate.sig_typ);
      if (len === 2 && Names$ReactTemplate.eq_ind(match$1[0][0], Globnames$ReactTemplate.destIndRef(sigty))) {
        var match$2 = pair_of_array(l);
        return /* Some */[/* tuple */[
                  match$2[0],
                  match$2[1]
                ]];
      } else {
        return /* None */0;
      }
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

var NoSubtacCoercion = Caml_exceptions.create("Coercion-ReactTemplate.NoSubtacCoercion");

function lift_args(n, sign) {
  var liftrec = function (k, param) {
    if (param) {
      return /* :: */[
              EConstr$ReactTemplate.Vars[/* liftn */1](n, k, param[0]),
              liftrec(k - 1 | 0, param[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  return liftrec(Curry._1(Util$ReactTemplate.List[/* length */0], sign), sign);
}

function mu(env, evdref, t) {
  var aux = function (v) {
    var v$prime = Reductionops$ReactTemplate.whd_all(env)(evdref[0], v);
    var match = disc_subset(evdref[0], v$prime);
    if (match) {
      var match$1 = match[0];
      var u = match$1[0];
      var match$2 = aux(u);
      var f = match$2[0];
      var p = Reductionops$ReactTemplate.whd_betaiota(evdref[0], match$1[1]);
      return /* tuple */[
              /* Some */[(function (x) {
                    return app_opt(env, evdref, f, Program$ReactTemplate.papp(evdref, Program$ReactTemplate.sig_proj1, /* array */[
                                    u,
                                    p,
                                    x
                                  ]));
                  })],
              match$2[1]
            ];
    } else {
      return /* tuple */[
              /* None */0,
              v
            ];
    }
  };
  return aux(t);
}

function coerce(loc, env, evdref, x, y) {
  var coerce_unify = function (env, x, y) {
    var x$1 = Reductionops$ReactTemplate.whd_all(env)(evdref[0], x);
    var y$1 = Reductionops$ReactTemplate.whd_all(env)(evdref[0], y);
    try {
      evdref[0] = Evarconv$ReactTemplate.the_conv_x_leq(env, /* None */0, x$1, y$1, evdref[0]);
      return /* None */0;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Evarconv$ReactTemplate.UnableToUnify) {
        var env$1 = env;
        var x$2 = x$1;
        var y$2 = y$1;
        var subco = function () {
          var env$2 = env$1;
          var evdref$1 = evdref;
          var x$3 = x$2;
          var y$3 = y$2;
          var match = disc_subset(evdref$1[0], x$3);
          if (match) {
            var match$1 = match[0];
            var p = match$1[1];
            var u = match$1[0];
            var c = coerce_unify(env$2, u, y$3);
            var f = function (x) {
              return app_opt(env$2, evdref$1, c, Program$ReactTemplate.papp(evdref$1, Program$ReactTemplate.sig_proj1, /* array */[
                              u,
                              p,
                              x
                            ]));
            };
            return /* Some */[f];
          } else {
            var match$2 = disc_subset(evdref$1[0], y$3);
            if (match$2) {
              var match$3 = match$2[0];
              var p$1 = match$3[1];
              var u$1 = match$3[0];
              var c$1 = coerce_unify(env$2, x$3, u$1);
              return /* Some */[(function (x) {
                          var cx = app_opt(env$2, evdref$1, c$1, x);
                          var evar = make_existential(loc, /* None */0, /* Anonymous */0, env$2, evdref$1, EConstr$ReactTemplate.mkApp(/* tuple */[
                                    p$1,
                                    /* array */[cx]
                                  ]));
                          return Program$ReactTemplate.papp(evdref$1, Program$ReactTemplate.sig_intro, /* array */[
                                      u$1,
                                      p$1,
                                      cx,
                                      evar
                                    ]);
                        })];
            } else {
              throw NoSubtacCoercion;
            }
          }
        };
        var dest_prod = function (c) {
          var match = Reductionops$ReactTemplate.splay_prod_n(env$1, evdref[0], 1)(c);
          var match$1 = match[0];
          if (match$1) {
            var match$2 = match$1[0];
            var exit = 0;
            var na;
            var t;
            na = match$2[0];
            if (match$2.tag) {
              t = match$2[2];
              exit = 1;
            } else {
              t = match$2[1];
              exit = 1;
            }
            if (exit === 1) {
              if (match$1[1]) {
                throw NoSubtacCoercion;
              } else {
                return /* tuple */[
                        /* tuple */[
                          na,
                          t
                        ],
                        match[1]
                      ];
              }
            }
            
          } else {
            throw NoSubtacCoercion;
          }
        };
        var coerce_application = function (typ, typ$prime, c, c$prime, l, l$prime) {
          var len = l.length;
          var aux = function (_tele, _typ, _typ$prime, _i, _co) {
            while(true) {
              var co = _co;
              var i = _i;
              var typ$prime = _typ$prime;
              var typ = _typ;
              var tele = _tele;
              if (i < len) {
                var hdx = Caml_array.caml_array_get(l, i);
                var hdy = Caml_array.caml_array_get(l$prime, i);
                try {
                  evdref[0] = Evarconv$ReactTemplate.the_conv_x_leq(env$1, /* None */0, hdx, hdy, evdref[0]);
                  var match = dest_prod(typ);
                  var match$1 = dest_prod(typ$prime);
                  return aux(/* :: */[
                              hdx,
                              tele
                            ], EConstr$ReactTemplate.Vars[/* subst1 */4](hdx, match[1]), EConstr$ReactTemplate.Vars[/* subst1 */4](hdy, match$1[1]), i + 1 | 0, co);
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === Evarconv$ReactTemplate.UnableToUnify) {
                    var match$2 = dest_prod(typ);
                    var match$3 = match$2[0];
                    var eqT = match$3[1];
                    var n = match$3[0];
                    var match$4 = dest_prod(typ$prime);
                    try {
                      evdref[0] = Evarconv$ReactTemplate.the_conv_x_leq(env$1, /* None */0, eqT, match$4[0][1], evdref[0]);
                    }
                    catch (raw_exn$1){
                      var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
                      if (exn$1[0] === Evarconv$ReactTemplate.UnableToUnify) {
                        throw NoSubtacCoercion;
                      } else {
                        throw exn$1;
                      }
                    }
                    if (Reductionops$ReactTemplate.is_arity(env$1, evdref[0], eqT)) {
                      throw NoSubtacCoercion;
                    }
                    var restargs = lift_args(1, Curry._1(Util$ReactTemplate.List[/* rev */4], Util$ReactTemplate.$$Array[/* to_list */9](Util$ReactTemplate.$$Array[/* sub */5](l, i + 1 | 0, len - (i + 1 | 0) | 0))));
                    var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
                    var args = Curry._1(Util$ReactTemplate.List[/* rev */4], Util$ReactTemplate.$at(restargs, /* :: */[
                              EConstr$ReactTemplate.mkRel(1),
                              Curry._2(Util$ReactTemplate.List[/* map */10], (function(partial_arg){
                                  return function (param) {
                                    return partial_arg(1, param);
                                  }
                                  }(partial_arg)), tele)
                            ]));
                    var pred = EConstr$ReactTemplate.mkLambda(/* tuple */[
                          n,
                          eqT,
                          EConstr$ReactTemplate.applist(/* tuple */[
                                EConstr$ReactTemplate.Vars[/* lift */0](1, c),
                                args
                              ])
                        ]);
                    var eq = Program$ReactTemplate.papp(evdref, Program$ReactTemplate.coq_eq_ind, /* array */[
                          eqT,
                          hdx,
                          hdy
                        ]);
                    var evar = make_existential(loc, /* None */0, n, env$1, evdref, eq);
                    _co = (function(co,hdx,hdy,eqT,pred,evar){
                    return function (x) {
                      var x$1 = Curry._1(co, x);
                      return Program$ReactTemplate.papp(evdref, Program$ReactTemplate.coq_eq_rect, /* array */[
                                  eqT,
                                  hdx,
                                  pred,
                                  x$1,
                                  hdy,
                                  evar
                                ]);
                    }
                    }(co,hdx,hdy,eqT,pred,evar));
                    _i = i + 1 | 0;
                    _typ$prime = EConstr$ReactTemplate.Vars[/* subst1 */4](hdy, match$4[1]);
                    _typ = EConstr$ReactTemplate.Vars[/* subst1 */4](hdx, match$2[1]);
                    _tele = /* :: */[
                      hdy,
                      tele
                    ];
                    continue ;
                    
                  } else {
                    throw exn;
                  }
                }
              } else {
                return /* Some */[(function(co){
                        return function (x) {
                          var term = Curry._1(co, x);
                          return Typing$ReactTemplate.e_solve_evars(env$1, evdref, term);
                        }
                        }(co))];
              }
            };
          };
          if (EConstr$ReactTemplate.isEvar(evdref[0], c) || EConstr$ReactTemplate.isEvar(evdref[0], c$prime) || !Program$ReactTemplate.is_program_generalized_coercion(/* () */0)) {
            throw NoSubtacCoercion;
          }
          return aux(/* [] */0, typ, typ$prime, 0, (function (x) {
                        return x;
                      }));
        };
        var match = EConstr$ReactTemplate.kind(evdref[0], x$2);
        var match$1 = EConstr$ReactTemplate.kind(evdref[0], y$2);
        switch (match.tag | 0) {
          case 4 : 
              if (match$1.tag === 4) {
                var match$2 = EConstr$ReactTemplate.ESorts[/* kind */1](evdref[0], match[0]);
                var match$3 = EConstr$ReactTemplate.ESorts[/* kind */1](evdref[0], match$1[0]);
                if (match$2.tag) {
                  if (!match$3.tag || !Univ$ReactTemplate.Universe[/* equal */1](match$2[0], match$3[0])) {
                    return subco(/* () */0);
                  } else {
                    return /* None */0;
                  }
                } else if (!match$3.tag && match$2[0] !== match$3[0]) {
                  return subco(/* () */0);
                } else {
                  return /* None */0;
                }
              } else {
                return subco(/* () */0);
              }
              break;
          case 6 : 
              if (match$1.tag === 6) {
                var a$prime = match$1[1];
                var name$prime = /* Name */[Namegen$ReactTemplate.next_ident_away(Namegen$ReactTemplate.default_dependent_ident, Termops$ReactTemplate.vars_of_env(env$1))];
                var env$prime = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                        name$prime,
                        a$prime
                      ]), env$1);
                var c1 = coerce_unify(env$prime, EConstr$ReactTemplate.Vars[/* lift */0](1, a$prime), EConstr$ReactTemplate.Vars[/* lift */0](1, match[1]));
                var coec1 = app_opt(env$prime, evdref, c1, EConstr$ReactTemplate.mkRel(1));
                var c2 = coerce_unify(env$prime, EConstr$ReactTemplate.Vars[/* subst1 */4](coec1, EConstr$ReactTemplate.Vars[/* liftn */1](1, 2, match[2])), match$1[2]);
                var exit = 0;
                if (c1) {
                  exit = 1;
                } else if (c2) {
                  exit = 1;
                } else {
                  return /* None */0;
                }
                if (exit === 1) {
                  return /* Some */[(function (f) {
                              return EConstr$ReactTemplate.mkLambda(/* tuple */[
                                          name$prime,
                                          a$prime,
                                          app_opt(env$prime, evdref, c2, EConstr$ReactTemplate.mkApp(/* tuple */[
                                                    EConstr$ReactTemplate.Vars[/* lift */0](1, f),
                                                    /* array */[coec1]
                                                  ]))
                                        ]);
                            })];
                }
                
              } else {
                return subco(/* () */0);
              }
              break;
          case 9 : 
              if (match$1.tag === 9) {
                var l$prime = match$1[1];
                var c$prime = match$1[0];
                var l = match[1];
                var c = match[0];
                var match$4 = EConstr$ReactTemplate.kind(evdref[0], c);
                var match$5 = EConstr$ReactTemplate.kind(evdref[0], c$prime);
                var exit$1 = 0;
                if (match$4.tag === 11) {
                  if (match$5.tag === 11) {
                    var i$prime = match$5[0][0];
                    var i = match$4[0][0];
                    var len = l.length;
                    var sigT = Util$ReactTemplate.delayed_force(Program$ReactTemplate.sigT_typ);
                    var prod = Util$ReactTemplate.delayed_force(Program$ReactTemplate.prod_typ);
                    if (len === l$prime.length && len === 2 && Names$ReactTemplate.eq_ind(i, i$prime) && (Names$ReactTemplate.eq_ind(i, Globnames$ReactTemplate.destIndRef(sigT)) || Names$ReactTemplate.eq_ind(i, Globnames$ReactTemplate.destIndRef(prod)))) {
                      if (Names$ReactTemplate.eq_ind(i, Globnames$ReactTemplate.destIndRef(sigT))) {
                        var match_000 = pair_of_array(l);
                        var match_001 = pair_of_array(l$prime);
                        var match$6 = match_001;
                        var a$prime$1 = match$6[0];
                        var match$7 = match_000;
                        var a = match$7[0];
                        var c1$1 = coerce_unify(env$1, a, a$prime$1);
                        var remove_head = function (a, c) {
                          var match = EConstr$ReactTemplate.kind(evdref[0], c);
                          switch (match.tag | 0) {
                            case 3 : 
                                var match$1 = match[0];
                                var match$2 = Evardefine$ReactTemplate.define_evar_as_lambda(env$1, evdref[0], /* tuple */[
                                      match$1[0],
                                      match$1[1]
                                    ]);
                                var t = match$2[1];
                                evdref[0] = match$2[0];
                                var match$3 = EConstr$ReactTemplate.destLambda(evdref[0], t);
                                var dom = match$3[1];
                                if (EConstr$ReactTemplate.isEvar(evdref[0], dom)) {
                                  var match$4 = EConstr$ReactTemplate.destEvar(evdref[0], dom);
                                  evdref[0] = Evd$ReactTemplate.define(match$4[0], EConstr$ReactTemplate.Unsafe[/* to_constr */0](a), evdref[0]);
                                }
                                return /* tuple */[
                                        t,
                                        match$3[2]
                                      ];
                            case 7 : 
                                return /* tuple */[
                                        c,
                                        match[2]
                                      ];
                            default:
                              throw NoSubtacCoercion;
                          }
                        };
                        var match_000$1 = remove_head(a, match$7[1]);
                        var match_001$1 = remove_head(a$prime$1, match$6[1]);
                        var match$8 = match_001$1;
                        var pb$prime = match$8[0];
                        var match$9 = match_000$1;
                        var pb = match$9[0];
                        var env$prime$1 = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                /* Name */[Namegen$ReactTemplate.default_dependent_ident],
                                a
                              ]), env$1);
                        var c2$1 = coerce_unify(env$prime$1, match$9[1], match$8[1]);
                        var exit$2 = 0;
                        if (c1$1) {
                          exit$2 = 2;
                        } else if (c2$1) {
                          exit$2 = 2;
                        } else {
                          return /* None */0;
                        }
                        if (exit$2 === 2) {
                          return /* Some */[(function (x) {
                                      var x$1 = app_opt(env$prime$1, evdref, c1$1, Program$ReactTemplate.papp(evdref, Program$ReactTemplate.sigT_proj1, /* array */[
                                                a,
                                                pb,
                                                x
                                              ]));
                                      var y = app_opt(env$prime$1, evdref, c2$1, Program$ReactTemplate.papp(evdref, Program$ReactTemplate.sigT_proj2, /* array */[
                                                a,
                                                pb,
                                                x
                                              ]));
                                      return Program$ReactTemplate.papp(evdref, Program$ReactTemplate.sigT_intro, /* array */[
                                                  a$prime$1,
                                                  pb$prime,
                                                  x$1,
                                                  y
                                                ]);
                                    })];
                        }
                        
                      } else {
                        var match_000$2 = pair_of_array(l);
                        var match_001$2 = pair_of_array(l$prime);
                        var match$10 = match_001$2;
                        var b$prime = match$10[1];
                        var a$prime$2 = match$10[0];
                        var match$11 = match_000$2;
                        var b = match$11[1];
                        var a$1 = match$11[0];
                        var c1$2 = coerce_unify(env$1, a$1, a$prime$2);
                        var c2$2 = coerce_unify(env$1, b, b$prime);
                        var exit$3 = 0;
                        if (c1$2) {
                          exit$3 = 2;
                        } else if (c2$2) {
                          exit$3 = 2;
                        } else {
                          return /* None */0;
                        }
                        if (exit$3 === 2) {
                          return /* Some */[(function (x) {
                                      var x$1 = app_opt(env$1, evdref, c1$2, Program$ReactTemplate.papp(evdref, Program$ReactTemplate.prod_proj1, /* array */[
                                                a$1,
                                                b,
                                                x
                                              ]));
                                      var y = app_opt(env$1, evdref, c2$2, Program$ReactTemplate.papp(evdref, Program$ReactTemplate.prod_proj2, /* array */[
                                                a$1,
                                                b,
                                                x
                                              ]));
                                      return Program$ReactTemplate.papp(evdref, Program$ReactTemplate.prod_intro, /* array */[
                                                  a$prime$2,
                                                  b$prime,
                                                  x$1,
                                                  y
                                                ]);
                                    })];
                        }
                        
                      }
                    } else if (Names$ReactTemplate.eq_ind(i, i$prime) && len === l$prime.length) {
                      var evm = evdref[0];
                      try {
                        return subco(/* () */0);
                      }
                      catch (exn$1){
                        if (exn$1 === NoSubtacCoercion) {
                          var typ = Typing$ReactTemplate.unsafe_type_of(env$1, evm, c);
                          var typ$prime = Typing$ReactTemplate.unsafe_type_of(env$1, evm, c$prime);
                          return coerce_application(typ, typ$prime, c, c$prime, l, l$prime);
                        } else {
                          throw exn$1;
                        }
                      }
                    } else {
                      return subco(/* () */0);
                    }
                  } else {
                    exit$1 = 1;
                  }
                } else {
                  exit$1 = 1;
                }
                if (exit$1 === 1) {
                  if (EConstr$ReactTemplate.eq_constr(evdref[0], c, c$prime)) {
                    if (l.length === l$prime.length) {
                      var evm$1 = evdref[0];
                      var lam_type = Typing$ReactTemplate.unsafe_type_of(env$1, evm$1, c);
                      var lam_type$prime = Typing$ReactTemplate.unsafe_type_of(env$1, evm$1, c$prime);
                      return coerce_application(lam_type, lam_type$prime, c, c$prime, l, l$prime);
                    } else {
                      return subco(/* () */0);
                    }
                  } else {
                    return subco(/* () */0);
                  }
                }
                
              } else {
                return subco(/* () */0);
              }
              break;
          default:
            return subco(/* () */0);
        }
      } else {
        throw exn;
      }
    }
  };
  return coerce_unify(env, x, y);
}

function app_coercion(env, evdref, coercion, v) {
  if (coercion) {
    var v$prime = Typing$ReactTemplate.e_solve_evars(env, evdref, Curry._1(coercion[0], v));
    return Reductionops$ReactTemplate.whd_betaiota(evdref[0], v$prime);
  } else {
    return v;
  }
}

function coerce_itf(loc, env, evd, v, t, c1) {
  var evdref = [evd];
  var coercion = coerce(loc, env, evdref, t, c1);
  var t$1 = Option$ReactTemplate.map((function (param) {
          return app_coercion(env, evdref, coercion, param);
        }), v);
  return /* tuple */[
          evdref[0],
          t$1
        ];
}

function saturate_evd(env, evd) {
  return Typeclasses$ReactTemplate.resolve_typeclasses(/* None */0, /* Some */[Typeclasses$ReactTemplate.no_goals], /* None */0, /* Some */[/* true */1], /* Some */[/* false */0], env, evd);
}

function apply_coercion(env, sigma, p, hj, typ_cl) {
  try {
    var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, i) {
            var ja = param[0];
            var match = Classops$ReactTemplate.coercion_value(i);
            var match$1 = match[0];
            var sigma = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible, param[2], match[1]);
            var argl = Util$ReactTemplate.$at(Classops$ReactTemplate.class_args_of(env, sigma, param[1]), /* :: */[
                  ja[/* uj_val */0],
                  /* [] */0
                ]);
            var match$2 = apply_coercion_args(env, sigma, /* true */1, match$1[2], argl, match$1[0]);
            var jres = match$2[1];
            return /* tuple */[
                    match$1[1] ? /* record */[
                        /* uj_val */ja[/* uj_val */0],
                        /* uj_type */jres[/* uj_type */1]
                      ] : jres,
                    jres[/* uj_type */1],
                    match$2[0]
                  ];
          }), /* tuple */[
          hj,
          typ_cl,
          sigma
        ], p);
    return /* tuple */[
            match[2],
            match[0]
          ];
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (e === NoCoercion) {
      throw e;
    } else if (CErrors$ReactTemplate.noncritical(e)) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("apply_coercion."));
    } else {
      throw e;
    }
  }
}

function inh_app_fun_core(env, evd, j) {
  var t = Reductionops$ReactTemplate.whd_all(env)(evd, j[/* uj_type */1]);
  var match = EConstr$ReactTemplate.kind(evd, t);
  switch (match.tag | 0) {
    case 3 : 
        var match$1 = Evardefine$ReactTemplate.define_evar_as_product(evd, match[0]);
        return /* tuple */[
                match$1[0],
                /* record */[
                  /* uj_val */j[/* uj_val */0],
                  /* uj_type */match$1[1]
                ]
              ];
    case 6 : 
        return /* tuple */[
                evd,
                j
              ];
    default:
      try {
        var match$2 = Classops$ReactTemplate.lookup_path_to_fun_from(env, evd, j[/* uj_type */1]);
        return apply_coercion(env, evd, match$2[1], j, match$2[0]);
      }
      catch (exn){
        var exit = 0;
        if (exn === Caml_builtin_exceptions.not_found) {
          exit = 1;
        } else if (exn === NoCoercion) {
          exit = 1;
        } else {
          throw exn;
        }
        if (exit === 1) {
          if (Flags$ReactTemplate.is_program_mode(/* () */0)) {
            try {
              var evdref = [evd];
              var match$3 = mu(env, evdref, t);
              var res_000 = /* uj_val */app_opt(env, evdref, match$3[0], j[/* uj_val */0]);
              var res_001 = /* uj_type */match$3[1];
              var res = /* record */[
                res_000,
                res_001
              ];
              return /* tuple */[
                      evdref[0],
                      res
                    ];
            }
            catch (exn$1){
              if (exn$1 === NoSubtacCoercion) {
                return /* tuple */[
                        evd,
                        j
                      ];
              } else if (exn$1 === NoCoercion) {
                return /* tuple */[
                        evd,
                        j
                      ];
              } else {
                throw exn$1;
              }
            }
          } else {
            throw NoCoercion;
          }
        }
        
      }
  }
}

function inh_app_fun(resolve_tc, env, evd, j) {
  try {
    return inh_app_fun_core(env, evd, j);
  }
  catch (exn){
    if (exn === NoCoercion) {
      if (!resolve_tc || !use_typeclasses_for_conversion[0]) {
        return /* tuple */[
                evd,
                j
              ];
      } else {
        try {
          return inh_app_fun_core(env, saturate_evd(env, evd), j);
        }
        catch (exn$1){
          if (exn$1 === NoCoercion) {
            return /* tuple */[
                    evd,
                    j
                  ];
          } else {
            throw exn$1;
          }
        }
      }
    } else {
      throw exn;
    }
  }
}

function type_judgment(env, sigma, j) {
  var match = EConstr$ReactTemplate.kind(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, j[/* uj_type */1]));
  if (match.tag === 4) {
    return /* record */[
            /* utj_val */j[/* uj_val */0],
            /* utj_type */EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0])
          ];
  } else {
    return Pretype_errors$ReactTemplate.error_not_a_type(/* None */0, env, sigma, j);
  }
}

function inh_coerce_to_sort(loc, env, evd, j) {
  var typ = Reductionops$ReactTemplate.whd_all(env)(evd, j[/* uj_type */1]);
  var match = EConstr$ReactTemplate.kind(evd, typ);
  switch (match.tag | 0) {
    case 3 : 
        var match$1 = Evardefine$ReactTemplate.define_evar_as_sort(env, evd, match[0]);
        return /* tuple */[
                match$1[0],
                /* record */[
                  /* utj_val */j[/* uj_val */0],
                  /* utj_type */match$1[1]
                ]
              ];
    case 4 : 
        return /* tuple */[
                evd,
                /* record */[
                  /* utj_val */j[/* uj_val */0],
                  /* utj_type */EConstr$ReactTemplate.ESorts[/* kind */1](evd, match[0])
                ]
              ];
    default:
      var loc$1 = loc;
      var env$1 = env;
      var evd$1 = evd;
      var j$1 = j;
      try {
        var match$2 = Classops$ReactTemplate.lookup_path_to_sort_from(env$1, evd$1, j$1[/* uj_type */1]);
        var match$3 = apply_coercion(env$1, evd$1, match$2[1], j$1, match$2[0]);
        var evd$2 = match$3[0];
        var j2 = Termops$ReactTemplate.on_judgment_type((function (param) {
                return Evarutil$ReactTemplate.whd_evar(evd$2, param);
              }), match$3[1]);
        return /* tuple */[
                evd$2,
                type_judgment(env$1, evd$2, j2)
              ];
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return Pretype_errors$ReactTemplate.error_not_a_type(loc$1, env$1, evd$1, j$1);
        } else if (exn === NoCoercion) {
          return Pretype_errors$ReactTemplate.error_not_a_type(loc$1, env$1, evd$1, j$1);
        } else {
          throw exn;
        }
      }
  }
}

function inh_coerce_to_base(_, env, evd, j) {
  if (Flags$ReactTemplate.is_program_mode(/* () */0)) {
    var evdref = [evd];
    var match = mu(env, evdref, j[/* uj_type */1]);
    var res_000 = /* uj_val */app_coercion(env, evdref, match[0], j[/* uj_val */0]);
    var res_001 = /* uj_type */match[1];
    var res = /* record */[
      res_000,
      res_001
    ];
    return /* tuple */[
            evdref[0],
            res
          ];
  } else {
    return /* tuple */[
            evd,
            j
          ];
  }
}

function inh_coerce_to_prod(_, env, evd, t) {
  if (Flags$ReactTemplate.is_program_mode(/* () */0)) {
    var evdref = [evd];
    var match = mu(env, evdref, t);
    return /* tuple */[
            evdref[0],
            match[1]
          ];
  } else {
    return /* tuple */[
            evd,
            t
          ];
  }
}

function inh_conv_coerce_to_fail(loc, env, evd, rigidonly, v, t, c1) {
  try {
    return /* tuple */[
            Evarconv$ReactTemplate.the_conv_x_leq(env, /* None */0, t, c1, evd),
            v
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Evarconv$ReactTemplate.UnableToUnify) {
      var e = exn[2];
      var best_failed_evd = exn[1];
      try {
        var env$1 = env;
        var evd$1 = evd;
        var rigidonly$1 = rigidonly;
        var v$1 = v;
        var t$1 = t;
        var c1$1 = c1;
        if (rigidonly$1 && !(Heads$ReactTemplate.is_rigid(env$1, EConstr$ReactTemplate.Unsafe[/* to_constr */0](c1$1)) && Heads$ReactTemplate.is_rigid(env$1, EConstr$ReactTemplate.Unsafe[/* to_constr */0](t$1)))) {
          throw NoCoercion;
        } else {
          var match;
          try {
            var match$1 = Classops$ReactTemplate.lookup_path_between(env$1, evd$1, /* tuple */[
                  t$1,
                  c1$1
                ]);
            if (v$1) {
              var match$2 = apply_coercion(env$1, evd$1, match$1[2], /* record */[
                    /* uj_val */v$1[0],
                    /* uj_type */t$1
                  ], match$1[0]);
              var j = match$2[1];
              match = /* tuple */[
                match$2[0],
                /* Some */[j[/* uj_val */0]],
                j[/* uj_type */1]
              ];
            } else {
              match = /* tuple */[
                evd$1,
                /* None */0,
                t$1
              ];
            }
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              throw NoCoercion;
            } else {
              throw exn$1;
            }
          }
          try {
            return /* tuple */[
                    Evarconv$ReactTemplate.the_conv_x_leq(env$1, /* None */0, match[2], c1$1, match[0]),
                    match[1]
                  ];
          }
          catch (raw_exn$1){
            var exn$2 = Js_exn.internalToOCamlException(raw_exn$1);
            if (exn$2[0] === Evarconv$ReactTemplate.UnableToUnify) {
              throw NoCoercion;
            } else {
              throw exn$2;
            }
          }
        }
      }
      catch (exn$3){
        if (exn$3 === NoCoercion) {
          var match$3 = EConstr$ReactTemplate.kind(evd, Reductionops$ReactTemplate.whd_all(env)(evd, t));
          var match$4 = EConstr$ReactTemplate.kind(evd, Reductionops$ReactTemplate.whd_all(env)(evd, c1));
          if (match$3.tag === 6) {
            if (match$4.tag === 6) {
              var u1 = match$4[1];
              var name = match$3[0];
              var name$1 = name ? name : /* Name */[Namegen$ReactTemplate.default_dependent_ident];
              var env1 = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      name$1,
                      u1
                    ]), env);
              var match$5 = inh_conv_coerce_to_fail(loc, env1, evd, rigidonly, /* Some */[EConstr$ReactTemplate.mkRel(1)], EConstr$ReactTemplate.Vars[/* lift */0](1, u1), EConstr$ReactTemplate.Vars[/* lift */0](1, match$3[1]));
              var evd$prime = match$5[0];
              var v1 = Option$ReactTemplate.get(match$5[1]);
              var v2 = Option$ReactTemplate.map((function (v) {
                      return Reductionops$ReactTemplate.beta_applist(evd$prime, /* tuple */[
                                  EConstr$ReactTemplate.Vars[/* lift */0](1, v),
                                  /* :: */[
                                    v1,
                                    /* [] */0
                                  ]
                                ]);
                    }), v);
              var t2 = v2 ? Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env1, evd$prime, v2[0]) : Termops$ReactTemplate.subst_term(evd$prime, v1, match$3[2]);
              var match$6 = inh_conv_coerce_to_fail(loc, env1, evd$prime, rigidonly, v2, t2, match$4[2]);
              return /* tuple */[
                      match$6[0],
                      Option$ReactTemplate.map((function (v2$prime) {
                              return EConstr$ReactTemplate.mkLambda(/* tuple */[
                                          name$1,
                                          u1,
                                          v2$prime
                                        ]);
                            }), match$6[1])
                    ];
            } else {
              throw [
                    NoCoercionNoUnifier,
                    best_failed_evd,
                    e
                  ];
            }
          } else {
            throw [
                  NoCoercionNoUnifier,
                  best_failed_evd,
                  e
                ];
          }
        } else {
          throw exn$3;
        }
      }
    } else {
      throw exn;
    }
  }
}

function inh_conv_coerce_to_gen(loc, resolve_tc, rigidonly, env, evd, cj, t) {
  var match;
  try {
    match = inh_conv_coerce_to_fail(loc, env, evd, rigidonly, /* Some */[cj[/* uj_val */0]], cj[/* uj_type */1], t);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === NoCoercionNoUnifier) {
      var e = exn[2];
      var best_failed_evd = exn[1];
      try {
        if (Flags$ReactTemplate.is_program_mode(/* () */0)) {
          match = coerce_itf(loc, env, evd, /* Some */[cj[/* uj_val */0]], cj[/* uj_type */1], t);
        } else {
          throw NoSubtacCoercion;
        }
      }
      catch (exn$1){
        if (exn$1 === NoSubtacCoercion) {
          if (!resolve_tc || !use_typeclasses_for_conversion[0]) {
            match = Pretype_errors$ReactTemplate.error_actual_type(loc, env, best_failed_evd, cj, t, e);
          } else {
            var evd$prime = saturate_evd(env, evd);
            try {
              match = evd$prime === evd ? Pretype_errors$ReactTemplate.error_actual_type(loc, env, best_failed_evd, cj, t, e) : inh_conv_coerce_to_fail(loc, env, evd$prime, rigidonly, /* Some */[cj[/* uj_val */0]], cj[/* uj_type */1], t);
            }
            catch (raw_exn$1){
              var exn$2 = Js_exn.internalToOCamlException(raw_exn$1);
              if (exn$2[0] === NoCoercionNoUnifier) {
                match = Pretype_errors$ReactTemplate.error_actual_type(loc, env, best_failed_evd, cj, t, e);
              } else {
                throw exn$2;
              }
            }
          }
        } else {
          throw exn$1;
        }
      }
    } else {
      throw exn;
    }
  }
  var val$prime = match[1];
  var val$prime$1;
  if (val$prime) {
    val$prime$1 = val$prime[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "coercion.ml",
            525,
            51
          ]
        ];
  }
  return /* tuple */[
          match[0],
          /* record */[
            /* uj_val */val$prime$1,
            /* uj_type */t
          ]
        ];
}

function inh_conv_coerce_to(loc, resolve_tc) {
  return (function (param, param$1, param$2, param$3) {
      return inh_conv_coerce_to_gen(loc, resolve_tc, /* false */0, param, param$1, param$2, param$3);
    });
}

function inh_conv_coerce_rigid_to(loc, resolve_tc) {
  return (function (param, param$1, param$2, param$3) {
      return inh_conv_coerce_to_gen(loc, resolve_tc, /* true */1, param, param$1, param$2, param$3);
    });
}

function inh_conv_coerces_to(loc, env, evd, t, t$prime) {
  try {
    return inh_conv_coerce_to_fail(loc, env, evd, /* true */1, /* None */0, t, t$prime)[0];
  }
  catch (exn){
    if (exn === NoCoercion) {
      return evd;
    } else {
      throw exn;
    }
  }
}

exports.inh_app_fun = inh_app_fun;
exports.inh_coerce_to_sort = inh_coerce_to_sort;
exports.inh_coerce_to_base = inh_coerce_to_base;
exports.inh_coerce_to_prod = inh_coerce_to_prod;
exports.inh_conv_coerce_to = inh_conv_coerce_to;
exports.inh_conv_coerce_rigid_to = inh_conv_coerce_rigid_to;
exports.inh_conv_coerces_to = inh_conv_coerces_to;
exports.inh_pattern_coerce_to = inh_pattern_coerce_to;
/*  Not a pure module */
