// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function universes_of_constr(env, c) {
  var aux = function (s, c) {
    var match = Constr$ReactTemplate.kind(c);
    var exit = 0;
    var mind;
    var u;
    switch (match.tag | 0) {
      case 4 : 
          var u$1 = match[0];
          if (Sorts$ReactTemplate.is_small(u$1)) {
            return Constr$ReactTemplate.fold(aux, s, c);
          } else {
            var u$2 = Sorts$ReactTemplate.univ_of_sort(u$1);
            return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], Univ$ReactTemplate.LSet[/* add */3], Univ$ReactTemplate.Universe[/* levels */9](u$2), s);
          }
          break;
      case 10 : 
          var match$1 = match[0];
          var match$2 = Environ$ReactTemplate.lookup_constant(match$1[0], env)[/* const_universes */4];
          if (match$2.tag) {
            return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], Univ$ReactTemplate.LSet[/* add */3], Univ$ReactTemplate.Instance[/* levels */12](match$1[1]), s);
          } else {
            return Curry._2(Univ$ReactTemplate.LSet[/* union */6], s, match$2[0][0]);
          }
          break;
      case 11 : 
          var match$3 = match[0];
          mind = match$3[0][0];
          u = match$3[1];
          exit = 1;
          break;
      case 12 : 
          var match$4 = match[0];
          mind = match$4[0][0][0];
          u = match$4[1];
          exit = 1;
          break;
      default:
        return Constr$ReactTemplate.fold(aux, s, c);
    }
    if (exit === 1) {
      var match$5 = Environ$ReactTemplate.lookup_mind(mind, env)[/* mind_universes */8];
      var exit$1 = 0;
      switch (match$5.tag | 0) {
        case 0 : 
            return Curry._2(Univ$ReactTemplate.LSet[/* union */6], s, match$5[0][0]);
        case 1 : 
        case 2 : 
            exit$1 = 2;
            break;
        
      }
      if (exit$1 === 2) {
        return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], Univ$ReactTemplate.LSet[/* add */3], Univ$ReactTemplate.Instance[/* levels */12](u), s);
      }
      
    }
    
  };
  return aux(Univ$ReactTemplate.LSet[/* empty */0], c);
}

function merge_types(d, d0) {
  var exit = 0;
  switch (d) {
    case 0 : 
        return /* Lt */0;
    case 1 : 
        exit = 1;
        break;
    case 2 : 
        if (d0 >= 2) {
          return /* Eq */2;
        } else {
          exit = 1;
        }
        break;
    
  }
  if (exit === 1) {
    switch (d0) {
      case 0 : 
          return /* Lt */0;
      case 1 : 
      case 2 : 
          return /* Le */1;
      
    }
  }
  
}

function merge_up(d, b, up) {
  var find;
  try {
    find = /* Some */[Curry._2(Univ$ReactTemplate.LMap[/* find */21], b, up)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      find = /* None */0;
    } else {
      throw exn;
    }
  }
  if (find) {
    var d0 = find[0];
    var d$1 = merge_types(d, d0);
    if (d$1 === d0) {
      return up;
    } else {
      return Curry._3(Univ$ReactTemplate.LMap[/* add */3], b, d$1, up);
    }
  } else {
    return Curry._3(Univ$ReactTemplate.LMap[/* add */3], b, d, up);
  }
}

function add_up(a, d, b, graph) {
  var match;
  try {
    match = /* tuple */[
      Curry._2(Univ$ReactTemplate.LMap[/* find */21], a, graph),
      graph
    ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var node = /* record */[
        /* up */Univ$ReactTemplate.LMap[/* empty */0],
        /* visited : false */0
      ];
      match = /* tuple */[
        node,
        Curry._3(Univ$ReactTemplate.LMap[/* add */3], a, node, graph)
      ];
    } else {
      throw exn;
    }
  }
  var node$1 = match[0];
  node$1[/* up */0] = merge_up(d, b, node$1[/* up */0]);
  return match[1];
}

function transitive_close(removable, graph) {
  var do_node = function (_, node) {
    if (node[/* visited */1]) {
      return 0;
    } else {
      var keepup = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (b, d, keepup) {
              if (Curry._2(Univ$ReactTemplate.LSet[/* mem */2], b, removable)) {
                var exit = 0;
                var bnode;
                try {
                  bnode = Curry._2(Univ$ReactTemplate.LMap[/* find */21], b, graph);
                  exit = 1;
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return keepup;
                  } else {
                    throw exn;
                  }
                }
                if (exit === 1) {
                  do_node(b, bnode);
                  return Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (k, d$prime, keepup) {
                                return merge_up(merge_types(d, d$prime), k, keepup);
                              }), bnode[/* up */0], keepup);
                }
                
              } else {
                return merge_up(d, b, keepup);
              }
            }), node[/* up */0], Univ$ReactTemplate.LMap[/* empty */0]);
      node[/* up */0] = keepup;
      node[/* visited */1] = /* true */1;
      return /* () */0;
    }
  };
  return Curry._2(Univ$ReactTemplate.LMap[/* iter */9], do_node, graph);
}

function restrict_universe_context(param, keep) {
  var univs = param[0];
  var removable = Curry._2(Univ$ReactTemplate.LSet[/* diff */8], univs, keep);
  var match = Curry._3(Univ$ReactTemplate.Constraint[/* fold */13], (function (cst, param) {
          var rem = param[1];
          var csts = param[0];
          var b = cst[2];
          var a = cst[0];
          if (Curry._2(Univ$ReactTemplate.LSet[/* mem */2], a, removable) || Curry._2(Univ$ReactTemplate.LSet[/* mem */2], b, removable)) {
            return /* tuple */[
                    csts,
                    add_up(a, cst[1], b, rem)
                  ];
          } else {
            return /* tuple */[
                    Curry._2(Univ$ReactTemplate.Constraint[/* add */3], cst, csts),
                    rem
                  ];
          }
        }), param[1], /* tuple */[
        Univ$ReactTemplate.Constraint[/* empty */0],
        Univ$ReactTemplate.LMap[/* empty */0]
      ]);
  var rem = match[1];
  transitive_close(removable, rem);
  var csts = Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (a, node, csts) {
          if (Curry._2(Univ$ReactTemplate.LSet[/* mem */2], a, removable)) {
            return csts;
          } else {
            return Curry._3(Univ$ReactTemplate.LMap[/* fold */10], (function (b, d, csts) {
                          return Curry._2(Univ$ReactTemplate.Constraint[/* add */3], /* tuple */[
                                      a,
                                      d,
                                      b
                                    ], csts);
                        }), node[/* up */0], csts);
          }
        }), rem, match[0]);
  return /* tuple */[
          Curry._2(Univ$ReactTemplate.LSet[/* inter */7], univs, keep),
          csts
        ];
}

exports.universes_of_constr = universes_of_constr;
exports.restrict_universe_context = restrict_universe_context;
/* Univ-ReactTemplate Not a pure module */
