// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("bs-platform/lib/js/sys.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Esubst$ReactTemplate = require("./esubst.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Uint31$ReactTemplate = require("./uint31.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Pre_env$ReactTemplate = require("./pre_env.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Cbytecodes$ReactTemplate = require("./cbytecodes.bs.js");
var Cemitcodes$ReactTemplate = require("./cemitcodes.bs.js");
var Retroknowledge$ReactTemplate = require("./retroknowledge.bs.js");

function pr_con(sp) {
  return Pp$ReactTemplate.str(Names$ReactTemplate.Label[/* to_string */4](Names$ReactTemplate.Constant[/* label */8](sp)));
}

function pp_names(ids) {
  return Pp$ReactTemplate.prlist_with_sep((function () {
                return Pp$ReactTemplate.brk(/* tuple */[
                            1,
                            1
                          ]);
              }), Names$ReactTemplate.Name[/* print */7], Util$ReactTemplate.$$Array[/* to_list */9](ids));
}

function pp_lam(lam) {
  switch (lam.tag | 0) {
    case 0 : 
        var name = lam[0];
        var n = lam[1];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Name[/* print */7](name), Pp$ReactTemplate.str("##")), Pp$ReactTemplate.$$int(n));
    case 1 : 
        return Names$ReactTemplate.Id[/* print */8](lam[0]);
    case 2 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("evar("), Evar$ReactTemplate.print(lam[0])), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lam, Util$ReactTemplate.$$Array[/* to_list */9](lam[1]))), Pp$ReactTemplate.str(")")));
    case 3 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("forall("), pp_lam(lam[0])), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.spc(/* () */0)), pp_lam(lam[1])), Pp$ReactTemplate.str(")")));
    case 4 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(fun "), pp_names(lam[0])), Pp$ReactTemplate.str(" =>")), Pp$ReactTemplate.spc(/* () */0)), pp_lam(lam[1])), Pp$ReactTemplate.str(")")));
    case 5 : 
        return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("let "), Names$ReactTemplate.Name[/* print */7](lam[0])), Pp$ReactTemplate.str(":=")), pp_lam(lam[1])), Pp$ReactTemplate.str(" in")), Pp$ReactTemplate.spc(/* () */0)), pp_lam(lam[2])));
    case 6 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pp_lam(lam[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lam, Util$ReactTemplate.$$Array[/* to_list */9](lam[1]))), Pp$ReactTemplate.str(")")));
    case 7 : 
        return pr_con(lam[0][0]);
    case 8 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(PRIM "), pr_con(lam[0][0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lam, Util$ReactTemplate.$$Array[/* to_list */9](lam[3]))), Pp$ReactTemplate.str(")")));
    case 9 : 
        var branches = lam[4];
        var ic = [-1];
        var ib = [0];
        return Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("<"), pp_lam(lam[2])), Pp$ReactTemplate.str(">")), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str("Case")), Pp$ReactTemplate.spc(/* () */0)), pp_lam(lam[3])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of")), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep((function () {
                                              return Pp$ReactTemplate.str("");
                                            }), (function (c) {
                                              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.cut(/* () */0), Pp$ReactTemplate.str("| ")), Pp$ReactTemplate.$$int((ic[0] = ic[0] + 1 | 0, ic[0]))), Pp$ReactTemplate.str(" => ")), pp_lam(c));
                                            }), Util$ReactTemplate.$$Array[/* to_list */9](branches[/* constant_branches */0])), Pp$ReactTemplate.prlist_with_sep((function () {
                                              return Pp$ReactTemplate.str("");
                                            }), (function (param) {
                                              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.cut(/* () */0), Pp$ReactTemplate.str("| ")), Pp$ReactTemplate.$$int((ib[0] = ib[0] + 1 | 0, ib[0]))), Pp$ReactTemplate.str(" ")), pp_names(param[0])), Pp$ReactTemplate.str(" => ")), pp_lam(param[1]));
                                            }), Util$ReactTemplate.$$Array[/* to_list */9](branches[/* nonconstant_branches */1]))))), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str("end")));
    case 10 : 
        var match = lam[1];
        var bl = match[2];
        var tl = match[1];
        var match$1 = lam[0];
        var t = match$1[0];
        var fixl = Util$ReactTemplate.$$Array[/* mapi */14]((function (i, id) {
                return /* tuple */[
                        id,
                        Caml_array.caml_array_get(t, i),
                        Caml_array.caml_array_get(tl, i),
                        Caml_array.caml_array_get(bl, i)
                      ];
              }), match[0]);
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("fix "), Pp$ReactTemplate.$$int(match$1[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("{")), Pp$ReactTemplate.v(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                                      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Name[/* print */7](param[0]), Pp$ReactTemplate.str("/")), Pp$ReactTemplate.$$int(param[1])), Pp$ReactTemplate.str(":")), pp_lam(param[2])), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str(":=")), pp_lam(param[3]));
                                    }), Util$ReactTemplate.$$Array[/* to_list */9](fixl)))), Pp$ReactTemplate.str("}")));
    case 11 : 
        var match$2 = lam[1];
        var bl$1 = match$2[2];
        var tl$1 = match$2[1];
        var fixl$1 = Util$ReactTemplate.$$Array[/* mapi */14]((function (i, na) {
                return /* tuple */[
                        na,
                        Caml_array.caml_array_get(tl$1, i),
                        Caml_array.caml_array_get(bl$1, i)
                      ];
              }), match$2[0]);
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("cofix "), Pp$ReactTemplate.$$int(lam[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("{")), Pp$ReactTemplate.v(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                                      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Name[/* print */7](param[0]), Pp$ReactTemplate.str(":")), pp_lam(param[1])), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str(":=")), pp_lam(param[2]));
                                    }), Util$ReactTemplate.$$Array[/* to_list */9](fixl$1)))), Pp$ReactTemplate.str("}")));
    case 12 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(makeblock "), Pp$ReactTemplate.$$int(lam[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pp_lam, Util$ReactTemplate.$$Array[/* to_list */9](lam[1]))), Pp$ReactTemplate.str(")")));
    case 13 : 
        return Pp$ReactTemplate.str("values");
    case 14 : 
        var s = lam[0];
        var match$3 = Sorts$ReactTemplate.family(s);
        switch (match$3) {
          case 0 : 
              return Pp$ReactTemplate.str("Prop");
          case 1 : 
              return Pp$ReactTemplate.str("Set");
          case 2 : 
              return Pp$ReactTemplate.str("Type");
          
        }
    case 15 : 
        var match$4 = lam[0][0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.MutInd[/* print */15](match$4[0]), Pp$ReactTemplate.str("#")), Pp$ReactTemplate.$$int(match$4[1]));
    case 16 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(proj#"), Pp$ReactTemplate.$$int(lam[0])), Pp$ReactTemplate.spc(/* () */0)), pr_con(lam[1])), Pp$ReactTemplate.str("(")), pp_lam(lam[2])), Pp$ReactTemplate.str(")")));
    case 17 : 
        return Pp$ReactTemplate.str("(uint)");
    
  }
}

function mkLapp(f, args) {
  if (args.length) {
    if (f.tag === 6) {
      return /* Lapp */Block.__(6, [
                f[0],
                Util$ReactTemplate.$$Array[/* append */3](f[1], args)
              ]);
    } else {
      return /* Lapp */Block.__(6, [
                f,
                args
              ]);
    }
  } else {
    return f;
  }
}

function mkLlam(ids, body) {
  if (ids.length) {
    if (body.tag === 4) {
      return /* Llam */Block.__(4, [
                Util$ReactTemplate.$$Array[/* append */3](ids, body[0]),
                body[1]
              ]);
    } else {
      return /* Llam */Block.__(4, [
                ids,
                body
              ]);
    }
  } else {
    return body;
  }
}

function decompose_Llam(lam) {
  if (lam.tag === 4) {
    return /* tuple */[
            lam[0],
            lam[1]
          ];
  } else {
    return /* tuple */[
            /* array */[],
            lam
          ];
  }
}

var subst_id = Esubst$ReactTemplate.subs_id(0);

function cons(v, subst) {
  return Esubst$ReactTemplate.subs_cons(/* tuple */[
              /* array */[v],
              subst
            ]);
}

function map_uint(_, f, n, u) {
  switch (u.tag | 0) {
    case 0 : 
        return u;
    case 1 : 
        var args = u[0];
        var args$prime = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, n), args);
        if (args === args$prime) {
          return u;
        } else {
          return /* UintDigits */Block.__(1, [args$prime]);
        }
    case 2 : 
        var a = u[0];
        var a$prime = Curry._2(f, n, a);
        if (a === a$prime) {
          return u;
        } else {
          return /* UintDecomp */Block.__(2, [a$prime]);
        }
    
  }
}

function map_lam_with_binders(g, f, n, lam) {
  switch (lam.tag | 0) {
    case 2 : 
        var args = lam[1];
        var args$prime = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, n), args);
        if (args === args$prime) {
          return lam;
        } else {
          return /* Levar */Block.__(2, [
                    lam[0],
                    args$prime
                  ]);
        }
    case 3 : 
        var codom = lam[1];
        var dom = lam[0];
        var dom$prime = Curry._2(f, n, dom);
        var codom$prime = Curry._2(f, n, codom);
        if (dom === dom$prime && codom === codom$prime) {
          return lam;
        } else {
          return /* Lprod */Block.__(3, [
                    dom$prime,
                    codom$prime
                  ]);
        }
    case 4 : 
        var body = lam[1];
        var ids = lam[0];
        var body$prime = Curry._2(f, Curry._2(g, ids.length, n), body);
        if (body === body$prime) {
          return lam;
        } else {
          return mkLlam(ids, body$prime);
        }
    case 5 : 
        var body$1 = lam[2];
        var def = lam[1];
        var def$prime = Curry._2(f, n, def);
        var body$prime$1 = Curry._2(f, Curry._2(g, 1, n), body$1);
        if (body$1 === body$prime$1 && def === def$prime) {
          return lam;
        } else {
          return /* Llet */Block.__(5, [
                    lam[0],
                    def$prime,
                    body$prime$1
                  ]);
        }
    case 6 : 
        var args$1 = lam[1];
        var fct = lam[0];
        var fct$prime = Curry._2(f, n, fct);
        var args$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, n), args$1);
        if (fct === fct$prime && args$1 === args$prime$1) {
          return lam;
        } else {
          return mkLapp(fct$prime, args$prime$1);
        }
    case 8 : 
        var args$2 = lam[3];
        var args$prime$2 = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, n), args$2);
        if (args$2 === args$prime$2) {
          return lam;
        } else {
          return /* Lprim */Block.__(8, [
                    lam[0],
                    lam[1],
                    lam[2],
                    args$prime$2
                  ]);
        }
    case 9 : 
        var branches = lam[4];
        var a = lam[3];
        var t = lam[2];
        var $$const = branches[/* constant_branches */0];
        var nonconst = branches[/* nonconstant_branches */1];
        var t$prime = Curry._2(f, n, t);
        var a$prime = Curry._2(f, n, a);
        var const$prime = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, n), $$const);
        var on_b = function (b) {
          var body = b[1];
          var ids = b[0];
          var body$prime = Curry._2(f, Curry._2(g, ids.length, n), body);
          if (body === body$prime) {
            return b;
          } else {
            return /* tuple */[
                    ids,
                    body$prime
                  ];
          }
        };
        var nonconst$prime = Util$ReactTemplate.$$Array[/* smartmap */47](on_b, nonconst);
        var branches$prime = $$const === const$prime && nonconst === nonconst$prime ? branches : /* record */[
            /* constant_branches */const$prime,
            /* nonconstant_branches */nonconst$prime
          ];
        if (t === t$prime && a === a$prime && branches === branches$prime) {
          return lam;
        } else {
          return /* Lcase */Block.__(9, [
                    lam[0],
                    lam[1],
                    t$prime,
                    a$prime,
                    branches$prime
                  ]);
        }
    case 10 : 
        var match = lam[1];
        var lbodies = match[2];
        var ltypes = match[1];
        var ids$1 = match[0];
        var ltypes$prime = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, n), ltypes);
        var lbodies$prime = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, Curry._2(g, ids$1.length, n)), lbodies);
        if (ltypes === ltypes$prime && lbodies === lbodies$prime) {
          return lam;
        } else {
          return /* Lfix */Block.__(10, [
                    lam[0],
                    /* tuple */[
                      ids$1,
                      ltypes$prime,
                      lbodies$prime
                    ]
                  ]);
        }
    case 11 : 
        var match$1 = lam[1];
        var lbodies$1 = match$1[2];
        var ltypes$1 = match$1[1];
        var ids$2 = match$1[0];
        var ltypes$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, n), ltypes$1);
        var lbodies$prime$1 = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, Curry._2(g, ids$2.length, n)), lbodies$1);
        if (ltypes$1 === ltypes$prime$1 && lbodies$1 === lbodies$prime$1) {
          return lam;
        } else {
          return /* Lcofix */Block.__(11, [
                    lam[0],
                    /* tuple */[
                      ids$2,
                      ltypes$prime$1,
                      lbodies$prime$1
                    ]
                  ]);
        }
    case 12 : 
        var args$3 = lam[1];
        var args$prime$3 = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(f, n), args$3);
        if (args$3 === args$prime$3) {
          return lam;
        } else {
          return /* Lmakeblock */Block.__(12, [
                    lam[0],
                    args$prime$3
                  ]);
        }
    case 16 : 
        var arg = lam[2];
        var arg$prime = Curry._2(f, n, arg);
        if (arg === arg$prime) {
          return lam;
        } else {
          return /* Lproj */Block.__(16, [
                    lam[0],
                    lam[1],
                    arg$prime
                  ]);
        }
    case 17 : 
        var u = lam[0];
        var u$prime = map_uint(g, f, n, u);
        if (u === u$prime) {
          return lam;
        } else {
          return /* Luint */Block.__(17, [u$prime]);
        }
    default:
      return lam;
  }
}

function lam_exlift(el, lam) {
  if (lam.tag) {
    return map_lam_with_binders(Esubst$ReactTemplate.el_liftn, lam_exlift, el, lam);
  } else {
    var i = lam[1];
    var i$prime = Esubst$ReactTemplate.reloc_rel(i, el);
    if (i === i$prime) {
      return lam;
    } else {
      return /* Lrel */Block.__(0, [
                lam[0],
                i$prime
              ]);
    }
  }
}

function lam_lift(k, lam) {
  if (k) {
    return lam_exlift(Esubst$ReactTemplate.el_shft(k, Esubst$ReactTemplate.el_id), lam);
  } else {
    return lam;
  }
}

function lam_subst_rel(lam, id, n, subst) {
  var match = Esubst$ReactTemplate.expand_rel(n, subst);
  if (match.tag) {
    var n$prime = match[0][0];
    if (n === n$prime) {
      return lam;
    } else {
      return /* Lrel */Block.__(0, [
                id,
                n$prime
              ]);
    }
  } else {
    var match$1 = match[0];
    return lam_lift(match$1[0], match$1[1]);
  }
}

function lam_exsubst(subst, lam) {
  if (lam.tag) {
    return map_lam_with_binders(Esubst$ReactTemplate.subs_liftn, lam_exsubst, subst, lam);
  } else {
    return lam_subst_rel(lam, lam[0], lam[1], subst);
  }
}

function lam_subst_args(subst, args) {
  if (Esubst$ReactTemplate.is_subs_id(subst)) {
    return args;
  } else {
    return Util$ReactTemplate.$$Array[/* smartmap */47]((function (param) {
                  return lam_exsubst(subst, param);
                }), args);
  }
}

function can_subst(lam) {
  switch (lam.tag | 0) {
    case 0 : 
    case 1 : 
    case 4 : 
    case 7 : 
    case 13 : 
    case 14 : 
    case 15 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function simplify(_subst, _lam) {
  while(true) {
    var lam = _lam;
    var subst = _subst;
    switch (lam.tag | 0) {
      case 0 : 
          return lam_subst_rel(lam, lam[0], lam[1], subst);
      case 5 : 
          var body = lam[2];
          var def = lam[1];
          var def$prime = simplify(subst, def);
          if (can_subst(def$prime)) {
            _lam = body;
            _subst = cons(def$prime, subst);
            continue ;
            
          } else {
            var body$prime = simplify(Esubst$ReactTemplate.subs_lift(subst), body);
            if (def === def$prime && body === body$prime) {
              return lam;
            } else {
              return /* Llet */Block.__(5, [
                        lam[0],
                        def$prime,
                        body$prime
                      ]);
            }
          }
          break;
      case 6 : 
          var args = lam[1];
          var f = lam[0];
          var lam$prime = simplify_app(subst, f, subst, args);
          if (lam$prime.tag === 6 && f === lam$prime[0] && args === lam$prime[1]) {
            return lam;
          } else {
            return lam$prime;
          }
          break;
      default:
        return map_lam_with_binders(Esubst$ReactTemplate.subs_liftn, simplify, subst, lam);
    }
  };
}

function simplify_app(_substf, _f, _substa, _args) {
  while(true) {
    var args = _args;
    var substa = _substa;
    var f = _f;
    var substf = _substf;
    switch (f.tag | 0) {
      case 0 : 
          var f$prime = lam_subst_rel(f, f[0], f[1], substf);
          if (f$prime.tag === 4) {
            return reduce_lapp(subst_id, Util$ReactTemplate.$$Array[/* to_list */9](f$prime[0]), f$prime[1], substa, Util$ReactTemplate.$$Array[/* to_list */9](args));
          } else {
            return mkLapp(f$prime, simplify_args(substa, args));
          }
          break;
      case 4 : 
          return reduce_lapp(substf, Util$ReactTemplate.$$Array[/* to_list */9](f[0]), f[1], substa, Util$ReactTemplate.$$Array[/* to_list */9](args));
      case 5 : 
          var body = f[2];
          var def$prime = simplify(substf, f[1]);
          if (can_subst(def$prime)) {
            _f = body;
            _substf = cons(def$prime, substf);
            continue ;
            
          } else {
            return /* Llet */Block.__(5, [
                      f[0],
                      def$prime,
                      simplify_app(Esubst$ReactTemplate.subs_lift(substf), body, Esubst$ReactTemplate.subs_shft(/* tuple */[
                                1,
                                substa
                              ]), args)
                    ]);
          }
          break;
      case 6 : 
          var args$1 = Util$ReactTemplate.$$Array[/* append */3](lam_subst_args(substf, f[1]), lam_subst_args(substa, args));
          _args = args$1;
          _substa = subst_id;
          _f = f[0];
          continue ;
          default:
        return mkLapp(simplify(substf, f), simplify_args(substa, args));
    }
  };
}

function simplify_args(subst, args) {
  return Util$ReactTemplate.$$Array[/* smartmap */47]((function (param) {
                return simplify(subst, param);
              }), args);
}

function reduce_lapp(_substf, _lids, body, substa, _largs) {
  while(true) {
    var largs = _largs;
    var lids = _lids;
    var substf = _substf;
    if (lids) {
      var lids$1 = lids[1];
      if (largs) {
        var largs$1 = largs[1];
        var a = simplify(substa, largs[0]);
        if (can_subst(a)) {
          _largs = largs$1;
          _lids = lids$1;
          _substf = cons(a, substf);
          continue ;
          
        } else {
          var body$1 = reduce_lapp(Esubst$ReactTemplate.subs_lift(substf), lids$1, body, Esubst$ReactTemplate.subs_shft(/* tuple */[
                    1,
                    substa
                  ]), largs$1);
          return /* Llet */Block.__(5, [
                    lids[0],
                    a,
                    body$1
                  ]);
        }
      } else {
        return /* Llam */Block.__(4, [
                  Util$ReactTemplate.$$Array[/* of_list */10](lids),
                  simplify(Esubst$ReactTemplate.subs_liftn(Curry._1(Util$ReactTemplate.List[/* length */0], lids), substf), body)
                ]);
      }
    } else if (largs) {
      return simplify_app(substf, body, substa, Util$ReactTemplate.$$Array[/* of_list */10](largs));
    } else {
      return simplify(substf, body);
    }
  };
}

function occurrence(_k, _kind, _lam) {
  while(true) {
    var lam = _lam;
    var kind = _kind;
    var k = _k;
    var exit = 0;
    switch (lam.tag | 0) {
      case 0 : 
          if (lam[1] === k) {
            if (kind) {
              return /* false */0;
            } else {
              throw Caml_builtin_exceptions.not_found;
            }
          } else {
            return kind;
          }
          break;
      case 3 : 
          _lam = lam[1];
          _kind = occurrence(k, kind, lam[0]);
          continue ;
          case 4 : 
          occurrence(k + lam[0].length | 0, /* false */0, lam[1]);
          return kind;
      case 5 : 
          _lam = lam[2];
          _kind = occurrence(k, kind, lam[1]);
          _k = k + 1 | 0;
          continue ;
          case 6 : 
          return occurrence_args(k, occurrence(k, kind, lam[0]), lam[1]);
      case 8 : 
          return occurrence_args(k, kind, lam[3]);
      case 9 : 
          var branches = lam[4];
          var kind$1 = occurrence(k, occurrence(k, kind, lam[2]), lam[3]);
          var r = [kind$1];
          Util$ReactTemplate.$$Array[/* iter */11]((function(k,kind$1,r){
              return function (c) {
                r[0] = occurrence(k, kind$1, c) && r[0];
                return /* () */0;
              }
              }(k,kind$1,r)), branches[/* constant_branches */0]);
          var on_b = (function(k,kind$1,r){
          return function on_b(param) {
            r[0] = occurrence(k + param[0].length | 0, kind$1, param[1]) && r[0];
            return /* () */0;
          }
          }(k,kind$1,r));
          Util$ReactTemplate.$$Array[/* iter */11](on_b, branches[/* nonconstant_branches */1]);
          return r[0];
      case 10 : 
      case 11 : 
          exit = 1;
          break;
      case 2 : 
      case 12 : 
          return occurrence_args(k, kind, lam[1]);
      case 16 : 
          _lam = lam[2];
          continue ;
          case 17 : 
          var k$1 = k;
          var kind$2 = kind;
          var u = lam[0];
          switch (u.tag | 0) {
            case 0 : 
                return kind$2;
            case 1 : 
                return occurrence_args(k$1, kind$2, u[0]);
            case 2 : 
                return occurrence(k$1, kind$2, u[0]);
            
          }
      default:
        return kind;
    }
    if (exit === 1) {
      var match = lam[1];
      var kind$3 = occurrence_args(k, kind, match[1]);
      occurrence_args(k + match[0].length | 0, /* false */0, match[2]);
      return kind$3;
    }
    
  };
}

function occurrence_args(k, kind, args) {
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (param, param$1) {
                return occurrence(k, param, param$1);
              }), kind, args);
}

function occur_once(lam) {
  try {
    occurrence(1, /* true */1, lam);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function remove_let(_subst, _lam) {
  while(true) {
    var lam = _lam;
    var subst = _subst;
    switch (lam.tag | 0) {
      case 0 : 
          return lam_subst_rel(lam, lam[0], lam[1], subst);
      case 5 : 
          var body = lam[2];
          var def = lam[1];
          var def$prime = remove_let(subst, def);
          if (occur_once(body)) {
            _lam = body;
            _subst = cons(def$prime, subst);
            continue ;
            
          } else {
            var body$prime = remove_let(Esubst$ReactTemplate.subs_lift(subst), body);
            if (def === def$prime && body === body$prime) {
              return lam;
            } else {
              return /* Llet */Block.__(5, [
                        lam[0],
                        def$prime,
                        body$prime
                      ]);
            }
          }
          break;
      default:
        return map_lam_with_binders(Esubst$ReactTemplate.subs_liftn, remove_let, subst, lam);
    }
  };
}

var TooLargeInductive = Caml_exceptions.create("Clambda-ReactTemplate.TooLargeInductive");

var max_nb_block = (16777216 + Cbytecodes$ReactTemplate.last_variant_tag | 0) - 1 | 0;

var str_max_constructors = Curry._2(Format.sprintf(/* Format */[
          /* String_literal */Block.__(11, [
              " which has more than ",
              /* Int */Block.__(4, [
                  /* Int_i */3,
                  /* No_padding */0,
                  /* No_precision */0,
                  /* String_literal */Block.__(11, [
                      " constant constructors or more than ",
                      /* Int */Block.__(4, [
                          /* Int_i */3,
                          /* No_padding */0,
                          /* No_precision */0,
                          /* String_literal */Block.__(11, [
                              " non-constant constructors",
                              /* End_of_format */0
                            ])
                        ])
                    ])
                ])
            ]),
          " which has more than %i constant constructors or more than %i non-constant constructors"
        ]), 16777216, max_nb_block);

function check_compilable(ib) {
  if (ib[/* mind_nb_args */13] <= max_nb_block && ib[/* mind_nb_constant */12] <= 16777216) {
    return 0;
  } else {
    var msg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot compile code for virtual machine as it uses inductive "), Names$ReactTemplate.Id[/* print */8](ib[/* mind_typename */0])), Pp$ReactTemplate.str(str_max_constructors));
    throw [
          TooLargeInductive,
          msg
        ];
  }
}

function is_value(lc) {
  if (lc.tag === 13) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function get_value(lc) {
  if (lc.tag === 13) {
    return lc[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function make_args(start, _end) {
  return Util$ReactTemplate.$$Array[/* init */0]((start - _end | 0) + 1 | 0, (function (i) {
                return /* Lrel */Block.__(0, [
                          /* Anonymous */0,
                          start - i | 0
                        ]);
              }));
}

function expand_constructor(tag, nparams, arity) {
  var ids = Caml_array.caml_make_vect(nparams + arity | 0, /* Anonymous */0);
  if (arity) {
    var args = make_args(arity, 1);
    return /* Llam */Block.__(4, [
              ids,
              /* Lmakeblock */Block.__(12, [
                  tag,
                  args
                ])
            ]);
  } else {
    return mkLlam(ids, /* Lval */Block.__(13, [/* Const_b0 */Block.__(3, [tag])]));
  }
}

function makeblock(tag, nparams, arity, args) {
  var nargs = args.length;
  if (nparams > 0 || nargs < arity) {
    return mkLapp(expand_constructor(tag, nparams, arity), args);
  } else if (arity) {
    if (Util$ReactTemplate.$$Array[/* for_all */26](is_value, args)) {
      if (tag < Cbytecodes$ReactTemplate.last_variant_tag) {
        return /* Lval */Block.__(13, [/* Const_bn */Block.__(4, [
                      tag,
                      Util$ReactTemplate.$$Array[/* map */12](get_value, args)
                    ])]);
      } else {
        var args$1 = Util$ReactTemplate.$$Array[/* map */12](get_value, args);
        var args$2 = Util$ReactTemplate.$$Array[/* append */3](/* array */[/* Const_b0 */Block.__(3, [tag - Cbytecodes$ReactTemplate.last_variant_tag | 0])], args$1);
        return /* Lval */Block.__(13, [/* Const_bn */Block.__(4, [
                      Cbytecodes$ReactTemplate.last_variant_tag,
                      args$2
                    ])]);
      }
    } else {
      return /* Lmakeblock */Block.__(12, [
                tag,
                args
              ]);
    }
  } else {
    return /* Lval */Block.__(13, [/* Const_b0 */Block.__(3, [tag])]);
  }
}

function get_alias(env, _kn) {
  while(true) {
    var kn = _kn;
    var cb = Pre_env$ReactTemplate.lookup_constant(kn, env);
    var tps = cb[/* const_body_code */3];
    if (tps) {
      var match = Cemitcodes$ReactTemplate.force(tps[0]);
      if (typeof match === "number") {
        return kn;
      } else if (match.tag) {
        _kn = match[0];
        continue ;
        
      } else {
        return kn;
      }
    } else {
      return kn;
    }
  };
}

/* Name */[Names$ReactTemplate.Id[/* of_string */5]("f")];

function compile_prim(n, op, kn, fc, args) {
  if (fc) {
    return /* Lprim */Block.__(8, [
              kn,
              n,
              op,
              args
            ]);
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function get_names(decl) {
  var decl$1 = Util$ReactTemplate.$$Array[/* of_list */10](decl);
  return Util$ReactTemplate.$$Array[/* map */12]((function (prim) {
                return prim[0];
              }), decl$1);
}

function extend(v) {
  if (v[/* size */1] === v[/* elems */0].length) {
    var new_size = Caml_primitive.caml_int_min((v[/* size */1] << 1), Sys.max_array_length);
    if (new_size <= v[/* size */1]) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Vect.extend"
          ];
    }
    var new_elems = Caml_array.caml_make_vect(new_size, Caml_array.caml_array_get(v[/* elems */0], 0));
    Util$ReactTemplate.$$Array[/* blit */8](v[/* elems */0], 0, new_elems, 0, v[/* size */1]);
    v[/* elems */0] = new_elems;
    return /* () */0;
  } else {
    return 0;
  }
}

function popn(v, n) {
  v[/* size */1] = Caml_primitive.caml_int_max(0, v[/* size */1] - n | 0);
  return /* () */0;
}

function get_last(v, n) {
  if (v[/* size */1] <= n) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Vect.get:index out of bounds"
        ];
  }
  return Caml_array.caml_array_get(v[/* elems */0], (v[/* size */1] - n | 0) - 1 | 0);
}

var dummy_lambda = /* Lrel */Block.__(0, [
    /* Anonymous */0,
    0
  ]);

var empty_args = /* array */[];

function make(env) {
  return /* record */[
          /* global_env */env,
          /* name_rel : record */[
            /* elems */Caml_array.caml_make_vect(16, /* Anonymous */0),
            /* size */0
          ],
          /* construct_tbl */Hashtbl.create(/* None */0, 111)
        ];
}

function push_rel(env, id) {
  var v = env[/* name_rel */1];
  var a = id;
  extend(v);
  Caml_array.caml_array_set(v[/* elems */0], v[/* size */1], a);
  v[/* size */1] = v[/* size */1] + 1 | 0;
  return /* () */0;
}

function push_rels(env, ids) {
  return Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                return push_rel(env, param);
              }), ids);
}

function popn$1(env, n) {
  for(var _i = 1; _i <= n; ++_i){
    popn(env[/* name_rel */1], 1);
  }
  return /* () */0;
}

function get_construct_info(env, c) {
  try {
    return Hashtbl.find(env[/* construct_tbl */2], c);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var match = c[0];
      var oib = Pre_env$ReactTemplate.lookup_mind(match[0], env[/* global_env */0]);
      var oip = Caml_array.caml_array_get(oib[/* mind_packets */0], match[1]);
      check_compilable(oip);
      var match$1 = Caml_array.caml_array_get(oip[/* mind_reloc_tbl */14], c[1] - 1 | 0);
      var nparams = oib[/* mind_nparams */5];
      var r_000 = match$1[0];
      var r_002 = match$1[1];
      var r = /* tuple */[
        r_000,
        nparams,
        r_002
      ];
      Hashtbl.add(env[/* construct_tbl */2], c, r);
      return r;
    } else {
      throw exn;
    }
  }
}

function lambda_of_constr(env, _c) {
  while(true) {
    var c = _c;
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 0 : 
          var env$1 = env;
          var n = match[0];
          return /* Lrel */Block.__(0, [
                    get_last(env$1[/* name_rel */1], n - 1 | 0),
                    n
                  ]);
      case 1 : 
          return /* Lvar */Block.__(1, [match[0]]);
      case 2 : 
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "Cbytegen.lambda_of_constr: Meta"
              ];
      case 3 : 
          var match$1 = match[0];
          var args = lambda_of_args(env, 0, match$1[1]);
          return /* Levar */Block.__(2, [
                    match$1[0],
                    args
                  ]);
      case 4 : 
          return /* Lsort */Block.__(14, [match[0]]);
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          var id = match[0];
          var ld = lambda_of_constr(env, match[1]);
          push_rel(env, id);
          var lc = lambda_of_constr(env, match[2]);
          popn(env[/* name_rel */1], 1);
          return /* Lprod */Block.__(3, [
                    ld,
                    /* Llam */Block.__(4, [
                        /* array */[id],
                        lc
                      ])
                  ]);
      case 7 : 
          var match$2 = Term$ReactTemplate.decompose_lam(c);
          var ids = get_names(Curry._1(Util$ReactTemplate.List[/* rev */4], match$2[0]));
          push_rels(env, ids);
          var lb = lambda_of_constr(env, match$2[1]);
          popn$1(env, ids.length);
          return mkLlam(ids, lb);
      case 8 : 
          var id$1 = match[0];
          var ld$1 = lambda_of_constr(env, match[1]);
          push_rel(env, id$1);
          var lb$1 = lambda_of_constr(env, match[3]);
          popn(env[/* name_rel */1], 1);
          return /* Llet */Block.__(5, [
                    id$1,
                    ld$1,
                    lb$1
                  ]);
      case 9 : 
          return lambda_of_app(env, match[0], match[1]);
      case 11 : 
          return /* Lind */Block.__(15, [match[0]]);
      case 10 : 
      case 12 : 
          return lambda_of_app(env, c, empty_args);
      case 13 : 
          var branches = match[3];
          var ci = match[0];
          var ind = ci[/* ci_ind */0];
          var mib = Pre_env$ReactTemplate.lookup_mind(ind[0], env[/* global_env */0]);
          var oib = Caml_array.caml_array_get(mib[/* mind_packets */0], ind[1]);
          check_compilable(oib);
          var rtbl = oib[/* mind_reloc_tbl */14];
          var la = lambda_of_constr(env, match[2]);
          var entry = Constr$ReactTemplate.mkInd(ind);
          var la$1;
          try {
            la$1 = Curry._1(Retroknowledge$ReactTemplate.get_vm_before_match_info(env[/* global_env */0][/* retroknowledge */6], entry), la);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              la$1 = la;
            } else {
              throw exn;
            }
          }
          var lt = lambda_of_constr(env, match[1]);
          var consts = Caml_array.caml_make_vect(oib[/* mind_nb_constant */12], dummy_lambda);
          var blocks = Caml_array.caml_make_vect(oib[/* mind_nb_args */13], /* tuple */[
                /* array */[],
                dummy_lambda
              ]);
          for(var i = 0 ,i_finish = rtbl.length - 1 | 0; i <= i_finish; ++i){
            var match$3 = Caml_array.caml_array_get(rtbl, i);
            var arity = match$3[1];
            var tag = match$3[0];
            var b = lambda_of_constr(env, Caml_array.caml_array_get(branches, i));
            if (arity) {
              var b$1;
              var exit = 0;
              if (b.tag === 4) {
                var ids$1 = b[0];
                if (ids$1.length === arity) {
                  b$1 = /* tuple */[
                    ids$1,
                    b[1]
                  ];
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
              if (exit === 1) {
                var ids$2 = Caml_array.caml_make_vect(arity, /* Anonymous */0);
                var args$1 = make_args(arity, 1);
                var ll = lam_lift(arity, b);
                b$1 = /* tuple */[
                  ids$2,
                  mkLapp(ll, args$1)
                ];
              }
              Caml_array.caml_array_set(blocks, tag - 1 | 0, b$1);
            } else {
              Caml_array.caml_array_set(consts, tag, b);
            }
          }
          var branches$1 = /* record */[
            /* constant_branches */consts,
            /* nonconstant_branches */blocks
          ];
          return /* Lcase */Block.__(9, [
                    ci,
                    rtbl,
                    lt,
                    la$1,
                    branches$1
                  ]);
      case 14 : 
          var match$4 = match[0];
          var match$5 = match$4[1];
          var names = match$5[0];
          var ltypes = lambda_of_args(env, 0, match$5[1]);
          push_rels(env, names);
          var lbodies = lambda_of_args(env, 0, match$5[2]);
          popn$1(env, names.length);
          return /* Lfix */Block.__(10, [
                    match$4[0],
                    /* tuple */[
                      names,
                      ltypes,
                      lbodies
                    ]
                  ]);
      case 15 : 
          var match$6 = match[0];
          var match$7 = match$6[1];
          var names$1 = match$7[0];
          var ltypes$1 = lambda_of_args(env, 0, match$7[1]);
          push_rels(env, names$1);
          var lbodies$1 = lambda_of_args(env, 0, match$7[2]);
          popn$1(env, names$1.length);
          return /* Lcofix */Block.__(11, [
                    match$6[0],
                    /* tuple */[
                      names$1,
                      ltypes$1,
                      lbodies$1
                    ]
                  ]);
      case 16 : 
          var kn = Names$ReactTemplate.Projection[/* constant */2](match[0]);
          var cb = Pre_env$ReactTemplate.lookup_constant(kn, env[/* global_env */0]);
          var pb = Option$ReactTemplate.get(cb[/* const_proj */5]);
          var n$1 = pb[/* proj_arg */2];
          var lc$1 = lambda_of_constr(env, match[1]);
          return /* Lproj */Block.__(16, [
                    n$1,
                    kn,
                    lc$1
                  ]);
      
    }
  };
}

function lambda_of_app(env, _f, args) {
  while(true) {
    var f = _f;
    var match = Constr$ReactTemplate.kind(f);
    switch (match.tag | 0) {
      case 10 : 
          var c = match[0];
          var kn = get_alias(env[/* global_env */0], c[0]);
          try {
            var f$1 = Retroknowledge$ReactTemplate.get_vm_compiling_info(env[/* global_env */0][/* retroknowledge */6], Constr$ReactTemplate.mkConstU(/* tuple */[
                      kn,
                      c[1]
                    ]));
            return Curry._1(f$1, lambda_of_args(env, 0, args));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              var cb = Pre_env$ReactTemplate.lookup_constant(kn, env[/* global_env */0]);
              var match$1 = cb[/* const_body */1];
              var exit = 0;
              switch (match$1.tag | 0) {
                case 1 : 
                    if (cb[/* const_inline_code */6]) {
                      _f = Mod_subst$ReactTemplate.force_constr(match$1[0]);
                      continue ;
                      
                    } else {
                      exit = 1;
                    }
                    break;
                case 0 : 
                case 2 : 
                    exit = 1;
                    break;
                
              }
              if (exit === 1) {
                return mkLapp(/* Lconst */Block.__(7, [c]), lambda_of_args(env, 0, args));
              }
              
            } else {
              throw exn;
            }
          }
          break;
      case 12 : 
          var match$2 = get_construct_info(env, match[0][0]);
          var arity = match$2[2];
          var nparams = match$2[1];
          var tag = match$2[0];
          var nargs = args.length;
          if ((nparams + arity | 0) === nargs) {
            try {
              try {
                return Curry._1(Retroknowledge$ReactTemplate.get_vm_constant_static_info(env[/* global_env */0][/* retroknowledge */6], f), args);
              }
              catch (exn$1){
                if (exn$1 === Cbytecodes$ReactTemplate.NotClosed) {
                  var rargs = Util$ReactTemplate.$$Array[/* sub */5](args, nparams, arity);
                  return Curry._1(Retroknowledge$ReactTemplate.get_vm_constant_dynamic_info(env[/* global_env */0][/* retroknowledge */6], f), lambda_of_args(env, nparams, rargs));
                } else {
                  throw exn$1;
                }
              }
            }
            catch (exn$2){
              if (exn$2 === Caml_builtin_exceptions.not_found) {
                var args$1 = lambda_of_args(env, nparams, args);
                return makeblock(tag, 0, arity, args$1);
              } else {
                throw exn$2;
              }
            }
          } else {
            var args$2 = lambda_of_args(env, nparams, args);
            try {
              return Curry._1(Retroknowledge$ReactTemplate.get_vm_constant_dynamic_info(env[/* global_env */0][/* retroknowledge */6], f), args$2);
            }
            catch (exn$3){
              if (exn$3 === Caml_builtin_exceptions.not_found) {
                if (nparams <= nargs) {
                  return makeblock(tag, 0, arity, args$2);
                } else {
                  return makeblock(tag, nparams - nargs | 0, arity, empty_args);
                }
              } else {
                throw exn$3;
              }
            }
          }
          break;
      default:
        var f$2 = lambda_of_constr(env, f);
        var args$3 = lambda_of_args(env, 0, args);
        return mkLapp(f$2, args$3);
    }
  };
}

function lambda_of_args(env, start, args) {
  var nargs = args.length;
  if (start < nargs) {
    return Util$ReactTemplate.$$Array[/* init */0](nargs - start | 0, (function (i) {
                  return lambda_of_constr(env, Caml_array.caml_array_get(args, start + i | 0));
                }));
  } else {
    return empty_args;
  }
}

function optimize_lambda(lam) {
  var lam$1 = simplify(subst_id, lam);
  return remove_let(subst_id, lam$1);
}

function lambda_of_constr$1(optimize, genv, c) {
  var env = make(genv);
  var ids = Curry._2(Util$ReactTemplate.List[/* rev_map */12], Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], genv[/* env_rel_context */2][/* env_rel_ctx */0]);
  push_rels(env, Util$ReactTemplate.$$Array[/* of_list */10](ids));
  var lam = lambda_of_constr(env, c);
  var lam$1 = optimize ? optimize_lambda(lam) : lam;
  if (Flags$ReactTemplate.dump_lambda[0]) {
    Feedback$ReactTemplate.msg_debug(/* None */0, pp_lam(lam$1));
  }
  return lam$1;
}

function compile_structured_int31(fc, args) {
  if (fc) {
    return /* Luint */Block.__(17, [/* UintVal */Block.__(0, [Curry._1(Uint31$ReactTemplate.of_int, Util$ReactTemplate.$$Array[/* fold_left */15]((function (temp_i, t) {
                              var match = Constr$ReactTemplate.kind(t);
                              if (match.tag === 12) {
                                return ((temp_i << 1) + match[0][0][1] | 0) - 1 | 0;
                              } else {
                                throw Cbytecodes$ReactTemplate.NotClosed;
                              }
                            }), 0, args))])]);
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function dynamic_int31_compilation(fc, args) {
  if (fc) {
    return /* Luint */Block.__(17, [/* UintDigits */Block.__(1, [args])]);
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function digits_from_uint(i) {
  var d0 = /* Lval */Block.__(13, [/* Const_b0 */Block.__(3, [0])]);
  var d1 = /* Lval */Block.__(13, [/* Const_b0 */Block.__(3, [1])]);
  var digits = Caml_array.caml_make_vect(31, d0);
  for(var k = 0; k <= 30; ++k){
    if (((Uint31$ReactTemplate.to_int(i) >>> k) & 1) === 1) {
      Caml_array.caml_array_set(digits, 30 - k | 0, d1);
    }
    
  }
  return digits;
}

function int31_escape_before_match(fc, t) {
  if (fc) {
    if (t.tag === 17) {
      var match = t[0];
      switch (match.tag | 0) {
        case 0 : 
            var digits = digits_from_uint(match[0]);
            return /* Lmakeblock */Block.__(12, [
                      1,
                      digits
                    ]);
        case 1 : 
            return /* Lmakeblock */Block.__(12, [
                      1,
                      match[0]
                    ]);
        case 2 : 
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "clambda.ml",
                    862,
                    4
                  ]
                ];
        
      }
    } else {
      return /* Luint */Block.__(17, [/* UintDecomp */Block.__(2, [t])]);
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

exports.TooLargeInductive = TooLargeInductive;
exports.lambda_of_constr = lambda_of_constr$1;
exports.decompose_Llam = decompose_Llam;
exports.get_alias = get_alias;
exports.compile_prim = compile_prim;
exports.compile_structured_int31 = compile_structured_int31;
exports.dynamic_int31_compilation = dynamic_int31_compilation;
exports.int31_escape_before_match = int31_escape_before_match;
/* subst_id Not a pure module */
