// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Esubst$ReactTemplate = require("./esubst.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var CClosure$ReactTemplate = require("./cClosure.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");

function shift_value(n, param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* VAL */Block.__(0, [
                  param[0] + n | 0,
                  param[1]
                ]);
    case 1 : 
        return /* STACK */Block.__(1, [
                  param[0] + n | 0,
                  param[1],
                  param[2]
                ]);
    case 2 : 
        return /* CBN */Block.__(2, [
                  param[0],
                  Esubst$ReactTemplate.subs_shft(/* tuple */[
                        n,
                        param[1]
                      ])
                ]);
    case 3 : 
        return /* LAM */Block.__(3, [
                  param[0],
                  param[1],
                  param[2],
                  Esubst$ReactTemplate.subs_shft(/* tuple */[
                        n,
                        param[3]
                      ])
                ]);
    case 4 : 
        return /* FIXP */Block.__(4, [
                  param[0],
                  Esubst$ReactTemplate.subs_shft(/* tuple */[
                        n,
                        param[1]
                      ]),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return shift_value(n, param);
                        }), param[2])
                ]);
    case 5 : 
        return /* COFIXP */Block.__(5, [
                  param[0],
                  Esubst$ReactTemplate.subs_shft(/* tuple */[
                        n,
                        param[1]
                      ]),
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return shift_value(n, param);
                        }), param[2])
                ]);
    case 6 : 
        return /* CONSTR */Block.__(6, [
                  param[0],
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return shift_value(n, param);
                        }), param[1])
                ]);
    
  }
}

function shift_value$1(n, v) {
  if (n) {
    return shift_value(n, v);
  } else {
    return v;
  }
}

function contract_fixp(env, param) {
  var bodies = param[1];
  var bds = bodies[2];
  var match = param[0];
  var reci = match[0];
  var make_body = function (j) {
    return /* FIXP */Block.__(4, [
              /* tuple */[
                /* tuple */[
                  reci,
                  j
                ],
                bodies
              ],
              env,
              /* array */[]
            ]);
  };
  var n = bds.length;
  return /* tuple */[
          Esubst$ReactTemplate.subs_cons(/* tuple */[
                Util$ReactTemplate.$$Array[/* init */0](n, make_body),
                env
              ]),
          Caml_array.caml_array_get(bds, match[1])
        ];
}

function contract_cofixp(env, param) {
  var bodies = param[1];
  var bds = bodies[2];
  var make_body = function (j) {
    return /* COFIXP */Block.__(5, [
              /* tuple */[
                j,
                bodies
              ],
              env,
              /* array */[]
            ]);
  };
  var n = bds.length;
  return /* tuple */[
          Esubst$ReactTemplate.subs_cons(/* tuple */[
                Util$ReactTemplate.$$Array[/* init */0](n, make_body),
                env
              ]),
          Caml_array.caml_array_get(bds, param[0])
        ];
}

function make_constr_ref(n, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Constr$ReactTemplate.mkConstU(param[0]);
    case 1 : 
        return Constr$ReactTemplate.mkVar(param[0]);
    case 2 : 
        return Constr$ReactTemplate.mkRel(n + param[0] | 0);
    
  }
}

function stack_app(appl, stack) {
  if (appl.length) {
    if (typeof stack === "number") {
      return /* APP */Block.__(0, [
                appl,
                stack
              ]);
    } else if (stack.tag) {
      return /* APP */Block.__(0, [
                appl,
                stack
              ]);
    } else {
      return /* APP */Block.__(0, [
                Util$ReactTemplate.$$Array[/* append */3](appl, stack[0]),
                stack[1]
              ]);
    }
  } else {
    return stack;
  }
}

function stack_concat(stk1, stk2) {
  if (typeof stk1 === "number") {
    return stk2;
  } else {
    switch (stk1.tag | 0) {
      case 0 : 
          return /* APP */Block.__(0, [
                    stk1[0],
                    stack_concat(stk1[1], stk2)
                  ]);
      case 1 : 
          return /* CASE */Block.__(1, [
                    stk1[0],
                    stk1[1],
                    stk1[2],
                    stk1[3],
                    stack_concat(stk1[4], stk2)
                  ]);
      case 2 : 
          return /* PROJ */Block.__(2, [
                    stk1[0],
                    stk1[1],
                    stack_concat(stk1[2], stk2)
                  ]);
      
    }
  }
}

function red_set_ref(flags, param) {
  switch (param.tag | 0) {
    case 0 : 
        return CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fCONST */7](param[0][0]));
    case 1 : 
        return CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fVAR */8](param[0]));
    case 2 : 
        return CClosure$ReactTemplate.RedFlags[/* red_set */15](flags, CClosure$ReactTemplate.RedFlags[/* fDELTA */1]);
    
  }
}

function strip_appl(head, stack) {
  switch (head.tag | 0) {
    case 4 : 
        return /* tuple */[
                /* FIXP */Block.__(4, [
                    head[0],
                    head[1],
                    /* array */[]
                  ]),
                stack_app(head[2], stack)
              ];
    case 5 : 
        return /* tuple */[
                /* COFIXP */Block.__(5, [
                    head[0],
                    head[1],
                    /* array */[]
                  ]),
                stack_app(head[2], stack)
              ];
    case 6 : 
        return /* tuple */[
                /* CONSTR */Block.__(6, [
                    head[0],
                    /* array */[]
                  ]),
                stack_app(head[1], stack)
              ];
    default:
      return /* tuple */[
              head,
              stack
            ];
  }
}

function fixp_reducible(flgs, param, stk) {
  var match = param[0];
  var i = match[1];
  var reci = match[0];
  if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flgs, CClosure$ReactTemplate.RedFlags[/* fFIX */4])) {
    if (typeof stk === "number") {
      return /* false */0;
    } else if (stk.tag) {
      return /* false */0;
    } else {
      var appl = stk[0];
      if (appl.length > Caml_array.caml_array_get(reci, i)) {
        var match$1 = Caml_array.caml_array_get(appl, Caml_array.caml_array_get(reci, i));
        if (match$1.tag === 6) {
          return /* true */1;
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    }
  } else {
    return /* false */0;
  }
}

function cofixp_reducible(flgs, _, stk) {
  if (CClosure$ReactTemplate.RedFlags[/* red_set */15](flgs, CClosure$ReactTemplate.RedFlags[/* fCOFIX */5])) {
    if (typeof stk === "number") {
      return /* false */0;
    } else {
      switch (stk.tag | 0) {
        case 0 : 
            var tmp = stk[1];
            if (typeof tmp === "number") {
              return /* false */0;
            } else {
              switch (tmp.tag | 0) {
                case 0 : 
                    return /* false */0;
                case 1 : 
                case 2 : 
                    return /* true */1;
                
              }
            }
            break;
        case 1 : 
        case 2 : 
            return /* true */1;
        
      }
    }
  } else {
    return /* false */0;
  }
}

var debug_cbv = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"cbv visited constants display",
      /* optkey : :: */[
        "Debug",
        /* :: */[
          "Cbv",
          /* [] */0
        ]
      ],
      /* optread */(function () {
          return debug_cbv[0];
        }),
      /* optwrite */(function (a) {
          debug_cbv[0] = a;
          return /* () */0;
        })
    ]);

function pr_key(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Names$ReactTemplate.Constant[/* print */16](param[0][0]);
    case 1 : 
        return Names$ReactTemplate.Id[/* print */8](param[0]);
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("REL_"), Pp$ReactTemplate.$$int(param[0]));
    
  }
}

function reify_stack(_t, _param) {
  while(true) {
    var param = _param;
    var t = _t;
    if (typeof param === "number") {
      return t;
    } else {
      switch (param.tag | 0) {
        case 0 : 
            _param = param[1];
            _t = Constr$ReactTemplate.mkApp(/* tuple */[
                  t,
                  Util$ReactTemplate.$$Array[/* map */12](reify_value, param[0])
                ]);
            continue ;
            case 1 : 
            _param = param[4];
            _t = Constr$ReactTemplate.mkCase(/* tuple */[
                  param[2],
                  param[0],
                  t,
                  param[1]
                ]);
            continue ;
            case 2 : 
            _param = param[2];
            _t = Constr$ReactTemplate.mkProj(/* tuple */[
                  param[0],
                  t
                ]);
            continue ;
            
      }
    }
  };
}

function reify_value(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Vars$ReactTemplate.lift(param[0])(param[1]);
    case 1 : 
        var n = param[0];
        if (n !== 0) {
          return Vars$ReactTemplate.lift(n)(reify_stack(reify_value(param[1]), param[2]));
        } else {
          return reify_stack(reify_value(param[1]), param[2]);
        }
    case 2 : 
        return apply_env(param[1], param[0]);
    case 3 : 
        return apply_env(param[3], Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (c, param) {
                          return Constr$ReactTemplate.mkLambda(/* tuple */[
                                      param[0],
                                      param[1],
                                      c
                                    ]);
                        }), param[2], param[1]));
    case 4 : 
        var match = param[0];
        var match$1 = match[1];
        var fix = Constr$ReactTemplate.mkFix(/* tuple */[
              match[0],
              /* tuple */[
                match$1[0],
                match$1[1],
                match$1[2]
              ]
            ]);
        return Constr$ReactTemplate.mkApp(/* tuple */[
                    apply_env(param[1], fix),
                    Util$ReactTemplate.$$Array[/* map */12](reify_value, param[2])
                  ]);
    case 5 : 
        var match$2 = param[0];
        var match$3 = match$2[1];
        var cofix = Constr$ReactTemplate.mkCoFix(/* tuple */[
              match$2[0],
              /* tuple */[
                match$3[0],
                match$3[1],
                match$3[2]
              ]
            ]);
        return Constr$ReactTemplate.mkApp(/* tuple */[
                    apply_env(param[1], cofix),
                    Util$ReactTemplate.$$Array[/* map */12](reify_value, param[2])
                  ]);
    case 6 : 
        return Constr$ReactTemplate.mkApp(/* tuple */[
                    Constr$ReactTemplate.mkConstructU(param[0]),
                    Util$ReactTemplate.$$Array[/* map */12](reify_value, param[1])
                  ]);
    
  }
}

function apply_env(env, t) {
  var match = Constr$ReactTemplate.kind(t);
  if (match.tag) {
    return Constr$ReactTemplate.map_with_binders(Esubst$ReactTemplate.subs_lift, apply_env, env, t);
  } else {
    var match$1 = Esubst$ReactTemplate.expand_rel(match[0], env);
    if (match$1.tag) {
      return Constr$ReactTemplate.mkRel(match$1[0][0]);
    } else {
      var match$2 = match$1[0];
      return reify_value(shift_value$1(match$2[0], match$2[1]));
    }
  }
}

function norm_head(info, _env, _t, _stack) {
  while(true) {
    var stack = _stack;
    var t = _t;
    var env = _env;
    var match = Constr$ReactTemplate.kind(t);
    switch (match.tag | 0) {
      case 0 : 
          var match$1 = Esubst$ReactTemplate.expand_rel(match[0], env);
          if (match$1.tag) {
            var match$2 = match$1[0];
            var match$3 = match$2[1];
            var n = match$2[0];
            if (match$3) {
              var p = match$3[0];
              return norm_head_ref(n - p | 0, info, env, stack, /* RelKey */Block.__(2, [p]));
            } else {
              return /* tuple */[
                      /* VAL */Block.__(0, [
                          0,
                          Constr$ReactTemplate.mkRel(n)
                        ]),
                      stack
                    ];
            }
          } else {
            var match$4 = match$1[0];
            var n$1 = match$4[0];
            if (n$1 !== 0) {
              return strip_appl(shift_value$1(n$1, match$4[1]), stack);
            } else {
              return strip_appl(match$4[1], stack);
            }
          }
          break;
      case 1 : 
          return norm_head_ref(0, info, env, stack, /* VarKey */Block.__(1, [match[0]]));
      case 3 : 
          var ev = match[0];
          var match$5 = CClosure$ReactTemplate.evar_value(info[/* infos */1][/* i_cache */1], ev);
          if (match$5) {
            _t = match$5[0];
            continue ;
            
          } else {
            var xs$prime = Util$ReactTemplate.$$Array[/* map */12]((function(env){
                return function (param) {
                  return apply_env(env, param);
                }
                }(env)), ev[1]);
            return /* tuple */[
                    /* VAL */Block.__(0, [
                        0,
                        Constr$ReactTemplate.mkEvar(/* tuple */[
                              ev[0],
                              xs$prime
                            ])
                      ]),
                    stack
                  ];
          }
          break;
      case 5 : 
          _t = match[0];
          continue ;
          case 6 : 
          return /* tuple */[
                  /* CBN */Block.__(2, [
                      t,
                      env
                    ]),
                  stack
                ];
      case 7 : 
          var match$6 = Term$ReactTemplate.decompose_lam(t);
          var ctxt = match$6[0];
          return /* tuple */[
                  /* LAM */Block.__(3, [
                      Curry._1(Util$ReactTemplate.List[/* length */0], ctxt),
                      Curry._1(Util$ReactTemplate.List[/* rev */4], ctxt),
                      match$6[1],
                      env
                    ]),
                  stack
                ];
      case 8 : 
          if (CClosure$ReactTemplate.RedFlags[/* red_set */15](CClosure$ReactTemplate.info_flags(info[/* infos */1]), CClosure$ReactTemplate.RedFlags[/* fZETA */6])) {
            var env$prime = Esubst$ReactTemplate.subs_cons(/* tuple */[
                  /* array */[cbv_stack_term(info, /* TOP */0, env, match[1])],
                  env
                ]);
            _t = match[3];
            _env = env$prime;
            continue ;
            
          } else {
            return /* tuple */[
                    /* CBN */Block.__(2, [
                        t,
                        env
                      ]),
                    stack
                  ];
          }
          break;
      case 9 : 
          var nargs = Util$ReactTemplate.$$Array[/* map */12]((function(env){
              return function (param) {
                return cbv_stack_term(info, /* TOP */0, env, param);
              }
              }(env)), match[1]);
          _stack = stack_app(nargs, stack);
          _t = match[0];
          continue ;
          case 10 : 
          Reductionops$ReactTemplate.reduction_effect_hook(CClosure$ReactTemplate.env_of_infos(info[/* infos */1]), info[/* sigma */2], t, Block.__(246, [(function(t,stack){
                  return function () {
                    return reify_stack(t, stack);
                  }
                  }(t,stack))]));
          return norm_head_ref(0, info, env, stack, /* ConstKey */Block.__(0, [match[0]]));
      case 12 : 
          return /* tuple */[
                  /* CONSTR */Block.__(6, [
                      match[0],
                      /* array */[]
                    ]),
                  stack
                ];
      case 13 : 
          _stack = /* CASE */Block.__(1, [
              match[1],
              match[3],
              match[0],
              env,
              stack
            ]);
          _t = match[2];
          continue ;
          case 14 : 
          return /* tuple */[
                  /* FIXP */Block.__(4, [
                      match[0],
                      env,
                      /* array */[]
                    ]),
                  stack
                ];
      case 15 : 
          return /* tuple */[
                  /* COFIXP */Block.__(5, [
                      match[0],
                      env,
                      /* array */[]
                    ]),
                  stack
                ];
      case 16 : 
          var p$1 = match[0];
          var p$prime = CClosure$ReactTemplate.RedFlags[/* red_set */15](CClosure$ReactTemplate.info_flags(info[/* infos */1]), CClosure$ReactTemplate.RedFlags[/* fCONST */7](Names$ReactTemplate.Projection[/* constant */2](p$1))) && CClosure$ReactTemplate.RedFlags[/* red_set */15](CClosure$ReactTemplate.info_flags(info[/* infos */1]), CClosure$ReactTemplate.RedFlags[/* fBETA */0]) ? Names$ReactTemplate.Projection[/* unfold */4](p$1) : p$1;
          var pinfo = Environ$ReactTemplate.lookup_projection(p$1, CClosure$ReactTemplate.info_env(info[/* infos */1]));
          _stack = /* PROJ */Block.__(2, [
              p$prime,
              pinfo,
              stack
            ]);
          _t = match[1];
          continue ;
          default:
        return /* tuple */[
                /* VAL */Block.__(0, [
                    0,
                    t
                  ]),
                stack
              ];
    }
  };
}

function norm_head_ref(k, info, _, stack, normt) {
  if (red_set_ref(CClosure$ReactTemplate.info_flags(info[/* infos */1]), normt)) {
    var match = CClosure$ReactTemplate.ref_value_cache(info[/* infos */1], info[/* tab */0], normt);
    if (match) {
      if (debug_cbv[0]) {
        Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unfolding "), pr_key(normt)));
      }
      return strip_appl(shift_value$1(k, match[0]), stack);
    } else {
      if (debug_cbv[0]) {
        Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Not unfolding "), pr_key(normt)));
      }
      return /* tuple */[
              /* VAL */Block.__(0, [
                  0,
                  make_constr_ref(k, normt)
                ]),
              stack
            ];
    }
  } else {
    if (debug_cbv[0]) {
      Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Not unfolding "), pr_key(normt)));
    }
    return /* tuple */[
            /* VAL */Block.__(0, [
                0,
                make_constr_ref(k, normt)
              ]),
            stack
          ];
  }
}

function cbv_stack_term(info, stack, env, t) {
  var info$1 = info;
  var _param = norm_head(info, env, t, stack);
  while(true) {
    var param = _param;
    var head = param[0];
    var exit = 0;
    switch (head.tag | 0) {
      case 3 : 
          var match = param[1];
          if (typeof match === "number") {
            exit = 1;
          } else if (match.tag) {
            exit = 1;
          } else {
            var stk = match[1];
            var args = match[0];
            var env$1 = head[3];
            var b = head[2];
            var nlams = head[0];
            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](CClosure$ReactTemplate.info_flags(info$1[/* infos */1]), CClosure$ReactTemplate.RedFlags[/* fBETA */0])) {
              var nargs = args.length;
              if (nargs === nlams) {
                return cbv_stack_term(info$1, stk, Esubst$ReactTemplate.subs_cons(/* tuple */[
                                args,
                                env$1
                              ]), b);
              } else if (nlams < nargs) {
                var env$prime = Esubst$ReactTemplate.subs_cons(/* tuple */[
                      Util$ReactTemplate.$$Array[/* sub */5](args, 0, nlams),
                      env$1
                    ]);
                var eargs = Util$ReactTemplate.$$Array[/* sub */5](args, nlams, nargs - nlams | 0);
                return cbv_stack_term(info$1, /* APP */Block.__(0, [
                              eargs,
                              stk
                            ]), env$prime, b);
              } else {
                var ctxt$prime = Curry._2(Util$ReactTemplate.List[/* skipn */107], nargs, head[1]);
                return /* LAM */Block.__(3, [
                          nlams - nargs | 0,
                          ctxt$prime,
                          b,
                          Esubst$ReactTemplate.subs_cons(/* tuple */[
                                args,
                                env$1
                              ])
                        ]);
              }
            } else {
              exit = 1;
            }
          }
          break;
      case 4 : 
          if (head[2].length !== 0) {
            exit = 1;
          } else {
            var stk$1 = param[1];
            var env$2 = head[1];
            var fix = head[0];
            if (fixp_reducible(CClosure$ReactTemplate.info_flags(info$1[/* infos */1]), fix, stk$1)) {
              var match$1 = contract_fixp(env$2, fix);
              return cbv_stack_term(info$1, stk$1, match$1[0], match$1[1]);
            } else if (typeof stk$1 === "number") {
              exit = 1;
            } else if (stk$1.tag) {
              exit = 1;
            } else if (typeof stk$1[1] === "number") {
              return /* FIXP */Block.__(4, [
                        fix,
                        env$2,
                        stk$1[0]
                      ]);
            } else {
              exit = 1;
            }
          }
          break;
      case 5 : 
          if (head[2].length !== 0) {
            exit = 1;
          } else {
            var stk$2 = param[1];
            var env$3 = head[1];
            var cofix = head[0];
            if (cofixp_reducible(CClosure$ReactTemplate.info_flags(info$1[/* infos */1]), cofix, stk$2)) {
              var match$2 = contract_cofixp(env$3, cofix);
              return cbv_stack_term(info$1, stk$2, match$2[0], match$2[1]);
            } else if (typeof stk$2 === "number") {
              exit = 1;
            } else if (stk$2.tag) {
              exit = 1;
            } else if (typeof stk$2[1] === "number") {
              return /* COFIXP */Block.__(5, [
                        cofix,
                        env$3,
                        stk$2[0]
                      ]);
            } else {
              exit = 1;
            }
          }
          break;
      case 6 : 
          if (head[1].length !== 0) {
            exit = 1;
          } else {
            var match$3 = param[1];
            var c = head[0];
            var n = c[0][1];
            if (typeof match$3 === "number") {
              exit = 1;
            } else {
              switch (match$3.tag | 0) {
                case 0 : 
                    var match$4 = match$3[1];
                    var args$1 = match$3[0];
                    if (typeof match$4 === "number") {
                      return /* CONSTR */Block.__(6, [
                                c,
                                args$1
                              ]);
                    } else {
                      switch (match$4.tag | 0) {
                        case 0 : 
                            exit = 1;
                            break;
                        case 1 : 
                            var ci = match$4[2];
                            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](CClosure$ReactTemplate.info_flags(info$1[/* infos */1]), CClosure$ReactTemplate.RedFlags[/* fMATCH */3])) {
                              var cargs = Util$ReactTemplate.$$Array[/* sub */5](args$1, ci[/* ci_npar */1], args$1.length - ci[/* ci_npar */1] | 0);
                              return cbv_stack_term(info$1, stack_app(cargs, match$4[4]), match$4[3], Caml_array.caml_array_get(match$4[1], n - 1 | 0));
                            } else {
                              exit = 1;
                            }
                            break;
                        case 2 : 
                            var pi = match$4[1];
                            if (CClosure$ReactTemplate.RedFlags[/* red_set */15](CClosure$ReactTemplate.info_flags(info$1[/* infos */1]), CClosure$ReactTemplate.RedFlags[/* fMATCH */3]) && Names$ReactTemplate.Projection[/* unfolded */3](match$4[0])) {
                              var arg = Caml_array.caml_array_get(args$1, pi[/* proj_npars */1] + pi[/* proj_arg */2] | 0);
                              _param = strip_appl(arg, match$4[2]);
                              continue ;
                              
                            } else {
                              exit = 1;
                            }
                            break;
                        
                      }
                    }
                    break;
                case 1 : 
                    if (CClosure$ReactTemplate.RedFlags[/* red_set */15](CClosure$ReactTemplate.info_flags(info$1[/* infos */1]), CClosure$ReactTemplate.RedFlags[/* fMATCH */3])) {
                      return cbv_stack_term(info$1, match$3[4], match$3[3], Caml_array.caml_array_get(match$3[1], n - 1 | 0));
                    } else {
                      exit = 1;
                    }
                    break;
                case 2 : 
                    exit = 1;
                    break;
                
              }
            }
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      var param$1 = /* tuple */[
        head,
        param[1]
      ];
      var v = param$1[0];
      if (typeof param$1[1] === "number") {
        return v;
      } else if (v.tag === 1) {
        if (v[0] !== 0) {
          return /* STACK */Block.__(1, [
                    0,
                    v,
                    param$1[1]
                  ]);
        } else {
          return /* STACK */Block.__(1, [
                    0,
                    v[1],
                    stack_concat(v[2], param$1[1])
                  ]);
        }
      } else {
        return /* STACK */Block.__(1, [
                  0,
                  v,
                  param$1[1]
                ]);
      }
    }
    
  };
}

function apply_stack(info, _t, _param) {
  while(true) {
    var param = _param;
    var t = _t;
    if (typeof param === "number") {
      return t;
    } else {
      switch (param.tag | 0) {
        case 0 : 
            _param = param[1];
            _t = Constr$ReactTemplate.mkApp(/* tuple */[
                  t,
                  Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                          return cbv_norm_value(info, param);
                        }), param[0])
                ]);
            continue ;
            case 1 : 
            var env = param[3];
            _param = param[4];
            _t = Constr$ReactTemplate.mkCase(/* tuple */[
                  param[2],
                  cbv_norm_term(info, env, param[0]),
                  t,
                  Util$ReactTemplate.$$Array[/* map */12]((function(env){
                      return function (param) {
                        return cbv_norm_term(info, env, param);
                      }
                      }(env)), param[1])
                ]);
            continue ;
            case 2 : 
            _param = param[2];
            _t = Constr$ReactTemplate.mkProj(/* tuple */[
                  param[0],
                  t
                ]);
            continue ;
            
      }
    }
  };
}

function cbv_norm_term(info, env, t) {
  return cbv_norm_value(info, cbv_stack_term(info, /* TOP */0, env, t));
}

function cbv_norm_value(info, param) {
  switch (param.tag | 0) {
    case 0 : 
        return Vars$ReactTemplate.lift(param[0])(param[1]);
    case 1 : 
        var n = param[0];
        if (n !== 0) {
          return Vars$ReactTemplate.lift(n)(apply_stack(info, cbv_norm_value(info, param[1]), param[2]));
        } else {
          return apply_stack(info, cbv_norm_value(info, param[1]), param[2]);
        }
    case 2 : 
        return Constr$ReactTemplate.map_with_binders(Esubst$ReactTemplate.subs_lift, (function (param, param$1) {
                      return cbv_norm_term(info, param, param$1);
                    }), param[1], param[0]);
    case 3 : 
        var env = param[3];
        var nctxt = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, param) {
                return /* tuple */[
                        param[0],
                        cbv_norm_term(info, Esubst$ReactTemplate.subs_liftn(i, env), param[1])
                      ];
              }), 0, param[1]);
        return Term$ReactTemplate.compose_lam(Curry._1(Util$ReactTemplate.List[/* rev */4], nctxt), cbv_norm_term(info, Esubst$ReactTemplate.subs_liftn(param[0], env), param[2]));
    case 4 : 
        var env$1 = param[1];
        var match = param[0];
        var match$1 = match[1];
        var lty = match$1[1];
        var partial_arg = Esubst$ReactTemplate.subs_liftn(lty.length, env$1);
        return Constr$ReactTemplate.mkApp(/* tuple */[
                    Constr$ReactTemplate.mkFix(/* tuple */[
                          match[0],
                          /* tuple */[
                            match$1[0],
                            Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                    return cbv_norm_term(info, env$1, param);
                                  }), lty),
                            Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                    return cbv_norm_term(info, partial_arg, param);
                                  }), match$1[2])
                          ]
                        ]),
                    Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                            return cbv_norm_value(info, param);
                          }), param[2])
                  ]);
    case 5 : 
        var env$2 = param[1];
        var match$2 = param[0];
        var match$3 = match$2[1];
        var lty$1 = match$3[1];
        var partial_arg$1 = Esubst$ReactTemplate.subs_liftn(lty$1.length, env$2);
        return Constr$ReactTemplate.mkApp(/* tuple */[
                    Constr$ReactTemplate.mkCoFix(/* tuple */[
                          match$2[0],
                          /* tuple */[
                            match$3[0],
                            Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                    return cbv_norm_term(info, env$2, param);
                                  }), lty$1),
                            Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                    return cbv_norm_term(info, partial_arg$1, param);
                                  }), match$3[2])
                          ]
                        ]),
                    Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                            return cbv_norm_value(info, param);
                          }), param[2])
                  ]);
    case 6 : 
        return Constr$ReactTemplate.mkApp(/* tuple */[
                    Constr$ReactTemplate.mkConstructU(param[0]),
                    Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                            return cbv_norm_value(info, param);
                          }), param[1])
                  ]);
    
  }
}

function cbv_norm(infos, constr) {
  var constr$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](constr);
  return EConstr$ReactTemplate.of_constr(CClosure$ReactTemplate.with_stats(Block.__(246, [(function () {
                        return cbv_norm_term(infos, Esubst$ReactTemplate.subs_id(0), constr$1);
                      })])));
}

function create_cbv_infos(flgs, env, sigma) {
  var infos = CClosure$ReactTemplate.create((function (old_info, tab, c) {
          return cbv_stack_term(/* record */[
                      /* tab */tab,
                      /* infos */old_info,
                      /* sigma */sigma
                    ], /* TOP */0, Esubst$ReactTemplate.subs_id(0), c);
        }), flgs, env, (function (param) {
          return Reductionops$ReactTemplate.safe_evar_value(sigma, param);
        }));
  return /* record */[
          /* tab */CClosure$ReactTemplate.create_tab(/* () */0),
          /* infos */infos,
          /* sigma */sigma
        ];
}

exports.create_cbv_infos = create_cbv_infos;
exports.cbv_norm = cbv_norm;
exports.shift_value = shift_value$1;
exports.stack_app = stack_app;
exports.strip_appl = strip_appl;
exports.cbv_stack_term = cbv_stack_term;
exports.cbv_norm_term = cbv_norm_term;
exports.norm_head = norm_head;
exports.apply_stack = apply_stack;
exports.cbv_norm_value = cbv_norm_value;
/*  Not a pure module */
