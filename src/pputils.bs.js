// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Genarg$ReactTemplate = require("./genarg.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Genprint$ReactTemplate = require("./genprint.bs.js");

var beautify_comments = [/* [] */0];

function extract_comments(pos) {
  var _comacc = /* [] */0;
  var _acc = /* [] */0;
  var pos$1 = pos;
  var _param = beautify_comments[0];
  while(true) {
    var param = _param;
    var acc = _acc;
    var comacc = _comacc;
    if (param) {
      var coms = param[1];
      var com = param[0];
      var match = com[0];
      _param = coms;
      if (match[1] <= pos$1 || pos$1 === match[0]) {
        _comacc = /* :: */[
          com[1],
          comacc
        ];
        continue ;
        
      } else {
        _acc = /* :: */[
          com,
          acc
        ];
        continue ;
        
      }
    } else {
      beautify_comments[0] = Curry._1(Util$ReactTemplate.List[/* rev */4], acc);
      return comacc;
    }
  };
}

function pr_located(pr, param) {
  var x = param[1];
  var loc = param[0];
  if (loc) {
    if (Flags$ReactTemplate.beautify[0]) {
      var match = Loc$ReactTemplate.unloc(loc[0]);
      var before = Pp$ReactTemplate.comment(extract_comments(match[0]));
      var x$1 = Curry._1(pr, x);
      var after = Pp$ReactTemplate.comment(extract_comments(match[1]));
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(before, x$1), after);
    } else {
      return Curry._1(pr, x);
    }
  } else {
    return Curry._1(pr, x);
  }
}

function pr_ast(pr, param) {
  return pr_located(pr, /* tuple */[
              param[/* loc */1],
              param[/* v */0]
            ]);
}

function pr_or_var(pr, param) {
  if (param.tag) {
    return Names$ReactTemplate.Id[/* print */8](param[0][/* v */0]);
  } else {
    return Curry._1(pr, param[0]);
  }
}

function pr_with_occurrences(pr, keyword, param) {
  var c = param[1];
  var occs = param[0];
  if (typeof occs === "number") {
    if (occs) {
      return Pervasives.failwith("pr_with_occurrences: no occurrences");
    } else {
      return Curry._1(pr, c);
    }
  } else if (occs.tag) {
    return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(pr, c), Pp$ReactTemplate.spc(/* () */0)), Curry._1(keyword, "at")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                              return pr_or_var(Pp$ReactTemplate.$$int, param);
                            }), occs[0]))));
  } else {
    return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(pr, c), Pp$ReactTemplate.spc(/* () */0)), Curry._1(keyword, "at")), Pp$ReactTemplate.str(" - ")), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                              return pr_or_var(Pp$ReactTemplate.$$int, param);
                            }), occs[0]))));
  }
}

var ComplexRedFlag = Caml_exceptions.create("Pputils-ReactTemplate.ComplexRedFlag");

function pr_short_red_flag(pr, r) {
  if (!r[/* rBeta */0] || !r[/* rMatch */1] || !r[/* rFix */2] || !r[/* rCofix */3] || !r[/* rZeta */4]) {
    throw ComplexRedFlag;
  } else if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], r[/* rConst */6])) {
    if (r[/* rDelta */5]) {
      return Pp$ReactTemplate.mt(/* () */0);
    } else {
      throw ComplexRedFlag;
    }
  } else {
    return Pp$ReactTemplate.$plus$plus(r[/* rDelta */5] ? Pp$ReactTemplate.str("-") : Pp$ReactTemplate.mt(/* () */0), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr, r[/* rConst */6])), Pp$ReactTemplate.str("]"))));
  }
}

function pr_red_flag(pr, r) {
  try {
    return pr_short_red_flag(pr, r);
  }
  catch (complexRedFlags){
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(r[/* rBeta */0] ? Pp$ReactTemplate.pr_arg(Pp$ReactTemplate.str, "beta") : Pp$ReactTemplate.mt(/* () */0), r[/* rMatch */1] && r[/* rFix */2] && r[/* rCofix */3] ? Pp$ReactTemplate.pr_arg(Pp$ReactTemplate.str, "iota") : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(r[/* rMatch */1] ? Pp$ReactTemplate.pr_arg(Pp$ReactTemplate.str, "match") : Pp$ReactTemplate.mt(/* () */0), r[/* rFix */2] ? Pp$ReactTemplate.pr_arg(Pp$ReactTemplate.str, "fix") : Pp$ReactTemplate.mt(/* () */0)), r[/* rCofix */3] ? Pp$ReactTemplate.pr_arg(Pp$ReactTemplate.str, "cofix") : Pp$ReactTemplate.mt(/* () */0))), r[/* rZeta */4] ? Pp$ReactTemplate.pr_arg(Pp$ReactTemplate.str, "zeta") : Pp$ReactTemplate.mt(/* () */0)), Curry._1(Util$ReactTemplate.List[/* is_empty */45], r[/* rConst */6]) ? (
                  r[/* rDelta */5] ? Pp$ReactTemplate.pr_arg(Pp$ReactTemplate.str, "delta") : Pp$ReactTemplate.mt(/* () */0)
                ) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_arg(Pp$ReactTemplate.str, "delta "), r[/* rDelta */5] ? Pp$ReactTemplate.str("-") : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr, r[/* rConst */6])), Pp$ReactTemplate.str("]")))));
  }
}

function pr_union(pr1, pr2, param) {
  if (param.tag) {
    return Curry._1(pr2, param[0]);
  } else {
    return Curry._1(pr1, param[0]);
  }
}

function pr_red_expr(param, keyword, param$1) {
  var pr_pattern = param[3];
  var pr_ref = param[2];
  var pr_constr = param[0];
  if (typeof param$1 === "number") {
    return Curry._1(keyword, "hnf");
  } else {
    switch (param$1.tag | 0) {
      case 0 : 
          if (param$1[0] !== 0) {
            return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Shouldn't be accessible from user."));
          } else {
            return Curry._1(keyword, "red");
          }
      case 1 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(keyword, "simpl"), pr_short_red_flag(pr_ref, param$1[0])), Pp$ReactTemplate.pr_opt((function (param) {
                            return pr_with_occurrences((function (param) {
                                          return pr_union(pr_ref, pr_pattern, param);
                                        }), keyword, param);
                          }), param$1[1]));
      case 2 : 
          var f = param$1[0];
          if (f[/* rBeta */0] && f[/* rMatch */1] && f[/* rFix */2] && f[/* rCofix */3] && f[/* rZeta */4] && f[/* rDelta */5] && Curry._1(Util$ReactTemplate.List[/* is_empty */45], f[/* rConst */6])) {
            return Curry._1(keyword, "compute");
          } else {
            return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Curry._1(keyword, "cbv"), pr_red_flag(pr_ref, f)));
          }
      case 3 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Curry._1(keyword, "cbn"), pr_red_flag(pr_ref, param$1[0])));
      case 4 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Curry._1(keyword, "lazy"), pr_red_flag(pr_ref, param$1[0])));
      case 5 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(keyword, "unfold"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, (function (param) {
                                return pr_with_occurrences(pr_ref, keyword, param);
                              }), param$1[0])));
      case 6 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Curry._1(keyword, "fold"), Pp$ReactTemplate.prlist((function (param) {
                                return Pp$ReactTemplate.pr_arg(pr_constr, param);
                              }), param$1[0])));
      case 7 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Curry._1(keyword, "pattern"), Pp$ReactTemplate.pr_arg((function (param) {
                                return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, (function (param) {
                                              return pr_with_occurrences(pr_constr, keyword, param);
                                            }), param);
                              }), param$1[0])));
      case 8 : 
          return Pp$ReactTemplate.str(param$1[0]);
      case 9 : 
          return Pp$ReactTemplate.$plus$plus(Curry._1(keyword, "vm_compute"), Pp$ReactTemplate.pr_opt((function (param) {
                            return pr_with_occurrences((function (param) {
                                          return pr_union(pr_ref, pr_pattern, param);
                                        }), keyword, param);
                          }), param$1[0]));
      
    }
  }
}

function pr_red_expr_env(env, sigma, param) {
  var partial_arg_000 = Curry._2(param[0], env, sigma);
  var partial_arg_001 = Curry._2(param[1], env, sigma);
  var partial_arg_002 = param[2];
  var partial_arg_003 = Curry._2(param[3], env, sigma);
  var partial_arg = /* tuple */[
    partial_arg_000,
    partial_arg_001,
    partial_arg_002,
    partial_arg_003
  ];
  return (function (param, param$1) {
      return pr_red_expr(partial_arg, param, param$1);
    });
}

function pr_or_by_notation(f, param) {
  var match = param[/* v */0];
  if (match.tag) {
    var match$1 = match[0];
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.qs(match$1[0]), Pp$ReactTemplate.pr_opt((function (sc) {
                      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("%"), Pp$ReactTemplate.str(sc));
                    }), match$1[1]));
  } else {
    return Curry._1(f, match[0]);
  }
}

function hov_if_not_empty(n, p) {
  if (Pp$ReactTemplate.ismt(p)) {
    return p;
  } else {
    return Pp$ReactTemplate.hov(n, p);
  }
}

function pr_raw_generic(env, param) {
  var x = param[1];
  var wit = param[0][0];
  switch (wit.tag | 0) {
    case 0 : 
        var match = Genprint$ReactTemplate.generic_raw_print(Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.rawwit(wit), x));
        if (match.tag) {
          var match$1 = match[0];
          return Curry._1(match$1[/* printer */2], match$1[/* default_ensure_surrounded */1]);
        } else {
          return Curry._1(match[0], /* () */0);
        }
        break;
    case 1 : 
        var wit$1 = wit[0];
        var map = function (x) {
          return pr_raw_generic(env, Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.rawwit(wit$1), x));
        };
        var ans = Pp$ReactTemplate.pr_sequence(map, x);
        return hov_if_not_empty(0, ans);
    case 2 : 
        var ans$1 = x ? pr_raw_generic(env, Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.rawwit(wit[0]), x[0])) : Pp$ReactTemplate.mt(/* () */0);
        return hov_if_not_empty(0, ans$1);
    case 3 : 
        var p = Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.rawwit(wit[0]), x[0]);
        var q = Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.rawwit(wit[1]), x[1]);
        return hov_if_not_empty(0, Pp$ReactTemplate.pr_sequence((function (param) {
                          return pr_raw_generic(env, param);
                        }), /* :: */[
                        p,
                        /* :: */[
                          q,
                          /* [] */0
                        ]
                      ]));
    
  }
}

function pr_glb_generic(env, param) {
  var x = param[1];
  var wit = param[0][0];
  switch (wit.tag | 0) {
    case 0 : 
        var match = Genprint$ReactTemplate.generic_glb_print(Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.glbwit(wit), x));
        if (match.tag) {
          var match$1 = match[0];
          return Curry._1(match$1[/* printer */2], match$1[/* default_ensure_surrounded */1]);
        } else {
          return Curry._1(match[0], /* () */0);
        }
        break;
    case 1 : 
        var wit$1 = wit[0];
        var map = function (x) {
          return pr_glb_generic(env, Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.glbwit(wit$1), x));
        };
        var ans = Pp$ReactTemplate.pr_sequence(map, x);
        return hov_if_not_empty(0, ans);
    case 2 : 
        var ans$1 = x ? pr_glb_generic(env, Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.glbwit(wit[0]), x[0])) : Pp$ReactTemplate.mt(/* () */0);
        return hov_if_not_empty(0, ans$1);
    case 3 : 
        var p = Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.glbwit(wit[0]), x[0]);
        var q = Genarg$ReactTemplate.in_gen(Genarg$ReactTemplate.glbwit(wit[1]), x[1]);
        var ans$2 = Pp$ReactTemplate.pr_sequence((function (param) {
                return pr_glb_generic(env, param);
              }), /* :: */[
              p,
              /* :: */[
                q,
                /* [] */0
              ]
            ]);
        return hov_if_not_empty(0, ans$2);
    
  }
}

exports.pr_located = pr_located;
exports.pr_ast = pr_ast;
exports.pr_or_var = pr_or_var;
exports.pr_or_by_notation = pr_or_by_notation;
exports.pr_with_occurrences = pr_with_occurrences;
exports.pr_short_red_flag = pr_short_red_flag;
exports.pr_red_flag = pr_red_flag;
exports.pr_red_expr = pr_red_expr;
exports.pr_red_expr_env = pr_red_expr_env;
exports.pr_raw_generic = pr_raw_generic;
exports.pr_glb_generic = pr_glb_generic;
exports.beautify_comments = beautify_comments;
exports.extract_comments = extract_comments;
/* Pp-ReactTemplate Not a pure module */
