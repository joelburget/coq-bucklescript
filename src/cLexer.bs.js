// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Buffer = require("bs-platform/lib/js/buffer.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var Tok$ReactTemplate = require("./tok.bs.js");
var Ploc$ReactTemplate = require("../camlp5/ocaml_src/lib/ploc.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CString$ReactTemplate = require("./cString.bs.js");
var Unicode$ReactTemplate = require("./unicode.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function ploc_file_of_coq_file(param) {
  if (param) {
    return param[0];
  } else {
    return "";
  }
}

function coq_file_of_ploc_file(s) {
  if (s === "") {
    return /* ToplevelInput */0;
  } else {
    return /* InFile */[s];
  }
}

function from_coqloc(fname, line_nb, bol_pos, bp, ep) {
  return Ploc$ReactTemplate.make_loc(ploc_file_of_coq_file(fname), line_nb, bol_pos, /* tuple */[
              bp,
              ep
            ], "");
}

function to_coqloc(loc) {
  return /* record */[
          /* fname */coq_file_of_ploc_file(Ploc$ReactTemplate.file_name(loc)),
          /* line_nb */Ploc$ReactTemplate.line_nb(loc),
          /* bol_pos */Ploc$ReactTemplate.bol_pos(loc),
          /* line_nb_last */Ploc$ReactTemplate.line_nb_last(loc),
          /* bol_pos_last */Ploc$ReactTemplate.bol_pos_last(loc),
          /* bp */Ploc$ReactTemplate.first_pos(loc),
          /* ep */Ploc$ReactTemplate.last_pos(loc)
        ];
}

var compare = Caml_obj.caml_compare;

var CharOrd = /* module */[/* compare */compare];

var CharMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], CharOrd);

var empty_ttree_001 = /* branch */CharMap[/* empty */0];

var empty_ttree = /* record */[
  /* node : None */0,
  empty_ttree_001
];

function ttree_add(ttree, str) {
  var insert = function (tt, i) {
    if (i === str.length) {
      return /* record */[
              /* node : Some */[str],
              /* branch */tt[/* branch */1]
            ];
    } else {
      var c = Caml_string.get(str, i);
      var match;
      try {
        match = /* Some */[Curry._2(CharMap[/* find */21], c, tt[/* branch */1])];
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          match = /* None */0;
        } else {
          throw exn;
        }
      }
      var br;
      if (match) {
        br = Curry._3(CharMap[/* add */3], c, insert(match[0], i + 1 | 0), Curry._2(CharMap[/* remove */5], c, tt[/* branch */1]));
      } else {
        var tt$prime_001 = /* branch */CharMap[/* empty */0];
        var tt$prime = /* record */[
          /* node : None */0,
          tt$prime_001
        ];
        br = Curry._3(CharMap[/* add */3], c, insert(tt$prime, i + 1 | 0), tt[/* branch */1]);
      }
      return /* record */[
              /* node */tt[/* node */0],
              /* branch */br
            ];
    }
  };
  return insert(ttree, 0);
}

function ttree_find(ttree, str) {
  var _tt = ttree;
  var _i = 0;
  while(true) {
    var i = _i;
    var tt = _tt;
    if (i === str.length) {
      return tt;
    } else {
      _i = i + 1 | 0;
      _tt = Curry._2(CharMap[/* find */21], Caml_string.get(str, i), tt[/* branch */1]);
      continue ;
      
    }
  };
}

function ttree_remove(ttree, str) {
  var remove = function (tt, i) {
    if (i === str.length) {
      return /* record */[
              /* node : None */0,
              /* branch */tt[/* branch */1]
            ];
    } else {
      var c = Caml_string.get(str, i);
      var match;
      try {
        match = /* Some */[Curry._2(CharMap[/* find */21], c, tt[/* branch */1])];
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          match = /* None */0;
        } else {
          throw exn;
        }
      }
      var br = match ? Curry._3(CharMap[/* add */3], c, remove(match[0], i + 1 | 0), Curry._2(CharMap[/* remove */5], c, tt[/* branch */1])) : tt[/* branch */1];
      return /* record */[
              /* node */tt[/* node */0],
              /* branch */br
            ];
    }
  };
  return remove(ttree, 0);
}

var E = Caml_exceptions.create("CLexer-ReactTemplate.Error.E");

function to_string(x) {
  var tmp;
  if (typeof x === "number") {
    switch (x) {
      case 0 : 
          tmp = "Illegal character";
          break;
      case 1 : 
          tmp = "Unterminated comment";
          break;
      case 2 : 
          tmp = "Unterminated string";
          break;
      case 3 : 
          tmp = "Undefined token";
          break;
      
    }
  } else {
    tmp = Curry._1(Format.sprintf(/* Format */[
              /* String_literal */Block.__(11, [
                  "Bad token ",
                  /* Caml_string */Block.__(3, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ])
                ]),
              "Bad token %S"
            ]), x[0]);
  }
  return "Syntax Error: Lexer: " + tmp;
}

var $$Error = /* module */[
  /* E */E,
  /* to_string */to_string
];

function err(loc, str) {
  return Loc$ReactTemplate.raise(/* Some */[to_coqloc(loc)], [
              E,
              str
            ]);
}

function bad_token(str) {
  throw [
        E,
        /* Bad_token */[str]
      ];
}

function set_loc_pos(loc, bp, ep) {
  return Ploc$ReactTemplate.sub(loc, bp - Ploc$ReactTemplate.first_pos(loc) | 0, ep - bp | 0);
}

function bump_loc_line(loc, bol_pos) {
  return Ploc$ReactTemplate.make_loc(Ploc$ReactTemplate.file_name(loc), Ploc$ReactTemplate.line_nb(loc) + 1 | 0, bol_pos, /* tuple */[
              Ploc$ReactTemplate.first_pos(loc),
              Ploc$ReactTemplate.last_pos(loc)
            ], Ploc$ReactTemplate.comment(loc));
}

function bump_loc_line_last(loc, bol_pos) {
  var loc$prime = Ploc$ReactTemplate.make_loc(Ploc$ReactTemplate.file_name(loc), Ploc$ReactTemplate.line_nb_last(loc) + 1 | 0, bol_pos, /* tuple */[
        Ploc$ReactTemplate.first_pos(loc) + 1 | 0,
        Ploc$ReactTemplate.last_pos(loc) + 1 | 0
      ], Ploc$ReactTemplate.comment(loc));
  return Ploc$ReactTemplate.encl(loc, loc$prime);
}

function after(loc) {
  var line_nb = Ploc$ReactTemplate.line_nb_last(loc);
  var bol_pos = Ploc$ReactTemplate.bol_pos_last(loc);
  return Ploc$ReactTemplate.make_loc(Ploc$ReactTemplate.file_name(loc), line_nb, bol_pos, /* tuple */[
              Ploc$ReactTemplate.last_pos(loc),
              Ploc$ReactTemplate.last_pos(loc)
            ], Ploc$ReactTemplate.comment(loc));
}

function error_utf8(loc, cs) {
  var bp = Stream.count(cs);
  Stream.junk(cs);
  var loc$1 = set_loc_pos(loc, bp, bp + 1 | 0);
  return err(loc$1, /* Illegal_character */0);
}

function utf8_char_size(loc, cs, param) {
  if (param >= 192) {
    if (param >= 240) {
      if (param >= 248) {
        return error_utf8(loc, cs);
      } else {
        return 4;
      }
    } else if (param >= 224) {
      return 3;
    } else {
      return 2;
    }
  } else if (param >= 128) {
    return error_utf8(loc, cs);
  } else {
    return 1;
  }
}

function check_utf8_trailing_byte(loc, cs, c) {
  if ((c & 192) !== 128) {
    return error_utf8(loc, cs);
  } else {
    return 0;
  }
}

function lookup_utf8(loc, cs) {
  var match = Stream.peek(cs);
  if (match) {
    var c = match[0];
    if (c >= 128) {
      var loc$1 = loc;
      var c$1 = c;
      var cs$1 = cs;
      if ((c$1 & 64) === 0 || (c$1 & 56) === 56) {
        return error_utf8(loc$1, cs$1);
      } else {
        var match$1;
        if (c$1 & 32) {
          if (c$1 & 16) {
            var match$2 = Stream.npeek(4, cs$1);
            if (match$2) {
              var match$3 = match$2[1];
              if (match$3) {
                var match$4 = match$3[1];
                if (match$4) {
                  var match$5 = match$4[1];
                  if (match$5) {
                    if (match$5[1]) {
                      match$1 = error_utf8(loc$1, cs$1);
                    } else {
                      var c4 = match$5[0];
                      var c3 = match$4[0];
                      var c2 = match$3[0];
                      check_utf8_trailing_byte(loc$1, cs$1, c2);
                      check_utf8_trailing_byte(loc$1, cs$1, c3);
                      check_utf8_trailing_byte(loc$1, cs$1, c4);
                      match$1 = /* tuple */[
                        4,
                        ((((c$1 & 7) << 18) + ((c2 & 63) << 12) | 0) + ((c3 & 63) << 6) | 0) + (c4 & 63) | 0
                      ];
                    }
                  } else {
                    match$1 = error_utf8(loc$1, cs$1);
                  }
                } else {
                  match$1 = error_utf8(loc$1, cs$1);
                }
              } else {
                match$1 = error_utf8(loc$1, cs$1);
              }
            } else {
              match$1 = error_utf8(loc$1, cs$1);
            }
          } else {
            var match$6 = Stream.npeek(3, cs$1);
            if (match$6) {
              var match$7 = match$6[1];
              if (match$7) {
                var match$8 = match$7[1];
                if (match$8) {
                  if (match$8[1]) {
                    match$1 = error_utf8(loc$1, cs$1);
                  } else {
                    var c3$1 = match$8[0];
                    var c2$1 = match$7[0];
                    check_utf8_trailing_byte(loc$1, cs$1, c2$1);
                    check_utf8_trailing_byte(loc$1, cs$1, c3$1);
                    match$1 = /* tuple */[
                      3,
                      (((c$1 & 15) << 12) + ((c2$1 & 63) << 6) | 0) + (c3$1 & 63) | 0
                    ];
                  }
                } else {
                  match$1 = error_utf8(loc$1, cs$1);
                }
              } else {
                match$1 = error_utf8(loc$1, cs$1);
              }
            } else {
              match$1 = error_utf8(loc$1, cs$1);
            }
          }
        } else {
          var match$9 = Stream.npeek(2, cs$1);
          if (match$9) {
            var match$10 = match$9[1];
            if (match$10) {
              if (match$10[1]) {
                match$1 = error_utf8(loc$1, cs$1);
              } else {
                var c2$2 = match$10[0];
                check_utf8_trailing_byte(loc$1, cs$1, c2$2);
                match$1 = /* tuple */[
                  2,
                  ((c$1 & 31) << 6) + (c2$2 & 63) | 0
                ];
              }
            } else {
              match$1 = error_utf8(loc$1, cs$1);
            }
          } else {
            match$1 = error_utf8(loc$1, cs$1);
          }
        }
        return /* Utf8Token */[/* tuple */[
                  Unicode$ReactTemplate.classify(match$1[1]),
                  match$1[0]
                ]];
      }
    } else {
      return /* AsciiChar */0;
    }
  } else {
    return /* EmptyStream */1;
  }
}

function check_keyword(str) {
  var strm__ = Stream.of_string(str);
  while(true) {
    var match = Stream.peek(strm__);
    var exit = 0;
    if (match) {
      var match$1 = match[0];
      if (match$1 >= 14) {
        if (match$1 !== 32) {
          if (match$1 !== 34) {
            exit = 1;
          } else {
            Stream.junk(strm__);
            return bad_token(str);
          }
        } else {
          Stream.junk(strm__);
          return bad_token(str);
        }
      } else if (match$1 >= 11) {
        if (match$1 >= 13) {
          Stream.junk(strm__);
          return bad_token(str);
        } else {
          exit = 1;
        }
      } else if (match$1 >= 9) {
        Stream.junk(strm__);
        return bad_token(str);
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$2 = lookup_utf8(Ploc$ReactTemplate.dummy, strm__);
      if (typeof match$2 === "number") {
        if (match$2 !== 0) {
          return /* () */0;
        } else {
          Stream.junk(strm__);
          continue ;
          
        }
      } else {
        Util$ReactTemplate.repeat(match$2[0][1], Stream.junk, strm__);
        continue ;
        
      }
    }
    
  };
}

function check_ident(str) {
  var _intail = /* false */0;
  var strm__ = Stream.of_string(str);
  while(true) {
    var intail = _intail;
    var match = Stream.peek(strm__);
    var exit = 0;
    if (match) {
      var match$1 = match[0];
      var exit$1 = 0;
      if (match$1 >= 65) {
        var switcher = match$1 - 91 | 0;
        if (switcher > 5 || switcher < 0) {
          if (switcher >= 32) {
            exit = 1;
          } else {
            Stream.junk(strm__);
            _intail = /* true */1;
            continue ;
            
          }
        } else if (switcher !== 4) {
          exit = 1;
        } else {
          Stream.junk(strm__);
          _intail = /* true */1;
          continue ;
          
        }
      } else if (match$1 >= 48) {
        if (match$1 >= 58) {
          exit = 1;
        } else {
          exit$1 = 2;
        }
      } else if (match$1 !== 39) {
        exit = 1;
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        if (intail) {
          Stream.junk(strm__);
          _intail = /* true */1;
          continue ;
          
        } else {
          exit = 1;
        }
      }
      
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$2 = lookup_utf8(Ploc$ReactTemplate.dummy, strm__);
      if (typeof match$2 === "number") {
        if (match$2 !== 0) {
          return /* () */0;
        } else {
          return bad_token(str);
        }
      } else {
        var match$3 = match$2[0];
        var n = match$3[1];
        var st = match$3[0];
        if (!intail && Unicode$ReactTemplate.is_valid_ident_initial(st)) {
          Util$ReactTemplate.repeat(n, Stream.junk, strm__);
          _intail = /* true */1;
          continue ;
          
        } else if (intail && Unicode$ReactTemplate.is_valid_ident_trailing(st)) {
          Util$ReactTemplate.repeat(n, Stream.junk, strm__);
          _intail = /* true */1;
          continue ;
          
        } else {
          return bad_token(str);
        }
      }
    }
    
  };
}

function is_ident(str) {
  try {
    check_ident(str);
    return /* true */1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === E) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

var token_tree = [empty_ttree];

function is_keyword(s) {
  try {
    var match = ttree_find(token_tree[0], s)[/* node */0];
    if (match) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function add_keyword(str) {
  if (is_keyword(str)) {
    return 0;
  } else {
    check_keyword(str);
    token_tree[0] = ttree_add(token_tree[0], str);
    return /* () */0;
  }
}

function remove_keyword(str) {
  token_tree[0] = ttree_remove(token_tree[0], str);
  return /* () */0;
}

function keywords() {
  var ttree = token_tree[0];
  var elts = function (tt, accu) {
    var match = tt[/* node */0];
    var accu$1 = match ? Curry._2(CString$ReactTemplate.$$Set[/* add */3], match[0], accu) : accu;
    return Curry._3(CharMap[/* fold */10], (function (_, tt, accu) {
                  return elts(tt, accu);
                }), tt[/* branch */1], accu$1);
  };
  return elts(ttree, CString$ReactTemplate.$$Set[/* empty */0]);
}

function get_keyword_state() {
  return token_tree[0];
}

function set_keyword_state(tt) {
  token_tree[0] = tt;
  return /* () */0;
}

var buff = [new Array(80)];

function store(len, x) {
  if (len >= buff[0].length) {
    buff[0] = Bytes.cat(buff[0], Caml_string.caml_create_string(buff[0].length));
  }
  buff[0][len] = x;
  return len + 1 | 0;
}

function nstore(_n, _len, cs) {
  while(true) {
    var len = _len;
    var n = _n;
    if (n > 0) {
      _len = store(len, Stream.next(cs));
      _n = n - 1 | 0;
      continue ;
      
    } else {
      return len;
    }
  };
}

function get_buff(len) {
  return Bytes.sub_string(buff[0], 0, len);
}

var warn_unrecognized_unicode = CWarnings$ReactTemplate.create("unrecognized-unicode", "parsing", /* None */0, (function (param) {
        return Pp$ReactTemplate.strbrk(Curry._2(Printf.sprintf(/* Format */[
                            /* String_literal */Block.__(11, [
                                "Not considering unicode character \"",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        "\" of unknown lexical status as part of identifier \"",
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                "\".",
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])
                              ]),
                            "Not considering unicode character \"%s\" of unknown lexical status as part of identifier \"%s\"."
                          ]), param[0], param[1]));
      }));

function ident_tail(loc, _len, strm__) {
  while(true) {
    var len = _len;
    var match = Stream.peek(strm__);
    var exit = 0;
    if (match) {
      var c = match[0];
      var exit$1 = 0;
      if (c >= 65) {
        var switcher = c - 91 | 0;
        if (switcher > 5 || switcher < 0) {
          if (switcher >= 32) {
            exit = 1;
          } else {
            exit$1 = 2;
          }
        } else if (switcher !== 4) {
          exit = 1;
        } else {
          exit$1 = 2;
        }
      } else if (c >= 48) {
        if (c >= 58) {
          exit = 1;
        } else {
          exit$1 = 2;
        }
      } else if (c !== 39) {
        exit = 1;
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        Stream.junk(strm__);
        _len = store(len, c);
        continue ;
        
      }
      
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$1 = lookup_utf8(loc, strm__);
      if (typeof match$1 === "number") {
        return len;
      } else {
        var match$2 = match$1[0];
        var n = match$2[1];
        var st = match$2[0];
        if (Unicode$ReactTemplate.is_valid_ident_trailing(st)) {
          _len = nstore(n, len, strm__);
          continue ;
          
        } else if (Unicode$ReactTemplate.is_unknown(st)) {
          var id = get_buff(len);
          var u = Curry._2(Util$ReactTemplate.$$String[/* concat */6], "", Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Util$ReactTemplate.$$String[/* make */0], 1), Stream.npeek(n, strm__)));
          Curry._2(warn_unrecognized_unicode, /* Some */[to_coqloc(loc)], /* tuple */[
                u,
                id
              ]);
          return len;
        } else {
          return len;
        }
      }
    }
    
  };
}

function number(_len, strm__) {
  while(true) {
    var len = _len;
    var match = Stream.peek(strm__);
    if (match) {
      var c = match[0];
      if (c > 57 || c < 48) {
        return len;
      } else {
        Stream.junk(strm__);
        _len = store(len, c);
        continue ;
        
      }
    } else {
      return len;
    }
  };
}

var warn_comment_terminator_in_string = CWarnings$ReactTemplate.create("comment-terminator-in-string", "parsing", /* None */0, (function () {
        return Pp$ReactTemplate.strbrk("Not interpreting \"*)\" as the end of current non-terminated comment because it occurs in a non-terminated string of the comment.");
      }));

function string(_loc, _comm_level, bp, _len, strm__) {
  while(true) {
    var len = _len;
    var comm_level = _comm_level;
    var loc = _loc;
    var match = Stream.peek(strm__);
    if (match) {
      var c = match[0];
      var exit = 0;
      if (c >= 34) {
        if (c >= 43) {
          exit = 1;
        } else {
          switch (c - 34 | 0) {
            case 0 : 
                Stream.junk(strm__);
                var match$1 = Stream.peek(strm__);
                var esc = match$1 && match$1[0] === 34 ? (Stream.junk(strm__), /* true */1) : /* false */0;
                if (esc) {
                  _len = store(len, /* "\"" */34);
                  continue ;
                  
                } else {
                  return /* tuple */[
                          loc,
                          len
                        ];
                }
                break;
            case 6 : 
                Stream.junk(strm__);
                var match$2 = Stream.peek(strm__);
                var exit$1 = 0;
                if (match$2) {
                  if (match$2[0] !== 42) {
                    exit$1 = 2;
                  } else {
                    Stream.junk(strm__);
                    var comm_level$1 = Option$ReactTemplate.map((function (prim) {
                            return prim + 1 | 0;
                          }), comm_level);
                    _len = store(store(len, /* "(" */40), /* "*" */42);
                    _comm_level = comm_level$1;
                    continue ;
                    
                  }
                } else {
                  exit$1 = 2;
                }
                if (exit$1 === 2) {
                  _len = store(len, /* "(" */40);
                  continue ;
                  
                }
                break;
            case 1 : 
            case 2 : 
            case 3 : 
            case 4 : 
            case 5 : 
            case 7 : 
                exit = 1;
                break;
            case 8 : 
                Stream.junk(strm__);
                var match$3 = Stream.peek(strm__);
                var exit$2 = 0;
                if (match$3) {
                  if (match$3[0] !== 41) {
                    exit$2 = 2;
                  } else {
                    Stream.junk(strm__);
                    if (comm_level) {
                      if (comm_level[0] !== 0) {
                        
                      } else {
                        Curry._2(warn_comment_terminator_in_string, /* Some */[to_coqloc(loc)], /* () */0);
                      }
                    }
                    var comm_level$2 = Option$ReactTemplate.map((function (prim) {
                            return prim - 1 | 0;
                          }), comm_level);
                    _len = store(store(len, /* "*" */42), /* ")" */41);
                    _comm_level = comm_level$2;
                    continue ;
                    
                  }
                } else {
                  exit$2 = 2;
                }
                if (exit$2 === 2) {
                  _len = store(len, /* "*" */42);
                  continue ;
                  
                }
                break;
            
          }
        }
      } else if (c !== 10) {
        exit = 1;
      } else {
        Stream.junk(strm__);
        var ep = Stream.count(strm__);
        var loc$1 = Option$ReactTemplate.has_some(comm_level) ? bump_loc_line(loc, ep) : bump_loc_line_last(loc, ep);
        _len = store(len, c);
        _loc = loc$1;
        continue ;
        
      }
      if (exit === 1) {
        Stream.junk(strm__);
        _len = store(len, c);
        continue ;
        
      }
      
    } else {
      Stream.empty(strm__);
      var ep$1 = Stream.count(strm__);
      var loc$2 = set_loc_pos(loc, bp, ep$1);
      return err(loc$2, /* Unterminated_string */2);
    }
  };
}

var current_file = [/* ToplevelInput */0];

var comment_begin = [/* None */0];

function comm_loc(bp) {
  var match = comment_begin[0];
  if (match) {
    return /* () */0;
  } else {
    comment_begin[0] = /* Some */[bp];
    return /* () */0;
  }
}

var comments = [/* [] */0];

var current_comment = Buffer.create(8192);

var between_commands = [/* true */1];

function init_lexer_state(f) {
  return /* tuple */[
          /* None */0,
          "",
          /* true */1,
          /* [] */0,
          f
        ];
}

function set_lexer_state(param) {
  comment_begin[0] = param[0];
  Buffer.clear(current_comment);
  Buffer.add_string(current_comment, param[1]);
  between_commands[0] = param[2];
  comments[0] = param[3];
  current_file[0] = param[4];
  return /* () */0;
}

function get_lexer_state() {
  return /* tuple */[
          comment_begin[0],
          Buffer.contents(current_comment),
          between_commands[0],
          comments[0],
          current_file[0]
        ];
}

function drop_lexer_state() {
  return set_lexer_state(/* tuple */[
              /* None */0,
              "",
              /* true */1,
              /* [] */0,
              /* ToplevelInput */0
            ]);
}

function get_comment_state(param) {
  return param[3];
}

function push_char(c) {
  var s = Buffer.contents(current_comment);
  if (between_commands[0] || Curry._2(Util$ReactTemplate.List[/* mem */24], c, /* :: */[
          /* "\n" */10,
          /* :: */[
            /* "\r" */13,
            /* [] */0
          ]
        ]) || Curry._2(Util$ReactTemplate.List[/* mem */24], c, /* :: */[
          /* " " */32,
          /* :: */[
            /* "\t" */9,
            /* [] */0
          ]
        ]) && (Buffer.length(current_comment) === 0 || !Curry._2(Util$ReactTemplate.List[/* mem */24], Caml_string.get(s, s.length - 1 | 0), /* :: */[
            /* " " */32,
            /* :: */[
              /* "\t" */9,
              /* :: */[
                /* "\n" */10,
                /* :: */[
                  /* "\r" */13,
                  /* [] */0
                ]
              ]
            ]
          ]))) {
    return Buffer.add_char(current_comment, c);
  } else {
    return 0;
  }
}

function null_comment(s) {
  var _i = s.length - 1 | 0;
  while(true) {
    var i = _i;
    if (i < 0) {
      return /* true */1;
    } else if (Curry._2(Util$ReactTemplate.List[/* mem */24], Caml_string.get(s, i), /* :: */[
            /* " " */32,
            /* :: */[
              /* "\t" */9,
              /* :: */[
                /* "\n" */10,
                /* :: */[
                  /* "\r" */13,
                  /* [] */0
                ]
              ]
            ]
          ])) {
      _i = i - 1 | 0;
      continue ;
      
    } else {
      return /* false */0;
    }
  };
}

function comment_stop(ep) {
  var current_s = Buffer.contents(current_comment);
  if (Flags$ReactTemplate.beautify[0] && Buffer.length(current_comment) > 0 && (between_commands[0] || !null_comment(current_s))) {
    var match = comment_begin[0];
    var bp = match ? match[0] : (Feedback$ReactTemplate.msg_notice(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No begin location for comment '"), Pp$ReactTemplate.str(current_s)), Pp$ReactTemplate.str("' ending at  ")), Pp$ReactTemplate.$$int(ep))), ep - 1 | 0);
    comments[0] = /* :: */[
      /* tuple */[
        /* tuple */[
          bp,
          ep
        ],
        current_s
      ],
      comments[0]
    ];
  }
  Buffer.clear(current_comment);
  comment_begin[0] = /* None */0;
  between_commands[0] = /* false */0;
  return /* () */0;
}

function comment(_loc, bp, strm__) {
  while(true) {
    var loc = _loc;
    var bp2 = Stream.count(strm__);
    var match = Stream.peek(strm__);
    var exit = 0;
    if (match) {
      var switcher = match[0] - 34 | 0;
      if (switcher > 8 || switcher < 0) {
        exit = 1;
      } else {
        switch (switcher) {
          case 0 : 
              Stream.junk(strm__);
              var match$1 = string(loc, /* Some */[0], bp2, 0, strm__);
              Buffer.add_string(current_comment, "\"");
              var s = get_buff(match$1[1]);
              Buffer.add_string(current_comment, s);
              Buffer.add_string(current_comment, "\"");
              _loc = match$1[0];
              continue ;
              case 6 : 
              Stream.junk(strm__);
              var loc$1;
              try {
                var match$2 = Stream.peek(strm__);
                if (match$2) {
                  if (match$2[0] !== 42) {
                    Buffer.add_string(current_comment, "(");
                    loc$1 = loc;
                  } else {
                    Stream.junk(strm__);
                    Buffer.add_string(current_comment, "(*");
                    loc$1 = comment(loc, bp, strm__);
                  }
                } else {
                  Buffer.add_string(current_comment, "(");
                  loc$1 = loc;
                }
              }
              catch (exn){
                if (exn === Stream.Failure) {
                  throw [
                        Stream.$$Error,
                        ""
                      ];
                } else {
                  throw exn;
                }
              }
              _loc = loc$1;
              continue ;
              case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 5 : 
          case 7 : 
              exit = 1;
              break;
          case 8 : 
              Stream.junk(strm__);
              try {
                var match$3 = Stream.peek(strm__);
                if (match$3 && match$3[0] === 41) {
                  Stream.junk(strm__);
                  Buffer.add_string(current_comment, "*)");
                  return loc;
                } else {
                  Buffer.add_char(current_comment, /* "*" */42);
                  return comment(loc, bp, strm__);
                }
              }
              catch (exn$1){
                if (exn$1 === Stream.Failure) {
                  throw [
                        Stream.$$Error,
                        ""
                      ];
                } else {
                  throw exn$1;
                }
              }
              break;
          
        }
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$4;
      try {
        match$4 = /* Some */[Stream.empty(strm__)];
      }
      catch (exn$2){
        if (exn$2 === Stream.Failure) {
          match$4 = /* None */0;
        } else {
          throw exn$2;
        }
      }
      if (match$4) {
        var ep = Stream.count(strm__);
        var loc$2 = set_loc_pos(loc, bp, ep);
        return err(loc$2, /* Unterminated_comment */1);
      } else {
        var match$5 = Stream.peek(strm__);
        if (match$5) {
          var z = match$5[0];
          Stream.junk(strm__);
          if (z !== 10) {
            Buffer.add_char(current_comment, z);
            continue ;
            
          } else {
            var ep$1 = Stream.count(strm__);
            Buffer.add_char(current_comment, z);
            _loc = bump_loc_line(loc, ep$1);
            continue ;
            
          }
        } else {
          throw Stream.Failure;
        }
      }
    }
    
  };
}

function progress_further(loc, last, nj, tt, cs) {
  try {
    return progress_from_byte(loc, last, nj, tt, cs, Curry._2(Util$ReactTemplate.List[/* nth */3], Stream.npeek(nj + 1 | 0, cs), nj));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return last;
    } else {
      throw exn;
    }
  }
}

function update_longest_valid_token(loc, last, nj, tt, cs) {
  var last$prime = tt[/* node */0];
  if (last$prime) {
    Util$ReactTemplate.stream_njunk(nj, cs);
    return progress_further(loc, last$prime, 0, tt, cs);
  } else {
    return progress_further(loc, last, nj, tt, cs);
  }
}

function progress_from_byte(loc, last, nj, tt, cs, c) {
  var loc$1 = loc;
  var last$1 = last;
  var nj$1 = nj;
  var n = utf8_char_size(loc, cs, c);
  var c$1 = c;
  var tt$1 = tt;
  var cs$1 = cs;
  try {
    var tt$2 = Curry._2(CharMap[/* find */21], c$1, tt$1[/* branch */1]);
    if (n === 1) {
      return update_longest_valid_token(loc$1, last$1, nj$1 + n | 0, tt$2, cs$1);
    } else {
      var l = Curry._2(Util$ReactTemplate.List[/* skipn */107], nj$1 + 1 | 0, Stream.npeek(nj$1 + n | 0, cs$1));
      if (Curry._1(Util$ReactTemplate.List[/* length */0], l) === (n - 1 | 0)) {
        Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return check_utf8_trailing_byte(loc$1, cs$1, param);
              }), l);
        var tt$3 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (tt, c) {
                return Curry._2(CharMap[/* find */21], c, tt[/* branch */1]);
              }), tt$2, l);
        return update_longest_valid_token(loc$1, last$1, nj$1 + n | 0, tt$3, cs$1);
      } else {
        return error_utf8(loc$1, cs$1);
      }
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return last$1;
    } else {
      throw exn;
    }
  }
}

function find_keyword(loc, id, s) {
  var tt = ttree_find(token_tree[0], id);
  var match = progress_further(loc, tt[/* node */0], 0, tt, s);
  if (match) {
    return /* KEYWORD */Block.__(0, [match[0]]);
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function process_sequence(loc, bp, c, cs) {
  var _n = 1;
  var cs$1 = cs;
  while(true) {
    var n = _n;
    var match = Stream.peek(cs$1);
    var exit = 0;
    if (match) {
      if (c === match[0]) {
        Stream.junk(cs$1);
        _n = n + 1 | 0;
        continue ;
        
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* tuple */[
              /* BULLET */Block.__(6, [Curry._2(Util$ReactTemplate.$$String[/* make */0], n, c)]),
              set_loc_pos(loc, bp, Stream.count(cs$1))
            ];
    }
    
  };
}

function process_chars(loc, bp, c, cs) {
  var t = progress_from_byte(loc, /* None */0, -1, token_tree[0], cs, c);
  var ep = Stream.count(cs);
  if (t) {
    return /* tuple */[
            /* KEYWORD */Block.__(0, [t[0]]),
            set_loc_pos(loc, bp, ep)
          ];
  } else {
    var ep$prime = bp + utf8_char_size(loc, cs, c) | 0;
    var partial_arg = ep$prime - ep | 0;
    ((function (param) {
            return Util$ReactTemplate.repeat(partial_arg, Stream.junk, param);
          })(cs));
    var loc$1 = set_loc_pos(loc, bp, ep$prime);
    return err(loc$1, /* Undefined_token */3);
  }
}

function parse_after_dot(loc, c, bp, strm__) {
  var match = Stream.peek(strm__);
  var exit = 0;
  if (match) {
    var d = match[0];
    var exit$1 = 0;
    var switcher = d - 91 | 0;
    if (switcher > 5 || switcher < 0) {
      if ((switcher + 26 >>> 0) > 57) {
        exit = 1;
      } else {
        exit$1 = 2;
      }
    } else if (switcher !== 4) {
      exit = 1;
    } else {
      exit$1 = 2;
    }
    if (exit$1 === 2) {
      Stream.junk(strm__);
      var len;
      try {
        len = ident_tail(loc, store(0, d), strm__);
      }
      catch (exn){
        if (exn === Stream.Failure) {
          throw [
                Stream.$$Error,
                ""
              ];
        } else {
          throw exn;
        }
      }
      var field = get_buff(len);
      try {
        return find_keyword(loc, "." + field, strm__);
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          return /* FIELD */Block.__(3, [field]);
        } else {
          throw exn$1;
        }
      }
    }
    
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var match$1 = lookup_utf8(loc, strm__);
    if (typeof match$1 === "number") {
      return process_chars(loc, bp, c, strm__)[0];
    } else {
      var match$2 = match$1[0];
      if (Unicode$ReactTemplate.is_valid_ident_initial(match$2[0])) {
        var len$1 = ident_tail(loc, nstore(match$2[1], 0, strm__), strm__);
        var field$1 = get_buff(len$1);
        try {
          return find_keyword(loc, "." + field$1, strm__);
        }
        catch (exn$2){
          if (exn$2 === Caml_builtin_exceptions.not_found) {
            return /* FIELD */Block.__(3, [field$1]);
          } else {
            throw exn$2;
          }
        }
      } else {
        return process_chars(loc, bp, c, strm__)[0];
      }
    }
  }
  
}

function parse_after_qmark(loc, bp, s) {
  var match = Stream.peek(s);
  var exit = 0;
  if (match) {
    var switcher = match[0] - 91 | 0;
    if (switcher > 5 || switcher < 0) {
      if ((switcher + 26 >>> 0) > 57) {
        exit = 1;
      } else {
        return /* LEFTQMARK */0;
      }
    } else if (switcher !== 4) {
      exit = 1;
    } else {
      return /* LEFTQMARK */0;
    }
  } else {
    return /* KEYWORD */Block.__(0, ["?"]);
  }
  if (exit === 1) {
    var match$1 = lookup_utf8(loc, s);
    if (typeof match$1 === "number" || !Unicode$ReactTemplate.is_valid_ident_initial(match$1[0][0])) {
      return process_chars(loc, bp, /* "?" */63, s)[0];
    } else {
      return /* LEFTQMARK */0;
    }
  }
  
}

function blank_or_eof(cs) {
  var match = Stream.peek(cs);
  if (match) {
    var switcher = match[0] - 9 | 0;
    if (switcher > 4 || switcher < 0) {
      if (switcher !== 23) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    } else if (switcher === 3 || switcher === 2) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  } else {
    return /* true */1;
  }
}

function next_token(_loc, strm__) {
  while(true) {
    var loc = _loc;
    var bp = Stream.count(strm__);
    var match = Stream.peek(strm__);
    var exit = 0;
    if (match) {
      var c = match[0];
      var exit$1 = 0;
      if (c >= 96) {
        var switcher = c - 97 | 0;
        if (switcher > 26 || switcher < 0) {
          if (switcher !== 28) {
            exit = 1;
          } else {
            exit$1 = 6;
          }
        } else {
          exit$1 = switcher >= 26 ? 6 : 4;
        }
      } else {
        var switcher$1 = c - 9 | 0;
        if (switcher$1 > 81 || switcher$1 < 0) {
          if (switcher$1 >= 86) {
            exit$1 = 4;
          } else {
            exit = 1;
          }
        } else if (switcher$1 >= 56) {
          exit$1 = 4;
        } else {
          switch (switcher$1) {
            case 1 : 
                Stream.junk(strm__);
                var ep = Stream.count(strm__);
                comm_loc(bp);
                push_char(c);
                _loc = bump_loc_line(loc, ep);
                continue ;
                case 0 : 
            case 4 : 
            case 23 : 
                exit$1 = 2;
                break;
            case 25 : 
                Stream.junk(strm__);
                var match$1;
                try {
                  match$1 = string(loc, /* None */0, bp, 0, strm__);
                }
                catch (exn){
                  if (exn === Stream.Failure) {
                    throw [
                          Stream.$$Error,
                          ""
                        ];
                  } else {
                    throw exn;
                  }
                }
                var ep$1 = Stream.count(strm__);
                comment_stop(bp);
                return /* tuple */[
                        /* STRING */Block.__(5, [get_buff(match$1[1])]),
                        set_loc_pos(match$1[0], bp, ep$1)
                      ];
            case 31 : 
                Stream.junk(strm__);
                try {
                  var match$2 = Stream.peek(strm__);
                  var exit$2 = 0;
                  if (match$2) {
                    if (match$2[0] !== 42) {
                      exit$2 = 7;
                    } else {
                      Stream.junk(strm__);
                      comm_loc(bp);
                      Buffer.add_string(current_comment, "(*");
                      var loc$1 = comment(loc, bp, strm__);
                      return next_token(loc$1, strm__);
                    }
                  } else {
                    exit$2 = 7;
                  }
                  if (exit$2 === 7) {
                    var t = process_chars(loc, bp, c, strm__);
                    comment_stop(bp);
                    return t;
                  }
                  
                }
                catch (exn$1){
                  if (exn$1 === Stream.Failure) {
                    throw [
                          Stream.$$Error,
                          ""
                        ];
                  } else {
                    throw exn$1;
                  }
                }
                break;
            case 33 : 
            case 34 : 
            case 36 : 
                exit$1 = 3;
                break;
            case 37 : 
                Stream.junk(strm__);
                var t$1;
                try {
                  t$1 = parse_after_dot(loc, c, bp, strm__);
                }
                catch (exn$2){
                  if (exn$2 === Stream.Failure) {
                    throw [
                          Stream.$$Error,
                          ""
                        ];
                  } else {
                    throw exn$2;
                  }
                }
                var ep$2 = Stream.count(strm__);
                comment_stop(bp);
                if (typeof t$1 !== "number") {
                  if (!t$1.tag) {
                    var exit$3 = 0;
                    switch (t$1[0]) {
                      case "." : 
                      case "..." : 
                          exit$3 = 7;
                          break;
                      default:
                        
                    }
                    if (exit$3 === 7) {
                      if (!blank_or_eof(strm__)) {
                        err(set_loc_pos(loc, bp, ep$2 + 1 | 0), /* Undefined_token */3);
                      }
                      between_commands[0] = /* true */1;
                    }
                    
                  }
                  
                }
                return /* tuple */[
                        t$1,
                        set_loc_pos(loc, bp, ep$2)
                      ];
            case 39 : 
            case 40 : 
            case 41 : 
            case 42 : 
            case 43 : 
            case 44 : 
            case 45 : 
            case 46 : 
            case 47 : 
            case 48 : 
                exit$1 = 5;
                break;
            case 54 : 
                Stream.junk(strm__);
                var ep$3 = Stream.count(strm__);
                var t$2 = parse_after_qmark(loc, bp, strm__);
                comment_stop(bp);
                return /* tuple */[
                        t$2,
                        set_loc_pos(loc, bp, ep$3)
                      ];
            case 2 : 
            case 3 : 
            case 5 : 
            case 6 : 
            case 7 : 
            case 8 : 
            case 9 : 
            case 10 : 
            case 11 : 
            case 12 : 
            case 13 : 
            case 14 : 
            case 15 : 
            case 16 : 
            case 17 : 
            case 18 : 
            case 19 : 
            case 20 : 
            case 21 : 
            case 22 : 
            case 24 : 
            case 26 : 
            case 27 : 
            case 28 : 
            case 29 : 
            case 30 : 
            case 32 : 
            case 35 : 
            case 38 : 
            case 49 : 
            case 50 : 
            case 51 : 
            case 52 : 
            case 53 : 
            case 55 : 
                exit = 1;
                break;
            
          }
        }
      }
      switch (exit$1) {
        case 2 : 
            Stream.junk(strm__);
            comm_loc(bp);
            push_char(c);
            continue ;
            case 3 : 
            Stream.junk(strm__);
            var match$3 = between_commands[0] ? /* tuple */[
                process_sequence(loc, bp, c, strm__),
                /* true */1
              ] : /* tuple */[
                process_chars(loc, bp, c, strm__),
                /* false */0
              ];
            comment_stop(bp);
            between_commands[0] = match$3[1];
            return match$3[0];
        case 4 : 
            Stream.junk(strm__);
            var len;
            try {
              len = ident_tail(loc, store(0, c), strm__);
            }
            catch (exn$3){
              if (exn$3 === Stream.Failure) {
                throw [
                      Stream.$$Error,
                      ""
                    ];
              } else {
                throw exn$3;
              }
            }
            var ep$4 = Stream.count(strm__);
            var id = get_buff(len);
            comment_stop(bp);
            var tmp;
            try {
              tmp = find_keyword(loc, id, strm__);
            }
            catch (exn$4){
              if (exn$4 === Caml_builtin_exceptions.not_found) {
                tmp = /* IDENT */Block.__(2, [id]);
              } else {
                throw exn$4;
              }
            }
            return /* tuple */[
                    tmp,
                    set_loc_pos(loc, bp, ep$4)
                  ];
        case 5 : 
            Stream.junk(strm__);
            var len$1;
            try {
              len$1 = number(store(0, c), strm__);
            }
            catch (exn$5){
              if (exn$5 === Stream.Failure) {
                throw [
                      Stream.$$Error,
                      ""
                    ];
              } else {
                throw exn$5;
              }
            }
            var ep$5 = Stream.count(strm__);
            comment_stop(bp);
            return /* tuple */[
                    /* INT */Block.__(4, [get_buff(len$1)]),
                    set_loc_pos(loc, bp, ep$5)
                  ];
        case 6 : 
            Stream.junk(strm__);
            var ep$6 = Stream.count(strm__);
            var match$4 = between_commands[0] ? /* tuple */[
                /* tuple */[
                  /* KEYWORD */Block.__(0, [Curry._2(Util$ReactTemplate.$$String[/* make */0], 1, c)]),
                  set_loc_pos(loc, bp, ep$6)
                ],
                /* true */1
              ] : /* tuple */[
                process_chars(loc, bp, c, strm__),
                /* false */0
              ];
            comment_stop(bp);
            between_commands[0] = match$4[1];
            return match$4[0];
        
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$5 = lookup_utf8(loc, strm__);
      var exit$4 = 0;
      if (typeof match$5 === "number") {
        if (match$5 !== 0) {
          comment_stop(bp);
          return /* tuple */[
                  /* EOI */1,
                  set_loc_pos(loc, bp, bp + 1 | 0)
                ];
        } else {
          exit$4 = 2;
        }
      } else {
        var match$6 = match$5[0];
        if (Unicode$ReactTemplate.is_valid_ident_initial(match$6[0])) {
          var len$2 = ident_tail(loc, nstore(match$6[1], 0, strm__), strm__);
          var id$1 = get_buff(len$2);
          var ep$7 = Stream.count(strm__);
          comment_stop(bp);
          var tmp$1;
          try {
            tmp$1 = find_keyword(loc, id$1, strm__);
          }
          catch (exn$6){
            if (exn$6 === Caml_builtin_exceptions.not_found) {
              tmp$1 = /* IDENT */Block.__(2, [id$1]);
            } else {
              throw exn$6;
            }
          }
          return /* tuple */[
                  tmp$1,
                  set_loc_pos(loc, bp, ep$7)
                ];
        } else {
          exit$4 = 2;
        }
      }
      if (exit$4 === 2) {
        var t$3 = process_chars(loc, bp, Stream.next(strm__), strm__);
        comment_stop(bp);
        return t$3;
      }
      
    }
    
  };
}

function token_text(param) {
  var con = param[0];
  var exit = 0;
  switch (con) {
    case "" : 
        return "'" + (param[1] + "'");
    case "EOI" : 
        if (param[1] === "") {
          return "end of input";
        } else {
          exit = 1;
        }
        break;
    case "IDENT" : 
        var t = param[1];
        if (t === "") {
          return "identifier";
        } else {
          return "'" + (t + "'");
        }
        break;
    case "INT" : 
        var s = param[1];
        if (s === "") {
          return "integer";
        } else {
          return "'" + (s + "'");
        }
        break;
    case "STRING" : 
        if (param[1] === "") {
          return "string";
        } else {
          exit = 1;
        }
        break;
    default:
      exit = 1;
  }
  if (exit === 1) {
    var prm = param[1];
    if (prm === "") {
      return con;
    } else {
      return con + (" \"" + (prm + "\""));
    }
  }
  
}

function func(cs) {
  var loct = Hashtbl.create(/* None */0, 207);
  var cur_loc = [from_coqloc(current_file[0], 1, 0, 0, 0)];
  var ts = Stream.from((function (i) {
          var match = next_token(cur_loc[0], cs);
          var loc = match[1];
          cur_loc[0] = after(loc);
          Hashtbl.add(loct, i, loc);
          return /* Some */[match[0]];
        }));
  return /* tuple */[
          ts,
          (function (param) {
              var loct$1 = loct;
              var i = param;
              try {
                return Hashtbl.find(loct$1, i);
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return Pervasives.invalid_arg("Lexer: location function");
                } else {
                  throw exn;
                }
              }
            })
        ];
}

var lexer = /* record */[
  /* tok_func */func,
  /* tok_using */(function (pat) {
      var match = Tok$ReactTemplate.of_pattern(pat);
      if (typeof match === "number" || match.tag) {
        return /* () */0;
      } else {
        return add_keyword(match[0]);
      }
    }),
  /* tok_removing */(function () {
      return /* () */0;
    }),
  /* tok_match */Tok$ReactTemplate.match_pattern,
  /* tok_text */token_text,
  /* tok_comm : None */0
];

function is_ident_not_keyword(s) {
  if (is_ident(s)) {
    return 1 - is_keyword(s);
  } else {
    return /* false */0;
  }
}

function is_number(s) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (s.length === i) {
      return /* true */1;
    } else {
      var match = Caml_string.get(s, i);
      if (match > 57 || match < 48) {
        return /* false */0;
      } else {
        _i = i + 1 | 0;
        continue ;
        
      }
    }
  };
}

function strip(s) {
  var loop = function (_i, _len) {
    while(true) {
      var len = _len;
      var i = _i;
      if (i === s.length) {
        return len;
      } else if (Caml_string.get(s, i) === /* " " */32) {
        _i = i + 1 | 0;
        continue ;
        
      } else {
        _len = len + 1 | 0;
        _i = i + 1 | 0;
        continue ;
        
      }
    };
  };
  var len = loop(0, 0);
  if (len === s.length) {
    return s;
  } else {
    var s$prime = Caml_string.caml_create_string(len);
    var loop$1 = function (_i, _i$prime) {
      while(true) {
        var i$prime = _i$prime;
        var i = _i;
        if (i === s.length) {
          return s$prime;
        } else if (Caml_string.get(s, i) === /* " " */32) {
          _i = i + 1 | 0;
          continue ;
          
        } else {
          s$prime[i$prime] = Caml_string.get(s, i);
          _i$prime = i$prime + 1 | 0;
          _i = i + 1 | 0;
          continue ;
          
        }
      };
    };
    return Bytes.to_string(loop$1(0, 0));
  }
}

function terminal(s) {
  var s$1 = strip(s);
  if (s$1 === "") {
    Pervasives.failwith("empty token.");
  }
  if (is_ident_not_keyword(s$1)) {
    return /* IDENT */Block.__(2, [s$1]);
  } else if (is_number(s$1)) {
    return /* INT */Block.__(4, [s$1]);
  } else {
    return /* KEYWORD */Block.__(0, [s$1]);
  }
}

var release_lexer_state = get_lexer_state;

exports.add_keyword = add_keyword;
exports.remove_keyword = remove_keyword;
exports.is_keyword = is_keyword;
exports.keywords = keywords;
exports.set_keyword_state = set_keyword_state;
exports.get_keyword_state = get_keyword_state;
exports.check_ident = check_ident;
exports.is_ident = is_ident;
exports.check_keyword = check_keyword;
exports.terminal = terminal;
exports.lexer = lexer;
exports.$$Error = $$Error;
exports.init_lexer_state = init_lexer_state;
exports.set_lexer_state = set_lexer_state;
exports.get_lexer_state = get_lexer_state;
exports.release_lexer_state = release_lexer_state;
exports.drop_lexer_state = drop_lexer_state;
exports.get_comment_state = get_comment_state;
/* CharMap Not a pure module */
