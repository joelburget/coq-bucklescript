// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Arguments_renaming$ReactTemplate = require("./arguments_renaming.bs.js");

function print_retype_error(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return Pp$ReactTemplate.str("Not a sort");
      case 1 : 
          return Pp$ReactTemplate.str("Not an arity");
      case 2 : 
          return Pp$ReactTemplate.str("Not a type (1)");
      case 3 : 
          return Pp$ReactTemplate.str("Bad recursive type");
      case 4 : 
          return Pp$ReactTemplate.str("Non-functional construction");
      
    }
  } else if (param.tag) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("unknown meta "), Pp$ReactTemplate.$$int(param[0]));
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("variable "), Names$ReactTemplate.Id[/* print */8](param[0])), Pp$ReactTemplate.str(" unbound"));
  }
}

var RetypeError = Caml_exceptions.create("Retyping-ReactTemplate.RetypeError");

function anomaly_on_error(f, x) {
  try {
    return Curry._1(f, x);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === RetypeError) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["retyping"], Pp$ReactTemplate.$plus$plus(print_retype_error(exn[1]), Pp$ReactTemplate.str(".")));
    } else {
      throw exn;
    }
  }
}

function get_type_from_constraints(_, sigma, t) {
  if (EConstr$ReactTemplate.isEvar(sigma, Termops$ReactTemplate.decompose_app_vect(sigma, t)[0])) {
    var match = Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function (param) {
            var t2 = param[3];
            var t1 = param[2];
            var env = param[1];
            if (Curry._4(Reductionops$ReactTemplate.is_fconv(/* None */0, /* CONV */0), env, sigma, t, EConstr$ReactTemplate.of_constr(t1))) {
              return /* Some */[t2];
            } else if (Curry._4(Reductionops$ReactTemplate.is_fconv(/* None */0, /* CONV */0), env, sigma, t, EConstr$ReactTemplate.of_constr(t2))) {
              return /* Some */[t1];
            } else {
              return /* None */0;
            }
          }), Evd$ReactTemplate.extract_all_conv_pbs(sigma)[1]);
    if (match) {
      return match[0];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function subst_type(env, sigma, _typ, _param) {
  while(true) {
    var param = _param;
    var typ = _typ;
    if (param) {
      var match = EConstr$ReactTemplate.kind(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, typ));
      if (match.tag === 6) {
        _param = param[1];
        _typ = EConstr$ReactTemplate.Vars[/* subst1 */4](param[0], match[2]);
        continue ;
        
      } else {
        throw [
              RetypeError,
              /* NonFunctionalConstruction */4
            ];
      }
    } else {
      return typ;
    }
  };
}

function sort_of_atomic_type(env, sigma, ft, args) {
  var _env = env;
  var _n = 0;
  var _ar = ft;
  var _args = Util$ReactTemplate.$$Array[/* to_list */9](args);
  while(true) {
    var args$1 = _args;
    var ar = _ar;
    var n = _n;
    var env$1 = _env;
    var match = EConstr$ReactTemplate.kind(sigma, Reductionops$ReactTemplate.whd_all(env$1)(sigma, ar));
    switch (match.tag | 0) {
      case 4 : 
          if (args$1) {
            throw [
                  RetypeError,
                  /* NotASort */0
                ];
          } else {
            return EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]);
          }
          break;
      case 6 : 
          if (args$1) {
            _args = args$1[1];
            _ar = match[2];
            _n = n + 1 | 0;
            _env = EConstr$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                    match[0],
                    EConstr$ReactTemplate.Vars[/* lift */0](n, args$1[0]),
                    match[1]
                  ]), env$1);
            continue ;
            
          } else {
            throw [
                  RetypeError,
                  /* NotASort */0
                ];
          }
          break;
      default:
        throw [
              RetypeError,
              /* NotASort */0
            ];
    }
  };
}

function type_of_var(env, id) {
  try {
    return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], EConstr$ReactTemplate.lookup_named(id, env));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            RetypeError,
            /* BadVariable */Block.__(0, [id])
          ];
    } else {
      throw exn;
    }
  }
}

function decomp_sort(env, sigma, t) {
  var match = EConstr$ReactTemplate.kind(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, t));
  if (match.tag === 4) {
    return EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]);
  } else {
    throw [
          RetypeError,
          /* NotASort */0
        ];
  }
}

function destSort(sigma, s) {
  return EConstr$ReactTemplate.ESorts[/* kind */1](sigma, EConstr$ReactTemplate.destSort(sigma, s));
}

function retype($staropt$star, sigma) {
  var polyprop = $staropt$star ? $staropt$star[0] : /* true */1;
  var type_of = function (env, cstr) {
    var match = EConstr$ReactTemplate.kind(sigma, cstr);
    switch (match.tag | 0) {
      case 0 : 
          var n = match[0];
          var ty = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], EConstr$ReactTemplate.lookup_rel(n, env));
          return EConstr$ReactTemplate.Vars[/* lift */0](n, ty);
      case 1 : 
          return type_of_var(env, match[0]);
      case 2 : 
          var n$1 = match[0];
          try {
            return Termops$ReactTemplate.strip_outer_cast(sigma, EConstr$ReactTemplate.of_constr(Evd$ReactTemplate.meta_ftype(sigma, n$1)[/* rebus */0]));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              throw [
                    RetypeError,
                    /* BadMeta */Block.__(1, [n$1])
                  ];
            } else {
              throw exn;
            }
          }
          break;
      case 3 : 
          return EConstr$ReactTemplate.existential_type(sigma, match[0]);
      case 5 : 
          return match[2];
      case 4 : 
      case 6 : 
          return EConstr$ReactTemplate.mkSort(sort_of(env, cstr));
      case 7 : 
          var c1 = match[1];
          var name = match[0];
          return EConstr$ReactTemplate.mkProd(/* tuple */[
                      name,
                      c1,
                      type_of(EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                  name,
                                  c1
                                ]), env), match[2])
                    ]);
      case 8 : 
          var b = match[1];
          return EConstr$ReactTemplate.Vars[/* subst1 */4](b, type_of(EConstr$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                                match[0],
                                b,
                                match[2]
                              ]), env), match[3]));
      case 9 : 
          var args = match[1];
          var f = match[0];
          if (Termops$ReactTemplate.is_template_polymorphic(env, sigma, f)) {
            var t = type_of_global_reference_knowing_parameters(env, f, args);
            return Termops$ReactTemplate.strip_outer_cast(sigma, subst_type(env, sigma, t, Util$ReactTemplate.$$Array[/* to_list */9](args)));
          } else {
            return Termops$ReactTemplate.strip_outer_cast(sigma, subst_type(env, sigma, type_of(env, f), Util$ReactTemplate.$$Array[/* to_list */9](args)));
          }
          break;
      case 10 : 
          var match$1 = match[0];
          return EConstr$ReactTemplate.of_constr(Arguments_renaming$ReactTemplate.rename_type_of_constant(env, /* tuple */[
                          match$1[0],
                          EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$1[1])
                        ]));
      case 11 : 
          var match$2 = match[0];
          return EConstr$ReactTemplate.of_constr(Arguments_renaming$ReactTemplate.rename_type_of_inductive(env, /* tuple */[
                          match$2[0],
                          EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$2[1])
                        ]));
      case 12 : 
          var match$3 = match[0];
          return EConstr$ReactTemplate.of_constr(Arguments_renaming$ReactTemplate.rename_type_of_constructor(env, /* tuple */[
                          match$3[0],
                          EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$3[1])
                        ]));
      case 13 : 
          var c = match[2];
          var t$1 = type_of(env, c);
          var match$4;
          try {
            match$4 = Inductiveops$ReactTemplate.find_rectype(env, sigma, t$1);
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              try {
                var t$2 = EConstr$ReactTemplate.of_constr(get_type_from_constraints(env, sigma, t$1));
                match$4 = Inductiveops$ReactTemplate.find_rectype(env, sigma, t$2);
              }
              catch (exn$2){
                if (exn$2 === Caml_builtin_exceptions.not_found) {
                  throw [
                        RetypeError,
                        /* BadRecursiveType */3
                      ];
                } else {
                  throw exn$2;
                }
              }
            } else {
              throw exn$1;
            }
          }
          var n$2 = Inductiveops$ReactTemplate.inductive_nrealdecls_env(env, Inductiveops$ReactTemplate.dest_ind_family(match$4[0])[0][0]);
          var t$3 = Reductionops$ReactTemplate.betazetaevar_applist(sigma, n$2, match[1], match$4[1]);
          var match$5 = EConstr$ReactTemplate.kind(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, type_of(env, t$3)));
          if (match$5.tag === 6) {
            return Reductionops$ReactTemplate.whd_beta(sigma, EConstr$ReactTemplate.applist(/* tuple */[
                            t$3,
                            /* :: */[
                              c,
                              /* [] */0
                            ]
                          ]));
          } else {
            return t$3;
          }
          break;
      case 14 : 
          var match$6 = match[0];
          return Caml_array.caml_array_get(match$6[1][1], match$6[0][1]);
      case 15 : 
          var match$7 = match[0];
          return Caml_array.caml_array_get(match$7[1][1], match$7[0]);
      case 16 : 
          var c$1 = match[1];
          var ty$1 = type_of(env, c$1);
          var tmp;
          try {
            tmp = Inductiveops$ReactTemplate.type_of_projection_knowing_arg(env, sigma, match[0], c$1, ty$1);
          }
          catch (raw_exn){
            var exn$3 = Js_exn.internalToOCamlException(raw_exn);
            if (exn$3[0] === Caml_builtin_exceptions.invalid_argument) {
              throw [
                    RetypeError,
                    /* BadRecursiveType */3
                  ];
            } else {
              throw exn$3;
            }
          }
          return EConstr$ReactTemplate.of_constr(tmp);
      
    }
  };
  var sort_of = function (env, t) {
    var match = EConstr$ReactTemplate.kind(sigma, t);
    switch (match.tag | 0) {
      case 4 : 
          var match$1 = EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]);
          if (match$1.tag) {
            return /* Type */Block.__(1, [Univ$ReactTemplate.$$super(match$1[0])]);
          } else {
            return Sorts$ReactTemplate.type1;
          }
          break;
      case 5 : 
          var s = match[2];
          if (EConstr$ReactTemplate.isSort(sigma, s)) {
            return destSort(sigma, s);
          } else {
            return decomp_sort(env, sigma, type_of(env, t));
          }
      case 6 : 
          var t$1 = match[1];
          var match$2 = sort_of(env, t$1);
          var match$3 = sort_of(EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      match[0],
                      t$1
                    ]), env), match[2]);
          var exit = 0;
          if (match$3.tag) {
            exit = 1;
          } else if (match$3[0] !== 0) {
            return match$3;
          } else {
            exit = 1;
          }
          if (exit === 1) {
            if (match$2.tag) {
              var u1 = match$2[0];
              if (match$3.tag) {
                return /* Type */Block.__(1, [Univ$ReactTemplate.sup(u1, match$3[0])]);
              } else if (Environ$ReactTemplate.is_impredicative_set(env)) {
                return match$3;
              } else {
                return /* Type */Block.__(1, [Univ$ReactTemplate.sup(u1, Univ$ReactTemplate.type0_univ)]);
              }
            } else if (!match$3.tag || match$2[0] !== 0) {
              return match$3;
            } else {
              return /* Type */Block.__(1, [Univ$ReactTemplate.sup(Univ$ReactTemplate.type0_univ, match$3[0])]);
            }
          }
          break;
      case 9 : 
          var args = match[1];
          var f = match[0];
          if (Termops$ReactTemplate.is_template_polymorphic(env, sigma, f)) {
            var t$2 = type_of_global_reference_knowing_parameters(env, f, args);
            return sort_of_atomic_type(env, sigma, t$2, args);
          } else {
            return sort_of_atomic_type(env, sigma, type_of(env, f), args);
          }
          break;
      case 7 : 
      case 12 : 
      case 14 : 
          throw [
                RetypeError,
                /* NotAType */2
              ];
      default:
        return decomp_sort(env, sigma, type_of(env, t));
    }
  };
  var type_of_global_reference_knowing_parameters = function (env, c, args) {
    var argtyps = Util$ReactTemplate.$$Array[/* map */12]((function (c) {
            return Block.__(246, [(function () {
                          return EConstr$ReactTemplate.to_constr(sigma, type_of(env, c));
                        })]);
          }), args);
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 11 : 
          var match$1 = match[0];
          var u = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$1[1]);
          var mip = Inductive$ReactTemplate.lookup_mind_specif(env, match$1[0]);
          var tmp;
          try {
            tmp = Inductive$ReactTemplate.type_of_inductive_knowing_parameters(env, /* Some */[polyprop], /* tuple */[
                  mip,
                  u
                ], argtyps);
          }
          catch (exn){
            if (exn === Reduction$ReactTemplate.NotArity) {
              throw [
                    RetypeError,
                    /* NotAnArity */1
                  ];
            } else {
              throw exn;
            }
          }
          return EConstr$ReactTemplate.of_constr(tmp);
      case 12 : 
          var match$2 = match[0];
          var u$1 = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$2[1]);
          return EConstr$ReactTemplate.of_constr(Inductiveops$ReactTemplate.type_of_constructor(env, /* tuple */[
                          match$2[0],
                          u$1
                        ]));
      default:
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "retyping.ml",
                184,
                11
              ]
            ];
    }
  };
  return /* tuple */[
          type_of,
          sort_of,
          type_of_global_reference_knowing_parameters
        ];
}

function get_sort_family_of($staropt$star, $staropt$star$1, env, sigma, t) {
  var truncation_style = $staropt$star ? $staropt$star[0] : /* false */0;
  var polyprop = $staropt$star$1 ? $staropt$star$1[0] : /* true */1;
  var match = retype(/* Some */[polyprop], sigma);
  var type_of_global_reference_knowing_parameters = match[2];
  var type_of = match[0];
  var sort_family_of = function (env, t) {
    var match = EConstr$ReactTemplate.kind(sigma, t);
    var exit = 0;
    switch (match.tag | 0) {
      case 4 : 
          return /* InType */2;
      case 5 : 
          var s = match[2];
          if (EConstr$ReactTemplate.isSort(sigma, s)) {
            return Sorts$ReactTemplate.family(destSort(sigma, s));
          } else {
            exit = 1;
          }
          break;
      case 6 : 
          var t$1 = match[1];
          var s2 = sort_family_of(EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      match[0],
                      t$1
                    ]), env), match[2]);
          if (!Environ$ReactTemplate.is_impredicative_set(env) && s2 === /* InSet */1 && sort_family_of(env, t$1) === /* InType */2) {
            return /* InType */2;
          } else {
            return s2;
          }
      case 9 : 
          var args = match[1];
          var f = match[0];
          if (Termops$ReactTemplate.is_template_polymorphic(env, sigma, f)) {
            if (truncation_style) {
              return /* InType */2;
            } else {
              var t$2 = Curry._3(type_of_global_reference_knowing_parameters, env, f, args);
              return Sorts$ReactTemplate.family(sort_of_atomic_type(env, sigma, t$2, args));
            }
          } else {
            return Sorts$ReactTemplate.family(sort_of_atomic_type(env, sigma, Curry._2(type_of, env, f), args));
          }
          break;
      case 11 : 
          if (truncation_style && Termops$ReactTemplate.is_template_polymorphic(env, sigma, t)) {
            return /* InType */2;
          } else {
            exit = 1;
          }
          break;
      case 7 : 
      case 12 : 
      case 14 : 
          throw [
                RetypeError,
                /* NotAType */2
              ];
      default:
        exit = 1;
    }
    if (exit === 1) {
      return Sorts$ReactTemplate.family(decomp_sort(env, sigma, Curry._2(type_of, env, t)));
    }
    
  };
  return sort_family_of(env, t);
}

function get_sort_of($staropt$star, env, sigma, t) {
  var polyprop = $staropt$star ? $staropt$star[0] : /* true */1;
  var match = retype(/* Some */[polyprop], sigma);
  return anomaly_on_error(Curry._1(match[1], env), t);
}

function type_of_global_reference_knowing_parameters(env, sigma, c, args) {
  var match = retype(/* None */0, sigma);
  return anomaly_on_error(Curry._2(match[2], env, c), args);
}

function type_of_global_reference_knowing_conclusion(env, sigma, c, conclty) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 1 : 
        return /* tuple */[
                sigma,
                type_of_var(env, match[0])
              ];
    case 10 : 
        var match$1 = match[0];
        var t = Environ$ReactTemplate.constant_type_in(env, /* tuple */[
              match$1[0],
              EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$1[1])
            ]);
        return /* tuple */[
                sigma,
                EConstr$ReactTemplate.of_constr(t)
              ];
    case 11 : 
        var match$2 = match[0];
        var spec = Inductive$ReactTemplate.lookup_mind_specif(env, match$2[0]);
        return Inductiveops$ReactTemplate.type_of_inductive_knowing_conclusion(env, sigma, /* tuple */[
                    spec,
                    EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$2[1])
                  ], conclty);
    case 12 : 
        var match$3 = match[0];
        return /* tuple */[
                sigma,
                EConstr$ReactTemplate.of_constr(Inductiveops$ReactTemplate.type_of_constructor(env, /* tuple */[
                          match$3[0],
                          EConstr$ReactTemplate.EInstance[/* kind */1](sigma, match$3[1])
                        ]))
              ];
    default:
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "retyping.ml",
              225,
              11
            ]
          ];
  }
}

function get_type_of($staropt$star, $staropt$star$1, env, sigma, c) {
  var polyprop = $staropt$star ? $staropt$star[0] : /* true */1;
  var lax = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var match = retype(/* Some */[polyprop], sigma);
  var f = match[0];
  if (lax) {
    return Curry._2(f, env, c);
  } else {
    return anomaly_on_error(Curry._1(f, env), c);
  }
}

function get_judgment_of(env, evc, c) {
  return /* record */[
          /* uj_val */c,
          /* uj_type */get_type_of(/* None */0, /* None */0, env, evc, c)
        ];
}

function sorts_of_context(env, evc, ctxt) {
  var aux = function (param) {
    if (param) {
      var d = param[0];
      var match = aux(param[1]);
      var env$1 = match[0];
      var s = get_sort_of(/* None */0, env$1, evc, Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], d));
      return /* tuple */[
              EConstr$ReactTemplate.push_rel(d, env$1),
              /* :: */[
                s,
                match[1]
              ]
            ];
    } else {
      return /* tuple */[
              env,
              /* [] */0
            ];
    }
  };
  return aux(ctxt)[1];
}

function expand_projection(env, sigma, pr, c, args) {
  var ty = get_type_of(/* None */0, /* Some */[/* true */1], env, sigma, c);
  var match;
  try {
    match = Inductiveops$ReactTemplate.find_mrectype(env, sigma, ty);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            RetypeError,
            /* BadRecursiveType */3
          ];
    } else {
      throw exn;
    }
  }
  return EConstr$ReactTemplate.mkApp(/* tuple */[
              EConstr$ReactTemplate.mkConstU(/* tuple */[
                    Names$ReactTemplate.Projection[/* constant */2](pr),
                    match[0][1]
                  ]),
              Util$ReactTemplate.$$Array[/* of_list */10](Util$ReactTemplate.$at(match[1], /* :: */[
                        c,
                        args
                      ]))
            ]);
}

exports.RetypeError = RetypeError;
exports.get_type_of = get_type_of;
exports.get_sort_of = get_sort_of;
exports.get_sort_family_of = get_sort_family_of;
exports.get_judgment_of = get_judgment_of;
exports.type_of_global_reference_knowing_parameters = type_of_global_reference_knowing_parameters;
exports.type_of_global_reference_knowing_conclusion = type_of_global_reference_knowing_conclusion;
exports.sorts_of_context = sorts_of_context;
exports.expand_projection = expand_projection;
exports.print_retype_error = print_retype_error;
/* Pp-ReactTemplate Not a pure module */
