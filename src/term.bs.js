// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function decompose_app(c) {
  var match = Constr$ReactTemplate.kind(c);
  if (match.tag === 9) {
    return /* tuple */[
            match[0],
            Util$ReactTemplate.$$Array[/* to_list */9](match[1])
          ];
  } else {
    return /* tuple */[
            c,
            /* [] */0
          ];
  }
}

function decompose_appvect(c) {
  var match = Constr$ReactTemplate.kind(c);
  if (match.tag === 9) {
    return /* tuple */[
            match[0],
            match[1]
          ];
  } else {
    return /* tuple */[
            c,
            /* array */[]
          ];
  }
}

function mkNamedProd(id, typ, c) {
  return Constr$ReactTemplate.mkProd(/* tuple */[
              /* Name */[id],
              typ,
              Vars$ReactTemplate.subst_var(id, c)
            ]);
}

function mkNamedLambda(id, typ, c) {
  return Constr$ReactTemplate.mkLambda(/* tuple */[
              /* Name */[id],
              typ,
              Vars$ReactTemplate.subst_var(id, c)
            ]);
}

function mkNamedLetIn(id, c1, t, c2) {
  return Constr$ReactTemplate.mkLetIn(/* tuple */[
              /* Name */[id],
              c1,
              t,
              Vars$ReactTemplate.subst_var(id, c2)
            ]);
}

function mkProd_or_LetIn(decl, c) {
  if (decl.tag) {
    return Constr$ReactTemplate.mkLetIn(/* tuple */[
                decl[0],
                decl[1],
                decl[2],
                c
              ]);
  } else {
    return Constr$ReactTemplate.mkProd(/* tuple */[
                decl[0],
                decl[1],
                c
              ]);
  }
}

function mkNamedProd_or_LetIn(decl, c) {
  if (decl.tag) {
    return mkNamedLetIn(decl[0], decl[1], decl[2], c);
  } else {
    return mkNamedProd(decl[0], decl[1], c);
  }
}

function mkProd_wo_LetIn(decl, c) {
  if (decl.tag) {
    return Vars$ReactTemplate.subst1(decl[1], c);
  } else {
    return Constr$ReactTemplate.mkProd(/* tuple */[
                decl[0],
                decl[1],
                c
              ]);
  }
}

function mkNamedProd_wo_LetIn(decl, c) {
  if (decl.tag) {
    return Vars$ReactTemplate.subst1(decl[1], Vars$ReactTemplate.subst_var(decl[0], c));
  } else {
    return mkNamedProd(decl[0], decl[1], c);
  }
}

function mkArrow(t1, t2) {
  return Constr$ReactTemplate.mkProd(/* tuple */[
              /* Anonymous */0,
              t1,
              t2
            ]);
}

function mkLambda_or_LetIn(decl, c) {
  if (decl.tag) {
    return Constr$ReactTemplate.mkLetIn(/* tuple */[
                decl[0],
                decl[1],
                decl[2],
                c
              ]);
  } else {
    return Constr$ReactTemplate.mkLambda(/* tuple */[
                decl[0],
                decl[1],
                c
              ]);
  }
}

function mkNamedLambda_or_LetIn(decl, c) {
  if (decl.tag) {
    return mkNamedLetIn(decl[0], decl[1], decl[2], c);
  } else {
    return mkNamedLambda(decl[0], decl[1], c);
  }
}

function prodn(n, env, b) {
  var _param = /* tuple */[
    n,
    env,
    b
  ];
  while(true) {
    var param = _param;
    var n$1 = param[0];
    if (n$1 !== 0) {
      var match = param[1];
      if (match) {
        var match$1 = match[0];
        _param = /* tuple */[
          n$1 - 1 | 0,
          match[1],
          Constr$ReactTemplate.mkProd(/* tuple */[
                match$1[0],
                match$1[1],
                param[2]
              ])
        ];
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "term.ml",
                291,
                11
              ]
            ];
      }
    } else {
      return param[2];
    }
  };
}

function compose_prod(l, b) {
  return prodn(Curry._1(Util$ReactTemplate.List[/* length */0], l), l, b);
}

function lamn(n, env, b) {
  var _param = /* tuple */[
    n,
    env,
    b
  ];
  while(true) {
    var param = _param;
    var n$1 = param[0];
    if (n$1 !== 0) {
      var match = param[1];
      if (match) {
        var match$1 = match[0];
        _param = /* tuple */[
          n$1 - 1 | 0,
          match[1],
          Constr$ReactTemplate.mkLambda(/* tuple */[
                match$1[0],
                match$1[1],
                param[2]
              ])
        ];
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "term.ml",
                303,
                11
              ]
            ];
      }
    } else {
      return param[2];
    }
  };
}

function compose_lam(l, b) {
  return lamn(Curry._1(Util$ReactTemplate.List[/* length */0], l), l, b);
}

function applist(param) {
  return Constr$ReactTemplate.mkApp(/* tuple */[
              param[0],
              Util$ReactTemplate.$$Array[/* of_list */10](param[1])
            ]);
}

function applistc(f, l) {
  return Constr$ReactTemplate.mkApp(/* tuple */[
              f,
              Util$ReactTemplate.$$Array[/* of_list */10](l)
            ]);
}

function appvectc(f, l) {
  return Constr$ReactTemplate.mkApp(/* tuple */[
              f,
              l
            ]);
}

function to_lambda(n, _prod) {
  while(true) {
    var prod = _prod;
    if (n) {
      var match = Constr$ReactTemplate.kind(prod);
      switch (match.tag | 0) {
        case 5 : 
            _prod = match[0];
            continue ;
            case 6 : 
            return Constr$ReactTemplate.mkLambda(/* tuple */[
                        match[0],
                        match[1],
                        to_lambda(n - 1 | 0, match[2])
                      ]);
        default:
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["to_lambda"], Pp$ReactTemplate.mt(/* () */0));
      }
    } else {
      return prod;
    }
  };
}

function to_prod(n, _lam) {
  while(true) {
    var lam = _lam;
    if (n) {
      var match = Constr$ReactTemplate.kind(lam);
      switch (match.tag | 0) {
        case 5 : 
            _lam = match[0];
            continue ;
            case 7 : 
            return Constr$ReactTemplate.mkProd(/* tuple */[
                        match[0],
                        match[1],
                        to_prod(n - 1 | 0, match[2])
                      ]);
        default:
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["to_prod"], Pp$ReactTemplate.mt(/* () */0));
      }
    } else {
      return lam;
    }
  };
}

var it_mkProd_or_LetIn = Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (c, d) {
        return mkProd_or_LetIn(d, c);
      }));

var it_mkLambda_or_LetIn = Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (c, d) {
        return mkLambda_or_LetIn(d, c);
      }));

function lambda_applist(c, l) {
  var _subst = /* [] */0;
  var _c = c;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var c$1 = _c;
    var subst = _subst;
    var match = Constr$ReactTemplate.kind(c$1);
    var exit = 0;
    if (match.tag === 7) {
      if (l$1) {
        _l = l$1[1];
        _c = match[2];
        _subst = /* :: */[
          l$1[0],
          subst
        ];
        continue ;
        
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (l$1) {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough lambda's."));
      } else {
        return Vars$ReactTemplate.substl(subst, c$1);
      }
    }
    
  };
}

function lambda_appvect(c, v) {
  return lambda_applist(c, Util$ReactTemplate.$$Array[/* to_list */9](v));
}

function lambda_applist_assum(n, c, l) {
  var _n = n;
  var _subst = /* [] */0;
  var _t = c;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var t = _t;
    var subst = _subst;
    var n$1 = _n;
    if (n$1) {
      var match = Constr$ReactTemplate.kind(t);
      var exit = 0;
      switch (match.tag | 0) {
        case 7 : 
            if (l$1) {
              _l = l$1[1];
              _t = match[2];
              _subst = /* :: */[
                l$1[0],
                subst
              ];
              _n = n$1 - 1 | 0;
              continue ;
              
            } else {
              exit = 1;
            }
            break;
        case 8 : 
            _t = match[3];
            _subst = /* :: */[
              Vars$ReactTemplate.substl(subst, match[1]),
              subst
            ];
            _n = n$1 - 1 | 0;
            continue ;
            default:
          exit = 1;
      }
      if (exit === 1) {
        if (l$1) {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough lambda/let's."));
        } else {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough arguments."));
        }
      }
      
    } else if (l$1) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Too many arguments."));
    } else {
      return Vars$ReactTemplate.substl(subst, t);
    }
  };
}

function lambda_appvect_assum(n, c, v) {
  return lambda_applist_assum(n, c, Util$ReactTemplate.$$Array[/* to_list */9](v));
}

function prod_applist(c, l) {
  var _subst = /* [] */0;
  var _c = c;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var c$1 = _c;
    var subst = _subst;
    var match = Constr$ReactTemplate.kind(c$1);
    var exit = 0;
    if (match.tag === 6) {
      if (l$1) {
        _l = l$1[1];
        _c = match[2];
        _subst = /* :: */[
          l$1[0],
          subst
        ];
        continue ;
        
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (l$1) {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough prod's."));
      } else {
        return Vars$ReactTemplate.substl(subst, c$1);
      }
    }
    
  };
}

function prod_appvect(c, v) {
  return prod_applist(c, Util$ReactTemplate.$$Array[/* to_list */9](v));
}

function prod_applist_assum(n, c, l) {
  var _n = n;
  var _subst = /* [] */0;
  var _t = c;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var t = _t;
    var subst = _subst;
    var n$1 = _n;
    if (n$1) {
      var match = Constr$ReactTemplate.kind(t);
      var exit = 0;
      switch (match.tag | 0) {
        case 6 : 
            if (l$1) {
              _l = l$1[1];
              _t = match[2];
              _subst = /* :: */[
                l$1[0],
                subst
              ];
              _n = n$1 - 1 | 0;
              continue ;
              
            } else {
              exit = 1;
            }
            break;
        case 8 : 
            _t = match[3];
            _subst = /* :: */[
              Vars$ReactTemplate.substl(subst, match[1]),
              subst
            ];
            _n = n$1 - 1 | 0;
            continue ;
            default:
          exit = 1;
      }
      if (exit === 1) {
        if (l$1) {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough prod/let's."));
        } else {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough arguments."));
        }
      }
      
    } else if (l$1) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Too many arguments."));
    } else {
      return Vars$ReactTemplate.substl(subst, t);
    }
  };
}

function prod_appvect_assum(n, c, v) {
  return prod_applist_assum(n, c, Util$ReactTemplate.$$Array[/* to_list */9](v));
}

function decompose_prod(param) {
  var _l = /* [] */0;
  var _c = param;
  while(true) {
    var c = _c;
    var l = _l;
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          _l = /* :: */[
            /* tuple */[
              match[0],
              match[1]
            ],
            l
          ];
          continue ;
          default:
        return /* tuple */[
                l,
                c
              ];
    }
  };
}

function decompose_lam(param) {
  var _l = /* [] */0;
  var _c = param;
  while(true) {
    var c = _c;
    var l = _l;
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 7 : 
          _c = match[2];
          _l = /* :: */[
            /* tuple */[
              match[0],
              match[1]
            ],
            l
          ];
          continue ;
          default:
        return /* tuple */[
                l,
                c
              ];
    }
  };
}

function decompose_prod_n(n) {
  if (n < 0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_prod_n: integer parameter must be positive"));
  }
  return (function (param) {
      var _l = /* [] */0;
      var _n = n;
      var _c = param;
      while(true) {
        var c = _c;
        var n$1 = _n;
        var l = _l;
        if (n$1) {
          var match = Constr$ReactTemplate.kind(c);
          switch (match.tag | 0) {
            case 5 : 
                _c = match[0];
                continue ;
                case 6 : 
                _c = match[2];
                _n = n$1 - 1 | 0;
                _l = /* :: */[
                  /* tuple */[
                    match[0],
                    match[1]
                  ],
                  l
                ];
                continue ;
                default:
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_prod_n: not enough products"));
          }
        } else {
          return /* tuple */[
                  l,
                  c
                ];
        }
      };
    });
}

function decompose_lam_n(n) {
  if (n < 0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n: integer parameter must be positive"));
  }
  return (function (param) {
      var _l = /* [] */0;
      var _n = n;
      var _c = param;
      while(true) {
        var c = _c;
        var n$1 = _n;
        var l = _l;
        if (n$1) {
          var match = Constr$ReactTemplate.kind(c);
          switch (match.tag | 0) {
            case 5 : 
                _c = match[0];
                continue ;
                case 7 : 
                _c = match[2];
                _n = n$1 - 1 | 0;
                _l = /* :: */[
                  /* tuple */[
                    match[0],
                    match[1]
                  ],
                  l
                ];
                continue ;
                default:
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n: not enough abstractions"));
          }
        } else {
          return /* tuple */[
                  l,
                  c
                ];
        }
      };
    });
}

var partial_arg = Context$ReactTemplate.Rel[/* empty */1];

function decompose_prod_assum(param) {
  var _l = partial_arg;
  var _c = param;
  while(true) {
    var c = _c;
    var l = _l;
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                  match[0],
                  match[1]
                ]), l);
          continue ;
          case 8 : 
          _c = match[3];
          _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                  match[0],
                  match[1],
                  match[2]
                ]), l);
          continue ;
          default:
        return /* tuple */[
                l,
                c
              ];
    }
  };
}

var partial_arg$1 = Context$ReactTemplate.Rel[/* empty */1];

function decompose_lam_assum(param) {
  var _l = partial_arg$1;
  var _c = param;
  while(true) {
    var c = _c;
    var l = _l;
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 7 : 
          _c = match[2];
          _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                  match[0],
                  match[1]
                ]), l);
          continue ;
          case 8 : 
          _c = match[3];
          _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                  match[0],
                  match[1],
                  match[2]
                ]), l);
          continue ;
          default:
        return /* tuple */[
                l,
                c
              ];
    }
  };
}

function decompose_prod_n_assum(n) {
  if (n < 0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_prod_n_assum: integer parameter must be positive"));
  }
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _l = partial_arg;
      var _n = n;
      var _c = param;
      while(true) {
        var c = _c;
        var n$1 = _n;
        var l = _l;
        if (n$1) {
          var c$1 = Constr$ReactTemplate.kind(c);
          switch (c$1.tag | 0) {
            case 5 : 
                _c = c$1[0];
                continue ;
                case 6 : 
                _c = c$1[2];
                _n = n$1 - 1 | 0;
                _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                        c$1[0],
                        c$1[1]
                      ]), l);
                continue ;
                case 8 : 
                _c = c$1[3];
                _n = n$1 - 1 | 0;
                _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                        c$1[0],
                        c$1[1],
                        c$1[2]
                      ]), l);
                continue ;
                default:
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_prod_n_assum: not enough assumptions"));
          }
        } else {
          return /* tuple */[
                  l,
                  c
                ];
        }
      };
    });
}

function decompose_lam_n_assum(n) {
  if (n < 0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n_assum: integer parameter must be positive"));
  }
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _l = partial_arg;
      var _n = n;
      var _c = param;
      while(true) {
        var c = _c;
        var n$1 = _n;
        var l = _l;
        if (n$1) {
          var c$1 = Constr$ReactTemplate.kind(c);
          switch (c$1.tag | 0) {
            case 5 : 
                _c = c$1[0];
                continue ;
                case 7 : 
                _c = c$1[2];
                _n = n$1 - 1 | 0;
                _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                        c$1[0],
                        c$1[1]
                      ]), l);
                continue ;
                case 8 : 
                _c = c$1[3];
                _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                        c$1[0],
                        c$1[1],
                        c$1[2]
                      ]), l);
                continue ;
                default:
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n_assum: not enough abstractions"));
          }
        } else {
          return /* tuple */[
                  l,
                  c
                ];
        }
      };
    });
}

function decompose_lam_n_decls(n) {
  if (n < 0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n_decls: integer parameter must be positive"));
  }
  var partial_arg = Context$ReactTemplate.Rel[/* empty */1];
  return (function (param) {
      var _l = partial_arg;
      var _n = n;
      var _c = param;
      while(true) {
        var c = _c;
        var n$1 = _n;
        var l = _l;
        if (n$1) {
          var c$1 = Constr$ReactTemplate.kind(c);
          switch (c$1.tag | 0) {
            case 5 : 
                _c = c$1[0];
                continue ;
                case 7 : 
                _c = c$1[2];
                _n = n$1 - 1 | 0;
                _l = Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                        c$1[0],
                        c$1[1]
                      ]), l);
                continue ;
                case 8 : 
                _c = c$1[3];
                _n = n$1 - 1 | 0;
                _l = Context$ReactTemplate.Rel[/* add */2](/* LocalDef */Block.__(1, [
                        c$1[0],
                        c$1[1],
                        c$1[2]
                      ]), l);
                continue ;
                default:
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("decompose_lam_n_decls: not enough abstractions"));
          }
        } else {
          return /* tuple */[
                  l,
                  c
                ];
        }
      };
    });
}

function prod_assum(t) {
  return decompose_prod_assum(t)[0];
}

function prod_n_assum(n, t) {
  return decompose_prod_n_assum(n)(t)[0];
}

function strip_prod_assum(t) {
  return decompose_prod_assum(t)[1];
}

function strip_prod(t) {
  return decompose_prod(t)[1];
}

function strip_prod_n(n, t) {
  return decompose_prod_n(n)(t)[1];
}

function lam_assum(t) {
  return decompose_lam_assum(t)[0];
}

function lam_n_assum(n, t) {
  return decompose_lam_n_assum(n)(t)[0];
}

function strip_lam_assum(t) {
  return decompose_lam_assum(t)[1];
}

function strip_lam(t) {
  return decompose_lam(t)[1];
}

function strip_lam_n(n, t) {
  return decompose_lam_n(n)(t)[1];
}

function destArity(param) {
  var _l = /* [] */0;
  var _c = param;
  while(true) {
    var c = _c;
    var l = _l;
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 4 : 
          return /* tuple */[
                  l,
                  match[0]
                ];
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          _l = /* :: */[
            /* LocalAssum */Block.__(0, [
                match[0],
                match[1]
              ]),
            l
          ];
          continue ;
          case 8 : 
          _c = match[3];
          _l = /* :: */[
            /* LocalDef */Block.__(1, [
                match[0],
                match[1],
                match[2]
              ]),
            l
          ];
          continue ;
          default:
        return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["destArity"], Pp$ReactTemplate.str("not an arity."));
    }
  };
}

function mkArity(param) {
  return Curry._2(it_mkProd_or_LetIn, Constr$ReactTemplate.mkSort(param[1]), param[0]);
}

function isArity(_c) {
  while(true) {
    var c = _c;
    var match = Constr$ReactTemplate.kind(c);
    switch (match.tag | 0) {
      case 4 : 
          return /* true */1;
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          continue ;
          case 8 : 
          _c = Vars$ReactTemplate.subst1(match[1], match[3]);
          continue ;
          default:
        return /* false */0;
    }
  };
}

function kind_of_type(t) {
  var match = Constr$ReactTemplate.kind(t);
  switch (match.tag | 0) {
    case 4 : 
        return /* SortType */Block.__(0, [match[0]]);
    case 5 : 
        return /* CastType */Block.__(1, [
                  match[0],
                  match[2]
                ]);
    case 6 : 
        return /* ProdType */Block.__(2, [
                  match[0],
                  match[1],
                  match[2]
                ]);
    case 8 : 
        return /* LetInType */Block.__(3, [
                  match[0],
                  match[1],
                  match[2],
                  match[3]
                ]);
    case 9 : 
        return /* AtomicType */Block.__(4, [
                  match[0],
                  match[1]
                ]);
    case 7 : 
    case 12 : 
        return Pervasives.failwith("Not a type");
    default:
      return /* AtomicType */Block.__(4, [
                t,
                /* array */[]
              ]);
  }
}

var DestKO = Constr$ReactTemplate.DestKO;

var isRel = Constr$ReactTemplate.isRel;

var isRelN = Constr$ReactTemplate.isRelN;

var isVar = Constr$ReactTemplate.isVar;

var isVarId = Constr$ReactTemplate.isVarId;

var isInd = Constr$ReactTemplate.isInd;

var isEvar = Constr$ReactTemplate.isEvar;

var isMeta = Constr$ReactTemplate.isMeta;

var isEvar_or_Meta = Constr$ReactTemplate.isEvar_or_Meta;

var isSort = Constr$ReactTemplate.isSort;

var isCast = Constr$ReactTemplate.isCast;

var isApp = Constr$ReactTemplate.isApp;

var isLambda = Constr$ReactTemplate.isLambda;

var isLetIn = Constr$ReactTemplate.isLetIn;

var isProd = Constr$ReactTemplate.isProd;

var isConst = Constr$ReactTemplate.isConst;

var isConstruct = Constr$ReactTemplate.isConstruct;

var isFix = Constr$ReactTemplate.isFix;

var isCoFix = Constr$ReactTemplate.isCoFix;

var isCase = Constr$ReactTemplate.isCase;

var isProj = Constr$ReactTemplate.isProj;

var is_Prop = Constr$ReactTemplate.is_Prop;

var is_Set = Constr$ReactTemplate.is_Set;

var isprop = Constr$ReactTemplate.isprop;

var is_Type = Constr$ReactTemplate.is_Type;

var iskind = Constr$ReactTemplate.iskind;

var is_small = Constr$ReactTemplate.is_small;

var destRel = Constr$ReactTemplate.destRel;

var destMeta = Constr$ReactTemplate.destRel;

var destVar = Constr$ReactTemplate.destVar;

var destSort = Constr$ReactTemplate.destSort;

var destCast = Constr$ReactTemplate.destCast;

var destProd = Constr$ReactTemplate.destProd;

var destLambda = Constr$ReactTemplate.destLambda;

var destLetIn = Constr$ReactTemplate.destLetIn;

var destApp = Constr$ReactTemplate.destApp;

var destApplication = Constr$ReactTemplate.destApp;

var destConst = Constr$ReactTemplate.destConst;

var destEvar = Constr$ReactTemplate.destEvar;

var destInd = Constr$ReactTemplate.destInd;

var destConstruct = Constr$ReactTemplate.destConstruct;

var destCase = Constr$ReactTemplate.destCase;

var destProj = Constr$ReactTemplate.destProj;

var destFix = Constr$ReactTemplate.destFix;

var destCoFix = Constr$ReactTemplate.destCoFix;

var appvect = Constr$ReactTemplate.mkApp;

var set_sort = Sorts$ReactTemplate.set;

var prop_sort = Sorts$ReactTemplate.prop;

var type1_sort = Sorts$ReactTemplate.type1;

var sorts_ord = Sorts$ReactTemplate.compare;

var is_prop_sort = Sorts$ReactTemplate.is_prop;

var family_of_sort = Sorts$ReactTemplate.family;

var mkRel = Constr$ReactTemplate.mkRel;

var mkVar = Constr$ReactTemplate.mkVar;

var mkMeta = Constr$ReactTemplate.mkMeta;

var mkEvar = Constr$ReactTemplate.mkEvar;

var mkSort = Constr$ReactTemplate.mkSort;

var mkProp = Constr$ReactTemplate.mkProp;

var mkSet = Constr$ReactTemplate.mkSet;

var mkType = Constr$ReactTemplate.mkType;

var mkCast = Constr$ReactTemplate.mkCast;

var mkProd = Constr$ReactTemplate.mkProd;

var mkLambda = Constr$ReactTemplate.mkLambda;

var mkLetIn = Constr$ReactTemplate.mkLetIn;

var mkApp = Constr$ReactTemplate.mkApp;

var mkConst = Constr$ReactTemplate.mkConst;

var mkProj = Constr$ReactTemplate.mkProj;

var mkInd = Constr$ReactTemplate.mkInd;

var mkConstruct = Constr$ReactTemplate.mkConstruct;

var mkConstU = Constr$ReactTemplate.mkConstU;

var mkIndU = Constr$ReactTemplate.mkIndU;

var mkConstructU = Constr$ReactTemplate.mkConstructU;

var mkConstructUi = Constr$ReactTemplate.mkConstructUi;

var mkCase = Constr$ReactTemplate.mkCase;

var mkFix = Constr$ReactTemplate.mkFix;

var mkCoFix = Constr$ReactTemplate.mkCoFix;

var eq_constr = Constr$ReactTemplate.equal;

var eq_constr_univs = Constr$ReactTemplate.eq_constr_univs;

var leq_constr_univs = Constr$ReactTemplate.leq_constr_univs;

var eq_constr_nounivs = Constr$ReactTemplate.eq_constr_nounivs;

var kind_of_term = Constr$ReactTemplate.kind;

var compare = Constr$ReactTemplate.compare;

var constr_ord = Constr$ReactTemplate.compare;

var fold_constr = Constr$ReactTemplate.fold;

var map_constr = Constr$ReactTemplate.map;

var map_constr_with_binders = Constr$ReactTemplate.map_with_binders;

var map_puniverses = Constr$ReactTemplate.map_puniverses;

var univ_of_sort = Sorts$ReactTemplate.univ_of_sort;

var sort_of_univ = Sorts$ReactTemplate.sort_of_univ;

var iter_constr = Constr$ReactTemplate.iter;

var iter_constr_with_binders = Constr$ReactTemplate.iter_with_binders;

var compare_constr = Constr$ReactTemplate.compare_head;

var hash_constr = Constr$ReactTemplate.hash;

var hcons_sorts = Sorts$ReactTemplate.hcons;

var hcons_constr = Constr$ReactTemplate.hcons;

var hcons_types = Constr$ReactTemplate.hcons;

exports.DestKO = DestKO;
exports.isRel = isRel;
exports.isRelN = isRelN;
exports.isVar = isVar;
exports.isVarId = isVarId;
exports.isInd = isInd;
exports.isEvar = isEvar;
exports.isMeta = isMeta;
exports.isEvar_or_Meta = isEvar_or_Meta;
exports.isSort = isSort;
exports.isCast = isCast;
exports.isApp = isApp;
exports.isLambda = isLambda;
exports.isLetIn = isLetIn;
exports.isProd = isProd;
exports.isConst = isConst;
exports.isConstruct = isConstruct;
exports.isFix = isFix;
exports.isCoFix = isCoFix;
exports.isCase = isCase;
exports.isProj = isProj;
exports.is_Prop = is_Prop;
exports.is_Set = is_Set;
exports.isprop = isprop;
exports.is_Type = is_Type;
exports.iskind = iskind;
exports.is_small = is_small;
exports.destRel = destRel;
exports.destMeta = destMeta;
exports.destVar = destVar;
exports.destSort = destSort;
exports.destCast = destCast;
exports.destProd = destProd;
exports.destLambda = destLambda;
exports.destLetIn = destLetIn;
exports.destApp = destApp;
exports.destApplication = destApplication;
exports.decompose_app = decompose_app;
exports.decompose_appvect = decompose_appvect;
exports.destConst = destConst;
exports.destEvar = destEvar;
exports.destInd = destInd;
exports.destConstruct = destConstruct;
exports.destCase = destCase;
exports.destProj = destProj;
exports.destFix = destFix;
exports.destCoFix = destCoFix;
exports.mkArrow = mkArrow;
exports.mkNamedLambda = mkNamedLambda;
exports.mkNamedLetIn = mkNamedLetIn;
exports.mkNamedProd = mkNamedProd;
exports.mkProd_or_LetIn = mkProd_or_LetIn;
exports.mkProd_wo_LetIn = mkProd_wo_LetIn;
exports.mkNamedProd_or_LetIn = mkNamedProd_or_LetIn;
exports.mkNamedProd_wo_LetIn = mkNamedProd_wo_LetIn;
exports.mkLambda_or_LetIn = mkLambda_or_LetIn;
exports.mkNamedLambda_or_LetIn = mkNamedLambda_or_LetIn;
exports.applist = applist;
exports.applistc = applistc;
exports.appvect = appvect;
exports.appvectc = appvectc;
exports.prodn = prodn;
exports.compose_prod = compose_prod;
exports.lamn = lamn;
exports.compose_lam = compose_lam;
exports.to_lambda = to_lambda;
exports.to_prod = to_prod;
exports.it_mkLambda_or_LetIn = it_mkLambda_or_LetIn;
exports.it_mkProd_or_LetIn = it_mkProd_or_LetIn;
exports.lambda_applist = lambda_applist;
exports.lambda_appvect = lambda_appvect;
exports.lambda_applist_assum = lambda_applist_assum;
exports.lambda_appvect_assum = lambda_appvect_assum;
exports.prod_appvect = prod_appvect;
exports.prod_applist = prod_applist;
exports.prod_appvect_assum = prod_appvect_assum;
exports.prod_applist_assum = prod_applist_assum;
exports.decompose_prod = decompose_prod;
exports.decompose_lam = decompose_lam;
exports.decompose_prod_n = decompose_prod_n;
exports.decompose_lam_n = decompose_lam_n;
exports.decompose_prod_assum = decompose_prod_assum;
exports.decompose_lam_assum = decompose_lam_assum;
exports.decompose_prod_n_assum = decompose_prod_n_assum;
exports.decompose_lam_n_assum = decompose_lam_n_assum;
exports.decompose_lam_n_decls = decompose_lam_n_decls;
exports.prod_assum = prod_assum;
exports.lam_assum = lam_assum;
exports.prod_n_assum = prod_n_assum;
exports.lam_n_assum = lam_n_assum;
exports.strip_prod = strip_prod;
exports.strip_lam = strip_lam;
exports.strip_prod_n = strip_prod_n;
exports.strip_lam_n = strip_lam_n;
exports.strip_prod_assum = strip_prod_assum;
exports.strip_lam_assum = strip_lam_assum;
exports.mkArity = mkArity;
exports.destArity = destArity;
exports.isArity = isArity;
exports.kind_of_type = kind_of_type;
exports.set_sort = set_sort;
exports.prop_sort = prop_sort;
exports.type1_sort = type1_sort;
exports.sorts_ord = sorts_ord;
exports.is_prop_sort = is_prop_sort;
exports.family_of_sort = family_of_sort;
exports.mkRel = mkRel;
exports.mkVar = mkVar;
exports.mkMeta = mkMeta;
exports.mkEvar = mkEvar;
exports.mkSort = mkSort;
exports.mkProp = mkProp;
exports.mkSet = mkSet;
exports.mkType = mkType;
exports.mkCast = mkCast;
exports.mkProd = mkProd;
exports.mkLambda = mkLambda;
exports.mkLetIn = mkLetIn;
exports.mkApp = mkApp;
exports.mkConst = mkConst;
exports.mkProj = mkProj;
exports.mkInd = mkInd;
exports.mkConstruct = mkConstruct;
exports.mkConstU = mkConstU;
exports.mkIndU = mkIndU;
exports.mkConstructU = mkConstructU;
exports.mkConstructUi = mkConstructUi;
exports.mkCase = mkCase;
exports.mkFix = mkFix;
exports.mkCoFix = mkCoFix;
exports.eq_constr = eq_constr;
exports.eq_constr_univs = eq_constr_univs;
exports.leq_constr_univs = leq_constr_univs;
exports.eq_constr_nounivs = eq_constr_nounivs;
exports.kind_of_term = kind_of_term;
exports.compare = compare;
exports.constr_ord = constr_ord;
exports.fold_constr = fold_constr;
exports.map_constr = map_constr;
exports.map_constr_with_binders = map_constr_with_binders;
exports.map_puniverses = map_puniverses;
exports.univ_of_sort = univ_of_sort;
exports.sort_of_univ = sort_of_univ;
exports.iter_constr = iter_constr;
exports.iter_constr_with_binders = iter_constr_with_binders;
exports.compare_constr = compare_constr;
exports.hash_constr = hash_constr;
exports.hcons_sorts = hcons_sorts;
exports.hcons_constr = hcons_constr;
exports.hcons_types = hcons_types;
/* it_mkProd_or_LetIn Not a pure module */
