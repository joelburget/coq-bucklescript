// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Tacred$ReactTemplate = require("./tacred.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");

function coe_info_typ_equal(c1, c2) {
  var eq_constr = function (c1, c2) {
    return Termops$ReactTemplate.eq_constr(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(c1), EConstr$ReactTemplate.of_constr(c2));
  };
  if (eq_constr(c1[/* coe_value */0], c2[/* coe_value */0]) && eq_constr(c1[/* coe_type */1], c2[/* coe_type */1]) && c1[/* coe_local */2] === c2[/* coe_local */2] && c1[/* coe_is_identity */4] === c2[/* coe_is_identity */4] && c1[/* coe_is_projection */5] === c2[/* coe_is_projection */5]) {
    return +(c1[/* coe_param */6] === c2[/* coe_param */6]);
  } else {
    return /* false */0;
  }
}

function cl_typ_ord(t1, t2) {
  if (typeof t1 === "number") {
    return Caml_obj.caml_compare(t1, t2);
  } else {
    switch (t1.tag | 0) {
      case 0 : 
          if (typeof t2 === "number" || t2.tag) {
            return Caml_obj.caml_compare(t1, t2);
          } else {
            return Curry._2(Names$ReactTemplate.Id[/* compare */1], t1[0], t2[0]);
          }
          break;
      case 1 : 
          if (typeof t2 === "number" || t2.tag !== 1) {
            return Caml_obj.caml_compare(t1, t2);
          } else {
            return Curry._2(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], t1[0], t2[0]);
          }
          break;
      case 2 : 
          if (typeof t2 === "number" || t2.tag !== 2) {
            return Caml_obj.caml_compare(t1, t2);
          } else {
            return Names$ReactTemplate.ind_ord(t1[0], t2[0]);
          }
          break;
      case 3 : 
          if (typeof t2 === "number" || t2.tag !== 3) {
            return Caml_obj.caml_compare(t1, t2);
          } else {
            return Curry._2(Names$ReactTemplate.Constant[/* CanOrd */9][/* compare */0], t1[0], t2[0]);
          }
          break;
      
    }
  }
}

var ClTyp = /* module */[/* compare */cl_typ_ord];

var ClTypMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], ClTyp);

var IntMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], [Caml_primitive.caml_int_compare]);

function cl_typ_eq(t1, t2) {
  return +(cl_typ_ord(t1, t2) === 0);
}

var empty_000 = /* v */IntMap[/* empty */0];

var empty_002 = /* inv */ClTypMap[/* empty */0];

var empty = /* record */[
  empty_000,
  /* s */0,
  empty_002
];

function mem(y, b) {
  return Curry._2(ClTypMap[/* mem */2], y, b[/* inv */2]);
}

function map(x, b) {
  return Curry._2(IntMap[/* find */21], x, b[/* v */0]);
}

function revmap(y, b) {
  var n = Curry._2(ClTypMap[/* find */21], y, b[/* inv */2]);
  return /* tuple */[
          n,
          Curry._2(IntMap[/* find */21], n, b[/* v */0])[1]
        ];
}

function add(x, y, b) {
  return /* record */[
          /* v */Curry._3(IntMap[/* add */3], b[/* s */1], /* tuple */[
                x,
                y
              ], b[/* v */0]),
          /* s */b[/* s */1] + 1 | 0,
          /* inv */Curry._3(ClTypMap[/* add */3], x, b[/* s */1], b[/* inv */2])
        ];
}

function dom(b) {
  return Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._3(ClTypMap[/* fold */10], (function (x, _, acc) {
                    return /* :: */[
                            x,
                            acc
                          ];
                  }), b[/* inv */2], /* [] */0));
}

var Bijint_000 = /* Index */[
  Caml_primitive.caml_int_compare,
  (function (prim, prim$1) {
      return +(prim === prim$1);
    }),
  Pp$ReactTemplate.$$int
];

var class_tab = [empty];

var coercion_tab = [Globnames$ReactTemplate.Refmap_env[/* empty */0]];

function compare(param, param$1) {
  var c = Curry._2(Bijint_000[/* compare */0], param[0], param$1[0]);
  if (c) {
    return c;
  } else {
    return Curry._2(Bijint_000[/* compare */0], param[1], param$1[1]);
  }
}

var ClPairOrd = /* module */[/* compare */compare];

var ClPairMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], ClPairOrd);

var inheritance_graph = [ClPairMap[/* empty */0]];

function freeze() {
  return /* tuple */[
          class_tab[0],
          coercion_tab[0],
          inheritance_graph[0]
        ];
}

function unfreeze(param) {
  class_tab[0] = param[0];
  coercion_tab[0] = param[1];
  inheritance_graph[0] = param[2];
  return /* () */0;
}

function add_new_class(cl, s) {
  if (mem(cl, class_tab[0])) {
    return 0;
  } else {
    class_tab[0] = add(cl, s, class_tab[0]);
    return /* () */0;
  }
}

function add_new_coercion(coe, s) {
  coercion_tab[0] = Curry._3(Globnames$ReactTemplate.Refmap_env[/* add */3], coe, s, coercion_tab[0]);
  return /* () */0;
}

function add_new_path(x, y) {
  inheritance_graph[0] = Curry._3(ClPairMap[/* add */3], x, y, inheritance_graph[0]);
  return /* () */0;
}

function init() {
  class_tab[0] = empty;
  add_new_class(/* CL_FUN */1, /* record */[/* cl_param */0]);
  add_new_class(/* CL_SORT */0, /* record */[/* cl_param */0]);
  coercion_tab[0] = Globnames$ReactTemplate.Refmap_env[/* empty */0];
  inheritance_graph[0] = ClPairMap[/* empty */0];
  return /* () */0;
}

Summary$ReactTemplate.declare_summary("inh_graph", /* record */[
      /* freeze_function */freeze,
      /* unfreeze_function */unfreeze,
      /* init_function */init
    ]);

init(/* () */0);

function class_info(cl) {
  return revmap(cl, class_tab[0]);
}

function class_exists(cl) {
  return mem(cl, class_tab[0]);
}

function class_info_from_index(i) {
  return map(i, class_tab[0]);
}

var cl_fun_index = class_info(/* CL_FUN */1)[0];

var cl_sort_index = class_info(/* CL_SORT */0)[0];

function coercion_info(coe) {
  return Curry._2(Globnames$ReactTemplate.Refmap_env[/* find */21], coe, coercion_tab[0]);
}

function coercion_exists(coe) {
  return Curry._2(Globnames$ReactTemplate.Refmap_env[/* mem */2], coe, coercion_tab[0]);
}

function find_class_type(sigma, t) {
  var match = Reductionops$ReactTemplate.whd_betaiotazeta_stack(sigma, t);
  var args = match[1];
  var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
  switch (match$1.tag | 0) {
    case 1 : 
        return /* tuple */[
                /* CL_SECVAR */Block.__(0, [match$1[0]]),
                EConstr$ReactTemplate.EInstance[/* empty */2],
                args
              ];
    case 4 : 
        return /* tuple */[
                /* CL_SORT */0,
                EConstr$ReactTemplate.EInstance[/* empty */2],
                /* [] */0
              ];
    case 6 : 
        return /* tuple */[
                /* CL_FUN */1,
                EConstr$ReactTemplate.EInstance[/* empty */2],
                /* [] */0
              ];
    case 10 : 
        var match$2 = match$1[0];
        return /* tuple */[
                /* CL_CONST */Block.__(1, [match$2[0]]),
                match$2[1],
                args
              ];
    case 11 : 
        var match$3 = match$1[0];
        return /* tuple */[
                /* CL_IND */Block.__(2, [match$3[0]]),
                match$3[1],
                args
              ];
    case 16 : 
        var p = match$1[0];
        if (Names$ReactTemplate.Projection[/* unfolded */3](p)) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          return /* tuple */[
                  /* CL_PROJ */Block.__(3, [Names$ReactTemplate.Projection[/* constant */2](p)]),
                  EConstr$ReactTemplate.EInstance[/* empty */2],
                  /* :: */[
                    match$1[1],
                    args
                  ]
                ];
        }
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function subst_cl_typ(subst, ct) {
  if (typeof ct === "number") {
    return ct;
  } else {
    switch (ct.tag | 0) {
      case 1 : 
          var c = ct[0];
          var match = Mod_subst$ReactTemplate.subst_con_kn(subst, c);
          if (match[0] === c) {
            return ct;
          } else {
            return Util$ReactTemplate.pi1(find_class_type(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(match[1])));
          }
      case 2 : 
          var i = ct[0];
          var i$prime = Mod_subst$ReactTemplate.subst_ind(subst, i);
          if (i$prime === i) {
            return ct;
          } else {
            return /* CL_IND */Block.__(2, [i$prime]);
          }
      case 3 : 
          var c$1 = ct[0];
          var match$1 = Mod_subst$ReactTemplate.subst_con_kn(subst, c$1);
          var c$prime = match$1[0];
          if (c$prime === c$1) {
            return ct;
          } else {
            return /* CL_PROJ */Block.__(3, [c$prime]);
          }
      default:
        return ct;
    }
  }
}

var subst_coe_typ = Globnames$ReactTemplate.subst_global_reference;

function class_of(env, sigma, t) {
  var match;
  try {
    var match$1 = find_class_type(sigma, t);
    var match$2 = class_info(match$1[0]);
    match = /* tuple */[
      t,
      match$2[1][/* cl_param */0],
      match$2[0],
      match$1[1],
      match$1[2]
    ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var t$1 = Tacred$ReactTemplate.hnf_constr(env, sigma, t);
      var match$3 = find_class_type(sigma, t$1);
      var match$4 = class_info(match$3[0]);
      match = /* tuple */[
        t$1,
        match$4[1][/* cl_param */0],
        match$4[0],
        match$3[1],
        match$3[2]
      ];
    } else {
      throw exn;
    }
  }
  if (Curry._1(Util$ReactTemplate.List[/* length */0], match[4]) === match[1]) {
    return /* tuple */[
            match[0],
            match[2]
          ];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function inductive_class_of(ind) {
  return class_info(/* CL_IND */Block.__(2, [ind]))[0];
}

function class_args_of(_, sigma, c) {
  return Util$ReactTemplate.pi3(find_class_type(sigma, c));
}

function string_of_class(param) {
  var exit = 0;
  if (typeof param === "number") {
    if (param) {
      return "Funclass";
    } else {
      return "Sortclass";
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Libnames$ReactTemplate.string_of_qualid(Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* VarRef */Block.__(0, [param[0]])));
      case 2 : 
          return Libnames$ReactTemplate.string_of_qualid(Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* IndRef */Block.__(2, [param[0]])));
      case 1 : 
      case 3 : 
          exit = 1;
          break;
      
    }
  }
  if (exit === 1) {
    return Libnames$ReactTemplate.string_of_qualid(Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* ConstRef */Block.__(1, [param[0]])));
  }
  
}

function pr_class(x) {
  return Pp$ReactTemplate.str(string_of_class(x));
}

function lookup_path_between_class(param) {
  return Curry._2(ClPairMap[/* find */21], /* tuple */[
              param[0],
              param[1]
            ], inheritance_graph[0]);
}

function lookup_path_to_fun_from_class(s) {
  return lookup_path_between_class(/* tuple */[
              s,
              cl_fun_index
            ]);
}

function lookup_path_to_sort_from_class(s) {
  return lookup_path_between_class(/* tuple */[
              s,
              cl_sort_index
            ]);
}

function apply_on_class_of(env, sigma, t, cont) {
  try {
    var match = find_class_type(sigma, t);
    var match$1 = class_info(match[0]);
    if (Curry._1(Util$ReactTemplate.List[/* length */0], match[2]) !== match$1[1][/* cl_param */0]) {
      throw Caml_builtin_exceptions.not_found;
    }
    return /* tuple */[
            t,
            Curry._1(cont, match$1[0])
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var t$1 = Tacred$ReactTemplate.hnf_constr(env, sigma, t);
      var match$2 = find_class_type(sigma, t$1);
      var match$3 = class_info(match$2[0]);
      if (Curry._1(Util$ReactTemplate.List[/* length */0], match$2[2]) !== match$3[1][/* cl_param */0]) {
        throw Caml_builtin_exceptions.not_found;
      }
      return /* tuple */[
              t$1,
              Curry._1(cont, match$3[0])
            ];
    } else {
      throw exn;
    }
  }
}

function lookup_path_between(env, sigma, param) {
  var t = param[1];
  var match = apply_on_class_of(env, sigma, param[0], (function (i) {
          return apply_on_class_of(env, sigma, t, (function (j) {
                        return lookup_path_between_class(/* tuple */[
                                    i,
                                    j
                                  ]);
                      }));
        }));
  var match$1 = match[1];
  return /* tuple */[
          match[0],
          match$1[0],
          match$1[1]
        ];
}

function lookup_path_to_fun_from(env, sigma, s) {
  return apply_on_class_of(env, sigma, s, lookup_path_to_fun_from_class);
}

function lookup_path_to_sort_from(env, sigma, s) {
  return apply_on_class_of(env, sigma, s, lookup_path_to_sort_from_class);
}

function lookup_pattern_path_between(env, param) {
  var i = class_info(/* CL_IND */Block.__(2, [param[0]]))[0];
  var j = class_info(/* CL_IND */Block.__(2, [param[1]]))[0];
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                var env$1 = env;
                var coe = param;
                var match = Reductionops$ReactTemplate.whd_all_stack(env$1)(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(coe[/* coe_value */0]));
                var match$1 = EConstr$ReactTemplate.kind(Evd$ReactTemplate.empty, match[0]);
                if (match$1.tag === 12) {
                  var cstr = match$1[0][0];
                  return /* tuple */[
                          cstr,
                          Inductiveops$ReactTemplate.constructor_nrealargs(cstr) - 1 | 0
                        ];
                } else {
                  throw Caml_builtin_exceptions.not_found;
                }
              }), Curry._2(ClPairMap[/* find */21], /* tuple */[
                  i,
                  j
                ], inheritance_graph[0]));
}

function coercion_value(param) {
  var match = Universes$ReactTemplate.fresh_universe_context_set_instance(param[/* coe_context */3]);
  var subst = match[0];
  var c$prime = Vars$ReactTemplate.subst_univs_level_constr(subst, param[/* coe_value */0]);
  var t$prime = Vars$ReactTemplate.subst_univs_level_constr(subst, param[/* coe_type */1]);
  return /* tuple */[
          /* tuple */[
            Environ$ReactTemplate.make_judge(EConstr$ReactTemplate.of_constr(c$prime), EConstr$ReactTemplate.of_constr(t$prime)),
            param[/* coe_is_identity */4],
            param[/* coe_is_projection */5]
          ],
          match[1]
        ];
}

var path_printer = [(function (_, _$1, _$2) {
      return Pp$ReactTemplate.str("<a class path>");
    })];

function install_path_printer(f) {
  path_printer[0] = f;
  return /* () */0;
}

function message_ambig(env, sigma, l) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Ambiguous paths:"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (ijp) {
                    var env$1 = env;
                    var sigma$1 = sigma;
                    var x = ijp;
                    return Curry._3(path_printer[0], env$1, sigma$1, x);
                  }), l));
}

function different_class_params(i) {
  var ci = class_info_from_index(i);
  if (ci[1][/* cl_param */0] > 0) {
    return /* true */1;
  } else {
    var match = ci[0];
    if (typeof match === "number") {
      return /* false */0;
    } else {
      switch (match.tag | 0) {
        case 1 : 
            return Global$ReactTemplate.is_polymorphic(/* ConstRef */Block.__(1, [match[0]]));
        case 2 : 
            return Global$ReactTemplate.is_polymorphic(/* IndRef */Block.__(2, [match[0]]));
        default:
          return /* false */0;
      }
    }
  }
}

function reference_arity_length(ref) {
  var match = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), ref);
  return Curry._1(Util$ReactTemplate.List[/* length */0], Reductionops$ReactTemplate.splay_arity(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(match[0]))[0]);
}

function class_params(param) {
  if (typeof param === "number") {
    return 0;
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return reference_arity_length(/* VarRef */Block.__(0, [param[0]]));
      case 1 : 
          return reference_arity_length(/* ConstRef */Block.__(1, [param[0]]));
      case 2 : 
          return reference_arity_length(/* IndRef */Block.__(2, [param[0]]));
      case 3 : 
          var p = param[0];
          var len = reference_arity_length(/* ConstRef */Block.__(1, [p]));
          var pb = Environ$ReactTemplate.lookup_projection(Names$ReactTemplate.Projection[/* make */0](p, /* false */0), Global$ReactTemplate.env(/* () */0));
          return len - pb[/* proj_npars */1] | 0;
      
    }
  }
}

function add_class(cl) {
  return add_new_class(cl, /* record */[/* cl_param */class_params(cl)]);
}

var automatically_import_coercions = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : true */1,
      /* optname */"automatic import of coercions",
      /* optkey : :: */[
        "Automatic",
        /* :: */[
          "Coercions",
          /* :: */[
            "Import",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return automatically_import_coercions[0];
        }),
      /* optwrite */(function (param) {
          automatically_import_coercions[0] = param;
          return /* () */0;
        })
    ]);

function cache_coercion(env, sigma, param) {
  var c = param[1];
  add_class(c[/* coercion_source */4]);
  add_class(c[/* coercion_target */5]);
  var match = class_info(c[/* coercion_source */4]);
  var match$1 = class_info(c[/* coercion_target */5]);
  var match$2 = Universes$ReactTemplate.fresh_global_instance(/* None */0, env, c[/* coercion_type */0]);
  var value = match$2[0];
  var typ = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, EConstr$ReactTemplate.of_constr(value));
  var typ$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](typ);
  var xf_002 = /* coe_local */c[/* coercion_local */1];
  var xf_003 = /* coe_context */match$2[1];
  var xf_004 = /* coe_is_identity */c[/* coercion_is_id */2];
  var xf_005 = /* coe_is_projection */c[/* coercion_is_proj */3];
  var xf_006 = /* coe_param */c[/* coercion_params */6];
  var xf = /* record */[
    /* coe_value */value,
    /* coe_type */typ$1,
    xf_002,
    xf_003,
    xf_004,
    xf_005,
    xf_006
  ];
  add_new_coercion(c[/* coercion_type */0], xf);
  var env$1 = env;
  var sigma$1 = sigma;
  var param$1 = /* tuple */[
    xf,
    match[0],
    match$1[0]
  ];
  var target = param$1[2];
  var source = param$1[1];
  var ic = param$1[0];
  var old_inheritance_graph = inheritance_graph[0];
  var ambig_paths = [/* [] */0];
  var try_add_new_path = function (ij, p) {
    var i = ij[0];
    try {
      if (Curry._2(Bijint_000[/* equal */1], i, ij[1])) {
        if (different_class_params(i)) {
          lookup_path_between_class(ij);
          ambig_paths[0] = /* :: */[
            /* tuple */[
              ij,
              p
            ],
            ambig_paths[0]
          ];
        }
        
      } else {
        lookup_path_between_class(ij);
        ambig_paths[0] = /* :: */[
          /* tuple */[
            ij,
            p
          ],
          ambig_paths[0]
        ];
      }
      return /* false */0;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        add_new_path(ij, p);
        return /* true */1;
      } else {
        throw exn;
      }
    }
  };
  var try_add_new_path1 = function (ij, p) {
    try_add_new_path(ij, p);
    return /* () */0;
  };
  if (try_add_new_path(/* tuple */[
          source,
          target
        ], /* :: */[
          ic,
          /* [] */0
        ])) {
    Curry._2(ClPairMap[/* iter */9], (function (param, p) {
            var t = param[1];
            var s = param[0];
            if (Curry._2(Bijint_000[/* equal */1], s, t)) {
              return 0;
            } else {
              if (Curry._2(Bijint_000[/* equal */1], t, source)) {
                try_add_new_path1(/* tuple */[
                      s,
                      target
                    ], Util$ReactTemplate.$at(p, /* :: */[
                          ic,
                          /* [] */0
                        ]));
                Curry._2(ClPairMap[/* iter */9], (function (param, q) {
                        var v = param[1];
                        var u = param[0];
                        if (!Curry._2(Bijint_000[/* equal */1], u, v) && Curry._2(Bijint_000[/* equal */1], u, target) && !Curry._3(Util$ReactTemplate.List[/* equal */44], coe_info_typ_equal, p, q)) {
                          return try_add_new_path1(/* tuple */[
                                      s,
                                      v
                                    ], Util$ReactTemplate.$at(p, Util$ReactTemplate.$at(/* :: */[
                                              ic,
                                              /* [] */0
                                            ], q)));
                        } else {
                          return 0;
                        }
                      }), old_inheritance_graph);
              }
              if (Curry._2(Bijint_000[/* equal */1], s, target)) {
                return try_add_new_path1(/* tuple */[
                            source,
                            t
                          ], /* :: */[
                            ic,
                            p
                          ]);
              } else {
                return 0;
              }
            }
          }), old_inheritance_graph);
  }
  var match$3 = ambig_paths[0];
  var is_ambig = match$3 ? /* true */1 : /* false */0;
  if (is_ambig && !Flags$ReactTemplate.quiet[0]) {
    return Feedback$ReactTemplate.msg_info(/* None */0, message_ambig(env$1, sigma$1, ambig_paths[0]));
  } else {
    return 0;
  }
}

function load_coercion(_, o) {
  if (automatically_import_coercions[0]) {
    return cache_coercion(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, o);
  } else {
    return 0;
  }
}

function open_coercion(i, o) {
  if (i === 1 && !automatically_import_coercions[0]) {
    return cache_coercion(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, o);
  } else {
    return 0;
  }
}

function subst_coercion(param) {
  var c = param[1];
  var subst = param[0];
  var coe = Globnames$ReactTemplate.subst_global_reference(subst, c[/* coercion_type */0]);
  var cls = subst_cl_typ(subst, c[/* coercion_source */4]);
  var clt = subst_cl_typ(subst, c[/* coercion_target */5]);
  if (c[/* coercion_type */0] === coe && c[/* coercion_source */4] === cls && c[/* coercion_target */5] === clt) {
    return c;
  } else {
    return /* record */[
            /* coercion_type */coe,
            /* coercion_local */c[/* coercion_local */1],
            /* coercion_is_id */c[/* coercion_is_id */2],
            /* coercion_is_proj */c[/* coercion_is_proj */3],
            /* coercion_source */cls,
            /* coercion_target */clt,
            /* coercion_params */c[/* coercion_params */6]
          ];
  }
}

function discharge_cl(cl) {
  if (typeof cl === "number") {
    return cl;
  } else {
    switch (cl.tag | 0) {
      case 1 : 
          return /* CL_CONST */Block.__(1, [Lib$ReactTemplate.discharge_con(cl[0])]);
      case 2 : 
          return /* CL_IND */Block.__(2, [Lib$ReactTemplate.discharge_inductive(cl[0])]);
      case 3 : 
          return /* CL_PROJ */Block.__(3, [Lib$ReactTemplate.discharge_con(cl[0])]);
      default:
        return cl;
    }
  }
}

function discharge_coercion(param) {
  var c = param[1];
  if (c[/* coercion_local */1]) {
    return /* None */0;
  } else {
    var n;
    try {
      var ins = Lib$ReactTemplate.section_instance(c[/* coercion_type */0]);
      n = ins[1].length;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        n = 0;
      } else {
        throw exn;
      }
    }
    var nc_000 = /* coercion_type */Lib$ReactTemplate.discharge_global(c[/* coercion_type */0]);
    var nc_001 = /* coercion_local */c[/* coercion_local */1];
    var nc_002 = /* coercion_is_id */c[/* coercion_is_id */2];
    var nc_003 = /* coercion_is_proj */c[/* coercion_is_proj */3];
    var nc_004 = /* coercion_source */discharge_cl(c[/* coercion_source */4]);
    var nc_005 = /* coercion_target */discharge_cl(c[/* coercion_target */5]);
    var nc_006 = /* coercion_params */n + c[/* coercion_params */6] | 0;
    var nc = /* record */[
      nc_000,
      nc_001,
      nc_002,
      nc_003,
      nc_004,
      nc_005,
      nc_006
    ];
    return /* Some */[nc];
  }
}

function classify_coercion(obj) {
  if (obj[/* coercion_local */1]) {
    return /* Dispose */0;
  } else {
    return /* Substitute */Block.__(0, [obj]);
  }
}

var init$1 = Libobject$ReactTemplate.default_object("COERCION");

var inCoercion = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$1[/* object_name */0],
      /* cache_function */(function (objn) {
          var env = Global$ReactTemplate.env(/* () */0);
          return cache_coercion(env, Evd$ReactTemplate.empty, objn);
        }),
      /* load_function */load_coercion,
      /* open_function */open_coercion,
      /* classify_function */classify_coercion,
      /* subst_function */subst_coercion,
      /* discharge_function */discharge_coercion,
      /* rebuild_function */init$1[/* rebuild_function */7]
    ]);

function declare_coercion(coef, $staropt$star, isid, cls, clt, ps) {
  var local = $staropt$star ? $staropt$star[0] : /* false */0;
  var isproj;
  isproj = coef.tag === 1 ? Environ$ReactTemplate.is_projection(coef[0], Global$ReactTemplate.env(/* () */0)) : /* false */0;
  var c = /* record */[
    /* coercion_type */coef,
    /* coercion_local */local,
    /* coercion_is_id */isid,
    /* coercion_is_proj */isproj,
    /* coercion_source */cls,
    /* coercion_target */clt,
    /* coercion_params */ps
  ];
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inCoercion, c));
}

function get_coercion_value(v) {
  return v[/* coe_value */0];
}

var pr_cl_index = Bijint_000[/* print */2];

function classes() {
  return dom(class_tab[0]);
}

function coercions() {
  return Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._3(Globnames$ReactTemplate.Refmap_env[/* fold */10], (function (_, y, acc) {
                    return /* :: */[
                            y,
                            acc
                          ];
                  }), coercion_tab[0], /* [] */0));
}

function inheritance_graph$1() {
  return Curry._1(ClPairMap[/* bindings */16], inheritance_graph[0]);
}

function coercion_of_reference(r) {
  var ref = Nametab$ReactTemplate.$$global(r);
  if (!coercion_exists(ref)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["try_add_coercion"], Pp$ReactTemplate.$plus$plus(Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], ref), Pp$ReactTemplate.str(" is not a coercion.")));
  }
  return ref;
}

var compare$1 = Globnames$ReactTemplate.RefOrdered[/* compare */0];

function printer(x) {
  return Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], x);
}

function member_message(x, b) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Explicit printing of coercion "), printer(x)), Pp$ReactTemplate.str(b ? " is set" : " is unset"));
}

var CoercionPrinting_004 = /* key : :: */[
  "Printing",
  /* :: */[
    "Coercion",
    /* [] */0
  ]
];

var CoercionPrinting = /* module */[
  /* compare */compare$1,
  /* encode */coercion_of_reference,
  /* subst */subst_coe_typ,
  /* printer */printer,
  CoercionPrinting_004,
  /* title */"Explicitly printed coercions: ",
  /* member_message */member_message
];

var PrintingCoercion = Goptions$ReactTemplate.MakeRefTable(CoercionPrinting);

function hide_coercion(coe) {
  if (Curry._1(PrintingCoercion[/* active */0], coe)) {
    return /* None */0;
  } else {
    var coe_info = coercion_info(coe);
    return /* Some */[coe_info[/* coe_param */6]];
  }
}

exports.cl_typ_eq = cl_typ_eq;
exports.subst_cl_typ = subst_cl_typ;
exports.cl_typ_ord = cl_typ_ord;
exports.class_exists = class_exists;
exports.class_info = class_info;
exports.class_info_from_index = class_info_from_index;
exports.find_class_type = find_class_type;
exports.class_of = class_of;
exports.inductive_class_of = inductive_class_of;
exports.class_args_of = class_args_of;
exports.declare_coercion = declare_coercion;
exports.coercion_exists = coercion_exists;
exports.coercion_value = coercion_value;
exports.lookup_path_between_class = lookup_path_between_class;
exports.lookup_path_between = lookup_path_between;
exports.lookup_path_to_fun_from = lookup_path_to_fun_from;
exports.lookup_path_to_sort_from = lookup_path_to_sort_from;
exports.lookup_pattern_path_between = lookup_pattern_path_between;
exports.install_path_printer = install_path_printer;
exports.string_of_class = string_of_class;
exports.pr_class = pr_class;
exports.pr_cl_index = pr_cl_index;
exports.get_coercion_value = get_coercion_value;
exports.inheritance_graph = inheritance_graph$1;
exports.classes = classes;
exports.coercions = coercions;
exports.hide_coercion = hide_coercion;
/* ClTypMap Not a pure module */
