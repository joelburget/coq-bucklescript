// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function cons(x, l) {
  if (l) {
    var match = l[2];
    if (match) {
      var h2 = match[0];
      var h1 = l[0];
      if (h1 === h2) {
        return /* Cons */[
                (1 + h1 | 0) + h2 | 0,
                /* Node */Block.__(1, [
                    x,
                    l[1],
                    match[1]
                  ]),
                match[2]
              ];
      } else {
        return /* Cons */[
                1,
                /* Leaf */Block.__(0, [x]),
                l
              ];
      }
    } else {
      return /* Cons */[
              1,
              /* Leaf */Block.__(0, [x]),
              l
            ];
    }
  } else {
    return /* Cons */[
            1,
            /* Leaf */Block.__(0, [x]),
            l
          ];
  }
}

function is_empty(param) {
  if (param) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function get(_l, _i) {
  while(true) {
    var i = _i;
    var l = _l;
    if (l) {
      var h = l[0];
      if (i < h) {
        var _h = h;
        var _t = l[1];
        var _i$1 = i;
        while(true) {
          var i$1 = _i$1;
          var t = _t;
          var h$1 = _h;
          if (t.tag) {
            if (i$1) {
              var h$2 = h$1 / 2 | 0;
              if (i$1 <= h$2) {
                _i$1 = i$1 - 1 | 0;
                _t = t[1];
                _h = h$2;
                continue ;
                
              } else {
                _i$1 = (i$1 - h$2 | 0) - 1 | 0;
                _t = t[2];
                _h = h$2;
                continue ;
                
              }
            } else {
              return t[0];
            }
          } else if (i$1) {
            return Pervasives.invalid_arg("index out of bounds");
          } else {
            return t[0];
          }
        };
      } else {
        _i = i - h | 0;
        _l = l[2];
        continue ;
        
      }
    } else {
      return Pervasives.invalid_arg("index out of bounds");
    }
  };
}

function length(l) {
  var _accu = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[2];
      _accu = param[0] + accu | 0;
      continue ;
      
    } else {
      return accu;
    }
  };
}

function tree_map(f, param) {
  if (param.tag) {
    return /* Node */Block.__(1, [
              Curry._1(f, param[0]),
              tree_map(f, param[1]),
              tree_map(f, param[2])
            ]);
  } else {
    return /* Leaf */Block.__(0, [Curry._1(f, param[0])]);
  }
}

function map(f, param) {
  if (param) {
    return /* Cons */[
            param[0],
            tree_map(f, param[1]),
            map(f, param[2])
          ];
  } else {
    return /* Nil */0;
  }
}

function tree_fold_left(f, _accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param.tag) {
      _param = param[2];
      _accu = tree_fold_left(f, Curry._2(f, accu, param[0]), param[1]);
      continue ;
      
    } else {
      return Curry._2(f, accu, param[0]);
    }
  };
}

function fold_left(f, _accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[2];
      _accu = tree_fold_left(f, accu, param[1]);
      continue ;
      
    } else {
      return accu;
    }
  };
}

function tree_fold_right(f, t, accu) {
  if (t.tag) {
    return Curry._2(f, t[0], tree_fold_right(f, t[1], tree_fold_right(f, t[2], accu)));
  } else {
    return Curry._2(f, t[0], accu);
  }
}

function fold_right(f, l, accu) {
  if (l) {
    return tree_fold_right(f, l[1], fold_right(f, l[2], accu));
  } else {
    return accu;
  }
}

function hd(param) {
  if (param) {
    return param[1][0];
  } else {
    return Pervasives.failwith("hd");
  }
}

function tl(param) {
  if (param) {
    var match = param[1];
    if (match.tag) {
      var h = param[0] / 2 | 0;
      return /* Cons */[
              h,
              match[1],
              /* Cons */[
                h,
                match[2],
                param[2]
              ]
            ];
    } else {
      return param[2];
    }
  } else {
    return Pervasives.failwith("tl");
  }
}

function skipn(_n, _l) {
  while(true) {
    var l = _l;
    var n = _n;
    if (n) {
      if (is_empty(l)) {
        return Pervasives.failwith("List.skipn");
      } else {
        _l = tl(l);
        _n = n - 1 | 0;
        continue ;
        
      }
    } else {
      return l;
    }
  };
}

var empty = /* Nil */0;

exports.empty = empty;
exports.cons = cons;
exports.is_empty = is_empty;
exports.length = length;
exports.map = map;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.hd = hd;
exports.tl = tl;
exports.skipn = skipn;
exports.get = get;
/* No side effect */
