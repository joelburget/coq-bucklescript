// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var EmptyHeap = Caml_exceptions.create("Heap-ReactTemplate.EmptyHeap");

function Functional(funarg) {
  var add = function (x, param) {
    if (param) {
      var r = param[2];
      var y = param[1];
      var l = param[0];
      if (Curry._2(funarg[/* compare */0], x, y) >= 0) {
        return /* Node */[
                add(y, r),
                x,
                l
              ];
      } else {
        return /* Node */[
                add(x, r),
                y,
                l
              ];
      }
    } else {
      return /* Node */[
              /* Leaf */0,
              x,
              /* Leaf */0
            ];
    }
  };
  var extract = function (param) {
    if (param) {
      var l = param[0];
      if (l) {
        var match = extract(l);
        return /* tuple */[
                match[0],
                /* Node */[
                  param[2],
                  param[1],
                  match[1]
                ]
              ];
      } else {
        if (param[2] !== /* Leaf */0) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "heap.ml",
                  80,
                  8
                ]
              ];
        }
        return /* tuple */[
                param[1],
                /* Leaf */0
              ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "heap.ml",
              78,
              8
            ]
          ];
    }
  };
  var is_above = function (x, param) {
    if (param) {
      return +(Curry._2(funarg[/* compare */0], x, param[1]) >= 0);
    } else {
      return /* true */1;
    }
  };
  var replace_min = function (x, param) {
    if (param) {
      var l = param[0];
      var exit = 0;
      var r = param[2];
      if (is_above(x, l) && is_above(x, r)) {
        return /* Node */[
                l,
                x,
                r
              ];
      } else if (l) {
        var r$1 = param[2];
        var lx = l[1];
        if (is_above(lx, r$1)) {
          return /* Node */[
                  replace_min(x, l),
                  lx,
                  r$1
                ];
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var r$2 = param[2];
        if (r$2) {
          return /* Node */[
                  l,
                  r$2[1],
                  replace_min(x, r$2)
                ];
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "heap.ml",
                  100,
                  8
                ]
              ];
        }
      }
      
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "heap.ml",
              100,
              8
            ]
          ];
    }
  };
  var merge = function (l, r) {
    if (r) {
      if (l) {
        var ly = r[1];
        var lx = l[1];
        if (Curry._2(funarg[/* compare */0], lx, ly) >= 0) {
          return /* Node */[
                  r,
                  lx,
                  merge(l[0], l[2])
                ];
        } else {
          var match = extract(l);
          return /* Node */[
                  replace_min(match[0], r),
                  ly,
                  match[1]
                ];
        }
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "heap.ml",
                114,
                8
              ]
            ];
      }
    } else {
      return l;
    }
  };
  var maximum = function (param) {
    if (param) {
      return param[1];
    } else {
      throw EmptyHeap;
    }
  };
  var remove = function (param) {
    if (param) {
      return merge(param[0], param[2]);
    } else {
      throw EmptyHeap;
    }
  };
  var iter = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        iter(f, param[0]);
        Curry._1(f, param[1]);
        _param = param[2];
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  };
  var fold = function (f, _h, _x0) {
    while(true) {
      var x0 = _x0;
      var h = _h;
      if (h) {
        _x0 = fold(f, h[2], Curry._2(f, h[1], x0));
        _h = h[0];
        continue ;
        
      } else {
        return x0;
      }
    };
  };
  return [
          /* Leaf */0,
          add,
          maximum,
          remove,
          iter,
          fold
        ];
}

exports.EmptyHeap = EmptyHeap;
exports.Functional = Functional;
/* No side effect */
