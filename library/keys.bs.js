// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var HMap$ReactTemplate = require("../src/hMap.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Summary$ReactTemplate = require("../src/summary.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("../src/globnames.bs.js");
var Libobject$ReactTemplate = require("../src/libobject.bs.js");

function hash(gr) {
  if (typeof gr === "number") {
    return gr;
  } else {
    return 8 + Globnames$ReactTemplate.RefOrdered[/* hash */2](gr[0]) | 0;
  }
}

function compare(gr1, gr2) {
  var exit = 0;
  if (typeof gr1 === "number") {
    if (typeof gr2 === "number") {
      exit = 1;
    } else {
      return -1;
    }
  } else if (typeof gr2 === "number") {
    exit = 1;
  } else {
    return Globnames$ReactTemplate.RefOrdered[/* compare */0](gr1[0], gr2[0]);
  }
  if (exit === 1) {
    if (typeof gr1 === "number") {
      return Caml_primitive.caml_int_compare(hash(gr1), hash(gr2));
    } else {
      return 1;
    }
  }
  
}

function equal(k1, k2) {
  if (typeof k1 === "number") {
    if (typeof k2 === "number") {
      return +(k1 === k2);
    } else {
      return /* false */0;
    }
  } else if (typeof k2 === "number") {
    return /* false */0;
  } else {
    return Globnames$ReactTemplate.RefOrdered[/* equal */1](k1[0], k2[0]);
  }
}

var Keymap = HMap$ReactTemplate.Make([
      compare,
      hash
    ]);

var keys = Summary$ReactTemplate.ref(/* None */0, "Keys_decl", Keymap[/* empty */0]);

function add_kv(k, v, m) {
  try {
    return Curry._3(Keymap[/* modify */27], k, (function (_, vs) {
                  return Curry._2(Keymap[/* Set */24][/* add */3], v, vs);
                }), m);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Curry._3(Keymap[/* add */3], k, Curry._1(Keymap[/* Set */24][/* singleton */4], v), m);
    } else {
      throw exn;
    }
  }
}

function equiv_keys(k, k$prime) {
  if (k === k$prime) {
    return /* true */1;
  } else if (equal(k, k$prime)) {
    return /* true */1;
  } else {
    try {
      return Curry._2(Keymap[/* Set */24][/* mem */2], k$prime, Curry._2(Keymap[/* find */21], k, keys[0]));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  }
}

function load_keys(_, param) {
  var match = param[1];
  var k = match[0];
  var v = match[1];
  keys[0] = add_kv(k, v, add_kv(v, k, keys[0]));
  return /* () */0;
}

function cache_keys(o) {
  return load_keys(1, o);
}

function subst_key(subst, k) {
  if (typeof k === "number") {
    return k;
  } else {
    return /* KGlob */[Globnames$ReactTemplate.subst_global_reference(subst, k[0])];
  }
}

function subst_keys(param) {
  var match = param[1];
  var subst = param[0];
  return /* tuple */[
          subst_key(subst, match[0]),
          subst_key(subst, match[1])
        ];
}

function discharge_key(x) {
  if (typeof x === "number") {
    return /* Some */[x];
  } else {
    var g = x[0];
    if (Lib$ReactTemplate.is_in_section(g)) {
      if (Globnames$ReactTemplate.isVarRef(g)) {
        return /* None */0;
      } else {
        return /* Some */[/* KGlob */[Globnames$ReactTemplate.pop_global_reference(g)]];
      }
    } else {
      return /* Some */[x];
    }
  }
}

function discharge_keys(param) {
  var match = param[1];
  var match$1 = discharge_key(match[0]);
  var match$2 = discharge_key(match[1]);
  if (match$1 && match$2) {
    return /* Some */[/* tuple */[
              match$1[0],
              match$2[0]
            ]];
  } else {
    return /* None */0;
  }
}

function rebuild_keys(param) {
  return /* tuple */[
          param[0],
          param[1]
        ];
}

var init = Libobject$ReactTemplate.default_object("KEYS");

var inKeys = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_keys,
      /* load_function */load_keys,
      /* open_function */init[/* open_function */3],
      /* classify_function */(function (x) {
          return /* Substitute */Block.__(0, [x]);
        }),
      /* subst_function */subst_keys,
      /* discharge_function */discharge_keys,
      /* rebuild_function */rebuild_keys
    ]);

function declare_equiv_keys(ref, ref$prime) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inKeys, /* tuple */[
                  ref,
                  ref$prime
                ]));
}

function constr_key(kind, c) {
  try {
    var aux = function (_k) {
      while(true) {
        var k = _k;
        var match = Curry._1(kind, k);
        switch (match.tag | 0) {
          case 0 : 
              return /* KRel */7;
          case 1 : 
              return /* KGlob */[/* VarRef */Block.__(0, [match[0]])];
          case 2 : 
          case 3 : 
              throw Caml_builtin_exceptions.not_found;
          case 4 : 
              return /* KSort */3;
          case 6 : 
              return /* KProd */2;
          case 7 : 
              return /* KLam */0;
          case 8 : 
              return /* KLet */1;
          case 5 : 
          case 9 : 
              _k = match[0];
              continue ;
              case 10 : 
              return /* KGlob */[/* ConstRef */Block.__(1, [match[0][0]])];
          case 11 : 
              return /* KGlob */[/* IndRef */Block.__(2, [match[0][0]])];
          case 12 : 
              return /* KGlob */[/* ConstructRef */Block.__(3, [match[0][0]])];
          case 13 : 
              return /* KCase */4;
          case 14 : 
              return /* KFix */5;
          case 15 : 
              return /* KCoFix */6;
          case 16 : 
              return /* KGlob */[/* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](match[0])])];
          
        }
      };
    };
    return /* Some */[aux(c)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function pr_key(pr_global, param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return Pp$ReactTemplate.str("Lambda");
      case 1 : 
          return Pp$ReactTemplate.str("Let");
      case 2 : 
          return Pp$ReactTemplate.str("Product");
      case 3 : 
          return Pp$ReactTemplate.str("Sort");
      case 4 : 
          return Pp$ReactTemplate.str("Case");
      case 5 : 
          return Pp$ReactTemplate.str("Fix");
      case 6 : 
          return Pp$ReactTemplate.str("CoFix");
      case 7 : 
          return Pp$ReactTemplate.str("Rel");
      
    }
  } else {
    return Curry._1(pr_global, param[0]);
  }
}

function pr_keyset(pr_global, v) {
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                return pr_key(pr_global, param);
              }), Curry._1(Keymap[/* Set */24][/* elements */19], v));
}

function pr_mapping(pr_global, k, v) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_key(pr_global, k), Pp$ReactTemplate.str(" <-> ")), pr_keyset(pr_global, v));
}

function pr_keys(pr_global) {
  return Curry._3(Keymap[/* fold */10], (function (k, v, acc) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_mapping(pr_global, k, v), Pp$ReactTemplate.fnl(/* () */0)), acc);
              }), keys[0], Pp$ReactTemplate.mt(/* () */0));
}

exports.declare_equiv_keys = declare_equiv_keys;
exports.equiv_keys = equiv_keys;
exports.constr_key = constr_key;
exports.pr_keys = pr_keys;
/* Keymap Not a pure module */
