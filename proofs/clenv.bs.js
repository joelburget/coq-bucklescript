// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Goal$ReactTemplate = require("../src/goal.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var Tacred$ReactTemplate = require("../src/tacred.bs.js");
var Typing$ReactTemplate = require("../src/typing.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Tacmach$ReactTemplate = require("./tacmach.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Coercion$ReactTemplate = require("../src/coercion.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Retyping$ReactTemplate = require("../src/retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Proofview$ReactTemplate = require("../src/proofview.bs.js");
var Typeclasses$ReactTemplate = require("../src/typeclasses.bs.js");
var Unification$ReactTemplate = require("../pretyping/unification.bs.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("../src/pretype_errors.bs.js");

function clenv_nf_meta(clenv, c) {
  return Reductionops$ReactTemplate.nf_meta(clenv[/* evd */1], c);
}

function clenv_meta_type(clenv, mv) {
  return Typing$ReactTemplate.meta_type(clenv[/* evd */1], mv);
}

function clenv_value(clenv) {
  return Reductionops$ReactTemplate.meta_instance(clenv[/* evd */1], clenv[/* templval */2]);
}

function clenv_type(clenv) {
  return Reductionops$ReactTemplate.meta_instance(clenv[/* evd */1], clenv[/* templtyp */3]);
}

function refresh_undefined_univs(clenv) {
  var match = EConstr$ReactTemplate.kind(clenv[/* evd */1], clenv[/* templval */2][/* rebus */0]);
  var exit = 0;
  switch (match.tag | 0) {
    case 1 : 
        return /* tuple */[
                clenv,
                Univ$ReactTemplate.empty_level_subst
              ];
    case 9 : 
        if (EConstr$ReactTemplate.isVar(clenv[/* evd */1], match[0])) {
          return /* tuple */[
                  clenv,
                  Univ$ReactTemplate.empty_level_subst
                ];
        } else {
          exit = 1;
        }
        break;
    default:
      exit = 1;
  }
  if (exit === 1) {
    var match$1 = Evd$ReactTemplate.refresh_undefined_universes(clenv[/* evd */1]);
    var subst = match$1[1];
    var map_freelisted = function (f) {
      return /* record */[
              /* rebus */EConstr$ReactTemplate.Vars[/* subst_univs_level_constr */16](subst, f[/* rebus */0]),
              /* freemetas */f[/* freemetas */1]
            ];
    };
    return /* tuple */[
            /* record */[
              /* env */clenv[/* env */0],
              /* evd */match$1[0],
              /* templval */map_freelisted(clenv[/* templval */2]),
              /* templtyp */map_freelisted(clenv[/* templtyp */3])
            ],
            subst
          ];
  }
  
}

function clenv_hnf_constr(ce, t) {
  return Tacred$ReactTemplate.hnf_constr(ce[/* env */0], ce[/* evd */1], t);
}

function clenv_get_type_of(ce, c) {
  return Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, ce[/* env */0], ce[/* evd */1], c);
}

var NotExtensibleClause = Caml_exceptions.create("Clenv-ReactTemplate.NotExtensibleClause");

function mk_freelisted(c) {
  return Evd$ReactTemplate.map_fl(EConstr$ReactTemplate.of_constr, Evd$ReactTemplate.mk_freelisted(EConstr$ReactTemplate.Unsafe[/* to_constr */0](c)));
}

function clenv_push_prod(cl) {
  var typ = Reductionops$ReactTemplate.whd_all(cl[/* env */0])(cl[/* evd */1], clenv_type(cl));
  var _typ = typ;
  while(true) {
    var typ$1 = _typ;
    var match = EConstr$ReactTemplate.kind(cl[/* evd */1], typ$1);
    switch (match.tag | 0) {
      case 5 : 
          _typ = match[0];
          continue ;
          case 6 : 
          var u = match[2];
          var mv = Evarutil$ReactTemplate.new_meta(/* () */0);
          var dep = 1 - EConstr$ReactTemplate.Vars[/* noccurn */12](cl[/* evd */1], 1, u);
          var na$prime = dep ? match[0] : /* Anonymous */0;
          var e$prime = Evd$ReactTemplate.meta_declare(mv, EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[1]), /* Some */[na$prime], cl[/* evd */1]);
          var concl = dep ? EConstr$ReactTemplate.Vars[/* subst1 */4](EConstr$ReactTemplate.mkMeta(mv), u) : u;
          var def = EConstr$ReactTemplate.applist(/* tuple */[
                cl[/* templval */2][/* rebus */0],
                /* :: */[
                  EConstr$ReactTemplate.mkMeta(mv),
                  /* [] */0
                ]
              ]);
          return /* record */[
                  /* env */cl[/* env */0],
                  /* evd */e$prime,
                  /* templval */mk_freelisted(def),
                  /* templtyp */mk_freelisted(concl)
                ];
      default:
        throw NotExtensibleClause;
    }
  };
}

function clenv_environments(evd, bound, t) {
  var _param = /* tuple */[
    evd,
    /* [] */0
  ];
  var _n = bound;
  var _t = t;
  while(true) {
    var param = _param;
    var t$1 = _t;
    var n = _n;
    var metas = param[1];
    var e = param[0];
    var match = EConstr$ReactTemplate.kind(evd, t$1);
    var exit = 0;
    if (n) {
      if (n[0] !== 0) {
        exit = 1;
      } else {
        return /* tuple */[
                e,
                Curry._1(Util$ReactTemplate.List[/* rev */4], metas),
                t$1
              ];
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      switch (match.tag | 0) {
        case 5 : 
            _t = match[0];
            _param = /* tuple */[
              e,
              metas
            ];
            continue ;
            case 6 : 
            var t2 = match[2];
            var mv = Evarutil$ReactTemplate.new_meta(/* () */0);
            var dep = 1 - EConstr$ReactTemplate.Vars[/* noccurn */12](evd, 1, t2);
            var na$prime = dep ? match[0] : /* Anonymous */0;
            var t1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[1]);
            var e$prime = Evd$ReactTemplate.meta_declare(mv, t1, /* Some */[na$prime], e);
            _t = dep ? EConstr$ReactTemplate.Vars[/* subst1 */4](EConstr$ReactTemplate.mkMeta(mv), t2) : t2;
            _n = Option$ReactTemplate.map((function (param) {
                    return -1 + param | 0;
                  }), n);
            _param = /* tuple */[
              e$prime,
              /* :: */[
                EConstr$ReactTemplate.mkMeta(mv),
                metas
              ]
            ];
            continue ;
            case 8 : 
            _t = EConstr$ReactTemplate.Vars[/* subst1 */4](match[1], match[3]);
            _param = /* tuple */[
              e,
              metas
            ];
            continue ;
            default:
          return /* tuple */[
                  e,
                  Curry._1(Util$ReactTemplate.List[/* rev */4], metas),
                  t$1
                ];
      }
    }
    
  };
}

function mk_clenv_from_env(env, sigma, n, param) {
  var evd = Evd$ReactTemplate.clear_metas(sigma);
  var match = clenv_environments(evd, n, param[1]);
  return /* record */[
          /* env */env,
          /* evd */match[0],
          /* templval */mk_freelisted(EConstr$ReactTemplate.applist(/* tuple */[
                    param[0],
                    match[1]
                  ])),
          /* templtyp */mk_freelisted(match[2])
        ];
}

function mk_clenv_from_n(gls, n, param) {
  var env = Proofview$ReactTemplate.Goal[/* env */4](gls);
  var sigma = Tacmach$ReactTemplate.New[/* project */3](gls);
  return mk_clenv_from_env(env, sigma, n, /* tuple */[
              param[0],
              param[1]
            ]);
}

function mk_clenv_from(gls) {
  return (function (param) {
      return mk_clenv_from_n(gls, /* None */0, param);
    });
}

function mk_clenv_type_of(gls, t) {
  return mk_clenv_from_n(gls, /* None */0, /* tuple */[
              t,
              Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gls, t)
            ]);
}

function mentions(clenv, mv0) {
  var menrec = function (mv1) {
    if (mv0 === mv1) {
      return /* true */1;
    } else {
      var mlist;
      try {
        var match = Evd$ReactTemplate.meta_opt_fvalue(clenv[/* evd */1], mv1);
        mlist = match ? match[0][0][/* freemetas */1] : Evd$ReactTemplate.Metaset[/* empty */0];
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          mlist = Evd$ReactTemplate.Metaset[/* empty */0];
        } else {
          throw exn;
        }
      }
      return Curry._2(Evd$ReactTemplate.Metaset[/* exists */15], menrec, mlist);
    }
  };
  return menrec;
}

function clenv_assign(mv, rhs, clenv) {
  var rhs_fls = mk_freelisted(rhs);
  if (Curry._2(Evd$ReactTemplate.Metaset[/* exists */15], mentions(clenv, mv), rhs_fls[/* freemetas */1])) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("clenv_assign: circularity in unification"));
  }
  try {
    if (Evd$ReactTemplate.meta_defined(clenv[/* evd */1], mv)) {
      if (EConstr$ReactTemplate.eq_constr(clenv[/* evd */1], EConstr$ReactTemplate.of_constr(Evd$ReactTemplate.meta_fvalue(clenv[/* evd */1], mv)[0][/* rebus */0]), rhs)) {
        return clenv;
      } else {
        var clenv$1 = clenv;
        var mv$1 = mv;
        var na = Evd$ReactTemplate.meta_name(clenv$1[/* evd */1], mv$1);
        if (na) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["clenv_assign"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("An incompatible instantiation has already been found for "), Names$ReactTemplate.Id[/* print */8](na[0])));
        } else {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["clenv_assign"], Pp$ReactTemplate.str("non dependent metavar already assigned."));
        }
      }
    } else {
      return /* record */[
              /* env */clenv[/* env */0],
              /* evd */Evd$ReactTemplate.meta_assign(mv, /* tuple */[
                    EConstr$ReactTemplate.Unsafe[/* to_constr */0](rhs_fls[/* rebus */0]),
                    /* tuple */[
                      /* Conv */2,
                      /* TypeNotProcessed */1
                    ]
                  ], clenv[/* evd */1]),
              /* templval */clenv[/* templval */2],
              /* templtyp */clenv[/* templtyp */3]
            ];
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("clenv_assign: undefined meta"));
    } else {
      throw exn;
    }
  }
}

function clenv_metas_in_type_of_meta(evd, mv) {
  return mk_freelisted(Reductionops$ReactTemplate.meta_instance(evd, Evd$ReactTemplate.map_fl(EConstr$ReactTemplate.of_constr, Evd$ReactTemplate.meta_ftype(evd, mv))))[/* freemetas */1];
}

function dependent_in_type_of_metas(clenv, mvs) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (mv) {
                return Curry._1(Evd$ReactTemplate.Metaset[/* union */6], clenv_metas_in_type_of_meta(clenv[/* evd */1], mv));
              }), mvs, Evd$ReactTemplate.Metaset[/* empty */0]);
}

function dependent_closure(clenv, mvs) {
  var aux = function (mvs, acc) {
    return Curry._3(Evd$ReactTemplate.Metaset[/* fold */13], (function (mv, deps) {
                  var metas_of_meta_type = clenv_metas_in_type_of_meta(clenv[/* evd */1], mv);
                  return aux(metas_of_meta_type, Curry._2(Evd$ReactTemplate.Metaset[/* union */6], deps, metas_of_meta_type));
                }), mvs, acc);
  };
  return aux(mvs, mvs);
}

function clenv_dependent_gen(hyps_only, $staropt$star, clenv) {
  var iter = $staropt$star ? $staropt$star[0] : /* true */1;
  var all_undefined = Evd$ReactTemplate.undefined_metas(clenv[/* evd */1]);
  var deps_in_concl = mk_freelisted(clenv_type(clenv))[/* freemetas */1];
  var deps_in_hyps = dependent_in_type_of_metas(clenv, all_undefined);
  var deps_in_concl$1 = hyps_only && iter ? dependent_closure(clenv, deps_in_concl) : deps_in_concl;
  return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (mv) {
                if (hyps_only) {
                  if (Curry._2(Evd$ReactTemplate.Metaset[/* mem */2], mv, deps_in_hyps)) {
                    return 1 - Curry._2(Evd$ReactTemplate.Metaset[/* mem */2], mv, deps_in_concl$1);
                  } else {
                    return /* false */0;
                  }
                } else if (Curry._2(Evd$ReactTemplate.Metaset[/* mem */2], mv, deps_in_hyps)) {
                  return /* true */1;
                } else {
                  return Curry._2(Evd$ReactTemplate.Metaset[/* mem */2], mv, deps_in_concl$1);
                }
              }), all_undefined);
}

function clenv_missing(ce) {
  return clenv_dependent_gen(/* true */1, /* None */0, ce);
}

function clenv_dependent(ce) {
  return clenv_dependent_gen(/* false */0, /* None */0, ce);
}

function clenv_unify($staropt$star, cv_pb, t1, t2, clenv) {
  var flags = $staropt$star ? $staropt$star[0] : Unification$ReactTemplate.default_unify_flags(/* () */0);
  return /* record */[
          /* env */clenv[/* env */0],
          /* evd */Unification$ReactTemplate.w_unify(clenv[/* env */0], clenv[/* evd */1], cv_pb, /* Some */[flags], t1, t2),
          /* templval */clenv[/* templval */2],
          /* templtyp */clenv[/* templtyp */3]
        ];
}

function clenv_unify_meta_types($staropt$star, clenv) {
  var flags = $staropt$star ? $staropt$star[0] : Unification$ReactTemplate.default_unify_flags(/* () */0);
  return /* record */[
          /* env */clenv[/* env */0],
          /* evd */Unification$ReactTemplate.w_unify_meta_types(clenv[/* env */0], /* Some */[flags], clenv[/* evd */1]),
          /* templval */clenv[/* templval */2],
          /* templtyp */clenv[/* templtyp */3]
        ];
}

function clenv_unique_resolver_gen($staropt$star, clenv, concl) {
  var flags = $staropt$star ? $staropt$star[0] : Unification$ReactTemplate.default_unify_flags(/* () */0);
  if (EConstr$ReactTemplate.isMeta(clenv[/* evd */1], Termops$ReactTemplate.decompose_app_vect(clenv[/* evd */1], Reductionops$ReactTemplate.whd_nored(clenv[/* evd */1], clenv[/* templtyp */3][/* rebus */0]))[0])) {
    return clenv_unify(/* Some */[flags], /* CUMUL */1, clenv_type(clenv), concl, clenv_unify_meta_types(/* Some */[flags], clenv));
  } else {
    return clenv_unify(/* Some */[flags], /* CUMUL */1, Reductionops$ReactTemplate.meta_reducible_instance(clenv[/* evd */1], clenv[/* templtyp */3]), concl, clenv);
  }
}

function old_clenv_unique_resolver(flags, clenv, gl) {
  var concl = Goal$ReactTemplate.V82[/* concl */3](clenv[/* evd */1], Evd$ReactTemplate.sig_it(gl));
  return clenv_unique_resolver_gen(flags, clenv, concl);
}

function clenv_unique_resolver(flags, clenv, gl) {
  var concl = Proofview$ReactTemplate.Goal[/* concl */2](gl);
  return clenv_unique_resolver_gen(flags, clenv, concl);
}

function adjust_meta_source(evd, mv, src) {
  var match = src[1];
  if (typeof match === "number") {
    return src;
  } else if (match.tag === 7) {
    var f = function (param) {
      var match = param[1];
      var exit = 0;
      var t;
      if (match.tag) {
        t = match[2];
        exit = 1;
      } else {
        t = match[1];
        exit = 1;
      }
      if (exit === 1) {
        if (Curry._2(Evd$ReactTemplate.Metaset[/* mem */2], mv, t[/* freemetas */1])) {
          var match$1 = EConstr$ReactTemplate.decompose_app(evd, EConstr$ReactTemplate.of_constr(t[/* rebus */0]));
          var match$2 = EConstr$ReactTemplate.kind(evd, match$1[0]);
          if (match$2.tag === 2) {
            var match$3 = Evd$ReactTemplate.meta_opt_fvalue(evd, match$2[0]);
            if (match$3) {
              var _c = EConstr$ReactTemplate.of_constr(match$3[0][0][/* rebus */0]);
              var _l = match$1[1];
              while(true) {
                var l = _l;
                var c = _c;
                var match$4 = EConstr$ReactTemplate.kind(evd, c);
                if (match$4.tag === 7) {
                  var match$5 = match$4[0];
                  var exit$1 = 0;
                  if (match$5) {
                    if (l) {
                      if (EConstr$ReactTemplate.eq_constr(evd, l[0], EConstr$ReactTemplate.mkMeta(mv))) {
                        return /* Some */[match$5[0]];
                      } else {
                        exit$1 = 1;
                      }
                    } else {
                      return /* None */0;
                    }
                  } else {
                    exit$1 = 1;
                  }
                  if (exit$1 === 1) {
                    if (l) {
                      _l = l[1];
                      _c = match$4[2];
                      continue ;
                      
                    } else {
                      return /* None */0;
                    }
                  }
                  
                } else {
                  return /* None */0;
                }
              };
            } else {
              return /* None */0;
            }
          } else {
            return /* None */0;
          }
        } else {
          return /* None */0;
        }
      }
      
    };
    var id;
    try {
      id = Curry._2(Util$ReactTemplate.List[/* find_map */94], f, Evd$ReactTemplate.meta_list(evd));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        id = match[0];
      } else {
        throw exn;
      }
    }
    return /* tuple */[
            src[0],
            /* VarInstance */Block.__(7, [id])
          ];
  } else {
    return src;
  }
}

function clenv_pose_metas_as_evars(clenv, dep_mvs) {
  var _clenv = clenv;
  var _param = dep_mvs;
  while(true) {
    var param = _param;
    var clenv$1 = _clenv;
    if (param) {
      var mvs = param[1];
      var mv = param[0];
      var ty = Typing$ReactTemplate.meta_type(clenv$1[/* evd */1], mv);
      if (Termops$ReactTemplate.occur_meta(clenv$1[/* evd */1], ty)) {
        _param = Util$ReactTemplate.$at(mvs, /* :: */[
              mv,
              /* [] */0
            ]);
        continue ;
        
      } else {
        var src = Evd$ReactTemplate.evar_source_of_meta(mv, clenv$1[/* evd */1]);
        var src$1 = adjust_meta_source(clenv$1[/* evd */1], mv, src);
        var evd = clenv$1[/* evd */1];
        var match = Evarutil$ReactTemplate.new_evar(clenv$1[/* env */0], evd, /* Some */[src$1], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, ty);
        var clenv$2 = clenv_assign(mv, match[1], /* record */[
              /* env */clenv$1[/* env */0],
              /* evd */match[0],
              /* templval */clenv$1[/* templval */2],
              /* templtyp */clenv$1[/* templtyp */3]
            ]);
        _param = mvs;
        _clenv = clenv$2;
        continue ;
        
      }
    } else {
      return clenv$1;
    }
  };
}

function fchain_flags() {
  var init = Unification$ReactTemplate.default_unify_flags(/* () */0);
  return /* record */[
          /* core_unify_flags */init[/* core_unify_flags */0],
          /* merge_unify_flags */init[/* merge_unify_flags */1],
          /* subterm_unify_flags */init[/* subterm_unify_flags */2],
          /* allow_K_in_toplevel_higher_order_unification : true */1,
          /* resolve_evars */init[/* resolve_evars */4]
        ];
}

function clenv_fchain(with_univs, $staropt$star, mv, clenv, nextclenv) {
  var flags = $staropt$star ? $staropt$star[0] : fchain_flags(/* () */0);
  var clenv$prime_000 = /* env */nextclenv[/* env */0];
  var clenv$prime_001 = /* evd */Evd$ReactTemplate.meta_merge(with_univs, nextclenv[/* evd */1], clenv[/* evd */1]);
  var clenv$prime_002 = /* templval */clenv[/* templval */2];
  var clenv$prime_003 = /* templtyp */clenv[/* templtyp */3];
  var clenv$prime = /* record */[
    clenv$prime_000,
    clenv$prime_001,
    clenv$prime_002,
    clenv$prime_003
  ];
  var clenv$prime$prime = clenv_unify(/* Some */[flags], /* CUMUL */1, Reductionops$ReactTemplate.meta_instance(clenv$prime_001, nextclenv[/* templtyp */3]), Typing$ReactTemplate.meta_type(clenv$prime_001, mv), clenv$prime);
  return clenv_assign(mv, Reductionops$ReactTemplate.meta_instance(clenv$prime_001, nextclenv[/* templval */2]), clenv$prime$prime);
}

function clenv_independent(clenv) {
  var mvs = Termops$ReactTemplate.collect_metas(clenv[/* evd */1], clenv_value(clenv));
  var ctyp_mvs = mk_freelisted(clenv_type(clenv))[/* freemetas */1];
  var deps = Curry._2(Evd$ReactTemplate.Metaset[/* union */6], dependent_in_type_of_metas(clenv, mvs), ctyp_mvs);
  return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (mv) {
                return 1 - Curry._2(Evd$ReactTemplate.Metaset[/* mem */2], mv, deps);
              }), mvs);
}

function qhyp_eq(h1, h2) {
  if (h1.tag) {
    if (h2.tag) {
      return Names$ReactTemplate.Id[/* equal */0](h1[0], h2[0]);
    } else {
      return /* false */0;
    }
  } else if (h2.tag) {
    return /* false */0;
  } else {
    return +(h1[0] === h2[0]);
  }
}

function check_bindings(bl) {
  var match = Curry._2(Util$ReactTemplate.List[/* duplicates */60], qhyp_eq, Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return param[/* v */0][0];
            }), bl));
  if (match) {
    var match$1 = match[0];
    if (match$1.tag) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The variable "), Names$ReactTemplate.Id[/* print */8](match$1[0])), Pp$ReactTemplate.str(" occurs more than once in binding list.")));
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The position "), Pp$ReactTemplate.$$int(match$1[0])), Pp$ReactTemplate.str(" occurs more than once in binding list.")));
    }
  } else {
    return /* () */0;
  }
}

function meta_of_binder(clause, _, mvs, param) {
  if (param.tag) {
    var evd = clause[/* evd */1];
    var id = param[0];
    var na = /* Name */[id];
    var fold = function (l, param) {
      var clb = param[1];
      var n = param[0];
      var l2 = l[1];
      var l1 = l[0];
      var match;
      match = clb.tag ? /* tuple */[
          clb[0],
          /* true */1
        ] : /* tuple */[
          clb[0],
          /* false */0
        ];
      if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], na, match[0])) {
        if (match[1]) {
          return /* tuple */[
                  /* :: */[
                    n,
                    l1
                  ],
                  l2
                ];
        } else {
          return /* tuple */[
                  /* :: */[
                    n,
                    l1
                  ],
                  /* :: */[
                    n,
                    l2
                  ]
                ];
        }
      } else {
        return l;
      }
    };
    var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, /* tuple */[
          /* [] */0,
          /* [] */0
        ], Evd$ReactTemplate.meta_list(evd));
    var mvnodef = match[1];
    var mvl = match[0];
    var exit = 0;
    if (mvl) {
      if (mvnodef) {
        if (mvnodef[1]) {
          exit = 1;
        } else {
          return mvnodef[0];
        }
      } else {
        exit = 1;
      }
    } else {
      var evd$1 = evd;
      var id$1 = id;
      var fold$1 = function (l, param) {
        var na = param[1][0];
        if (na !== /* Anonymous */0) {
          return /* :: */[
                  Nameops$ReactTemplate.Name[/* get_id */15](na),
                  l
                ];
        } else {
          return l;
        }
      };
      var mvl$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold$1, /* [] */0, Evd$ReactTemplate.meta_list(evd$1));
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Evd.meta_with_name"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such bound variable "), Names$ReactTemplate.Id[/* print */8](id$1)), mvl$1 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" (possible name"), Pp$ReactTemplate.str(Curry._1(Util$ReactTemplate.List[/* length */0], mvl$1) === 1 ? " is: " : "s are: ")), Pp$ReactTemplate.pr_enum(Names$ReactTemplate.Id[/* print */8], mvl$1)), Pp$ReactTemplate.str(").")) : Pp$ReactTemplate.str(" (no bound variables at all in the expression).")));
    }
    if (exit === 1) {
      if (mvl[1]) {
        return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Evd.meta_with_name"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Binder name \""), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.strbrk("\" occurs more than once in clause.")));
      } else {
        return mvl[0];
      }
    }
    
  } else {
    try {
      return Curry._2(Util$ReactTemplate.List[/* nth */3], mvs, param[0] - 1 | 0);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such binder."));
      } else if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such binder."));
      } else {
        throw exn;
      }
    }
  }
}

function clenv_unify_binding_type(clenv, c, t, u) {
  if (EConstr$ReactTemplate.isMeta(clenv[/* evd */1], Termops$ReactTemplate.decompose_app_vect(clenv[/* evd */1], Reductionops$ReactTemplate.whd_nored(clenv[/* evd */1], u))[0])) {
    return /* tuple */[
            /* CoerceToType */0,
            clenv,
            c
          ];
  } else {
    try {
      var match = Unification$ReactTemplate.w_coerce_to_type(clenv[/* env */0], clenv[/* evd */1], c, t, u);
      return /* tuple */[
              /* TypeProcessed */2,
              /* record */[
                /* env */clenv[/* env */0],
                /* evd */match[0],
                /* templval */clenv[/* templval */2],
                /* templtyp */clenv[/* templtyp */3]
              ],
              match[1]
            ];
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      var exit = 0;
      if (e[0] === Pretype_errors$ReactTemplate.PretypeError) {
        var match$1 = e[3];
        if (match$1.tag === 1) {
          var tmp = match$1[2];
          if (typeof tmp === "number") {
            exit = 1;
          } else {
            switch (tmp.tag | 0) {
              case 1 : 
              case 2 : 
                  throw e;
              default:
                exit = 1;
            }
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (Pretype_errors$ReactTemplate.precatchable_exception(e)) {
          return /* tuple */[
                  /* TypeNotProcessed */1,
                  clenv,
                  c
                ];
        } else {
          throw e;
        }
      }
      
    }
  }
}

function clenv_assign_binding(clenv, k, c) {
  var k_typ = clenv_hnf_constr(clenv, Typing$ReactTemplate.meta_type(clenv[/* evd */1], k));
  var c_typ = Reductionops$ReactTemplate.nf_betaiota(clenv[/* env */0], clenv[/* evd */1], clenv_get_type_of(clenv, c));
  var match = clenv_unify_binding_type(clenv, c, c_typ, k_typ);
  var clenv$prime = match[1];
  var c$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[2]);
  return /* record */[
          /* env */clenv$prime[/* env */0],
          /* evd */Evd$ReactTemplate.meta_assign(k, /* tuple */[
                c$1,
                /* tuple */[
                  /* Conv */2,
                  match[0]
                ]
              ], clenv$prime[/* evd */1]),
          /* templval */clenv$prime[/* templval */2],
          /* templtyp */clenv$prime[/* templtyp */3]
        ];
}

var NoSuchBinding = Caml_exceptions.create("Clenv-ReactTemplate.NoSuchBinding");

function clenv_constrain_last_binding(c, clenv) {
  var all_mvs = Termops$ReactTemplate.collect_metas(clenv[/* evd */1], clenv[/* templval */2][/* rebus */0]);
  var k;
  try {
    k = Curry._1(Util$ReactTemplate.List[/* last */105], all_mvs);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      throw NoSuchBinding;
    } else {
      throw exn;
    }
  }
  return clenv_assign_binding(clenv, k, c);
}

function error_not_right_number_missing_arguments(n) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Not the right number of missing arguments (expected "), Pp$ReactTemplate.$$int(n)), Pp$ReactTemplate.str(").")));
}

function make_clenv_binding_gen(hyps_only, n, env, sigma, param, param$1) {
  var t = param[1];
  var c = param[0];
  if (typeof param$1 === "number") {
    return mk_clenv_from_env(env, sigma, n, /* tuple */[
                c,
                t
              ]);
  } else if (param$1.tag) {
    var t$1 = Namegen$ReactTemplate.rename_bound_vars_as_displayed(sigma, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* [] */0, t);
    var clause = mk_clenv_from_env(env, sigma, n, /* tuple */[
          c,
          t$1
        ]);
    var bl = param$1[0];
    var clenv = clause;
    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], bl)) {
      return clenv;
    } else {
      var mvs = clenv_independent(clenv);
      check_bindings(bl);
      return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (clenv, param) {
                    var match = param[/* v */0];
                    var c = match[1];
                    var b = match[0];
                    var k = meta_of_binder(clenv, param[/* loc */1], mvs, b);
                    if (Evd$ReactTemplate.meta_defined(clenv[/* evd */1], k)) {
                      if (EConstr$ReactTemplate.eq_constr(clenv[/* evd */1], EConstr$ReactTemplate.of_constr(Evd$ReactTemplate.meta_fvalue(clenv[/* evd */1], k)[0][/* rebus */0]), c)) {
                        return clenv;
                      } else {
                        var b$1 = b;
                        if (b$1.tag) {
                          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Binder name \""), Names$ReactTemplate.Id[/* print */8](b$1[0])), Pp$ReactTemplate.str("\" already defined with incompatible value.")));
                        } else {
                          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Position "), Pp$ReactTemplate.$$int(b$1[0])), Pp$ReactTemplate.str(" already defined.")));
                        }
                      }
                    } else {
                      return clenv_assign_binding(clenv, k, c);
                    }
                  }), clenv, bl);
    }
  } else {
    var clause$1 = mk_clenv_from_env(env, sigma, n, /* tuple */[
          c,
          t
        ]);
    var hyps_only$1 = hyps_only;
    var bl$1 = param$1[0];
    var clenv$1 = clause$1;
    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], bl$1)) {
      return clenv$1;
    } else {
      var occlist = clenv_dependent_gen(hyps_only$1, /* None */0, clenv$1);
      if (Curry._1(Util$ReactTemplate.List[/* length */0], occlist) === Curry._1(Util$ReactTemplate.List[/* length */0], bl$1)) {
        return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], clenv_assign_binding, clenv$1, occlist, bl$1);
      } else if (hyps_only$1) {
        var occlist$prime = clenv_dependent_gen(hyps_only$1, /* Some */[/* false */0], clenv$1);
        if (Curry._1(Util$ReactTemplate.List[/* length */0], occlist$prime) === Curry._1(Util$ReactTemplate.List[/* length */0], bl$1)) {
          return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], clenv_assign_binding, clenv$1, occlist$prime, bl$1);
        } else {
          return error_not_right_number_missing_arguments(Curry._1(Util$ReactTemplate.List[/* length */0], occlist));
        }
      } else {
        return error_not_right_number_missing_arguments(Curry._1(Util$ReactTemplate.List[/* length */0], occlist));
      }
    }
  }
}

function make_clenv_binding_env_apply(env, sigma, n) {
  return (function (param, param$1) {
      return make_clenv_binding_gen(/* true */1, n, env, sigma, param, param$1);
    });
}

function make_clenv_binding_env(env, sigma) {
  return (function (param, param$1) {
      return make_clenv_binding_gen(/* false */0, /* None */0, env, sigma, param, param$1);
    });
}

function make_clenv_binding_apply(env, sigma, n) {
  return (function (param, param$1) {
      return make_clenv_binding_gen(/* true */1, n, env, sigma, param, param$1);
    });
}

function make_clenv_binding(env, sigma) {
  return (function (param, param$1) {
      return make_clenv_binding_gen(/* false */0, /* None */0, env, sigma, param, param$1);
    });
}

function pr_clenv(clenv) {
  return Pp$ReactTemplate.h(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("TEMPL: "), Termops$ReactTemplate.print_constr(clenv[/* templval */2][/* rebus */0])), Pp$ReactTemplate.str(" : ")), Termops$ReactTemplate.print_constr(clenv[/* templtyp */3][/* rebus */0])), Pp$ReactTemplate.fnl(/* () */0)), Termops$ReactTemplate.pr_evar_map(/* None */0, /* Some */[2], clenv[/* evd */1])));
}

function make_evar_clause(env, sigma, len, t) {
  var bound;
  if (len) {
    var n = len[0];
    if (0 > n) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "clenv.ml",
              607,
              14
            ]
          ];
    }
    bound = n;
  } else {
    bound = -1;
  }
  var t$1 = Namegen$ReactTemplate.rename_bound_vars_as_displayed(sigma, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* [] */0, t);
  var clrec = function (_param, _n, _t) {
    while(true) {
      var param = _param;
      var t = _t;
      var n = _n;
      var holes = param[1];
      var sigma = param[0];
      if (n) {
        var match = EConstr$ReactTemplate.kind(sigma, t);
        switch (match.tag | 0) {
          case 5 : 
              _t = match[0];
              _param = /* tuple */[
                sigma,
                holes
              ];
              continue ;
              case 6 : 
              var t2 = match[2];
              var t1 = match[1];
              var store = Typeclasses$ReactTemplate.set_resolvable(Evd$ReactTemplate.Store[/* empty */0], /* false */0);
              var match$1 = Evarutil$ReactTemplate.new_evar(env, sigma, /* None */0, /* None */0, /* None */0, /* Some */[store], /* None */0, /* None */0, t1);
              var ev = match$1[1];
              var sigma$1 = match$1[0];
              var dep = 1 - EConstr$ReactTemplate.Vars[/* noccurn */12](sigma$1, 1, t2);
              var hole_003 = /* hole_name */match[0];
              var hole = /* record */[
                /* hole_evar */ev,
                /* hole_type */t1,
                /* hole_deps */dep,
                hole_003
              ];
              var t2$1 = dep ? EConstr$ReactTemplate.Vars[/* subst1 */4](ev, t2) : t2;
              _t = t2$1;
              _n = n - 1 | 0;
              _param = /* tuple */[
                sigma$1,
                /* :: */[
                  hole,
                  holes
                ]
              ];
              continue ;
              case 8 : 
              _t = EConstr$ReactTemplate.Vars[/* subst1 */4](match[1], match[3]);
              _param = /* tuple */[
                sigma,
                holes
              ];
              continue ;
              default:
            return /* tuple */[
                    sigma,
                    holes,
                    t
                  ];
        }
      } else {
        return /* tuple */[
                sigma,
                holes,
                t
              ];
      }
    };
  };
  var match = clrec(/* tuple */[
        sigma,
        /* [] */0
      ], bound, t$1);
  var holes = Curry._1(Util$ReactTemplate.List[/* rev */4], match[1]);
  var clause_001 = /* cl_concl */match[2];
  var clause = /* record */[
    /* cl_holes */holes,
    clause_001
  ];
  return /* tuple */[
          match[0],
          clause
        ];
}

function evar_of_binder(holes, param) {
  if (param.tag) {
    var holes$1 = holes;
    var id = param[0];
    var map = function (h) {
      var match = h[/* hole_name */3];
      if (match && Names$ReactTemplate.Id[/* equal */0](id, match[0])) {
        return /* Some */[h];
      } else {
        return /* None */0;
      }
    };
    var hole = Curry._2(Util$ReactTemplate.List[/* map_filter */62], map, holes$1);
    if (hole) {
      if (hole[1]) {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Binder name \""), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str("\" occurs more than once in clause.")));
      } else {
        return hole[0][/* hole_evar */0];
      }
    } else {
      var holes$2 = holes$1;
      var id$1 = id;
      var fold = function (h, accu) {
        var match = h[/* hole_name */3];
        if (match) {
          return /* :: */[
                  match[0],
                  accu
                ];
        } else {
          return accu;
        }
      };
      var mvl = Curry._3(Util$ReactTemplate.List[/* fold_right */14], fold, holes$2, /* [] */0);
      var expl = mvl ? (
          mvl[1] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(possible names are: "), Pp$ReactTemplate.pr_enum(Names$ReactTemplate.Id[/* print */8], mvl)), Pp$ReactTemplate.str(").")) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(possible name is: "), Names$ReactTemplate.Id[/* print */8](mvl[0])), Pp$ReactTemplate.str(")."))
        ) : Pp$ReactTemplate.str(" (no bound variables at all in the expression).");
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such bound variable "), Names$ReactTemplate.Id[/* print */8](id$1)), expl));
    }
  } else {
    try {
      var nondeps = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (hole) {
              return 1 - hole[/* hole_deps */2];
            }), holes);
      return Curry._2(Util$ReactTemplate.List[/* nth */3], nondeps, param[0] - 1 | 0)[/* hole_evar */0];
    }
    catch (raw_e){
      var e = Js_exn.internalToOCamlException(raw_e);
      if (CErrors$ReactTemplate.noncritical(e)) {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such binder."));
      } else {
        throw e;
      }
    }
  }
}

function define_with_type(sigma, env, ev, c) {
  var t = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, ev);
  var ty = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c);
  var j = Environ$ReactTemplate.make_judge(c, ty);
  var match = Coercion$ReactTemplate.inh_conv_coerce_to(/* None */0, /* true */1)(env, sigma, j, t);
  var sigma$1 = match[0];
  var match$1 = EConstr$ReactTemplate.destEvar(sigma$1, ev);
  return Evd$ReactTemplate.define(match$1[0], EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[1][/* uj_val */0]), sigma$1);
}

function solve_evar_clause(env, sigma, hyp_only, clause, param) {
  if (typeof param === "number") {
    return sigma;
  } else if (param.tag) {
    var lbind = param[0];
    check_bindings(lbind);
    var fold = function (sigma, param) {
      var match = param[/* v */0];
      var ev = evar_of_binder(clause[/* cl_holes */0], match[0]);
      return define_with_type(sigma, env, ev, match[1]);
    };
    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, sigma, lbind);
  } else {
    var largs = param[0];
    var fold$1 = function (holes, h) {
      if (h[/* hole_deps */2]) {
        var match = EConstr$ReactTemplate.destEvar(sigma, h[/* hole_evar */0]);
        var ev = match[0];
        var is_dep = function (hole) {
          return Termops$ReactTemplate.occur_evar(sigma, ev, hole[/* hole_type */1]);
        };
        var in_hyp = Curry._2(Util$ReactTemplate.List[/* exists */21], is_dep, holes);
        var in_ccl = Termops$ReactTemplate.occur_evar(sigma, ev, clause[/* cl_concl */1]);
        var dep = hyp_only ? in_hyp && 1 - in_ccl : in_hyp || in_ccl;
        var h_000 = /* hole_evar */h[/* hole_evar */0];
        var h_001 = /* hole_type */h[/* hole_type */1];
        var h_003 = /* hole_name */h[/* hole_name */3];
        var h$1 = /* record */[
          h_000,
          h_001,
          /* hole_deps */dep,
          h_003
        ];
        return /* :: */[
                h$1,
                holes
              ];
      } else {
        return /* :: */[
                h,
                holes
              ];
      }
    };
    var holes = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold$1, /* [] */0, Curry._1(Util$ReactTemplate.List[/* rev */4], clause[/* cl_holes */0]));
    var map = function (h) {
      if (h[/* hole_deps */2]) {
        return /* Some */[h[/* hole_evar */0]];
      } else {
        return /* None */0;
      }
    };
    var evs = Curry._2(Util$ReactTemplate.List[/* map_filter */62], map, holes);
    var len = Curry._1(Util$ReactTemplate.List[/* length */0], evs);
    if (len === Curry._1(Util$ReactTemplate.List[/* length */0], largs)) {
      var fold$2 = function (sigma, ev, arg) {
        return define_with_type(sigma, env, ev, arg);
      };
      return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], fold$2, sigma, evs, largs);
    } else {
      return error_not_right_number_missing_arguments(len);
    }
  }
}

exports.clenv_value = clenv_value;
exports.clenv_type = clenv_type;
exports.clenv_nf_meta = clenv_nf_meta;
exports.clenv_meta_type = clenv_meta_type;
exports.mk_clenv_from = mk_clenv_from;
exports.mk_clenv_from_n = mk_clenv_from_n;
exports.mk_clenv_type_of = mk_clenv_type_of;
exports.mk_clenv_from_env = mk_clenv_from_env;
exports.refresh_undefined_univs = refresh_undefined_univs;
exports.clenv_fchain = clenv_fchain;
exports.clenv_unify = clenv_unify;
exports.old_clenv_unique_resolver = old_clenv_unique_resolver;
exports.clenv_unique_resolver = clenv_unique_resolver;
exports.clenv_dependent = clenv_dependent;
exports.clenv_pose_metas_as_evars = clenv_pose_metas_as_evars;
exports.clenv_independent = clenv_independent;
exports.clenv_missing = clenv_missing;
exports.NoSuchBinding = NoSuchBinding;
exports.clenv_constrain_last_binding = clenv_constrain_last_binding;
exports.clenv_unify_meta_types = clenv_unify_meta_types;
exports.make_clenv_binding_env_apply = make_clenv_binding_env_apply;
exports.make_clenv_binding_apply = make_clenv_binding_apply;
exports.make_clenv_binding_env = make_clenv_binding_env;
exports.make_clenv_binding = make_clenv_binding;
exports.NotExtensibleClause = NotExtensibleClause;
exports.clenv_push_prod = clenv_push_prod;
exports.pr_clenv = pr_clenv;
exports.make_evar_clause = make_evar_clause;
exports.solve_evar_clause = solve_evar_clause;
/* Pp-ReactTemplate Not a pure module */
