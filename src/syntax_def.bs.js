// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Notation$ReactTemplate = require("./notation.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Notation_ops$ReactTemplate = require("./notation_ops.bs.js");

var syntax_table = Summary$ReactTemplate.ref(/* None */0, "SYNTAXCONSTANT", Names$ReactTemplate.KNmap[/* empty */0]);

function add_syntax_constant(kn, c, onlyparse) {
  syntax_table[0] = Curry._3(Names$ReactTemplate.KNmap[/* add */3], kn, /* tuple */[
        c,
        onlyparse
      ], syntax_table[0]);
  return /* () */0;
}

function load_syntax_constant(i, param) {
  var match = param[1];
  var match$1 = param[0];
  var kn = match$1[1];
  var sp = match$1[0];
  if (Nametab$ReactTemplate.exists_cci(sp)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["cache_syntax_constant"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](Libnames$ReactTemplate.basename(sp)), Pp$ReactTemplate.str(" already exists")));
  }
  add_syntax_constant(kn, match[1], match[2]);
  return Nametab$ReactTemplate.push_syndef(/* Until */Block.__(0, [i]), sp, kn);
}

function is_alias_of_already_visible_name(sp, param) {
  var match = param[1];
  if (match.tag) {
    return /* false */0;
  } else {
    var match$1 = Libnames$ReactTemplate.repr_qualid(Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], match[0]));
    if (Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], match$1[0])) {
      return Names$ReactTemplate.Id[/* equal */0](match$1[1], Libnames$ReactTemplate.basename(sp));
    } else {
      return /* false */0;
    }
  }
}

function open_syntax_constant(i, param) {
  var match = param[1];
  var pat = match[1];
  var match$1 = param[0];
  var kn = match$1[1];
  var sp = match$1[0];
  if (i === 1 && is_alias_of_already_visible_name(sp, pat)) {
    return 0;
  } else {
    Nametab$ReactTemplate.push_syndef(/* Exactly */Block.__(1, [i]), sp, kn);
    if (match[2]) {
      return /* () */0;
    } else {
      return Notation$ReactTemplate.declare_uninterpretation(/* SynDefRule */Block.__(1, [kn]), pat);
    }
  }
}

function cache_syntax_constant(d) {
  load_syntax_constant(1, d);
  return open_syntax_constant(1, d);
}

function subst_syntax_constant(param) {
  var match = param[1];
  return /* tuple */[
          match[0],
          Notation_ops$ReactTemplate.subst_interpretation(param[0], match[1]),
          match[2]
        ];
}

function classify_syntax_constant(o) {
  if (o[0]) {
    return /* Dispose */0;
  } else {
    return /* Substitute */Block.__(0, [o]);
  }
}

var init = Libobject$ReactTemplate.default_object("SYNTAXCONSTANT");

var in_syntax_constant = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_syntax_constant,
      /* load_function */load_syntax_constant,
      /* open_function */open_syntax_constant,
      /* classify_function */classify_syntax_constant,
      /* subst_function */subst_syntax_constant,
      /* discharge_function */init[/* discharge_function */6],
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

function in_pat(param) {
  return /* tuple */[
          Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return /* tuple */[
                          param[0],
                          /* tuple */[
                            param[1],
                            /* NtnTypeConstr */0
                          ]
                        ];
                }), param[0]),
          param[1]
        ];
}

function out_pat(param) {
  return /* tuple */[
          Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return /* tuple */[
                          param[0],
                          param[1][0]
                        ];
                }), param[0]),
          param[1]
        ];
}

function declare_syntactic_definition(local, id, onlyparse, pat) {
  Lib$ReactTemplate.add_leaf(id, Curry._1(in_syntax_constant, /* tuple */[
            local,
            in_pat(pat),
            onlyparse
          ]));
  return /* () */0;
}

function pr_syndef(kn) {
  return Libnames$ReactTemplate.pr_qualid(Nametab$ReactTemplate.shortest_qualid_of_syndef(Names$ReactTemplate.Id[/* Set */9][/* empty */0], kn));
}

function pr_compat_warning(param) {
  var def = param[1];
  var pp_def;
  if (def[0]) {
    pp_def = Pp$ReactTemplate.strbrk(" is a compatibility notation");
  } else {
    var match = def[1];
    pp_def = match.tag ? Pp$ReactTemplate.strbrk(" is a compatibility notation") : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("is")), Pp$ReactTemplate.spc(/* () */0)), Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], match[0]));
  }
  return Pp$ReactTemplate.$plus$plus(pr_syndef(param[0]), pp_def);
}

var warn_compatibility_notation = CWarnings$ReactTemplate.create("compatibility-notation", "deprecated", /* Some */[/* Enabled */1], pr_compat_warning);

function verbose_compat(kn, def, param) {
  if (param) {
    var v = param[0];
    if (Flags$ReactTemplate.version_strictly_greater(v)) {
      return Curry._2(warn_compatibility_notation, /* None */0, /* tuple */[
                  kn,
                  def,
                  v
                ]);
    } else {
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

function search_syntactic_definition(kn) {
  var match = Curry._2(Names$ReactTemplate.KNmap[/* find */21], kn, syntax_table[0]);
  var def = out_pat(match[0]);
  verbose_compat(kn, def, match[1]);
  return def;
}

exports.declare_syntactic_definition = declare_syntactic_definition;
exports.search_syntactic_definition = search_syntactic_definition;
/* syntax_table Not a pure module */
