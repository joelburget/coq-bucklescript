// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Dn$ReactTemplate = require("./dn.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Globnames$ReactTemplate = require("../src/globnames.bs.js");
var Patternops$ReactTemplate = require("../src/patternops.bs.js");

var dnet_depth = [8];

function compare_term_label(t1, t2) {
  if (typeof t1 === "number" || typeof t2 === "number") {
    return Caml_obj.caml_compare(t1, t2);
  } else {
    return Globnames$ReactTemplate.RefOrdered[/* compare */0](t1[0], t2[0]);
  }
}

function decrec(_acc, _c) {
  while(true) {
    var c = _c;
    var acc = _acc;
    switch (c.tag | 0) {
      case 4 : 
          _c = c[0];
          _acc = Util$ReactTemplate.$at(Util$ReactTemplate.$$Array[/* to_list */9](c[1]), acc);
          continue ;
          case 6 : 
          return /* tuple */[
                  /* PRef */Block.__(0, [/* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](c[0])])]),
                  /* :: */[
                    c[1],
                    acc
                  ]
                ];
      default:
        return /* tuple */[
                c,
                acc
              ];
    }
  };
}

function decomp(sigma, t) {
  var _acc = /* [] */0;
  var _c = t;
  while(true) {
    var c = _c;
    var acc = _acc;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 9 : 
          _c = match[0];
          _acc = Util$ReactTemplate.$$Array[/* fold_right */16]((function (a, l) {
                  return /* :: */[
                          a,
                          l
                        ];
                }), match[1], acc);
          continue ;
          case 16 : 
          return /* tuple */[
                  EConstr$ReactTemplate.mkConst(Names$ReactTemplate.Projection[/* constant */2](match[0])),
                  /* :: */[
                    match[1],
                    acc
                  ]
                ];
      default:
        return /* tuple */[
                c,
                acc
              ];
    }
  };
}

function constr_val_discr(sigma, t) {
  var match = decomp(sigma, t);
  var l = match[1];
  var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
  switch (match$1.tag | 0) {
    case 1 : 
        return /* Label */[/* tuple */[
                  /* GRLabel */[/* VarRef */Block.__(0, [match$1[0]])],
                  l
                ]];
    case 10 : 
        return /* Everything */1;
    case 11 : 
        return /* Label */[/* tuple */[
                  /* GRLabel */[/* IndRef */Block.__(2, [match$1[0][0]])],
                  l
                ]];
    case 12 : 
        return /* Label */[/* tuple */[
                  /* GRLabel */[/* ConstructRef */Block.__(3, [match$1[0][0]])],
                  l
                ]];
    default:
      return /* Nothing */0;
  }
}

function constr_pat_discr(t) {
  if (Patternops$ReactTemplate.occur_meta_pattern(t)) {
    var match = decrec(/* [] */0, t);
    var match$1 = match[0];
    if (match$1.tag) {
      return /* None */0;
    } else {
      var ref = match$1[0];
      switch (ref.tag | 0) {
        case 1 : 
            return /* None */0;
        case 0 : 
        case 2 : 
        case 3 : 
            return /* Some */[/* tuple */[
                      /* GRLabel */[ref],
                      match[1]
                    ]];
        
      }
    }
  } else {
    return /* None */0;
  }
}

function constr_val_discr_st(sigma, param, t) {
  var match = decomp(sigma, t);
  var l = match[1];
  var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
  switch (match$1.tag | 0) {
    case 1 : 
        var id = match$1[0];
        if (Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], id, param[0])) {
          return /* Nothing */0;
        } else {
          return /* Label */[/* tuple */[
                    /* GRLabel */[/* VarRef */Block.__(0, [id])],
                    l
                  ]];
        }
    case 3 : 
        return /* Everything */1;
    case 4 : 
        return /* Label */[/* tuple */[
                  /* SortLabel */2,
                  /* [] */0
                ]];
    case 6 : 
        return /* Label */[/* tuple */[
                  /* ProdLabel */0,
                  /* :: */[
                    match$1[1],
                    /* :: */[
                      match$1[2],
                      /* [] */0
                    ]
                  ]
                ]];
    case 7 : 
        if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
          return /* Label */[/* tuple */[
                    /* LambdaLabel */1,
                    Util$ReactTemplate.$at(/* :: */[
                          match$1[1],
                          /* :: */[
                            match$1[2],
                            /* [] */0
                          ]
                        ], l)
                  ]];
        } else {
          return /* Everything */1;
        }
    case 10 : 
        var c = match$1[0][0];
        if (Curry._2(Names$ReactTemplate.Cpred[/* mem */4], c, param[1])) {
          return /* Everything */1;
        } else {
          return /* Label */[/* tuple */[
                    /* GRLabel */[/* ConstRef */Block.__(1, [c])],
                    l
                  ]];
        }
    case 11 : 
        return /* Label */[/* tuple */[
                  /* GRLabel */[/* IndRef */Block.__(2, [match$1[0][0]])],
                  l
                ]];
    case 12 : 
        return /* Label */[/* tuple */[
                  /* GRLabel */[/* ConstructRef */Block.__(3, [match$1[0][0]])],
                  l
                ]];
    default:
      return /* Nothing */0;
  }
}

function constr_pat_discr_st(param, t) {
  var idpred = param[0];
  var match = decrec(/* [] */0, t);
  var match$1 = match[0];
  switch (match$1.tag | 0) {
    case 0 : 
        var ref = match$1[0];
        switch (ref.tag | 0) {
          case 0 : 
              if (Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], ref[0], idpred)) {
                return /* None */0;
              } else {
                return /* Some */[/* tuple */[
                          /* GRLabel */[ref],
                          match[1]
                        ]];
              }
          case 1 : 
              if (Curry._2(Names$ReactTemplate.Cpred[/* mem */4], ref[0], param[1])) {
                return /* None */0;
              } else {
                return /* Some */[/* tuple */[
                          /* GRLabel */[ref],
                          match[1]
                        ]];
              }
          case 2 : 
          case 3 : 
              return /* Some */[/* tuple */[
                        /* GRLabel */[ref],
                        match[1]
                      ]];
          
        }
        break;
    case 1 : 
        var v = match$1[0];
        if (Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], v, idpred)) {
          return /* None */0;
        } else {
          return /* Some */[/* tuple */[
                    /* GRLabel */[/* VarRef */Block.__(0, [v])],
                    match[1]
                  ]];
        }
    case 7 : 
        if (match[1]) {
          return /* None */0;
        } else {
          return /* Some */[/* tuple */[
                    /* LambdaLabel */1,
                    /* :: */[
                      match$1[1],
                      /* :: */[
                        match$1[2],
                        /* [] */0
                      ]
                    ]
                  ]];
        }
    case 8 : 
        if (match[1]) {
          return /* None */0;
        } else {
          return /* Some */[/* tuple */[
                    /* ProdLabel */0,
                    /* :: */[
                      match$1[1],
                      /* :: */[
                        match$1[2],
                        /* [] */0
                      ]
                    ]
                  ]];
        }
    case 10 : 
        if (match[1]) {
          return /* None */0;
        } else {
          return /* Some */[/* tuple */[
                    /* SortLabel */2,
                    /* [] */0
                  ]];
        }
    default:
      return /* None */0;
  }
}

function bounded_constr_pat_discr_st(st, param) {
  var depth = param[1];
  if (depth) {
    var match = constr_pat_discr_st(st, param[0]);
    if (match) {
      var match$1 = match[0];
      return /* Some */[/* tuple */[
                match$1[0],
                Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
                        return /* tuple */[
                                c,
                                depth - 1 | 0
                              ];
                      }), match$1[1])
              ]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function bounded_constr_pat_discr(param) {
  var depth = param[1];
  if (depth) {
    var match = constr_pat_discr(param[0]);
    if (match) {
      var match$1 = match[0];
      return /* Some */[/* tuple */[
                match$1[0],
                Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
                        return /* tuple */[
                                c,
                                depth - 1 | 0
                              ];
                      }), match$1[1])
              ]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function Make(funarg) {
  var Y = /* module */[/* compare */compare_term_label];
  var Dn = Dn$ReactTemplate.Make(Y)(funarg);
  var empty = Dn[/* empty */0];
  var add = function (param) {
    if (param) {
      var st = param[0];
      return (function (dn, param) {
          return Curry._3(Dn[/* add */1], dn, (function (param) {
                        return bounded_constr_pat_discr_st(st, param);
                      }), /* tuple */[
                      /* tuple */[
                        param[0],
                        dnet_depth[0]
                      ],
                      param[1]
                    ]);
        });
    } else {
      return (function (dn, param) {
          return Curry._3(Dn[/* add */1], dn, bounded_constr_pat_discr, /* tuple */[
                      /* tuple */[
                        param[0],
                        dnet_depth[0]
                      ],
                      param[1]
                    ]);
        });
    }
  };
  var rmv = function (param) {
    if (param) {
      var st = param[0];
      return (function (dn, param) {
          return Curry._3(Dn[/* rmv */2], dn, (function (param) {
                        return bounded_constr_pat_discr_st(st, param);
                      }), /* tuple */[
                      /* tuple */[
                        param[0],
                        dnet_depth[0]
                      ],
                      param[1]
                    ]);
        });
    } else {
      return (function (dn, param) {
          return Curry._3(Dn[/* rmv */2], dn, bounded_constr_pat_discr, /* tuple */[
                      /* tuple */[
                        param[0],
                        dnet_depth[0]
                      ],
                      param[1]
                    ]);
        });
    }
  };
  var lookup = function (sigma, param) {
    if (param) {
      var st = param[0];
      return (function (dn, t) {
          return Curry._3(Dn[/* lookup */3], dn, (function (param) {
                        var sigma$1 = sigma;
                        var st$1 = st;
                        var param$1 = param;
                        var depth = param$1[1];
                        if (depth) {
                          var match = constr_val_discr_st(sigma$1, st$1, param$1[0]);
                          if (typeof match === "number") {
                            if (match !== 0) {
                              return /* Everything */1;
                            } else {
                              return /* Nothing */0;
                            }
                          } else {
                            var match$1 = match[0];
                            return /* Label */[/* tuple */[
                                      match$1[0],
                                      Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
                                              return /* tuple */[
                                                      c,
                                                      depth - 1 | 0
                                                    ];
                                            }), match$1[1])
                                    ]];
                          }
                        } else {
                          return /* Nothing */0;
                        }
                      }), /* tuple */[
                      t,
                      dnet_depth[0]
                    ]);
        });
    } else {
      return (function (dn, t) {
          return Curry._3(Dn[/* lookup */3], dn, (function (param) {
                        var sigma$1 = sigma;
                        var param$1 = param;
                        var depth = param$1[1];
                        if (depth) {
                          var match = constr_val_discr(sigma$1, param$1[0]);
                          if (typeof match === "number") {
                            if (match !== 0) {
                              return /* Everything */1;
                            } else {
                              return /* Nothing */0;
                            }
                          } else {
                            var match$1 = match[0];
                            return /* Label */[/* tuple */[
                                      match$1[0],
                                      Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
                                              return /* tuple */[
                                                      c,
                                                      depth - 1 | 0
                                                    ];
                                            }), match$1[1])
                                    ]];
                          }
                        } else {
                          return /* Nothing */0;
                        }
                      }), /* tuple */[
                      t,
                      dnet_depth[0]
                    ]);
        });
    }
  };
  var app = function (f, dn) {
    return Curry._2(Dn[/* app */4], f, dn);
  };
  return [
          empty,
          add,
          rmv,
          lookup,
          app
        ];
}

exports.Make = Make;
exports.dnet_depth = dnet_depth;
/* Dn-ReactTemplate Not a pure module */
