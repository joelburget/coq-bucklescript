// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Lazy = require("bs-platform/lib/js/lazy.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Rtree$ReactTemplate = require("./rtree.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");
var Type_errors$ReactTemplate = require("./type_errors.bs.js");

function lookup_mind_specif(env, param) {
  var tyi = param[1];
  var mib = Environ$ReactTemplate.lookup_mind(param[0], env);
  if (tyi >= mib[/* mind_packets */0].length) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Inductive.lookup_mind_specif: invalid inductive index"));
  }
  return /* tuple */[
          mib,
          Caml_array.caml_array_get(mib[/* mind_packets */0], tyi)
        ];
}

function find_rectype(env, c) {
  var match = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(env, c));
  var match$1 = Constr$ReactTemplate.kind(match[0]);
  if (match$1.tag === 11) {
    return /* tuple */[
            match$1[0],
            match[1]
          ];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_inductive(env, c) {
  var match = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(env, c));
  var match$1 = Constr$ReactTemplate.kind(match[0]);
  if (match$1.tag === 11) {
    var ind = match$1[0];
    if (lookup_mind_specif(env, Univ$ReactTemplate.out_punivs(ind))[0][/* mind_finite */2] !== /* CoFinite */1) {
      return /* tuple */[
              ind,
              match[1]
            ];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_coinductive(env, c) {
  var match = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(env, c));
  var match$1 = Constr$ReactTemplate.kind(match[0]);
  if (match$1.tag === 11) {
    var ind = match$1[0];
    if (lookup_mind_specif(env, Univ$ReactTemplate.out_punivs(ind))[0][/* mind_finite */2] === /* CoFinite */1) {
      return /* tuple */[
              ind,
              match[1]
            ];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function inductive_params(param) {
  return param[0][/* mind_nparams */5];
}

function inductive_paramdecls(param) {
  return Vars$ReactTemplate.subst_instance_context(param[1], param[0][/* mind_params_ctxt */7]);
}

function instantiate_inductive_constraints(mib, u) {
  var match = mib[/* mind_universes */8];
  switch (match.tag | 0) {
    case 0 : 
        return Univ$ReactTemplate.Constraint[/* empty */0];
    case 1 : 
        return Univ$ReactTemplate.AUContext[/* instantiate */6](u, match[0]);
    case 2 : 
        var auctx = Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](match[0]);
        return Univ$ReactTemplate.AUContext[/* instantiate */6](u, auctx);
    
  }
}

function ind_subst(mind, mib, u) {
  var ntypes = mib[/* mind_ntypes */3];
  var make_Ik = function (k) {
    return Constr$ReactTemplate.mkIndU(/* tuple */[
                /* tuple */[
                  mind,
                  (ntypes - k | 0) - 1 | 0
                ],
                u
              ]);
  };
  return Curry._2(Util$ReactTemplate.List[/* init */46], ntypes, make_Ik);
}

function constructor_instantiate(mind, u, mib, c) {
  var s = ind_subst(mind, mib, u);
  return Vars$ReactTemplate.substl(s, Vars$ReactTemplate.subst_instance_constr(u, c));
}

function instantiate_params(full, t, u, args, sign) {
  var fail = function () {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["instantiate_params"], Pp$ReactTemplate.str("type, ctxt and args mismatch."));
  };
  var match = Context$ReactTemplate.Rel[/* fold_outside */10]((function (decl, param) {
          var ty = param[2];
          var subs = param[1];
          var largs = param[0];
          var match = Constr$ReactTemplate.kind(ty);
          var exit = 0;
          if (decl.tag) {
            if (match.tag === 8) {
              return /* tuple */[
                      largs,
                      /* :: */[
                        Vars$ReactTemplate.substl(subs, Vars$ReactTemplate.subst_instance_constr(u, decl[1])),
                        subs
                      ],
                      match[3]
                    ];
            } else {
              exit = 1;
            }
          } else if (largs) {
            if (match.tag === 6) {
              return /* tuple */[
                      largs[1],
                      /* :: */[
                        largs[0],
                        subs
                      ],
                      match[2]
                    ];
            } else {
              return fail(/* () */0);
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            if (largs || full) {
              return fail(/* () */0);
            } else {
              return /* tuple */[
                      /* [] */0,
                      subs,
                      ty
                    ];
            }
          }
          
        }), sign, /* tuple */[
        args,
        /* [] */0,
        t
      ]);
  if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], match[0])) {
    fail(/* () */0);
  }
  return Vars$ReactTemplate.substl(match[1], match[2]);
}

function full_inductive_instantiate(mib, u, params, sign) {
  var t = Term$ReactTemplate.mkArity(/* tuple */[
        Vars$ReactTemplate.subst_instance_context(u, sign),
        Sorts$ReactTemplate.prop
      ]);
  return Term$ReactTemplate.destArity(instantiate_params(/* true */1, t, u, params, mib[/* mind_params_ctxt */7]))[0];
}

function full_constructor_instantiate(param, t) {
  var mib = param[2][0];
  var u = param[1];
  var inst_ind = constructor_instantiate(param[0][0], u, mib, t);
  return instantiate_params(/* true */1, inst_ind, u, param[3], mib[/* mind_params_ctxt */7]);
}

function sort_as_univ(param) {
  if (param.tag) {
    return param[0];
  } else if (param[0] !== 0) {
    return Univ$ReactTemplate.Universe[/* type0m */12];
  } else {
    return Univ$ReactTemplate.Universe[/* type0 */13];
  }
}

function cons_subst(u, su, subst) {
  try {
    return Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, Univ$ReactTemplate.sup(Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, subst), su), subst);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, su, subst);
    } else {
      throw exn;
    }
  }
}

function remember_subst(u, subst) {
  try {
    var su = Univ$ReactTemplate.Universe[/* make */3](u);
    return Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, Univ$ReactTemplate.sup(Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, subst), su), subst);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return subst;
    } else {
      throw exn;
    }
  }
}

function make_subst(env) {
  var partial_arg = Univ$ReactTemplate.LMap[/* empty */0];
  return (function (param) {
      var _subst = partial_arg;
      var _param = param;
      while(true) {
        var param$1 = _param;
        var subst = _subst;
        var sign = param$1[0];
        var exit = 0;
        if (sign) {
          var exit$1 = 0;
          if (sign[0].tag) {
            _param = /* tuple */[
              sign[1],
              param$1[1],
              param$1[2]
            ];
            continue ;
            
          } else {
            var match = param$1[1];
            if (match) {
              var match$1 = match[0];
              if (match$1) {
                if (param$1[2]) {
                  exit$1 = 2;
                } else {
                  _param = /* tuple */[
                    sign[1],
                    match[1],
                    /* [] */0
                  ];
                  _subst = remember_subst(match$1[0], subst);
                  continue ;
                  
                }
              } else {
                exit$1 = 2;
              }
            } else {
              exit = 1;
            }
          }
          if (exit$1 === 2) {
            var match$2 = param$1[1];
            var match$3 = match$2[0];
            var sign$1 = sign[1];
            if (match$3) {
              var match$4 = param$1[2];
              var a = match$4[0];
              var tag = a.tag | 0;
              var s = sort_as_univ(Reduction$ReactTemplate.dest_arity(env, tag === 250 ? a[0] : (
                            tag === 246 ? CamlinternalLazy.force_lazy_block(a) : a
                          ))[1]);
              _param = /* tuple */[
                sign$1,
                match$2[1],
                match$4[1]
              ];
              _subst = cons_subst(match$3[0], s, subst);
              continue ;
              
            } else {
              var args = param$1[2];
              var args$1 = args ? args[1] : /* [] */0;
              _param = /* tuple */[
                sign$1,
                match$2[1],
                args$1
              ];
              continue ;
              
            }
          }
          
        } else {
          exit = 1;
        }
        if (exit === 1) {
          if (param$1[1]) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "inductive.ml",
                    185,
                    8
                  ]
                ];
          } else {
            return subst;
          }
        }
        
      };
    });
}

var SingletonInductiveBecomesProp = Caml_exceptions.create("Inductive-ReactTemplate.SingletonInductiveBecomesProp");

function instantiate_universes(env, ctx, ar, argsorts) {
  var args = Util$ReactTemplate.$$Array[/* to_list */9](argsorts);
  var subst = make_subst(env)(/* tuple */[
        ctx,
        ar[/* template_param_levels */0],
        args
      ]);
  var level = Univ$ReactTemplate.subst_univs_universe((function (param) {
          return Univ$ReactTemplate.make_subst(subst, param);
        }), ar[/* template_level */1]);
  var ty = Univ$ReactTemplate.is_type0m_univ(level) ? Sorts$ReactTemplate.prop : (
      Univ$ReactTemplate.is_type0_univ(level) ? Sorts$ReactTemplate.set : /* Type */Block.__(1, [level])
    );
  return /* tuple */[
          ctx,
          ty
        ];
}

function type_of_inductive_gen($staropt$star, env, param, paramtyps) {
  var mip = param[0][1];
  var polyprop = $staropt$star ? $staropt$star[0] : /* true */1;
  var match = mip[/* mind_arity */2];
  if (match.tag) {
    var ar = match[0];
    var ctx = Curry._1(Util$ReactTemplate.List[/* rev */4], mip[/* mind_arity_ctxt */1]);
    var match$1 = instantiate_universes(env, ctx, ar, paramtyps);
    var s = match$1[1];
    if (!polyprop && !Univ$ReactTemplate.is_type0m_univ(ar[/* template_level */1]) && Sorts$ReactTemplate.is_prop(s)) {
      throw [
            SingletonInductiveBecomesProp,
            mip[/* mind_typename */0]
          ];
    }
    return Term$ReactTemplate.mkArity(/* tuple */[
                Curry._1(Util$ReactTemplate.List[/* rev */4], match$1[0]),
                s
              ]);
  } else {
    return Vars$ReactTemplate.subst_instance_constr(param[1], match[0][/* mind_user_arity */0]);
  }
}

function type_of_inductive(env, pind) {
  return type_of_inductive_gen(/* None */0, env, pind, /* array */[]);
}

function constrained_type_of_inductive(env, pind) {
  var ty = type_of_inductive(env, pind);
  var cst = instantiate_inductive_constraints(pind[0][0], pind[1]);
  return /* tuple */[
          ty,
          cst
        ];
}

function constrained_type_of_inductive_knowing_parameters(env, pind, args) {
  var ty = type_of_inductive_gen(/* None */0, env, pind, args);
  var cst = instantiate_inductive_constraints(pind[0][0], pind[1]);
  return /* tuple */[
          ty,
          cst
        ];
}

function type_of_inductive_knowing_parameters(env, $staropt$star, mip, args) {
  var polyprop = $staropt$star ? $staropt$star[0] : /* true */1;
  return type_of_inductive_gen(/* Some */[polyprop], env, mip, args);
}

function cumulate_constructor_univ(u, param) {
  if (param.tag) {
    return Univ$ReactTemplate.Universe[/* sup */11](u, param[0]);
  } else if (param[0] !== 0) {
    return u;
  } else {
    return Univ$ReactTemplate.Universe[/* sup */11](Univ$ReactTemplate.Universe[/* type0 */13], u);
  }
}

var partial_arg = Univ$ReactTemplate.Universe[/* type0m */12];

var partial_arg$1 = Util$ReactTemplate.$$Array[/* fold_left */15];

function max_inductive_sort(param) {
  return partial_arg$1(cumulate_constructor_univ, partial_arg, param);
}

function type_of_constructor(param, param$1) {
  var mip = param$1[1];
  var cstr = param[0];
  var ind = Names$ReactTemplate.inductive_of_constructor(cstr);
  var specif = mip[/* mind_user_lc */4];
  var i = Names$ReactTemplate.index_of_constructor(cstr);
  var nconstr = mip[/* mind_consnames */3].length;
  if (i > nconstr) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough constructors in the type."));
  }
  return constructor_instantiate(ind[0], param[1], param$1[0], Caml_array.caml_array_get(specif, i - 1 | 0));
}

function constrained_type_of_constructor(cstru, ind) {
  var ty = type_of_constructor(cstru, ind);
  var cst = instantiate_inductive_constraints(ind[0], cstru[1]);
  return /* tuple */[
          ty,
          cst
        ];
}

function arities_of_specif(param, param$1) {
  var mib = param$1[0];
  var u = param[1];
  var kn = param[0];
  var specif = param$1[1][/* mind_nf_lc */8];
  return Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                return constructor_instantiate(kn, u, mib, param);
              }), specif);
}

function arities_of_constructors(ind, specif) {
  return arities_of_specif(/* tuple */[
              ind[0][0],
              ind[1]
            ], specif);
}

function type_of_constructors(param, param$1) {
  var mib = param$1[0];
  var u = param[1];
  var specif = param$1[1][/* mind_user_lc */4];
  var partial_arg = param[0][0];
  return Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                return constructor_instantiate(partial_arg, u, mib, param);
              }), specif);
}

function inductive_sort_family(mip) {
  var match = mip[/* mind_arity */2];
  if (match.tag) {
    return /* InType */2;
  } else {
    return Sorts$ReactTemplate.family(match[0][/* mind_sort */1]);
  }
}

function mind_arity(mip) {
  return /* tuple */[
          mip[/* mind_arity_ctxt */1],
          inductive_sort_family(mip)
        ];
}

function get_instantiated_arity(param, param$1, params) {
  var match = mind_arity(param$1[1]);
  return /* tuple */[
          full_inductive_instantiate(param$1[0], param[1], params, match[0]),
          match[1]
        ];
}

function elim_sorts(param) {
  return param[1][/* mind_kelim */7];
}

function is_private(param) {
  return Caml_obj.caml_equal(param[0][/* mind_private */9], /* Some */[/* true */1]);
}

function is_primitive_record(param) {
  var match = param[0][/* mind_record */1];
  if (match && match[0]) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function build_dependent_inductive(ind, param, params) {
  var mip = param[1];
  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], mip[/* mind_nrealdecls */6], mip[/* mind_arity_ctxt */1]);
  return Term$ReactTemplate.applist(/* tuple */[
              Constr$ReactTemplate.mkIndU(ind),
              Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* map */10], Vars$ReactTemplate.lift(mip[/* mind_nrealdecls */6]), params), Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, match[0]))
            ]);
}

var LocalArity = Caml_exceptions.create("Inductive-ReactTemplate.LocalArity");

function is_correct_arity(env, c, pj, ind, specif, params) {
  var match = get_instantiated_arity(ind, specif, params);
  try {
    var _env = env;
    var _pt = pj[/* uj_type */1];
    var _ar = Curry._1(Util$ReactTemplate.List[/* rev */4], match[0]);
    while(true) {
      var ar = _ar;
      var pt = _pt;
      var env$1 = _env;
      var pt$prime = Reduction$ReactTemplate.whd_all(env$1, pt);
      var match$1 = Constr$ReactTemplate.kind(pt$prime);
      var exit = 0;
      if (match$1.tag === 6) {
        var t = match$1[2];
        var a1 = match$1[1];
        var na1 = match$1[0];
        if (ar) {
          var match$2 = ar[0];
          if (match$2.tag) {
            exit = 1;
          } else {
            try {
              Curry._2(Reduction$ReactTemplate.conv(/* None */0, /* None */0, env$1, /* None */0), a1, match$2[1]);
            }
            catch (exn){
              if (exn === Reduction$ReactTemplate.NotConvertible) {
                throw [
                      LocalArity,
                      /* None */0
                    ];
              } else {
                throw exn;
              }
            }
            _ar = ar[1];
            _pt = t;
            _env = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                    na1,
                    a1
                  ]), env$1);
            continue ;
            
          }
        } else {
          var env$prime = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  na1,
                  a1
                ]), env$1);
          var match$3 = Constr$ReactTemplate.kind(Reduction$ReactTemplate.whd_all(env$prime, t));
          var ksort;
          if (match$3.tag === 4) {
            ksort = Sorts$ReactTemplate.family(match$3[0]);
          } else {
            throw [
                  LocalArity,
                  /* None */0
                ];
          }
          var dep_ind = build_dependent_inductive(ind, specif, params);
          try {
            Curry._2(Reduction$ReactTemplate.conv(/* None */0, /* None */0, env$1, /* None */0), a1, dep_ind);
          }
          catch (exn$1){
            if (exn$1 === Reduction$ReactTemplate.NotConvertible) {
              throw [
                    LocalArity,
                    /* None */0
                  ];
            } else {
              throw exn$1;
            }
          }
          var ksort$1 = ksort;
          var specif$1 = specif;
          var eq_ksort = (function(ksort$1){
          return function eq_ksort(s) {
            switch (ksort$1) {
              case 0 : 
                  if (s !== 0) {
                    return /* false */0;
                  } else {
                    return /* true */1;
                  }
              case 1 : 
                  if (s !== 1) {
                    return /* false */0;
                  } else {
                    return /* true */1;
                  }
              case 2 : 
                  if (s >= 2) {
                    return /* true */1;
                  } else {
                    return /* false */0;
                  }
              
            }
          }
          }(ksort$1));
          if (CList$ReactTemplate.exists(eq_ksort, elim_sorts(specif$1))) {
            return 0;
          } else {
            var s = inductive_sort_family(specif$1[1]);
            throw [
                  LocalArity,
                  /* Some */[/* tuple */[
                      ksort$1,
                      s,
                      Type_errors$ReactTemplate.error_elim_explain(ksort$1, s)
                    ]]
                ];
          }
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (ar) {
          var d = ar[0];
          if (d.tag) {
            _ar = ar[1];
            _pt = Vars$ReactTemplate.lift(1)(pt$prime);
            _env = Environ$ReactTemplate.push_rel(d, env$1);
            continue ;
            
          } else {
            throw [
                  LocalArity,
                  /* None */0
                ];
          }
        } else {
          throw [
                LocalArity,
                /* None */0
              ];
        }
      }
      
    };
  }
  catch (raw_exn){
    var exn$2 = Js_exn.internalToOCamlException(raw_exn);
    if (exn$2[0] === LocalArity) {
      return Type_errors$ReactTemplate.error_elim_arity(env, ind, elim_sorts(specif), c, pj, exn$2[1]);
    } else {
      throw exn$2;
    }
  }
}

function build_branches_type(param, specif, params, p) {
  var mip = specif[1];
  var u = param[1];
  var ind = param[0];
  var build_one_branch = function (i, cty) {
    var typi = full_constructor_instantiate(/* tuple */[
          ind,
          u,
          specif,
          params
        ], cty);
    var match = Term$ReactTemplate.decompose_prod_assum(typi);
    var cstrsign = match[0];
    var nargs = Curry._1(Context$ReactTemplate.Rel[/* length */3], cstrsign);
    var match$1 = Constr$ReactTemplate.decompose_app(match[1]);
    var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], inductive_params(specif), match$1[1]);
    var cstr = Names$ReactTemplate.ith_constructor_of_inductive(ind, i + 1 | 0);
    var dep_cstr = Term$ReactTemplate.applist(/* tuple */[
          Constr$ReactTemplate.mkConstructU(/* tuple */[
                cstr,
                u
              ]),
          Util$ReactTemplate.$at(match$2[0], Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, cstrsign))
        ]);
    var cargs = Util$ReactTemplate.$at(match$2[1], /* :: */[
          dep_cstr,
          /* [] */0
        ]);
    var base = Term$ReactTemplate.lambda_appvect_assum(mip[/* mind_nrealdecls */6] + 1 | 0, Vars$ReactTemplate.lift(nargs)(p), Util$ReactTemplate.$$Array[/* of_list */10](cargs));
    return Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, base, cstrsign);
  };
  return Util$ReactTemplate.$$Array[/* mapi */14](build_one_branch, mip[/* mind_nf_lc */8]);
}

function build_case_type(env, n, p, c, realargs) {
  return Reduction$ReactTemplate.whd_betaiota(env, Term$ReactTemplate.lambda_appvect_assum(n + 1 | 0, p, Util$ReactTemplate.$$Array[/* of_list */10](Util$ReactTemplate.$at(realargs, /* :: */[
                          c,
                          /* [] */0
                        ]))));
}

function type_case_branches(env, param, pj, c) {
  var pind = param[0];
  var specif = lookup_mind_specif(env, pind[0]);
  var nparams = inductive_params(specif);
  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], nparams, param[1]);
  var params = match[0];
  var p = pj[/* uj_val */0];
  is_correct_arity(env, c, pj, pind, specif, params);
  var lc = build_branches_type(pind, specif, params, p);
  var ty = build_case_type(env, specif[1][/* mind_nrealdecls */6], p, c, match[1]);
  return /* tuple */[
          lc,
          ty
        ];
}

function check_case_info(env, param, ci) {
  var indsp = param[0];
  var spec = lookup_mind_specif(env, indsp);
  var mip = spec[1];
  if (!Names$ReactTemplate.eq_ind(indsp, ci[/* ci_ind */0]) || spec[0][/* mind_nparams */5] !== ci[/* ci_npar */1] || !Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
            return +(prim === prim$1);
          }), mip[/* mind_consnrealdecls */10], ci[/* ci_cstr_ndecls */2]) || !Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
            return +(prim === prim$1);
          }), mip[/* mind_consnrealargs */9], ci[/* ci_cstr_nargs */3]) || is_primitive_record(spec)) {
    throw [
          Type_errors$ReactTemplate.TypeError,
          env,
          /* WrongCaseInfo */Block.__(7, [
              /* tuple */[
                indsp,
                param[1]
              ],
              ci
            ])
        ];
  } else {
    return 0;
  }
}

function size_glb(s1, s2) {
  if (s1 !== 0 && s2 !== 0) {
    return /* Strict */1;
  } else {
    return /* Large */0;
  }
}

function inter_recarg(r1, r2) {
  var exit = 0;
  var i1;
  var i2;
  if (typeof r1 === "number") {
    if (typeof r2 === "number") {
      return /* Some */[r1];
    } else {
      return /* None */0;
    }
  } else if (r1.tag) {
    var i1$1 = r1[0];
    if (typeof r2 === "number") {
      return /* None */0;
    } else if (r2.tag) {
      i1 = i1$1;
      i2 = r2[0];
      exit = 1;
    } else if (Names$ReactTemplate.eq_ind(i1$1, r2[0])) {
      return /* Some */[r2];
    } else {
      return /* None */0;
    }
  } else if (typeof r2 === "number") {
    return /* None */0;
  } else {
    i1 = r1[0];
    i2 = r2[0];
    exit = 1;
  }
  if (exit === 1) {
    if (Names$ReactTemplate.eq_ind(i1, i2)) {
      return /* Some */[r1];
    } else {
      return /* None */0;
    }
  }
  
}

function inter_wf_paths(param, param$1) {
  return Rtree$ReactTemplate.inter(Declareops$ReactTemplate.eq_recarg, inter_recarg, /* Norec */0, param, param$1);
}

function spec_of_tree(t) {
  if (Rtree$ReactTemplate.equal(Declareops$ReactTemplate.eq_recarg, t, Declareops$ReactTemplate.mk_norec)) {
    return /* Not_subterm */1;
  } else {
    return /* Subterm */[/* tuple */[
              /* Strict */1,
              t
            ]];
  }
}

function inter_spec(s1, s2) {
  var exit = 0;
  if (typeof s2 === "number") {
    if (s2 !== 0) {
      exit = 1;
    } else {
      return s1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (typeof s1 === "number") {
      if (s1 !== 0) {
        return s1;
      } else {
        return s2;
      }
    } else if (typeof s2 === "number") {
      return s2;
    } else {
      var match = s2[0];
      var match$1 = s1[0];
      return /* Subterm */[/* tuple */[
                size_glb(match$1[0], match[0]),
                inter_wf_paths(match$1[1], match[1])
              ]];
    }
  }
  
}

var partial_arg$2 = Util$ReactTemplate.$$Array[/* fold_left */15];

function subterm_spec_glb(param) {
  return partial_arg$2(inter_spec, /* Dead_code */0, param);
}

function make_renv(env, recarg, tree) {
  return /* record */[
          /* env */env,
          /* rel_min */recarg + 2 | 0,
          /* genv : :: */[
            Lazy.from_val(/* Subterm */[/* tuple */[
                    /* Large */0,
                    tree
                  ]]),
            /* [] */0
          ]
        ];
}

function push_var(renv, param) {
  return /* record */[
          /* env */Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  param[0],
                  param[1]
                ]), renv[/* env */0]),
          /* rel_min */renv[/* rel_min */1] + 1 | 0,
          /* genv : :: */[
            param[2],
            renv[/* genv */2]
          ]
        ];
}

function assign_var_spec(renv, param) {
  return /* record */[
          /* env */renv[/* env */0],
          /* rel_min */renv[/* rel_min */1],
          /* genv */Curry._3(Util$ReactTemplate.List[/* assign */57], renv[/* genv */2], param[0] - 1 | 0, param[1])
        ];
}

function push_var_renv(renv, param) {
  return push_var(renv, /* tuple */[
              param[0],
              param[1],
              /* Not_subterm */1
            ]);
}

function push_ctxt_renv(renv, ctxt) {
  var n = Curry._1(Context$ReactTemplate.Rel[/* length */3], ctxt);
  return /* record */[
          /* env */Environ$ReactTemplate.push_rel_context(ctxt, renv[/* env */0]),
          /* rel_min */renv[/* rel_min */1] + n | 0,
          /* genv */Util$ReactTemplate.iterate((function (ge) {
                  return /* :: */[
                          /* Not_subterm */1,
                          ge
                        ];
                }), n, renv[/* genv */2])
        ];
}

function push_fix_renv(renv, recdef) {
  var n = recdef[1].length;
  return /* record */[
          /* env */Environ$ReactTemplate.push_rec_types(recdef, renv[/* env */0]),
          /* rel_min */renv[/* rel_min */1] + n | 0,
          /* genv */Util$ReactTemplate.iterate((function (ge) {
                  return /* :: */[
                          /* Not_subterm */1,
                          ge
                        ];
                }), n, renv[/* genv */2])
        ];
}

function push_stack_closures(renv, l, stack) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (h, b) {
                return /* :: */[
                        /* SClosure */Block.__(0, [
                            renv,
                            h
                          ]),
                        b
                      ];
              }), l, stack);
}

function push_stack_args(l, stack) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (h, b) {
                return /* :: */[
                        /* SArg */Block.__(1, [h]),
                        b
                      ];
              }), l, stack);
}

function lookup_subterms(env, ind) {
  var match = lookup_mind_specif(env, ind);
  return match[1][/* mind_recargs */11];
}

function match_inductive(ind, ra) {
  if (typeof ra === "number") {
    return /* false */0;
  } else {
    return Names$ReactTemplate.eq_ind(ind, ra[0]);
  }
}

function branches_specif(renv, c_spec, ci) {
  var match = lookup_mind_specif(renv[/* env */0], ci[/* ci_ind */0]);
  var v = Declareops$ReactTemplate.dest_subterms(match[1][/* mind_recargs */11]);
  var car = Util$ReactTemplate.$$Array[/* map */12](Util$ReactTemplate.List[/* length */0], v);
  return Util$ReactTemplate.$$Array[/* mapi */14]((function (i, nca) {
                var lvra = Block.__(246, [(function () {
                        var tag = c_spec.tag | 0;
                        var match = tag === 250 ? c_spec[0] : (
                            tag === 246 ? CamlinternalLazy.force_lazy_block(c_spec) : c_spec
                          );
                        if (typeof match === "number") {
                          if (match !== 0) {
                            return Caml_array.caml_make_vect(nca, /* Not_subterm */1);
                          } else {
                            return Caml_array.caml_make_vect(nca, /* Dead_code */0);
                          }
                        } else {
                          var t = match[0][1];
                          if (match_inductive(ci[/* ci_ind */0], Declareops$ReactTemplate.dest_recarg(t))) {
                            var vra = Util$ReactTemplate.$$Array[/* of_list */10](Caml_array.caml_array_get(Declareops$ReactTemplate.dest_subterms(t), i));
                            if (nca !== vra.length) {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "inductive.ml",
                                      559,
                                      4
                                    ]
                                  ];
                            }
                            return Util$ReactTemplate.$$Array[/* map */12](spec_of_tree, vra);
                          } else {
                            return Caml_array.caml_make_vect(nca, /* Not_subterm */1);
                          }
                        }
                      })]);
                return Curry._2(Util$ReactTemplate.List[/* init */46], nca, (function (j) {
                              return Block.__(246, [(function () {
                                            var tag = lvra.tag | 0;
                                            return Caml_array.caml_array_get(tag === 250 ? lvra[0] : (
                                                          tag === 246 ? CamlinternalLazy.force_lazy_block(lvra) : lvra
                                                        ), j);
                                          })]);
                            }));
              }), car);
}

function check_inductive_codomain(env, p) {
  var match = Reduction$ReactTemplate.dest_lam_assum(env)(p);
  var env$1 = Environ$ReactTemplate.push_rel_context(match[0], env);
  var match$1 = Reduction$ReactTemplate.dest_prod_assum(env$1)(match[1]);
  var env$2 = Environ$ReactTemplate.push_rel_context(match$1[0], env$1);
  var match$2 = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(env$2, match$1[1]));
  return Constr$ReactTemplate.isInd(match$2[0]);
}

function ienv_push_var(param, param$1) {
  return /* tuple */[
          Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  param$1[0],
                  param$1[1]
                ]), param[0]),
          /* :: */[
            /* tuple */[
              /* Norec */0,
              param$1[2]
            ],
            param[1]
          ]
        ];
}

function ienv_push_inductive(param, param$1) {
  var lpar = param$1[1];
  var match = param$1[0];
  var u = match[1];
  var mind = match[0];
  var env = param[0];
  var mib = Environ$ReactTemplate.lookup_mind(mind, env);
  var ntypes = mib[/* mind_ntypes */3];
  var push_ind = function (specif, env) {
    var decl_001 = Reduction$ReactTemplate.hnf_prod_applist(env, type_of_inductive(env, /* tuple */[
              /* tuple */[
                mib,
                specif
              ],
              u
            ]), lpar);
    var decl = /* LocalAssum */Block.__(0, [
        /* Anonymous */0,
        decl_001
      ]);
    return Environ$ReactTemplate.push_rel(decl, env);
  };
  var env$1 = Util$ReactTemplate.$$Array[/* fold_right */16](push_ind, mib[/* mind_packets */0], env);
  var rc = Util$ReactTemplate.$$Array[/* mapi */14]((function (j, t) {
          return /* tuple */[
                  /* Imbr */Block.__(1, [/* tuple */[
                        mind,
                        j
                      ]]),
                  t
                ];
        }), Rtree$ReactTemplate.mk_rec_calls(ntypes));
  var lra_ind = Util$ReactTemplate.$$Array[/* rev_to_list */63](rc);
  var ra_env = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[0],
                  Rtree$ReactTemplate.lift(ntypes, param[1])
                ];
        }), param[1]);
  return /* tuple */[
          env$1,
          Util$ReactTemplate.$at(lra_ind, ra_env)
        ];
}

function ienv_decompose_prod(_ienv, _n, _c) {
  while(true) {
    var c = _c;
    var n = _n;
    var ienv = _ienv;
    if (n) {
      var c$prime = Reduction$ReactTemplate.whd_all(ienv[0], c);
      var match = Constr$ReactTemplate.kind(c$prime);
      if (match.tag === 6) {
        var ienv$prime = ienv_push_var(ienv, /* tuple */[
              match[0],
              match[1],
              Declareops$ReactTemplate.mk_norec
            ]);
        _c = match[2];
        _n = n - 1 | 0;
        _ienv = ienv$prime;
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "inductive.ml",
                599,
                12
              ]
            ];
      }
    } else {
      return /* tuple */[
              ienv,
              c
            ];
    }
  };
}

function lambda_implicit_lift(n, a) {
  var level = Univ$ReactTemplate.Level[/* make */8](Names$ReactTemplate.DirPath[/* make */3](/* :: */[
            Names$ReactTemplate.Id[/* of_string */5]("implicit"),
            /* [] */0
          ]), 0);
  var implicit_sort = Constr$ReactTemplate.mkType(Univ$ReactTemplate.Universe[/* make */3](level));
  var lambda_implicit = function (a) {
    return Constr$ReactTemplate.mkLambda(/* tuple */[
                /* Anonymous */0,
                implicit_sort,
                a
              ]);
  };
  return Util$ReactTemplate.iterate(lambda_implicit, n, Vars$ReactTemplate.lift(n)(a));
}

function abstract_mind_lc(ntyps, npars, lc) {
  if (npars) {
    var make_abs = Curry._2(Util$ReactTemplate.List[/* init */46], ntyps, (function (i) {
            return lambda_implicit_lift(npars, Constr$ReactTemplate.mkRel(i + 1 | 0));
          }));
    return Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                  return Vars$ReactTemplate.substl(make_abs, param);
                }), lc);
  } else {
    return lc;
  }
}

function get_recargs_approx(env, tree, ind, args) {
  var build_recargs = function (_ienv, tree, _c) {
    while(true) {
      var c = _c;
      var ienv = _ienv;
      var match = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(ienv[0], c));
      var largs = match[1];
      var err = Constr$ReactTemplate.kind(match[0]);
      switch (err.tag | 0) {
        case 0 : 
            try {
              return Curry._2(Util$ReactTemplate.List[/* nth */3], ienv[1], err[0] - 1 | 0)[1];
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Caml_builtin_exceptions.failure) {
                return Declareops$ReactTemplate.mk_norec;
              } else if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
                return Declareops$ReactTemplate.mk_norec;
              } else {
                throw exn;
              }
            }
            break;
        case 6 : 
            if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], largs)) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "inductive.ml",
                      629,
                      7
                    ]
                  ];
            }
            _c = err[2];
            _ienv = ienv_push_var(ienv, /* tuple */[
                  err[0],
                  err[1],
                  Declareops$ReactTemplate.mk_norec
                ]);
            continue ;
            case 11 : 
            var ind_kn = err[0];
            var match$1 = Declareops$ReactTemplate.dest_recarg(tree);
            if (typeof match$1 === "number" || !Names$ReactTemplate.eq_ind(ind_kn[0], match$1[0])) {
              return Declareops$ReactTemplate.mk_norec;
            } else {
              return build_recargs_nested(ienv, tree, /* tuple */[
                          ind_kn,
                          largs
                        ]);
            }
        default:
          return Declareops$ReactTemplate.mk_norec;
      }
    };
  };
  var build_recargs_nested = function (ienv, tree, param) {
    var match = param[0];
    var match$1 = match[0];
    var mind = match$1[0];
    if (Rtree$ReactTemplate.equal(Declareops$ReactTemplate.eq_recarg, tree, Declareops$ReactTemplate.mk_norec)) {
      return tree;
    } else {
      var mib = Environ$ReactTemplate.lookup_mind(mind, ienv[0]);
      var auxnpar = mib[/* mind_nparams_rec */6];
      var nonrecpar = mib[/* mind_nparams */5] - auxnpar | 0;
      var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], auxnpar, param[1]);
      var lpar = match$2[0];
      var auxntyp = mib[/* mind_ntypes */3];
      var ienv$prime = ienv_push_inductive(ienv, /* tuple */[
            /* tuple */[
              mind,
              match[1]
            ],
            lpar
          ]);
      var env$prime = ienv$prime[0];
      var lpar$prime = Curry._2(Util$ReactTemplate.List[/* map */10], Vars$ReactTemplate.lift(auxntyp), lpar);
      var trees = auxntyp === 1 ? /* array */[Declareops$ReactTemplate.dest_subterms(tree)] : Util$ReactTemplate.$$Array[/* map */12]((function (mip) {
                return Declareops$ReactTemplate.dest_subterms(mip[/* mind_recargs */11]);
              }), mib[/* mind_packets */0]);
      var mk_irecargs = function (j, specif) {
        var auxlcvect = abstract_mind_lc(auxntyp, auxnpar, specif[/* mind_nf_lc */8]);
        var paths = Util$ReactTemplate.$$Array[/* mapi */14]((function (k, c) {
                var c$prime = Reduction$ReactTemplate.hnf_prod_applist(env$prime, c, lpar$prime);
                var match = ienv_decompose_prod(ienv$prime, nonrecpar, c$prime);
                var ienv = match[0];
                var trees$1 = Caml_array.caml_array_get(Caml_array.caml_array_get(trees, j), k);
                var c$1 = match[1];
                var _ienv = ienv;
                var _trees = trees$1;
                var _lrec = /* [] */0;
                var _c = c$1;
                while(true) {
                  var c$2 = _c;
                  var lrec = _lrec;
                  var trees$2 = _trees;
                  var ienv$1 = _ienv;
                  var match$1 = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(ienv$1[0], c$2));
                  var hd = Constr$ReactTemplate.kind(match$1[0]);
                  if (hd.tag === 6) {
                    var b = hd[1];
                    if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], match$1[1])) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "inductive.ml",
                              689,
                              15
                            ]
                          ];
                    }
                    var recarg = build_recargs(ienv$1, Curry._1(Util$ReactTemplate.List[/* hd */1], trees$2), b);
                    var ienv$prime$1 = ienv_push_var(ienv$1, /* tuple */[
                          hd[0],
                          b,
                          Declareops$ReactTemplate.mk_norec
                        ]);
                    _c = hd[2];
                    _lrec = /* :: */[
                      recarg,
                      lrec
                    ];
                    _trees = Curry._1(Util$ReactTemplate.List[/* tl */2], trees$2);
                    _ienv = ienv$prime$1;
                    continue ;
                    
                  } else {
                    return Curry._1(Util$ReactTemplate.List[/* rev */4], lrec);
                  }
                };
              }), auxlcvect);
        return Declareops$ReactTemplate.mk_paths(/* Imbr */Block.__(1, [/* tuple */[
                        mind,
                        j
                      ]]), paths);
      };
      var irecargs = Util$ReactTemplate.$$Array[/* mapi */14](mk_irecargs, mib[/* mind_packets */0]);
      return Caml_array.caml_array_get(Rtree$ReactTemplate.mk_rec(irecargs), match$1[1]);
    }
  };
  return build_recargs_nested(/* tuple */[
              env,
              /* [] */0
            ], tree, /* tuple */[
              ind,
              args
            ]);
}

function restrict_spec(env, spec, p) {
  if (spec === /* Not_subterm */1) {
    return spec;
  } else {
    var match = Reduction$ReactTemplate.dest_lam_assum(env)(p);
    var ar = match[1];
    var absctx = match[0];
    if (Vars$ReactTemplate.noccur_with_meta(1, Curry._1(Context$ReactTemplate.Rel[/* length */3], absctx), ar)) {
      return spec;
    } else {
      var env$1 = Environ$ReactTemplate.push_rel_context(absctx, env);
      var match$1 = Reduction$ReactTemplate.dest_prod_assum(env$1)(ar);
      var env$2 = Environ$ReactTemplate.push_rel_context(match$1[0], env$1);
      var match$2 = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(env$2, match$1[1]));
      var match$3 = Constr$ReactTemplate.kind(match$2[0]);
      if (match$3.tag === 11) {
        if (typeof spec === "number") {
          if (spec !== 0) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "inductive.ml",
                    723,
                    11
                  ]
                ];
          } else {
            return spec;
          }
        } else {
          var match$4 = spec[0];
          var tree = match$4[1];
          var recargs = get_recargs_approx(env$2, tree, match$3[0], match$2[1]);
          var recargs$1 = inter_wf_paths(tree, recargs);
          return /* Subterm */[/* tuple */[
                    match$4[0],
                    recargs$1
                  ]];
        }
      } else {
        return /* Not_subterm */1;
      }
    }
  }
}

function subterm_specif(_renv, _stack, _t) {
  while(true) {
    var t = _t;
    var stack = _stack;
    var renv = _renv;
    var match = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(renv[/* env */0], t));
    var l = match[1];
    var match$1 = Constr$ReactTemplate.kind(match[0]);
    switch (match$1.tag | 0) {
      case 0 : 
          var p = match$1[0];
          var renv$1 = renv;
          try {
            var lzarg = Curry._2(Util$ReactTemplate.List[/* nth */3], renv$1[/* genv */2], p - 1 | 0);
            var tag = lzarg.tag | 0;
            if (tag === 250) {
              return lzarg[0];
            } else if (tag === 246) {
              return CamlinternalLazy.force_lazy_block(lzarg);
            } else {
              return lzarg;
            }
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === Caml_builtin_exceptions.failure) {
              return /* Not_subterm */1;
            } else if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
              return /* Not_subterm */1;
            } else {
              throw exn;
            }
          }
      case 2 : 
      case 3 : 
          return /* Dead_code */0;
      case 7 : 
          var a = match$1[1];
          if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "inductive.ml",
                    792,
                    15
                  ]
                ];
          }
          var match$2 = extract_stack(renv, a, stack);
          _t = match$1[2];
          _stack = match$2[1];
          _renv = push_var(renv, /* tuple */[
                match$1[0],
                a,
                match$2[0]
              ]);
          continue ;
          case 13 : 
          var stack$prime = push_stack_closures(renv, l, stack);
          var cases_spec = branches_specif(renv, lazy_subterm_specif(renv, /* [] */0, match$1[2]), match$1[0]);
          var stl = Util$ReactTemplate.$$Array[/* mapi */14]((function(renv,stack$prime,cases_spec){
              return function (i, br$prime) {
                var stack_br = push_stack_args(Caml_array.caml_array_get(cases_spec, i), stack$prime);
                return subterm_specif(renv, stack_br, br$prime);
              }
              }(renv,stack$prime,cases_spec)), match$1[3]);
          var spec = Curry._1(subterm_spec_glb, stl);
          return restrict_spec(renv[/* env */0], spec, match$1[1]);
      case 14 : 
          var match$3 = match$1[0];
          var recdef = match$3[1];
          var typarray = recdef[1];
          var match$4 = match$3[0];
          var i = match$4[1];
          if (check_inductive_codomain(renv[/* env */0], Caml_array.caml_array_get(typarray, i))) {
            var match$5 = Reduction$ReactTemplate.dest_prod(renv[/* env */0])(Caml_array.caml_array_get(typarray, i));
            var env$prime = Environ$ReactTemplate.push_rel_context(match$5[0], renv[/* env */0]);
            var oind;
            try {
              oind = /* Some */[find_inductive(env$prime, match$5[1])[0]];
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                oind = /* None */0;
              } else {
                throw exn$1;
              }
            }
            if (oind) {
              var nbfix = typarray.length;
              var recargs = lookup_subterms(renv[/* env */0], oind[0][0]);
              var renv$prime = push_fix_renv(renv, recdef);
              var renv$prime$1 = assign_var_spec(renv$prime, /* tuple */[
                    nbfix - i | 0,
                    Block.__(246, [(function(recargs){
                        return function () {
                          return /* Subterm */[/* tuple */[
                                    /* Strict */1,
                                    recargs
                                  ]];
                        }
                        }(recargs))])
                  ]);
              var decrArg = Caml_array.caml_array_get(match$4[0], i);
              var theBody = Caml_array.caml_array_get(recdef[2], i);
              var nbOfAbst = decrArg + 1 | 0;
              var match$6 = Term$ReactTemplate.decompose_lam_n_assum(nbOfAbst)(theBody);
              var stack$prime$1 = push_stack_closures(renv, l, stack);
              var renv$prime$prime = push_ctxt_renv(renv$prime$1, match$6[0]);
              var renv$prime$prime$1;
              if (Curry._1(Util$ReactTemplate.List[/* length */0], stack$prime$1) < nbOfAbst) {
                renv$prime$prime$1 = renv$prime$prime;
              } else {
                var decrArg$1 = Curry._2(Util$ReactTemplate.List[/* nth */3], stack$prime$1, decrArg);
                var arg_spec = stack_element_specif(decrArg$1);
                renv$prime$prime$1 = assign_var_spec(renv$prime$prime, /* tuple */[
                      1,
                      arg_spec
                    ]);
              }
              _t = match$6[1];
              _stack = /* [] */0;
              _renv = renv$prime$prime$1;
              continue ;
              
            } else {
              return /* Not_subterm */1;
            }
          } else {
            return /* Not_subterm */1;
          }
          break;
      case 16 : 
          var subt = subterm_specif(renv, stack, match$1[1]);
          if (typeof subt === "number") {
            if (subt !== 0) {
              return /* Not_subterm */1;
            } else {
              return /* Dead_code */0;
            }
          } else {
            var wf_args = Caml_array.caml_array_get(Declareops$ReactTemplate.dest_subterms(subt[0][1]), 0);
            var kn = Names$ReactTemplate.Projection[/* constant */2](match$1[0]);
            var cb = Environ$ReactTemplate.lookup_constant(kn, renv[/* env */0]);
            var pb = Option$ReactTemplate.get(cb[/* const_proj */5]);
            var n = pb[/* proj_arg */2];
            return spec_of_tree(Curry._2(Util$ReactTemplate.List[/* nth */3], wf_args, n));
          }
          break;
      default:
        return /* Not_subterm */1;
    }
  };
}

function lazy_subterm_specif(renv, stack, t) {
  return Block.__(246, [(function () {
                return subterm_specif(renv, stack, t);
              })]);
}

function stack_element_specif(param) {
  if (param.tag) {
    return param[0];
  } else {
    return lazy_subterm_specif(param[0], /* [] */0, param[1]);
  }
}

function extract_stack(_, _$1, param) {
  if (param) {
    return /* tuple */[
            stack_element_specif(param[0]),
            param[1]
          ];
  } else {
    return /* tuple */[
            Lazy.from_val(/* Not_subterm */1),
            /* [] */0
          ];
  }
}

function check_is_subterm(x, tree) {
  var tag = x.tag | 0;
  var match = tag === 250 ? x[0] : (
      tag === 246 ? CamlinternalLazy.force_lazy_block(x) : x
    );
  if (typeof match === "number") {
    if (match !== 0) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  } else {
    var match$1 = match[0];
    if (match$1[0] !== 0) {
      var param = tree;
      var param$1 = match$1[1];
      return Rtree$ReactTemplate.incl(Declareops$ReactTemplate.eq_recarg, inter_recarg, /* Norec */0, param, param$1);
    } else {
      return /* false */0;
    }
  }
}

var FixGuardError = Caml_exceptions.create("Inductive-ReactTemplate.FixGuardError");

function error_partial_apply(renv, fx) {
  throw [
        FixGuardError,
        renv[/* env */0],
        /* NotEnoughArgumentsForFixCall */Block.__(2, [fx])
      ];
}

function filter_stack_domain(env, _, p, stack) {
  var match = Reduction$ReactTemplate.dest_lam_assum(env)(p);
  var ar = match[1];
  var absctx = match[0];
  if (Vars$ReactTemplate.noccur_with_meta(1, Curry._1(Context$ReactTemplate.Rel[/* length */3], absctx), ar)) {
    return stack;
  } else {
    var env$1 = Environ$ReactTemplate.push_rel_context(absctx, env);
    var filter_stack = function (env, ar, stack) {
      var t = Reduction$ReactTemplate.whd_all(env, ar);
      var match = Constr$ReactTemplate.kind(t);
      var exit = 0;
      if (stack) {
        if (match.tag === 6) {
          var a = match[1];
          var elt = stack[0];
          var d_000 = match[0];
          var d = /* LocalAssum */Block.__(0, [
              d_000,
              a
            ]);
          var match$1 = Reduction$ReactTemplate.dest_prod_assum(env)(a);
          var env$1 = Environ$ReactTemplate.push_rel_context(match$1[0], env);
          var match$2 = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(env$1, match$1[1]));
          var match$3 = Constr$ReactTemplate.kind(match$2[0]);
          var elt$1;
          if (match$3.tag === 11) {
            var spec$prime = stack_element_specif(elt);
            var tag = spec$prime.tag | 0;
            var match$4 = tag === 250 ? spec$prime[0] : (
                tag === 246 ? CamlinternalLazy.force_lazy_block(spec$prime) : spec$prime
              );
            if (typeof match$4 === "number") {
              elt$1 = elt;
            } else {
              var match$5 = match$4[0];
              var path = match$5[1];
              var s = match$5[0];
              var recargs = get_recargs_approx(env$1, path, match$3[0], match$2[1]);
              var path$1 = inter_wf_paths(path, recargs);
              elt$1 = /* SArg */Block.__(1, [Block.__(246, [(function () {
                          return /* Subterm */[/* tuple */[
                                    s,
                                    path$1
                                  ]];
                        })])]);
            }
          } else {
            elt$1 = /* SArg */Block.__(1, [/* Not_subterm */1]);
          }
          return /* :: */[
                  elt$1,
                  filter_stack(Environ$ReactTemplate.push_rel(d, env$1), match[2], stack[1])
                ];
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (_, l) {
                      return /* :: */[
                              /* SArg */Block.__(1, [/* Not_subterm */1]),
                              l
                            ];
                    }), stack, /* [] */0);
      }
      
    };
    return filter_stack(env$1, ar, stack);
  }
}

function check_one_fix(renv, recpos, trees, def) {
  var nfi = recpos.length;
  var check_rec_call = function (_renv, _stack, _t) {
    while(true) {
      var t = _t;
      var stack = _stack;
      var renv = _renv;
      if (Vars$ReactTemplate.noccur_with_meta(renv[/* rel_min */1], nfi, t)) {
        return /* () */0;
      } else {
        var match = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_betaiotazeta(renv[/* env */0], t));
        var l = match[1];
        var match$1 = Constr$ReactTemplate.kind(match[0]);
        switch (match$1.tag | 0) {
          case 0 : 
              var p = match$1[0];
              if (renv[/* rel_min */1] <= p && p < (renv[/* rel_min */1] + nfi | 0)) {
                Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                    return function (param) {
                      return check_rec_call(renv, /* [] */0, param);
                    }
                    }(renv)), l);
                var glob = ((renv[/* rel_min */1] + nfi | 0) - 1 | 0) - p | 0;
                var np = Caml_array.caml_array_get(recpos, glob);
                var stack$prime = push_stack_closures(renv, l, stack);
                if (Curry._1(Util$ReactTemplate.List[/* length */0], stack$prime) <= np) {
                  return error_partial_apply(renv, glob);
                } else {
                  var z = Curry._2(Util$ReactTemplate.List[/* nth */3], stack$prime, np);
                  if (check_is_subterm(stack_element_specif(z), Caml_array.caml_array_get(trees, glob))) {
                    return 0;
                  } else if (z.tag) {
                    return error_partial_apply(renv, glob);
                  } else {
                    var renv$1 = renv;
                    var fx = glob;
                    var param = /* tuple */[
                      z[0],
                      z[1]
                    ];
                    var match$2 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, sbt) {
                            var lt = param[2];
                            var le = param[1];
                            var i = param[0];
                            var tag = sbt.tag | 0;
                            var match = tag === 250 ? sbt[0] : (
                                tag === 246 ? CamlinternalLazy.force_lazy_block(sbt) : sbt
                              );
                            var exit = 0;
                            if (typeof match === "number") {
                              if (match !== 0) {
                                return /* tuple */[
                                        i + 1 | 0,
                                        le,
                                        lt
                                      ];
                              } else {
                                exit = 1;
                              }
                            } else if (match[0][0] !== 0) {
                              exit = 1;
                            } else {
                              return /* tuple */[
                                      i + 1 | 0,
                                      /* :: */[
                                        i,
                                        le
                                      ],
                                      lt
                                    ];
                            }
                            if (exit === 1) {
                              return /* tuple */[
                                      i + 1 | 0,
                                      le,
                                      /* :: */[
                                        i,
                                        lt
                                      ]
                                    ];
                            }
                            
                          }), /* tuple */[
                          1,
                          /* [] */0,
                          /* [] */0
                        ], renv$1[/* genv */2]);
                    throw [
                          FixGuardError,
                          renv$1[/* env */0],
                          /* RecursionOnIllegalTerm */Block.__(1, [
                              fx,
                              /* tuple */[
                                param[0][/* env */0],
                                param[1]
                              ],
                              match$2[1],
                              match$2[2]
                            ])
                        ];
                  }
                }
              } else {
                var match$3 = Environ$ReactTemplate.lookup_rel(p, renv[/* env */0]);
                if (match$3.tag) {
                  try {
                    return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                              return function (param) {
                                return check_rec_call(renv, /* [] */0, param);
                              }
                              }(renv)), l);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === FixGuardError) {
                      _t = Term$ReactTemplate.applist(/* tuple */[
                            Vars$ReactTemplate.lift(p)(match$3[1]),
                            l
                          ]);
                      continue ;
                      
                    } else {
                      throw exn;
                    }
                  }
                } else {
                  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                            return function (param) {
                              return check_rec_call(renv, /* [] */0, param);
                            }
                            }(renv)), l);
                }
              }
              break;
          case 1 : 
              var match$4 = Environ$ReactTemplate.lookup_named(match$1[0], renv[/* env */0]);
              if (match$4.tag) {
                try {
                  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                            return function (param) {
                              return check_rec_call(renv, /* [] */0, param);
                            }
                            }(renv)), l);
                }
                catch (raw_exn$1){
                  var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
                  if (exn$1[0] === FixGuardError) {
                    _t = Term$ReactTemplate.applist(/* tuple */[
                          match$4[1],
                          l
                        ]);
                    continue ;
                    
                  } else {
                    throw exn$1;
                  }
                }
              } else {
                return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                          return function (param) {
                            return check_rec_call(renv, /* [] */0, param);
                          }
                          }(renv)), l);
              }
              break;
          case 2 : 
          case 3 : 
              return /* () */0;
          case 4 : 
              if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
                return 0;
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "inductive.ml",
                        1020,
                        10
                      ]
                    ];
              }
              break;
          case 6 : 
              var a = match$1[1];
              if (!(Curry._1(Util$ReactTemplate.List[/* is_empty */45], l) && Curry._1(Util$ReactTemplate.List[/* is_empty */45], stack))) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "inductive.ml",
                        990,
                        21
                      ]
                    ];
              }
              check_rec_call(renv, /* [] */0, a);
              _t = match$1[2];
              _stack = /* [] */0;
              _renv = push_var_renv(renv, /* tuple */[
                    match$1[0],
                    a
                  ]);
              continue ;
              case 7 : 
              var a$1 = match$1[1];
              if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "inductive.ml",
                        984,
                        21
                      ]
                    ];
              }
              check_rec_call(renv, /* [] */0, a$1);
              var match$5 = extract_stack(renv, a$1, stack);
              _t = match$1[2];
              _stack = match$5[1];
              _renv = push_var(renv, /* tuple */[
                    match$1[0],
                    a$1,
                    match$5[0]
                  ]);
              continue ;
              case 10 : 
              var cu = match$1[0];
              if (Environ$ReactTemplate.evaluable_constant(cu[0], renv[/* env */0])) {
                try {
                  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                            return function (param) {
                              return check_rec_call(renv, /* [] */0, param);
                            }
                            }(renv)), l);
                }
                catch (raw_exn$2){
                  var exn$2 = Js_exn.internalToOCamlException(raw_exn$2);
                  if (exn$2[0] === FixGuardError) {
                    var value = Term$ReactTemplate.applist(/* tuple */[
                          Environ$ReactTemplate.constant_value_in(renv[/* env */0], cu),
                          l
                        ]);
                    _t = value;
                    continue ;
                    
                  } else {
                    throw exn$2;
                  }
                }
              } else {
                return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                          return function (param) {
                            return check_rec_call(renv, /* [] */0, param);
                          }
                          }(renv)), l);
              }
              break;
          case 11 : 
              return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                        return function (param) {
                          return check_rec_call(renv, /* [] */0, param);
                        }
                        }(renv)), l);
          case 12 : 
              return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                        return function (param) {
                          return check_rec_call(renv, /* [] */0, param);
                        }
                        }(renv)), l);
          case 13 : 
              var c_0 = match$1[2];
              var p$1 = match$1[1];
              var ci = match$1[0];
              Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                  return function (param) {
                    return check_rec_call(renv, /* [] */0, param);
                  }
                  }(renv)), /* :: */[
                    c_0,
                    /* :: */[
                      p$1,
                      l
                    ]
                  ]);
              var case_spec = branches_specif(renv, lazy_subterm_specif(renv, /* [] */0, c_0), ci);
              var stack$prime$1 = push_stack_closures(renv, l, stack);
              var stack$prime$2 = filter_stack_domain(renv[/* env */0], ci, p$1, stack$prime$1);
              return Util$ReactTemplate.$$Array[/* iteri */13]((function(renv,case_spec,stack$prime$2){
                        return function (k, br$prime) {
                          var stack_br = push_stack_args(Caml_array.caml_array_get(case_spec, k), stack$prime$2);
                          return check_rec_call(renv, stack_br, br$prime);
                        }
                        }(renv,case_spec,stack$prime$2)), match$1[3]);
          case 14 : 
              var match$6 = match$1[0];
              var recdef = match$6[1];
              var match$7 = match$6[0];
              var i = match$7[1];
              Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                  return function (param) {
                    return check_rec_call(renv, /* [] */0, param);
                  }
                  }(renv)), l);
              Util$ReactTemplate.$$Array[/* iter */11]((function(renv){
                  return function (param) {
                    return check_rec_call(renv, /* [] */0, param);
                  }
                  }(renv)), recdef[1]);
              var decrArg = Caml_array.caml_array_get(match$7[0], i);
              var renv$prime = push_fix_renv(renv, recdef);
              var stack$prime$3 = push_stack_closures(renv, l, stack);
              return Util$ReactTemplate.$$Array[/* iteri */13]((function(i,decrArg,renv$prime,stack$prime$3){
                        return function (j, body) {
                          if (i === j && Curry._1(Util$ReactTemplate.List[/* length */0], stack$prime$3) > decrArg) {
                            var recArg = Curry._2(Util$ReactTemplate.List[/* nth */3], stack$prime$3, decrArg);
                            var arg_sp = stack_element_specif(recArg);
                            var _renv = renv$prime;
                            var _decr = decrArg + 1 | 0;
                            var recArgsDecrArg = arg_sp;
                            var _body = body;
                            while(true) {
                              var body$1 = _body;
                              var decr = _decr;
                              var renv = _renv;
                              if (decr) {
                                var match = Constr$ReactTemplate.kind(body$1);
                                if (match.tag === 7) {
                                  var a = match[1];
                                  check_rec_call(renv, /* [] */0, a);
                                  var renv$prime$1 = push_var_renv(renv, /* tuple */[
                                        match[0],
                                        a
                                      ]);
                                  _body = match[2];
                                  _decr = decr - 1 | 0;
                                  _renv = renv$prime$1;
                                  continue ;
                                  
                                } else {
                                  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough abstractions in fix body."));
                                }
                              } else {
                                return check_rec_call(assign_var_spec(renv, /* tuple */[
                                                1,
                                                recArgsDecrArg
                                              ]), /* [] */0, body$1);
                              }
                            };
                          } else {
                            return check_rec_call(renv$prime, /* [] */0, body);
                          }
                        }
                        }(i,decrArg,renv$prime,stack$prime$3)), recdef[2]);
          case 15 : 
              var recdef$1 = match$1[0][1];
              Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                  return function (param) {
                    return check_rec_call(renv, /* [] */0, param);
                  }
                  }(renv)), l);
              Util$ReactTemplate.$$Array[/* iter */11]((function(renv){
                  return function (param) {
                    return check_rec_call(renv, /* [] */0, param);
                  }
                  }(renv)), recdef$1[1]);
              var renv$prime$1 = push_fix_renv(renv, recdef$1);
              return Util$ReactTemplate.$$Array[/* iter */11]((function(renv$prime$1){
                        return function (param) {
                          return check_rec_call(renv$prime$1, /* [] */0, param);
                        }
                        }(renv$prime$1)), recdef$1[2]);
          case 16 : 
              Curry._2(Util$ReactTemplate.List[/* iter */9], (function(renv){
                  return function (param) {
                    return check_rec_call(renv, /* [] */0, param);
                  }
                  }(renv)), l);
              _t = match$1[1];
              _stack = /* [] */0;
              continue ;
              default:
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "inductive.ml",
                    1025,
                    40
                  ]
                ];
        }
      }
    };
  };
  return check_rec_call(renv, /* [] */0, def);
}

function judgment_of_fixpoint(param) {
  return Util$ReactTemplate.$$Array[/* map2 */49]((function (typ, body) {
                return /* record */[
                        /* uj_val */body,
                        /* uj_type */typ
                      ];
              }), param[1], param[2]);
}

function inductive_of_mutfix(env, param) {
  var recdef = param[1];
  var bodies = recdef[2];
  var names = recdef[0];
  var match = param[0];
  var bodynum = match[1];
  var nvect = match[0];
  var nbfix = bodies.length;
  if (nbfix === 0 || nvect.length !== nbfix || recdef[1].length !== nbfix || names.length !== nbfix || bodynum < 0 || bodynum >= nbfix) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Ill-formed fix term."));
  }
  var fixenv = Environ$ReactTemplate.push_rec_types(recdef, env);
  var vdefj = judgment_of_fixpoint(recdef);
  var raise_err = function (env, i, err) {
    return Type_errors$ReactTemplate.error_ill_formed_rec_body(env, err, names, i, fixenv, vdefj);
  };
  var find_ind = function (i, k, def) {
    var _env = fixenv;
    var _n = 1;
    var _def = def;
    while(true) {
      var def$1 = _def;
      var n = _n;
      var env = _env;
      var match = Constr$ReactTemplate.kind(Reduction$ReactTemplate.whd_all(env, def$1));
      if (match.tag === 7) {
        var b = match[2];
        var a = match[1];
        if (Vars$ReactTemplate.noccur_with_meta(n, nbfix, a)) {
          var env$prime = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  match[0],
                  a
                ]), env);
          if (n === (k + 1 | 0)) {
            var match$1;
            try {
              match$1 = find_inductive(env, a);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                match$1 = raise_err(env, i, /* RecursionNotOnInductiveType */Block.__(0, [a]));
              } else {
                throw exn;
              }
            }
            var mind = match$1[0];
            var match$2 = lookup_mind_specif(env, Univ$ReactTemplate.out_punivs(mind));
            if (match$2[0][/* mind_finite */2] !== /* Finite */0) {
              raise_err(env, i, /* RecursionNotOnInductiveType */Block.__(0, [a]));
            }
            return /* tuple */[
                    mind,
                    /* tuple */[
                      env$prime,
                      b
                    ]
                  ];
          } else {
            _def = b;
            _n = n + 1 | 0;
            _env = env$prime;
            continue ;
            
          }
        } else {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["check_one_fix"], Pp$ReactTemplate.str("Bad occurrence of recursive call."));
        }
      } else {
        return raise_err(env, i, /* NotEnoughAbstractionInFixBody */0);
      }
    };
  };
  var rv = Util$ReactTemplate.$$Array[/* map2_i */50](find_ind, nvect, bodies);
  return /* tuple */[
          Util$ReactTemplate.$$Array[/* map */12]((function (prim) {
                  return prim[0];
                }), rv),
          Util$ReactTemplate.$$Array[/* map */12]((function (prim) {
                  return prim[1];
                }), rv)
        ];
}

function check_fix(env, fix) {
  var recdef = fix[1];
  var names = recdef[0];
  var nvect = fix[0][0];
  var flags = Environ$ReactTemplate.typing_flags(env);
  if (flags[/* check_guarded */0]) {
    var match = inductive_of_mutfix(env, fix);
    var rdef = match[1];
    var trees = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
            var param$1 = param[0];
            var mib = Environ$ReactTemplate.lookup_mind(param$1[0], env);
            return Caml_array.caml_array_get(mib[/* mind_packets */0], param$1[1])[/* mind_recargs */11];
          }), match[0]);
    for(var i = 0 ,i_finish = recdef[2].length - 1 | 0; i <= i_finish; ++i){
      var match$1 = Caml_array.caml_array_get(rdef, i);
      var renv = make_renv(match$1[0], Caml_array.caml_array_get(nvect, i), Caml_array.caml_array_get(trees, i));
      try {
        check_one_fix(renv, nvect, trees, match$1[1]);
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === FixGuardError) {
          Type_errors$ReactTemplate.error_ill_formed_rec_body(exn[1], exn[2], names, i, Environ$ReactTemplate.push_rec_types(recdef, env), judgment_of_fixpoint(recdef));
        } else {
          throw exn;
        }
      }
    }
    return /* () */0;
  } else {
    return /* () */0;
  }
}

var CoFixGuardError = Caml_exceptions.create("Inductive-ReactTemplate.CoFixGuardError");

function codomain_is_coind(_env, _c) {
  while(true) {
    var c = _c;
    var env = _env;
    var b = Reduction$ReactTemplate.whd_all(env, c);
    var match = Constr$ReactTemplate.kind(b);
    if (match.tag === 6) {
      _c = match[2];
      _env = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
              match[0],
              match[1]
            ]), env);
      continue ;
      
    } else {
      try {
        return find_coinductive(env, b);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          throw [
                CoFixGuardError,
                env,
                /* CodomainNotInductiveType */Block.__(3, [b])
              ];
        } else {
          throw exn;
        }
      }
    }
  };
}

function check_one_cofix(env, nbfix, def, deftype) {
  var check_rec_call = function (_env, alreadygrd, _n, tree, vlra, _t) {
    while(true) {
      var t = _t;
      var n = _n;
      var env = _env;
      if (Vars$ReactTemplate.noccur_with_meta(n, nbfix, t)) {
        return 0;
      } else {
        var match = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(env, t));
        var args = match[1];
        var c = match[0];
        var match$1 = Constr$ReactTemplate.kind(c);
        switch (match$1.tag | 0) {
          case 0 : 
              var p = match$1[0];
              if (n <= p && p < (n + nbfix | 0)) {
                if (alreadygrd) {
                  if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function(n){
                        return function (param) {
                          return Vars$ReactTemplate.noccur_with_meta(n, nbfix, param);
                        }
                        }(n)), args)) {
                    return 0;
                  } else {
                    throw [
                          CoFixGuardError,
                          env,
                          /* NestedRecursiveOccurrences */1
                        ];
                  }
                } else {
                  throw [
                        CoFixGuardError,
                        env,
                        /* UnguardedRecursiveCall */Block.__(4, [t])
                      ];
                }
              } else {
                throw [
                      CoFixGuardError,
                      env,
                      /* NotGuardedForm */Block.__(11, [t])
                    ];
              }
              break;
          case 2 : 
              return /* () */0;
          case 3 : 
              return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(env,n){
                        return function (param) {
                          return check_rec_call(env, alreadygrd, n, tree, vlra, param);
                        }
                        }(env,n)), args);
          case 7 : 
              var a = match$1[1];
              if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], args)) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "inductive.ml",
                        1161,
                        14
                      ]
                    ];
              }
              if (Vars$ReactTemplate.noccur_with_meta(n, nbfix, a)) {
                var env$prime = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                        match$1[0],
                        a
                      ]), env);
                _t = match$1[2];
                _n = n + 1 | 0;
                _env = env$prime;
                continue ;
                
              } else {
                throw [
                      CoFixGuardError,
                      env,
                      /* RecCallInTypeOfAbstraction */Block.__(5, [a])
                    ];
              }
              break;
          case 12 : 
              var cstr_kn = match$1[0][0];
              var lra = Caml_array.caml_array_get(vlra, cstr_kn[1] - 1 | 0);
              var mI = Names$ReactTemplate.inductive_of_constructor(cstr_kn);
              var match$2 = lookup_mind_specif(env, mI);
              var realargs = Curry._2(Util$ReactTemplate.List[/* skipn */107], match$2[0][/* mind_nparams */5], args);
              var _param = /* tuple */[
                realargs,
                lra
              ];
              while(true) {
                var param = _param;
                var match$3 = param[0];
                if (match$3) {
                  var match$4 = param[1];
                  if (match$4) {
                    var lrar = match$4[1];
                    var rar = match$4[0];
                    var lr = match$3[1];
                    var t$1 = match$3[0];
                    if (Rtree$ReactTemplate.equal(Declareops$ReactTemplate.eq_recarg, rar, Declareops$ReactTemplate.mk_norec)) {
                      if (Vars$ReactTemplate.noccur_with_meta(n, nbfix, t$1)) {
                        _param = /* tuple */[
                          lr,
                          lrar
                        ];
                        continue ;
                        
                      } else {
                        throw [
                              CoFixGuardError,
                              env,
                              /* RecCallInNonRecArgOfConstructor */Block.__(6, [t$1])
                            ];
                      }
                    } else {
                      check_rec_call(env, /* true */1, n, rar, Declareops$ReactTemplate.dest_subterms(rar), t$1);
                      _param = /* tuple */[
                        lr,
                        lrar
                      ];
                      continue ;
                      
                    }
                  } else {
                    return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["check_one_cofix"], Pp$ReactTemplate.str("too many arguments applied to constructor."));
                  }
                } else {
                  return /* () */0;
                }
              };
          case 13 : 
              var p$1 = match$1[1];
              var match$5 = restrict_spec(env, /* Subterm */[/* tuple */[
                      /* Strict */1,
                      tree
                    ]], p$1);
              var tree$1;
              if (typeof match$5 === "number") {
                if (match$5 !== 0) {
                  throw [
                        CoFixGuardError,
                        env,
                        /* ReturnPredicateNotCoInductive */Block.__(12, [c])
                      ];
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "inductive.ml",
                          1184,
                          21
                        ]
                      ];
                }
              } else {
                tree$1 = match$5[0][1];
              }
              if (Vars$ReactTemplate.noccur_with_meta(n, nbfix, p$1)) {
                if (Vars$ReactTemplate.noccur_with_meta(n, nbfix, match$1[2])) {
                  if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function(n){
                        return function (param) {
                          return Vars$ReactTemplate.noccur_with_meta(n, nbfix, param);
                        }
                        }(n)), args)) {
                    var vlra$1 = Declareops$ReactTemplate.dest_subterms(tree$1);
                    return Util$ReactTemplate.$$Array[/* iter */11]((function(env,n,tree$1,vlra$1){
                              return function (param) {
                                return check_rec_call(env, alreadygrd, n, tree$1, vlra$1, param);
                              }
                              }(env,n,tree$1,vlra$1)), match$1[3]);
                  } else {
                    throw [
                          CoFixGuardError,
                          env,
                          /* RecCallInCaseFun */Block.__(8, [c])
                        ];
                  }
                } else {
                  throw [
                        CoFixGuardError,
                        env,
                        /* RecCallInCaseArg */Block.__(9, [c])
                      ];
                }
              } else {
                throw [
                      CoFixGuardError,
                      env,
                      /* RecCallInCasePred */Block.__(10, [c])
                    ];
              }
              break;
          case 15 : 
              var recdef = match$1[0][1];
              var vdefs = recdef[2];
              if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function(n){
                    return function (param) {
                      return Vars$ReactTemplate.noccur_with_meta(n, nbfix, param);
                    }
                    }(n)), args)) {
                if (Util$ReactTemplate.$$Array[/* for_all */26]((function(n){
                      return function (param) {
                        return Vars$ReactTemplate.noccur_with_meta(n, nbfix, param);
                      }
                      }(n)), recdef[1])) {
                  var nbfix$1 = vdefs.length;
                  var env$prime$1 = Environ$ReactTemplate.push_rec_types(recdef, env);
                  var partial_arg = n + nbfix$1 | 0;
                  Util$ReactTemplate.$$Array[/* iter */11]((function(env$prime$1,partial_arg){
                      return function (param) {
                        return check_rec_call(env$prime$1, alreadygrd, partial_arg, tree, vlra, param);
                      }
                      }(env$prime$1,partial_arg)), vdefs);
                  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function(env,n){
                            return function (param) {
                              return check_rec_call(env, alreadygrd, n, tree, vlra, param);
                            }
                            }(env,n)), args);
                } else {
                  throw [
                        CoFixGuardError,
                        env,
                        /* RecCallInTypeOfDef */Block.__(7, [c])
                      ];
                }
              } else {
                throw [
                      CoFixGuardError,
                      env,
                      /* UnguardedRecursiveCall */Block.__(4, [c])
                    ];
              }
              break;
          default:
            throw [
                  CoFixGuardError,
                  env,
                  /* NotGuardedForm */Block.__(11, [t])
                ];
        }
      }
    };
  };
  var match = codomain_is_coind(env, deftype);
  var vlra = lookup_subterms(env, match[0][0]);
  return check_rec_call(env, /* false */0, 1, vlra, Declareops$ReactTemplate.dest_subterms(vlra), def);
}

function check_cofix(env, param) {
  var recdef = param[1];
  var bodies = recdef[2];
  var types = recdef[1];
  var names = recdef[0];
  var flags = Environ$ReactTemplate.typing_flags(env);
  if (flags[/* check_guarded */0]) {
    var nbfix = bodies.length;
    for(var i = 0 ,i_finish = nbfix - 1 | 0; i <= i_finish; ++i){
      var fixenv = Environ$ReactTemplate.push_rec_types(recdef, env);
      try {
        check_one_cofix(fixenv, nbfix, Caml_array.caml_array_get(bodies, i), Caml_array.caml_array_get(types, i));
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === CoFixGuardError) {
          Type_errors$ReactTemplate.error_ill_formed_rec_body(exn[1], exn[2], names, i, fixenv, judgment_of_fixpoint(recdef));
        } else {
          throw exn;
        }
      }
    }
    return /* () */0;
  } else {
    return /* () */0;
  }
}

exports.find_rectype = find_rectype;
exports.find_inductive = find_inductive;
exports.find_coinductive = find_coinductive;
exports.lookup_mind_specif = lookup_mind_specif;
exports.ind_subst = ind_subst;
exports.inductive_paramdecls = inductive_paramdecls;
exports.instantiate_inductive_constraints = instantiate_inductive_constraints;
exports.constrained_type_of_inductive = constrained_type_of_inductive;
exports.constrained_type_of_inductive_knowing_parameters = constrained_type_of_inductive_knowing_parameters;
exports.type_of_inductive = type_of_inductive;
exports.type_of_inductive_knowing_parameters = type_of_inductive_knowing_parameters;
exports.elim_sorts = elim_sorts;
exports.is_private = is_private;
exports.is_primitive_record = is_primitive_record;
exports.constrained_type_of_constructor = constrained_type_of_constructor;
exports.type_of_constructor = type_of_constructor;
exports.arities_of_constructors = arities_of_constructors;
exports.type_of_constructors = type_of_constructors;
exports.arities_of_specif = arities_of_specif;
exports.inductive_params = inductive_params;
exports.type_case_branches = type_case_branches;
exports.build_branches_type = build_branches_type;
exports.mind_arity = mind_arity;
exports.inductive_sort_family = inductive_sort_family;
exports.check_case_info = check_case_info;
exports.check_fix = check_fix;
exports.check_cofix = check_cofix;
exports.SingletonInductiveBecomesProp = SingletonInductiveBecomesProp;
exports.max_inductive_sort = max_inductive_sort;
exports.instantiate_universes = instantiate_universes;
exports.subterm_specif = subterm_specif;
exports.lambda_implicit_lift = lambda_implicit_lift;
exports.abstract_mind_lc = abstract_mind_lc;
/* Pp-ReactTemplate Not a pure module */
