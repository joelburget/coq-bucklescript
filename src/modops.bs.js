// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Cbytegen$ReactTemplate = require("./cbytegen.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Cemitcodes$ReactTemplate = require("./cemitcodes.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");
var Opaqueproof$ReactTemplate = require("./opaqueproof.bs.js");

var ModuleTypingError = Caml_exceptions.create("Modops-ReactTemplate.ModuleTypingError");

function error_existing_label(l) {
  throw [
        ModuleTypingError,
        /* LabelAlreadyDeclared */Block.__(1, [l])
      ];
}

function error_incompatible_modtypes(mexpr1, mexpr2) {
  throw [
        ModuleTypingError,
        /* IncompatibleModuleTypes */Block.__(3, [
            mexpr1,
            mexpr2
          ])
      ];
}

function error_signature_mismatch(l, spec, why) {
  throw [
        ModuleTypingError,
        /* SignatureMismatch */Block.__(0, [
            l,
            spec,
            why
          ])
      ];
}

function error_no_such_label(l) {
  throw [
        ModuleTypingError,
        /* NoSuchLabel */Block.__(5, [l])
      ];
}

function error_incompatible_labels(l, l$prime) {
  throw [
        ModuleTypingError,
        /* IncompatibleLabels */Block.__(6, [
            l,
            l$prime
          ])
      ];
}

function error_not_a_module(s) {
  throw [
        ModuleTypingError,
        /* NotAModule */Block.__(7, [s])
      ];
}

function error_not_a_constant(l) {
  throw [
        ModuleTypingError,
        /* NotAConstant */Block.__(9, [l])
      ];
}

function error_incorrect_with_constraint(l) {
  throw [
        ModuleTypingError,
        /* IncorrectWithConstraint */Block.__(10, [l])
      ];
}

function error_generative_module_expected(l) {
  throw [
        ModuleTypingError,
        /* GenerativeModuleExpected */Block.__(11, [l])
      ];
}

function error_no_such_label_sub(l, l1) {
  throw [
        ModuleTypingError,
        /* LabelMissing */Block.__(12, [
            l,
            l1
          ])
      ];
}

function error_include_restricted_functor(mp) {
  throw [
        ModuleTypingError,
        /* IncludeRestrictedFunctor */Block.__(13, [mp])
      ];
}

function is_functor(param) {
  if (param.tag) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function destr_functor(param) {
  if (param.tag) {
    return /* tuple */[
            param[0],
            param[1],
            param[2]
          ];
  } else {
    throw [
          ModuleTypingError,
          /* NotAFunctor */0
        ];
  }
}

function destr_nofunctor(param) {
  if (param.tag) {
    throw [
          ModuleTypingError,
          /* IsAFunctor */1
        ];
  } else {
    return param[0];
  }
}

function functor_smartmap(fty, f0, funct) {
  if (funct.tag) {
    var e = funct[2];
    var ty = funct[1];
    var ty$prime = Curry._1(fty, ty);
    var e$prime = functor_smartmap(fty, f0, e);
    if (ty === ty$prime && e === e$prime) {
      return funct;
    } else {
      return /* MoreFunctor */Block.__(1, [
                funct[0],
                ty$prime,
                e$prime
              ]);
    }
  } else {
    var a = funct[0];
    var a$prime = Curry._1(f0, a);
    if (a === a$prime) {
      return funct;
    } else {
      return /* NoFunctor */Block.__(0, [a$prime]);
    }
  }
}

function functor_iter(fty, f0, _param) {
  while(true) {
    var param = _param;
    if (param.tag) {
      Curry._1(fty, param[1]);
      _param = param[2];
      continue ;
      
    } else {
      return Curry._1(f0, param[0]);
    }
  };
}

function module_type_of_module(mb) {
  return /* record */[
          /* mod_mp */mb[/* mod_mp */0],
          /* mod_expr : () */0,
          /* mod_type */mb[/* mod_type */2],
          /* mod_type_alg : None */0,
          /* mod_constraints */mb[/* mod_constraints */4],
          /* mod_delta */mb[/* mod_delta */5],
          /* mod_retroknowledge : ModTypeRK */0
        ];
}

function module_body_of_type(mp, mtb) {
  return /* record */[
          /* mod_mp */mp,
          /* mod_expr : Abstract */0,
          /* mod_type */mtb[/* mod_type */2],
          /* mod_type_alg */mtb[/* mod_type_alg */3],
          /* mod_constraints */mtb[/* mod_constraints */4],
          /* mod_delta */mtb[/* mod_delta */5],
          /* mod_retroknowledge : ModBodyRK */[/* [] */0]
        ];
}

function check_modpath_equiv(env, mp1, mp2) {
  if (Names$ReactTemplate.ModPath[/* equal */1](mp1, mp2)) {
    return /* () */0;
  } else {
    var mp1$prime = Mod_subst$ReactTemplate.mp_of_delta(Environ$ReactTemplate.lookup_module(mp1, env)[/* mod_delta */5], mp1);
    var mp2$prime = Mod_subst$ReactTemplate.mp_of_delta(Environ$ReactTemplate.lookup_module(mp2, env)[/* mod_delta */5], mp2);
    if (Names$ReactTemplate.ModPath[/* equal */1](mp1$prime, mp2$prime)) {
      return /* () */0;
    } else {
      var mp1$1 = mp1;
      var mp2$1 = mp2;
      throw [
            ModuleTypingError,
            /* NotEqualModulePaths */Block.__(4, [
                mp1$1,
                mp2$1
              ])
          ];
    }
  }
}

function implem_smartmap(fs, fa, impl) {
  if (typeof impl === "number") {
    return impl;
  } else if (impl.tag) {
    var e = impl[0];
    var e$prime = Curry._1(fs, e);
    if (e === e$prime) {
      return impl;
    } else {
      return /* Struct */Block.__(1, [e$prime]);
    }
  } else {
    var a = impl[0];
    var a$prime = Curry._1(fa, a);
    if (a === a$prime) {
      return impl;
    } else {
      return /* Algebraic */Block.__(0, [a$prime]);
    }
  }
}

function implem_iter(fs, fa, impl) {
  if (typeof impl === "number") {
    return /* () */0;
  } else if (impl.tag) {
    return Curry._1(fs, impl[0]);
  } else {
    return Curry._1(fa, impl[0]);
  }
}

function id_delta(x, _) {
  return x;
}

function subst_with_body(sub, orig) {
  if (orig.tag) {
    var match = orig[1];
    var c = match[0];
    var c$prime = Mod_subst$ReactTemplate.subst_mps(sub, c);
    if (c === c$prime) {
      return orig;
    } else {
      return /* WithDef */Block.__(1, [
                orig[0],
                /* tuple */[
                  c$prime,
                  match[1]
                ]
              ]);
    }
  } else {
    var mp = orig[1];
    var mp$prime = Mod_subst$ReactTemplate.subst_mp(sub, mp);
    if (mp === mp$prime) {
      return orig;
    } else {
      return /* WithMod */Block.__(0, [
                orig[0],
                mp$prime
              ]);
    }
  }
}

function subst_structure(sub, do_delta, sign) {
  var subst_body = function (orig) {
    var body = orig[1];
    var l = orig[0];
    switch (body.tag | 0) {
      case 0 : 
          var cb = body[0];
          var cb$prime = Declareops$ReactTemplate.subst_const_body(sub, cb);
          if (cb === cb$prime) {
            return orig;
          } else {
            return /* tuple */[
                    l,
                    /* SFBconst */Block.__(0, [cb$prime])
                  ];
          }
      case 1 : 
          var mib = body[0];
          var mib$prime = Declareops$ReactTemplate.subst_mind_body(sub, mib);
          if (mib === mib$prime) {
            return orig;
          } else {
            return /* tuple */[
                    l,
                    /* SFBmind */Block.__(1, [mib$prime])
                  ];
          }
      case 2 : 
          var mb = body[0];
          var mb$prime = subst_module(sub, do_delta, mb);
          if (mb === mb$prime) {
            return orig;
          } else {
            return /* tuple */[
                    l,
                    /* SFBmodule */Block.__(2, [mb$prime])
                  ];
          }
      case 3 : 
          var mtb = body[0];
          var mtb$prime = subst_modtype(sub, do_delta, mtb);
          if (mtb === mtb$prime) {
            return orig;
          } else {
            return /* tuple */[
                    l,
                    /* SFBmodtype */Block.__(3, [mtb$prime])
                  ];
          }
      
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* smartmap */65], subst_body, sign);
}

function subst_body(is_mod, sub, subst_impl, do_delta, mb) {
  var aty = mb[/* mod_type_alg */3];
  var ty = mb[/* mod_type */2];
  var me = mb[/* mod_expr */1];
  var mp = mb[/* mod_mp */0];
  var mp$prime = Mod_subst$ReactTemplate.subst_mp(sub, mp);
  var sub$1 = Names$ReactTemplate.ModPath[/* equal */1](mp, mp$prime) || is_mod && !is_functor(ty) ? sub : Mod_subst$ReactTemplate.add_mp(mp, mp$prime, Mod_subst$ReactTemplate.empty_delta_resolver, sub);
  var ty$prime = subst_signature(sub$1, do_delta)(ty);
  var me$prime = Curry._2(subst_impl, sub$1, me);
  var aty$prime = Option$ReactTemplate.smartmap(subst_expression(sub$1, id_delta), aty);
  var delta$prime = Curry._2(do_delta, mb[/* mod_delta */5], sub$1);
  if (mp === mp$prime && me === me$prime && ty === ty$prime && aty === aty$prime && delta$prime === mb[/* mod_delta */5]) {
    return mb;
  } else {
    return /* record */[
            /* mod_mp */mp$prime,
            /* mod_expr */me$prime,
            /* mod_type */ty$prime,
            /* mod_type_alg */aty$prime,
            /* mod_constraints */mb[/* mod_constraints */4],
            /* mod_delta */delta$prime,
            /* mod_retroknowledge */mb[/* mod_retroknowledge */6]
          ];
  }
}

function subst_module(sub, do_delta, mb) {
  return subst_body(/* true */1, sub, subst_impl, do_delta, mb);
}

function subst_impl(sub, me) {
  return implem_smartmap(subst_signature(sub, id_delta), subst_expression(sub, id_delta), me);
}

function subst_modtype(sub, do_delta, mtb) {
  return subst_body(/* false */0, sub, (function (_, _$1) {
                return /* () */0;
              }), do_delta, mtb);
}

function subst_expr(sub, do_delta, seb) {
  switch (seb.tag | 0) {
    case 0 : 
        var mp = seb[0];
        var mp$prime = Mod_subst$ReactTemplate.subst_mp(sub, mp);
        if (mp === mp$prime) {
          return seb;
        } else {
          return /* MEident */Block.__(0, [mp$prime]);
        }
    case 1 : 
        var mp2 = seb[1];
        var meb1 = seb[0];
        var meb1$prime = subst_expr(sub, do_delta, meb1);
        var mp2$prime = Mod_subst$ReactTemplate.subst_mp(sub, mp2);
        if (meb1 === meb1$prime && mp2 === mp2$prime) {
          return seb;
        } else {
          return /* MEapply */Block.__(1, [
                    meb1$prime,
                    mp2$prime
                  ]);
        }
    case 2 : 
        var wdb = seb[1];
        var meb = seb[0];
        var meb$prime = subst_expr(sub, do_delta, meb);
        var wdb$prime = subst_with_body(sub, wdb);
        if (meb === meb$prime && wdb === wdb$prime) {
          return seb;
        } else {
          return /* MEwith */Block.__(2, [
                    meb$prime,
                    wdb$prime
                  ]);
        }
    
  }
}

function subst_expression(sub, do_delta) {
  return (function (param) {
      return functor_smartmap((function (param) {
                    return subst_modtype(sub, do_delta, param);
                  }), (function (param) {
                    return subst_expr(sub, do_delta, param);
                  }), param);
    });
}

function subst_signature(sub, do_delta) {
  return (function (param) {
      return functor_smartmap((function (param) {
                    return subst_modtype(sub, do_delta, param);
                  }), (function (param) {
                    return subst_structure(sub, do_delta, param);
                  }), param);
    });
}

function do_delta_dom(reso, sub) {
  return Mod_subst$ReactTemplate.subst_dom_delta_resolver(sub, reso);
}

function do_delta_codom(reso, sub) {
  return Mod_subst$ReactTemplate.subst_codom_delta_resolver(sub, reso);
}

function do_delta_dom_codom(reso, sub) {
  return Mod_subst$ReactTemplate.subst_dom_codom_delta_resolver(sub, reso);
}

function subst_signature$1(subst) {
  return subst_signature(subst, do_delta_codom);
}

function subst_structure$1(subst) {
  return (function (param) {
      return subst_structure(subst, do_delta_codom, param);
    });
}

function add_retroknowledge() {
  var perform = function (rkaction, env) {
    var e = rkaction[1];
    if (Constr$ReactTemplate.isConst(e) || Constr$ReactTemplate.isInd(e)) {
      return Environ$ReactTemplate.register(env, rkaction[0], e);
    } else {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Modops.add_retroknowledge"], Pp$ReactTemplate.str("had to import an unsupported kind of term."));
    }
  };
  return (function (param) {
      var lclrk = param[0];
      return (function (env) {
          return Curry._3(Util$ReactTemplate.List[/* fold_right */14], perform, lclrk, env);
        });
    });
}

function add_structure(mp, sign, resolver, linkinfo, env) {
  var add_one = function (env, param) {
    var elem = param[1];
    var l = param[0];
    switch (elem.tag | 0) {
      case 0 : 
          var c = Mod_subst$ReactTemplate.constant_of_delta_kn(resolver, Names$ReactTemplate.KerName[/* make2 */1](mp, l));
          return Environ$ReactTemplate.add_constant_key(c, elem[0], linkinfo, env);
      case 1 : 
          var mib = elem[0];
          var mind = Mod_subst$ReactTemplate.mind_of_delta_kn(resolver, Names$ReactTemplate.KerName[/* make2 */1](mp, l));
          var mib$1;
          if (mib[/* mind_private */9] !== /* None */0) {
            var newrecord = mib.slice();
            newrecord[/* mind_private */9] = /* Some */[/* true */1];
            mib$1 = newrecord;
          } else {
            mib$1 = mib;
          }
          return Environ$ReactTemplate.add_mind_key(mind, /* tuple */[
                      mib$1,
                      [linkinfo]
                    ], env);
      case 2 : 
          return add_module(elem[0], linkinfo, env);
      case 3 : 
          return Environ$ReactTemplate.add_modtype(elem[0], env);
      
    }
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], add_one, env, sign);
}

function add_module(mb, linkinfo, env) {
  var mp = mb[/* mod_mp */0];
  var env$1 = Environ$ReactTemplate.shallow_add_module(mb, env);
  var match = mb[/* mod_type */2];
  if (match.tag) {
    return env$1;
  } else {
    return Curry._1(add_retroknowledge(mp)(mb[/* mod_retroknowledge */6]), add_structure(mp, match[0], mb[/* mod_delta */5], linkinfo, env$1));
  }
}

var add_linked_module = add_module;

function add_structure$1(mp, sign, resolver, env) {
  return add_structure(mp, sign, resolver, Environ$ReactTemplate.no_link_info, env);
}

function add_module$1(mb, env) {
  return add_module(mb, Environ$ReactTemplate.no_link_info, env);
}

function add_module_type(mp, mtb, env) {
  return add_module$1(module_body_of_type(mp, mtb), env);
}

function strengthen_const(mp_from, l, cb, resolver) {
  var match = cb[/* const_body */1];
  var exit = 0;
  switch (match.tag | 0) {
    case 1 : 
        return cb;
    case 0 : 
    case 2 : 
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    var kn = Names$ReactTemplate.KerName[/* make2 */1](mp_from, l);
    var con = Mod_subst$ReactTemplate.constant_of_delta_kn(resolver, kn);
    var match$1 = cb[/* const_universes */4];
    var u;
    u = match$1.tag ? Univ$ReactTemplate.make_abstract_instance(match$1[0]) : Univ$ReactTemplate.Instance[/* empty */0];
    var newrecord = cb.slice();
    newrecord[/* const_body */1] = /* Def */Block.__(1, [Mod_subst$ReactTemplate.from_val(Constr$ReactTemplate.mkConstU(/* tuple */[
                  con,
                  u
                ]))]);
    newrecord[/* const_body_code */3] = /* Some */[Cemitcodes$ReactTemplate.from_val(Cbytegen$ReactTemplate.compile_alias(con))];
    return newrecord;
  }
  
}

function strengthen_mod(mp_from, mp_to, mb) {
  if (Mod_subst$ReactTemplate.mp_in_delta(mb[/* mod_mp */0])(mb[/* mod_delta */5])) {
    return mb;
  } else {
    var match = mb[/* mod_type */2];
    if (match.tag) {
      return mb;
    } else {
      var match$1 = strengthen_sig(mp_from, match[0], mp_to, mb[/* mod_delta */5]);
      return /* record */[
              /* mod_mp */mb[/* mod_mp */0],
              /* mod_expr : Algebraic */Block.__(0, [/* NoFunctor */Block.__(0, [/* MEident */Block.__(0, [mp_to])])]),
              /* mod_type : NoFunctor */Block.__(0, [match$1[1]]),
              /* mod_type_alg */mb[/* mod_type_alg */3],
              /* mod_constraints */mb[/* mod_constraints */4],
              /* mod_delta */Mod_subst$ReactTemplate.add_mp_delta_resolver(mp_from, mp_to)(Mod_subst$ReactTemplate.add_delta_resolver(mb[/* mod_delta */5], match$1[0])),
              /* mod_retroknowledge */mb[/* mod_retroknowledge */6]
            ];
    }
  }
}

function strengthen_sig(mp_from, struc, mp_to, reso) {
  if (struc) {
    var item = struc[0];
    var match = item[1];
    var l = item[0];
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          var item$prime_001 = /* SFBconst */Block.__(0, [strengthen_const(mp_from, l, match[0], reso)]);
          var item$prime = /* tuple */[
            l,
            item$prime_001
          ];
          var match$1 = strengthen_sig(mp_from, struc[1], mp_to, reso);
          return /* tuple */[
                  match$1[0],
                  /* :: */[
                    item$prime,
                    match$1[1]
                  ]
                ];
      case 2 : 
          var mb = match[0];
          var mp_from$prime = /* MPdot */Block.__(2, [
              mp_from,
              l
            ]);
          var mp_to$prime = /* MPdot */Block.__(2, [
              mp_to,
              l
            ]);
          var mb$prime = strengthen_mod(mp_from$prime, mp_to$prime, mb);
          var item$prime_001$1 = /* SFBmodule */Block.__(2, [mb$prime]);
          var item$prime$1 = /* tuple */[
            l,
            item$prime_001$1
          ];
          var match$2 = strengthen_sig(mp_from, struc[1], mp_to, reso);
          return /* tuple */[
                  Mod_subst$ReactTemplate.add_delta_resolver(match$2[0], mb[/* mod_delta */5]),
                  /* :: */[
                    item$prime$1,
                    match$2[1]
                  ]
                ];
      case 1 : 
      case 3 : 
          exit = 1;
          break;
      
    }
    if (exit === 1) {
      var match$3 = strengthen_sig(mp_from, struc[1], mp_to, reso);
      return /* tuple */[
              match$3[0],
              /* :: */[
                item,
                match$3[1]
              ]
            ];
    }
    
  } else {
    return /* tuple */[
            Mod_subst$ReactTemplate.empty_delta_resolver,
            /* [] */0
          ];
  }
}

function strengthen(mtb, mp) {
  if (Mod_subst$ReactTemplate.mp_in_delta(mtb[/* mod_mp */0])(mtb[/* mod_delta */5])) {
    return mtb;
  } else {
    var match = mtb[/* mod_type */2];
    if (match.tag) {
      return mtb;
    } else {
      var match$1 = strengthen_sig(mtb[/* mod_mp */0], match[0], mp, mtb[/* mod_delta */5]);
      return /* record */[
              /* mod_mp */mtb[/* mod_mp */0],
              /* mod_expr */mtb[/* mod_expr */1],
              /* mod_type : NoFunctor */Block.__(0, [match$1[1]]),
              /* mod_type_alg */mtb[/* mod_type_alg */3],
              /* mod_constraints */mtb[/* mod_constraints */4],
              /* mod_delta */Mod_subst$ReactTemplate.add_delta_resolver(mtb[/* mod_delta */5], Mod_subst$ReactTemplate.add_mp_delta_resolver(mtb[/* mod_mp */0], mp)(match$1[0])),
              /* mod_retroknowledge */mtb[/* mod_retroknowledge */6]
            ];
    }
  }
}

function inline_delta_resolver(env, inl, mp, mbid, mtb, delta) {
  var constants = Mod_subst$ReactTemplate.inline_of_delta(inl, mtb[/* mod_delta */5]);
  var make_inline = function (delta, param) {
    if (param) {
      var match = param[0];
      var kn = Mod_subst$ReactTemplate.replace_mp_in_kn(/* MPbound */Block.__(1, [mbid]), mp, match[1]);
      var con = Mod_subst$ReactTemplate.constant_of_delta_kn(delta, kn);
      try {
        var constant = Environ$ReactTemplate.lookup_constant(con, env);
        var l = make_inline(delta, param[1]);
        var match$1 = constant[/* const_body */1];
        switch (match$1.tag | 0) {
          case 1 : 
              var constr = Mod_subst$ReactTemplate.force_constr(match$1[0]);
              return Mod_subst$ReactTemplate.add_inline_delta_resolver(kn, /* tuple */[
                            match[0],
                            /* Some */[constr]
                          ])(l);
          case 0 : 
          case 2 : 
              return l;
          
        }
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return error_no_such_label_sub(Names$ReactTemplate.Constant[/* label */8](con), Names$ReactTemplate.ModPath[/* to_string */4](Names$ReactTemplate.Constant[/* modpath */7](con)));
        } else {
          throw exn;
        }
      }
    } else {
      return delta;
    }
  };
  return make_inline(delta, constants);
}

function strengthen_and_subst_mod(mb, subst, mp_from, mp_to) {
  var match = mb[/* mod_type */2];
  if (match.tag) {
    var subst$1 = Mod_subst$ReactTemplate.add_mp(mb[/* mod_mp */0], mp_to, Mod_subst$ReactTemplate.empty_delta_resolver, subst);
    return subst_module(subst$1, do_delta_dom, mb);
  } else {
    var mb_is_an_alias = Mod_subst$ReactTemplate.mp_in_delta(mb[/* mod_mp */0])(mb[/* mod_delta */5]);
    if (mb_is_an_alias) {
      return subst_module(subst, do_delta_dom, mb);
    } else {
      var match$1 = strengthen_and_subst_struct(match[0], subst, mp_from, mp_to, /* false */0, /* false */0, mb[/* mod_delta */5]);
      return /* record */[
              /* mod_mp */mp_to,
              /* mod_expr : Algebraic */Block.__(0, [/* NoFunctor */Block.__(0, [/* MEident */Block.__(0, [mp_from])])]),
              /* mod_type : NoFunctor */Block.__(0, [match$1[1]]),
              /* mod_type_alg */mb[/* mod_type_alg */3],
              /* mod_constraints */mb[/* mod_constraints */4],
              /* mod_delta */Mod_subst$ReactTemplate.add_mp_delta_resolver(mp_to, mp_from)(match$1[0]),
              /* mod_retroknowledge */mb[/* mod_retroknowledge */6]
            ];
    }
  }
}

function strengthen_and_subst_struct(str, subst, mp_from, mp_to, alias, incl, reso) {
  if (str) {
    var item = str[0];
    var match = item[1];
    var l = item[0];
    switch (match.tag | 0) {
      case 0 : 
          var rest = str[1];
          var cb = match[0];
          var cb$prime = Declareops$ReactTemplate.subst_const_body(subst, cb);
          var cb$prime$1 = alias ? cb$prime : strengthen_const(mp_from, l, cb$prime, reso);
          var item$prime = cb$prime$1 === cb ? item : /* tuple */[
              l,
              /* SFBconst */Block.__(0, [cb$prime$1])
            ];
          var match$1 = strengthen_and_subst_struct(rest, subst, mp_from, mp_to, alias, incl, reso);
          var rest$prime = match$1[1];
          var reso$prime = match$1[0];
          var str$prime = rest$prime === rest && item$prime === item ? str : /* :: */[
              item$prime,
              rest$prime
            ];
          if (incl) {
            var kn_from = Names$ReactTemplate.KerName[/* make2 */1](mp_from, l);
            var kn_to = Names$ReactTemplate.KerName[/* make2 */1](mp_to, l);
            var old_name = Mod_subst$ReactTemplate.kn_of_delta(reso, kn_from);
            return /* tuple */[
                    Mod_subst$ReactTemplate.add_kn_delta_resolver(kn_to, old_name)(reso$prime),
                    str$prime
                  ];
          } else {
            return /* tuple */[
                    reso$prime,
                    str$prime
                  ];
          }
          break;
      case 1 : 
          var rest$1 = str[1];
          var mib = match[0];
          var mib$prime = Declareops$ReactTemplate.subst_mind_body(subst, mib);
          var item$prime$1 = mib$prime === mib ? item : /* tuple */[
              l,
              /* SFBmind */Block.__(1, [mib$prime])
            ];
          var match$2 = strengthen_and_subst_struct(rest$1, subst, mp_from, mp_to, alias, incl, reso);
          var rest$prime$1 = match$2[1];
          var reso$prime$1 = match$2[0];
          var str$prime$1 = rest$prime$1 === rest$1 && item$prime$1 === item ? str : /* :: */[
              item$prime$1,
              rest$prime$1
            ];
          if (incl) {
            var kn_from$1 = Names$ReactTemplate.KerName[/* make2 */1](mp_from, l);
            var kn_to$1 = Names$ReactTemplate.KerName[/* make2 */1](mp_to, l);
            var old_name$1 = Mod_subst$ReactTemplate.kn_of_delta(reso, kn_from$1);
            return /* tuple */[
                    Mod_subst$ReactTemplate.add_kn_delta_resolver(kn_to$1, old_name$1)(reso$prime$1),
                    str$prime$1
                  ];
          } else {
            return /* tuple */[
                    reso$prime$1,
                    str$prime$1
                  ];
          }
          break;
      case 2 : 
          var rest$2 = str[1];
          var mb = match[0];
          var mp_from$prime = /* MPdot */Block.__(2, [
              mp_from,
              l
            ]);
          var mp_to$prime = /* MPdot */Block.__(2, [
              mp_to,
              l
            ]);
          var mb$prime = alias ? subst_module(subst, do_delta_dom, mb) : strengthen_and_subst_mod(mb, subst, mp_from$prime, mp_to$prime);
          var item$prime$2 = mb$prime === mb ? item : /* tuple */[
              l,
              /* SFBmodule */Block.__(2, [mb$prime])
            ];
          var match$3 = strengthen_and_subst_struct(rest$2, subst, mp_from, mp_to, alias, incl, reso);
          var rest$prime$2 = match$3[1];
          var reso$prime$2 = match$3[0];
          var str$prime$2 = rest$prime$2 === rest$2 && item$prime$2 === item ? str : /* :: */[
              item$prime$2,
              rest$prime$2
            ];
          if (is_functor(mb$prime[/* mod_type */2])) {
            return /* tuple */[
                    Mod_subst$ReactTemplate.add_mp_delta_resolver(mp_to$prime, mp_to$prime)(reso$prime$2),
                    str$prime$2
                  ];
          } else {
            return /* tuple */[
                    Mod_subst$ReactTemplate.add_delta_resolver(reso$prime$2, mb$prime[/* mod_delta */5]),
                    str$prime$2
                  ];
          }
      case 3 : 
          var rest$3 = str[1];
          var mty = match[0];
          var mp_from$prime$1 = /* MPdot */Block.__(2, [
              mp_from,
              l
            ]);
          var mp_to$prime$1 = /* MPdot */Block.__(2, [
              mp_to,
              l
            ]);
          var subst$prime = Mod_subst$ReactTemplate.add_mp(mp_from$prime$1, mp_to$prime$1, Mod_subst$ReactTemplate.empty_delta_resolver, subst);
          var mty$prime = subst_modtype(subst$prime, (function (resolver, _) {
                  return Mod_subst$ReactTemplate.subst_dom_codom_delta_resolver(subst$prime, resolver);
                }), mty);
          var item$prime$3 = mty$prime === mty ? item : /* tuple */[
              l,
              /* SFBmodtype */Block.__(3, [mty$prime])
            ];
          var match$4 = strengthen_and_subst_struct(rest$3, subst, mp_from, mp_to, alias, incl, reso);
          var rest$prime$3 = match$4[1];
          var str$prime$3 = rest$prime$3 === rest$3 && item$prime$3 === item ? str : /* :: */[
              item$prime$3,
              rest$prime$3
            ];
          return /* tuple */[
                  Mod_subst$ReactTemplate.add_mp_delta_resolver(mp_to$prime$1, mp_to$prime$1)(match$4[0]),
                  str$prime$3
                ];
      
    }
  } else {
    return /* tuple */[
            Mod_subst$ReactTemplate.empty_delta_resolver,
            /* [] */0
          ];
  }
}

function strengthen_and_subst_mb(mb, mp, include_b) {
  var match = mb[/* mod_type */2];
  if (match.tag) {
    var subst = Mod_subst$ReactTemplate.map_mp(mb[/* mod_mp */0], mp, Mod_subst$ReactTemplate.empty_delta_resolver);
    return subst_module(subst, do_delta_dom_codom, mb);
  } else {
    var mb_is_an_alias = Mod_subst$ReactTemplate.mp_in_delta(mb[/* mod_mp */0])(mb[/* mod_delta */5]);
    var mp_alias = Mod_subst$ReactTemplate.mp_of_delta(mb[/* mod_delta */5], mb[/* mod_mp */0]);
    var subst_resolver = Mod_subst$ReactTemplate.map_mp(mb[/* mod_mp */0], mp, Mod_subst$ReactTemplate.empty_delta_resolver);
    var new_resolver = Mod_subst$ReactTemplate.add_mp_delta_resolver(mp, mp_alias)(Mod_subst$ReactTemplate.subst_dom_delta_resolver(subst_resolver, mb[/* mod_delta */5]));
    var subst$1 = Mod_subst$ReactTemplate.map_mp(mb[/* mod_mp */0], mp, new_resolver);
    var match$1 = strengthen_and_subst_struct(match[0], subst$1, mb[/* mod_mp */0], mp, mb_is_an_alias, include_b, mb[/* mod_delta */5]);
    var reso$prime = match$1[0];
    return /* record */[
            /* mod_mp */mp,
            /* mod_expr : Algebraic */Block.__(0, [/* NoFunctor */Block.__(0, [/* MEident */Block.__(0, [mb[/* mod_mp */0]])])]),
            /* mod_type : NoFunctor */Block.__(0, [match$1[1]]),
            /* mod_type_alg */mb[/* mod_type_alg */3],
            /* mod_constraints */mb[/* mod_constraints */4],
            /* mod_delta */include_b ? reso$prime : Mod_subst$ReactTemplate.add_delta_resolver(new_resolver, reso$prime),
            /* mod_retroknowledge */mb[/* mod_retroknowledge */6]
          ];
  }
}

function subst_modtype_and_resolver(mtb, mp) {
  var subst = Mod_subst$ReactTemplate.map_mp(mtb[/* mod_mp */0], mp, Mod_subst$ReactTemplate.empty_delta_resolver);
  var new_delta = Mod_subst$ReactTemplate.subst_dom_codom_delta_resolver(subst, mtb[/* mod_delta */5]);
  var full_subst = Mod_subst$ReactTemplate.map_mp(mtb[/* mod_mp */0], mp, new_delta);
  return subst_modtype(full_subst, do_delta_dom_codom, mtb);
}

function is_bounded_expr(l, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          var match = param[0];
          switch (match.tag | 0) {
            case 1 : 
                return Curry._2(Names$ReactTemplate.MBIset[/* mem */2], match[0], l);
            case 0 : 
            case 2 : 
                return /* false */0;
            
          }
          break;
      case 1 : 
          if (is_bounded_expr(l, /* MEident */Block.__(0, [param[1]]))) {
            return /* true */1;
          } else {
            _param = param[0];
            continue ;
            
          }
          break;
      case 2 : 
          return /* false */0;
      
    }
  };
}

function clean_module_body(l, mb) {
  var impl = mb[/* mod_expr */1];
  var typ = mb[/* mod_type */2];
  var typ$prime = clean_signature(l)(typ);
  var impl$prime;
  var exit = 0;
  if (typeof impl === "number") {
    exit = 1;
  } else if (impl.tag) {
    exit = 1;
  } else {
    var match = impl[0];
    if (!match.tag && is_bounded_expr(l, match[0])) {
      impl$prime = /* FullStruct */1;
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    impl$prime = implem_smartmap(clean_signature(l), (function (param) {
            return functor_smartmap((function (param) {
                          return clean_module_type(l, param);
                        }), (function (me) {
                          return me;
                        }), param);
          }), impl);
  }
  if (typ === typ$prime && impl === impl$prime) {
    return mb;
  } else {
    return /* record */[
            /* mod_mp */mb[/* mod_mp */0],
            /* mod_expr */impl$prime,
            /* mod_type */typ$prime,
            /* mod_type_alg */mb[/* mod_type_alg */3],
            /* mod_constraints */mb[/* mod_constraints */4],
            /* mod_delta */mb[/* mod_delta */5],
            /* mod_retroknowledge */mb[/* mod_retroknowledge */6]
          ];
  }
}

function clean_module_type(l, mb) {
  var match_000 = mb[/* mod_expr */1];
  var match_001 = mb[/* mod_type */2];
  var typ = match_001;
  var typ$prime = clean_signature(l)(typ);
  if (typ === typ$prime) {
    return mb;
  } else {
    var newrecord = mb.slice();
    newrecord[/* mod_type */2] = typ$prime;
    return newrecord;
  }
}

function clean_field(l, field) {
  var match = field[1];
  if (match.tag === 2) {
    var mb = match[0];
    var mb$prime = clean_module_body(l, mb);
    if (mb === mb$prime) {
      return field;
    } else {
      return /* tuple */[
              field[0],
              /* SFBmodule */Block.__(2, [mb$prime])
            ];
    }
  } else {
    return field;
  }
}

function clean_signature(l) {
  var partial_arg = Curry._1(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
          return clean_field(l, param);
        }));
  return (function (param) {
      return functor_smartmap((function (param) {
                    return clean_module_type(l, param);
                  }), partial_arg, param);
    });
}

function collect_mbid(l, sign) {
  if (sign.tag) {
    var m = sign[2];
    var mbid = sign[0];
    var m$prime = collect_mbid(Curry._2(Names$ReactTemplate.MBIset[/* add */3], mbid, l), m);
    if (m === m$prime) {
      return sign;
    } else {
      return /* MoreFunctor */Block.__(1, [
                mbid,
                sign[1],
                m$prime
              ]);
    }
  } else {
    var struc = sign[0];
    var struc$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
            return clean_field(l, param);
          }), struc);
    if (struc === struc$prime) {
      return sign;
    } else {
      return /* NoFunctor */Block.__(0, [struc$prime]);
    }
  }
}

function clean_bounded_mod_expr(sign) {
  if (is_functor(sign)) {
    return collect_mbid(Names$ReactTemplate.MBIset[/* empty */0], sign);
  } else {
    return sign;
  }
}

function join_structure(except, otab, s) {
  var join_module = function (mb) {
    Option$ReactTemplate.iter(join_expression, mb[/* mod_type_alg */3]);
    return functor_iter(join_module, join_structure$1, mb[/* mod_type */2]);
  };
  var join_field = function (param) {
    var body = param[1];
    switch (body.tag | 0) {
      case 0 : 
          var except$1 = except;
          var otab$1 = otab;
          var cb = body[0];
          var match = cb[/* const_body */1];
          switch (match.tag | 0) {
            case 0 : 
            case 1 : 
                return /* () */0;
            case 2 : 
                var o = match[0];
                var match$1 = Opaqueproof$ReactTemplate.uuid_opaque(otab$1, o);
                if (match$1 && !Curry._2(Future$ReactTemplate.UUIDSet[/* mem */2], match$1[0], except$1)) {
                  return Opaqueproof$ReactTemplate.join_opaque(otab$1, o);
                } else {
                  return /* () */0;
                }
            
          }
      case 1 : 
          return /* () */0;
      case 2 : 
          var m = body[0];
          implem_iter(join_signature, join_expression, m[/* mod_expr */1]);
          return join_module(m);
      case 3 : 
          return join_module(body[0]);
      
    }
  };
  var join_structure$1 = function (struc) {
    return Curry._2(Util$ReactTemplate.List[/* iter */9], join_field, struc);
  };
  var join_signature = function (sign) {
    return functor_iter(join_module, join_structure$1, sign);
  };
  var join_expression = function (me) {
    return functor_iter(join_module, (function () {
                  return /* () */0;
                }), me);
  };
  return Curry._2(Util$ReactTemplate.List[/* iter */9], join_field, s);
}

exports.is_functor = is_functor;
exports.destr_functor = destr_functor;
exports.destr_nofunctor = destr_nofunctor;
exports.module_type_of_module = module_type_of_module;
exports.module_body_of_type = module_body_of_type;
exports.check_modpath_equiv = check_modpath_equiv;
exports.implem_smartmap = implem_smartmap;
exports.subst_signature = subst_signature$1;
exports.subst_structure = subst_structure$1;
exports.add_structure = add_structure$1;
exports.add_module = add_module$1;
exports.add_linked_module = add_linked_module;
exports.add_module_type = add_module_type;
exports.strengthen = strengthen;
exports.inline_delta_resolver = inline_delta_resolver;
exports.strengthen_and_subst_mb = strengthen_and_subst_mb;
exports.subst_modtype_and_resolver = subst_modtype_and_resolver;
exports.clean_bounded_mod_expr = clean_bounded_mod_expr;
exports.join_structure = join_structure;
exports.ModuleTypingError = ModuleTypingError;
exports.error_existing_label = error_existing_label;
exports.error_incompatible_modtypes = error_incompatible_modtypes;
exports.error_signature_mismatch = error_signature_mismatch;
exports.error_incompatible_labels = error_incompatible_labels;
exports.error_no_such_label = error_no_such_label;
exports.error_not_a_module = error_not_a_module;
exports.error_not_a_constant = error_not_a_constant;
exports.error_incorrect_with_constraint = error_incorrect_with_constraint;
exports.error_generative_module_expected = error_generative_module_expected;
exports.error_no_such_label_sub = error_no_such_label_sub;
exports.error_include_restricted_functor = error_include_restricted_functor;
/* Pp-ReactTemplate Not a pure module */
