// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Dyn$ReactTemplate = require("./dyn.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var DYN = Dyn$ReactTemplate.Make(/* module */[]);

var eq = DYN[/* eq */1];

var repr = DYN[/* repr */2];

var create = DYN[/* create */0];

function name(s) {
  var match = Curry._1(DYN[/* name */3], s);
  if (match) {
    return /* Some */[/* Any */[match[0][0]]];
  } else {
    return /* None */0;
  }
}

function genarg_type_eq(t1, t2) {
  switch (t1.tag | 0) {
    case 0 : 
        if (t2.tag) {
          return /* None */0;
        } else {
          return Curry._2(eq, t1[0], t2[0]);
        }
        break;
    case 1 : 
        if (t2.tag === 1) {
          var match = genarg_type_eq(t1[0], t2[0]);
          if (match) {
            return /* Some */[/* Refl */0];
          } else {
            return /* None */0;
          }
        } else {
          return /* None */0;
        }
        break;
    case 2 : 
        if (t2.tag === 2) {
          var match$1 = genarg_type_eq(t1[0], t2[0]);
          if (match$1) {
            return /* Some */[/* Refl */0];
          } else {
            return /* None */0;
          }
        } else {
          return /* None */0;
        }
        break;
    case 3 : 
        if (t2.tag === 3) {
          var match$2 = genarg_type_eq(t1[0], t2[0]);
          if (match$2) {
            var match$3 = genarg_type_eq(t1[1], t2[1]);
            if (match$3) {
              return /* Some */[/* Refl */0];
            } else {
              return /* None */0;
            }
          } else {
            return /* None */0;
          }
        } else {
          return /* None */0;
        }
        break;
    
  }
}

function pr_genarg_type(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.str(Curry._1(repr, param[0]));
    case 1 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_genarg_type(param[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("list"));
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_genarg_type(param[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("opt"));
    case 3 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_genarg_type(param[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("*")), Pp$ReactTemplate.spc(/* () */0)), pr_genarg_type(param[1])), Pp$ReactTemplate.str(")"));
    
  }
}

function argument_type_eq(arg1, arg2) {
  var match = genarg_type_eq(arg1[0], arg2[0]);
  if (match) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function pr_argument_type(param) {
  return pr_genarg_type(param[0]);
}

function rawwit(t) {
  return /* Rawwit */Block.__(0, [t]);
}

function glbwit(t) {
  return /* Glbwit */Block.__(1, [t]);
}

function topwit(t) {
  return /* Topwit */Block.__(2, [t]);
}

function wit_list(t) {
  return /* ListArg */Block.__(1, [t]);
}

function wit_opt(t) {
  return /* OptArg */Block.__(2, [t]);
}

function wit_pair(t1, t2) {
  return /* PairArg */Block.__(3, [
            t1,
            t2
          ]);
}

function in_gen(t, o) {
  return /* GenArg */[
          t,
          o
        ];
}

function abstract_argument_type_eq(t1, t2) {
  var match = genarg_type_eq(t1[0], t2[0]);
  if (match) {
    return /* Some */[/* Refl */0];
  } else {
    return /* None */0;
  }
}

function out_gen(t, o) {
  var match = abstract_argument_type_eq(t, o[0]);
  if (match) {
    return o[1];
  } else {
    return Pervasives.failwith("out_gen");
  }
}

function has_type(param, u) {
  var match = abstract_argument_type_eq(param[0], u);
  if (match) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function unquote(param) {
  return /* ArgumentType */[param[0]];
}

function genarg_tag(param) {
  return unquote(param[0]);
}

function create_arg(name$1) {
  var match = name(name$1);
  if (match) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("generic argument already declared: "), Pp$ReactTemplate.str(name$1)), Pp$ReactTemplate.str(".")));
  } else {
    return /* ExtraArg */Block.__(0, [Curry._1(create, name$1)]);
  }
}

function get_arg_tag(param) {
  if (param.tag) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "genarg.ml",
            179,
            7
          ]
        ];
  } else {
    return param[0];
  }
}

var ArgT = [
  eq,
  repr,
  name
];

var make0 = create_arg;

function Register(funarg) {
  var include = Curry._1(DYN[/* Map */4], /* module */[]);
  var add = include[1];
  var find = include[3];
  var mem = include[4];
  var arg0_map = [include[0]];
  var register0 = function (arg, f) {
    var s = get_arg_tag(arg);
    if (Curry._2(mem, s, arg0_map[0])) {
      var msg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(funarg[/* name */0]), Pp$ReactTemplate.str(" function already registered: ")), Pp$ReactTemplate.str(Curry._1(repr, s))), Pp$ReactTemplate.str("."));
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, msg);
    } else {
      arg0_map[0] = Curry._3(add, s, /* Pack */[f], arg0_map[0]);
      return /* () */0;
    }
  };
  var obj = function (t) {
    var name = get_arg_tag(t);
    try {
      return Curry._2(find, name, arg0_map[0])[0];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var match = Curry._1(funarg[/* default */1], /* ExtraArg */Block.__(0, [name]));
        if (match) {
          return match[0];
        } else {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(funarg[/* name */0]), Pp$ReactTemplate.str(" function not found: ")), Pp$ReactTemplate.str(Curry._1(repr, name))), Pp$ReactTemplate.str(".")));
        }
      } else {
        throw exn;
      }
    }
  };
  return [
          register0,
          obj
        ];
}

exports.ArgT = ArgT;
exports.make0 = make0;
exports.create_arg = create_arg;
exports.rawwit = rawwit;
exports.glbwit = glbwit;
exports.topwit = topwit;
exports.in_gen = in_gen;
exports.out_gen = out_gen;
exports.has_type = has_type;
exports.argument_type_eq = argument_type_eq;
exports.genarg_type_eq = genarg_type_eq;
exports.abstract_argument_type_eq = abstract_argument_type_eq;
exports.pr_argument_type = pr_argument_type;
exports.genarg_tag = genarg_tag;
exports.unquote = unquote;
exports.get_arg_tag = get_arg_tag;
exports.Register = Register;
exports.wit_list = wit_list;
exports.wit_opt = wit_opt;
exports.wit_pair = wit_pair;
/* DYN Not a pure module */
