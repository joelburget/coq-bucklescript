// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Miscops$ReactTemplate = require("./miscops.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");

function case_info_pattern_eq(i1, i2) {
  if (i1[/* cip_style */0] === i2[/* cip_style */0] && Option$ReactTemplate.equal(Names$ReactTemplate.eq_ind, i1[/* cip_ind */1], i2[/* cip_ind */1]) && Option$ReactTemplate.equal(Curry._1(Util$ReactTemplate.List[/* equal */44], (function (prim, prim$1) {
                return +(prim === prim$1);
              })), i1[/* cip_ind_tags */2], i2[/* cip_ind_tags */2])) {
    return +(i1[/* cip_extensible */3] === i2[/* cip_extensible */3]);
  } else {
    return /* false */0;
  }
}

function constr_pattern_eq(_p1, _p2) {
  while(true) {
    var p2 = _p2;
    var p1 = _p1;
    switch (p1.tag | 0) {
      case 0 : 
          if (p2.tag) {
            return /* false */0;
          } else {
            return Globnames$ReactTemplate.eq_gr(p1[0], p2[0]);
          }
          break;
      case 1 : 
          if (p2.tag === 1) {
            return Names$ReactTemplate.Id[/* equal */0](p1[0], p2[0]);
          } else {
            return /* false */0;
          }
          break;
      case 2 : 
          if (p2.tag === 2 && Evar$ReactTemplate.equal(p1[0], p2[0])) {
            return Util$ReactTemplate.$$Array[/* equal */21](constr_pattern_eq, p1[1], p2[1]);
          } else {
            return /* false */0;
          }
          break;
      case 3 : 
          if (p2.tag === 3) {
            return +(p1[0] === p2[0]);
          } else {
            return /* false */0;
          }
          break;
      case 4 : 
          if (p2.tag === 4 && constr_pattern_eq(p1[0], p2[0])) {
            return Util$ReactTemplate.$$Array[/* equal */21](constr_pattern_eq, p1[1], p2[1]);
          } else {
            return /* false */0;
          }
          break;
      case 5 : 
          if (p2.tag === 5 && Names$ReactTemplate.Id[/* equal */0](p1[0], p2[0])) {
            return Curry._3(Util$ReactTemplate.List[/* equal */44], constr_pattern_eq, p1[1], p2[1]);
          } else {
            return /* false */0;
          }
          break;
      case 6 : 
          if (p2.tag === 6) {
            if (Names$ReactTemplate.Projection[/* equal */5](p1[0], p2[0])) {
              _p2 = p2[1];
              _p1 = p1[1];
              continue ;
              
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 7 : 
          if (p2.tag === 7) {
            if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], p1[0], p2[0])) {
              if (constr_pattern_eq(p1[1], p2[1])) {
                _p2 = p2[2];
                _p1 = p1[2];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 8 : 
          if (p2.tag === 8) {
            if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], p1[0], p2[0])) {
              if (constr_pattern_eq(p1[1], p2[1])) {
                _p2 = p2[2];
                _p1 = p1[2];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 9 : 
          if (p2.tag === 9) {
            if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], p1[0], p2[0])) {
              if (constr_pattern_eq(p1[1], p2[1])) {
                if (Option$ReactTemplate.equal(constr_pattern_eq, p1[2], p2[2])) {
                  _p2 = p2[3];
                  _p1 = p1[3];
                  continue ;
                  
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 10 : 
          if (p2.tag === 10) {
            return Miscops$ReactTemplate.glob_sort_eq(p1[0], p2[0]);
          } else {
            return /* false */0;
          }
          break;
      case 11 : 
          if (p2.tag === 11) {
            return Option$ReactTemplate.equal(Names$ReactTemplate.Id[/* equal */0], p1[0], p2[0]);
          } else {
            return /* false */0;
          }
          break;
      case 12 : 
          if (p2.tag === 12) {
            if (constr_pattern_eq(p1[0], p2[0])) {
              if (constr_pattern_eq(p1[1], p2[1])) {
                _p2 = p2[2];
                _p1 = p1[2];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 13 : 
          if (p2.tag === 13 && case_info_pattern_eq(p1[0], p2[0]) && constr_pattern_eq(p1[1], p2[1]) && constr_pattern_eq(p1[2], p2[2])) {
            return Curry._3(Util$ReactTemplate.List[/* equal */44], pattern_eq, p1[3], p2[3]);
          } else {
            return /* false */0;
          }
          break;
      case 14 : 
          if (p2.tag === 14) {
            var param = p1[0];
            var param$1 = p2[0];
            var match = param$1[0];
            var match$1 = param[0];
            if (match$1[1] === match[1] && Util$ReactTemplate.$$Array[/* equal */21]((function (prim, prim$1) {
                      return +(prim === prim$1);
                    }), match$1[0], match[0])) {
              return rec_declaration_eq(param[1], param$1[1]);
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 15 : 
          if (p2.tag === 15) {
            var param$2 = p1[0];
            var param$3 = p2[0];
            if (param$2[0] === param$3[0]) {
              return rec_declaration_eq(param$2[1], param$3[1]);
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      
    }
  };
}

function pattern_eq(param, param$1) {
  if (param[0] === param$1[0] && Curry._3(Util$ReactTemplate.List[/* equal */44], (function (prim, prim$1) {
            return +(prim === prim$1);
          }), param[1], param$1[1])) {
    return constr_pattern_eq(param[2], param$1[2]);
  } else {
    return /* false */0;
  }
}

function rec_declaration_eq(param, param$1) {
  if (Util$ReactTemplate.$$Array[/* equal */21](Nameops$ReactTemplate.Name[/* equal */4], param[0], param$1[0]) && Util$ReactTemplate.$$Array[/* equal */21](Constr$ReactTemplate.equal, param[1], param$1[1])) {
    return Util$ReactTemplate.$$Array[/* equal */21](Constr$ReactTemplate.equal, param[2], param$1[2]);
  } else {
    return /* false */0;
  }
}

function occur_meta_pattern(_param) {
  while(true) {
    var param = _param;
    var exit = 0;
    switch (param.tag | 0) {
      case 4 : 
          if (occur_meta_pattern(param[0])) {
            return /* true */1;
          } else {
            return Util$ReactTemplate.$$Array[/* exists */24](occur_meta_pattern, param[1]);
          }
      case 6 : 
          _param = param[1];
          continue ;
          case 7 : 
      case 8 : 
          exit = 1;
          break;
      case 9 : 
          if (Option$ReactTemplate.fold_left((function (b, t) {
                    if (b) {
                      return /* true */1;
                    } else {
                      return occur_meta_pattern(t);
                    }
                  }), occur_meta_pattern(param[1]), param[2])) {
            return /* true */1;
          } else {
            _param = param[3];
            continue ;
            
          }
          break;
      case 5 : 
      case 11 : 
          return /* true */1;
      case 12 : 
          if (occur_meta_pattern(param[0])) {
            return /* true */1;
          } else if (occur_meta_pattern(param[1])) {
            return /* true */1;
          } else {
            _param = param[2];
            continue ;
            
          }
          break;
      case 13 : 
          if (occur_meta_pattern(param[1]) || occur_meta_pattern(param[2])) {
            return /* true */1;
          } else {
            return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                          return occur_meta_pattern(param[2]);
                        }), param[3]);
          }
      default:
        return /* false */0;
    }
    if (exit === 1) {
      if (occur_meta_pattern(param[1])) {
        return /* true */1;
      } else {
        _param = param[2];
        continue ;
        
      }
    }
    
  };
}

function occurn_pattern(_n, _param) {
  while(true) {
    var param = _param;
    var n = _n;
    var exit = 0;
    switch (param.tag | 0) {
      case 2 : 
          return Util$ReactTemplate.$$Array[/* exists */24]((function(n){
                    return function (param) {
                      return occurn_pattern(n, param);
                    }
                    }(n)), param[1]);
      case 3 : 
          return +(n === param[0]);
      case 4 : 
          if (occurn_pattern(n, param[0])) {
            return /* true */1;
          } else {
            return Util$ReactTemplate.$$Array[/* exists */24]((function(n){
                      return function (param) {
                        return occurn_pattern(n, param);
                      }
                      }(n)), param[1]);
          }
      case 6 : 
          _param = param[1];
          continue ;
          case 7 : 
      case 8 : 
          exit = 1;
          break;
      case 9 : 
          if (Option$ReactTemplate.fold_left((function(n){
                return function (b, t) {
                  if (b) {
                    return /* true */1;
                  } else {
                    return occurn_pattern(n, t);
                  }
                }
                }(n)), occurn_pattern(n, param[1]), param[2])) {
            return /* true */1;
          } else {
            _param = param[3];
            _n = n + 1 | 0;
            continue ;
            
          }
          break;
      case 5 : 
      case 11 : 
          return /* true */1;
      case 12 : 
          if (occurn_pattern(n, param[0])) {
            return /* true */1;
          } else if (occurn_pattern(n, param[1])) {
            return /* true */1;
          } else {
            _param = param[2];
            continue ;
            
          }
          break;
      case 13 : 
          if (occurn_pattern(n, param[1]) || occurn_pattern(n, param[2])) {
            return /* true */1;
          } else {
            return Curry._2(Util$ReactTemplate.List[/* exists */21], (function(n){
                      return function (param) {
                        return occurn_pattern(n, param[2]);
                      }
                      }(n)), param[3]);
          }
      case 14 : 
          return 1 - Vars$ReactTemplate.noccurn(n, Constr$ReactTemplate.mkFix(param[0]));
      case 15 : 
          return 1 - Vars$ReactTemplate.noccurn(n, Constr$ReactTemplate.mkCoFix(param[0]));
      default:
        return /* false */0;
    }
    if (exit === 1) {
      if (occurn_pattern(n, param[1])) {
        return /* true */1;
      } else {
        _param = param[2];
        _n = n + 1 | 0;
        continue ;
        
      }
    }
    
  };
}

function noccurn_pattern(n, c) {
  return 1 - occurn_pattern(n, c);
}

var BoundPattern = Caml_exceptions.create("Patternops-ReactTemplate.BoundPattern");

function head_pattern_bound(_t) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          return t[0];
      case 1 : 
          return /* VarRef */Block.__(0, [t[0]]);
      case 7 : 
          throw BoundPattern;
      case 9 : 
          _t = t[3];
          continue ;
          case 4 : 
      case 12 : 
          _t = t[0];
          continue ;
          case 8 : 
      case 13 : 
          _t = t[2];
          continue ;
          case 15 : 
          return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["head_pattern_bound"], Pp$ReactTemplate.str("not a type."));
      default:
        throw BoundPattern;
    }
  };
}

function head_of_constr_reference(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 1 : 
        return /* VarRef */Block.__(0, [match[0]]);
    case 10 : 
        return /* ConstRef */Block.__(1, [match[0][0]]);
    case 11 : 
        return /* IndRef */Block.__(2, [match[0][0]]);
    case 12 : 
        return /* ConstructRef */Block.__(3, [match[0][0]]);
    default:
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not a rigid reference."));
  }
}

function pattern_of_constr(env, sigma, t) {
  var pattern_of_constr$1 = function (env, _t) {
    while(true) {
      var t = _t;
      var match = Constr$ReactTemplate.kind(t);
      switch (match.tag | 0) {
        case 0 : 
            return /* PRel */Block.__(3, [match[0]]);
        case 1 : 
            return /* PVar */Block.__(1, [match[0]]);
        case 2 : 
            return /* PMeta */Block.__(11, [/* Some */[Names$ReactTemplate.Id[/* of_string */5]("META" + Pervasives.string_of_int(match[0]))]]);
        case 3 : 
            var ev = match[0];
            var evk = ev[0];
            var match$1 = Evd$ReactTemplate.evar_source(evk, sigma)[1];
            var exit = 0;
            if (typeof match$1 === "number") {
              if (match$1 === 1) {
                exit = 1;
              } else {
                return /* PMeta */Block.__(11, [/* None */0]);
              }
            } else {
              switch (match$1.tag | 0) {
                case 6 : 
                    var match$2 = match$1[0];
                    if (match$2.tag) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "patternops.ml",
                              197,
                              69
                            ]
                          ];
                    } else {
                      return /* PMeta */Block.__(11, [/* Some */[match$2[0]]]);
                    }
                    break;
                case 7 : 
                    exit = 1;
                    break;
                default:
                  return /* PMeta */Block.__(11, [/* None */0]);
              }
            }
            if (exit === 1) {
              if (Evd$ReactTemplate.is_defined(sigma, evk)) {
                _t = Evd$ReactTemplate.existential_value(sigma, ev);
                continue ;
                
              } else {
                return /* PEvar */Block.__(2, [
                          evk,
                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                  return pattern_of_constr$1(env, param);
                                }), ev[1])
                        ]);
              }
            }
            break;
        case 4 : 
            var match$3 = match[0];
            if (match$3.tag) {
              return /* PSort */Block.__(10, [/* GType */[/* [] */0]]);
            } else if (match$3[0] !== 0) {
              return /* PSort */Block.__(10, [/* GProp */0]);
            } else {
              return /* PSort */Block.__(10, [/* GSet */1]);
            }
            break;
        case 5 : 
            _t = match[0];
            continue ;
            case 6 : 
            var c = match[1];
            var na = match[0];
            return /* PProd */Block.__(8, [
                      na,
                      pattern_of_constr$1(env, c),
                      pattern_of_constr$1(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                  na,
                                  c
                                ]), env), match[2])
                    ]);
        case 7 : 
            var c$1 = match[1];
            var na$1 = match[0];
            return /* PLambda */Block.__(7, [
                      na$1,
                      pattern_of_constr$1(env, c$1),
                      pattern_of_constr$1(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                  na$1,
                                  c$1
                                ]), env), match[2])
                    ]);
        case 8 : 
            var t$1 = match[2];
            var c$2 = match[1];
            var na$2 = match[0];
            return /* PLetIn */Block.__(9, [
                      na$2,
                      pattern_of_constr$1(env, c$2),
                      /* Some */[pattern_of_constr$1(env, t$1)],
                      pattern_of_constr$1(Environ$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                                  na$2,
                                  c$2,
                                  t$1
                                ]), env), match[3])
                    ]);
        case 9 : 
            var a = match[1];
            var f = match[0];
            var match$4 = Constr$ReactTemplate.kind(f);
            var match$5;
            if (match$4.tag === 3) {
              var match$6 = Evd$ReactTemplate.evar_source(match$4[0][0], sigma)[1];
              if (typeof match$6 === "number") {
                match$5 = /* None */0;
              } else if (match$6.tag === 6) {
                var match$7 = match$6[0];
                match$5 = match$7.tag ? /* Some */[match$7[0]] : /* None */0;
              } else {
                match$5 = /* None */0;
              }
            } else {
              match$5 = /* None */0;
            }
            if (match$5) {
              return /* PSoApp */Block.__(5, [
                        match$5[0],
                        Util$ReactTemplate.$$Array[/* to_list */9](Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                    return pattern_of_constr$1(env, param);
                                  }), a))
                      ]);
            } else {
              return /* PApp */Block.__(4, [
                        pattern_of_constr$1(env, f),
                        Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                return pattern_of_constr$1(env, param);
                              }), a)
                      ]);
            }
        case 10 : 
            return /* PRef */Block.__(0, [/* ConstRef */Block.__(1, [Names$ReactTemplate.Constant[/* make1 */1](Names$ReactTemplate.Constant[/* canonical */5](match[0][0]))])]);
        case 11 : 
            return /* PRef */Block.__(0, [Globnames$ReactTemplate.canonical_gr(/* IndRef */Block.__(2, [match[0][0]]))]);
        case 12 : 
            return /* PRef */Block.__(0, [Globnames$ReactTemplate.canonical_gr(/* ConstructRef */Block.__(3, [match[0][0]]))]);
        case 13 : 
            var ci = match[0];
            var cip_000 = /* cip_style */ci[/* ci_pp_info */4][/* style */2];
            var cip_001 = /* cip_ind : Some */[ci[/* ci_ind */0]];
            var cip_002 = /* cip_ind_tags : Some */[ci[/* ci_pp_info */4][/* ind_tags */0]];
            var cip = /* record */[
              cip_000,
              cip_001,
              cip_002,
              /* cip_extensible : false */0
            ];
            var branch_of_constr = (function(ci){
            return function branch_of_constr(i, c) {
              return /* tuple */[
                      i,
                      Caml_array.caml_array_get(ci[/* ci_pp_info */4][/* cstr_tags */1], i),
                      pattern_of_constr$1(env, c)
                    ];
            }
            }(ci));
            return /* PCase */Block.__(13, [
                      cip,
                      pattern_of_constr$1(env, match[1]),
                      pattern_of_constr$1(env, match[2]),
                      Util$ReactTemplate.$$Array[/* to_list */9](Util$ReactTemplate.$$Array[/* mapi */14](branch_of_constr, match[3]))
                    ]);
        case 14 : 
            return /* PFix */Block.__(14, [match[0]]);
        case 15 : 
            return /* PCoFix */Block.__(15, [match[0]]);
        case 16 : 
            _t = EConstr$ReactTemplate.Unsafe[/* to_constr */0](Retyping$ReactTemplate.expand_projection(env, sigma, match[0], EConstr$ReactTemplate.of_constr(match[1]), /* [] */0));
            continue ;
            
      }
    };
  };
  return pattern_of_constr$1(env, t);
}

function map_pattern_with_binders(g, f, l, x) {
  switch (x.tag | 0) {
    case 4 : 
        return /* PApp */Block.__(4, [
                  Curry._2(f, l, x[0]),
                  Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, l), x[1])
                ]);
    case 5 : 
        return /* PSoApp */Block.__(5, [
                  x[0],
                  Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(f, l), x[1])
                ]);
    case 6 : 
        return /* PProj */Block.__(6, [
                  x[0],
                  Curry._2(f, l, x[1])
                ]);
    case 7 : 
        var n = x[0];
        return /* PLambda */Block.__(7, [
                  n,
                  Curry._2(f, l, x[1]),
                  Curry._2(f, Curry._2(g, n, l), x[2])
                ]);
    case 8 : 
        var n$1 = x[0];
        return /* PProd */Block.__(8, [
                  n$1,
                  Curry._2(f, l, x[1]),
                  Curry._2(f, Curry._2(g, n$1, l), x[2])
                ]);
    case 9 : 
        var n$2 = x[0];
        return /* PLetIn */Block.__(9, [
                  n$2,
                  Curry._2(f, l, x[1]),
                  Option$ReactTemplate.map(Curry._1(f, l), x[2]),
                  Curry._2(f, Curry._2(g, n$2, l), x[3])
                ]);
    case 12 : 
        return /* PIf */Block.__(12, [
                  Curry._2(f, l, x[0]),
                  Curry._2(f, l, x[1]),
                  Curry._2(f, l, x[2])
                ]);
    case 13 : 
        return /* PCase */Block.__(13, [
                  x[0],
                  Curry._2(f, l, x[1]),
                  Curry._2(f, l, x[2]),
                  Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                          return /* tuple */[
                                  param[0],
                                  param[1],
                                  Curry._2(f, l, param[2])
                                ];
                        }), x[3])
                ]);
    default:
      return x;
  }
}

function instantiate_pattern(env, sigma, lvar, c) {
  var aux = function (vars, x) {
    switch (x.tag | 0) {
      case 1 : 
          var id = x[0];
          try {
            var match = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, lvar);
            var ctx = match[0];
            try {
              var inst = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
                      return EConstr$ReactTemplate.mkRel(Curry._3(Util$ReactTemplate.List[/* index */77], Nameops$ReactTemplate.Name[/* equal */4], /* Name */[id], vars));
                    }), ctx);
              var c = EConstr$ReactTemplate.Vars[/* substl */3](inst, match[1]);
              var c$1 = Evarutil$ReactTemplate.nf_evar(sigma, c);
              return pattern_of_constr(env, sigma, EConstr$ReactTemplate.Unsafe[/* to_constr */0](c$1));
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                var vars$1 = Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function (param) {
                        if (param) {
                          return /* Some */[param[0]];
                        } else {
                          return /* None */0;
                        }
                      }), vars);
                var id$1 = id;
                var l = Curry._3(Util$ReactTemplate.List[/* subtract */53], Names$ReactTemplate.Id[/* equal */0], ctx, vars$1);
                var is = l && !l[1] ? "is" : "are";
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot substitute the term bound to "), Names$ReactTemplate.Id[/* print */8](id$1)), Pp$ReactTemplate.strbrk(" in pattern because the term refers to ")), Pp$ReactTemplate.pr_enum(Names$ReactTemplate.Id[/* print */8], l)), Pp$ReactTemplate.strbrk(" which ")), Pp$ReactTemplate.str(is)), Pp$ReactTemplate.strbrk(" not bound in the pattern.")));
              } else {
                throw exn;
              }
            }
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              return x;
            } else {
              throw exn$1;
            }
          }
          break;
      case 14 : 
      case 15 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Non instantiable pattern."));
      default:
        return map_pattern_with_binders((function (id, vars) {
                      return /* :: */[
                              id,
                              vars
                            ];
                    }), aux, vars, x);
    }
  };
  return aux(/* [] */0, c);
}

function liftn_pattern(k, n, x) {
  switch (x.tag | 0) {
    case 3 : 
        var i = x[0];
        if (i >= n) {
          return /* PRel */Block.__(3, [i + k | 0]);
        } else {
          return x;
        }
    case 14 : 
        return /* PFix */Block.__(14, [Constr$ReactTemplate.destFix(Vars$ReactTemplate.liftn(k, n, Constr$ReactTemplate.mkFix(x[0])))]);
    case 15 : 
        return /* PCoFix */Block.__(15, [Constr$ReactTemplate.destCoFix(Vars$ReactTemplate.liftn(k, n, Constr$ReactTemplate.mkCoFix(x[0])))]);
    default:
      return map_pattern_with_binders((function () {
                    return (function (prim) {
                        return prim + 1 | 0;
                      });
                  }), (function (param, param$1) {
                    return liftn_pattern(k, param, param$1);
                  }), n, x);
  }
}

function lift_pattern(k) {
  return (function (param) {
      return liftn_pattern(k, 1, param);
    });
}

function subst_pattern(subst, pat) {
  switch (pat.tag | 0) {
    case 0 : 
        var ref = pat[0];
        var match = Globnames$ReactTemplate.subst_global(subst, ref);
        if (match[0] === ref) {
          return pat;
        } else {
          return pattern_of_constr(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, match[1]);
        }
    case 4 : 
        var args = pat[1];
        var f = pat[0];
        var f$prime = subst_pattern(subst, f);
        var args$prime = Util$ReactTemplate.$$Array[/* smartmap */47]((function (param) {
                return subst_pattern(subst, param);
              }), args);
        if (f$prime === f && args$prime === args) {
          return pat;
        } else {
          return /* PApp */Block.__(4, [
                    f$prime,
                    args$prime
                  ]);
        }
    case 5 : 
        var args$1 = pat[1];
        var args$prime$1 = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
                return subst_pattern(subst, param);
              }), args$1);
        if (args$prime$1 === args$1) {
          return pat;
        } else {
          return /* PSoApp */Block.__(5, [
                    pat[0],
                    args$prime$1
                  ]);
        }
    case 6 : 
        var c = pat[1];
        var p = pat[0];
        var p$prime = Names$ReactTemplate.Projection[/* map */9]((function (p) {
                return Globnames$ReactTemplate.destConstRef(Globnames$ReactTemplate.subst_global(subst, /* ConstRef */Block.__(1, [p]))[0]);
              }), p);
        var c$prime = subst_pattern(subst, c);
        if (p$prime === p && c$prime === c) {
          return pat;
        } else {
          return /* PProj */Block.__(6, [
                    p$prime,
                    c$prime
                  ]);
        }
    case 7 : 
        var c2 = pat[2];
        var c1 = pat[1];
        var c1$prime = subst_pattern(subst, c1);
        var c2$prime = subst_pattern(subst, c2);
        if (c1$prime === c1 && c2$prime === c2) {
          return pat;
        } else {
          return /* PLambda */Block.__(7, [
                    pat[0],
                    c1$prime,
                    c2$prime
                  ]);
        }
    case 8 : 
        var c2$1 = pat[2];
        var c1$1 = pat[1];
        var c1$prime$1 = subst_pattern(subst, c1$1);
        var c2$prime$1 = subst_pattern(subst, c2$1);
        if (c1$prime$1 === c1$1 && c2$prime$1 === c2$1) {
          return pat;
        } else {
          return /* PProd */Block.__(8, [
                    pat[0],
                    c1$prime$1,
                    c2$prime$1
                  ]);
        }
    case 9 : 
        var c2$2 = pat[3];
        var t = pat[2];
        var c1$2 = pat[1];
        var c1$prime$2 = subst_pattern(subst, c1$2);
        var t$prime = Option$ReactTemplate.smartmap((function (param) {
                return subst_pattern(subst, param);
              }), t);
        var c2$prime$2 = subst_pattern(subst, c2$2);
        if (c1$prime$2 === c1$2 && t$prime === t && c2$prime$2 === c2$2) {
          return pat;
        } else {
          return /* PLetIn */Block.__(9, [
                    pat[0],
                    c1$prime$2,
                    t$prime,
                    c2$prime$2
                  ]);
        }
    case 10 : 
    case 11 : 
        return pat;
    case 12 : 
        var c2$3 = pat[2];
        var c1$3 = pat[1];
        var c$1 = pat[0];
        var c$prime$1 = subst_pattern(subst, c$1);
        var c1$prime$3 = subst_pattern(subst, c1$3);
        var c2$prime$3 = subst_pattern(subst, c2$3);
        if (c$prime$1 === c$1 && c1$prime$3 === c1$3 && c2$prime$3 === c2$3) {
          return pat;
        } else {
          return /* PIf */Block.__(12, [
                    c$prime$1,
                    c1$prime$3,
                    c2$prime$3
                  ]);
        }
    case 13 : 
        var branches = pat[3];
        var c$2 = pat[2];
        var typ = pat[1];
        var cip = pat[0];
        var ind = cip[/* cip_ind */1];
        var ind$prime = Option$ReactTemplate.smartmap((function (param) {
                return Mod_subst$ReactTemplate.subst_ind(subst, param);
              }), ind);
        var cip$prime = ind$prime === ind ? cip : /* record */[
            /* cip_style */cip[/* cip_style */0],
            /* cip_ind */ind$prime,
            /* cip_ind_tags */cip[/* cip_ind_tags */2],
            /* cip_extensible */cip[/* cip_extensible */3]
          ];
        var typ$prime = subst_pattern(subst, typ);
        var c$prime$2 = subst_pattern(subst, c$2);
        var subst_branch = function (br) {
          var c = br[2];
          var c$prime = subst_pattern(subst, c);
          if (c$prime === c) {
            return br;
          } else {
            return /* tuple */[
                    br[0],
                    br[1],
                    c$prime
                  ];
          }
        };
        var branches$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], subst_branch, branches);
        if (cip$prime === cip && typ$prime === typ && c$prime$2 === c$2 && branches$prime === branches) {
          return pat;
        } else {
          return /* PCase */Block.__(13, [
                    cip$prime,
                    typ$prime,
                    c$prime$2,
                    branches$prime
                  ]);
        }
    case 14 : 
        var fixpoint = pat[0];
        var cstr = Constr$ReactTemplate.mkFix(fixpoint);
        var fixpoint$prime = Constr$ReactTemplate.destFix(Mod_subst$ReactTemplate.subst_mps(subst, cstr));
        if (fixpoint$prime === fixpoint) {
          return pat;
        } else {
          return /* PFix */Block.__(14, [fixpoint$prime]);
        }
    case 15 : 
        var cofixpoint = pat[0];
        var cstr$1 = Constr$ReactTemplate.mkCoFix(cofixpoint);
        var cofixpoint$prime = Constr$ReactTemplate.destCoFix(Mod_subst$ReactTemplate.subst_mps(subst, cstr$1));
        if (cofixpoint$prime === cofixpoint) {
          return pat;
        } else {
          return /* PCoFix */Block.__(15, [cofixpoint$prime]);
        }
    default:
      return pat;
  }
}

function mkPLambda(na, b) {
  return /* PLambda */Block.__(7, [
            na,
            /* PMeta */Block.__(11, [/* None */0]),
            b
          ]);
}

var rev_it_mkPLambda = Curry._1(Util$ReactTemplate.List[/* fold_right */14], mkPLambda);

var warn_cast_in_pattern = CWarnings$ReactTemplate.create("cast-in-pattern", "automation", /* None */0, (function () {
        return Pp$ReactTemplate.strbrk("Casts are ignored in patterns");
      }));

function pat_of_raw(metas, vars) {
  return (function (param) {
      return DAst$ReactTemplate.with_loc_val((function (loc, param) {
                    switch (param.tag | 0) {
                      case 0 : 
                          return /* PRef */Block.__(0, [Globnames$ReactTemplate.canonical_gr(param[0])]);
                      case 1 : 
                          var id = param[0];
                          try {
                            return /* PRel */Block.__(3, [Curry._3(Util$ReactTemplate.List[/* index */77], Nameops$ReactTemplate.Name[/* equal */4], /* Name */[id], vars)]);
                          }
                          catch (exn){
                            if (exn === Caml_builtin_exceptions.not_found) {
                              return /* PVar */Block.__(1, [id]);
                            } else {
                              throw exn;
                            }
                          }
                          break;
                      case 2 : 
                          var pp = Pp$ReactTemplate.str("Non supported pattern.");
                          return CErrors$ReactTemplate.user_err(loc, /* Some */["pattern_of_glob_constr"], pp);
                      case 3 : 
                          var match = param[0];
                          if (match.tag) {
                            var pp$1 = Pp$ReactTemplate.str("Non supported pattern.");
                            return CErrors$ReactTemplate.user_err(loc, /* Some */["pattern_of_glob_constr"], pp$1);
                          } else {
                            var n = match[0];
                            metas[0] = /* :: */[
                              n,
                              metas[0]
                            ];
                            return /* PMeta */Block.__(11, [/* Some */[n]]);
                          }
                          break;
                      case 4 : 
                          var cl = param[1];
                          var c = param[0];
                          var match$1 = DAst$ReactTemplate.get(c);
                          var exit = 0;
                          if (match$1.tag === 3) {
                            var match$2 = match$1[0];
                            if (match$2.tag) {
                              var n$1 = match$2[0];
                              metas[0] = /* :: */[
                                n$1,
                                metas[0]
                              ];
                              return /* PSoApp */Block.__(5, [
                                        n$1,
                                        Curry._2(Util$ReactTemplate.List[/* map */10], pat_of_raw(metas, vars), cl)
                                      ]);
                            } else {
                              exit = 1;
                            }
                          } else {
                            exit = 1;
                          }
                          if (exit === 1) {
                            return /* PApp */Block.__(4, [
                                      pat_of_raw(metas, vars)(c),
                                      Util$ReactTemplate.$$Array[/* of_list */10](Curry._2(Util$ReactTemplate.List[/* map */10], pat_of_raw(metas, vars), cl))
                                    ]);
                          }
                          break;
                      case 5 : 
                          var na = param[0];
                          Nameops$ReactTemplate.Name[/* iter */11]((function (n) {
                                  metas[0] = /* :: */[
                                    n,
                                    metas[0]
                                  ];
                                  return /* () */0;
                                }), na);
                          return /* PLambda */Block.__(7, [
                                    na,
                                    pat_of_raw(metas, vars)(param[2]),
                                    pat_of_raw(metas, /* :: */[
                                            na,
                                            vars
                                          ])(param[3])
                                  ]);
                      case 6 : 
                          var na$1 = param[0];
                          Nameops$ReactTemplate.Name[/* iter */11]((function (n) {
                                  metas[0] = /* :: */[
                                    n,
                                    metas[0]
                                  ];
                                  return /* () */0;
                                }), na$1);
                          return /* PProd */Block.__(8, [
                                    na$1,
                                    pat_of_raw(metas, vars)(param[2]),
                                    pat_of_raw(metas, /* :: */[
                                            na$1,
                                            vars
                                          ])(param[3])
                                  ]);
                      case 7 : 
                          var na$2 = param[0];
                          Nameops$ReactTemplate.Name[/* iter */11]((function (n) {
                                  metas[0] = /* :: */[
                                    n,
                                    metas[0]
                                  ];
                                  return /* () */0;
                                }), na$2);
                          return /* PLetIn */Block.__(9, [
                                    na$2,
                                    pat_of_raw(metas, vars)(param[1]),
                                    Option$ReactTemplate.map(pat_of_raw(metas, vars), param[2]),
                                    pat_of_raw(metas, /* :: */[
                                            na$2,
                                            vars
                                          ])(param[3])
                                  ]);
                      case 8 : 
                          var match$3 = param[2];
                          var p = param[1];
                          var exit$1 = 0;
                          if (match$3) {
                            if (match$3[1]) {
                              exit$1 = 1;
                            } else {
                              var brs = param[3];
                              var match$4 = match$3[0];
                              var match$5 = match$4[1];
                              var indnames = match$5[1];
                              var na$3 = match$5[0];
                              var get_ind = function (param) {
                                if (param) {
                                  var match = param[0][/* v */0][1];
                                  if (match && !match[1]) {
                                    var p = match[0];
                                    var match$1 = DAst$ReactTemplate.get(p);
                                    if (match$1.tag) {
                                      return /* Some */[match$1[0][0]];
                                    } else {
                                      return /* None */0;
                                    }
                                  } else {
                                    return /* None */0;
                                  }
                                } else {
                                  return /* None */0;
                                }
                              };
                              var match$6;
                              if (indnames) {
                                var match$7 = indnames[0][/* v */0];
                                match$6 = /* tuple */[
                                  /* Some */[Curry._1(Util$ReactTemplate.List[/* length */0], match$7[1])],
                                  /* Some */[match$7[0]]
                                ];
                              } else {
                                match$6 = /* tuple */[
                                  /* None */0,
                                  get_ind(brs)
                                ];
                              }
                              var ind = match$6[1];
                              var match$8 = pats_of_glob_branches(loc, metas, vars, ind, brs);
                              var pred;
                              if (p) {
                                var p$1 = p[0];
                                if (indnames) {
                                  var nal = indnames[0][/* v */0][1];
                                  var nvars = Util$ReactTemplate.$at(/* :: */[
                                        na$3,
                                        Curry._1(Util$ReactTemplate.List[/* rev */4], nal)
                                      ], vars);
                                  pred = Curry._2(rev_it_mkPLambda, nal, /* PLambda */Block.__(7, [
                                          na$3,
                                          /* PMeta */Block.__(11, [/* None */0]),
                                          pat_of_raw(metas, nvars)(p$1)
                                        ]));
                                } else {
                                  var match$9 = DAst$ReactTemplate.get(p$1);
                                  pred = match$9.tag === 13 ? /* PMeta */Block.__(11, [/* None */0]) : CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.strbrk("Clause \"in\" expected in patterns over \"match\" expressions with an explicit \"return\" clause."));
                                }
                              } else {
                                pred = /* PMeta */Block.__(11, [/* None */0]);
                              }
                              var info_000 = /* cip_style */param[0];
                              var info_003 = /* cip_extensible */match$8[0];
                              var info = /* record */[
                                info_000,
                                /* cip_ind */ind,
                                /* cip_ind_tags : None */0,
                                info_003
                              ];
                              return /* PCase */Block.__(13, [
                                        info,
                                        pred,
                                        pat_of_raw(metas, vars)(match$4[0]),
                                        match$8[1]
                                      ]);
                            }
                          } else {
                            exit$1 = 1;
                          }
                          if (exit$1 === 1) {
                            var pp$2 = Pp$ReactTemplate.str("Non supported pattern.");
                            return CErrors$ReactTemplate.user_err(loc, /* Some */["pattern_of_glob_constr"], pp$2);
                          }
                          break;
                      case 9 : 
                          var nal$1 = param[0];
                          if (param[1][1]) {
                            var pp$3 = Pp$ReactTemplate.str("Non supported pattern.");
                            return CErrors$ReactTemplate.user_err(loc, /* Some */["pattern_of_glob_constr"], pp$3);
                          } else {
                            var mkGLambda = function (na, c) {
                              return DAst$ReactTemplate.make(loc, /* GLambda */Block.__(5, [
                                            na,
                                            /* Explicit */0,
                                            DAst$ReactTemplate.make(/* None */0, /* GHole */Block.__(13, [
                                                    /* InternalHole */0,
                                                    /* IntroAnonymous */0,
                                                    /* None */0
                                                  ])),
                                            c
                                          ]));
                            };
                            var c$1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], mkGLambda, nal$1, param[3]);
                            var tags = Curry._2(Util$ReactTemplate.List[/* map */10], (function () {
                                    return /* false */0;
                                  }), nal$1);
                            return /* PCase */Block.__(13, [
                                      /* record */[
                                        /* cip_style : LetStyle */0,
                                        /* cip_ind : None */0,
                                        /* cip_ind_tags : None */0,
                                        /* cip_extensible : false */0
                                      ],
                                      /* PMeta */Block.__(11, [/* None */0]),
                                      pat_of_raw(metas, vars)(param[2]),
                                      /* :: */[
                                        /* tuple */[
                                          0,
                                          tags,
                                          pat_of_raw(metas, vars)(c$1)
                                        ],
                                        /* [] */0
                                      ]
                                    ]);
                          }
                          break;
                      case 10 : 
                          if (param[1][1]) {
                            var pp$4 = Pp$ReactTemplate.str("Non supported pattern.");
                            return CErrors$ReactTemplate.user_err(loc, /* Some */["pattern_of_glob_constr"], pp$4);
                          } else {
                            return /* PIf */Block.__(12, [
                                      pat_of_raw(metas, vars)(param[0]),
                                      pat_of_raw(metas, vars)(param[2]),
                                      pat_of_raw(metas, vars)(param[3])
                                    ]);
                          }
                          break;
                      case 11 : 
                          var pp$5 = Pp$ReactTemplate.str("Non supported pattern.");
                          return CErrors$ReactTemplate.user_err(loc, /* Some */["pattern_of_glob_constr"], pp$5);
                      case 12 : 
                          return /* PSort */Block.__(10, [param[0]]);
                      case 13 : 
                          return /* PMeta */Block.__(11, [/* None */0]);
                      case 14 : 
                          Curry._2(warn_cast_in_pattern, /* None */0, /* () */0);
                          return pat_of_raw(metas, vars)(param[0]);
                      case 15 : 
                          return /* PProj */Block.__(6, [
                                    param[0],
                                    pat_of_raw(metas, vars)(param[1])
                                  ]);
                      
                    }
                  }), param);
    });
}

function pats_of_glob_branches(loc, metas, vars, ind, brs) {
  var get_arg = function (p) {
    var match = DAst$ReactTemplate.get(p);
    if (match.tag) {
      var pp = Pp$ReactTemplate.str("Non supported pattern.");
      return CErrors$ReactTemplate.user_err(p[/* loc */1], /* Some */["pattern_of_glob_constr"], pp);
    } else {
      var na = match[0];
      Nameops$ReactTemplate.Name[/* iter */11]((function (n) {
              metas[0] = /* :: */[
                n,
                metas[0]
              ];
              return /* () */0;
            }), na);
      return na;
    }
  };
  var get_pat = function (indexes, param) {
    if (param) {
      var match = param[0];
      var match$1 = match[/* v */0];
      var match$2 = match$1[1];
      var exit = 0;
      if (match$2) {
        if (match$2[1]) {
          exit = 1;
        } else {
          var brs = param[1];
          var loc$prime = match[/* loc */1];
          var br = match$1[2];
          var match$3 = DAst$ReactTemplate.get(match$2[0]);
          var match$4 = DAst$ReactTemplate.get(br);
          if (match$3.tag) {
            var lv = match$3[1];
            var match$5 = match$3[0];
            var j = match$5[1];
            if (ind) {
              if (!Names$ReactTemplate.eq_ind(ind[0], match$5[0])) {
                var pp = Pp$ReactTemplate.str("All constructors must be in the same inductive type.");
                CErrors$ReactTemplate.user_err(loc, /* Some */["pattern_of_glob_constr"], pp);
              }
              
            } else {
              var pp$1 = Pp$ReactTemplate.str("All constructors must be in the same inductive type.");
              CErrors$ReactTemplate.user_err(loc, /* Some */["pattern_of_glob_constr"], pp$1);
            }
            if (Curry._2(Int$ReactTemplate.$$Set[/* mem */2], j - 1 | 0, indexes)) {
              var pp$2 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No unique branch for "), Pp$ReactTemplate.$$int(j)), Pp$ReactTemplate.str("-th constructor."));
              CErrors$ReactTemplate.user_err(loc, /* Some */["pattern_of_glob_constr"], pp$2);
            }
            var lna = Curry._2(Util$ReactTemplate.List[/* map */10], get_arg, lv);
            var vars$prime = Util$ReactTemplate.$at(Curry._1(Util$ReactTemplate.List[/* rev */4], lna), vars);
            var pat = Curry._2(rev_it_mkPLambda, lna, pat_of_raw(metas, vars$prime)(br));
            var match$6 = get_pat(Curry._2(Int$ReactTemplate.$$Set[/* add */3], j - 1 | 0, indexes), brs);
            var tags = Curry._2(Util$ReactTemplate.List[/* map */10], (function () {
                    return /* false */0;
                  }), lv);
            return /* tuple */[
                    match$6[0],
                    /* :: */[
                      /* tuple */[
                        j - 1 | 0,
                        tags,
                        pat
                      ],
                      match$6[1]
                    ]
                  ];
          } else if (match$3[0]) {
            var pp$3 = Pp$ReactTemplate.str("Non supported pattern.");
            return CErrors$ReactTemplate.user_err(loc$prime, /* Some */["pattern_of_glob_constr"], pp$3);
          } else if (match$4.tag === 13) {
            if (brs) {
              var pp$4 = Pp$ReactTemplate.str("Non supported pattern.");
              return CErrors$ReactTemplate.user_err(loc$prime, /* Some */["pattern_of_glob_constr"], pp$4);
            } else {
              return /* tuple */[
                      /* true */1,
                      /* [] */0
                    ];
            }
          } else {
            var pp$5 = Pp$ReactTemplate.str("Non supported pattern.");
            return CErrors$ReactTemplate.user_err(loc$prime, /* Some */["pattern_of_glob_constr"], pp$5);
          }
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var pp$6 = Pp$ReactTemplate.str("Non supported pattern.");
        return CErrors$ReactTemplate.user_err(match[/* loc */1], /* Some */["pattern_of_glob_constr"], pp$6);
      }
      
    } else {
      return /* tuple */[
              /* false */0,
              /* [] */0
            ];
    }
  };
  return get_pat(Int$ReactTemplate.$$Set[/* empty */0], brs);
}

function pattern_of_glob_constr(c) {
  var metas = [/* [] */0];
  var p = pat_of_raw(metas, /* [] */0)(c);
  return /* tuple */[
          metas[0],
          p
        ];
}

exports.constr_pattern_eq = constr_pattern_eq;
exports.occur_meta_pattern = occur_meta_pattern;
exports.subst_pattern = subst_pattern;
exports.noccurn_pattern = noccurn_pattern;
exports.BoundPattern = BoundPattern;
exports.head_pattern_bound = head_pattern_bound;
exports.head_of_constr_reference = head_of_constr_reference;
exports.pattern_of_constr = pattern_of_constr;
exports.pattern_of_glob_constr = pattern_of_glob_constr;
exports.instantiate_pattern = instantiate_pattern;
exports.lift_pattern = lift_pattern;
/* rev_it_mkPLambda Not a pure module */
