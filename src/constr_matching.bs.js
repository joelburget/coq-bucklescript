// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var IStream$ReactTemplate = require("./iStream.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Patternops$ReactTemplate = require("./patternops.bs.js");

var PatternMatchingFailure = Caml_exceptions.create("Constr_matching-ReactTemplate.PatternMatchingFailure");

var warn_meta_collision = CWarnings$ReactTemplate.create("meta-collision", "ltac", /* None */0, (function (name) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Collision between bound variable "), Names$ReactTemplate.Id[/* print */8](name)), Pp$ReactTemplate.strbrk(" and a metavariable of same name."));
      }));

function constrain(sigma, n, param, subst) {
  var terms = subst[1];
  var names = subst[0];
  var m = param[1];
  var ids = param[0];
  try {
    var match = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], n, terms);
    if (Curry._3(Util$ReactTemplate.List[/* equal */44], Names$ReactTemplate.Id[/* equal */0], ids, match[0]) && EConstr$ReactTemplate.eq_constr(sigma, m, match[1])) {
      return subst;
    } else {
      throw PatternMatchingFailure;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], n, names)) {
        Curry._2(warn_meta_collision, /* None */0, n);
      }
      return /* tuple */[
              names,
              Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], n, /* tuple */[
                    ids,
                    m
                  ], terms)
            ];
    } else {
      throw exn;
    }
  }
}

function add_binders(na1, na2, binding_vars, subst) {
  var terms = subst[1];
  var names = subst[0];
  if (na1) {
    if (na2) {
      var id1 = na1[0];
      if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id1, binding_vars)) {
        if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id1, names)) {
          Glob_ops$ReactTemplate.warn_variable_collision(/* None */0, id1);
          return /* tuple */[
                  names,
                  terms
                ];
        } else {
          var names$1 = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id1, na2[0], names);
          if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id1, terms)) {
            Curry._2(warn_meta_collision, /* None */0, id1);
          }
          return /* tuple */[
                  names$1,
                  terms
                ];
        }
      } else {
        return subst;
      }
    } else {
      return subst;
    }
  } else {
    return subst;
  }
}

function build_lambda(sigma, _vars, _ctx, _m) {
  while(true) {
    var m = _m;
    var ctx = _ctx;
    var vars = _vars;
    if (vars) {
      var n = vars[0];
      var match = Curry._2(Util$ReactTemplate.List[/* chop */99], n - 1 | 0, ctx);
      var suf = match[1];
      var pre = match[0];
      var match$1;
      if (suf) {
        var match$2 = suf[0];
        match$1 = /* tuple */[
          /* Name */[match$2[1]],
          match$2[2],
          suf[1]
        ];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "constr_matching.ml",
                93,
                10
              ]
            ];
      }
      var suf$1 = match$1[2];
      var is_nondep = function (t, clear) {
        if (clear) {
          var rels = Termops$ReactTemplate.free_rels(sigma, t);
          var check = function (i, b) {
            if (b) {
              return /* true */1;
            } else {
              return 1 - Curry._2(Int$ReactTemplate.$$Set[/* mem */2], i, rels);
            }
          };
          return Curry._3(Util$ReactTemplate.List[/* for_all_i */86], check, 1, clear);
        } else {
          return /* true */1;
        }
      };
      var fold = function (param, clear) {
        return /* :: */[
                is_nondep(param[2], clear),
                clear
              ];
      };
      var clear = Curry._3(Util$ReactTemplate.List[/* fold_right */14], fold, pre, /* :: */[
            /* false */0,
            /* [] */0
          ]);
      var clear$1 = Curry._1(Util$ReactTemplate.List[/* drop_last */112], clear);
      if (!is_nondep(m, clear$1)) {
        throw PatternMatchingFailure;
      }
      var fold$1 = function (param, keep) {
        var accu = param[1];
        var k = param[0];
        if (keep) {
          var k$1 = k + 1 | 0;
          return /* tuple */[
                  k$1,
                  /* :: */[
                    /* Some */[k$1],
                    accu
                  ]
                ];
        } else {
          return /* tuple */[
                  k,
                  /* :: */[
                    /* None */0,
                    accu
                  ]
                ];
        }
      };
      var match$3 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold$1, /* tuple */[
            0,
            /* [] */0
          ], clear$1);
      var keep = match$3[0];
      var shift = Curry._1(Util$ReactTemplate.List[/* rev */4], match$3[1]);
      var map = function (param) {
        if (param) {
          return EConstr$ReactTemplate.mkRel(param[0] + 1 | 0);
        } else {
          return EConstr$ReactTemplate.mkProp;
        }
      };
      var subst = Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* map */10], map, shift), /* :: */[
            EConstr$ReactTemplate.mkRel(1),
            Curry._2(Util$ReactTemplate.List[/* mapi */11], (function(keep){
                return function (i, _) {
                  return EConstr$ReactTemplate.mkRel((i + keep | 0) + 2 | 0);
                }
                }(keep)), suf$1)
          ]);
      var map$1 = (function(subst){
      return function map$1(i, param) {
        var i$1 = i + 1 | 0;
        var subst$1 = Curry._2(Util$ReactTemplate.List[/* skipn */107], i$1, subst);
        var subst$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
                return EConstr$ReactTemplate.Vars[/* lift */0](-i$1 | 0, c);
              }), subst$1);
        return /* tuple */[
                param[0],
                param[1],
                EConstr$ReactTemplate.Vars[/* substl */3](subst$2, param[2])
              ];
      }
      }(subst));
      var pre$1 = Curry._2(Util$ReactTemplate.List[/* mapi */11], map$1, pre);
      var pre$2 = Curry._2(Util$ReactTemplate.List[/* filter_with */64], clear$1, pre$1);
      var m$1 = EConstr$ReactTemplate.Vars[/* substl */3](subst, m);
      var map$2 = (function(n,keep,shift){
      return function map$2(i) {
        if (i > n) {
          return (i - n | 0) + keep | 0;
        } else {
          var match = Curry._2(Util$ReactTemplate.List[/* nth */3], shift, i - 1 | 0);
          if (match) {
            return match[0];
          } else {
            throw PatternMatchingFailure;
          }
        }
      }
      }(n,keep,shift));
      var vars$1 = Curry._2(Util$ReactTemplate.List[/* map */10], map$2, vars[1]);
      var m$2 = EConstr$ReactTemplate.mkLambda(/* tuple */[
            match$1[0],
            EConstr$ReactTemplate.Vars[/* lift */0](keep, match$1[1]),
            m$1
          ]);
      _m = m$2;
      _ctx = Util$ReactTemplate.$at(pre$2, suf$1);
      _vars = vars$1;
      continue ;
      
    } else if (EConstr$ReactTemplate.Vars[/* closed0 */15](sigma, m)) {
      return m;
    } else {
      throw PatternMatchingFailure;
    }
  };
}

function extract_bound_vars(frels, ctx) {
  var _k = 1;
  var _accu = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var frels$1 = frels;
  var _ctx = ctx;
  while(true) {
    var ctx$1 = _ctx;
    var accu = _accu;
    var k = _k;
    if (ctx$1) {
      var ctx$2 = ctx$1[1];
      var na = ctx$1[0][0];
      if (Curry._2(Int$ReactTemplate.$$Set[/* mem */2], k, frels$1)) {
        if (na) {
          var id = na[0];
          if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, accu)) {
            throw PatternMatchingFailure;
          }
          _ctx = ctx$2;
          _accu = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, accu);
          _k = k + 1 | 0;
          continue ;
          
        } else {
          throw PatternMatchingFailure;
        }
      } else {
        _ctx = ctx$2;
        _k = k + 1 | 0;
        continue ;
        
      }
    } else {
      return accu;
    }
  };
}

function push_binder(na1, na2, t, ctx) {
  var id2;
  if (na2) {
    id2 = na2[0];
  } else {
    var avoid = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* of_list */25], Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi2, ctx));
    id2 = Namegen$ReactTemplate.next_ident_away(Namegen$ReactTemplate.default_non_dependent_ident, avoid);
  }
  return /* :: */[
          /* tuple */[
            na1,
            id2,
            t
          ],
          ctx
        ];
}

function to_fix(param) {
  var match = param[1];
  return /* tuple */[
          param[0],
          /* tuple */[
            match[0],
            Util$ReactTemplate.$$Array[/* map */12](EConstr$ReactTemplate.of_constr, match[1]),
            Util$ReactTemplate.$$Array[/* map */12](EConstr$ReactTemplate.of_constr, match[2])
          ]
        ];
}

function merge_binding(sigma, allow_bound_rels, ctx, n, cT, subst) {
  var c;
  if (ctx) {
    var frels = Termops$ReactTemplate.free_rels(sigma, cT);
    if (allow_bound_rels) {
      var vars = extract_bound_vars(frels, ctx);
      var ordered_vars = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], vars);
      var rename = function (binding) {
        var ids = ordered_vars;
        var param = binding;
        var match = param[0];
        if (match) {
          try {
            return EConstr$ReactTemplate.mkRel(Curry._3(Util$ReactTemplate.List[/* index */77], Names$ReactTemplate.Id[/* equal */0], match[0], ids));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return EConstr$ReactTemplate.mkProp;
            } else {
              throw exn;
            }
          }
        } else {
          return EConstr$ReactTemplate.mkProp;
        }
      };
      var renaming = Curry._2(Util$ReactTemplate.List[/* map */10], rename, ctx);
      c = /* tuple */[
        ordered_vars,
        EConstr$ReactTemplate.Vars[/* substl */3](renaming, cT)
      ];
    } else {
      var depth = Curry._1(Util$ReactTemplate.List[/* length */0], ctx);
      var min_elt;
      try {
        min_elt = Curry._1(Int$ReactTemplate.$$Set[/* min_elt */20], frels);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          min_elt = depth + 1 | 0;
        } else {
          throw exn;
        }
      }
      if (depth < min_elt) {
        c = /* tuple */[
          /* [] */0,
          EConstr$ReactTemplate.Vars[/* lift */0](-depth | 0, cT)
        ];
      } else {
        throw PatternMatchingFailure;
      }
    }
  } else {
    c = /* tuple */[
      /* [] */0,
      cT
    ];
  }
  return constrain(sigma, n, c, subst);
}

function matches_core(env, sigma, allow_bound_rels, param, c) {
  var binding_vars = param[0];
  var convref = function (ref, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (ref.tag | 0) {
      case 0 : 
          if (match.tag === 1) {
            return Names$ReactTemplate.Id[/* equal */0](ref[0], match[0]);
          } else {
            return /* false */0;
          }
          break;
      case 1 : 
          if (match.tag === 10) {
            return Names$ReactTemplate.Constant[/* equal */12](ref[0], match[0][0]);
          } else {
            return /* false */0;
          }
          break;
      case 2 : 
          if (match.tag === 11) {
            return Names$ReactTemplate.eq_ind(ref[0], match[0][0]);
          } else {
            return /* false */0;
          }
          break;
      case 3 : 
          if (match.tag === 12) {
            return Names$ReactTemplate.eq_constructor(ref[0], match[0][0]);
          } else {
            return /* false */0;
          }
          break;
      
    }
  };
  var sorec = function (_ctx, _env, _subst, _p, _t) {
    while(true) {
      var t = _t;
      var p = _p;
      var subst = _subst;
      var env = _env;
      var ctx = _ctx;
      var cT = Termops$ReactTemplate.strip_outer_cast(sigma, t);
      var match = EConstr$ReactTemplate.kind(sigma, cT);
      switch (p.tag | 0) {
        case 0 : 
            var ref = p[0];
            var exit = 0;
            if (ref.tag) {
              exit = 1;
            } else if (match.tag === 1) {
              if (Names$ReactTemplate.Id[/* equal */0](ref[0], match[0])) {
                return subst;
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              if (convref(ref, cT)) {
                return subst;
              } else {
                throw PatternMatchingFailure;
              }
            }
            break;
        case 1 : 
            if (match.tag === 1) {
              if (Names$ReactTemplate.Id[/* equal */0](p[0], match[0])) {
                return subst;
              } else {
                throw PatternMatchingFailure;
              }
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 2 : 
            if (match.tag === 3) {
              var match$1 = match[0];
              if (Evar$ReactTemplate.equal(p[0], match$1[0])) {
                return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function(ctx,env){
                          return function (param, param$1, param$2) {
                            return sorec(ctx, env, param, param$1, param$2);
                          }
                          }(ctx,env)), subst, p[1], match$1[1]);
              } else {
                throw PatternMatchingFailure;
              }
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 3 : 
            if (match.tag) {
              throw PatternMatchingFailure;
            } else if (p[0] === match[0]) {
              return subst;
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 4 : 
            var p$1 = p[0];
            var exit$1 = 0;
            if (p[1].length !== 0) {
              switch (p$1.tag | 0) {
                case 0 : 
                    var match$2 = p$1[0];
                    if (match$2.tag === 1) {
                      switch (match.tag | 0) {
                        case 9 : 
                            exit$1 = 1;
                            break;
                        case 16 : 
                            var pr = match[0];
                            if (Names$ReactTemplate.Projection[/* unfolded */3](pr) || !Names$ReactTemplate.Constant[/* equal */12](match$2[0], Names$ReactTemplate.Projection[/* constant */2](pr))) {
                              throw PatternMatchingFailure;
                            } else {
                              exit$1 = 1;
                            }
                            break;
                        default:
                          throw PatternMatchingFailure;
                      }
                    } else {
                      exit$1 = 1;
                    }
                    break;
                case 4 : 
                    _p = /* PApp */Block.__(4, [
                        p$1[0],
                        Util$ReactTemplate.$$Array[/* append */3](p$1[1], p[1])
                      ]);
                    continue ;
                    case 11 : 
                    var args1 = p[1];
                    var meta = p$1[0];
                    switch (match.tag | 0) {
                      case 9 : 
                          var args2 = match[1];
                          var c2 = match[0];
                          var diff = args2.length - args1.length | 0;
                          if (diff >= 0) {
                            var match$3 = Util$ReactTemplate.$$Array[/* chop */46](diff, args2);
                            var c = EConstr$ReactTemplate.mkApp(/* tuple */[
                                  c2,
                                  match$3[0]
                                ]);
                            var subst$1 = meta ? merge_binding(sigma, allow_bound_rels, ctx, meta[0], c, subst) : subst;
                            return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function(ctx,env){
                                      return function (param, param$1, param$2) {
                                        return sorec(ctx, env, param, param$1, param$2);
                                      }
                                      }(ctx,env)), subst$1, args1, match$3[1]);
                          } else {
                            var match$4 = EConstr$ReactTemplate.kind(sigma, c2);
                            if (match$4.tag === 16) {
                              var pr$1 = match$4[0];
                              if (Names$ReactTemplate.Projection[/* unfolded */3](pr$1)) {
                                throw PatternMatchingFailure;
                              } else {
                                try {
                                  var term = Retyping$ReactTemplate.expand_projection(env, sigma, pr$1, match$4[1], Util$ReactTemplate.$$Array[/* to_list */9](args2));
                                  return sorec(ctx, env, subst, p, term);
                                }
                                catch (raw_exn){
                                  var exn = Js_exn.internalToOCamlException(raw_exn);
                                  if (exn[0] === Retyping$ReactTemplate.RetypeError) {
                                    throw PatternMatchingFailure;
                                  } else {
                                    throw exn;
                                  }
                                }
                              }
                            } else {
                              throw PatternMatchingFailure;
                            }
                          }
                          break;
                      case 16 : 
                          exit$1 = 1;
                          break;
                      default:
                        throw PatternMatchingFailure;
                    }
                    break;
                default:
                  exit$1 = 1;
              }
            } else {
              _p = p$1;
              continue ;
              
            }
            if (exit$1 === 1) {
              var arg1 = p[1];
              switch (match.tag | 0) {
                case 9 : 
                    var arg2 = match[1];
                    var c2$1 = match[0];
                    var match$5 = EConstr$ReactTemplate.kind(sigma, c2$1);
                    var exit$2 = 0;
                    var exit$3 = 0;
                    switch (p$1.tag | 0) {
                      case 0 : 
                          var match$6 = p$1[0];
                          if (match$6.tag === 1) {
                            if (match$5.tag === 16) {
                              var pr$2 = match$5[0];
                              if (!Names$ReactTemplate.Constant[/* equal */12](match$6[0], Names$ReactTemplate.Projection[/* constant */2](pr$2)) || Names$ReactTemplate.Projection[/* unfolded */3](pr$2)) {
                                throw PatternMatchingFailure;
                              } else {
                                exit$3 = 3;
                              }
                            } else {
                              exit$2 = 2;
                            }
                          } else {
                            exit$3 = 3;
                          }
                          break;
                      case 6 : 
                          if (match$5.tag === 16) {
                            if (Names$ReactTemplate.Projection[/* equal */5](p$1[0], match$5[0])) {
                              try {
                                return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function(ctx,env){
                                          return function (param, param$1, param$2) {
                                            return sorec(ctx, env, param, param$1, param$2);
                                          }
                                          }(ctx,env)), sorec(ctx, env, subst, p$1[1], match$5[1]), arg1, arg2);
                              }
                              catch (raw_exn$1){
                                var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
                                if (exn$1[0] === Caml_builtin_exceptions.invalid_argument) {
                                  throw PatternMatchingFailure;
                                } else {
                                  throw exn$1;
                                }
                              }
                            } else {
                              throw PatternMatchingFailure;
                            }
                          } else {
                            exit$2 = 2;
                          }
                          break;
                      default:
                        exit$3 = 3;
                    }
                    if (exit$3 === 3) {
                      if (match$5.tag === 16) {
                        var pr$3 = match$5[0];
                        if (Names$ReactTemplate.Projection[/* unfolded */3](pr$3)) {
                          exit$2 = 2;
                        } else {
                          try {
                            var term$1 = Retyping$ReactTemplate.expand_projection(env, sigma, pr$3, match$5[1], Util$ReactTemplate.$$Array[/* to_list */9](arg2));
                            return sorec(ctx, env, subst, p, term$1);
                          }
                          catch (raw_exn$2){
                            var exn$2 = Js_exn.internalToOCamlException(raw_exn$2);
                            if (exn$2[0] === Retyping$ReactTemplate.RetypeError) {
                              throw PatternMatchingFailure;
                            } else {
                              throw exn$2;
                            }
                          }
                        }
                      } else {
                        exit$2 = 2;
                      }
                    }
                    if (exit$2 === 2) {
                      try {
                        return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function(ctx,env){
                                  return function (param, param$1, param$2) {
                                    return sorec(ctx, env, param, param$1, param$2);
                                  }
                                  }(ctx,env)), sorec(ctx, env, subst, p$1, c2$1), arg1, arg2);
                      }
                      catch (raw_exn$3){
                        var exn$3 = Js_exn.internalToOCamlException(raw_exn$3);
                        if (exn$3[0] === Caml_builtin_exceptions.invalid_argument) {
                          throw PatternMatchingFailure;
                        } else {
                          throw exn$3;
                        }
                      }
                    }
                    break;
                case 16 : 
                    try {
                      var term$2 = Retyping$ReactTemplate.expand_projection(env, sigma, match[0], match[1], /* [] */0);
                      return sorec(ctx, env, subst, p, term$2);
                    }
                    catch (raw_exn$4){
                      var exn$4 = Js_exn.internalToOCamlException(raw_exn$4);
                      if (exn$4[0] === Retyping$ReactTemplate.RetypeError) {
                        throw PatternMatchingFailure;
                      } else {
                        throw exn$4;
                      }
                    }
                    break;
                default:
                  throw PatternMatchingFailure;
              }
            }
            break;
        case 5 : 
            var fold = function (param, param$1) {
              var seen = param[1];
              if (param$1.tag === 3) {
                var n = param$1[0];
                if (Curry._2(Int$ReactTemplate.$$Set[/* mem */2], n, seen)) {
                  CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Non linear second-order pattern"));
                }
                return /* tuple */[
                        /* :: */[
                          n,
                          param[0]
                        ],
                        Curry._2(Int$ReactTemplate.$$Set[/* add */3], n, seen)
                      ];
              } else {
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Only bound indices allowed in second order pattern matching."));
              }
            };
            var match$7 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, /* tuple */[
                  /* [] */0,
                  Int$ReactTemplate.$$Set[/* empty */0]
                ], p[1]);
            var frels = Termops$ReactTemplate.free_rels(sigma, cT);
            if (Curry._2(Int$ReactTemplate.$$Set[/* subset */11], frels, match$7[1])) {
              return constrain(sigma, p[0], /* tuple */[
                          /* [] */0,
                          build_lambda(sigma, match$7[0], ctx, cT)
                        ], subst);
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 6 : 
            if (match.tag === 16) {
              if (Names$ReactTemplate.Projection[/* equal */5](p[0], match[0])) {
                _t = match[1];
                _p = p[1];
                continue ;
                
              } else {
                throw PatternMatchingFailure;
              }
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 7 : 
            var na1 = p[0];
            if (match.tag === 7) {
              var c2$2 = match[1];
              var na2 = match[0];
              _t = match[2];
              _p = p[2];
              _subst = add_binders(na1, na2, binding_vars, sorec(ctx, env, subst, p[1], c2$2));
              _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      na2,
                      c2$2
                    ]), env);
              _ctx = push_binder(na1, na2, c2$2, ctx);
              continue ;
              
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 8 : 
            var na1$1 = p[0];
            if (match.tag === 6) {
              var c2$3 = match[1];
              var na2$1 = match[0];
              _t = match[2];
              _p = p[2];
              _subst = add_binders(na1$1, na2$1, binding_vars, sorec(ctx, env, subst, p[1], c2$3));
              _env = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      na2$1,
                      c2$3
                    ]), env);
              _ctx = push_binder(na1$1, na2$1, c2$3, ctx);
              continue ;
              
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 9 : 
            var match$8 = p[2];
            var c1 = p[1];
            var na1$2 = p[0];
            if (match$8) {
              if (match.tag === 8) {
                var t2 = match[2];
                var c2$4 = match[1];
                var na2$2 = match[0];
                _t = match[3];
                _p = p[3];
                _subst = add_binders(na1$2, na2$2, binding_vars, sorec(ctx, env, sorec(ctx, env, subst, c1, c2$4), match$8[0], t2));
                _env = EConstr$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                        na2$2,
                        c2$4,
                        t2
                      ]), env);
                _ctx = push_binder(na1$2, na2$2, t2, ctx);
                continue ;
                
              } else {
                throw PatternMatchingFailure;
              }
            } else if (match.tag === 8) {
              var t2$1 = match[2];
              var c2$5 = match[1];
              var na2$3 = match[0];
              _t = match[3];
              _p = p[3];
              _subst = add_binders(na1$2, na2$3, binding_vars, sorec(ctx, env, subst, c1, c2$5));
              _env = EConstr$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                      na2$3,
                      c2$5,
                      t2$1
                    ]), env);
              _ctx = push_binder(na1$2, na2$3, t2$1, ctx);
              continue ;
              
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 10 : 
            var ps = p[0];
            if (match.tag === 4) {
              var match$9 = EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]);
              if (typeof ps === "number") {
                if (ps !== 0) {
                  if (match$9.tag) {
                    throw PatternMatchingFailure;
                  } else if (match$9[0] !== 0) {
                    throw PatternMatchingFailure;
                  } else {
                    return subst;
                  }
                } else if (match$9.tag) {
                  throw PatternMatchingFailure;
                } else if (match$9[0] !== 0) {
                  return subst;
                } else {
                  throw PatternMatchingFailure;
                }
              } else if (match$9.tag) {
                return subst;
              } else {
                throw PatternMatchingFailure;
              }
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 11 : 
            var match$10 = p[0];
            if (match$10) {
              return merge_binding(sigma, allow_bound_rels, ctx, match$10[0], cT, subst);
            } else {
              return subst;
            }
        case 12 : 
            if (match.tag === 13) {
              var match$11 = match[3];
              if (match$11.length !== 2) {
                throw PatternMatchingFailure;
              } else {
                var ci = match[0];
                var b2 = match$11[0];
                var b2$prime = match$11[1];
                var match$12 = EConstr$ReactTemplate.decompose_lam_n_decls(sigma, Caml_array.caml_array_get(ci[/* ci_cstr_ndecls */2], 0))(b2);
                var b2$1 = match$12[1];
                var ctx_b2 = match$12[0];
                var match$13 = EConstr$ReactTemplate.decompose_lam_n_decls(sigma, Caml_array.caml_array_get(ci[/* ci_cstr_ndecls */2], 1))(b2$prime);
                var b2$prime$1 = match$13[1];
                var ctx_b2$prime = match$13[0];
                var n = Curry._1(Context$ReactTemplate.Rel[/* length */3], ctx_b2);
                var n$prime = Curry._1(Context$ReactTemplate.Rel[/* length */3], ctx_b2$prime);
                if (EConstr$ReactTemplate.Vars[/* noccur_between */13](sigma, 1, n, b2$1) && EConstr$ReactTemplate.Vars[/* noccur_between */13](sigma, 1, n$prime, b2$prime$1)) {
                  var f = function (l, param) {
                    if (param.tag) {
                      return push_binder(/* Anonymous */0, param[0], param[2], l);
                    } else {
                      return push_binder(/* Anonymous */0, param[0], param[1], l);
                    }
                  };
                  var ctx_br = Curry._3(Util$ReactTemplate.List[/* fold_left */13], f, ctx, ctx_b2);
                  var ctx_br$prime = Curry._3(Util$ReactTemplate.List[/* fold_left */13], f, ctx, ctx_b2$prime);
                  var b1 = Patternops$ReactTemplate.lift_pattern(n)(p[1]);
                  var b1$prime = Patternops$ReactTemplate.lift_pattern(n$prime)(p[2]);
                  _t = b2$prime$1;
                  _p = b1$prime;
                  _subst = sorec(ctx_br, EConstr$ReactTemplate.push_rel_context(ctx_b2, env), sorec(ctx, env, subst, p[0], match[2]), b1, b2$1);
                  _env = EConstr$ReactTemplate.push_rel_context(ctx_b2$prime, env);
                  _ctx = ctx_br$prime;
                  continue ;
                  
                } else {
                  throw PatternMatchingFailure;
                }
              }
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 13 : 
            var br1 = p[3];
            var ci1 = p[0];
            if (match.tag === 13) {
              var br2 = match[3];
              var n2 = br2.length;
              var match$14 = ci1[/* cip_ind */1];
              if (match$14) {
                if (!Names$ReactTemplate.eq_ind(match$14[0], match[0][/* ci_ind */0])) {
                  throw PatternMatchingFailure;
                }
                
              }
              if (!ci1[/* cip_extensible */3] && Curry._1(Util$ReactTemplate.List[/* length */0], br1) !== n2) {
                throw PatternMatchingFailure;
              }
              var chk_branch = (function(ctx,env,br2,n2){
              return function chk_branch(subst, param) {
                var j = param[0];
                if (j >= n2) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "constr_matching.ml",
                          361,
                          5
                        ]
                      ];
                }
                return sorec(ctx, env, subst, param[2], Caml_array.caml_array_get(br2, j));
              }
              }(ctx,env,br2,n2));
              var chk_head = sorec(ctx, env, sorec(ctx, env, subst, p[2], match[2]), p[1], match[1]);
              return Curry._3(Util$ReactTemplate.List[/* fold_left */13], chk_branch, chk_head, br1);
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 14 : 
            if (match.tag === 14) {
              if (EConstr$ReactTemplate.eq_constr(sigma, EConstr$ReactTemplate.mkFix(to_fix(p[0])), cT)) {
                return subst;
              } else {
                throw PatternMatchingFailure;
              }
            } else {
              throw PatternMatchingFailure;
            }
            break;
        case 15 : 
            if (match.tag === 15) {
              if (EConstr$ReactTemplate.eq_constr(sigma, EConstr$ReactTemplate.mkCoFix(to_fix(p[0])), cT)) {
                return subst;
              } else {
                throw PatternMatchingFailure;
              }
            } else {
              throw PatternMatchingFailure;
            }
            break;
        
      }
    };
  };
  return sorec(/* [] */0, env, /* tuple */[
              Names$ReactTemplate.Id[/* Map */10][/* empty */0],
              Names$ReactTemplate.Id[/* Map */10][/* empty */0]
            ], param[1], c);
}

function matches_core_closed(env, sigma, pat, c) {
  var match = matches_core(env, sigma, /* false */0, pat, c);
  return /* tuple */[
          match[0],
          Curry._2(Names$ReactTemplate.Id[/* Map */10][/* map */22], (function (prim) {
                  return prim[1];
                }), match[1])
        ];
}

function extended_matches(env, sigma) {
  return (function (param, param$1) {
      return matches_core(env, sigma, /* true */1, param, param$1);
    });
}

function matches(env, sigma, pat, c) {
  return matches_core_closed(env, sigma, /* tuple */[
                Names$ReactTemplate.Id[/* Set */9][/* empty */0],
                pat
              ], c)[1];
}

function isPMeta(param) {
  if (param.tag === 11) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function matches_head(env, sigma, pat, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  var head;
  if (pat.tag === 4) {
    if (match.tag === 9) {
      var arg2 = match[1];
      if (isPMeta(pat[0])) {
        head = c;
      } else {
        var n1 = pat[1].length;
        head = n1 < arg2.length ? EConstr$ReactTemplate.mkApp(/* tuple */[
                match[0],
                Util$ReactTemplate.$$Array[/* sub */5](arg2, 0, n1)
              ]) : c;
      }
    } else {
      head = c;
    }
  } else {
    head = match.tag === 9 && !isPMeta(pat) ? match[0] : c;
  }
  return matches(env, sigma, pat, head);
}

function authorized_occ(env, sigma, closed, pat, c, mk_ctx) {
  try {
    var subst = matches_core_closed(env, sigma, pat, c);
    if (closed && Curry._2(Names$ReactTemplate.Id[/* Map */10][/* exists */12], (function (_, c) {
              return 1 - EConstr$ReactTemplate.Vars[/* closed0 */15](sigma, c);
            }), subst[1])) {
      return (function (next) {
          return Curry._1(next, /* () */0);
        });
    } else {
      return (function (next) {
          var s = subst;
          var c = Curry._1(mk_ctx, EConstr$ReactTemplate.mkMeta(-1));
          var n = next;
          return /* Cons */[
                  /* record */[
                    /* m_sub */s,
                    /* m_ctx */c
                  ],
                  IStream$ReactTemplate.thunk(n)
                ];
        });
    }
  }
  catch (exn){
    if (exn === PatternMatchingFailure) {
      return (function (next) {
          return Curry._1(next, /* () */0);
        });
    } else {
      throw exn;
    }
  }
}

function subargs(env, v) {
  return Util$ReactTemplate.$$Array[/* map_to_list */44]((function (c) {
                return /* tuple */[
                        env,
                        c
                      ];
              }), v);
}

function sub_match($staropt$star, env, sigma, pat, c) {
  var closed = $staropt$star ? $staropt$star[0] : /* true */1;
  var aux = function (env, c, mk_ctx, next) {
    var here = authorized_occ(env, sigma, closed, pat, c, mk_ctx);
    return Curry._1(here, (function () {
                  var match = EConstr$ReactTemplate.kind(sigma, c);
                  switch (match.tag | 0) {
                    case 5 : 
                        var c2 = match[2];
                        var k = match[1];
                        var next_mk_ctx = function (param) {
                          if (param) {
                            if (param[1]) {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "constr_matching.ml",
                                      429,
                                      13
                                    ]
                                  ];
                            } else {
                              return Curry._1(mk_ctx, EConstr$ReactTemplate.mkCast(/* tuple */[
                                              param[0],
                                              k,
                                              c2
                                            ]));
                            }
                          } else {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "constr_matching.ml",
                                    429,
                                    13
                                  ]
                                ];
                          }
                        };
                        return try_aux(/* :: */[
                                    /* tuple */[
                                      env,
                                      match[0]
                                    ],
                                    /* [] */0
                                  ], next_mk_ctx, next);
                    case 6 : 
                        var c1 = match[1];
                        var x = match[0];
                        var next_mk_ctx$1 = function (param) {
                          var exit = 0;
                          if (param) {
                            var match = param[1];
                            if (match) {
                              if (match[1]) {
                                exit = 1;
                              } else {
                                return Curry._1(mk_ctx, EConstr$ReactTemplate.mkProd(/* tuple */[
                                                x,
                                                param[0],
                                                match[0]
                                              ]));
                              }
                            } else {
                              exit = 1;
                            }
                          } else {
                            exit = 1;
                          }
                          if (exit === 1) {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "constr_matching.ml",
                                    442,
                                    13
                                  ]
                                ];
                          }
                          
                        };
                        var env$prime = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                x,
                                c1
                              ]), env);
                        return try_aux(/* :: */[
                                    /* tuple */[
                                      env,
                                      c1
                                    ],
                                    /* :: */[
                                      /* tuple */[
                                        env$prime,
                                        match[2]
                                      ],
                                      /* [] */0
                                    ]
                                  ], next_mk_ctx$1, next);
                    case 7 : 
                        var c1$1 = match[1];
                        var x$1 = match[0];
                        var next_mk_ctx$2 = function (param) {
                          var exit = 0;
                          if (param) {
                            var match = param[1];
                            if (match) {
                              if (match[1]) {
                                exit = 1;
                              } else {
                                return Curry._1(mk_ctx, EConstr$ReactTemplate.mkLambda(/* tuple */[
                                                x$1,
                                                param[0],
                                                match[0]
                                              ]));
                              }
                            } else {
                              exit = 1;
                            }
                          } else {
                            exit = 1;
                          }
                          if (exit === 1) {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "constr_matching.ml",
                                    435,
                                    13
                                  ]
                                ];
                          }
                          
                        };
                        var env$prime$1 = EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                x$1,
                                c1$1
                              ]), env);
                        return try_aux(/* :: */[
                                    /* tuple */[
                                      env,
                                      c1$1
                                    ],
                                    /* :: */[
                                      /* tuple */[
                                        env$prime$1,
                                        match[2]
                                      ],
                                      /* [] */0
                                    ]
                                  ], next_mk_ctx$2, next);
                    case 8 : 
                        var t = match[2];
                        var c1$2 = match[1];
                        var x$2 = match[0];
                        var next_mk_ctx$3 = function (param) {
                          var exit = 0;
                          if (param) {
                            var match = param[1];
                            if (match) {
                              if (match[1]) {
                                exit = 1;
                              } else {
                                return Curry._1(mk_ctx, EConstr$ReactTemplate.mkLetIn(/* tuple */[
                                                x$2,
                                                param[0],
                                                t,
                                                match[0]
                                              ]));
                              }
                            } else {
                              exit = 1;
                            }
                          } else {
                            exit = 1;
                          }
                          if (exit === 1) {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "constr_matching.ml",
                                    449,
                                    13
                                  ]
                                ];
                          }
                          
                        };
                        var env$prime$2 = EConstr$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                                x$2,
                                c1$2,
                                t
                              ]), env);
                        return try_aux(/* :: */[
                                    /* tuple */[
                                      env,
                                      c1$2
                                    ],
                                    /* :: */[
                                      /* tuple */[
                                        env$prime$2,
                                        match[3]
                                      ],
                                      /* [] */0
                                    ]
                                  ], next_mk_ctx$3, next);
                    case 9 : 
                        var lc = match[1];
                        var lc1 = Util$ReactTemplate.$$Array[/* sub */5](lc, 0, lc.length - 1 | 0);
                        var app = EConstr$ReactTemplate.mkApp(/* tuple */[
                              match[0],
                              lc1
                            ]);
                        var mk_ctx$1 = function (param) {
                          var exit = 0;
                          if (param) {
                            var match = param[1];
                            if (match) {
                              if (match[1]) {
                                exit = 1;
                              } else {
                                return Curry._1(mk_ctx, EConstr$ReactTemplate.mkApp(/* tuple */[
                                                param[0],
                                                /* array */[match[0]]
                                              ]));
                              }
                            } else {
                              exit = 1;
                            }
                          } else {
                            exit = 1;
                          }
                          if (exit === 1) {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "constr_matching.ml",
                                    458,
                                    14
                                  ]
                                ];
                          }
                          
                        };
                        return try_aux(/* :: */[
                                    /* tuple */[
                                      env,
                                      app
                                    ],
                                    /* :: */[
                                      /* tuple */[
                                        env,
                                        Util$ReactTemplate.$$Array[/* last */34](lc)
                                      ],
                                      /* [] */0
                                    ]
                                  ], mk_ctx$1, next);
                    case 13 : 
                        var ci = match[0];
                        var next_mk_ctx$4 = function (param) {
                          if (param) {
                            var match = param[1];
                            if (match) {
                              return Curry._1(mk_ctx, EConstr$ReactTemplate.mkCase(/* tuple */[
                                              ci,
                                              match[0],
                                              param[0],
                                              Util$ReactTemplate.$$Array[/* of_list */10](match[1])
                                            ]));
                            } else {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "constr_matching.ml",
                                      463,
                                      13
                                    ]
                                  ];
                            }
                          } else {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "constr_matching.ml",
                                    463,
                                    13
                                  ]
                                ];
                          }
                        };
                        var sub_000 = /* tuple */[
                          env,
                          match[2]
                        ];
                        var sub_001 = /* :: */[
                          /* tuple */[
                            env,
                            match[1]
                          ],
                          subargs(env, match[3])
                        ];
                        var sub = /* :: */[
                          sub_000,
                          sub_001
                        ];
                        return try_aux(sub, next_mk_ctx$4, next);
                    case 14 : 
                        var match$1 = match[0];
                        var recdefs = match$1[1];
                        var types = recdefs[1];
                        var names = recdefs[0];
                        var indx = match$1[0];
                        var nb_fix = types.length;
                        var next_mk_ctx$5 = function (le) {
                          var match = CList$ReactTemplate.chop(nb_fix, le);
                          return Curry._1(mk_ctx, EConstr$ReactTemplate.mkFix(/* tuple */[
                                          indx,
                                          /* tuple */[
                                            names,
                                            Util$ReactTemplate.$$Array[/* of_list */10](match[0]),
                                            Util$ReactTemplate.$$Array[/* of_list */10](match[1])
                                          ]
                                        ]));
                        };
                        var env$prime$3 = EConstr$ReactTemplate.push_rec_types(recdefs, env);
                        var sub$1 = Util$ReactTemplate.$at(subargs(env, types), subargs(env$prime$3, recdefs[2]));
                        return try_aux(sub$1, next_mk_ctx$5, next);
                    case 15 : 
                        var match$2 = match[0];
                        var recdefs$1 = match$2[1];
                        var types$1 = recdefs$1[1];
                        var names$1 = recdefs$1[0];
                        var i = match$2[0];
                        var nb_fix$1 = types$1.length;
                        var next_mk_ctx$6 = function (le) {
                          var match = CList$ReactTemplate.chop(nb_fix$1, le);
                          return Curry._1(mk_ctx, EConstr$ReactTemplate.mkCoFix(/* tuple */[
                                          i,
                                          /* tuple */[
                                            names$1,
                                            Util$ReactTemplate.$$Array[/* of_list */10](match[0]),
                                            Util$ReactTemplate.$$Array[/* of_list */10](match[1])
                                          ]
                                        ]));
                        };
                        var env$prime$4 = EConstr$ReactTemplate.push_rec_types(recdefs$1, env);
                        var sub$2 = Util$ReactTemplate.$at(subargs(env, types$1), subargs(env$prime$4, recdefs$1[2]));
                        return try_aux(sub$2, next_mk_ctx$6, next);
                    case 16 : 
                        try {
                          var term = Retyping$ReactTemplate.expand_projection(env, sigma, match[0], match[1], /* [] */0);
                          return aux(env, term, mk_ctx, next);
                        }
                        catch (raw_exn){
                          var exn = Js_exn.internalToOCamlException(raw_exn);
                          if (exn[0] === Retyping$ReactTemplate.RetypeError) {
                            return Curry._1(next, /* () */0);
                          } else {
                            throw exn;
                          }
                        }
                        break;
                    default:
                      return Curry._1(next, /* () */0);
                  }
                }));
  };
  var try_aux = function (lc, mk_ctx, next) {
    var try_sub_match_rec = function (lacc, lc) {
      if (lc) {
        var tl = lc[1];
        var match = lc[0];
        var c = match[1];
        var mk_ctx$1 = function (ce) {
          return Curry._1(mk_ctx, Curry._2(Util$ReactTemplate.List[/* rev_append */6], lacc, /* :: */[
                          ce,
                          Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                  return prim[1];
                                }), tl)
                        ]));
        };
        var next$1 = function () {
          return try_sub_match_rec(/* :: */[
                      c,
                      lacc
                    ], tl);
        };
        return aux(match[0], c, mk_ctx$1, next$1);
      } else {
        return Curry._1(next, /* () */0);
      }
    };
    return try_sub_match_rec(/* [] */0, lc);
  };
  var lempty = function () {
    return /* Nil */0;
  };
  return IStream$ReactTemplate.thunk((function () {
                return aux(env, c, (function (x) {
                              return x;
                            }), lempty);
              }));
}

function match_subterm(env, sigma, pat, c) {
  return sub_match(/* None */0, env, sigma, pat, c);
}

function is_matching(env, sigma, pat, c) {
  try {
    matches(env, sigma, pat, c);
    return /* true */1;
  }
  catch (exn){
    if (exn === PatternMatchingFailure) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_matching_head(env, sigma, pat, c) {
  try {
    matches_head(env, sigma, pat, c);
    return /* true */1;
  }
  catch (exn){
    if (exn === PatternMatchingFailure) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_matching_appsubterm($staropt$star, env, sigma, pat, c) {
  var closed = $staropt$star ? $staropt$star[0] : /* true */1;
  var pat_000 = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var pat$1 = /* tuple */[
    pat_000,
    pat
  ];
  var results = sub_match(/* Some */[closed], env, sigma, pat$1, c);
  return 1 - IStream$ReactTemplate.is_empty(results);
}

var special_meta = -1;

exports.PatternMatchingFailure = PatternMatchingFailure;
exports.special_meta = special_meta;
exports.matches = matches;
exports.matches_head = matches_head;
exports.extended_matches = extended_matches;
exports.is_matching = is_matching;
exports.is_matching_head = is_matching_head;
exports.match_subterm = match_subterm;
exports.is_matching_appsubterm = is_matching_appsubterm;
/* warn_meta_collision Not a pure module */
