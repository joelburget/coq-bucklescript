// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var CProfile$ReactTemplate = require("../shims/cProfile.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");
var Type_errors$ReactTemplate = require("./type_errors.bs.js");

function conv_leq(l2r, env, x, y) {
  return Reduction$ReactTemplate.default_conv(/* CUMUL */1, /* Some */[l2r], env, x, y);
}

function conv_leq_vecti(env, v1, v2) {
  return Util$ReactTemplate.$$Array[/* fold_left2_i */42]((function (i, _, t1, t2) {
                try {
                  return conv_leq(/* false */0, env, t1, t2);
                }
                catch (exn){
                  if (exn === Reduction$ReactTemplate.NotConvertible) {
                    throw [
                          Reduction$ReactTemplate.NotConvertibleVect,
                          i
                        ];
                  } else {
                    throw exn;
                  }
                }
              }), /* () */0, v1, v2);
}

function check_constraints(cst, env) {
  if (Environ$ReactTemplate.check_constraints(cst, env)) {
    return /* () */0;
  } else {
    return Type_errors$ReactTemplate.error_unsatisfied_constraints(env, cst);
  }
}

function check_type(env, c, t) {
  var match = Constr$ReactTemplate.kind(Reduction$ReactTemplate.whd_all(env, t));
  if (match.tag === 4) {
    return match[0];
  } else {
    return Type_errors$ReactTemplate.error_not_type(env, Environ$ReactTemplate.make_judge(c, t));
  }
}

function check_assumption(env, t, ty) {
  try {
    check_type(env, t, ty);
    return t;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Type_errors$ReactTemplate.TypeError) {
      return Type_errors$ReactTemplate.error_assumption(env, Environ$ReactTemplate.make_judge(t, ty));
    } else {
      throw exn;
    }
  }
}

var type1 = Constr$ReactTemplate.mkSort(Sorts$ReactTemplate.type1);

function type_of_sort(param) {
  if (param.tag) {
    return Constr$ReactTemplate.mkType(Univ$ReactTemplate.Universe[/* super */10](param[0]));
  } else {
    return type1;
  }
}

function type_of_relative(env, n) {
  try {
    return Vars$ReactTemplate.lift(n)(Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], Environ$ReactTemplate.lookup_rel(n, env)));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Type_errors$ReactTemplate.error_unbound_rel(env, n);
    } else {
      throw exn;
    }
  }
}

function type_of_variable(env, id) {
  try {
    return Environ$ReactTemplate.named_type(id, env);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Type_errors$ReactTemplate.error_unbound_var(env, id);
    } else {
      throw exn;
    }
  }
}

function check_hyps_inclusion(env, f, c, sign) {
  return Context$ReactTemplate.Named[/* fold_outside */9]((function (d1, _) {
                var id = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d1);
                try {
                  var d2 = Environ$ReactTemplate.lookup_named(id, env);
                  Curry._2(Reduction$ReactTemplate.conv(/* None */0, /* None */0, env, /* None */0), Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], d2), Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], d1));
                  if (d2.tag) {
                    if (d1.tag) {
                      return Curry._2(Reduction$ReactTemplate.conv(/* None */0, /* None */0, env, /* None */0), d2[1], d1[1]);
                    } else {
                      throw Reduction$ReactTemplate.NotConvertible;
                    }
                  } else {
                    return /* () */0;
                  }
                }
                catch (exn){
                  var exit = 0;
                  if (exn === Caml_builtin_exceptions.not_found) {
                    exit = 1;
                  } else if (exn === Reduction$ReactTemplate.NotConvertible) {
                    exit = 1;
                  } else if (exn === Option$ReactTemplate.Heterogeneous) {
                    exit = 1;
                  } else {
                    throw exn;
                  }
                  if (exit === 1) {
                    return Type_errors$ReactTemplate.error_reference_variables(env, id, Curry._1(f, c));
                  }
                  
                }
              }), sign, /* () */0);
}

function type_of_constant(env, cst) {
  var cb = Environ$ReactTemplate.lookup_constant(cst[0], env);
  check_hyps_inclusion(env, Constr$ReactTemplate.mkConstU, cst, cb[/* const_hyps */0]);
  var match = Environ$ReactTemplate.constant_type(env, cst);
  check_constraints(match[1], env);
  return match[0];
}

function type_of_constant_in(env, cst) {
  var cb = Environ$ReactTemplate.lookup_constant(cst[0], env);
  check_hyps_inclusion(env, Constr$ReactTemplate.mkConstU, cst, cb[/* const_hyps */0]);
  return Environ$ReactTemplate.constant_type_in(env, cst);
}

function type_of_abstraction(_, name, $$var, ty) {
  return Constr$ReactTemplate.mkProd(/* tuple */[
              name,
              $$var,
              ty
            ]);
}

function make_judgev(c, t) {
  return Util$ReactTemplate.$$Array[/* map2 */49](Environ$ReactTemplate.make_judge, c, t);
}

function type_of_apply(env, func, funt, argsv, argstv) {
  var len = argsv.length;
  var apply_rec = function (i, typ) {
    if (i === len) {
      return typ;
    } else {
      var match = Constr$ReactTemplate.kind(Reduction$ReactTemplate.whd_all(env, typ));
      if (match.tag === 6) {
        var c1 = match[1];
        var arg = Caml_array.caml_array_get(argsv, i);
        var argt = Caml_array.caml_array_get(argstv, i);
        try {
          conv_leq(/* false */0, env, argt, c1);
          return apply_rec(i + 1 | 0, Vars$ReactTemplate.subst1(arg, match[2]));
        }
        catch (exn){
          if (exn === Reduction$ReactTemplate.NotConvertible) {
            return Type_errors$ReactTemplate.error_cant_apply_bad_type(env, /* tuple */[
                        i + 1 | 0,
                        c1,
                        argt
                      ], Environ$ReactTemplate.make_judge(func, funt), make_judgev(argsv, argstv));
          } else {
            throw exn;
          }
        }
      } else {
        return Type_errors$ReactTemplate.error_cant_apply_not_functional(env, Environ$ReactTemplate.make_judge(func, funt), make_judgev(argsv, argstv));
      }
    }
  };
  return apply_rec(0, funt);
}

function sort_of_product(env, domsort, rangsort) {
  var exit = 0;
  if (rangsort.tag) {
    exit = 1;
  } else if (rangsort[0] !== 0) {
    return rangsort;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (domsort.tag) {
      var u1 = domsort[0];
      if (rangsort.tag) {
        return /* Type */Block.__(1, [Univ$ReactTemplate.Universe[/* sup */11](u1, rangsort[0])]);
      } else if (Environ$ReactTemplate.is_impredicative_set(env)) {
        return rangsort;
      } else {
        return /* Type */Block.__(1, [Univ$ReactTemplate.Universe[/* sup */11](Univ$ReactTemplate.Universe[/* type0 */13], u1)]);
      }
    } else if (!rangsort.tag || domsort[0] !== 0) {
      return rangsort;
    } else {
      return /* Type */Block.__(1, [Univ$ReactTemplate.Universe[/* sup */11](Univ$ReactTemplate.Universe[/* type0 */13], rangsort[0])]);
    }
  }
  
}

function type_of_product(env, _, s1, s2) {
  return Constr$ReactTemplate.mkSort(sort_of_product(env, s1, s2));
}

function check_cast(env, c, ct, k, expected_type) {
  try {
    switch (k) {
      case 0 : 
          return Reduction$ReactTemplate.vm_conv(/* CUMUL */1, env, ct, expected_type);
      case 1 : 
          throw [
                Caml_builtin_exceptions.match_failure,
                [
                  "typeops.ml",
                  222,
                  4
                ]
              ];
      case 2 : 
          return Reduction$ReactTemplate.default_conv(/* CUMUL */1, /* Some */[/* false */0], env, ct, expected_type);
      case 3 : 
          return Reduction$ReactTemplate.default_conv(/* CUMUL */1, /* Some */[/* true */1], env, ct, expected_type);
      
    }
  }
  catch (exn){
    if (exn === Reduction$ReactTemplate.NotConvertible) {
      return Type_errors$ReactTemplate.error_actual_type(env, Environ$ReactTemplate.make_judge(c, ct), expected_type);
    } else {
      throw exn;
    }
  }
}

function type_of_inductive_knowing_parameters(env, indu, args) {
  var spec = Inductive$ReactTemplate.lookup_mind_specif(env, indu[0]);
  check_hyps_inclusion(env, Constr$ReactTemplate.mkIndU, indu, spec[0][/* mind_hyps */4]);
  var match = Inductive$ReactTemplate.constrained_type_of_inductive_knowing_parameters(env, /* tuple */[
        spec,
        indu[1]
      ], args);
  check_constraints(match[1], env);
  return match[0];
}

function type_of_inductive(env, indu) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, indu[0]);
  var mib = match[0];
  check_hyps_inclusion(env, Constr$ReactTemplate.mkIndU, indu, mib[/* mind_hyps */4]);
  var match$1 = Inductive$ReactTemplate.constrained_type_of_inductive(env, /* tuple */[
        /* tuple */[
          mib,
          match[1]
        ],
        indu[1]
      ]);
  check_constraints(match$1[1], env);
  return match$1[0];
}

function type_of_constructor(env, cu) {
  var c = cu[0];
  var mib = Environ$ReactTemplate.lookup_mind(c[0][0], env);
  check_hyps_inclusion(env, Constr$ReactTemplate.mkConstructU, cu, mib[/* mind_hyps */4]);
  var specif = Inductive$ReactTemplate.lookup_mind_specif(env, Names$ReactTemplate.inductive_of_constructor(c));
  var match = Inductive$ReactTemplate.constrained_type_of_constructor(cu, specif);
  check_constraints(match[1], env);
  return match[0];
}

function check_branch_types(env, param, c, ct, lft, explft) {
  try {
    return conv_leq_vecti(env, lft, explft);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Reduction$ReactTemplate.NotConvertibleVect) {
      var i = exn[1];
      return Type_errors$ReactTemplate.error_ill_formed_branch(env, c, /* tuple */[
                  /* tuple */[
                    param[0],
                    i + 1 | 0
                  ],
                  param[1]
                ], Caml_array.caml_array_get(lft, i), Caml_array.caml_array_get(explft, i));
    } else if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return Type_errors$ReactTemplate.error_number_branches(env, Environ$ReactTemplate.make_judge(c, ct), explft.length);
    } else {
      throw exn;
    }
  }
}

function type_of_case(env, ci, p, pt, c, ct, _, lft) {
  var indspec;
  try {
    indspec = Inductive$ReactTemplate.find_rectype(env, ct);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      indspec = Type_errors$ReactTemplate.error_case_not_inductive(env, Environ$ReactTemplate.make_judge(c, ct));
    } else {
      throw exn;
    }
  }
  var pind = indspec[0];
  Inductive$ReactTemplate.check_case_info(env, pind, ci);
  var match = Inductive$ReactTemplate.type_case_branches(env, indspec, Environ$ReactTemplate.make_judge(p, pt), c);
  check_branch_types(env, pind, c, ct, lft, match[0]);
  return match[1];
}

function type_of_projection(env, p, c, ct) {
  var pb = Environ$ReactTemplate.lookup_projection(p, env);
  var match;
  try {
    match = Inductive$ReactTemplate.find_rectype(env, ct);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      match = Type_errors$ReactTemplate.error_case_not_inductive(env, Environ$ReactTemplate.make_judge(c, ct));
    } else {
      throw exn;
    }
  }
  var match$1 = match[0];
  if (!Names$ReactTemplate.MutInd[/* equal */12](pb[/* proj_ind */0], match$1[0][0])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typeops.ml",
            306,
            2
          ]
        ];
  }
  var ty = Vars$ReactTemplate.subst_instance_constr(match$1[1], pb[/* proj_type */3]);
  return Vars$ReactTemplate.substl(/* :: */[
              c,
              CList$ReactTemplate.rev(match[1])
            ], ty);
}

function check_fixpoint(env, lna, lar, vdef, vdeft) {
  var lt = vdeft.length;
  if (lar.length !== lt) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "typeops.ml",
            318,
            2
          ]
        ];
  }
  try {
    return conv_leq_vecti(env, vdeft, Util$ReactTemplate.$$Array[/* map */12]((function (ty) {
                      return Vars$ReactTemplate.lift(lt)(ty);
                    }), lar));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Reduction$ReactTemplate.NotConvertibleVect) {
      return Type_errors$ReactTemplate.error_ill_typed_rec_body(env, exn[1], lna, make_judgev(vdef, vdeft), lar);
    } else {
      throw exn;
    }
  }
}

function execute(env, cstr) {
  var match = Constr$ReactTemplate.kind(cstr);
  switch (match.tag | 0) {
    case 0 : 
        return type_of_relative(env, match[0]);
    case 1 : 
        return type_of_variable(env, match[0]);
    case 2 : 
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("the kernel does not support metavariables."));
    case 3 : 
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("the kernel does not support existential variables."));
    case 4 : 
        return type_of_sort(match[0]);
    case 5 : 
        var t = match[2];
        var c = match[0];
        var ct = execute(env, c);
        check_type(env, t, execute(env, t));
        check_cast(env, c, ct, match[1], t);
        return t;
    case 6 : 
        var c1 = match[1];
        var name = match[0];
        var vars = execute_is_type(env, c1);
        var env1 = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                name,
                c1
              ]), env);
        var vars$prime = execute_is_type(env1, match[2]);
        return type_of_product(env, name, vars, vars$prime);
    case 7 : 
        var c1$1 = match[1];
        var name$1 = match[0];
        execute_is_type(env, c1$1);
        var env1$1 = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                name$1,
                c1$1
              ]), env);
        var c2t = execute(env1$1, match[2]);
        return type_of_abstraction(env, name$1, c1$1, c2t);
    case 8 : 
        var c2 = match[2];
        var c1$2 = match[1];
        var c1t = execute(env, c1$2);
        execute_is_type(env, c2);
        check_cast(env, c1$2, c1t, /* DEFAULTcast */2, c2);
        var env1$2 = Environ$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                match[0],
                c1$2,
                c2
              ]), env);
        var c3t = execute(env1$2, match[3]);
        return Vars$ReactTemplate.subst1(c1$2, c3t);
    case 9 : 
        var args = match[1];
        var f = match[0];
        var partial_arg = Util$ReactTemplate.$$Array[/* map */12];
        var argst = (function (param) {
              return partial_arg((function (param) {
                            return execute(env, param);
                          }), param);
            })(args);
        var match$1 = Constr$ReactTemplate.kind(f);
        var ft;
        if (match$1.tag === 11) {
          var ind = match$1[0];
          if (Environ$ReactTemplate.template_polymorphic_pind(ind, env)) {
            var args$1 = Util$ReactTemplate.$$Array[/* map */12]((function (t) {
                    return Block.__(250, [t]);
                  }), argst);
            ft = type_of_inductive_knowing_parameters(env, ind, args$1);
          } else {
            ft = execute(env, f);
          }
        } else {
          ft = execute(env, f);
        }
        return type_of_apply(env, f, ft, args, argst);
    case 10 : 
        return type_of_constant(env, match[0]);
    case 11 : 
        return type_of_inductive(env, match[0]);
    case 12 : 
        return type_of_constructor(env, match[0]);
    case 13 : 
        var lf = match[3];
        var c$1 = match[2];
        var p = match[1];
        var ct$1 = execute(env, c$1);
        var pt = execute(env, p);
        var partial_arg$1 = Util$ReactTemplate.$$Array[/* map */12];
        var lft = (function (param) {
              return partial_arg$1((function (param) {
                            return execute(env, param);
                          }), param);
            })(lf);
        return type_of_case(env, match[0], p, pt, c$1, ct$1, lf, lft);
    case 14 : 
        var match$2 = match[0];
        var vni = match$2[0];
        var match$3 = execute_recdef(env, match$2[1], vni[1]);
        var fix_001 = match$3[1];
        var fix = /* tuple */[
          vni,
          fix_001
        ];
        Inductive$ReactTemplate.check_fix(env, fix);
        return match$3[0];
    case 15 : 
        var match$4 = match[0];
        var i = match$4[0];
        var match$5 = execute_recdef(env, match$4[1], i);
        var cofix_001 = match$5[1];
        var cofix = /* tuple */[
          i,
          cofix_001
        ];
        Inductive$ReactTemplate.check_cofix(env, cofix);
        return match$5[0];
    case 16 : 
        var c$2 = match[1];
        var ct$2 = execute(env, c$2);
        return type_of_projection(env, match[0], c$2, ct$2);
    
  }
}

function execute_is_type(env, constr) {
  var t = execute(env, constr);
  return check_type(env, constr, t);
}

function execute_recdef(env, param, i) {
  var vdef = param[2];
  var lar = param[1];
  var names = param[0];
  var partial_arg = Util$ReactTemplate.$$Array[/* map */12];
  var lart = (function (param) {
        return partial_arg((function (param) {
                      return execute(env, param);
                    }), param);
      })(lar);
  var lara = Util$ReactTemplate.$$Array[/* map2 */49]((function (param, param$1) {
          return check_assumption(env, param, param$1);
        }), lar, lart);
  var env1 = Environ$ReactTemplate.push_rec_types(/* tuple */[
        names,
        lara,
        vdef
      ], env);
  var partial_arg$1 = Util$ReactTemplate.$$Array[/* map */12];
  var vdeft = (function (param) {
        return partial_arg$1((function (param) {
                      return execute(env1, param);
                    }), param);
      })(vdef);
  check_fixpoint(env1, names, lara, vdef, vdeft);
  return /* tuple */[
          Caml_array.caml_array_get(lara, i),
          /* tuple */[
            names,
            lara,
            vdef
          ]
        ];
}

function infer(env, constr) {
  var t = execute(env, constr);
  return Environ$ReactTemplate.make_judge(constr, t);
}

var infer$1;

if (Flags$ReactTemplate.profile) {
  var infer_key = CProfile$ReactTemplate.declare_profile("Fast_infer");
  infer$1 = CProfile$ReactTemplate.profile2(infer_key, infer);
} else {
  infer$1 = infer;
}

function assumption_of_judgment(env, param) {
  return check_assumption(env, param[/* uj_val */0], param[/* uj_type */1]);
}

function type_judgment(env, param) {
  var c = param[/* uj_val */0];
  var s = check_type(env, c, param[/* uj_type */1]);
  return /* record */[
          /* utj_val */c,
          /* utj_type */s
        ];
}

function infer_type(env, constr) {
  var t = execute(env, constr);
  var s = check_type(env, constr, t);
  return /* record */[
          /* utj_val */constr,
          /* utj_type */s
        ];
}

function infer_v(env, cv) {
  var partial_arg = Util$ReactTemplate.$$Array[/* map */12];
  var jv = (function (param) {
        return partial_arg((function (param) {
                      return execute(env, param);
                    }), param);
      })(cv);
  return make_judgev(cv, jv);
}

function infer_local_decl(env, id, param) {
  if (param.tag) {
    var c = param[0];
    var t = execute(env, c);
    return /* LocalAssum */Block.__(0, [
              /* Name */[id],
              check_assumption(env, c, t)
            ]);
  } else {
    var c$1 = param[0];
    var t$1 = execute(env, c$1);
    return /* LocalDef */Block.__(1, [
              /* Name */[id],
              c$1,
              t$1
            ]);
  }
}

function infer_local_decls(env, decls) {
  var inferec = function (env, param) {
    if (param) {
      var match = param[0];
      var match$1 = inferec(env, param[1]);
      var env$1 = match$1[0];
      var d = infer_local_decl(env$1, match[0], match[1]);
      return /* tuple */[
              Environ$ReactTemplate.push_rel(d, env$1),
              Context$ReactTemplate.Rel[/* add */2](d, match$1[1])
            ];
    } else {
      return /* tuple */[
              env,
              Context$ReactTemplate.Rel[/* empty */1]
            ];
    }
  };
  return inferec(env, decls);
}

var judge_of_prop = Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkProp, type1);

var judge_of_set = Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkSet, type1);

function judge_of_type(u) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkType(u), Constr$ReactTemplate.mkType(Univ$ReactTemplate.Universe[/* super */10](u)));
}

function judge_of_prop_contents(param) {
  if (param !== 0) {
    return judge_of_prop;
  } else {
    return judge_of_set;
  }
}

function judge_of_relative(env, k) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkRel(k), type_of_relative(env, k));
}

function judge_of_variable(env, x) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkVar(x), type_of_variable(env, x));
}

function judge_of_constant(env, cst) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkConstU(cst), type_of_constant(env, cst));
}

function judge_of_projection(env, p, cj) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkProj(/* tuple */[
                  p,
                  cj[/* uj_val */0]
                ]), type_of_projection(env, p, cj[/* uj_val */0], cj[/* uj_type */1]));
}

function dest_judgev(v) {
  return /* tuple */[
          Util$ReactTemplate.$$Array[/* map */12](Environ$ReactTemplate.j_val, v),
          Util$ReactTemplate.$$Array[/* map */12](Environ$ReactTemplate.j_type, v)
        ];
}

function judge_of_apply(env, funj, argjv) {
  var match = dest_judgev(argjv);
  var args = match[0];
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkApp(/* tuple */[
                  funj[/* uj_val */0],
                  args
                ]), type_of_apply(env, funj[/* uj_val */0], funj[/* uj_type */1], args, match[1]));
}

function judge_of_abstraction(env, x, varj, bodyj) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkLambda(/* tuple */[
                  x,
                  varj[/* utj_val */0],
                  bodyj[/* uj_val */0]
                ]), type_of_abstraction(env, x, varj[/* utj_val */0], bodyj[/* uj_type */1]));
}

function judge_of_product(env, x, varj, outj) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkProd(/* tuple */[
                  x,
                  varj[/* utj_val */0],
                  outj[/* utj_val */0]
                ]), Constr$ReactTemplate.mkSort(sort_of_product(env, varj[/* utj_type */1], outj[/* utj_type */1])));
}

function judge_of_letin(_, name, defj, typj, j) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkLetIn(/* tuple */[
                  name,
                  defj[/* uj_val */0],
                  typj[/* utj_val */0],
                  j[/* uj_val */0]
                ]), Vars$ReactTemplate.subst1(defj[/* uj_val */0], j[/* uj_type */1]));
}

function judge_of_cast(env, cj, k, tj) {
  check_cast(env, cj[/* uj_val */0], cj[/* uj_type */1], k, tj[/* utj_val */0]);
  var c = k >= 3 ? cj[/* uj_val */0] : Constr$ReactTemplate.mkCast(/* tuple */[
          cj[/* uj_val */0],
          k,
          tj[/* utj_val */0]
        ]);
  return Environ$ReactTemplate.make_judge(c, tj[/* utj_val */0]);
}

function judge_of_inductive(env, indu) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkIndU(indu), type_of_inductive(env, indu));
}

function judge_of_constructor(env, cu) {
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkConstructU(cu), type_of_constructor(env, cu));
}

function judge_of_case(env, ci, pj, cj, lfj) {
  var match = dest_judgev(lfj);
  var lft = match[1];
  return Environ$ReactTemplate.make_judge(Constr$ReactTemplate.mkCase(/* tuple */[
                  ci,
                  pj[/* uj_val */0],
                  cj[/* uj_val */0],
                  lft
                ]), type_of_case(env, ci, pj[/* uj_val */0], pj[/* uj_type */1], cj[/* uj_val */0], cj[/* uj_type */1], match[0], lft));
}

function type_of_projection_constant(env, param) {
  var cst = Names$ReactTemplate.Projection[/* constant */2](param[0]);
  var cb = Environ$ReactTemplate.lookup_constant(cst, env);
  var match = cb[/* const_proj */5];
  if (match) {
    var pb = match[0];
    if (Declareops$ReactTemplate.constant_is_polymorphic(cb)) {
      return Vars$ReactTemplate.subst_instance_constr(param[1], pb[/* proj_type */3]);
    } else {
      return pb[/* proj_type */3];
    }
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "type_of_projection: not a projection"
        ];
  }
}

exports.infer = infer$1;
exports.infer_v = infer_v;
exports.infer_type = infer_type;
exports.infer_local_decls = infer_local_decls;
exports.assumption_of_judgment = assumption_of_judgment;
exports.type_judgment = type_judgment;
exports.type1 = type1;
exports.type_of_sort = type_of_sort;
exports.judge_of_prop = judge_of_prop;
exports.judge_of_set = judge_of_set;
exports.judge_of_prop_contents = judge_of_prop_contents;
exports.judge_of_type = judge_of_type;
exports.type_of_relative = type_of_relative;
exports.judge_of_relative = judge_of_relative;
exports.type_of_variable = type_of_variable;
exports.judge_of_variable = judge_of_variable;
exports.judge_of_constant = judge_of_constant;
exports.judge_of_projection = judge_of_projection;
exports.judge_of_apply = judge_of_apply;
exports.judge_of_abstraction = judge_of_abstraction;
exports.sort_of_product = sort_of_product;
exports.type_of_product = type_of_product;
exports.judge_of_product = judge_of_product;
exports.judge_of_letin = judge_of_letin;
exports.judge_of_cast = judge_of_cast;
exports.judge_of_inductive = judge_of_inductive;
exports.judge_of_constructor = judge_of_constructor;
exports.judge_of_case = judge_of_case;
exports.type_of_projection_constant = type_of_projection_constant;
exports.type_of_constant_in = type_of_constant_in;
exports.check_hyps_inclusion = check_hyps_inclusion;
/* type1 Not a pure module */
