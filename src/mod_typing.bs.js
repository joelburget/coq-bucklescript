// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Modops$ReactTemplate = require("./modops.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var UGraph$ReactTemplate = require("./uGraph.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Typeops$ReactTemplate = require("./typeops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Subtyping$ReactTemplate = require("./subtyping.bs.js");
var Cemitcodes$ReactTemplate = require("./cemitcodes.bs.js");

function mp_from_mexpr(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return param[0];
      case 1 : 
      case 2 : 
          _param = param[0];
          continue ;
          
    }
  };
}

function is_modular(param) {
  switch (param.tag | 0) {
    case 0 : 
    case 1 : 
        return /* false */0;
    case 2 : 
    case 3 : 
        return /* true */1;
    
  }
}

function split_struc(k, m, struc) {
  var _rev_before = /* [] */0;
  var _param = struc;
  while(true) {
    var param = _param;
    var rev_before = _rev_before;
    if (param) {
      var after = param[1];
      var h = param[0];
      var b = h[1];
      if (Names$ReactTemplate.Label[/* equal */0](k, h[0]) && is_modular(b) === m) {
        return /* tuple */[
                Curry._1(Util$ReactTemplate.List[/* rev */4], rev_before),
                b,
                after
              ];
      } else {
        _param = after;
        _rev_before = /* :: */[
          h,
          rev_before
        ];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function discr_resolver(mtb) {
  var match = mtb[/* mod_type */2];
  if (match.tag) {
    return Mod_subst$ReactTemplate.empty_delta_resolver;
  } else {
    return mtb[/* mod_delta */5];
  }
}

function rebuild_mp(_mp, _l) {
  while(true) {
    var l = _l;
    var mp = _mp;
    if (l) {
      _l = l[1];
      _mp = /* MPdot */Block.__(2, [
          mp,
          Names$ReactTemplate.Label[/* of_id */5](l[0])
        ]);
      continue ;
      
    } else {
      return mp;
    }
  };
}

var $plus$plus$plus = Univ$ReactTemplate.ContextSet[/* union */6];

function check_with_def(env, struc, param, mp, equiv) {
  var match = param[1];
  var ctx = match[1];
  var c = match[0];
  var idl = param[0];
  var match$1;
  if (idl) {
    match$1 = /* tuple */[
      Names$ReactTemplate.Label[/* of_id */5](idl[0]),
      idl[1]
    ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "mod_typing.ml",
            61,
            12
          ]
        ];
  }
  var idl$1 = match$1[1];
  var lab = match$1[0];
  try {
    var modular = 1 - Curry._1(Util$ReactTemplate.List[/* is_empty */45], idl$1);
    var match$2 = split_struc(lab, modular, struc);
    var after = match$2[2];
    var spec = match$2[1];
    var before = match$2[0];
    var env$prime = Modops$ReactTemplate.add_structure(mp, before, equiv, env);
    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], idl$1)) {
      var cb;
      cb = spec.tag ? Modops$ReactTemplate.error_not_a_constant(lab) : spec[0];
      var match$3 = cb[/* const_universes */4];
      var match$4;
      if (match$3.tag) {
        if (ctx) {
          var ctx$1 = ctx[0];
          var uctx = match$3[0];
          if (!UGraph$ReactTemplate.check_subtype(Environ$ReactTemplate.universes(env), uctx, ctx$1)) {
            Modops$ReactTemplate.error_incorrect_with_constraint(lab);
          }
          var env$prime$1 = Environ$ReactTemplate.push_context(/* Some */[/* false */0], Univ$ReactTemplate.AUContext[/* repr */0](uctx), env);
          var match$5 = cb[/* const_body */1];
          var cst;
          var exit = 0;
          switch (match$5.tag | 0) {
            case 1 : 
                var c$prime = Mod_subst$ReactTemplate.force_constr(match$5[0]);
                cst = Reduction$ReactTemplate.infer_conv(/* None */0, /* None */0, /* None */0, env$prime$1, Environ$ReactTemplate.universes(env$prime$1), c, c$prime);
                break;
            case 0 : 
            case 2 : 
                exit = 1;
                break;
            
          }
          if (exit === 1) {
            var j = Curry._2(Typeops$ReactTemplate.infer, env$prime$1, c);
            var typ = cb[/* const_type */2];
            cst = Reduction$ReactTemplate.infer_conv_leq(/* None */0, /* None */0, /* None */0, env$prime$1, Environ$ReactTemplate.universes(env$prime$1), j[/* uj_type */1], typ);
          }
          if (!Curry._1(Univ$ReactTemplate.Constraint[/* is_empty */1], cst)) {
            Modops$ReactTemplate.error_incorrect_with_constraint(lab);
          }
          match$4 = /* tuple */[
            c,
            /* Polymorphic_const */Block.__(1, [ctx$1]),
            Univ$ReactTemplate.Constraint[/* empty */0]
          ];
        } else {
          match$4 = Modops$ReactTemplate.error_incorrect_with_constraint(lab);
        }
      } else if (ctx) {
        match$4 = Modops$ReactTemplate.error_incorrect_with_constraint(lab);
      } else {
        var match$6 = cb[/* const_body */1];
        var match$7;
        var exit$1 = 0;
        switch (match$6.tag | 0) {
          case 1 : 
              var c$prime$1 = Mod_subst$ReactTemplate.force_constr(match$6[0]);
              match$7 = /* tuple */[
                c,
                Reduction$ReactTemplate.infer_conv(/* None */0, /* None */0, /* None */0, env$prime, Environ$ReactTemplate.universes(env$prime), c, c$prime$1)
              ];
              break;
          case 0 : 
          case 2 : 
              exit$1 = 1;
              break;
          
        }
        if (exit$1 === 1) {
          var j$1 = Curry._2(Typeops$ReactTemplate.infer, env$prime, c);
          var typ$1 = cb[/* const_type */2];
          var cst$prime = Reduction$ReactTemplate.infer_conv_leq(/* None */0, /* None */0, /* None */0, env$prime, Environ$ReactTemplate.universes(env$prime), j$1[/* uj_type */1], typ$1);
          match$7 = /* tuple */[
            j$1[/* uj_val */0],
            cst$prime
          ];
        }
        match$4 = /* tuple */[
          match$7[0],
          /* Monomorphic_const */Block.__(0, [Univ$ReactTemplate.ContextSet[/* empty */0]]),
          match$7[1]
        ];
      }
      var c$prime$2 = match$4[0];
      var def = /* Def */Block.__(1, [Mod_subst$ReactTemplate.from_val(c$prime$2)]);
      var cb$prime_000 = /* const_hyps */cb[/* const_hyps */0];
      var cb$prime_002 = /* const_type */cb[/* const_type */2];
      var cb$prime_003 = /* const_body_code */Option$ReactTemplate.map(Cemitcodes$ReactTemplate.from_val, Environ$ReactTemplate.compile_constant_body(env$prime, cb[/* const_universes */4], def));
      var cb$prime_004 = /* const_universes */match$4[1];
      var cb$prime_005 = /* const_proj */cb[/* const_proj */5];
      var cb$prime_006 = /* const_inline_code */cb[/* const_inline_code */6];
      var cb$prime_007 = /* const_typing_flags */cb[/* const_typing_flags */7];
      var cb$prime = /* record */[
        cb$prime_000,
        /* const_body */def,
        cb$prime_002,
        cb$prime_003,
        cb$prime_004,
        cb$prime_005,
        cb$prime_006,
        cb$prime_007
      ];
      return /* tuple */[
              Util$ReactTemplate.$at(before, /* :: */[
                    /* tuple */[
                      lab,
                      /* SFBconst */Block.__(0, [cb$prime])
                    ],
                    after
                  ]),
              c$prime$2,
              match$4[2]
            ];
    } else {
      var mb;
      mb = spec.tag === 2 ? spec[0] : Modops$ReactTemplate.error_not_a_module(Names$ReactTemplate.Label[/* to_string */4](lab));
      var match$8 = mb[/* mod_expr */1];
      if (typeof match$8 === "number") {
        if (match$8 !== 0) {
          return Modops$ReactTemplate.error_generative_module_expected(lab);
        } else {
          var struc$1 = Modops$ReactTemplate.destr_nofunctor(mb[/* mod_type */2]);
          var match$9 = check_with_def(env$prime, struc$1, /* tuple */[
                idl$1,
                /* tuple */[
                  c,
                  ctx
                ]
              ], /* MPdot */Block.__(2, [
                  mp,
                  lab
                ]), mb[/* mod_delta */5]);
          var mb$prime_000 = /* mod_mp */mb[/* mod_mp */0];
          var mb$prime_001 = /* mod_expr */mb[/* mod_expr */1];
          var mb$prime_002 = /* mod_type : NoFunctor */Block.__(0, [match$9[0]]);
          var mb$prime_004 = /* mod_constraints */mb[/* mod_constraints */4];
          var mb$prime_005 = /* mod_delta */mb[/* mod_delta */5];
          var mb$prime_006 = /* mod_retroknowledge */mb[/* mod_retroknowledge */6];
          var mb$prime = /* record */[
            mb$prime_000,
            mb$prime_001,
            mb$prime_002,
            /* mod_type_alg : None */0,
            mb$prime_004,
            mb$prime_005,
            mb$prime_006
          ];
          return /* tuple */[
                  Util$ReactTemplate.$at(before, /* :: */[
                        /* tuple */[
                          lab,
                          /* SFBmodule */Block.__(2, [mb$prime])
                        ],
                        after
                      ]),
                  match$9[1],
                  match$9[2]
                ];
        }
      } else {
        return Modops$ReactTemplate.error_generative_module_expected(lab);
      }
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Modops$ReactTemplate.error_no_such_label(lab);
    } else if (exn === Reduction$ReactTemplate.NotConvertible) {
      return Modops$ReactTemplate.error_incorrect_with_constraint(lab);
    } else {
      throw exn;
    }
  }
}

function check_with_mod(env, struc, param, mp, equiv) {
  var mp1 = param[1];
  var idl = param[0];
  var match;
  if (idl) {
    match = /* tuple */[
      Names$ReactTemplate.Label[/* of_id */5](idl[0]),
      idl[1]
    ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "mod_typing.ml",
            151,
            12
          ]
        ];
  }
  var idl$1 = match[1];
  var lab = match[0];
  try {
    var match$1 = split_struc(lab, /* true */1, struc);
    var after = match$1[2];
    var spec = match$1[1];
    var before = match$1[0];
    var env$prime = Modops$ReactTemplate.add_structure(mp, before, equiv, env);
    var old;
    old = spec.tag === 2 ? spec[0] : Modops$ReactTemplate.error_not_a_module(Names$ReactTemplate.Label[/* to_string */4](lab));
    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], idl$1)) {
      var mb_mp1 = Environ$ReactTemplate.lookup_module(mp1, env);
      var mtb_mp1 = Modops$ReactTemplate.module_type_of_module(mb_mp1);
      var match$2 = old[/* mod_expr */1];
      var cst;
      if (typeof match$2 === "number") {
        if (match$2) {
          cst = Modops$ReactTemplate.error_generative_module_expected(lab);
        } else {
          var mtb_old = Modops$ReactTemplate.module_type_of_module(old);
          var chk_cst = Subtyping$ReactTemplate.check_subtypes(env$prime, mtb_mp1, mtb_old);
          cst = Univ$ReactTemplate.ContextSet[/* add_constraints */10](chk_cst, old[/* mod_constraints */4]);
        }
      } else if (match$2.tag) {
        cst = Modops$ReactTemplate.error_generative_module_expected(lab);
      } else {
        var match$3 = match$2[0];
        if (match$3.tag) {
          cst = Modops$ReactTemplate.error_generative_module_expected(lab);
        } else {
          var match$4 = match$3[0];
          switch (match$4.tag | 0) {
            case 0 : 
                Modops$ReactTemplate.check_modpath_equiv(env$prime, mp1, match$4[0]);
                cst = old[/* mod_constraints */4];
                break;
            case 1 : 
            case 2 : 
                cst = Modops$ReactTemplate.error_generative_module_expected(lab);
                break;
            
          }
        }
      }
      var mp$prime = /* MPdot */Block.__(2, [
          mp,
          lab
        ]);
      var new_mb = Modops$ReactTemplate.strengthen_and_subst_mb(mb_mp1, mp$prime, /* false */0);
      var new_mb$prime_001 = /* mod_expr : Algebraic */Block.__(0, [/* NoFunctor */Block.__(0, [/* MEident */Block.__(0, [mp1])])]);
      var new_mb$prime_002 = /* mod_type */new_mb[/* mod_type */2];
      var new_mb$prime_003 = /* mod_type_alg */new_mb[/* mod_type_alg */3];
      var new_mb$prime_005 = /* mod_delta */new_mb[/* mod_delta */5];
      var new_mb$prime_006 = /* mod_retroknowledge */new_mb[/* mod_retroknowledge */6];
      var new_mb$prime = /* record */[
        /* mod_mp */mp$prime,
        new_mb$prime_001,
        new_mb$prime_002,
        new_mb$prime_003,
        /* mod_constraints */cst,
        new_mb$prime_005,
        new_mb$prime_006
      ];
      var new_equiv = Mod_subst$ReactTemplate.add_delta_resolver(equiv, new_mb[/* mod_delta */5]);
      var id_subst = Mod_subst$ReactTemplate.map_mp(mp$prime, mp$prime, new_mb[/* mod_delta */5]);
      var new_after = Modops$ReactTemplate.subst_structure(id_subst)(after);
      return /* tuple */[
              Util$ReactTemplate.$at(before, /* :: */[
                    /* tuple */[
                      lab,
                      /* SFBmodule */Block.__(2, [new_mb$prime])
                    ],
                    new_after
                  ]),
              new_equiv,
              cst
            ];
    } else {
      var mp$prime$1 = /* MPdot */Block.__(2, [
          mp,
          lab
        ]);
      var old$1;
      old$1 = spec.tag === 2 ? spec[0] : Modops$ReactTemplate.error_not_a_module(Names$ReactTemplate.Label[/* to_string */4](lab));
      var match$5 = old$1[/* mod_expr */1];
      if (typeof match$5 === "number") {
        if (match$5) {
          return Modops$ReactTemplate.error_generative_module_expected(lab);
        } else {
          var struc$1 = Modops$ReactTemplate.destr_nofunctor(old$1[/* mod_type */2]);
          var match$6 = check_with_mod(env$prime, struc$1, /* tuple */[
                idl$1,
                mp1
              ], mp$prime$1, old$1[/* mod_delta */5]);
          var equiv$prime = match$6[1];
          var new_mb_000 = /* mod_mp */old$1[/* mod_mp */0];
          var new_mb_001 = /* mod_expr */old$1[/* mod_expr */1];
          var new_mb_002 = /* mod_type : NoFunctor */Block.__(0, [match$6[0]]);
          var new_mb_004 = /* mod_constraints */old$1[/* mod_constraints */4];
          var new_mb_006 = /* mod_retroknowledge */old$1[/* mod_retroknowledge */6];
          var new_mb$1 = /* record */[
            new_mb_000,
            new_mb_001,
            new_mb_002,
            /* mod_type_alg : None */0,
            new_mb_004,
            /* mod_delta */equiv$prime,
            new_mb_006
          ];
          var new_equiv$1 = Mod_subst$ReactTemplate.add_delta_resolver(equiv, equiv$prime);
          var id_subst$1 = Mod_subst$ReactTemplate.map_mp(mp$prime$1, mp$prime$1, equiv$prime);
          var new_after$1 = Modops$ReactTemplate.subst_structure(id_subst$1)(after);
          return /* tuple */[
                  Util$ReactTemplate.$at(before, /* :: */[
                        /* tuple */[
                          lab,
                          /* SFBmodule */Block.__(2, [new_mb$1])
                        ],
                        new_after$1
                      ]),
                  new_equiv$1,
                  match$6[2]
                ];
        }
      } else if (match$5.tag) {
        return Modops$ReactTemplate.error_generative_module_expected(lab);
      } else {
        var match$7 = match$5[0];
        if (match$7.tag) {
          return Modops$ReactTemplate.error_generative_module_expected(lab);
        } else {
          var match$8 = match$7[0];
          switch (match$8.tag | 0) {
            case 0 : 
                var mpnew = rebuild_mp(match$8[0], idl$1);
                Modops$ReactTemplate.check_modpath_equiv(env$prime, mpnew, mp);
                return /* tuple */[
                        Util$ReactTemplate.$at(before, /* :: */[
                              /* tuple */[
                                lab,
                                spec
                              ],
                              after
                            ]),
                        equiv,
                        Univ$ReactTemplate.ContextSet[/* empty */0]
                      ];
            case 1 : 
            case 2 : 
                return Modops$ReactTemplate.error_generative_module_expected(lab);
            
          }
        }
      }
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Modops$ReactTemplate.error_no_such_label(lab);
    } else if (exn === Reduction$ReactTemplate.NotConvertible) {
      return Modops$ReactTemplate.error_incorrect_with_constraint(lab);
    } else {
      throw exn;
    }
  }
}

function translate_apply(env, inl, param, mp1, mkalg) {
  var match = Modops$ReactTemplate.destr_functor(param[0]);
  var farg_b = match[1];
  var farg_id = match[0];
  var mtb = Modops$ReactTemplate.module_type_of_module(Environ$ReactTemplate.lookup_module(mp1, env));
  var cst2 = Subtyping$ReactTemplate.check_subtypes(env, mtb, farg_b);
  var mp_delta = discr_resolver(mtb);
  var mp_delta$1 = Modops$ReactTemplate.inline_delta_resolver(env, inl, mp1, farg_id, farg_b, mp_delta);
  var subst = Mod_subst$ReactTemplate.map_mbid(farg_id, mp1, mp_delta$1);
  var body = Modops$ReactTemplate.subst_signature(subst)(match[2]);
  var alg$prime = Curry._2(mkalg, param[1], mp1);
  var reso$prime = Mod_subst$ReactTemplate.subst_codom_delta_resolver(subst, param[2]);
  return /* tuple */[
          body,
          alg$prime,
          reso$prime,
          Univ$ReactTemplate.ContextSet[/* add_constraints */10](cst2, param[3])
        ];
}

function mk_alg_app(alg, arg) {
  return /* MEapply */Block.__(1, [
            alg,
            arg
          ]);
}

function translate_mse(env, mpo, inl, me) {
  switch (me.tag | 0) {
    case 0 : 
        var mp1 = me[0];
        var mb;
        if (mpo) {
          mb = Modops$ReactTemplate.strengthen_and_subst_mb(Environ$ReactTemplate.lookup_module(mp1, env), mpo[0], /* false */0);
        } else {
          var mt = Environ$ReactTemplate.lookup_modtype(mp1, env);
          mb = Modops$ReactTemplate.module_body_of_type(mt[/* mod_mp */0], mt);
        }
        return /* tuple */[
                mb[/* mod_type */2],
                me,
                mb[/* mod_delta */5],
                Univ$ReactTemplate.ContextSet[/* empty */0]
              ];
    case 1 : 
        return translate_apply(env, inl, translate_mse(env, mpo, inl, me[0]), me[1], mk_alg_app);
    case 2 : 
        var me$1 = me[0];
        if (mpo !== /* None */0) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "mod_typing.ml",
                  266,
                  4
                ]
              ];
        }
        var mp = mp_from_mexpr(me$1);
        var env$1 = env;
        var mp$1 = mp;
        var param = translate_mse(env, /* None */0, inl, me$1);
        var wd = me[1];
        var cst = param[3];
        var reso = param[2];
        var alg = param[1];
        var sign = param[0];
        if (wd.tag) {
          var match = wd[1];
          var ctx = match[1];
          var idl = wd[0];
          var struc = Modops$ReactTemplate.destr_nofunctor(sign);
          var match$1 = check_with_def(env$1, struc, /* tuple */[
                idl,
                /* tuple */[
                  match[0],
                  ctx
                ]
              ], mp$1, reso);
          var wd$prime_001 = /* tuple */[
            match$1[1],
            ctx
          ];
          var wd$prime = /* WithDef */Block.__(1, [
              idl,
              wd$prime_001
            ]);
          return /* tuple */[
                  /* NoFunctor */Block.__(0, [match$1[0]]),
                  /* MEwith */Block.__(2, [
                      alg,
                      wd$prime
                    ]),
                  reso,
                  Univ$ReactTemplate.ContextSet[/* add_constraints */10](match$1[2], cst)
                ];
        } else {
          var struc$1 = Modops$ReactTemplate.destr_nofunctor(sign);
          var match$2 = check_with_mod(env$1, struc$1, /* tuple */[
                wd[0],
                wd[1]
              ], mp$1, reso);
          return /* tuple */[
                  /* NoFunctor */Block.__(0, [match$2[0]]),
                  /* MEwith */Block.__(2, [
                      alg,
                      wd
                    ]),
                  match$2[1],
                  Curry._2($plus$plus$plus, cst, match$2[2])
                ];
        }
    
  }
}

function mk_mod(mp, e, ty, cst, reso) {
  return /* record */[
          /* mod_mp */mp,
          /* mod_expr */e,
          /* mod_type */ty,
          /* mod_type_alg : None */0,
          /* mod_constraints */cst,
          /* mod_delta */reso,
          /* mod_retroknowledge : ModBodyRK */[/* [] */0]
        ];
}

function mk_modtype(mp, ty, cst, reso) {
  var mb = mk_mod(mp, /* Abstract */0, ty, cst, reso);
  return /* record */[
          /* mod_mp */mb[/* mod_mp */0],
          /* mod_expr : () */0,
          /* mod_type */mb[/* mod_type */2],
          /* mod_type_alg */mb[/* mod_type_alg */3],
          /* mod_constraints */mb[/* mod_constraints */4],
          /* mod_delta */mb[/* mod_delta */5],
          /* mod_retroknowledge : ModTypeRK */0
        ];
}

function translate_mse_funct(env, mpo, inl, mse, param) {
  if (param) {
    var match = param[0];
    var mbid = match[0];
    var mp_id = /* MPbound */Block.__(1, [mbid]);
    var mtb = translate_modtype(env, mp_id, inl, /* tuple */[
          /* [] */0,
          match[1]
        ]);
    var env$prime = Modops$ReactTemplate.add_module_type(mp_id, mtb, env);
    var match$1 = translate_mse_funct(env$prime, mpo, inl, mse, param[1]);
    var alg$prime_002 = match$1[1];
    var alg$prime = /* MoreFunctor */Block.__(1, [
        mbid,
        mtb,
        alg$prime_002
      ]);
    return /* tuple */[
            /* MoreFunctor */Block.__(1, [
                mbid,
                mtb,
                match$1[0]
              ]),
            alg$prime,
            match$1[2],
            Curry._2($plus$plus$plus, match$1[3], mtb[/* mod_constraints */4])
          ];
  } else {
    var match$2 = translate_mse(env, mpo, inl, mse);
    return /* tuple */[
            match$2[0],
            /* NoFunctor */Block.__(0, [match$2[1]]),
            match$2[2],
            match$2[3]
          ];
  }
}

function translate_modtype(env, mp, inl, param) {
  var mte = param[1];
  var match = translate_mse_funct(env, /* None */0, inl, mte, param[0]);
  var mtb = mk_modtype(mp_from_mexpr(mte), match[0], match[3], match[2]);
  var mtb$prime = Modops$ReactTemplate.subst_modtype_and_resolver(mtb, mp);
  var newrecord = mtb$prime.slice();
  newrecord[/* mod_type_alg */3] = /* Some */[match[1]];
  return newrecord;
}

function finalize_module(env, mp, param, restype) {
  var cst = param[3];
  var reso = param[2];
  var alg = param[1];
  var sign = param[0];
  if (restype) {
    var match = restype[0];
    var res_mtb = translate_modtype(env, mp, match[1], match[0]);
    var auto_mtb = mk_modtype(mp, sign, Univ$ReactTemplate.ContextSet[/* empty */0], reso);
    var cst$prime = Subtyping$ReactTemplate.check_subtypes(env, auto_mtb, res_mtb);
    var impl = alg ? /* Algebraic */Block.__(0, [alg[0]]) : /* Struct */Block.__(1, [sign]);
    return /* record */[
            /* mod_mp */mp,
            /* mod_expr */impl,
            /* mod_type */res_mtb[/* mod_type */2],
            /* mod_type_alg */res_mtb[/* mod_type_alg */3],
            /* mod_constraints */Univ$ReactTemplate.ContextSet[/* add_constraints */10](cst$prime, Curry._2($plus$plus$plus, cst, res_mtb[/* mod_constraints */4])),
            /* mod_delta */res_mtb[/* mod_delta */5],
            /* mod_retroknowledge : ModBodyRK */[/* [] */0]
          ];
  } else {
    var impl$1 = alg ? /* Algebraic */Block.__(0, [alg[0]]) : /* FullStruct */1;
    return mk_mod(mp, impl$1, sign, cst, reso);
  }
}

function translate_module(env, mp, inl, param) {
  if (param.tag) {
    var params = param[0];
    var match = translate_mse_funct(env, /* Some */[mp], inl, param[1], params);
    var restype = Option$ReactTemplate.map((function (ty) {
            return /* tuple */[
                    /* tuple */[
                      params,
                      ty
                    ],
                    inl
                  ];
          }), param[2]);
    return finalize_module(env, mp, /* tuple */[
                match[0],
                /* Some */[match[1]],
                match[2],
                match[3]
              ], restype);
  } else {
    var mtb = translate_modtype(env, mp, inl, /* tuple */[
          param[0],
          param[1]
        ]);
    return Modops$ReactTemplate.module_body_of_type(mp, mtb);
  }
}

function unfunct(_param) {
  while(true) {
    var param = _param;
    if (param.tag) {
      _param = param[2];
      continue ;
      
    } else {
      return param[0];
    }
  };
}

function forbid_incl_signed_functor(env, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          var mp1 = param[0];
          var mb = Environ$ReactTemplate.lookup_module(mp1, env);
          var match = mb[/* mod_type */2];
          var match$1 = mb[/* mod_type_alg */3];
          var match$2 = mb[/* mod_expr */1];
          if (match.tag) {
            if (match$1) {
              return Modops$ReactTemplate.error_include_restricted_functor(mp1);
            } else if (typeof match$2 === "number") {
              return /* () */0;
            } else if (match$2.tag) {
              return /* () */0;
            } else {
              _param = unfunct(match$2[0]);
              continue ;
              
            }
          } else {
            return /* () */0;
          }
          break;
      case 1 : 
          _param = param[0];
          continue ;
          case 2 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "mod_typing.ml",
                  344,
                  15
                ]
              ];
      
    }
  };
}

function translate_mse_inclmod(env, mp, inl, param) {
  switch (param.tag | 0) {
    case 0 : 
        var mb = Modops$ReactTemplate.strengthen_and_subst_mb(Environ$ReactTemplate.lookup_module(param[0], env), mp, /* true */1);
        var sign = Modops$ReactTemplate.clean_bounded_mod_expr(mb[/* mod_type */2]);
        return /* tuple */[
                sign,
                /* () */0,
                mb[/* mod_delta */5],
                Univ$ReactTemplate.ContextSet[/* empty */0]
              ];
    case 1 : 
        var ftrans = translate_mse_inclmod(env, mp, inl, param[0]);
        return translate_apply(env, inl, ftrans, param[1], (function (_, _$1) {
                      return /* () */0;
                    }));
    case 2 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "mod_typing.ml",
                364,
                15
              ]
            ];
    
  }
}

function translate_mse_incl(is_mod, env, mp, inl, me) {
  if (is_mod) {
    forbid_incl_signed_functor(env, me);
    return translate_mse_inclmod(env, mp, inl, me);
  } else {
    var mtb = translate_modtype(env, mp, inl, /* tuple */[
          /* [] */0,
          me
        ]);
    var sign = Modops$ReactTemplate.clean_bounded_mod_expr(mtb[/* mod_type */2]);
    return /* tuple */[
            sign,
            /* () */0,
            mtb[/* mod_delta */5],
            mtb[/* mod_constraints */4]
          ];
  }
}

exports.translate_module = translate_module;
exports.translate_modtype = translate_modtype;
exports.translate_mse = translate_mse;
exports.finalize_module = finalize_module;
exports.translate_mse_incl = translate_mse_incl;
/* Univ-ReactTemplate Not a pure module */
