// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Evar$ReactTemplate = require("../src/evar.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Vars$ReactTemplate = require("../src/vars.bs.js");
var Clenv$ReactTemplate = require("../proofs/clenv.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Hints$ReactTemplate = require("./hints.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Genarg$ReactTemplate = require("../src/genarg.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var Pfedit$ReactTemplate = require("../src/pfedit.bs.js");
var Stdarg$ReactTemplate = require("../src/stdarg.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Ftactic$ReactTemplate = require("../src/ftactic.bs.js");
var Tacmach$ReactTemplate = require("../proofs/tacmach.bs.js");
var Tactics$ReactTemplate = require("../src/tactics.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var CProfile$ReactTemplate = require("../shims/cProfile.bs.js");
var Clenvtac$ReactTemplate = require("../proofs/clenvtac.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Locusops$ReactTemplate = require("../src/locusops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Geninterp$ReactTemplate = require("../src/geninterp.bs.js");
var Proofview$ReactTemplate = require("../src/proofview.bs.js");
var Tacticals$ReactTemplate = require("./tacticals.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Constr_matching$ReactTemplate = require("../src/constr_matching.bs.js");

function priority(l) {
  return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                return +(param[1][/* pri */0] === 0);
              }), l);
}

function compute_secvars(gl) {
  return Hints$ReactTemplate.secvars_of_hyps(Proofview$ReactTemplate.Goal[/* hyps */3](gl));
}

function auto_core_unif_flags_of(st1, st2) {
  return /* record */[
          /* modulo_conv_on_closed_terms : Some */[st1],
          /* use_metas_eagerly_in_conv_on_closed_terms : false */0,
          /* use_evars_eagerly_in_conv_on_closed_terms : false */0,
          /* modulo_delta */st2,
          /* modulo_delta_types */Names$ReactTemplate.full_transparent_state,
          /* check_applied_meta_types : false */0,
          /* use_pattern_unification : false */0,
          /* use_meta_bound_pattern_unification : true */1,
          /* frozen_evars */Evar$ReactTemplate.$$Set[/* empty */0],
          /* restrict_conv_on_strict_subterms : false */0,
          /* modulo_betaiota : false */0,
          /* modulo_eta : true */1
        ];
}

function auto_unif_flags_of(st1, st2) {
  var flags = auto_core_unif_flags_of(st1, st2);
  var newrecord = flags.slice();
  return /* record */[
          /* core_unify_flags */flags,
          /* merge_unify_flags */flags,
          /* subterm_unify_flags */(newrecord[/* modulo_delta */3] = Names$ReactTemplate.empty_transparent_state, newrecord),
          /* allow_K_in_toplevel_higher_order_unification : false */0,
          /* resolve_evars : true */1
        ];
}

var auto_unif_flags = auto_unif_flags_of(Names$ReactTemplate.full_transparent_state, Names$ReactTemplate.empty_transparent_state);

function connect_hint_clenv(poly, param, clenv, gl) {
  var ctx = param[2];
  var c = param[0];
  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
  var evd = Evd$ReactTemplate.evars_reset_evd(/* Some */[/* true */1], /* Some */[/* false */0], sigma, clenv[/* evd */1]);
  var match;
  if (poly) {
    var match$1 = Universes$ReactTemplate.fresh_universe_context_set_instance(ctx);
    var subst = match$1[0];
    var map = function (c) {
      return Vars$ReactTemplate.subst_univs_level_constr(subst, c);
    };
    var emap = function (c) {
      return EConstr$ReactTemplate.Vars[/* subst_univs_level_constr */16](subst, c);
    };
    var evd$1 = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible, evd, match$1[1]);
    var clenv_000 = /* env */Proofview$ReactTemplate.Goal[/* env */4](gl);
    var clenv_001 = /* evd */Evd$ReactTemplate.map_metas(map, evd$1);
    var clenv_002 = /* templval */Evd$ReactTemplate.map_fl(emap, clenv[/* templval */2]);
    var clenv_003 = /* templtyp */Evd$ReactTemplate.map_fl(emap, clenv[/* templtyp */3]);
    var clenv$1 = /* record */[
      clenv_000,
      clenv_001,
      clenv_002,
      clenv_003
    ];
    match = /* tuple */[
      clenv$1,
      EConstr$ReactTemplate.Vars[/* subst_univs_level_constr */16](subst, c)
    ];
  } else {
    var evd$2 = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible, evd, ctx);
    match = /* tuple */[
      /* record */[
        /* env */Proofview$ReactTemplate.Goal[/* env */4](gl),
        /* evd */evd$2,
        /* templval */clenv[/* templval */2],
        /* templtyp */clenv[/* templtyp */3]
      ],
      c
    ];
  }
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function unify_resolve(poly, flags, param) {
  var clenv = param[1];
  var c = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var match = connect_hint_clenv(poly, c, clenv, gl);
                var clenv$1 = Clenv$ReactTemplate.clenv_unique_resolver(/* Some */[flags], match[0], gl);
                return Clenvtac$ReactTemplate.clenv_refine(/* false */0, /* None */0, clenv$1);
              }));
}

function unify_resolve_gen(poly, param) {
  if (param) {
    var flags = param[0];
    return (function (param) {
        return unify_resolve(poly, flags, param);
      });
  } else {
    return (function (param) {
        return unify_resolve(poly, auto_unif_flags, param);
      });
  }
}

function conclPattern(concl, pat, tac) {
  var constr_bindings = function (env, sigma) {
    if (pat) {
      try {
        return Curry._1(Proofview$ReactTemplate.tclUNIT, Constr_matching$ReactTemplate.matches(env, sigma, pat[0], concl));
      }
      catch (exn){
        if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
          return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("pattern-matching failed"));
        } else {
          throw exn;
        }
      }
    } else {
      return Curry._1(Proofview$ReactTemplate.tclUNIT, Names$ReactTemplate.Id[/* Map */10][/* empty */0]);
    }
  };
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], constr_bindings(env, sigma), (function (constr_bindings) {
                              var inj = function (c) {
                                var match = Geninterp$ReactTemplate.val_tag(Genarg$ReactTemplate.topwit(Stdarg$ReactTemplate.wit_constr));
                                if (match.tag) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "auto.ml",
                                          154,
                                          12
                                        ]
                                      ];
                                } else {
                                  return /* Dyn */[
                                          match[0],
                                          c
                                        ];
                                }
                              };
                              var fold = function (id, c, accu) {
                                return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, inj(c), accu);
                              };
                              var lfun = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], fold, constr_bindings, Names$ReactTemplate.Id[/* Map */10][/* empty */0]);
                              var ist_001 = /* extra */Geninterp$ReactTemplate.TacStore[/* empty */0];
                              var ist = /* record */[
                                /* lfun */lfun,
                                ist_001
                              ];
                              return Ftactic$ReactTemplate.run(Curry._3(Geninterp$ReactTemplate.interp, tac[0][0], ist, tac[1]), (function () {
                                            return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
                                          }));
                            }));
              }));
}

var global_debug_trivial = [/* false */0];

var global_debug_auto = [/* false */0];

var global_info_trivial = [/* false */0];

var global_info_auto = [/* false */0];

function add_option(ls, refe) {
  Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
        /* optdepr : false */0,
        /* optname */Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", ls),
        /* optkey */ls,
        /* optread */(function () {
            return refe[0];
          }),
        /* optwrite */(function (param) {
            refe[0] = param;
            return /* () */0;
          })
      ]);
  return /* () */0;
}

add_option(/* :: */[
      "Debug",
      /* :: */[
        "Trivial",
        /* [] */0
      ]
    ], global_debug_trivial);

add_option(/* :: */[
      "Debug",
      /* :: */[
        "Auto",
        /* [] */0
      ]
    ], global_debug_auto);

add_option(/* :: */[
      "Info",
      /* :: */[
        "Trivial",
        /* [] */0
      ]
    ], global_info_trivial);

add_option(/* :: */[
      "Info",
      /* :: */[
        "Auto",
        /* [] */0
      ]
    ], global_info_auto);

function no_dbg(param) {
  return /* tuple */[
          /* Off */2,
          param[1],
          0,
          [/* [] */0]
        ];
}

function mk_trivial_dbg(debug) {
  var d = debug === /* Debug */0 || global_debug_trivial[0] ? /* Debug */0 : (
      debug === /* Info */1 || global_info_trivial[0] ? /* Info */1 : /* Off */2
    );
  return /* tuple */[
          d,
          /* ReportForTrivial */0,
          0,
          [/* [] */0]
        ];
}

function mk_auto_dbg(debug) {
  var d = debug === /* Debug */0 || global_debug_auto[0] ? /* Debug */0 : (
      debug === /* Info */1 || global_info_auto[0] ? /* Info */1 : /* Off */2
    );
  return /* tuple */[
          d,
          /* ReportForAuto */1,
          0,
          [/* [] */0]
        ];
}

function incr_dbg(param) {
  return /* tuple */[
          param[0],
          param[1],
          param[2] + 1 | 0,
          param[3]
        ];
}

function tclLOG(param, pp, tac) {
  var trace = param[3];
  var depth = param[2];
  switch (param[0]) {
    case 0 : 
        var s = Curry._2(Util$ReactTemplate.$$String[/* make */0], depth + 1 | 0, /* "*" */42);
        return Proofview$ReactTemplate.V82[/* tactic */0](/* None */0, (function (gl) {
                      try {
                        var out = Proofview$ReactTemplate.V82[/* of_tactic */7](tac, gl);
                        Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(s), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pp, /* () */0)), Pp$ReactTemplate.str(". (*success*)")));
                        return out;
                      }
                      catch (raw_reraise){
                        var reraise = Js_exn.internalToOCamlException(raw_reraise);
                        var reraise$1 = CErrors$ReactTemplate.push(reraise);
                        Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(s), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pp, /* () */0)), Pp$ReactTemplate.str(". (*fail*)")));
                        return Util$ReactTemplate.iraise(reraise$1);
                      }
                    }));
    case 1 : 
        return Proofview$ReactTemplate.V82[/* tactic */0](/* None */0, (function (gl) {
                      try {
                        var out = Proofview$ReactTemplate.V82[/* of_tactic */7](tac, gl);
                        trace[0] = /* :: */[
                          /* tuple */[
                            depth,
                            /* Some */[pp]
                          ],
                          trace[0]
                        ];
                        return out;
                      }
                      catch (raw_reraise){
                        var reraise = Js_exn.internalToOCamlException(raw_reraise);
                        var reraise$1 = CErrors$ReactTemplate.push(reraise);
                        trace[0] = /* :: */[
                          /* tuple */[
                            depth,
                            /* None */0
                          ],
                          trace[0]
                        ];
                        return Util$ReactTemplate.iraise(reraise$1);
                      }
                    }));
    case 2 : 
        return tac;
    
  }
}

function cleanup_info_trace(_depth, _acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    var depth = _depth;
    if (l) {
      var match = l[0];
      var match$1 = match[1];
      if (match$1) {
        var d = match[0];
        _l = l[1];
        _acc = /* :: */[
          /* tuple */[
            d,
            match$1[0]
          ],
          acc
        ];
        _depth = d;
        continue ;
        
      } else {
        _l = erase_subtree(depth, l);
        continue ;
        
      }
    } else {
      return acc;
    }
  };
}

function erase_subtree(depth, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      if (param[0][0] === depth) {
        return l;
      } else {
        _param = l;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function pr_info_atom(param) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* make */0], param[0], /* " " */32)), Curry._1(param[1], /* () */0)), Pp$ReactTemplate.str("."));
}

function pr_info_trace(param) {
  if (param[0] !== 1) {
    return /* () */0;
  } else {
    var match = param[3][/* contents */0];
    if (match) {
      var match$1 = match[0];
      var match$2 = match$1[1];
      if (match$2) {
        var d = match$1[0];
        return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, pr_info_atom, cleanup_info_trace(d, /* :: */[
                            /* tuple */[
                              d,
                              match$2[0]
                            ],
                            /* [] */0
                          ], match[1])));
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  }
}

function pr_info_nop(param) {
  if (param[0] !== 1) {
    return /* () */0;
  } else {
    return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.str("idtac."));
  }
}

function pr_dbg_header(param) {
  switch (param[0]) {
    case 0 : 
        if (param[1] !== 0) {
          return Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.str("(* debug auto: *)"));
        } else {
          return Feedback$ReactTemplate.msg_debug(/* None */0, Pp$ReactTemplate.str("(* debug trivial: *)"));
        }
    case 1 : 
        if (param[1] !== 0) {
          return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.str("(* info auto: *)"));
        } else {
          return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.str("(* info trivial: *)"));
        }
    case 2 : 
        return /* () */0;
    
  }
}

function tclTRY_dbg(d, tac) {
  var delay = function (f) {
    return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0), (function () {
                  return Curry._1(f, /* () */0);
                }));
  };
  var tac$1 = Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], delay((function () {
              pr_dbg_header(d);
              return tac;
            })), (function () {
          pr_info_trace(d);
          return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
        }));
  var after = delay((function () {
          pr_info_nop(d);
          return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
        }));
  return Tacticals$ReactTemplate.New[/* tclORELSE0 */10](tac$1, after);
}

function auto_flags_of_state(st) {
  return auto_unif_flags_of(Names$ReactTemplate.full_transparent_state, st);
}

function hintmap_of(sigma, secvars, hdc, concl) {
  if (hdc) {
    var hdc$1 = hdc[0];
    if (Termops$ReactTemplate.occur_existential(sigma, concl)) {
      var partial_arg = Hints$ReactTemplate.Hint_db[/* map_existential */4];
      return (function (param) {
          return partial_arg(sigma, secvars, hdc$1, concl, param);
        });
    } else {
      var partial_arg$1 = Hints$ReactTemplate.Hint_db[/* map_auto */6];
      return (function (param) {
          return partial_arg$1(sigma, secvars, hdc$1, concl, param);
        });
    }
  } else {
    var partial_arg$2 = Hints$ReactTemplate.Hint_db[/* map_none */2];
    return (function (param) {
        return partial_arg$2(secvars, param);
      });
  }
}

function exists_evaluable_reference(env, param) {
  if (param.tag) {
    return /* true */1;
  } else {
    try {
      Environ$ReactTemplate.lookup_named(param[0], env);
      return /* true */1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  }
}

function dbg_intro(dbg) {
  return tclLOG(dbg, (function () {
                return Pp$ReactTemplate.str("intro");
              }), Tactics$ReactTemplate.intro);
}

function dbg_assumption(dbg) {
  return tclLOG(dbg, (function () {
                return Pp$ReactTemplate.str("assumption");
              }), Tactics$ReactTemplate.assumption);
}

function trivial_fail_db(dbg, mod_delta, db_list, local_db) {
  var intro_tac = Tacticals$ReactTemplate.New[/* tclTHEN */2](dbg_intro(dbg), Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
              var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
              var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
              var nf = function (c) {
                return Evarutil$ReactTemplate.nf_evar(sigma, c);
              };
              var decl = Tacmach$ReactTemplate.New[/* pf_last_hyp */16](gl);
              var hyp = Curry._2(Context$ReactTemplate.Named[/* Declaration */0][/* map_constr */13], nf, decl);
              var hintl = Hints$ReactTemplate.make_resolve_hyp(env, sigma, hyp);
              return trivial_fail_db(dbg, mod_delta, db_list, Hints$ReactTemplate.Hint_db[/* add_list */8](env, sigma, hintl, local_db));
            })));
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var concl = Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var secvars = Hints$ReactTemplate.secvars_of_hyps(Proofview$ReactTemplate.Goal[/* hyps */3](gl));
                return Tacticals$ReactTemplate.New[/* tclFIRST */23](/* :: */[
                            dbg_assumption(dbg),
                            /* :: */[
                              intro_tac,
                              Curry._2(Util$ReactTemplate.List[/* map */10], Tacticals$ReactTemplate.New[/* tclCOMPLETE */31], trivial_resolve(sigma, dbg, mod_delta, db_list, local_db, secvars, concl))
                            ]
                          ]);
              }));
}

function my_find_search_nodelta(sigma, db_list, local_db, secvars, hdc, concl) {
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (hint) {
                return /* tuple */[
                        /* None */0,
                        hint
                      ];
              }), Curry._2(Util$ReactTemplate.List[/* map_append */113], hintmap_of(sigma, secvars, hdc, concl), /* :: */[
                  local_db,
                  db_list
                ]));
}

function my_find_search_delta(sigma, db_list, local_db, secvars, hdc, concl) {
  var f = hintmap_of(sigma, secvars, hdc, concl);
  if (Termops$ReactTemplate.occur_existential(sigma, concl)) {
    return Curry._2(Util$ReactTemplate.List[/* map_append */113], (function (db) {
                  if (Hints$ReactTemplate.Hint_db[/* use_dn */12](db)) {
                    var st = Hints$ReactTemplate.Hint_db[/* transparent_state */13](db);
                    var flags = auto_unif_flags_of(st, st);
                    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                                  return /* tuple */[
                                          /* Some */[flags],
                                          x
                                        ];
                                }), Curry._1(f, db));
                  } else {
                    var flags$1 = auto_flags_of_state(Hints$ReactTemplate.Hint_db[/* transparent_state */13](db));
                    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                                  return /* tuple */[
                                          /* Some */[flags$1],
                                          x
                                        ];
                                }), Curry._1(f, db));
                  }
                }), /* :: */[
                local_db,
                db_list
              ]);
  } else {
    return Curry._2(Util$ReactTemplate.List[/* map_append */113], (function (db) {
                  if (Hints$ReactTemplate.Hint_db[/* use_dn */12](db)) {
                    var st = Hints$ReactTemplate.Hint_db[/* transparent_state */13](db);
                    var flags = auto_unif_flags_of(st, st);
                    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                                  return /* tuple */[
                                          /* Some */[flags],
                                          x
                                        ];
                                }), Curry._1(f, db));
                  } else {
                    var st$1 = Hints$ReactTemplate.Hint_db[/* transparent_state */13](db);
                    var l;
                    if (hdc) {
                      var hdc$1 = hdc[0];
                      l = Curry._1(Names$ReactTemplate.Id[/* Pred */11][/* is_empty */2], st$1[0]) && Curry._1(Names$ReactTemplate.Cpred[/* is_empty */2], st$1[1]) ? Hints$ReactTemplate.Hint_db[/* map_auto */6](sigma, secvars, hdc$1, concl, db) : Hints$ReactTemplate.Hint_db[/* map_existential */4](sigma, secvars, hdc$1, concl, db);
                    } else {
                      l = Hints$ReactTemplate.Hint_db[/* map_none */2](secvars, db);
                    }
                    var match_000 = auto_flags_of_state(st$1);
                    var flags$1 = match_000;
                    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                                  return /* tuple */[
                                          /* Some */[flags$1],
                                          x
                                        ];
                                }), l);
                  }
                }), /* :: */[
                local_db,
                db_list
              ]);
  }
}

function tac_of_hint(dbg, db_list, local_db, concl, param) {
  var match = param[1];
  var t = match[/* code */6];
  var dbname = match[/* db */4];
  var p = match[/* pat */2];
  var poly = match[/* poly */1];
  var flags = param[0];
  var tactic = function (param) {
    switch (param.tag | 0) {
      case 0 : 
          var match = param[0];
          return Curry._1(unify_resolve_gen(poly, flags), /* tuple */[
                      match[0],
                      match[1]
                    ]);
      case 1 : 
          return Proofview$ReactTemplate.Goal[/* enter */9]((function () {
                        return Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("eres_pf"));
                      }));
      case 2 : 
          var match$1 = param[0];
          var poly$1 = poly;
          var param$1 = /* tuple */[
            match$1[0],
            match$1[1]
          ];
          var clenv = param$1[1];
          var c = param$1[0];
          return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                        var match = connect_hint_clenv(poly$1, c, clenv, gl);
                        return Tacticals$ReactTemplate.New[/* tclTHEN */2](Proofview$ReactTemplate.Unsafe[/* tclEVARUNIVCONTEXT */10](Evd$ReactTemplate.evar_universe_context(match[0][/* evd */1])), Tactics$ReactTemplate.exact_check(match[1]));
                      }));
      case 3 : 
          var match$2 = param[0];
          return Tacticals$ReactTemplate.New[/* tclTHEN */2](Curry._1(unify_resolve_gen(poly, flags), /* tuple */[
                          match$2[0],
                          match$2[1]
                        ]), trivial_fail_db(no_dbg(dbg), 1 - Option$ReactTemplate.is_empty(flags), db_list, local_db));
      case 4 : 
          var c$1 = param[0];
          return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                        if (exists_evaluable_reference(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), c$1)) {
                          return Tacticals$ReactTemplate.New[/* tclPROGRESS */33](Tactics$ReactTemplate.reduce(/* Unfold */Block.__(5, [/* :: */[
                                              /* tuple */[
                                                /* AllOccurrences */0,
                                                c$1
                                              ],
                                              /* [] */0
                                            ]]), Locusops$ReactTemplate.onConcl));
                        } else {
                          return Tacticals$ReactTemplate.New[/* tclFAIL */3](0, Pp$ReactTemplate.str("Unbound reference"));
                        }
                      }));
      case 5 : 
          return conclPattern(concl, p, param[0]);
      
    }
  };
  var pr_hint = function () {
    var origin = dbname ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" (in "), Pp$ReactTemplate.str(dbname[0])), Pp$ReactTemplate.str(")")) : Pp$ReactTemplate.mt(/* () */0);
    var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
    return Pp$ReactTemplate.$plus$plus(Hints$ReactTemplate.pr_hint(match[1], match[0], t), origin);
  };
  return tclLOG(dbg, pr_hint, Hints$ReactTemplate.run_hint(t, tactic));
}

function trivial_resolve(sigma, dbg, mod_delta, db_list, local_db, secvars, cl) {
  try {
    var head;
    try {
      var hdconstr = Hints$ReactTemplate.decompose_app_bound(sigma, cl);
      head = /* Some */[hdconstr];
    }
    catch (exn){
      if (exn === Hints$ReactTemplate.Bound) {
        head = /* None */0;
      } else {
        throw exn;
      }
    }
    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return tac_of_hint(dbg, db_list, local_db, cl, param);
                }), priority(Curry._6(mod_delta ? my_find_search_delta : my_find_search_nodelta, sigma, db_list, local_db, secvars, head, cl)));
  }
  catch (exn$1){
    if (exn$1 === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn$1;
    }
  }
}

function trivial($staropt$star, lems, dbnames) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var db_list = Hints$ReactTemplate.make_db_list(dbnames);
                var d = mk_trivial_dbg(debug);
                var hints = Hints$ReactTemplate.make_local_hint_db(env, sigma, /* None */0, /* false */0, lems);
                return tclTRY_dbg(d, trivial_fail_db(d, /* false */0, db_list, hints));
              }));
}

function full_trivial($staropt$star, lems) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var db_list = Hints$ReactTemplate.current_pure_db(/* () */0);
                var d = mk_trivial_dbg(debug);
                var hints = Hints$ReactTemplate.make_local_hint_db(env, sigma, /* None */0, /* false */0, lems);
                return tclTRY_dbg(d, trivial_fail_db(d, /* false */0, db_list, hints));
              }));
}

function gen_trivial($staropt$star, lems, param) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  if (param) {
    return trivial(/* Some */[debug], lems, param[0]);
  } else {
    return full_trivial(/* Some */[debug], lems);
  }
}

function h_trivial($staropt$star, lems, l) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  return gen_trivial(/* Some */[debug], lems, l);
}

function possible_resolve(sigma, dbg, mod_delta, db_list, local_db, secvars, cl) {
  try {
    var head;
    try {
      var hdconstr = Hints$ReactTemplate.decompose_app_bound(sigma, cl);
      head = /* Some */[hdconstr];
    }
    catch (exn){
      if (exn === Hints$ReactTemplate.Bound) {
        head = /* None */0;
      } else {
        throw exn;
      }
    }
    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return tac_of_hint(dbg, db_list, local_db, cl, param);
                }), Curry._6(mod_delta ? my_find_search_delta : my_find_search_nodelta, sigma, db_list, local_db, secvars, head, cl));
  }
  catch (exn$1){
    if (exn$1 === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    } else {
      throw exn$1;
    }
  }
}

function extend_local_db(decl, db, gl) {
  var env = Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl);
  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
  return Hints$ReactTemplate.Hint_db[/* add_list */8](env, sigma, Hints$ReactTemplate.make_resolve_hyp(env, sigma, decl), db);
}

function intro_register(dbg, kont, db) {
  return Tacticals$ReactTemplate.New[/* tclTHEN */2](dbg_intro(dbg), Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                    return Tacticals$ReactTemplate.New[/* onLastDecl */44]((function (decl) {
                                  return Curry._1(kont, extend_local_db(decl, db, gl));
                                }));
                  })));
}

function search(d, n, mod_delta, db_list, local_db) {
  var search$1 = function (d, n, local_db) {
    return Proofview$ReactTemplate.tclEXTEND(/* [] */0, n ? Tacticals$ReactTemplate.New[/* tclORELSE0 */10](dbg_assumption(d), Tacticals$ReactTemplate.New[/* tclORELSE0 */10](intro_register(d, (function (param) {
                                return search$1(d, n, param);
                              }), local_db), Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                var concl = Curry._1(Tacmach$ReactTemplate.New[/* pf_concl */5], gl);
                                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                                var secvars = Hints$ReactTemplate.secvars_of_hyps(Proofview$ReactTemplate.Goal[/* hyps */3](gl));
                                var d$prime = incr_dbg(d);
                                return Tacticals$ReactTemplate.New[/* tclFIRST */23](Curry._2(Util$ReactTemplate.List[/* map */10], (function (ntac) {
                                                  return Tacticals$ReactTemplate.New[/* tclTHEN */2](ntac, search$1(d$prime, n - 1 | 0, local_db));
                                                }), possible_resolve(sigma, d, mod_delta, db_list, local_db, secvars, concl)));
                              })))) : Tacticals$ReactTemplate.New[/* tclZEROMSG */4](/* None */0, Pp$ReactTemplate.str("BOUND 2")), /* [] */0);
  };
  return search$1(d, n, local_db);
}

var default_search_depth = [5];

function delta_auto(debug, mod_delta, n, lems, dbnames) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var db_list = Hints$ReactTemplate.make_db_list(dbnames);
                var d = mk_auto_dbg(debug);
                var hints = Hints$ReactTemplate.make_local_hint_db(env, sigma, /* None */0, /* false */0, lems);
                return tclTRY_dbg(d, search(d, n, mod_delta, db_list, hints));
              }));
}

var delta_auto$1;

if (Flags$ReactTemplate.profile) {
  var key = CProfile$ReactTemplate.declare_profile("delta_auto");
  delta_auto$1 = CProfile$ReactTemplate.profile5(key, delta_auto);
} else {
  delta_auto$1 = delta_auto;
}

function auto($staropt$star, n) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  return Curry._3(delta_auto$1, debug, /* false */0, n);
}

function new_auto($staropt$star, n) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  return Curry._3(delta_auto$1, debug, /* true */1, n);
}

var default_auto = Curry._2(auto(/* None */0, default_search_depth[0]), /* [] */0, /* [] */0);

function delta_full_auto($staropt$star, mod_delta, n, lems) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
                var db_list = Hints$ReactTemplate.current_pure_db(/* () */0);
                var d = mk_auto_dbg(debug);
                var hints = Hints$ReactTemplate.make_local_hint_db(env, sigma, /* None */0, /* false */0, lems);
                return tclTRY_dbg(d, search(d, n, mod_delta, db_list, hints));
              }));
}

function full_auto($staropt$star, n) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  var partial_arg = /* Some */[debug];
  return (function (param) {
      return delta_full_auto(partial_arg, /* false */0, n, param);
    });
}

function new_full_auto($staropt$star, n) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  var partial_arg = /* Some */[debug];
  return (function (param) {
      return delta_full_auto(partial_arg, /* true */1, n, param);
    });
}

var default_full_auto = full_auto(/* None */0, default_search_depth[0])(/* [] */0);

function gen_auto($staropt$star, n, lems, dbnames) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  var n$1 = n ? n[0] : default_search_depth[0];
  if (dbnames) {
    return Curry._2(auto(/* Some */[debug], n$1), lems, dbnames[0]);
  } else {
    return full_auto(/* Some */[debug], n$1)(lems);
  }
}

function h_auto($staropt$star, n, lems, l) {
  var debug = $staropt$star ? $staropt$star[0] : /* Off */2;
  return gen_auto(/* Some */[debug], n, lems, l);
}

exports.compute_secvars = compute_secvars;
exports.default_search_depth = default_search_depth;
exports.auto_flags_of_state = auto_flags_of_state;
exports.connect_hint_clenv = connect_hint_clenv;
exports.unify_resolve = unify_resolve;
exports.conclPattern = conclPattern;
exports.auto = auto;
exports.new_auto = new_auto;
exports.default_auto = default_auto;
exports.full_auto = full_auto;
exports.new_full_auto = new_full_auto;
exports.default_full_auto = default_full_auto;
exports.gen_auto = gen_auto;
exports.h_auto = h_auto;
exports.trivial = trivial;
exports.gen_trivial = gen_trivial;
exports.full_trivial = full_trivial;
exports.h_trivial = h_trivial;
/* auto_unif_flags Not a pure module */
