// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Typeops$ReactTemplate = require("./typeops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");

var name_table = Summary$ReactTemplate.ref(/* None */0, "rename-arguments", Globnames$ReactTemplate.Refmap[/* empty */0]);

function load_rename_args(_, param) {
  var match = param[1][1];
  name_table[0] = Curry._3(Globnames$ReactTemplate.Refmap[/* add */3], match[0], match[1], name_table[0]);
  return /* () */0;
}

function cache_rename_args(o) {
  return load_rename_args(1, o);
}

function classify_rename_args(o) {
  if (o[0]) {
    return /* Substitute */Block.__(0, [o]);
  } else {
    return /* Dispose */0;
  }
}

function subst_rename_args(param) {
  var orig = param[1][1];
  var r = orig[0];
  var r$prime = Globnames$ReactTemplate.subst_global(param[0], r)[0];
  return /* tuple */[
          /* ReqLocal */0,
          r === r$prime ? orig : /* tuple */[
              r$prime,
              orig[1]
            ]
        ];
}

function discharge_rename_args(param) {
  var req = param[1];
  var match = req[0];
  if (match) {
    var names = match[1];
    var c = match[0];
    try {
      var vars = Lib$ReactTemplate.variable_section_segment_of_reference(c);
      var c$prime = Globnames$ReactTemplate.pop_global_reference(c);
      var partial_arg = Names$ReactTemplate.Name[/* mk_name */0];
      var partial_arg$1 = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
      var partial_arg$2 = function (param) {
        return Util$ReactTemplate.$percent$great((function (prim) {
                      return prim[0];
                    }), partial_arg$1, param);
      };
      var var_names = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return Util$ReactTemplate.$percent$great(partial_arg$2, partial_arg, param);
            }), vars);
      var names$prime = Util$ReactTemplate.$at(var_names, names);
      return /* Some */[/* tuple */[
                /* ReqGlobal */[
                  c$prime,
                  names
                ],
                /* tuple */[
                  c$prime,
                  names$prime
                ]
              ]];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* Some */[req];
      } else {
        throw exn;
      }
    }
  } else {
    return /* None */0;
  }
}

function rebuild_rename_args(x) {
  return x;
}

var init = Libobject$ReactTemplate.default_object("RENAME-ARGUMENTS");

var inRenameArgs = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_rename_args,
      /* load_function */load_rename_args,
      /* open_function */init[/* open_function */3],
      /* classify_function */classify_rename_args,
      /* subst_function */subst_rename_args,
      /* discharge_function */discharge_rename_args,
      /* rebuild_function */rebuild_rename_args
    ]);

function rename_arguments(local, r, names) {
  var req = local ? /* ReqLocal */0 : /* ReqGlobal */[
      r,
      names
    ];
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inRenameArgs, /* tuple */[
                  req,
                  /* tuple */[
                    r,
                    names
                  ]
                ]));
}

function arguments_names(r) {
  return Curry._2(Globnames$ReactTemplate.Refmap[/* find */21], r, name_table[0]);
}

function rename_prod(c, param) {
  if (param) {
    var n = param[0];
    if (n) {
      var match = Term$ReactTemplate.kind_of_type(c);
      if (match.tag === 2) {
        return Constr$ReactTemplate.mkProd(/* tuple */[
                    n,
                    match[1],
                    rename_prod(match[2], param[1])
                  ]);
      } else {
        return c;
      }
    } else {
      var match$1 = Term$ReactTemplate.kind_of_type(c);
      if (match$1.tag === 2) {
        return Constr$ReactTemplate.mkProd(/* tuple */[
                    match$1[0],
                    match$1[1],
                    rename_prod(match$1[2], param[1])
                  ]);
      } else {
        return c;
      }
    }
  } else {
    return c;
  }
}

function rename_type(ty, ref) {
  try {
    return rename_prod(ty, arguments_names(ref));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ty;
    } else {
      throw exn;
    }
  }
}

function rename_type_of_constant(env, c) {
  var ty = Typeops$ReactTemplate.type_of_constant_in(env, c);
  return rename_type(ty, /* ConstRef */Block.__(1, [c[0]]));
}

function rename_type_of_inductive(env, ind) {
  var ty = Inductiveops$ReactTemplate.type_of_inductive(env, ind);
  return rename_type(ty, /* IndRef */Block.__(2, [ind[0]]));
}

function rename_type_of_constructor(env, cstruct) {
  var ty = Inductiveops$ReactTemplate.type_of_constructor(env, cstruct);
  return rename_type(ty, /* ConstructRef */Block.__(3, [cstruct[0]]));
}

function rename_typing(env, c) {
  var j = Curry._2(Typeops$ReactTemplate.infer, env, c);
  var match = Constr$ReactTemplate.kind(c);
  switch (match.tag | 0) {
    case 10 : 
        return /* record */[
                /* uj_val */j[/* uj_val */0],
                /* uj_type */rename_type(j[/* uj_type */1], /* ConstRef */Block.__(1, [match[0][0]]))
              ];
    case 11 : 
        return /* record */[
                /* uj_val */j[/* uj_val */0],
                /* uj_type */rename_type(j[/* uj_type */1], /* IndRef */Block.__(2, [match[0][0]]))
              ];
    case 12 : 
        return /* record */[
                /* uj_val */j[/* uj_val */0],
                /* uj_type */rename_type(j[/* uj_type */1], /* ConstructRef */Block.__(3, [match[0][0]]))
              ];
    default:
      return j;
  }
}

exports.rename_arguments = rename_arguments;
exports.arguments_names = arguments_names;
exports.rename_type_of_constant = rename_type_of_constant;
exports.rename_type_of_inductive = rename_type_of_inductive;
exports.rename_type_of_constructor = rename_type_of_constructor;
exports.rename_typing = rename_typing;
/* name_table Not a pure module */
