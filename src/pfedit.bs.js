// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Logic$ReactTemplate = require("./logic.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Proof$ReactTemplate = require("./proof.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Refine$ReactTemplate = require("./refine.bs.js");
var UState$ReactTemplate = require("./uState.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Refiner$ReactTemplate = require("./refiner.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Proofview$ReactTemplate = require("./proofview.bs.js");
var Logic_monad$ReactTemplate = require("./logic_monad.bs.js");
var Safe_typing$ReactTemplate = require("./safe_typing.bs.js");
var Proof_global$ReactTemplate = require("./proof_global.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");

var use_unification_heuristics_ref = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"Solve unification constraints at every \".\"",
      /* optkey : :: */[
        "Solve",
        /* :: */[
          "Unification",
          /* :: */[
            "Constraints",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return use_unification_heuristics_ref[0];
        }),
      /* optwrite */(function (a) {
          use_unification_heuristics_ref[0] = a;
          return /* () */0;
        })
    ]);

function start_proof(id, pl, str, sigma, hyps, c, init_tac, terminator) {
  var goals_000 = /* tuple */[
    Global$ReactTemplate.env_of_context(hyps),
    c
  ];
  var goals = /* :: */[
    goals_000,
    /* [] */0
  ];
  Proof_global$ReactTemplate.start_proof(sigma, id, pl, str, goals, terminator);
  var env = Global$ReactTemplate.env(/* () */0);
  Proof_global$ReactTemplate.with_current_proof((function (_, p) {
          if (init_tac) {
            return Proof$ReactTemplate.run_tactic(env, init_tac[0], p);
          } else {
            return /* tuple */[
                    p,
                    /* tuple */[
                      /* true */1,
                      /* [] */0
                    ]
                  ];
          }
        }));
  return /* () */0;
}

function cook_this_proof(p) {
  var match = p[/* entries */1];
  if (match) {
    if (match[1]) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Pfedit.cook_proof"], Pp$ReactTemplate.str("more than one proof term."));
    } else {
      return /* tuple */[
              p[/* id */0],
              /* tuple */[
                match[0],
                p[/* universes */3],
                p[/* persistence */2]
              ]
            ];
    }
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Pfedit.cook_proof"], Pp$ReactTemplate.str("more than one proof term."));
  }
}

function cook_proof() {
  return cook_this_proof(Proof_global$ReactTemplate.close_proof(/* false */0, (function (x) {
                      return x;
                    }))[0]);
}

var NoSuchGoal = Caml_exceptions.create("Pfedit-ReactTemplate.NoSuchGoal");

CErrors$ReactTemplate.register_handler((function (param) {
        if (param === NoSuchGoal) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such goal."));
        } else {
          throw CErrors$ReactTemplate.Unhandled;
        }
      }));

function get_nth_V82_goal(i) {
  var p = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
  var match = Proof$ReactTemplate.proof(p);
  try {
    return /* record */[
            /* it */Curry._2(Util$ReactTemplate.List[/* nth */3], match[0], i - 1 | 0),
            /* sigma */match[4]
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      throw NoSuchGoal;
    } else {
      throw exn;
    }
  }
}

function get_goal_context_gen(i) {
  var match = get_nth_V82_goal(i);
  var sigma = match[/* sigma */1];
  return /* tuple */[
          sigma,
          Refiner$ReactTemplate.pf_env(/* record */[
                /* it */match[/* it */0],
                /* sigma */sigma
              ])
        ];
}

function get_goal_context(i) {
  try {
    return get_goal_context_gen(i);
  }
  catch (exn){
    if (exn === Proof_global$ReactTemplate.NoCurrentProof) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No focused proof."));
    } else if (exn === NoSuchGoal) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such goal."));
    } else {
      throw exn;
    }
  }
}

function get_current_goal_context() {
  try {
    return get_goal_context_gen(1);
  }
  catch (exn){
    if (exn === Proof_global$ReactTemplate.NoCurrentProof) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No focused proof."));
    } else if (exn === NoSuchGoal) {
      var env = Global$ReactTemplate.env(/* () */0);
      return /* tuple */[
              Evd$ReactTemplate.from_env(env),
              env
            ];
    } else {
      throw exn;
    }
  }
}

function get_current_context() {
  try {
    return get_goal_context_gen(1);
  }
  catch (exn){
    if (exn === Proof_global$ReactTemplate.NoCurrentProof) {
      var env = Global$ReactTemplate.env(/* () */0);
      return /* tuple */[
              Evd$ReactTemplate.from_env(env),
              env
            ];
    } else if (exn === NoSuchGoal) {
      var p = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
      var evd = Proof$ReactTemplate.in_proof(p, (function (x) {
              return x;
            }));
      return /* tuple */[
              evd,
              Global$ReactTemplate.env(/* () */0)
            ];
    } else {
      throw exn;
    }
  }
}

function current_proof_statement() {
  var match = Proof_global$ReactTemplate.V82[/* get_current_initial_conclusions */0](/* () */0);
  var match$1 = match[1];
  var match$2 = match$1[0];
  if (match$2) {
    if (match$2[1]) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Pfedit.current_proof_statement"], Pp$ReactTemplate.str("more than one statement."));
    } else {
      return /* tuple */[
              match[0],
              match$1[1],
              match$2[0]
            ];
    }
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["Pfedit.current_proof_statement"], Pp$ReactTemplate.str("more than one statement."));
  }
}

function solve(with_end_tac, gi, info_lvl, tac, pr) {
  try {
    var tac$1 = with_end_tac ? Curry._2(Proofview$ReactTemplate.tclTHEN, tac, with_end_tac[0]) : tac;
    var tac$2 = info_lvl ? Curry._1(Proofview$ReactTemplate.Trace[/* record_info_trace */0], tac$1) : tac$1;
    var tac$3;
    if (typeof gi === "number") {
      tac$3 = tac$2;
    } else {
      switch (gi.tag | 0) {
        case 0 : 
            var i = gi[0];
            tac$3 = Proofview$ReactTemplate.tclFOCUS(i, i, tac$2);
            break;
        case 1 : 
            tac$3 = Proofview$ReactTemplate.tclFOCUSLIST(gi[0], tac$2);
            break;
        case 2 : 
            tac$3 = Proofview$ReactTemplate.tclFOCUSID(gi[0], tac$2);
            break;
        
      }
    }
    var tac$4 = use_unification_heuristics_ref[0] ? Curry._2(Proofview$ReactTemplate.tclTHEN, tac$3, Refine$ReactTemplate.solve_constraints) : tac$3;
    var match = Proof$ReactTemplate.run_tactic(Global$ReactTemplate.env(/* () */0), tac$4, pr);
    var match$1 = match[1];
    if (info_lvl) {
      Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.hov(0, Proofview$ReactTemplate.Trace[/* pr_info */3](/* Some */[info_lvl[0]], match$1[1])));
    }
    return /* tuple */[
            match[0],
            match$1[0]
          ];
  }
  catch (exn){
    if (exn === Proof_global$ReactTemplate.NoCurrentProof) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No focused proof"));
    } else {
      throw exn;
    }
  }
}

function by(tac) {
  return Proof_global$ReactTemplate.with_current_proof((function () {
                var partial_arg = /* SelectNth */Block.__(0, [1]);
                return (function (param) {
                    return solve(/* None */0, partial_arg, /* None */0, tac, param);
                  });
              }));
}

function instantiate_nth_evar_com(n, com) {
  return Proof_global$ReactTemplate.simple_with_current_proof((function (_, p) {
                return Proof$ReactTemplate.V82[/* instantiate_evar */5](n, com, p);
              }));
}

var n = [0];

function build_constant_by_tactic(id, ctx, sign, $staropt$star, typ, tac) {
  var goal_kind = $staropt$star ? $staropt$star[0] : /* tuple */[
      /* Global */2,
      /* false */0,
      /* Proof */Block.__(1, [/* Theorem */0])
    ];
  var evd = Evd$ReactTemplate.from_ctx(ctx);
  var terminator = Proof_global$ReactTemplate.make_terminator((function () {
          return /* () */0;
        }));
  start_proof(id, /* None */0, goal_kind, evd, sign, typ, /* None */0, terminator);
  try {
    var status = by(tac);
    var match = cook_proof(/* () */0);
    var match$1 = match[1];
    var $$const = match$1[0];
    Proof_global$ReactTemplate.discard_current(/* () */0);
    var univs = UState$ReactTemplate.demote_seff_univs($$const, match$1[1]);
    return /* tuple */[
            $$const,
            status,
            univs
          ];
  }
  catch (raw_reraise){
    var reraise = Js_exn.internalToOCamlException(raw_reraise);
    var reraise$1 = CErrors$ReactTemplate.push(reraise);
    Proof_global$ReactTemplate.discard_current(/* () */0);
    return Util$ReactTemplate.iraise(reraise$1);
  }
}

function build_by_tactic($staropt$star, env, sigma, $staropt$star$1, typ, tac) {
  var side_eff = $staropt$star ? $staropt$star[0] : /* true */1;
  var poly = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var id = Names$ReactTemplate.Id[/* of_string */5]("temporary_proof" + Pervasives.string_of_int((n[0] = n[0] + 1 | 0, n[0])));
  var sign = Environ$ReactTemplate.val_of_named_context(Environ$ReactTemplate.named_context(env));
  var gk_002 = /* Proof */Block.__(1, [/* Theorem */0]);
  var gk = /* tuple */[
    /* Global */2,
    poly,
    gk_002
  ];
  var match = build_constant_by_tactic(id, sigma, sign, /* Some */[gk], typ, tac);
  var ce = match[0];
  var ce$1;
  if (side_eff) {
    ce$1 = Safe_typing$ReactTemplate.inline_private_constants_in_definition_entry(env, ce);
  } else {
    var newrecord = ce.slice();
    newrecord[/* const_entry_body */0] = Future$ReactTemplate.chain(ce[/* const_entry_body */0], (function (param) {
            return /* tuple */[
                    param[0],
                    /* () */0
                  ];
          }));
    ce$1 = newrecord;
  }
  var match$1 = Future$ReactTemplate.force(ce$1[/* const_entry_body */0]);
  var match$2 = match$1[0];
  var univs$prime = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_rigid, Evd$ReactTemplate.from_ctx(match[2]), match$2[1]);
  return /* tuple */[
          match$2[0],
          match[1],
          Evd$ReactTemplate.evar_universe_context(univs$prime)
        ];
}

function refine_by_tactic(env, sigma, ty, tac) {
  var eff = Evd$ReactTemplate.eval_side_effects(sigma);
  var sigma$1 = Evd$ReactTemplate.drop_side_effects(sigma);
  var prev_future_goals = Evd$ReactTemplate.save_future_goals(sigma$1);
  var prf = Proof$ReactTemplate.start(sigma$1, /* :: */[
        /* tuple */[
          env,
          ty
        ],
        /* [] */0
      ]);
  var match;
  try {
    match = Proof$ReactTemplate.run_tactic(env, tac, prf);
  }
  catch (raw_src){
    var src = Js_exn.internalToOCamlException(raw_src);
    if (src[0] === Logic_monad$ReactTemplate.TacticFailure) {
      var match$1 = CErrors$ReactTemplate.push(src);
      match = Util$ReactTemplate.iraise(/* tuple */[
            src[1],
            match$1[1]
          ]);
    } else {
      throw src;
    }
  }
  var prf$1 = match[0];
  var match$2 = Proof$ReactTemplate.proof(prf$1);
  var sigma$2 = match$2[4];
  if (match$2[1] !== /* [] */0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "pfedit.ml",
            186,
            2
          ]
        ];
  }
  var match$3 = Proof$ReactTemplate.initial_goals(prf$1);
  var ans;
  if (match$3) {
    if (match$3[1]) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "pfedit.ml",
              189,
              9
            ]
          ];
    } else {
      ans = match$3[0][0];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "pfedit.ml",
            189,
            9
          ]
        ];
  }
  var ans$1 = Reductionops$ReactTemplate.nf_evar(sigma$2, ans);
  var ans$2 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](ans$1);
  var neff = Evd$ReactTemplate.eval_side_effects(sigma$2);
  var sigma$3 = Evd$ReactTemplate.drop_side_effects(sigma$2);
  var sigma$4 = Evd$ReactTemplate.emit_side_effects(eff, sigma$3);
  var sigma$5 = Evd$ReactTemplate.restore_future_goals(sigma$4, prev_future_goals);
  var partial_arg = /* Some */[/* ToShelve */0];
  var sigma$6 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
          return Evd$ReactTemplate.declare_future_goal(partial_arg, param, param$1);
        }), match$2[2], sigma$5);
  var partial_arg$1 = /* Some */[/* ToGiveUp */1];
  var sigma$7 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
          return Evd$ReactTemplate.declare_future_goal(partial_arg$1, param, param$1);
        }), match$2[3], sigma$6);
  var sigma$8 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (eta) {
          return (function (param) {
              return Evd$ReactTemplate.declare_future_goal(/* None */0, eta, param);
            });
        }), match$2[0], sigma$7);
  var ans$3 = Safe_typing$ReactTemplate.inline_private_constants_in_constr(env, ans$2, neff);
  return /* tuple */[
          ans$3,
          sigma$8
        ];
}

var implicit_tactic = Summary$ReactTemplate.ref(/* None */0, "implicit-tactic", /* None */0);

function declare_implicit_tactic(tac) {
  implicit_tactic[0] = /* Some */[tac];
  return /* () */0;
}

function clear_implicit_tactic() {
  implicit_tactic[0] = /* None */0;
  return /* () */0;
}

function apply_implicit_tactic(tac) {
  return (function (env, sigma, evk) {
      var evi = Evd$ReactTemplate.find_undefined(sigma, evk);
      var match = Evd$ReactTemplate.evar_source(evk, sigma)[1];
      var exit = 0;
      if (typeof match === "number") {
        throw Pervasives.Exit;
      } else {
        switch (match.tag | 0) {
          case 0 : 
          case 3 : 
              exit = 1;
              break;
          default:
            throw Pervasives.Exit;
        }
      }
      if (exit === 1) {
        if (Curry._1(Context$ReactTemplate.Named[/* equal */5](Constr$ReactTemplate.equal, Environ$ReactTemplate.named_context_of_val(evi[/* evar_hyps */1])), Environ$ReactTemplate.named_context(env))) {
          var tac$1 = Curry._2(Proofview$ReactTemplate.tclTHEN, tac, Proofview$ReactTemplate.tclEXTEND(/* [] */0, Proofview$ReactTemplate.tclZERO(/* None */0, [
                        CErrors$ReactTemplate.UserError,
                        /* None */0,
                        Pp$ReactTemplate.str("Proof is not complete.")
                      ]), /* [] */0));
          try {
            var c = Evarutil$ReactTemplate.nf_evars_universes(sigma)(evi[/* evar_concl */0]);
            var c$1 = EConstr$ReactTemplate.of_constr(c);
            if (Evarutil$ReactTemplate.has_undefined_evars(sigma, c$1)) {
              throw Pervasives.Exit;
            }
            var match$1 = build_by_tactic(/* None */0, env, Evd$ReactTemplate.evar_universe_context(sigma), /* None */0, c$1, tac$1);
            var sigma$1 = Evd$ReactTemplate.set_universe_context(sigma, match$1[2]);
            return /* tuple */[
                    sigma$1,
                    EConstr$ReactTemplate.of_constr(match$1[0])
                  ];
          }
          catch (raw_e){
            var e = Js_exn.internalToOCamlException(raw_e);
            if (Logic$ReactTemplate.catchable_exception(e)) {
              throw Pervasives.Exit;
            } else {
              throw e;
            }
          }
        } else {
          throw Pervasives.Exit;
        }
      }
      
    });
}

function solve_by_implicit_tactic() {
  var match = implicit_tactic[0];
  if (match) {
    return /* Some */[apply_implicit_tactic(match[0])];
  } else {
    return /* None */0;
  }
}

exports.start_proof = start_proof;
exports.cook_this_proof = cook_this_proof;
exports.cook_proof = cook_proof;
exports.get_goal_context = get_goal_context;
exports.get_current_goal_context = get_current_goal_context;
exports.get_current_context = get_current_context;
exports.current_proof_statement = current_proof_statement;
exports.solve = solve;
exports.by = by;
exports.instantiate_nth_evar_com = instantiate_nth_evar_com;
exports.build_constant_by_tactic = build_constant_by_tactic;
exports.build_by_tactic = build_by_tactic;
exports.refine_by_tactic = refine_by_tactic;
exports.declare_implicit_tactic = declare_implicit_tactic;
exports.clear_implicit_tactic = clear_implicit_tactic;
exports.solve_by_implicit_tactic = solve_by_implicit_tactic;
/*  Not a pure module */
