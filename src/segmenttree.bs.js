// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function list_iteri(f, l) {
  var _i = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var i = _i;
    if (param) {
      Curry._2(f, i, param[0]);
      _param = param[1];
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function log2(x) {
  return Math.log(x) / Math.log(2);
}

function log2n(x) {
  return Math.ceil(log2(x)) | 0;
}

function left_child(i) {
  return (i << 1) + 1 | 0;
}

function right_child(i) {
  return (i << 1) + 2 | 0;
}

function value_of(i, t) {
  var match = Caml_array.caml_array_get(t, i);
  var match$1 = match[1];
  if (match$1) {
    return match$1[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function create(n, init) {
  return Caml_array.caml_make_vect((1 << (log2n(n) + 1 | 0)) - 1 | 0, init);
}

function make(segments) {
  var nsegments = List.length(segments);
  var tree = create(nsegments, /* tuple */[
        /* Universe */0,
        /* None */0
      ]);
  var leaves_offset = (1 << log2n(nsegments)) - 1 | 0;
  list_iteri((function (i, param) {
          var match = param[0];
          var k = leaves_offset + i | 0;
          var i_000 = match[0];
          var i_001 = match[1];
          var i$1 = /* Interval */[
            i_000,
            i_001
          ];
          return Caml_array.caml_array_set(tree, k, /* tuple */[
                      i$1,
                      /* Some */[i$1]
                    ]);
        }), segments);
  for(var k = leaves_offset + nsegments | 0 ,k_finish = tree.length - 1 | 0; k <= k_finish; ++k){
    Caml_array.caml_array_set(tree, k, /* tuple */[
          /* Universe */0,
          /* Some */[/* Universe */0]
        ]);
  }
  for(var k$1 = leaves_offset - 1 | 0; k$1 >= 0; --k$1){
    var match = value_of(left_child(k$1), tree);
    var match$1 = value_of(right_child(k$1), tree);
    var match$2;
    if (match) {
      var left_max = match[1];
      var left_min = match[0];
      match$2 = match$1 ? /* tuple */[
          /* Interval */[
            left_max,
            match$1[0]
          ],
          /* Interval */[
            left_min,
            match$1[1]
          ]
        ] : /* tuple */[
          /* Interval */[
            left_max,
            left_max
          ],
          /* Interval */[
            left_min,
            left_max
          ]
        ];
    } else if (match$1) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "segmenttree.ml",
              102,
              20
            ]
          ];
    } else {
      match$2 = /* tuple */[
        /* Universe */0,
        /* Universe */0
      ];
    }
    Caml_array.caml_array_set(tree, k$1, /* tuple */[
          match$2[0],
          /* Some */[match$2[1]]
        ]);
  }
  var final_tree = $$Array.mapi((function (_, param) {
          return /* tuple */[
                  param[0],
                  /* None */0
                ];
        }), tree);
  list_iteri((function (i, param) {
          var match = param[0];
          return Caml_array.caml_array_set(final_tree, leaves_offset + i | 0, /* tuple */[
                      /* Interval */[
                        match[0],
                        match[1]
                      ],
                      /* Some */[param[1]]
                    ]);
        }), segments);
  return final_tree;
}

function lookup(k, t) {
  var i = 0;
  while(Caml_array.caml_array_get(t, i)[1] === /* None */0) {
    var match = Caml_array.caml_array_get(t, i)[0];
    if (match) {
      if (k <= match[0]) {
        i = left_child(i);
      } else if (k >= match[1]) {
        i = right_child(i);
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var match$1 = Caml_array.caml_array_get(t, i)[0];
  if (match$1) {
    if (k >= match$1[0] && k <= match$1[1]) {
      var match$2 = Caml_array.caml_array_get(t, i)[1];
      if (match$2) {
        return match$2[0];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "segmenttree.ml",
                135,
                17
              ]
            ];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "segmenttree.ml",
            138,
            20
          ]
        ];
  }
}

exports.make = make;
exports.lookup = lookup;
/* No side effect */
