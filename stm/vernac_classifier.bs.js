// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var CList$ReactTemplate = require("../src/cList.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Proof_global$ReactTemplate = require("../src/proof_global.bs.js");
var Vernacentries$ReactTemplate = require("../vernac/vernacentries.bs.js");

function string_of_parallel(param) {
  if (typeof param === "number") {
    return "";
  } else {
    var match = param[1];
    return "par" + (
            match[0] ? "solve" : "" + (
                match[1] ? "abs" : ""
              )
          );
  }
}

function string_of_vernac_type(param) {
  if (typeof param === "number") {
    if (param) {
      return "Unknown";
    } else {
      return "Meta ";
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return "StartProof";
      case 1 : 
          return "Sideff";
      case 2 : 
          switch (param[0]) {
            case 0 : 
                return "Qed(keep)";
            case 1 : 
                return "Qed(admitted)";
            case 2 : 
                return "Qed(drop)";
            
          }
          break;
      case 3 : 
          var match = param[0];
          return "ProofStep " + (string_of_parallel(match[/* parallel */0]) + Option$ReactTemplate.$$default("", match[/* proof_block_detection */1]));
      case 4 : 
          return "ProofMode " + param[0];
      case 5 : 
          return "Query " + ((
                    param[0] ? " (inside script)" : ""
                  ) + (" route " + Pervasives.string_of_int(param[1])));
      
    }
  }
}

function string_of_vernac_when(param) {
  if (param !== 0) {
    return "Later";
  } else {
    return "Now";
  }
}

function string_of_vernac_classification(param) {
  return string_of_vernac_type(param[0]) + (" " + string_of_vernac_when(param[1]));
}

var classifiers = [/* [] */0];

function declare_vernac_classifier(s, f) {
  classifiers[0] = Util$ReactTemplate.$at(classifiers[0], /* :: */[
        /* tuple */[
          s,
          f
        ],
        /* [] */0
      ]);
  return /* () */0;
}

function idents_of_name(param) {
  if (param) {
    return /* :: */[
            param[0],
            /* [] */0
          ];
  } else {
    return /* [] */0;
  }
}

function classify_vernac(e) {
  var static_control_classifier = function (poly, _param) {
    while(true) {
      var param = _param;
      switch (param.tag | 0) {
        case 0 : 
            var poly$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (poly, f) {
                    if (typeof f === "number" || f.tag) {
                      return poly;
                    } else {
                      return f[0];
                    }
                  }), poly, param[0]);
            var poly$2 = poly$1;
            var e = param[1];
            var exit = 0;
            var exit$1 = 0;
            if (typeof e === "number") {
              switch (e) {
                case 0 : 
                case 1 : 
                case 2 : 
                    return /* tuple */[
                            /* VtMeta */0,
                            /* VtNow */0
                          ];
                case 5 : 
                    return /* tuple */[
                            /* VtProofStep */Block.__(3, [/* record */[
                                  /* parallel : No */17505,
                                  /* proof_block_detection : Some */["curly"]
                                ]]),
                            /* VtLater */1
                          ];
                case 3 : 
                case 4 : 
                case 6 : 
                    return /* tuple */[
                            /* VtProofStep */Block.__(3, [/* record */[
                                  /* parallel : No */17505,
                                  /* proof_block_detection : None */0
                                ]]),
                            /* VtLater */1
                          ];
                
              }
            } else {
              switch (e.tag | 0) {
                case 8 : 
                    var exit$2 = 0;
                    if (e[0][0] !== 0) {
                      exit$2 = 6;
                    } else if (e[2].tag) {
                      exit$2 = 6;
                    } else {
                      return /* tuple */[
                              /* VtStartProof */Block.__(0, [/* tuple */[
                                    Proof_global$ReactTemplate.get_default_proof_mode_name(/* () */0),
                                    /* Doesn'tGuaranteeOpacity */1,
                                    idents_of_name(e[1][0][/* v */0])
                                  ]]),
                              /* VtLater */1
                            ];
                    }
                    if (exit$2 === 6) {
                      var i = e[1][0][/* v */0];
                      if (e[2].tag) {
                        return /* tuple */[
                                /* VtSideff */Block.__(1, [idents_of_name(i)]),
                                /* VtLater */1
                              ];
                      } else {
                        var guarantee = poly$2 ? /* Doesn'tGuaranteeOpacity */1 : /* GuaranteesOpacity */0;
                        return /* tuple */[
                                /* VtStartProof */Block.__(0, [/* tuple */[
                                      Proof_global$ReactTemplate.get_default_proof_mode_name(/* () */0),
                                      guarantee,
                                      idents_of_name(i)
                                    ]]),
                                /* VtLater */1
                              ];
                      }
                    }
                    break;
                case 9 : 
                    var ids = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                            return param[0][0][/* v */0];
                          }), e[1]);
                    var guarantee$1 = poly$2 ? /* Doesn'tGuaranteeOpacity */1 : /* GuaranteesOpacity */0;
                    return /* tuple */[
                            /* VtStartProof */Block.__(0, [/* tuple */[
                                  Proof_global$ReactTemplate.get_default_proof_mode_name(/* () */0),
                                  guarantee$1,
                                  ids
                                ]]),
                            /* VtLater */1
                          ];
                case 10 : 
                    if (e[0]) {
                      return /* tuple */[
                              /* VtQed */Block.__(2, [/* VtKeep */0]),
                              /* VtLater */1
                            ];
                    } else {
                      return /* tuple */[
                              /* VtQed */Block.__(2, [/* VtKeepAsAxiom */1]),
                              /* VtLater */1
                            ];
                    }
                case 11 : 
                    return /* tuple */[
                            /* VtQed */Block.__(2, [/* VtKeep */0]),
                            /* VtLater */1
                          ];
                case 12 : 
                    var ids$1 = Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                              return param[0][/* v */0];
                                            }), param[1][0]);
                              }), e[2]));
                    return /* tuple */[
                            /* VtSideff */Block.__(1, [ids$1]),
                            /* VtLater */1
                          ];
                case 13 : 
                    var ids$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                            var match = param[0];
                            var cl = match[4];
                            var tmp;
                            if (cl.tag) {
                              var oid = cl[0];
                              tmp = Util$ReactTemplate.$at(oid ? /* :: */[
                                      oid[0][/* v */0],
                                      /* [] */0
                                    ] : /* [] */0, CList$ReactTemplate.map_filter((function (param) {
                                          var match = param[0][0][1];
                                          if (match.tag) {
                                            return /* None */0;
                                          } else {
                                            var match$1 = match[0][/* v */0];
                                            if (match$1) {
                                              return /* Some */[match$1[0]];
                                            } else {
                                              return /* None */0;
                                            }
                                          }
                                        }), cl[1]));
                            } else {
                              tmp = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      return param[1][0][/* v */0];
                                    }), cl[0]);
                            }
                            return /* :: */[
                                    match[0][1][0][/* v */0],
                                    tmp
                                  ];
                          }), e[3]);
                    return /* tuple */[
                            /* VtSideff */Block.__(1, [Curry._1(Util$ReactTemplate.List[/* flatten */8], ids$2)]),
                            /* VtLater */1
                          ];
                case 14 : 
                    var guarantee$2 = e[0] === /* DoDischarge */0 || poly$2 ? /* Doesn'tGuaranteeOpacity */1 : /* GuaranteesOpacity */0;
                    var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                            var match = param$1[0];
                            return /* tuple */[
                                    /* :: */[
                                      match[0][0][/* v */0],
                                      param[0]
                                    ],
                                    param[1] || +(match[4] === /* None */0)
                                  ];
                          }), /* tuple */[
                          /* [] */0,
                          /* false */0
                        ], e[1]);
                    var ids$3 = match[0];
                    if (match[1]) {
                      return /* tuple */[
                              /* VtStartProof */Block.__(0, [/* tuple */[
                                    Proof_global$ReactTemplate.get_default_proof_mode_name(/* () */0),
                                    guarantee$2,
                                    ids$3
                                  ]]),
                              /* VtLater */1
                            ];
                    } else {
                      return /* tuple */[
                              /* VtSideff */Block.__(1, [ids$3]),
                              /* VtLater */1
                            ];
                    }
                case 15 : 
                    var guarantee$3 = e[0] === /* DoDischarge */0 || poly$2 ? /* Doesn'tGuaranteeOpacity */1 : /* GuaranteesOpacity */0;
                    var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                            var match = param$1[0];
                            return /* tuple */[
                                    /* :: */[
                                      match[0][0][/* v */0],
                                      param[0]
                                    ],
                                    param[1] || +(match[3] === /* None */0)
                                  ];
                          }), /* tuple */[
                          /* [] */0,
                          /* false */0
                        ], e[1]);
                    var ids$4 = match$1[0];
                    if (match$1[1]) {
                      return /* tuple */[
                              /* VtStartProof */Block.__(0, [/* tuple */[
                                    Proof_global$ReactTemplate.get_default_proof_mode_name(/* () */0),
                                    guarantee$3,
                                    ids$4
                                  ]]),
                              /* VtLater */1
                            ];
                    } else {
                      return /* tuple */[
                              /* VtSideff */Block.__(1, [ids$4]),
                              /* VtLater */1
                            ];
                    }
                case 16 : 
                    var ids$5 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                            return param[/* v */0];
                          }), CList$ReactTemplate.map_filter((function (param) {
                                return param[0];
                              }), e[0]));
                    return /* tuple */[
                            /* VtSideff */Block.__(1, [ids$5]),
                            /* VtLater */1
                          ];
                case 17 : 
                case 20 : 
                    exit$1 = 3;
                    break;
                case 28 : 
                    return /* tuple */[
                            /* VtUnknown */1,
                            /* VtNow */0
                          ];
                case 32 : 
                case 33 : 
                    exit$1 = 4;
                    break;
                case 34 : 
                    return /* tuple */[
                            /* VtSideff */Block.__(1, [/* :: */[
                                  e[0][/* v */0],
                                  /* [] */0
                                ]]),
                            e[1] ? /* VtNow */0 : /* VtLater */1
                          ];
                case 58 : 
                case 59 : 
                    exit$1 = 5;
                    break;
                case 72 : 
                    return /* tuple */[
                            /* VtQed */Block.__(2, [/* VtDrop */2]),
                            /* VtLater */1
                          ];
                case 44 : 
                case 45 : 
                case 46 : 
                case 73 : 
                case 74 : 
                case 75 : 
                    return /* tuple */[
                            /* VtMeta */0,
                            /* VtNow */0
                          ];
                case 77 : 
                    return /* tuple */[
                            /* VtProofStep */Block.__(3, [/* record */[
                                  /* parallel : No */17505,
                                  /* proof_block_detection : Some */["bullet"]
                                ]]),
                            /* VtLater */1
                          ];
                case 64 : 
                case 67 : 
                case 68 : 
                case 69 : 
                case 79 : 
                    exit = 1;
                    break;
                case 36 : 
                case 76 : 
                case 78 : 
                case 80 : 
                    return /* tuple */[
                            /* VtProofStep */Block.__(3, [/* record */[
                                  /* parallel : No */17505,
                                  /* proof_block_detection : None */0
                                ]]),
                            /* VtLater */1
                          ];
                case 0 : 
                case 1 : 
                case 2 : 
                case 3 : 
                case 4 : 
                case 5 : 
                case 6 : 
                case 7 : 
                case 21 : 
                case 22 : 
                case 23 : 
                case 29 : 
                case 35 : 
                case 40 : 
                case 42 : 
                case 43 : 
                case 50 : 
                case 81 : 
                case 82 : 
                    return /* tuple */[
                            /* VtSideff */Block.__(1, [/* [] */0]),
                            /* VtNow */0
                          ];
                case 83 : 
                    var s = e[0];
                    try {
                      return Curry._4(Util$ReactTemplate.List[/* assoc */30], s, classifiers[0], e[1], /* () */0);
                    }
                    catch (exn){
                      if (exn === Caml_builtin_exceptions.not_found) {
                        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No classifier for"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(s[0])), Pp$ReactTemplate.str(".")));
                      } else {
                        throw exn;
                      }
                    }
                    break;
                default:
                  exit = 2;
              }
            }
            switch (exit$1) {
              case 3 : 
                  return /* tuple */[
                          /* VtSideff */Block.__(1, [/* :: */[
                                e[0][/* v */0],
                                /* [] */0
                              ]]),
                          /* VtLater */1
                        ];
              case 4 : 
                  return /* tuple */[
                          /* VtSideff */Block.__(1, [/* :: */[
                                e[1][/* v */0],
                                /* [] */0
                              ]]),
                          e[2] === /* [] */0 && e[0] === /* None */0 ? /* VtLater */1 : /* VtNow */0
                        ];
              case 5 : 
                  if (CList$ReactTemplate.equal((function (prim, prim$1) {
                            return +(prim === prim$1);
                          }), e[1], Vernacentries$ReactTemplate.universe_polymorphism_option_name)) {
                    return /* tuple */[
                            /* VtSideff */Block.__(1, [/* [] */0]),
                            /* VtNow */0
                          ];
                  } else {
                    exit = 2;
                  }
                  break;
              
            }
            switch (exit) {
              case 1 : 
                  return /* tuple */[
                          /* VtQuery */Block.__(5, [
                              /* true */1,
                              Feedback$ReactTemplate.default_route
                            ]),
                          /* VtLater */1
                        ];
              case 2 : 
                  if (typeof e === "number") {
                    return /* tuple */[
                            /* VtSideff */Block.__(1, [/* [] */0]),
                            /* VtLater */1
                          ];
                  } else {
                    switch (e.tag | 0) {
                      case 58 : 
                          var match$2 = e[1];
                          if (match$2) {
                            if (match$2[0] === "Default") {
                              var match$3 = match$2[1];
                              if (match$3) {
                                if (match$3[0] === "Proof") {
                                  var match$4 = match$3[1];
                                  if (match$4) {
                                    if (match$4[0] === "Using") {
                                      if (match$4[1]) {
                                        return /* tuple */[
                                                /* VtSideff */Block.__(1, [/* [] */0]),
                                                /* VtLater */1
                                              ];
                                      } else {
                                        return /* tuple */[
                                                /* VtSideff */Block.__(1, [/* [] */0]),
                                                /* VtNow */0
                                              ];
                                      }
                                    } else {
                                      return /* tuple */[
                                              /* VtSideff */Block.__(1, [/* [] */0]),
                                              /* VtLater */1
                                            ];
                                    }
                                  } else {
                                    return /* tuple */[
                                            /* VtSideff */Block.__(1, [/* [] */0]),
                                            /* VtLater */1
                                          ];
                                  }
                                } else {
                                  return /* tuple */[
                                          /* VtSideff */Block.__(1, [/* [] */0]),
                                          /* VtLater */1
                                        ];
                                }
                              } else {
                                return /* tuple */[
                                        /* VtSideff */Block.__(1, [/* [] */0]),
                                        /* VtLater */1
                                      ];
                              }
                            } else {
                              return /* tuple */[
                                      /* VtSideff */Block.__(1, [/* [] */0]),
                                      /* VtLater */1
                                    ];
                            }
                          } else {
                            return /* tuple */[
                                    /* VtSideff */Block.__(1, [/* [] */0]),
                                    /* VtLater */1
                                  ];
                          }
                          break;
                      case 59 : 
                          var match$5 = e[1];
                          if (match$5) {
                            if (match$5[0] === "Default") {
                              var match$6 = match$5[1];
                              if (match$6) {
                                if (match$6[0] === "Proof") {
                                  var match$7 = match$6[1];
                                  if (match$7) {
                                    if (match$7[0] === "Using") {
                                      if (match$7[1]) {
                                        return /* tuple */[
                                                /* VtSideff */Block.__(1, [/* [] */0]),
                                                /* VtLater */1
                                              ];
                                      } else {
                                        return /* tuple */[
                                                /* VtSideff */Block.__(1, [/* [] */0]),
                                                /* VtNow */0
                                              ];
                                      }
                                    } else {
                                      return /* tuple */[
                                              /* VtSideff */Block.__(1, [/* [] */0]),
                                              /* VtLater */1
                                            ];
                                    }
                                  } else {
                                    return /* tuple */[
                                            /* VtSideff */Block.__(1, [/* [] */0]),
                                            /* VtLater */1
                                          ];
                                  }
                                } else {
                                  return /* tuple */[
                                          /* VtSideff */Block.__(1, [/* [] */0]),
                                          /* VtLater */1
                                        ];
                                }
                              } else {
                                return /* tuple */[
                                        /* VtSideff */Block.__(1, [/* [] */0]),
                                        /* VtLater */1
                                      ];
                              }
                            } else {
                              return /* tuple */[
                                      /* VtSideff */Block.__(1, [/* [] */0]),
                                      /* VtLater */1
                                    ];
                            }
                          } else {
                            return /* tuple */[
                                    /* VtSideff */Block.__(1, [/* [] */0]),
                                    /* VtLater */1
                                  ];
                          }
                          break;
                      default:
                        return /* tuple */[
                                /* VtSideff */Block.__(1, [/* [] */0]),
                                /* VtLater */1
                              ];
                    }
                  }
                  break;
              
            }
        case 1 : 
        case 2 : 
            _param = param[1][/* v */0];
            continue ;
            case 3 : 
            _param = param[1];
            continue ;
            case 4 : 
            var x = static_control_classifier(poly, param[0]);
            var tmp = x[0];
            if (typeof tmp === "number") {
              if (tmp === 1) {
                return /* tuple */[
                        /* VtUnknown */1,
                        /* VtNow */0
                      ];
              } else {
                return x;
              }
            } else {
              switch (tmp.tag | 0) {
                case 0 : 
                    return /* tuple */[
                            /* VtUnknown */1,
                            /* VtNow */0
                          ];
                case 2 : 
                    return /* tuple */[
                            /* VtProofStep */Block.__(3, [/* record */[
                                  /* parallel : No */17505,
                                  /* proof_block_detection : None */0
                                ]]),
                            /* VtNow */0
                          ];
                default:
                  return x;
              }
            }
            break;
        
      }
    };
  };
  return static_control_classifier(Flags$ReactTemplate.is_universe_polymorphism(/* () */0), e);
}

var classify_as_query_000 = /* VtQuery */Block.__(5, [
    /* true */1,
    Feedback$ReactTemplate.default_route
  ]);

var classify_as_query = /* tuple */[
  classify_as_query_000,
  /* VtLater */1
];

var classify_as_sideeff = /* tuple */[
  /* VtSideff */Block.__(1, [/* [] */0]),
  /* VtLater */1
];

var classify_as_proofstep = /* tuple */[
  /* VtProofStep */Block.__(3, [/* record */[
        /* parallel : No */17505,
        /* proof_block_detection : None */0
      ]]),
  /* VtLater */1
];

exports.string_of_vernac_classification = string_of_vernac_classification;
exports.classify_vernac = classify_vernac;
exports.declare_vernac_classifier = declare_vernac_classifier;
exports.classify_as_query = classify_as_query;
exports.classify_as_sideeff = classify_as_sideeff;
exports.classify_as_proofstep = classify_as_proofstep;
/* Pp-ReactTemplate Not a pure module */
