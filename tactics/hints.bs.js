// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var Goal$ReactTemplate = require("../src/goal.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Clenv$ReactTemplate = require("../proofs/clenv.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Logic$ReactTemplate = require("../src/logic.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Proof$ReactTemplate = require("../src/proof.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var Pfedit$ReactTemplate = require("../src/pfedit.bs.js");
var Tacred$ReactTemplate = require("../src/tacred.bs.js");
var Typing$ReactTemplate = require("../src/typing.bs.js");
var Btermdn$ReactTemplate = require("./btermdn.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Pputils$ReactTemplate = require("../src/pputils.bs.js");
var Printer$ReactTemplate = require("../src/printer.bs.js");
var Summary$ReactTemplate = require("../src/summary.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Feedback$ReactTemplate = require("../src/feedback.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Retyping$ReactTemplate = require("../src/retyping.bs.js");
var CWarnings$ReactTemplate = require("../src/cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Genintern$ReactTemplate = require("../src/genintern.bs.js");
var Globnames$ReactTemplate = require("../src/globnames.bs.js");
var Libobject$ReactTemplate = require("../src/libobject.bs.js");
var Mod_subst$ReactTemplate = require("../src/mod_subst.bs.js");
var Pretyping$ReactTemplate = require("../src/pretyping.bs.js");
var Proofview$ReactTemplate = require("../src/proofview.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var Declareops$ReactTemplate = require("../src/declareops.bs.js");
var Patternops$ReactTemplate = require("../src/patternops.bs.js");
var Smartlocate$ReactTemplate = require("../shims/smartlocate.bs.js");
var Typeclasses$ReactTemplate = require("../src/typeclasses.bs.js");
var Constrintern$ReactTemplate = require("../src/constrintern.bs.js");
var Inductiveops$ReactTemplate = require("../src/inductiveops.bs.js");
var Proof_global$ReactTemplate = require("../src/proof_global.bs.js");

var Bound = Caml_exceptions.create("Hints-ReactTemplate.Bound");

function head_constr_bound(sigma, t) {
  var t$1 = Termops$ReactTemplate.strip_outer_cast(sigma, t);
  var match = EConstr$ReactTemplate.decompose_prod_assum(sigma, t$1);
  var match$1 = EConstr$ReactTemplate.decompose_app(sigma, match[1]);
  var match$2 = EConstr$ReactTemplate.kind(sigma, match$1[0]);
  switch (match$2.tag | 0) {
    case 1 : 
        return /* VarRef */Block.__(0, [match$2[0]]);
    case 10 : 
        return /* ConstRef */Block.__(1, [match$2[0][0]]);
    case 11 : 
        return /* IndRef */Block.__(2, [match$2[0][0]]);
    case 12 : 
        return /* ConstructRef */Block.__(3, [match$2[0][0]]);
    case 16 : 
        return /* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](match$2[0])]);
    default:
      throw Bound;
  }
}

function head_constr(sigma, c) {
  try {
    return head_constr_bound(sigma, c);
  }
  catch (exn){
    if (exn === Bound) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Head identifier must be a constant, section variable, (co)inductive type, (co)inductive type constructor, or projection."));
    } else {
      throw exn;
    }
  }
}

function decompose_app_bound(sigma, t) {
  var t$1 = Termops$ReactTemplate.strip_outer_cast(sigma, t);
  var match = EConstr$ReactTemplate.decompose_prod_assum(sigma, t$1);
  var match$1 = Termops$ReactTemplate.decompose_app_vect(sigma, match[1]);
  var args = match$1[1];
  var match$2 = EConstr$ReactTemplate.kind(sigma, match$1[0]);
  switch (match$2.tag | 0) {
    case 1 : 
        return /* tuple */[
                /* VarRef */Block.__(0, [match$2[0]]),
                args
              ];
    case 10 : 
        return /* tuple */[
                /* ConstRef */Block.__(1, [match$2[0][0]]),
                args
              ];
    case 11 : 
        return /* tuple */[
                /* IndRef */Block.__(2, [match$2[0][0]]),
                args
              ];
    case 12 : 
        return /* tuple */[
                /* ConstructRef */Block.__(3, [match$2[0][0]]),
                args
              ];
    case 16 : 
        return /* tuple */[
                /* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](match$2[0])]),
                Util$ReactTemplate.$$Array[/* cons */35](match$2[1], args)
              ];
    default:
      throw Bound;
  }
}

function secvars_of_hyps(hyps) {
  var secctx = Global$ReactTemplate.named_context(/* () */0);
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, decl) {
          var pred = param[0];
          try {
            Context$ReactTemplate.Named[/* lookup */4](Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), hyps);
            return /* tuple */[
                    Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* add */6], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), pred),
                    param[1]
                  ];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* tuple */[
                      pred,
                      /* false */0
                    ];
            } else {
              throw exn;
            }
          }
        }), /* tuple */[
        Names$ReactTemplate.Id[/* Pred */11][/* empty */0],
        /* true */1
      ], secctx);
  if (match[1]) {
    return Names$ReactTemplate.Id[/* Pred */11][/* full */1];
  } else {
    return match[0];
  }
}

var empty_hint_info = /* record */[
  /* hint_priority : None */0,
  /* hint_pattern : None */0
];

var warn_hint = [/* LAX */3793987];

function read_warn_hint() {
  var match = warn_hint[0];
  if (match !== 3793987) {
    if (match >= 968043078) {
      return "Warn";
    } else {
      return "Strict";
    }
  } else {
    return "Lax";
  }
}

function write_warn_hint(param) {
  switch (param) {
    case "Lax" : 
        warn_hint[0] = /* LAX */3793987;
        return /* () */0;
    case "Strict" : 
        warn_hint[0] = /* STRICT */-1011692727;
        return /* () */0;
    case "Warn" : 
        warn_hint[0] = /* WARN */968043078;
        return /* () */0;
    default:
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Only the following flags are accepted: Lax, Warn, Strict."));
  }
}

Goptions$ReactTemplate.declare_string_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"behavior of non-imported hints",
      /* optkey : :: */[
        "Loose",
        /* :: */[
          "Hint",
          /* :: */[
            "Behavior",
            /* [] */0
          ]
        ]
      ],
      /* optread */read_warn_hint,
      /* optwrite */write_warn_hint
    ]);

var id = Summary$ReactTemplate.ref(/* None */0, "HINT-COUNTER", 0);

function fresh_key() {
  id[0] = id[0] + 1 | 0;
  var cur = id[0];
  var lbl = Names$ReactTemplate.Id[/* of_string */5]("_" + Pervasives.string_of_int(cur));
  var kn = Lib$ReactTemplate.make_kn(lbl);
  var match = Names$ReactTemplate.KerName[/* repr */2](kn);
  var dir = match[1];
  var mp = match[0];
  var lbl$1 = Names$ReactTemplate.Id[/* of_string_soft */6](Curry._3(Printf.sprintf(/* Format */[
                /* String */Block.__(2, [
                    /* No_padding */0,
                    /* Char_literal */Block.__(12, [
                        /* "#" */35,
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Char_literal */Block.__(12, [
                                /* "#" */35,
                                /* Int */Block.__(4, [
                                    /* Int_i */3,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ])
                  ]),
                "%s#%s#%i"
              ]), Names$ReactTemplate.ModPath[/* to_string */4](mp), Names$ReactTemplate.DirPath[/* to_string */7](dir), cur));
  return Names$ReactTemplate.KerName[/* make */0](mp, dir, Names$ReactTemplate.Label[/* of_id */5](lbl$1));
}

function pri_order_int(param, param$1) {
  var d = param[1][/* pri */0] - param$1[1][/* pri */0] | 0;
  if (d) {
    return d;
  } else {
    return param$1[0] - param[0] | 0;
  }
}

function pri_order(t1, t2) {
  return +(pri_order_int(t1, t2) <= 0);
}

var Bounded_net = Btermdn$ReactTemplate.Make(/* module */[/* compare */pri_order_int]);

var empty_se_002 = /* sentry_bnet */Bounded_net[/* empty */0];

var empty_se = /* record */[
  /* sentry_nopat : [] */0,
  /* sentry_pat : [] */0,
  empty_se_002,
  /* sentry_mode : [] */0
];

function eq_pri_auto_tactic(param, param$1) {
  return Names$ReactTemplate.KerName[/* equal */9](param[1][/* code */6][/* uid */1], param$1[1][/* code */6][/* uid */1]);
}

function add_tac(pat, t, st, se) {
  if (pat) {
    if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
              return eq_pri_auto_tactic(t, param);
            }), se[/* sentry_pat */1])) {
      return se;
    } else {
      return /* record */[
              /* sentry_nopat */se[/* sentry_nopat */0],
              /* sentry_pat */Curry._3(Util$ReactTemplate.List[/* insert */91], pri_order, t, se[/* sentry_pat */1]),
              /* sentry_bnet */Curry._3(Bounded_net[/* add */1], st, se[/* sentry_bnet */2], /* tuple */[
                    pat[0],
                    t
                  ]),
              /* sentry_mode */se[/* sentry_mode */3]
            ];
    }
  } else if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
            return eq_pri_auto_tactic(t, param);
          }), se[/* sentry_nopat */0])) {
    return se;
  } else {
    return /* record */[
            /* sentry_nopat */Curry._3(Util$ReactTemplate.List[/* insert */91], pri_order, t, se[/* sentry_nopat */0]),
            /* sentry_pat */se[/* sentry_pat */1],
            /* sentry_bnet */se[/* sentry_bnet */2],
            /* sentry_mode */se[/* sentry_mode */3]
          ];
  }
}

function rebuild_dn(st, se) {
  var dn$prime = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (dn, param) {
          var t = param[1];
          return Curry._3(Bounded_net[/* add */1], /* Some */[st], dn, /* tuple */[
                      Option$ReactTemplate.get(t[/* pat */2]),
                      /* tuple */[
                        param[0],
                        t
                      ]
                    ]);
        }), Bounded_net[/* empty */0], se[/* sentry_pat */1]);
  return /* record */[
          /* sentry_nopat */se[/* sentry_nopat */0],
          /* sentry_pat */se[/* sentry_pat */1],
          /* sentry_bnet */dn$prime,
          /* sentry_mode */se[/* sentry_mode */3]
        ];
}

function lookup_tacs(sigma, concl, st, se) {
  var l$prime = Curry._4(Bounded_net[/* lookup */3], sigma, st, se[/* sentry_bnet */2], concl);
  var sl$prime = Curry._2(Util$ReactTemplate.List[/* stable_sort */39], pri_order_int, l$prime);
  return Curry._3(Util$ReactTemplate.List[/* merge */42], pri_order_int, se[/* sentry_nopat */0], sl$prime);
}

var Constr_map = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], [Globnames$ReactTemplate.RefOrdered[0]]);

function is_transparent_gr(param, param$1) {
  switch (param$1.tag | 0) {
    case 0 : 
        return Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], param$1[0], param[0]);
    case 1 : 
        return Curry._2(Names$ReactTemplate.Cpred[/* mem */4], param$1[0], param[1]);
    case 2 : 
    case 3 : 
        return /* false */0;
    
  }
}

function strip_params(env, sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 9) {
    var args = match[1];
    var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
    if (match$1.tag === 10) {
      var p = match$1[0][0];
      var cb = Environ$ReactTemplate.lookup_constant(p, env);
      var match$2 = cb[/* const_proj */5];
      if (match$2) {
        var n = match$2[0][/* proj_npars */1];
        if (args.length > n) {
          return EConstr$ReactTemplate.mkApp(/* tuple */[
                      EConstr$ReactTemplate.mkProj(/* tuple */[
                            Names$ReactTemplate.Projection[/* make */0](p, /* false */0),
                            Caml_array.caml_array_get(args, n)
                          ]),
                      Util$ReactTemplate.$$Array[/* sub */5](args, n + 1 | 0, args.length - (n + 1 | 0) | 0)
                    ]);
        } else {
          return c;
        }
      } else {
        return c;
      }
    } else {
      return c;
    }
  } else {
    return c;
  }
}

function instantiate_hint(env, sigma, p) {
  var mk_clenv = function (param) {
    var sigma$1 = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible, sigma, param[2]);
    var cl = Clenv$ReactTemplate.mk_clenv_from_env(env, sigma$1, /* None */0, /* tuple */[
          param[0],
          param[1]
        ]);
    var init = cl[/* templval */2];
    return /* record */[
            /* env */Environ$ReactTemplate.empty_env,
            /* evd */cl[/* evd */1],
            /* templval : record */[
              /* rebus */strip_params(env, sigma$1, cl[/* templval */2][/* rebus */0]),
              /* freemetas */init[/* freemetas */1]
            ],
            /* templtyp */cl[/* templtyp */3]
          ];
  };
  var match = p[/* code */6][/* obj */0];
  var code;
  switch (match.tag | 0) {
    case 0 : 
        var c = match[0];
        code = /* Res_pf */Block.__(0, [/* tuple */[
              c,
              mk_clenv(c)
            ]]);
        break;
    case 1 : 
        var c$1 = match[0];
        code = /* ERes_pf */Block.__(1, [/* tuple */[
              c$1,
              mk_clenv(c$1)
            ]]);
        break;
    case 2 : 
        var c$2 = match[0];
        code = /* Give_exact */Block.__(2, [/* tuple */[
              c$2,
              mk_clenv(c$2)
            ]]);
        break;
    case 3 : 
        var c$3 = match[0];
        code = /* Res_pf_THEN_trivial_fail */Block.__(3, [/* tuple */[
              c$3,
              mk_clenv(c$3)
            ]]);
        break;
    case 4 : 
        code = /* Unfold_nth */Block.__(4, [match[0]]);
        break;
    case 5 : 
        code = /* Extern */Block.__(5, [match[0]]);
        break;
    
  }
  var newrecord = p.slice();
  var init = p[/* code */6];
  newrecord[/* code */6] = /* record */[
    /* obj */code,
    /* uid */init[/* uid */1]
  ];
  return newrecord;
}

function hints_path_atom_eq(h1, h2) {
  if (h1) {
    if (h2) {
      return Curry._3(Util$ReactTemplate.List[/* equal */44], Globnames$ReactTemplate.eq_gr, h1[0], h2[0]);
    } else {
      return /* false */0;
    }
  } else if (h2) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function hints_path_eq(_h1, _h2) {
  while(true) {
    var h2 = _h2;
    var h1 = _h1;
    if (typeof h1 === "number") {
      if (h1) {
        if (typeof h2 === "number" && h2 !== 0) {
          return /* true */1;
        } else {
          return /* false */0;
        }
      } else if (typeof h2 === "number" && h2 === 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else {
      switch (h1.tag | 0) {
        case 0 : 
            if (typeof h2 === "number" || h2.tag) {
              return /* false */0;
            } else {
              return hints_path_atom_eq(h1[0], h2[0]);
            }
            break;
        case 1 : 
            if (typeof h2 === "number") {
              return /* false */0;
            } else if (h2.tag === 1) {
              _h2 = h2[0];
              _h1 = h1[0];
              continue ;
              
            } else {
              return /* false */0;
            }
            break;
        case 2 : 
            if (typeof h2 === "number") {
              return /* false */0;
            } else if (h2.tag === 2) {
              if (hints_path_eq(h1[0], h2[0])) {
                _h2 = h2[1];
                _h1 = h1[1];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        case 3 : 
            if (typeof h2 === "number") {
              return /* false */0;
            } else if (h2.tag === 3) {
              if (hints_path_eq(h1[0], h2[0])) {
                _h2 = h2[1];
                _h1 = h1[1];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
            break;
        
      }
    }
  };
}

function path_matches(hp, hints) {
  var aux = function (_hp, hints, _k) {
    while(true) {
      var k = _k;
      var hp = _hp;
      if (typeof hp === "number") {
        if (hp) {
          return Curry._1(k, hints);
        } else {
          return /* false */0;
        }
      } else {
        switch (hp.tag | 0) {
          case 0 : 
              var p = hp[0];
              if (hints && !(p && !hints_path_atom_eq(p, hints[0]))) {
                return Curry._1(k, hints[1]);
              } else {
                return /* false */0;
              }
          case 1 : 
              if (Curry._1(k, hints)) {
                return /* true */1;
              } else {
                _k = (function(hp,k){
                return function (hints$prime) {
                  return aux(hp, hints$prime, k);
                }
                }(hp,k));
                _hp = hp[0];
                continue ;
                
              }
              break;
          case 2 : 
              var hp$prime = hp[1];
              _k = (function(k,hp$prime){
              return function (hints$prime) {
                return aux(hp$prime, hints$prime, k);
              }
              }(k,hp$prime));
              _hp = hp[0];
              continue ;
              case 3 : 
              if (aux(hp[0], hints, k)) {
                return /* true */1;
              } else {
                _hp = hp[1];
                continue ;
                
              }
              break;
          
        }
      }
    };
  };
  return aux(hp, hints, (function () {
                return /* true */1;
              }));
}

function matches_epsilon(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      if (param) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else {
      switch (param.tag | 0) {
        case 0 : 
            return /* false */0;
        case 1 : 
            return /* true */1;
        case 2 : 
            if (matches_epsilon(param[0])) {
              _param = param[1];
              continue ;
              
            } else {
              return /* false */0;
            }
            break;
        case 3 : 
            if (matches_epsilon(param[0])) {
              return /* true */1;
            } else {
              _param = param[1];
              continue ;
              
            }
            break;
        
      }
    }
  };
}

function is_empty(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      if (param) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    } else {
      switch (param.tag | 0) {
        case 2 : 
            if (is_empty(param[0])) {
              return /* true */1;
            } else {
              _param = param[1];
              continue ;
              
            }
            break;
        case 3 : 
            if (matches_epsilon(param[0])) {
              return matches_epsilon(param[1]);
            } else {
              return /* false */0;
            }
        default:
          return /* false */0;
      }
    }
  };
}

function path_seq(p, p$prime) {
  var exit = 0;
  if (typeof p === "number") {
    if (p !== 0) {
      return p$prime;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (typeof p$prime === "number") {
      if (p$prime !== 0) {
        return p;
      } else {
        return /* PathSeq */Block.__(2, [
                  p,
                  p$prime
                ]);
      }
    } else {
      return /* PathSeq */Block.__(2, [
                p,
                p$prime
              ]);
    }
  }
  
}

function path_derivate(hp, hint) {
  if (typeof hp === "number") {
    return /* PathEmpty */0;
  } else {
    switch (hp.tag | 0) {
      case 0 : 
          var match = hp[0];
          if (match) {
            var grs = match[0];
            var exit = 0;
            if (grs) {
              if (hint) {
                exit = 1;
              } else {
                return /* PathEmpty */0;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              if (hint) {
                var _hints = grs;
                var _hints$prime = hint[0];
                while(true) {
                  var hints$prime = _hints$prime;
                  var hints = _hints;
                  if (hints) {
                    if (hints$prime) {
                      if (Globnames$ReactTemplate.eq_gr(hints[0], hints$prime[0])) {
                        _hints$prime = hints$prime[1];
                        _hints = hints[1];
                        continue ;
                        
                      } else {
                        return /* PathEmpty */0;
                      }
                    } else {
                      return /* PathAtom */Block.__(0, [/* PathHints */[hints]]);
                    }
                  } else if (hints$prime) {
                    return /* PathEmpty */0;
                  } else {
                    return /* PathEpsilon */1;
                  }
                };
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "hints.ml",
                        380,
                        16
                      ]
                    ];
              }
            }
            
          } else {
            return /* PathEpsilon */1;
          }
          break;
      case 1 : 
          if (path_matches(hp[0], /* :: */[
                  hint,
                  /* [] */0
                ])) {
            return hp;
          } else {
            return /* PathEpsilon */1;
          }
      case 2 : 
          var hp$prime = hp[1];
          var hp$1 = hp[0];
          var hpder = path_derivate(hp$1, hint);
          if (matches_epsilon(hp$1)) {
            return /* PathOr */Block.__(3, [
                      path_seq(hpder, hp$prime),
                      path_derivate(hp$prime, hint)
                    ]);
          } else if (is_empty(hpder)) {
            return /* PathEmpty */0;
          } else {
            return path_seq(hpder, hp$prime);
          }
      case 3 : 
          return /* PathOr */Block.__(3, [
                    path_derivate(hp[0], hint),
                    path_derivate(hp[1], hint)
                  ]);
      
    }
  }
}

function normalize_path(_h) {
  while(true) {
    var h = _h;
    if (typeof h === "number") {
      return h;
    } else {
      switch (h.tag | 0) {
        case 1 : 
            var match = h[0];
            if (typeof match === "number" && match !== 0) {
              return /* PathEpsilon */1;
            } else {
              return h;
            }
        case 2 : 
            var p = h[0];
            var exit = 0;
            var exit$1 = 0;
            if (typeof p === "number") {
              if (p !== 0) {
                exit$1 = 2;
              } else {
                return /* PathEmpty */0;
              }
            } else {
              exit$1 = 2;
            }
            if (exit$1 === 2) {
              var match$1 = h[1];
              if (typeof match$1 === "number") {
                if (match$1 !== 0) {
                  exit = 1;
                } else {
                  return /* PathEmpty */0;
                }
              } else {
                exit = 1;
              }
            }
            if (exit === 1) {
              if (typeof p === "number") {
                _h = h[1];
                continue ;
                
              } else {
                var q = h[1];
                if (typeof q === "number") {
                  _h = p;
                  continue ;
                  
                } else {
                  var p$prime = normalize_path(p);
                  var q$prime = normalize_path(q);
                  if (hints_path_eq(p, p$prime) && hints_path_eq(q, q$prime)) {
                    return h;
                  } else {
                    _h = /* PathSeq */Block.__(2, [
                        p$prime,
                        q$prime
                      ]);
                    continue ;
                    
                  }
                }
              }
            }
            break;
        case 3 : 
            var p$1 = h[0];
            var exit$2 = 0;
            if (typeof p$1 === "number") {
              if (p$1 !== 0) {
                exit$2 = 1;
              } else {
                _h = h[1];
                continue ;
                
              }
            } else {
              exit$2 = 1;
            }
            if (exit$2 === 1) {
              var q$1 = h[1];
              var exit$3 = 0;
              if (typeof q$1 === "number") {
                if (q$1 !== 0) {
                  exit$3 = 2;
                } else {
                  _h = p$1;
                  continue ;
                  
                }
              } else {
                exit$3 = 2;
              }
              if (exit$3 === 2) {
                var p$prime$1 = normalize_path(p$1);
                var q$prime$1 = normalize_path(q$1);
                if (hints_path_eq(p$1, p$prime$1) && hints_path_eq(q$1, q$prime$1)) {
                  return h;
                } else {
                  _h = /* PathOr */Block.__(3, [
                      p$prime$1,
                      q$prime$1
                    ]);
                  continue ;
                  
                }
              }
              
            }
            break;
        default:
          return h;
      }
    }
  };
}

function path_derivate$1(hp, hint) {
  return normalize_path(path_derivate(hp, hint));
}

function pp_hints_path_atom(prg, a) {
  if (a) {
    return Pp$ReactTemplate.pr_sequence(prg, a[0]);
  } else {
    return Pp$ReactTemplate.str("_");
  }
}

function pp_hints_path_gen(prg) {
  var aux = function (param) {
    if (typeof param === "number") {
      if (param) {
        return Pp$ReactTemplate.str("eps");
      } else {
        return Pp$ReactTemplate.str("emp");
      }
    } else {
      switch (param.tag | 0) {
        case 0 : 
            return pp_hints_path_atom(prg, param[0]);
        case 1 : 
            var p = param[0];
            var exit = 0;
            if (typeof p === "number") {
              exit = 1;
            } else if (p.tag) {
              exit = 1;
            } else if (p[0]) {
              exit = 1;
            } else {
              return Pp$ReactTemplate.str("_*");
            }
            if (exit === 1) {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), aux(p)), Pp$ReactTemplate.str(")*"));
            }
            break;
        case 2 : 
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(aux(param[0]), Pp$ReactTemplate.spc(/* () */0)), aux(param[1]));
        case 3 : 
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), aux(param[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("|")), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.spc(/* () */0)), aux(param[1])), Pp$ReactTemplate.str(")"));
        
      }
    }
  };
  return aux;
}

var pp_hints_path = pp_hints_path_gen(Printer$ReactTemplate.pr_global);

function glob_hints_path_atom(p) {
  if (p) {
    return /* PathHints */[Curry._2(Util$ReactTemplate.List[/* map */10], Nametab$ReactTemplate.$$global, p[0])];
  } else {
    return /* PathAny */0;
  }
}

function aux(param) {
  if (typeof param === "number") {
    if (param) {
      return /* PathEpsilon */1;
    } else {
      return /* PathEmpty */0;
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return /* PathAtom */Block.__(0, [glob_hints_path_atom(param[0])]);
      case 1 : 
          return /* PathStar */Block.__(1, [aux(param[0])]);
      case 2 : 
          return /* PathSeq */Block.__(2, [
                    aux(param[0]),
                    aux(param[1])
                  ]);
      case 3 : 
          return /* PathOr */Block.__(3, [
                    aux(param[0]),
                    aux(param[1])
                  ]);
      
    }
  }
}

function subst_path_atom(subst, p) {
  if (p) {
    var grs = p[0];
    var gr$prime = function (gr) {
      return Globnames$ReactTemplate.subst_global(subst, gr)[0];
    };
    var grs$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], gr$prime, grs);
    if (grs$prime === grs) {
      return p;
    } else {
      return /* PathHints */[grs$prime];
    }
  } else {
    return p;
  }
}

function subst_hints_path(subst, hp) {
  if (typeof hp === "number") {
    return hp;
  } else {
    switch (hp.tag | 0) {
      case 0 : 
          var p = hp[0];
          var p$prime = subst_path_atom(subst, p);
          if (p$prime === p) {
            return hp;
          } else {
            return /* PathAtom */Block.__(0, [p$prime]);
          }
      case 1 : 
          var p$1 = hp[0];
          var p$prime$1 = subst_hints_path(subst, p$1);
          if (p$prime$1 === p$1) {
            return hp;
          } else {
            return /* PathStar */Block.__(1, [p$prime$1]);
          }
      case 2 : 
          var q = hp[1];
          var p$2 = hp[0];
          var p$prime$2 = subst_hints_path(subst, p$2);
          var q$prime = subst_hints_path(subst, q);
          if (p$prime$2 === p$2 && q$prime === q) {
            return hp;
          } else {
            return /* PathSeq */Block.__(2, [
                      p$prime$2,
                      q$prime
                    ]);
          }
      case 3 : 
          var q$1 = hp[1];
          var p$3 = hp[0];
          var p$prime$3 = subst_hints_path(subst, p$3);
          var q$prime$1 = subst_hints_path(subst, q$1);
          if (p$prime$3 === p$3 && q$prime$1 === q$1) {
            return hp;
          } else {
            return /* PathOr */Block.__(3, [
                      p$prime$3,
                      q$prime$1
                    ]);
          }
      
    }
  }
}

function next_hint_id(db) {
  var h = db[/* hintdb_max_id */3];
  var newrecord = db.slice();
  return /* tuple */[
          (newrecord[/* hintdb_max_id */3] = db[/* hintdb_max_id */3] + 1 | 0, newrecord),
          h
        ];
}

function empty(name, st, use_dn) {
  return /* record */[
          /* hintdb_state */st,
          /* hintdb_cut : PathEmpty */0,
          /* hintdb_unfolds : tuple */[
            Names$ReactTemplate.Id[/* Set */9][/* empty */0],
            Names$ReactTemplate.Cset[/* empty */0]
          ],
          /* hintdb_max_id */0,
          /* use_dn */use_dn,
          /* hintdb_map */Constr_map[/* empty */0],
          /* hintdb_nopat : [] */0,
          /* hintdb_name */name
        ];
}

function find(key, db) {
  try {
    return Curry._2(Constr_map[/* find */21], key, db[/* hintdb_map */5]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return empty_se;
    } else {
      throw exn;
    }
  }
}

function head_evar(sigma, c) {
  var _c = c;
  while(true) {
    var c$1 = _c;
    var match = EConstr$ReactTemplate.kind(sigma, c$1);
    switch (match.tag | 0) {
      case 3 : 
          return match[0][0];
      case 5 : 
      case 9 : 
          _c = match[0];
          continue ;
          case 13 : 
          _c = match[2];
          continue ;
          case 16 : 
          _c = match[1];
          continue ;
          default:
        throw Evarutil$ReactTemplate.NoHeadEvar;
    }
  };
}

function matches_modes(sigma, args, modes) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], modes)) {
    return /* true */1;
  } else {
    return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                  var sigma$1 = sigma;
                  var args$1 = args;
                  var mode = param;
                  if (mode.length === args$1.length) {
                    return Util$ReactTemplate.$$Array[/* for_all2 */27]((function (param, param$1) {
                                  var sigma$2 = sigma$1;
                                  var m = param;
                                  var arg = param$1;
                                  switch (m) {
                                    case 0 : 
                                        return 1 - Termops$ReactTemplate.occur_existential(sigma$2, arg);
                                    case 1 : 
                                        try {
                                          head_evar(sigma$2, arg);
                                          return /* false */0;
                                        }
                                        catch (exn){
                                          if (exn === Evarutil$ReactTemplate.NoHeadEvar) {
                                            return /* true */1;
                                          } else {
                                            throw exn;
                                          }
                                        }
                                        break;
                                    case 2 : 
                                        return /* true */1;
                                    
                                  }
                                }), mode, args$1);
                  } else {
                    return /* false */0;
                  }
                }), modes);
  }
}

function merge_entry(secvars, db, nopat, pat) {
  var h = Curry._2(Util$ReactTemplate.List[/* sort */38], pri_order_int, Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
              return prim[1];
            }), db[/* hintdb_nopat */6]));
  var h$1 = Curry._3(Util$ReactTemplate.List[/* merge */42], pri_order_int, h, nopat);
  var h$2 = Curry._3(Util$ReactTemplate.List[/* merge */42], pri_order_int, h$1, pat);
  return Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function (param) {
                var secvars$1 = secvars;
                var param$1 = param;
                var tac = param$1[1];
                if (Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* subset */13], tac[/* secvars */5], secvars$1)) {
                  return /* Some */[tac];
                } else {
                  return /* None */0;
                }
              }), h$2);
}

function map_none(secvars, db) {
  return merge_entry(secvars, db, /* [] */0, /* [] */0);
}

function map_all(secvars, k, db) {
  var se = find(k, db);
  return merge_entry(secvars, db, se[/* sentry_nopat */0], se[/* sentry_pat */1]);
}

function map_auto(sigma, secvars, param, concl, db) {
  var se = find(param[0], db);
  var st = db[/* use_dn */4] ? /* Some */[db[/* hintdb_state */0]] : /* None */0;
  var pat = lookup_tacs(sigma, concl, st, se);
  return merge_entry(secvars, db, /* [] */0, pat);
}

function map_existential(sigma, secvars, param, _, db) {
  var se = find(param[0], db);
  if (matches_modes(sigma, param[1], se[/* sentry_mode */3])) {
    return merge_entry(secvars, db, se[/* sentry_nopat */0], se[/* sentry_pat */1]);
  } else {
    return merge_entry(secvars, db, /* [] */0, /* [] */0);
  }
}

function map_eauto(sigma, secvars, param, concl, db) {
  var se = find(param[0], db);
  if (matches_modes(sigma, param[1], se[/* sentry_mode */3])) {
    var st = db[/* use_dn */4] ? /* Some */[db[/* hintdb_state */0]] : /* None */0;
    var pat = lookup_tacs(sigma, concl, st, se);
    return merge_entry(secvars, db, /* [] */0, pat);
  } else {
    return merge_entry(secvars, db, /* [] */0, /* [] */0);
  }
}

function is_exact(param) {
  if (param.tag === 2) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_unfold(param) {
  if (param.tag === 4) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function addkv(gr, id, v, db) {
  var newrecord = v.slice();
  var idv_001 = (newrecord[/* db */4] = db[/* hintdb_name */7], newrecord);
  var idv = /* tuple */[
    id,
    idv_001
  ];
  var k;
  if (gr) {
    var gr$1 = gr[0];
    k = db[/* use_dn */4] && is_transparent_gr(db[/* hintdb_state */0], gr$1) && is_unfold(v[/* code */6][/* obj */0]) ? /* None */0 : /* Some */[gr$1];
  } else {
    k = /* None */0;
  }
  var dnst = db[/* use_dn */4] ? /* Some */[db[/* hintdb_state */0]] : /* None */0;
  var pat = !db[/* use_dn */4] && is_exact(v[/* code */6][/* obj */0]) ? /* None */0 : v[/* pat */2];
  if (k) {
    var gr$2 = k[0];
    var oval = find(gr$2, db);
    var newrecord$1 = db.slice();
    newrecord$1[/* hintdb_map */5] = Curry._3(Constr_map[/* add */3], gr$2, add_tac(pat, idv, dnst, oval), db[/* hintdb_map */5]);
    return newrecord$1;
  } else {
    var is_present = function (param) {
      return Names$ReactTemplate.KerName[/* equal */9](v[/* code */6][/* uid */1], param[1][1][/* code */6][/* uid */1]);
    };
    if (Curry._2(Util$ReactTemplate.List[/* exists */21], is_present, db[/* hintdb_nopat */6])) {
      return db;
    } else {
      var newrecord$2 = db.slice();
      newrecord$2[/* hintdb_nopat */6] = /* :: */[
        /* tuple */[
          gr,
          idv
        ],
        db[/* hintdb_nopat */6]
      ];
      return newrecord$2;
    }
  }
}

function rebuild_db(st$prime, db) {
  var db$prime_001 = /* hintdb_cut */db[/* hintdb_cut */1];
  var db$prime_002 = /* hintdb_unfolds */db[/* hintdb_unfolds */2];
  var db$prime_003 = /* hintdb_max_id */db[/* hintdb_max_id */3];
  var db$prime_004 = /* use_dn */db[/* use_dn */4];
  var db$prime_005 = /* hintdb_map */Curry._2(Constr_map[/* map */22], (function (param) {
          return rebuild_dn(st$prime, param);
        }), db[/* hintdb_map */5]);
  var db$prime_007 = /* hintdb_name */db[/* hintdb_name */7];
  var db$prime = /* record */[
    /* hintdb_state */st$prime,
    db$prime_001,
    db$prime_002,
    db$prime_003,
    db$prime_004,
    db$prime_005,
    /* hintdb_nopat : [] */0,
    db$prime_007
  ];
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (db, param) {
                var match = param[1];
                return addkv(param[0], match[0], match[1], db);
              }), db$prime, db[/* hintdb_nopat */6]);
}

function add_one(env, sigma, param, db) {
  var v = instantiate_hint(env, sigma, param[1]);
  var match = v[/* code */6][/* obj */0];
  var match$1;
  if (match.tag === 4) {
    var egr = match[0];
    var addunf = function (param, param$1) {
      var csts$prime = param$1[1];
      var ids$prime = param$1[0];
      var csts = param[1];
      var ids = param[0];
      if (egr.tag) {
        var cst = egr[0];
        return /* tuple */[
                /* tuple */[
                  ids,
                  Curry._2(Names$ReactTemplate.Cpred[/* add */6], cst, csts)
                ],
                /* tuple */[
                  ids$prime,
                  Curry._2(Names$ReactTemplate.Cset[/* add */3], cst, csts$prime)
                ]
              ];
      } else {
        var id = egr[0];
        return /* tuple */[
                /* tuple */[
                  Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* add */6], id, ids),
                  csts
                ],
                /* tuple */[
                  Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, ids$prime),
                  csts$prime
                ]
              ];
      }
    };
    var match$2 = addunf(db[/* hintdb_state */0], db[/* hintdb_unfolds */2]);
    var newrecord = db.slice();
    match$1 = /* tuple */[
      match$2[0],
      (newrecord[/* hintdb_unfolds */2] = match$2[1], newrecord),
      /* true */1
    ];
  } else {
    match$1 = /* tuple */[
      db[/* hintdb_state */0],
      db,
      /* false */0
    ];
  }
  var db$1 = match$1[1];
  var db$2 = db$1[/* use_dn */4] && match$1[2] ? rebuild_db(match$1[0], db$1) : db$1;
  var match$3 = next_hint_id(db$2);
  return addkv(param[0], match$3[1], v, match$3[0]);
}

function add_list(env, sigma, l, db) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (db, k) {
                return add_one(env, sigma, k, db);
              }), db, l);
}

function remove_list(grs, db) {
  var filter = function (param) {
    var match = param[1][/* name */3];
    if (match) {
      var match$1 = match[0];
      if (match$1 && !match$1[1]) {
        return 1 - Curry._3(Util$ReactTemplate.List[/* mem_f */47], Globnames$ReactTemplate.eq_gr, match$1[0], grs);
      } else {
        return /* true */1;
      }
    } else {
      return /* true */1;
    }
  };
  var partial_arg = db[/* hintdb_state */0];
  var hintmap = Curry._2(Constr_map[/* map */22], (function (param) {
          var st = partial_arg;
          var p = filter;
          var se = param;
          var sl1$prime = Curry._2(Util$ReactTemplate.List[/* smartfilter */74], p, se[/* sentry_nopat */0]);
          var sl2$prime = Curry._2(Util$ReactTemplate.List[/* smartfilter */74], p, se[/* sentry_pat */1]);
          if (sl1$prime === se[/* sentry_nopat */0] && sl2$prime === se[/* sentry_pat */1]) {
            return se;
          } else {
            return rebuild_dn(st, /* record */[
                        /* sentry_nopat */sl1$prime,
                        /* sentry_pat */sl2$prime,
                        /* sentry_bnet */se[/* sentry_bnet */2],
                        /* sentry_mode */se[/* sentry_mode */3]
                      ]);
          }
        }), db[/* hintdb_map */5]);
  var hintnopat = Curry._2(Util$ReactTemplate.List[/* smartfilter */74], (function (param) {
          return filter(param[1]);
        }), db[/* hintdb_nopat */6]);
  var newrecord = db.slice();
  newrecord[/* hintdb_map */5] = hintmap;
  newrecord[/* hintdb_nopat */6] = hintnopat;
  return newrecord;
}

function remove_one(gr, db) {
  return remove_list(/* :: */[
              gr,
              /* [] */0
            ], db);
}

function get_entry(se) {
  var h = Curry._3(Util$ReactTemplate.List[/* merge */42], pri_order_int, se[/* sentry_nopat */0], se[/* sentry_pat */1]);
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                return prim[1];
              }), h);
}

function iter(f, db) {
  var iter_se = function (k, se) {
    return Curry._3(f, /* Some */[k], se[/* sentry_mode */3], get_entry(se));
  };
  Curry._3(f, /* None */0, /* [] */0, Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
              return x[1][1];
            }), db[/* hintdb_nopat */6]));
  return Curry._2(Constr_map[/* iter */9], iter_se, db[/* hintdb_map */5]);
}

function fold(f, db, accu) {
  var accu$1 = Curry._4(f, /* None */0, /* [] */0, Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
              return x[1][1];
            }), db[/* hintdb_nopat */6]), accu);
  return Curry._3(Constr_map[/* fold */10], (function (k, se) {
                return Curry._3(f, /* Some */[k], se[/* sentry_mode */3], get_entry(se));
              }), db[/* hintdb_map */5], accu$1);
}

function transparent_state(db) {
  return db[/* hintdb_state */0];
}

function set_transparent_state(db, st) {
  if (db[/* use_dn */4]) {
    return rebuild_db(st, db);
  } else {
    var newrecord = db.slice();
    newrecord[/* hintdb_state */0] = st;
    return newrecord;
  }
}

function add_cut(path, db) {
  var newrecord = db.slice();
  newrecord[/* hintdb_cut */1] = normalize_path(/* PathOr */Block.__(3, [
          db[/* hintdb_cut */1],
          path
        ]));
  return newrecord;
}

function add_mode(gr, m, db) {
  var se = find(gr, db);
  var se_000 = /* sentry_nopat */se[/* sentry_nopat */0];
  var se_001 = /* sentry_pat */se[/* sentry_pat */1];
  var se_002 = /* sentry_bnet */se[/* sentry_bnet */2];
  var se_003 = /* sentry_mode : :: */[
    m,
    se[/* sentry_mode */3]
  ];
  var se$1 = /* record */[
    se_000,
    se_001,
    se_002,
    se_003
  ];
  var newrecord = db.slice();
  newrecord[/* hintdb_map */5] = Curry._3(Constr_map[/* add */3], gr, se$1, db[/* hintdb_map */5]);
  return newrecord;
}

function cut(db) {
  return db[/* hintdb_cut */1];
}

function unfolds(db) {
  return db[/* hintdb_unfolds */2];
}

function use_dn(db) {
  return db[/* use_dn */4];
}

var typeclasses_db = "typeclass_instances";

var rewrite_db = "rewrite";

var auto_init_db = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], typeclasses_db, empty(/* None */0, Names$ReactTemplate.full_transparent_state, /* true */1), Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], rewrite_db, empty(/* None */0, Names$ReactTemplate.cst_full_transparent_state, /* true */1), Util$ReactTemplate.$$String[/* Map */39][/* empty */0]));

var searchtable = [auto_init_db];

var statustable = [Names$ReactTemplate.KNmap[/* empty */0]];

function searchtable_map(name) {
  return Curry._2(Util$ReactTemplate.$$String[/* Map */39][/* find */21], name, searchtable[0]);
}

function searchtable_add(param) {
  searchtable[0] = Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* add */3], param[0], param[1], searchtable[0]);
  return /* () */0;
}

function current_db_names() {
  return Curry._1(Util$ReactTemplate.$$String[/* Map */39][/* domain */27], searchtable[0]);
}

function current_db() {
  return Curry._1(Util$ReactTemplate.$$String[/* Map */39][/* bindings */16], searchtable[0]);
}

function current_pure_db() {
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                return prim[1];
              }), current_db(/* () */0));
}

function error_no_such_hint_database(x) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Hints"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No such Hint database: "), Pp$ReactTemplate.str(x)), Pp$ReactTemplate.str(".")));
}

var hints_init = [(function () {
      return /* () */0;
    })];

function add_hints_init(f) {
  var init = hints_init[0];
  hints_init[0] = (function () {
      Curry._1(init, /* () */0);
      return Curry._1(f, /* () */0);
    });
  return /* () */0;
}

function init() {
  searchtable[0] = auto_init_db;
  statustable[0] = Names$ReactTemplate.KNmap[/* empty */0];
  return Curry._1(hints_init[0], /* () */0);
}

function freeze() {
  return /* tuple */[
          searchtable[0],
          statustable[0]
        ];
}

function unfreeze(param) {
  searchtable[0] = param[0];
  statustable[0] = param[1];
  return /* () */0;
}

Summary$ReactTemplate.declare_summary("search", /* record */[
      /* freeze_function */freeze,
      /* unfreeze_function */unfreeze,
      /* init_function */init
    ]);

function nb_hyp(sigma, _c) {
  while(true) {
    var c = _c;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 6) {
      var c2 = match[2];
      if (EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, c2)) {
        return 1 + nb_hyp(sigma, c2) | 0;
      } else {
        _c = c2;
        continue ;
        
      }
    } else {
      return 0;
    }
  };
}

function try_head_pattern(c) {
  try {
    return Patternops$ReactTemplate.head_pattern_bound(c);
  }
  catch (exn){
    if (exn === Patternops$ReactTemplate.BoundPattern) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Head pattern or sub-pattern must be a global constant, a section variable, an if, case, or let expression, an application, or a projection."));
    } else {
      throw exn;
    }
  }
}

function secvars_of_idset(s) {
  return Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], (function (id, p) {
                if (Termops$ReactTemplate.is_section_variable(id)) {
                  return Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* add */6], id, p);
                } else {
                  return p;
                }
              }), s, Names$ReactTemplate.Id[/* Pred */11][/* empty */0]);
}

function secvars_of_constr(env, sigma, c) {
  return secvars_of_idset(Termops$ReactTemplate.global_vars_set(env, sigma, c));
}

function make_exact_entry(env, sigma, info, poly, $staropt$star, param) {
  var c = param[0];
  var name = $staropt$star ? $staropt$star[0] : /* PathAny */0;
  var secvars = secvars_of_constr(env, sigma, c);
  var cty = Termops$ReactTemplate.strip_outer_cast(sigma, param[1]);
  var match = EConstr$ReactTemplate.kind(sigma, cty);
  if (match.tag === 6) {
    return Pervasives.failwith("make_exact_entry");
  } else {
    var pat = Patternops$ReactTemplate.pattern_of_constr(env, sigma, EConstr$ReactTemplate.to_constr(sigma, cty));
    var hd;
    try {
      hd = Patternops$ReactTemplate.head_pattern_bound(pat);
    }
    catch (exn){
      if (exn === Patternops$ReactTemplate.BoundPattern) {
        hd = Pervasives.failwith("make_exact_entry");
      } else {
        throw exn;
      }
    }
    var match$1 = info[/* hint_priority */0];
    var pri = match$1 ? match$1[0] : 0;
    var match$2 = info[/* hint_pattern */1];
    var pat$1 = match$2 ? match$2[0][1] : pat;
    return /* tuple */[
            /* Some */[hd],
            /* record */[
              /* pri */pri,
              /* poly */poly,
              /* pat : Some */[pat$1],
              /* name */name,
              /* db : None */0,
              /* secvars */secvars,
              /* code : record */[
                /* obj : Give_exact */Block.__(2, [/* tuple */[
                      c,
                      cty,
                      param[2]
                    ]]),
                /* uid */fresh_key(/* () */0)
              ]
            ]
          ];
  }
}

function make_apply_entry(env, sigma, param, info, poly, $staropt$star, param$1) {
  var ctx = param$1[2];
  var cty = param$1[1];
  var c = param$1[0];
  var name = $staropt$star ? $staropt$star[0] : /* PathAny */0;
  var cty$1 = param[1] ? Tacred$ReactTemplate.hnf_constr(env, sigma, cty) : cty;
  var match = EConstr$ReactTemplate.kind(sigma, cty$1);
  if (match.tag === 6) {
    var sigma$prime = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible, sigma, ctx);
    var ce = Clenv$ReactTemplate.mk_clenv_from_env(env, sigma$prime, /* None */0, /* tuple */[
          c,
          cty$1
        ]);
    var c$prime = Clenv$ReactTemplate.clenv_type(ce);
    var pat = Patternops$ReactTemplate.pattern_of_constr(env, ce[/* evd */1], EConstr$ReactTemplate.to_constr(sigma, c$prime));
    var hd;
    try {
      hd = Patternops$ReactTemplate.head_pattern_bound(pat);
    }
    catch (exn){
      if (exn === Patternops$ReactTemplate.BoundPattern) {
        hd = Pervasives.failwith("make_apply_entry");
      } else {
        throw exn;
      }
    }
    var nmiss = Curry._1(Util$ReactTemplate.List[/* length */0], Clenv$ReactTemplate.clenv_missing(ce));
    var secvars = secvars_of_constr(env, sigma, c);
    var match$1 = info[/* hint_priority */0];
    var pri = match$1 ? match$1[0] : nb_hyp(sigma$prime, cty$1) + nmiss | 0;
    var match$2 = info[/* hint_pattern */1];
    var pat$1 = match$2 ? match$2[0][1] : pat;
    if (nmiss) {
      if (!param[0]) {
        Pervasives.failwith("make_apply_entry");
      }
      if (param[2]) {
        Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("the hint: eapply "), Printer$ReactTemplate.pr_leconstr_env(env, sigma$prime, c)), Pp$ReactTemplate.str(" will only be used by eauto")));
      }
      return /* tuple */[
              /* Some */[hd],
              /* record */[
                /* pri */pri,
                /* poly */poly,
                /* pat : Some */[pat$1],
                /* name */name,
                /* db : None */0,
                /* secvars */secvars,
                /* code : record */[
                  /* obj : ERes_pf */Block.__(1, [/* tuple */[
                        c,
                        cty$1,
                        ctx
                      ]]),
                  /* uid */fresh_key(/* () */0)
                ]
              ]
            ];
    } else {
      return /* tuple */[
              /* Some */[hd],
              /* record */[
                /* pri */pri,
                /* poly */poly,
                /* pat : Some */[pat$1],
                /* name */name,
                /* db : None */0,
                /* secvars */secvars,
                /* code : record */[
                  /* obj : Res_pf */Block.__(0, [/* tuple */[
                        c,
                        cty$1,
                        ctx
                      ]]),
                  /* uid */fresh_key(/* () */0)
                ]
              ]
            ];
    }
  } else {
    return Pervasives.failwith("make_apply_entry");
  }
}

function pr_hint_term(env, sigma, _, param) {
  if (param.tag) {
    var sigma$1 = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible, sigma, param[1]);
    return Printer$ReactTemplate.pr_econstr_env(env, sigma$1, param[0]);
  } else {
    return Printer$ReactTemplate.pr_global(param[0]);
  }
}

function cache_context_set(param) {
  return Global$ReactTemplate.push_context_set(/* false */0, param[1]);
}

var init$1 = Libobject$ReactTemplate.default_object("Global universe context");

var input_context_set = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$1[/* object_name */0],
      /* cache_function */cache_context_set,
      /* load_function */(function () {
          return cache_context_set;
        }),
      /* open_function */init$1[/* open_function */3],
      /* classify_function */(function (a) {
          return /* Keep */Block.__(1, [a]);
        }),
      /* subst_function */init$1[/* subst_function */5],
      /* discharge_function */(function (param) {
          return /* Some */[param[1]];
        }),
      /* rebuild_function */init$1[/* rebuild_function */7]
    ]);

var warn_polymorphic_hint = CWarnings$ReactTemplate.create("polymorphic-hint", "automation", /* None */0, (function (hint) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Using polymorphic hint "), hint), Pp$ReactTemplate.str(" monomorphically")), Pp$ReactTemplate.strbrk(" use Polymorphic Hint to use it polymorphically."));
      }));

function fresh_global_or_constr(env, sigma, poly, cr) {
  var match;
  if (cr.tag) {
    match = /* tuple */[
      /* false */0,
      /* tuple */[
        cr[0],
        cr[1]
      ]
    ];
  } else {
    var match$1 = Universes$ReactTemplate.fresh_global_instance(/* None */0, env, cr[0]);
    match = /* tuple */[
      /* true */1,
      /* tuple */[
        EConstr$ReactTemplate.of_constr(match$1[0]),
        match$1[1]
      ]
    ];
  }
  var match$2 = match[1];
  var ctx = match$2[1];
  var c = match$2[0];
  if (poly) {
    return /* tuple */[
            c,
            ctx
          ];
  } else if (Univ$ReactTemplate.ContextSet[/* is_empty */1](ctx)) {
    return /* tuple */[
            c,
            ctx
          ];
  } else {
    if (match[0]) {
      Curry._2(warn_polymorphic_hint, /* None */0, pr_hint_term(env, sigma, ctx, cr));
    }
    Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(input_context_set, ctx));
    return /* tuple */[
            c,
            Univ$ReactTemplate.ContextSet[/* empty */0]
          ];
  }
}

function make_resolves(env, sigma, flags, info, poly, name, cr) {
  var match = fresh_global_or_constr(env, sigma, poly, cr);
  var ctx = match[1];
  var c = match[0];
  var cty = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, sigma, c);
  var try_apply = function (f) {
    try {
      return /* Some */[Curry._1(f, /* tuple */[
                    c,
                    cty,
                    ctx
                  ])];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
  };
  var ents = Curry._2(Util$ReactTemplate.List[/* map_filter */62], try_apply, /* :: */[
        (function (param) {
            return make_exact_entry(env, sigma, info, poly, name, param);
          }),
        /* :: */[
          (function (param) {
              return make_apply_entry(env, sigma, flags, info, poly, name, param);
            }),
          /* [] */0
        ]
      ]);
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], ents)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Hint"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_leconstr_env(env, sigma, c), Pp$ReactTemplate.spc(/* () */0)), Util$ReactTemplate.pi1(flags) ? Pp$ReactTemplate.str("cannot be used as a hint.") : Pp$ReactTemplate.str("can be used as a hint only for eauto.")));
  }
  return ents;
}

function make_resolve_hyp(env, sigma, decl) {
  var hname = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl);
  var c = EConstr$ReactTemplate.mkVar(hname);
  try {
    return /* :: */[
            make_apply_entry(env, sigma, /* tuple */[
                  /* true */1,
                  /* true */1,
                  /* false */0
                ], empty_hint_info, /* false */0, /* Some */[/* PathHints */[/* :: */[
                      /* VarRef */Block.__(0, [hname]),
                      /* [] */0
                    ]]], /* tuple */[
                  c,
                  Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl),
                  Univ$ReactTemplate.ContextSet[/* empty */0]
                ]),
            /* [] */0
          ];
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (e[0] === Caml_builtin_exceptions.failure) {
      return /* [] */0;
    } else if (Logic$ReactTemplate.catchable_exception(e)) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("make_resolve_hyp."));
    } else {
      throw e;
    }
  }
}

function make_unfold(eref) {
  var g = Tacred$ReactTemplate.global_of_evaluable_reference(eref);
  var env = Global$ReactTemplate.env(/* () */0);
  return /* tuple */[
          /* Some */[g],
          /* record */[
            /* pri */4,
            /* poly : false */0,
            /* pat : None */0,
            /* name : PathHints */[/* :: */[
                g,
                /* [] */0
              ]],
            /* db : None */0,
            /* secvars */secvars_of_idset(Termops$ReactTemplate.vars_of_global_reference(env, g)),
            /* code : record */[
              /* obj : Unfold_nth */Block.__(4, [eref]),
              /* uid */fresh_key(/* () */0)
            ]
          ]
        ];
}

function make_extern(pri, pat, tacast) {
  var hdconstr = Option$ReactTemplate.map(try_head_pattern, pat);
  return /* tuple */[
          hdconstr,
          /* record */[
            /* pri */pri,
            /* poly : false */0,
            /* pat */pat,
            /* name : PathAny */0,
            /* db : None */0,
            /* secvars */Names$ReactTemplate.Id[/* Pred */11][/* empty */0],
            /* code : record */[
              /* obj : Extern */Block.__(5, [tacast]),
              /* uid */fresh_key(/* () */0)
            ]
          ]
        ];
}

function make_mode(ref, m) {
  var match = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), ref);
  var match$1 = Term$ReactTemplate.decompose_prod(match[0]);
  var n = Curry._1(Util$ReactTemplate.List[/* length */0], match$1[0]);
  var m$prime = Util$ReactTemplate.$$Array[/* of_list */10](m);
  if (n !== m$prime.length) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Hint"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Printer$ReactTemplate.pr_global(ref), Pp$ReactTemplate.str(" has ")), Pp$ReactTemplate.$$int(n)), Pp$ReactTemplate.str(" arguments while the mode declares ")), Pp$ReactTemplate.$$int(m$prime.length)));
  } else {
    return m$prime;
  }
}

function get_db(dbname) {
  try {
    return searchtable_map(dbname);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return empty(/* Some */[dbname], Names$ReactTemplate.empty_transparent_state, /* false */0);
    } else {
      throw exn;
    }
  }
}

function load_autohint(_, param) {
  var h = param[1];
  var name = h[/* hint_name */1];
  var match = h[/* hint_action */2];
  switch (match.tag | 0) {
    case 0 : 
        return searchtable_add(/* tuple */[
                    name,
                    empty(/* Some */[name], match[1], match[0])
                  ]);
    case 1 : 
        var dbname = name;
        var grs = match[0];
        var b = match[1];
        var db = get_db(dbname);
        var st = db[/* hintdb_state */0];
        var st$prime = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, gr) {
                var csts = param[1];
                var ids = param[0];
                if (gr.tag) {
                  return /* tuple */[
                          ids,
                          Curry._2(b ? Names$ReactTemplate.Cpred[/* add */6] : Names$ReactTemplate.Cpred[/* remove */7], gr[0], csts)
                        ];
                } else {
                  return /* tuple */[
                          Curry._2(b ? Names$ReactTemplate.Id[/* Pred */11][/* add */6] : Names$ReactTemplate.Id[/* Pred */11][/* remove */7], gr[0], ids),
                          csts
                        ];
                }
              }), st, grs);
        return searchtable_add(/* tuple */[
                    dbname,
                    set_transparent_state(db, st$prime)
                  ]);
    case 2 : 
        var dbname$1 = name;
        var hintlist = match[0];
        var check = function (param) {
          var h = param[1];
          if (Curry._2(Names$ReactTemplate.KNmap[/* mem */2], h[/* code */6][/* uid */1], statustable[0])) {
            CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Conflicting hint keys. This can happen when including twice the same module."));
          }
          statustable[0] = Curry._3(Names$ReactTemplate.KNmap[/* add */3], h[/* code */6][/* uid */1], /* false */0, statustable[0]);
          return /* () */0;
        };
        Curry._2(Util$ReactTemplate.List[/* iter */9], check, hintlist);
        var db$1 = get_db(dbname$1);
        var env = Global$ReactTemplate.env(/* () */0);
        var sigma = Evd$ReactTemplate.from_env(env);
        var db$prime = add_list(env, sigma, hintlist, db$1);
        return searchtable_add(/* tuple */[
                    dbname$1,
                    db$prime
                  ]);
    case 3 : 
        var dbname$2 = name;
        var grs$1 = match[0];
        var db$2 = get_db(dbname$2);
        var db$prime$1 = remove_list(grs$1, db$2);
        return searchtable_add(/* tuple */[
                    dbname$2,
                    db$prime$1
                  ]);
    case 4 : 
        var dbname$3 = name;
        var path = match[0];
        var db$3 = get_db(dbname$3);
        var db$prime$2 = add_cut(path, db$3);
        return searchtable_add(/* tuple */[
                    dbname$3,
                    db$prime$2
                  ]);
    case 5 : 
        var dbname$4 = name;
        var l = match[0];
        var m = match[1];
        var db$4 = get_db(dbname$4);
        var db$prime$3 = add_mode(l, m, db$4);
        return searchtable_add(/* tuple */[
                    dbname$4,
                    db$prime$3
                  ]);
    
  }
}

function open_autohint(i, param) {
  if (i === 1) {
    var match = param[1][/* hint_action */2];
    if (match.tag === 2) {
      var add = function (param) {
        statustable[0] = Curry._3(Names$ReactTemplate.KNmap[/* add */3], param[1][/* code */6][/* uid */1], /* true */1, statustable[0]);
        return /* () */0;
      };
      return Curry._2(Util$ReactTemplate.List[/* iter */9], add, match[0]);
    } else {
      return /* () */0;
    }
  } else {
    return 0;
  }
}

function cache_autohint(param) {
  var obj = param[1];
  var kn = param[0];
  load_autohint(1, /* tuple */[
        kn,
        obj
      ]);
  return open_autohint(1, /* tuple */[
              kn,
              obj
            ]);
}

function subst_autohint(param) {
  var obj = param[1];
  var subst = param[0];
  var subst_key = function (gr) {
    var match = Globnames$ReactTemplate.subst_global(subst, gr);
    var elab$prime = EConstr$ReactTemplate.of_constr(match[1]);
    var gr$prime;
    try {
      gr$prime = head_constr_bound(Evd$ReactTemplate.empty, elab$prime);
    }
    catch (exn){
      if (exn === Bound) {
        gr$prime = match[0];
      } else {
        throw exn;
      }
    }
    if (gr$prime === gr) {
      return gr;
    } else {
      return gr$prime;
    }
  };
  var subst_hint = function (hint) {
    var data = hint[1];
    var k = hint[0];
    var k$prime = Option$ReactTemplate.smartmap(subst_key, k);
    var pat$prime = Option$ReactTemplate.smartmap((function (param) {
            return Patternops$ReactTemplate.subst_pattern(subst, param);
          }), data[/* pat */2]);
    var subst_mps = function (subst, c) {
      return EConstr$ReactTemplate.of_constr(Mod_subst$ReactTemplate.subst_mps(subst, EConstr$ReactTemplate.Unsafe[/* to_constr */0](c)));
    };
    var match = data[/* code */6][/* obj */0];
    var code$prime;
    switch (match.tag | 0) {
      case 0 : 
          var match$1 = match[0];
          var t = match$1[1];
          var c = match$1[0];
          var c$prime = subst_mps(subst, c);
          var t$prime = subst_mps(subst, t);
          code$prime = c === c$prime && t$prime === t ? data[/* code */6][/* obj */0] : /* Res_pf */Block.__(0, [/* tuple */[
                  c$prime,
                  t$prime,
                  match$1[2]
                ]]);
          break;
      case 1 : 
          var match$2 = match[0];
          var t$1 = match$2[1];
          var c$1 = match$2[0];
          var c$prime$1 = subst_mps(subst, c$1);
          var t$prime$1 = subst_mps(subst, t$1);
          code$prime = c$1 === c$prime$1 && t$prime$1 === t$1 ? data[/* code */6][/* obj */0] : /* ERes_pf */Block.__(1, [/* tuple */[
                  c$prime$1,
                  t$prime$1,
                  match$2[2]
                ]]);
          break;
      case 2 : 
          var match$3 = match[0];
          var t$2 = match$3[1];
          var c$2 = match$3[0];
          var c$prime$2 = subst_mps(subst, c$2);
          var t$prime$2 = subst_mps(subst, t$2);
          code$prime = c$2 === c$prime$2 && t$prime$2 === t$2 ? data[/* code */6][/* obj */0] : /* Give_exact */Block.__(2, [/* tuple */[
                  c$prime$2,
                  t$prime$2,
                  match$3[2]
                ]]);
          break;
      case 3 : 
          var match$4 = match[0];
          var t$3 = match$4[1];
          var c$3 = match$4[0];
          var c$prime$3 = subst_mps(subst, c$3);
          var t$prime$3 = subst_mps(subst, t$3);
          code$prime = c$3 === c$prime$3 && t$3 === t$prime$3 ? data[/* code */6][/* obj */0] : /* Res_pf_THEN_trivial_fail */Block.__(3, [/* tuple */[
                  c$prime$3,
                  t$prime$3,
                  match$4[2]
                ]]);
          break;
      case 4 : 
          var ref = match[0];
          var ref$prime = Mod_subst$ReactTemplate.subst_evaluable_reference(subst, ref);
          code$prime = ref === ref$prime ? data[/* code */6][/* obj */0] : /* Unfold_nth */Block.__(4, [ref$prime]);
          break;
      case 5 : 
          var tac = match[0];
          var tac$prime = Genintern$ReactTemplate.generic_substitute(subst, tac);
          code$prime = tac === tac$prime ? data[/* code */6][/* obj */0] : /* Extern */Block.__(5, [tac$prime]);
          break;
      
    }
    var name$prime = subst_path_atom(subst, data[/* name */3]);
    var uid$prime = Mod_subst$ReactTemplate.subst_kn(subst, data[/* code */6][/* uid */1]);
    var data$prime = data[/* code */6][/* uid */1] === uid$prime && data[/* pat */2] === pat$prime && data[/* name */3] === name$prime && data[/* code */6][/* obj */0] === code$prime ? data : /* record */[
        /* pri */data[/* pri */0],
        /* poly */data[/* poly */1],
        /* pat */pat$prime,
        /* name */name$prime,
        /* db */data[/* db */4],
        /* secvars */data[/* secvars */5],
        /* code : record */[
          /* obj */code$prime,
          /* uid */uid$prime
        ]
      ];
    if (k$prime === k && data$prime === data) {
      return hint;
    } else {
      return /* tuple */[
              k$prime,
              data$prime
            ];
    }
  };
  var match = obj[/* hint_action */2];
  var action;
  switch (match.tag | 0) {
    case 0 : 
        action = obj[/* hint_action */2];
        break;
    case 1 : 
        var grs = match[0];
        var grs$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
                return Mod_subst$ReactTemplate.subst_evaluable_reference(subst, param);
              }), grs);
        action = grs === grs$prime ? obj[/* hint_action */2] : /* AddTransparency */Block.__(1, [
              grs$prime,
              match[1]
            ]);
        break;
    case 2 : 
        var hintlist = match[0];
        var hintlist$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], subst_hint, hintlist);
        action = hintlist$prime === hintlist ? obj[/* hint_action */2] : /* AddHints */Block.__(2, [hintlist$prime]);
        break;
    case 3 : 
        var grs$1 = match[0];
        var grs$prime$1 = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
                return Globnames$ReactTemplate.subst_global_reference(subst, param);
              }), grs$1);
        action = grs$1 === grs$prime$1 ? obj[/* hint_action */2] : /* RemoveHints */Block.__(3, [grs$prime$1]);
        break;
    case 4 : 
        var path = match[0];
        var path$prime = subst_hints_path(subst, path);
        action = path$prime === path ? obj[/* hint_action */2] : /* AddCut */Block.__(4, [path$prime]);
        break;
    case 5 : 
        var l = match[0];
        var l$prime = Globnames$ReactTemplate.subst_global_reference(subst, l);
        action = l$prime === l ? obj[/* hint_action */2] : /* AddMode */Block.__(5, [
              l$prime,
              match[1]
            ]);
        break;
    
  }
  if (action === obj[/* hint_action */2]) {
    return obj;
  } else {
    return /* record */[
            /* hint_local */obj[/* hint_local */0],
            /* hint_name */obj[/* hint_name */1],
            /* hint_action */action
          ];
  }
}

function classify_autohint(obj) {
  var match = obj[/* hint_action */2];
  if (match.tag === 2) {
    if (match[0] && !obj[/* hint_local */0]) {
      return /* Substitute */Block.__(0, [obj]);
    } else {
      return /* Dispose */0;
    }
  } else if (obj[/* hint_local */0]) {
    return /* Dispose */0;
  } else {
    return /* Substitute */Block.__(0, [obj]);
  }
}

var init$2 = Libobject$ReactTemplate.default_object("AUTOHINT");

var inAutoHint = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$2[/* object_name */0],
      /* cache_function */cache_autohint,
      /* load_function */load_autohint,
      /* open_function */open_autohint,
      /* classify_function */classify_autohint,
      /* subst_function */subst_autohint,
      /* discharge_function */init$2[/* discharge_function */6],
      /* rebuild_function */init$2[/* rebuild_function */7]
    ]);

function make_hint($staropt$star, name, action) {
  var local = $staropt$star ? $staropt$star[0] : /* false */0;
  return /* record */[
          /* hint_local */local,
          /* hint_name */name,
          /* hint_action */action
        ];
}

function create_hint_db(l, n, st, b) {
  var hint = make_hint(/* Some */[l], n, /* CreateDB */Block.__(0, [
          b,
          st
        ]));
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inAutoHint, hint));
}

function remove_hints(local, dbnames, grs) {
  var dbnames$1 = Curry._1(Util$ReactTemplate.List[/* is_empty */45], dbnames) ? /* :: */[
      "core",
      /* [] */0
    ] : dbnames;
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (dbname) {
                var hint = make_hint(/* Some */[local], dbname, /* RemoveHints */Block.__(3, [grs]));
                return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inAutoHint, hint));
              }), dbnames$1);
}

var default_prepare_hint_ident = Names$ReactTemplate.Id[/* of_string */5]("H");

var Found = Caml_exceptions.create("Hints-ReactTemplate.Found");

function prepare_hint(check, param, env, init, param$1) {
  var sigma = Typeclasses$ReactTemplate.resolve_typeclasses(/* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* false */0], env, param$1[0]);
  var match = Evd$ReactTemplate.nf_univ_variables(sigma);
  var sigma$1 = match[0];
  var c = Evarutil$ReactTemplate.nf_evar(sigma$1, param$1[1]);
  var c$1 = Termops$ReactTemplate.drop_extra_implicit_args(sigma$1, c);
  var vars = [Termops$ReactTemplate.collect_vars(sigma$1, c$1)];
  var subst = [/* [] */0];
  var find_next_evar = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma$1, c);
    if (match.tag === 3) {
      var t = Evarutil$ReactTemplate.nf_evar(sigma$1, EConstr$ReactTemplate.existential_type(sigma$1, match[0]));
      var t$1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, c) {
              return Termops$ReactTemplate.replace_term(sigma$1, param[0], param[1], c);
            }), subst[0], t);
      if (!EConstr$ReactTemplate.Vars[/* closed0 */15](sigma$1, c)) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Hints with holes dependent on a bound variable not supported."));
      }
      if (Termops$ReactTemplate.occur_existential(sigma$1, t$1)) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not clever enough to deal with evars dependent in other evars."));
      }
      throw [
            Found,
            c,
            t$1
          ];
    } else {
      return EConstr$ReactTemplate.iter(sigma$1, find_next_evar, c);
    }
  };
  var iter = function (c) {
    try {
      find_next_evar(c);
      return c;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Found) {
        var evar = exn[1];
        var id = Namegen$ReactTemplate.next_ident_away_from(default_prepare_hint_ident, (function (id) {
                return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, vars[0]);
              }));
        vars[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, vars[0]);
        subst[0] = /* :: */[
          /* tuple */[
            evar,
            EConstr$ReactTemplate.mkVar(id)
          ],
          subst[0]
        ];
        return EConstr$ReactTemplate.mkNamedLambda(id, exn[2], iter(Termops$ReactTemplate.replace_term(sigma$1, evar, EConstr$ReactTemplate.mkVar(id), c)));
      } else {
        throw exn;
      }
    }
  };
  var c$prime = iter(c$1);
  if (check) {
    Pretyping$ReactTemplate.check_evars(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, sigma$1, c$prime);
  }
  var diff = Univ$ReactTemplate.ContextSet[/* diff */8](Evd$ReactTemplate.universe_context_set(sigma$1), Evd$ReactTemplate.universe_context_set(init));
  if (param[0]) {
    return /* IsConstr */Block.__(1, [
              c$prime,
              diff
            ]);
  } else if (param[1]) {
    return /* IsConstr */Block.__(1, [
              c$prime,
              diff
            ]);
  } else {
    Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(input_context_set, diff));
    return /* IsConstr */Block.__(1, [
              c$prime,
              Univ$ReactTemplate.ContextSet[/* empty */0]
            ]);
  }
}

function interp_hints(poly, h) {
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_env(env);
  var f = function (poly, c) {
    var match = Constrintern$ReactTemplate.interp_open_constr(env, sigma, c);
    return prepare_hint(/* true */1, /* tuple */[
                poly,
                /* false */0
              ], Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, /* tuple */[
                match[0],
                match[1]
              ]);
  };
  var fr = function (r) {
    return Tacred$ReactTemplate.evaluable_of_global_reference(env, Curry._2(Smartlocate$ReactTemplate.global_with_alias, /* None */0, r));
  };
  var fi = function (c) {
    if (c.tag) {
      return /* tuple */[
              /* PathAny */0,
              poly,
              f(poly, c[0])
            ];
    } else {
      var gr = Curry._2(Smartlocate$ReactTemplate.global_with_alias, /* None */0, c[0]);
      return /* tuple */[
              /* PathHints */[/* :: */[
                  gr,
                  /* [] */0
                ]],
              poly,
              /* IsGlobRef */Block.__(0, [gr])
            ];
    }
  };
  var fp = function (param, param$1, param$2) {
    return Constrintern$ReactTemplate.intern_constr_pattern(env, sigma, param, param$1, param$2);
  };
  var fres = function (param) {
    var info = param[0];
    var match = fi(param[2]);
    var info_000 = /* hint_priority */info[/* hint_priority */0];
    var info_001 = /* hint_pattern */Option$ReactTemplate.map((function (eta) {
            return fp(/* None */0, /* None */0, eta);
          }), info[/* hint_pattern */1]);
    var info$1 = /* record */[
      info_000,
      info_001
    ];
    return /* tuple */[
            info$1,
            match[1],
            param[1],
            match[0],
            match[2]
          ];
  };
  switch (h.tag | 0) {
    case 0 : 
        return /* HintsResolveEntry */Block.__(0, [Curry._2(Util$ReactTemplate.List[/* map */10], fres, h[0])]);
    case 1 : 
        return /* HintsImmediateEntry */Block.__(1, [Curry._2(Util$ReactTemplate.List[/* map */10], fi, h[0])]);
    case 2 : 
        return /* HintsUnfoldEntry */Block.__(3, [Curry._2(Util$ReactTemplate.List[/* map */10], fr, h[0])]);
    case 3 : 
        return /* HintsTransparencyEntry */Block.__(4, [
                  Curry._2(Util$ReactTemplate.List[/* map */10], fr, h[0]),
                  h[1]
                ]);
    case 4 : 
        return /* HintsModeEntry */Block.__(5, [
                  Curry._2(Smartlocate$ReactTemplate.global_with_alias, /* None */0, h[0]),
                  h[1]
                ]);
    case 5 : 
        var constr_hints_of_ind = function (qid) {
          var ind = Curry._1(Smartlocate$ReactTemplate.global_inductive_with_alias, qid);
          var match = Global$ReactTemplate.lookup_inductive(ind);
          var mib = match[0];
          return Curry._2(Util$ReactTemplate.List[/* init */46], Inductiveops$ReactTemplate.nconstructors(ind), (function (i) {
                        var c_001 = i + 1 | 0;
                        var c = /* tuple */[
                          ind,
                          c_001
                        ];
                        var gr = /* ConstructRef */Block.__(3, [c]);
                        return /* tuple */[
                                empty_hint_info,
                                Declareops$ReactTemplate.inductive_is_polymorphic(mib),
                                /* true */1,
                                /* PathHints */[/* :: */[
                                    gr,
                                    /* [] */0
                                  ]],
                                /* IsGlobRef */Block.__(0, [gr])
                              ];
                      }));
        };
        return /* HintsResolveEntry */Block.__(0, [Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], constr_hints_of_ind, h[0]))]);
    case 6 : 
        var pat = Option$ReactTemplate.map((function (eta) {
                return fp(/* None */0, /* None */0, eta);
              }), h[1]);
        var l = pat ? pat[0][0] : /* [] */0;
        var ltacvars = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (accu, x) {
                return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], x, accu);
              }), Names$ReactTemplate.Id[/* Set */9][/* empty */0], l);
        var init = Genintern$ReactTemplate.empty_glob_sign(env);
        var env_001 = /* genv */init[/* genv */1];
        var env_002 = /* extra */init[/* extra */2];
        var env$1 = /* record */[
          /* ltacvars */ltacvars,
          env_001,
          env_002
        ];
        var match = Genintern$ReactTemplate.generic_intern(env$1, h[2]);
        return /* HintsExternEntry */Block.__(6, [
                  /* record */[
                    /* hint_priority : Some */[h[0]],
                    /* hint_pattern */pat
                  ],
                  match[1]
                ]);
    
  }
}

function add_hints(local, dbnames0, h) {
  if (Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem */1], "nocore", dbnames0)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("The hint database \"nocore\" is meant to stay empty."));
  }
  var dbnames = Curry._1(Util$ReactTemplate.List[/* is_empty */45], dbnames0) ? /* :: */[
      "core",
      /* [] */0
    ] : dbnames0;
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_env(env);
  switch (h.tag | 0) {
    case 0 : 
        var env$1 = env;
        var sigma$1 = sigma;
        var clist = h[0];
        var local$1 = local;
        var dbnames$1 = dbnames;
        return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (dbname) {
                      var r = Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                  return make_resolves(env$1, sigma$1, /* tuple */[
                                              /* true */1,
                                              param[2],
                                              1 - Flags$ReactTemplate.quiet[0]
                                            ], param[0], param[1], /* Some */[param[3]], param[4]);
                                }), clist));
                      var hint = make_hint(/* Some */[local$1], dbname, /* AddHints */Block.__(2, [r]));
                      return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inAutoHint, hint));
                    }), dbnames$1);
    case 1 : 
        var env$2 = env;
        var sigma$2 = sigma;
        var l = h[0];
        var local$2 = local;
        var dbnames$2 = dbnames;
        return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (dbname) {
                      var l$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                              var env$3 = env$2;
                              var sigma$3 = sigma$2;
                              var poly = param[1];
                              var $staropt$star = /* Some */[param[0]];
                              var r = param[2];
                              var name = $staropt$star ? $staropt$star[0] : /* PathAny */0;
                              var match = fresh_global_or_constr(env$3, sigma$3, poly, r);
                              var ctx = match[1];
                              var c = match[0];
                              var sigma$4 = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible, sigma$3, ctx);
                              var t = Tacred$ReactTemplate.hnf_constr(env$3, sigma$4, Typing$ReactTemplate.unsafe_type_of(env$3, sigma$4, c));
                              var hd = head_constr(sigma$4, t);
                              var ce = Clenv$ReactTemplate.mk_clenv_from_env(env$3, sigma$4, /* None */0, /* tuple */[
                                    c,
                                    t
                                  ]);
                              return /* tuple */[
                                      /* Some */[hd],
                                      /* record */[
                                        /* pri */1,
                                        /* poly */poly,
                                        /* pat : Some */[Patternops$ReactTemplate.pattern_of_constr(env$3, ce[/* evd */1], EConstr$ReactTemplate.to_constr(sigma$4, Clenv$ReactTemplate.clenv_type(ce)))],
                                        /* name */name,
                                        /* db : None */0,
                                        /* secvars */secvars_of_constr(env$3, sigma$4, c),
                                        /* code : record */[
                                          /* obj : Res_pf_THEN_trivial_fail */Block.__(3, [/* tuple */[
                                                c,
                                                t,
                                                ctx
                                              ]]),
                                          /* uid */fresh_key(/* () */0)
                                        ]
                                      ]
                                    ];
                            }), l);
                      var hint = make_hint(/* Some */[local$2], dbname, /* AddHints */Block.__(2, [l$1]));
                      return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inAutoHint, hint));
                    }), dbnames$2);
    case 2 : 
        var l$1 = h[0];
        var local$3 = local;
        var dbnames$3 = dbnames;
        return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (dbname) {
                      var hint = make_hint(/* Some */[local$3], dbname, /* AddCut */Block.__(4, [l$1]));
                      return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inAutoHint, hint));
                    }), dbnames$3);
    case 3 : 
        var l$2 = h[0];
        var local$4 = local;
        var dbnames$4 = dbnames;
        return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (dbname) {
                      var hint = make_hint(/* Some */[local$4], dbname, /* AddHints */Block.__(2, [Curry._2(Util$ReactTemplate.List[/* map */10], make_unfold, l$2)]));
                      return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inAutoHint, hint));
                    }), dbnames$4);
    case 4 : 
        var l$3 = h[0];
        var b = h[1];
        var local$5 = local;
        var dbnames$5 = dbnames;
        return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (dbname) {
                      var hint = make_hint(/* Some */[local$5], dbname, /* AddTransparency */Block.__(1, [
                              l$3,
                              b
                            ]));
                      return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inAutoHint, hint));
                    }), dbnames$5);
    case 5 : 
        var l$4 = h[0];
        var m = h[1];
        var local$6 = local;
        var dbnames$6 = dbnames;
        return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (dbname) {
                      var m$prime = make_mode(l$4, m);
                      var hint = make_hint(/* Some */[local$6], dbname, /* AddMode */Block.__(5, [
                              l$4,
                              m$prime
                            ]));
                      return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inAutoHint, hint));
                    }), dbnames$6);
    case 6 : 
        var info = h[0];
        var tacast = h[1];
        var local$7 = local;
        var dbnames$7 = dbnames;
        return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                      var info$1 = info;
                      var tacast$1 = tacast;
                      var local$8 = local$7;
                      var dbname = param;
                      var match = info$1[/* hint_pattern */1];
                      var pat = match ? /* Some */[match[0][1]] : /* None */0;
                      var hint = make_hint(/* Some */[local$8], dbname, /* AddHints */Block.__(2, [/* :: */[
                                make_extern(Option$ReactTemplate.get(info$1[/* hint_priority */0]), pat, tacast$1),
                                /* [] */0
                              ]]));
                      return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inAutoHint, hint));
                    }), dbnames$7);
    
  }
}

function expand_constructor_hints(env, sigma, lems) {
  return Curry._2(Util$ReactTemplate.List[/* map_append */113], (function (param) {
                var lem = param[1];
                var evd = param[0];
                var match = EConstr$ReactTemplate.kind(sigma, lem);
                if (match.tag === 11) {
                  var match$1 = match[0];
                  var u = match$1[1];
                  var ind = match$1[0];
                  return Curry._2(Util$ReactTemplate.List[/* init */46], Inductiveops$ReactTemplate.nconstructors(ind), (function (i) {
                                var ctx = Univ$ReactTemplate.ContextSet[/* diff */8](Evd$ReactTemplate.universe_context_set(evd), Evd$ReactTemplate.universe_context_set(sigma));
                                return /* tuple */[
                                        1 - Univ$ReactTemplate.ContextSet[/* is_empty */1](ctx),
                                        /* IsConstr */Block.__(1, [
                                            EConstr$ReactTemplate.mkConstructU(/* tuple */[
                                                  /* tuple */[
                                                    ind,
                                                    i + 1 | 0
                                                  ],
                                                  u
                                                ]),
                                            ctx
                                          ])
                                      ];
                              }));
                } else {
                  var match$2 = prepare_hint(/* false */0, /* tuple */[
                        /* false */0,
                        /* true */1
                      ], env, sigma, /* tuple */[
                        evd,
                        lem
                      ]);
                  var tmp;
                  if (match$2.tag) {
                    var ctx = match$2[1];
                    tmp = /* tuple */[
                      1 - Univ$ReactTemplate.ContextSet[/* is_empty */1](ctx),
                      /* IsConstr */Block.__(1, [
                          match$2[0],
                          ctx
                        ])
                    ];
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "hints.ml",
                            1356,
                            18
                          ]
                        ];
                  }
                  return /* :: */[
                          tmp,
                          /* [] */0
                        ];
                }
              }), lems);
}

function make_local_hint_db(env, sigma, ts, eapply, lems) {
  var env$1 = env;
  var sigma$1 = sigma;
  var ts$1 = ts;
  var eapply$1 = eapply;
  var lems$1 = lems;
  var map = function (c) {
    return Curry._2(c, env$1, sigma$1);
  };
  var lems$2 = Curry._2(Util$ReactTemplate.List[/* map */10], map, lems$1);
  var sign = EConstr$ReactTemplate.named_context(env$1);
  var ts$2 = ts$1 ? ts$1[0] : searchtable_map("core")[/* hintdb_state */0];
  var hintlist = Curry._2(Util$ReactTemplate.List[/* map_append */113], (function (param) {
          return make_resolve_hyp(env$1, sigma$1, param);
        }), sign);
  var env$2 = env$1;
  var sigma$2 = sigma$1;
  var eapply$2 = eapply$1;
  var lems$3 = lems$2;
  var hint_db = add_list(env$1, sigma$1, hintlist, empty(/* None */0, ts$2, /* false */0));
  var lems$4 = expand_constructor_hints(env$2, sigma$2, lems$3);
  var hintlist$prime = Curry._2(Util$ReactTemplate.List[/* map_append */113], (function (param) {
          return make_resolves(env$2, sigma$2, /* tuple */[
                      eapply$2,
                      /* true */1,
                      /* false */0
                    ], empty_hint_info, param[0], /* None */0, param[1]);
        }), lems$4);
  return add_list(env$2, sigma$2, hintlist$prime, hint_db);
}

function make_db_list(dbnames) {
  var use_core = 1 - Curry._2(Util$ReactTemplate.List[/* mem */24], "nocore", dbnames);
  var dbnames$1 = Curry._3(Util$ReactTemplate.List[/* remove */88], (function (prim, prim$1) {
          return +(prim === prim$1);
        }), "nocore", dbnames);
  var dbnames$2 = use_core ? /* :: */[
      "core",
      dbnames$1
    ] : dbnames$1;
  var lookup = function (db) {
    try {
      return searchtable_map(db);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return error_no_such_hint_database(db);
      } else {
        throw exn;
      }
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* map */10], lookup, dbnames$2);
}

function pr_hint_elt(env, sigma, param) {
  return Printer$ReactTemplate.pr_econstr_env(env, sigma, param[0]);
}

function pr_hint(env, sigma, h) {
  var match = h[/* obj */0];
  switch (match.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("simple apply "), pr_hint_elt(env, sigma, match[0][0]));
    case 1 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("simple eapply "), pr_hint_elt(env, sigma, match[0][0]));
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("exact "), pr_hint_elt(env, sigma, match[0][0]));
    case 3 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("simple apply "), pr_hint_elt(env, sigma, match[0][0])), Pp$ReactTemplate.str(" ; trivial"));
    case 4 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("unfold "), Printer$ReactTemplate.pr_evaluable_reference(match[0]));
    case 5 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("(*external*) "), Pputils$ReactTemplate.pr_glb_generic(env, match[0]));
    
  }
}

function pr_hint_list(env, sigma, hintlist) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("  "), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist((function (param) {
                            var env$1 = env;
                            var sigma$1 = sigma;
                            var param$1 = param;
                            var v = param$1[1];
                            var pr_pat = function (p) {
                              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(", pattern "), Printer$ReactTemplate.pr_lconstr_pattern_env(env$1, sigma$1, p));
                            };
                            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_hint(env$1, sigma$1, v[/* code */6]), Pp$ReactTemplate.str("(level ")), Pp$ReactTemplate.$$int(v[/* pri */0])), Pp$ReactTemplate.pr_opt_no_spc(pr_pat, v[/* pat */2])), Pp$ReactTemplate.str(", id ")), Pp$ReactTemplate.$$int(param$1[0])), Pp$ReactTemplate.str(")")), Pp$ReactTemplate.spc(/* () */0));
                          }), hintlist))), Pp$ReactTemplate.fnl(/* () */0));
}

function pr_hints_db(env, sigma, param) {
  var hintlist = param[2];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("In the database "), Pp$ReactTemplate.str(param[0])), Pp$ReactTemplate.str(":")), Curry._1(Util$ReactTemplate.List[/* is_empty */45], hintlist) ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" nothing"), Pp$ReactTemplate.fnl(/* () */0)) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), pr_hint_list(env, sigma, hintlist)));
}

function pr_hint_ref(ref) {
  return (function (param, param$1) {
      var env = ref;
      var sigma = param;
      var c = param$1;
      var dbs = current_db(/* () */0);
      var validate = function (param) {
        var db = param[1];
        var hints = Curry._2(Util$ReactTemplate.List[/* map */10], (function (v) {
                return /* tuple */[
                        0,
                        v
                      ];
              }), map_all(Names$ReactTemplate.Id[/* Pred */11][/* full */1], c, db));
        return /* tuple */[
                param[0],
                db,
                hints
              ];
      };
      var valid_dbs = Curry._2(Util$ReactTemplate.List[/* map */10], validate, dbs);
      if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], valid_dbs)) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("No hint declared for :"), Printer$ReactTemplate.pr_global(c));
      } else {
        return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("For "), Printer$ReactTemplate.pr_global(c)), Pp$ReactTemplate.str(" -> ")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist((function (param) {
                                  return pr_hints_db(env, sigma, param);
                                }), valid_dbs))));
      }
    });
}

function pr_applicable_hint() {
  var env = Global$ReactTemplate.env(/* () */0);
  var pts = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
  var match = Proof$ReactTemplate.proof(pts);
  var sigma = match[4];
  var glss = match[0];
  if (glss) {
    var env$1 = env;
    var sigma$1 = sigma;
    var cl = Goal$ReactTemplate.V82[/* concl */3](sigma, glss[0]);
    try {
      var dbs = current_db(/* () */0);
      var fn;
      try {
        var hdc = decompose_app_bound(sigma$1, cl);
        if (Termops$ReactTemplate.occur_existential(sigma$1, cl)) {
          var partial_arg = Names$ReactTemplate.Id[/* Pred */11][/* full */1];
          fn = (function (param) {
              return map_existential(sigma$1, partial_arg, hdc, cl, param);
            });
        } else {
          var partial_arg$1 = Names$ReactTemplate.Id[/* Pred */11][/* full */1];
          fn = (function (param) {
              return map_auto(sigma$1, partial_arg$1, hdc, cl, param);
            });
        }
      }
      catch (exn){
        if (exn === Bound) {
          var partial_arg$2 = Names$ReactTemplate.Id[/* Pred */11][/* full */1];
          fn = (function (param) {
              return map_none(partial_arg$2, param);
            });
        } else {
          throw exn;
        }
      }
      var fn$1 = function (db) {
        return Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                      return /* tuple */[
                              0,
                              x
                            ];
                    }), Curry._1(fn, db));
      };
      var valid_dbs = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              var db = param[1];
              return /* tuple */[
                      param[0],
                      db,
                      fn$1(db)
                    ];
            }), dbs);
      if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], valid_dbs)) {
        return Pp$ReactTemplate.str("No hint applicable for current goal");
      } else {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Applicable Hints :"), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist((function (param) {
                              return pr_hints_db(env$1, sigma$1, param);
                            }), valid_dbs)));
      }
    }
    catch (raw_exn){
      var exn$1 = Js_exn.internalToOCamlException(raw_exn);
      if (exn$1[0] === Caml_builtin_exceptions.match_failure) {
        return Pp$ReactTemplate.str("No hint applicable for current goal");
      } else if (exn$1[0] === Caml_builtin_exceptions.failure) {
        return Pp$ReactTemplate.str("No hint applicable for current goal");
      } else {
        throw exn$1;
      }
    }
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No focused goal."));
  }
}

function pp_hint_mode(param) {
  switch (param) {
    case 0 : 
        return Pp$ReactTemplate.str("+");
    case 1 : 
        return Pp$ReactTemplate.str("!");
    case 2 : 
        return Pp$ReactTemplate.str("-");
    
  }
}

function pr_hint_db_env(env, sigma, db) {
  var pr_mode = function (param) {
    return Pp$ReactTemplate.prvect_with_sep(Pp$ReactTemplate.spc, pp_hint_mode, param);
  };
  var pr_modes = function (l) {
    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l)) {
      return Pp$ReactTemplate.mt(/* () */0);
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" (modes "), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, pr_mode, l)), Pp$ReactTemplate.str(")"));
    }
  };
  var fold$1 = function (head, modes, hintlist, accu) {
    var goal_descr = head ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("For "), Printer$ReactTemplate.pr_global(head[0])), pr_modes(modes)) : Pp$ReactTemplate.str("For any goal");
    var hints = pr_hint_list(env, sigma, Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                return /* tuple */[
                        0,
                        x
                      ];
              }), hintlist));
    var hint_descr = Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(goal_descr, Pp$ReactTemplate.str(" -> ")), hints));
    return Pp$ReactTemplate.$plus$plus(accu, hint_descr);
  };
  var content = fold(fold$1, db, Pp$ReactTemplate.mt(/* () */0));
  var match = db[/* hintdb_state */0];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, db[/* use_dn */4] ? Pp$ReactTemplate.str("Discriminated database") : Pp$ReactTemplate.str("Non-discriminated database")), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unfoldable variable definitions: "), Printer$ReactTemplate.pr_idpred(match[0])))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unfoldable constant definitions: "), Printer$ReactTemplate.pr_cpred(match[1])))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cut: "), pp_hints_path(db[/* hintdb_cut */1])))), Pp$ReactTemplate.fnl(/* () */0)), content);
}

function pr_hint_db(db) {
  var match = Pfedit$ReactTemplate.get_current_context(/* () */0);
  return pr_hint_db_env(match[1], match[0], db);
}

function pr_hint_db_by_name(env, sigma, dbname) {
  try {
    var db = searchtable_map(dbname);
    return pr_hint_db_env(env, sigma, db);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return error_no_such_hint_database(dbname);
    } else {
      throw exn;
    }
  }
}

function pr_searchtable(env, sigma) {
  var fold = function (name, db, accu) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(accu, Pp$ReactTemplate.str("In the database ")), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.fnl(/* () */0)), pr_hint_db_env(env, sigma, db)), Pp$ReactTemplate.fnl(/* () */0));
  };
  return Curry._3(Util$ReactTemplate.$$String[/* Map */39][/* fold */10], fold, searchtable[0], Pp$ReactTemplate.mt(/* () */0));
}

function print_mp(mp) {
  try {
    var qid = Nametab$ReactTemplate.shortest_qualid_of_module(mp);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" from "), Libnames$ReactTemplate.pr_qualid(qid));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Pp$ReactTemplate.mt(/* () */0);
    } else {
      throw exn;
    }
  }
}

function is_imported(h) {
  try {
    return Curry._2(Names$ReactTemplate.KNmap[/* find */21], h[/* uid */1], statustable[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

var warn_non_imported_hint = CWarnings$ReactTemplate.create("non-imported-hint", "automation", /* None */0, (function (param) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Hint used but not imported: "), param[0]), print_mp(param[1]));
      }));

function run_hint(tac, k) {
  var match = warn_hint[0];
  if (match !== 3793987) {
    if (match >= 968043078) {
      if (is_imported(tac)) {
        return Curry._1(k, tac[/* obj */0]);
      } else {
        return Curry._2(Proofview$ReactTemplate.tclBIND, Curry._1(k, tac[/* obj */0]), (function (x) {
                      var h = tac;
                      var x$1 = x;
                      return Curry._2(Proofview$ReactTemplate.tclBIND, Proofview$ReactTemplate.tclENV, (function (env) {
                                    return Curry._2(Proofview$ReactTemplate.tclBIND, Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                                                  var hint = pr_hint(env, sigma, h);
                                                  var match = Names$ReactTemplate.KerName[/* repr */2](h[/* uid */1]);
                                                  Curry._2(warn_non_imported_hint, /* None */0, /* tuple */[
                                                        hint,
                                                        match[0]
                                                      ]);
                                                  return Curry._1(Proofview$ReactTemplate.tclUNIT, x$1);
                                                }));
                                  }));
                    }));
      }
    } else if (is_imported(tac)) {
      return Curry._1(k, tac[/* obj */0]);
    } else {
      return Proofview$ReactTemplate.tclZERO(/* None */0, [
                  CErrors$ReactTemplate.UserError,
                  /* None */0,
                  Pp$ReactTemplate.str("Tactic failure.")
                ]);
    }
  } else {
    return Curry._1(k, tac[/* obj */0]);
  }
}

function repr_hint(h) {
  return h[/* obj */0];
}

var glob_hints_path = aux;

var Hint_db = [
  empty,
  find,
  map_none,
  map_all,
  map_existential,
  map_eauto,
  map_auto,
  add_one,
  add_list,
  remove_one,
  remove_list,
  iter,
  use_dn,
  transparent_state,
  set_transparent_state,
  add_cut,
  cut,
  unfolds
];

exports.Bound = Bound;
exports.decompose_app_bound = decompose_app_bound;
exports.secvars_of_hyps = secvars_of_hyps;
exports.empty_hint_info = empty_hint_info;
exports.normalize_path = normalize_path;
exports.path_matches = path_matches;
exports.path_derivate = path_derivate$1;
exports.pp_hints_path_gen = pp_hints_path_gen;
exports.pp_hints_path_atom = pp_hints_path_atom;
exports.pp_hints_path = pp_hints_path;
exports.pp_hint_mode = pp_hint_mode;
exports.glob_hints_path_atom = glob_hints_path_atom;
exports.glob_hints_path = glob_hints_path;
exports.Hint_db = Hint_db;
exports.searchtable_map = searchtable_map;
exports.searchtable_add = searchtable_add;
exports.create_hint_db = create_hint_db;
exports.remove_hints = remove_hints;
exports.current_db_names = current_db_names;
exports.current_pure_db = current_pure_db;
exports.interp_hints = interp_hints;
exports.add_hints = add_hints;
exports.prepare_hint = prepare_hint;
exports.make_exact_entry = make_exact_entry;
exports.make_apply_entry = make_apply_entry;
exports.make_resolves = make_resolves;
exports.make_resolve_hyp = make_resolve_hyp;
exports.make_extern = make_extern;
exports.run_hint = run_hint;
exports.repr_hint = repr_hint;
exports.make_local_hint_db = make_local_hint_db;
exports.make_db_list = make_db_list;
exports.typeclasses_db = typeclasses_db;
exports.rewrite_db = rewrite_db;
exports.pr_searchtable = pr_searchtable;
exports.pr_applicable_hint = pr_applicable_hint;
exports.pr_hint_ref = pr_hint_ref;
exports.pr_hint_db_by_name = pr_hint_db_by_name;
exports.pr_hint_db_env = pr_hint_db_env;
exports.pr_hint_db = pr_hint_db;
exports.pr_hint = pr_hint;
exports.add_hints_init = add_hints_init;
/*  Not a pure module */
