// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("../src/globnames.bs.js");

function make_dir(l) {
  return Names$ReactTemplate.DirPath[/* make */3](Curry._2(Util$ReactTemplate.List[/* rev_map */12], Names$ReactTemplate.Id[/* of_string */5], l));
}

function find_reference(locstr, dir, s) {
  var dp = make_dir(dir);
  var sp = Libnames$ReactTemplate.make_path(dp, Names$ReactTemplate.Id[/* of_string */5](s));
  try {
    return Nametab$ReactTemplate.global_of_path(sp);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* Some */[locstr], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("cannot find "), Libnames$ReactTemplate.pr_path(sp)), Pp$ReactTemplate.str("; maybe library ")), Names$ReactTemplate.DirPath[/* print */10](dp)), Pp$ReactTemplate.str(" has to be required first.")));
    } else {
      throw exn;
    }
  }
}

function coq_reference(locstr, dir, s) {
  return find_reference(locstr, /* :: */[
              Libnames$ReactTemplate.coq_string,
              dir
            ], s);
}

function gen_reference_in_modules(locstr, dirs, s) {
  var dirs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], make_dir, dirs);
  var qualid = Libnames$ReactTemplate.qualid_of_string(s);
  var all = Nametab$ReactTemplate.locate_all(qualid);
  var all$1 = Curry._2(Util$ReactTemplate.List[/* sort_uniquize */96], Globnames$ReactTemplate.RefOrdered_env[/* compare */0], all);
  var these = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
          var dirs$2 = dirs$1;
          var ref = param;
          var dir = Libnames$ReactTemplate.dirpath(Nametab$ReactTemplate.path_of_global(ref));
          return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (d) {
                        return Libnames$ReactTemplate.is_dirpath_prefix_of(d, dir);
                      }), dirs$2);
        }), all$1);
  if (these) {
    if (these[1]) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */[locstr], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("ambiguous name "), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str(" can represent ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, (function (x) {
                                            return Libnames$ReactTemplate.pr_path(Nametab$ReactTemplate.path_of_global(x));
                                          }), these)), Pp$ReactTemplate.str(" in module")), Pp$ReactTemplate.str(Curry._1(Util$ReactTemplate.List[/* length */0], dirs$1) > 1 ? "s " : " ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Names$ReactTemplate.DirPath[/* print */10], dirs$1)), Pp$ReactTemplate.str(".")));
    } else {
      return these[0];
    }
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */[locstr], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("cannot find "), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str(" in module")), Pp$ReactTemplate.str(Curry._1(Util$ReactTemplate.List[/* length */0], dirs$1) > 1 ? "s " : " ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Names$ReactTemplate.DirPath[/* print */10], dirs$1)), Pp$ReactTemplate.str(".")));
  }
}

function check_required_library(d) {
  var dir = make_dir(d);
  var match = Lib$ReactTemplate.current_mp(/* () */0);
  var in_current_dir;
  switch (match.tag | 0) {
    case 0 : 
        in_current_dir = Curry._2(Names$ReactTemplate.DirPath[/* equal */0], dir, match[0]);
        break;
    case 1 : 
    case 2 : 
        in_current_dir = /* false */0;
        break;
    
  }
  if (in_current_dir) {
    return 0;
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Coqlib.check_required_library"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Library "), Names$ReactTemplate.DirPath[/* print */10](dir)), Pp$ReactTemplate.str(" has to be required first.")));
  }
}

function init_reference(dir, s) {
  var d_001 = /* :: */[
    "Init",
    dir
  ];
  var d = /* :: */[
    Libnames$ReactTemplate.coq_string,
    d_001
  ];
  check_required_library(d);
  return find_reference("Coqlib", d, s);
}

function logic_reference(dir, s) {
  var d_001 = /* :: */[
    "Logic",
    dir
  ];
  var d = /* :: */[
    Libnames$ReactTemplate.coq_string,
    d_001
  ];
  check_required_library(d);
  return find_reference("Coqlib", d, s);
}

var arith_dir_001 = /* :: */[
  "Arith",
  /* [] */0
];

var arith_dir = /* :: */[
  Libnames$ReactTemplate.coq_string,
  arith_dir_001
];

var arith_modules = /* :: */[
  arith_dir,
  /* [] */0
];

var numbers_dir_001 = /* :: */[
  "Numbers",
  /* [] */0
];

var numbers_dir = /* :: */[
  Libnames$ReactTemplate.coq_string,
  numbers_dir_001
];

var parith_dir_001 = /* :: */[
  "PArith",
  /* [] */0
];

var parith_dir = /* :: */[
  Libnames$ReactTemplate.coq_string,
  parith_dir_001
];

var narith_dir_001 = /* :: */[
  "NArith",
  /* [] */0
];

var narith_dir = /* :: */[
  Libnames$ReactTemplate.coq_string,
  narith_dir_001
];

var zarith_dir_001 = /* :: */[
  "ZArith",
  /* [] */0
];

var zarith_dir = /* :: */[
  Libnames$ReactTemplate.coq_string,
  zarith_dir_001
];

var zarith_base_modules_001 = /* :: */[
  parith_dir,
  /* :: */[
    narith_dir,
    /* :: */[
      zarith_dir,
      /* [] */0
    ]
  ]
];

var zarith_base_modules = /* :: */[
  numbers_dir,
  zarith_base_modules_001
];

var init_dir_001 = /* :: */[
  "Init",
  /* [] */0
];

var init_dir = /* :: */[
  Libnames$ReactTemplate.coq_string,
  init_dir_001
];

var init_modules_000 = Util$ReactTemplate.$at(init_dir, /* :: */[
      "Datatypes",
      /* [] */0
    ]);

var init_modules_001 = /* :: */[
  Util$ReactTemplate.$at(init_dir, /* :: */[
        "Logic",
        /* [] */0
      ]),
  /* :: */[
    Util$ReactTemplate.$at(init_dir, /* :: */[
          "Specif",
          /* [] */0
        ]),
    /* :: */[
      Util$ReactTemplate.$at(init_dir, /* :: */[
            "Logic_Type",
            /* [] */0
          ]),
      /* :: */[
        Util$ReactTemplate.$at(init_dir, /* :: */[
              "Nat",
              /* [] */0
            ]),
        /* :: */[
          Util$ReactTemplate.$at(init_dir, /* :: */[
                "Peano",
                /* [] */0
              ]),
          /* :: */[
            Util$ReactTemplate.$at(init_dir, /* :: */[
                  "Wf",
                  /* [] */0
                ]),
            /* [] */0
          ]
        ]
      ]
    ]
  ]
];

var init_modules = /* :: */[
  init_modules_000,
  init_modules_001
];

var prelude_module_name = Util$ReactTemplate.$at(init_dir, /* :: */[
      "Prelude",
      /* [] */0
    ]);

var prelude_module = make_dir(prelude_module_name);

var logic_module_name = Util$ReactTemplate.$at(init_dir, /* :: */[
      "Logic",
      /* [] */0
    ]);

var logic_module = make_dir(logic_module_name);

var logic_type_module_name = Util$ReactTemplate.$at(init_dir, /* :: */[
      "Logic_Type",
      /* [] */0
    ]);

var logic_type_module = make_dir(logic_type_module_name);

var datatypes_module_name = Util$ReactTemplate.$at(init_dir, /* :: */[
      "Datatypes",
      /* [] */0
    ]);

var datatypes_module = make_dir(datatypes_module_name);

var jmeq_module_name_001 = /* :: */[
  "Logic",
  /* :: */[
    "JMeq",
    /* [] */0
  ]
];

var jmeq_module_name = /* :: */[
  Libnames$ReactTemplate.coq_string,
  jmeq_module_name_001
];

var jmeq_module = make_dir(jmeq_module_name);

function make_ind(dir, id) {
  return Globnames$ReactTemplate.encode_mind(dir, Names$ReactTemplate.Id[/* of_string */5](id));
}

function make_con(dir, id) {
  return Globnames$ReactTemplate.encode_con(dir, Names$ReactTemplate.Id[/* of_string */5](id));
}

var id = make_con(datatypes_module, "idProp");

var type_of_id = make_con(datatypes_module, "IDProp");

var nat_kn = make_ind(datatypes_module, "nat");

var nat_path = Libnames$ReactTemplate.make_path(datatypes_module, Names$ReactTemplate.Id[/* of_string */5]("nat"));

var glob_nat = /* IndRef */Block.__(2, [/* tuple */[
      nat_kn,
      0
    ]]);

var path_of_O_000 = /* tuple */[
  nat_kn,
  0
];

var path_of_O = /* tuple */[
  path_of_O_000,
  1
];

var path_of_S_000 = /* tuple */[
  nat_kn,
  0
];

var path_of_S = /* tuple */[
  path_of_S_000,
  2
];

var glob_O = /* ConstructRef */Block.__(3, [path_of_O]);

var glob_S = /* ConstructRef */Block.__(3, [path_of_S]);

var bool_kn = make_ind(datatypes_module, "bool");

var glob_bool = /* IndRef */Block.__(2, [/* tuple */[
      bool_kn,
      0
    ]]);

var path_of_true_000 = /* tuple */[
  bool_kn,
  0
];

var path_of_true = /* tuple */[
  path_of_true_000,
  1
];

var path_of_false_000 = /* tuple */[
  bool_kn,
  0
];

var path_of_false = /* tuple */[
  path_of_false_000,
  2
];

var glob_true = /* ConstructRef */Block.__(3, [path_of_true]);

var glob_false = /* ConstructRef */Block.__(3, [path_of_false]);

var eq_kn = make_ind(logic_module, "eq");

var glob_eq = /* IndRef */Block.__(2, [/* tuple */[
      eq_kn,
      0
    ]]);

var identity_kn = make_ind(datatypes_module, "identity");

var glob_identity = /* IndRef */Block.__(2, [/* tuple */[
      identity_kn,
      0
    ]]);

var jmeq_kn = make_ind(jmeq_module, "JMeq");

var glob_jmeq = /* IndRef */Block.__(2, [/* tuple */[
      jmeq_kn,
      0
    ]]);

function build_bool_type() {
  return /* record */[
          /* andb */init_reference(/* :: */[
                "Datatypes",
                /* [] */0
              ], "andb"),
          /* andb_prop */init_reference(/* :: */[
                "Datatypes",
                /* [] */0
              ], "andb_prop"),
          /* andb_true_intro */init_reference(/* :: */[
                "Datatypes",
                /* [] */0
              ], "andb_true_intro")
        ];
}

function build_sigma_set() {
  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Use build_sigma_type."));
}

function build_sigma_type() {
  return /* record */[
          /* proj1 */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "projT1"),
          /* proj2 */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "projT2"),
          /* elim */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "sigT_rect"),
          /* intro */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "existT"),
          /* typ */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "sigT")
        ];
}

function build_sigma() {
  return /* record */[
          /* proj1 */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "proj1_sig"),
          /* proj2 */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "proj2_sig"),
          /* elim */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "sig_rect"),
          /* intro */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "exist"),
          /* typ */init_reference(/* :: */[
                "Specif",
                /* [] */0
              ], "sig")
        ];
}

function build_prod() {
  return /* record */[
          /* proj1 */init_reference(/* :: */[
                "Datatypes",
                /* [] */0
              ], "fst"),
          /* proj2 */init_reference(/* :: */[
                "Datatypes",
                /* [] */0
              ], "snd"),
          /* elim */init_reference(/* :: */[
                "Datatypes",
                /* [] */0
              ], "prod_rec"),
          /* intro */init_reference(/* :: */[
                "Datatypes",
                /* [] */0
              ], "pair"),
          /* typ */init_reference(/* :: */[
                "Datatypes",
                /* [] */0
              ], "prod")
        ];
}

var coq_eq_eq = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "eq");
      })]);

var coq_eq_refl = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "eq_refl");
      })]);

var coq_eq_ind = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "eq_ind");
      })]);

var coq_eq_congr = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "f_equal");
      })]);

var coq_eq_sym = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "eq_sym");
      })]);

var coq_eq_trans = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "eq_trans");
      })]);

var coq_f_equal2 = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "f_equal2");
      })]);

var coq_eq_congr_canonical = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "f_equal_canonical_form");
      })]);

function build_coq_eq_data() {
  check_required_library(logic_module_name);
  var tag = coq_eq_eq.tag | 0;
  var tag$1 = coq_eq_ind.tag | 0;
  var tag$2 = coq_eq_refl.tag | 0;
  var tag$3 = coq_eq_sym.tag | 0;
  var tag$4 = coq_eq_trans.tag | 0;
  var tag$5 = coq_eq_congr.tag | 0;
  return /* record */[
          /* eq */tag === 250 ? coq_eq_eq[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_eq) : coq_eq_eq
            ),
          /* ind */tag$1 === 250 ? coq_eq_ind[0] : (
              tag$1 === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_ind) : coq_eq_ind
            ),
          /* refl */tag$2 === 250 ? coq_eq_refl[0] : (
              tag$2 === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_refl) : coq_eq_refl
            ),
          /* sym */tag$3 === 250 ? coq_eq_sym[0] : (
              tag$3 === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_sym) : coq_eq_sym
            ),
          /* trans */tag$4 === 250 ? coq_eq_trans[0] : (
              tag$4 === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_trans) : coq_eq_trans
            ),
          /* congr */tag$5 === 250 ? coq_eq_congr[0] : (
              tag$5 === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_congr) : coq_eq_congr
            )
        ];
}

function build_coq_eq() {
  var tag = coq_eq_eq.tag | 0;
  if (tag === 250) {
    return coq_eq_eq[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_eq_eq);
  } else {
    return coq_eq_eq;
  }
}

function build_coq_eq_refl() {
  var tag = coq_eq_refl.tag | 0;
  if (tag === 250) {
    return coq_eq_refl[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_eq_refl);
  } else {
    return coq_eq_refl;
  }
}

function build_coq_eq_sym() {
  var tag = coq_eq_sym.tag | 0;
  if (tag === 250) {
    return coq_eq_sym[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_eq_sym);
  } else {
    return coq_eq_sym;
  }
}

function build_coq_f_equal2() {
  var tag = coq_f_equal2.tag | 0;
  if (tag === 250) {
    return coq_f_equal2[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_f_equal2);
  } else {
    return coq_f_equal2;
  }
}

function build_coq_inversion_eq_data() {
  check_required_library(logic_module_name);
  var tag = coq_eq_eq.tag | 0;
  var tag$1 = coq_eq_ind.tag | 0;
  var tag$2 = coq_eq_congr_canonical.tag | 0;
  return /* record */[
          /* inv_eq */tag === 250 ? coq_eq_eq[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_eq) : coq_eq_eq
            ),
          /* inv_ind */tag$1 === 250 ? coq_eq_ind[0] : (
              tag$1 === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_ind) : coq_eq_ind
            ),
          /* inv_congr */tag$2 === 250 ? coq_eq_congr_canonical[0] : (
              tag$2 === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_congr_canonical) : coq_eq_congr_canonical
            )
        ];
}

var coq_jmeq_eq = Block.__(246, [(function () {
        return logic_reference(/* :: */[
                    "JMeq",
                    /* [] */0
                  ], "JMeq");
      })]);

var coq_jmeq_hom = Block.__(246, [(function () {
        return logic_reference(/* :: */[
                    "JMeq",
                    /* [] */0
                  ], "JMeq_hom");
      })]);

var coq_jmeq_refl = Block.__(246, [(function () {
        return logic_reference(/* :: */[
                    "JMeq",
                    /* [] */0
                  ], "JMeq_refl");
      })]);

var coq_jmeq_ind = Block.__(246, [(function () {
        return logic_reference(/* :: */[
                    "JMeq",
                    /* [] */0
                  ], "JMeq_ind");
      })]);

var coq_jmeq_sym = Block.__(246, [(function () {
        return logic_reference(/* :: */[
                    "JMeq",
                    /* [] */0
                  ], "JMeq_sym");
      })]);

var coq_jmeq_congr = Block.__(246, [(function () {
        return logic_reference(/* :: */[
                    "JMeq",
                    /* [] */0
                  ], "JMeq_congr");
      })]);

var coq_jmeq_trans = Block.__(246, [(function () {
        return logic_reference(/* :: */[
                    "JMeq",
                    /* [] */0
                  ], "JMeq_trans");
      })]);

var coq_jmeq_congr_canonical = Block.__(246, [(function () {
        return logic_reference(/* :: */[
                    "JMeq",
                    /* [] */0
                  ], "JMeq_congr_canonical_form");
      })]);

function build_coq_jmeq_data() {
  check_required_library(jmeq_module_name);
  var tag = coq_jmeq_eq.tag | 0;
  var tag$1 = coq_jmeq_ind.tag | 0;
  var tag$2 = coq_jmeq_refl.tag | 0;
  var tag$3 = coq_jmeq_sym.tag | 0;
  var tag$4 = coq_jmeq_trans.tag | 0;
  var tag$5 = coq_jmeq_congr.tag | 0;
  return /* record */[
          /* eq */tag === 250 ? coq_jmeq_eq[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(coq_jmeq_eq) : coq_jmeq_eq
            ),
          /* ind */tag$1 === 250 ? coq_jmeq_ind[0] : (
              tag$1 === 246 ? CamlinternalLazy.force_lazy_block(coq_jmeq_ind) : coq_jmeq_ind
            ),
          /* refl */tag$2 === 250 ? coq_jmeq_refl[0] : (
              tag$2 === 246 ? CamlinternalLazy.force_lazy_block(coq_jmeq_refl) : coq_jmeq_refl
            ),
          /* sym */tag$3 === 250 ? coq_jmeq_sym[0] : (
              tag$3 === 246 ? CamlinternalLazy.force_lazy_block(coq_jmeq_sym) : coq_jmeq_sym
            ),
          /* trans */tag$4 === 250 ? coq_jmeq_trans[0] : (
              tag$4 === 246 ? CamlinternalLazy.force_lazy_block(coq_jmeq_trans) : coq_jmeq_trans
            ),
          /* congr */tag$5 === 250 ? coq_jmeq_congr[0] : (
              tag$5 === 246 ? CamlinternalLazy.force_lazy_block(coq_jmeq_congr) : coq_jmeq_congr
            )
        ];
}

function build_coq_inversion_jmeq_data() {
  check_required_library(logic_module_name);
  var tag = coq_jmeq_hom.tag | 0;
  var tag$1 = coq_jmeq_ind.tag | 0;
  var tag$2 = coq_jmeq_congr_canonical.tag | 0;
  return /* record */[
          /* inv_eq */tag === 250 ? coq_jmeq_hom[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(coq_jmeq_hom) : coq_jmeq_hom
            ),
          /* inv_ind */tag$1 === 250 ? coq_jmeq_ind[0] : (
              tag$1 === 246 ? CamlinternalLazy.force_lazy_block(coq_jmeq_ind) : coq_jmeq_ind
            ),
          /* inv_congr */tag$2 === 250 ? coq_jmeq_congr_canonical[0] : (
              tag$2 === 246 ? CamlinternalLazy.force_lazy_block(coq_jmeq_congr_canonical) : coq_jmeq_congr_canonical
            )
        ];
}

var coq_sumbool = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Specif",
                    /* [] */0
                  ], "sumbool");
      })]);

function build_coq_sumbool() {
  var tag = coq_sumbool.tag | 0;
  if (tag === 250) {
    return coq_sumbool[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_sumbool);
  } else {
    return coq_sumbool;
  }
}

var coq_identity_eq = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Datatypes",
                    /* [] */0
                  ], "identity");
      })]);

var coq_identity_refl = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Datatypes",
                    /* [] */0
                  ], "identity_refl");
      })]);

var coq_identity_ind = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Datatypes",
                    /* [] */0
                  ], "identity_ind");
      })]);

var coq_identity_congr = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic_Type",
                    /* [] */0
                  ], "identity_congr");
      })]);

var coq_identity_sym = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic_Type",
                    /* [] */0
                  ], "identity_sym");
      })]);

var coq_identity_trans = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic_Type",
                    /* [] */0
                  ], "identity_trans");
      })]);

var coq_identity_congr_canonical = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic_Type",
                    /* [] */0
                  ], "identity_congr_canonical_form");
      })]);

function build_coq_identity_data() {
  check_required_library(datatypes_module_name);
  var tag = coq_identity_eq.tag | 0;
  var tag$1 = coq_identity_ind.tag | 0;
  var tag$2 = coq_identity_refl.tag | 0;
  var tag$3 = coq_identity_sym.tag | 0;
  var tag$4 = coq_identity_trans.tag | 0;
  var tag$5 = coq_identity_congr.tag | 0;
  return /* record */[
          /* eq */tag === 250 ? coq_identity_eq[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(coq_identity_eq) : coq_identity_eq
            ),
          /* ind */tag$1 === 250 ? coq_identity_ind[0] : (
              tag$1 === 246 ? CamlinternalLazy.force_lazy_block(coq_identity_ind) : coq_identity_ind
            ),
          /* refl */tag$2 === 250 ? coq_identity_refl[0] : (
              tag$2 === 246 ? CamlinternalLazy.force_lazy_block(coq_identity_refl) : coq_identity_refl
            ),
          /* sym */tag$3 === 250 ? coq_identity_sym[0] : (
              tag$3 === 246 ? CamlinternalLazy.force_lazy_block(coq_identity_sym) : coq_identity_sym
            ),
          /* trans */tag$4 === 250 ? coq_identity_trans[0] : (
              tag$4 === 246 ? CamlinternalLazy.force_lazy_block(coq_identity_trans) : coq_identity_trans
            ),
          /* congr */tag$5 === 250 ? coq_identity_congr[0] : (
              tag$5 === 246 ? CamlinternalLazy.force_lazy_block(coq_identity_congr) : coq_identity_congr
            )
        ];
}

function build_coq_inversion_identity_data() {
  check_required_library(datatypes_module_name);
  check_required_library(logic_type_module_name);
  var tag = coq_identity_eq.tag | 0;
  var tag$1 = coq_identity_ind.tag | 0;
  var tag$2 = coq_identity_congr_canonical.tag | 0;
  return /* record */[
          /* inv_eq */tag === 250 ? coq_identity_eq[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(coq_identity_eq) : coq_identity_eq
            ),
          /* inv_ind */tag$1 === 250 ? coq_identity_ind[0] : (
              tag$1 === 246 ? CamlinternalLazy.force_lazy_block(coq_identity_ind) : coq_identity_ind
            ),
          /* inv_congr */tag$2 === 250 ? coq_identity_congr_canonical[0] : (
              tag$2 === 246 ? CamlinternalLazy.force_lazy_block(coq_identity_congr_canonical) : coq_identity_congr_canonical
            )
        ];
}

var coq_eq_true_eq = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Datatypes",
                    /* [] */0
                  ], "eq_true");
      })]);

var coq_eq_true_ind = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Datatypes",
                    /* [] */0
                  ], "eq_true_ind");
      })]);

var coq_eq_true_congr = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "eq_true_congr");
      })]);

function build_coq_inversion_eq_true_data() {
  check_required_library(datatypes_module_name);
  check_required_library(logic_module_name);
  var tag = coq_eq_true_eq.tag | 0;
  var tag$1 = coq_eq_true_ind.tag | 0;
  var tag$2 = coq_eq_true_congr.tag | 0;
  return /* record */[
          /* inv_eq */tag === 250 ? coq_eq_true_eq[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_true_eq) : coq_eq_true_eq
            ),
          /* inv_ind */tag$1 === 250 ? coq_eq_true_ind[0] : (
              tag$1 === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_true_ind) : coq_eq_true_ind
            ),
          /* inv_congr */tag$2 === 250 ? coq_eq_true_congr[0] : (
              tag$2 === 246 ? CamlinternalLazy.force_lazy_block(coq_eq_true_congr) : coq_eq_true_congr
            )
        ];
}

var coq_False = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "False");
      })]);

var coq_True = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "True");
      })]);

var coq_I = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "I");
      })]);

var coq_not = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "not");
      })]);

var coq_and = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "and");
      })]);

var coq_conj = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "conj");
      })]);

var coq_or = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "or");
      })]);

var coq_ex = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "ex");
      })]);

var coq_iff = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "iff");
      })]);

var coq_iff_left_proj = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "proj1");
      })]);

var coq_iff_right_proj = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "proj2");
      })]);

function build_coq_True() {
  var tag = coq_True.tag | 0;
  if (tag === 250) {
    return coq_True[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_True);
  } else {
    return coq_True;
  }
}

function build_coq_I() {
  var tag = coq_I.tag | 0;
  if (tag === 250) {
    return coq_I[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_I);
  } else {
    return coq_I;
  }
}

function build_coq_False() {
  var tag = coq_False.tag | 0;
  if (tag === 250) {
    return coq_False[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_False);
  } else {
    return coq_False;
  }
}

function build_coq_not() {
  var tag = coq_not.tag | 0;
  if (tag === 250) {
    return coq_not[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_not);
  } else {
    return coq_not;
  }
}

function build_coq_and() {
  var tag = coq_and.tag | 0;
  if (tag === 250) {
    return coq_and[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_and);
  } else {
    return coq_and;
  }
}

function build_coq_conj() {
  var tag = coq_conj.tag | 0;
  if (tag === 250) {
    return coq_conj[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_conj);
  } else {
    return coq_conj;
  }
}

function build_coq_or() {
  var tag = coq_or.tag | 0;
  if (tag === 250) {
    return coq_or[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_or);
  } else {
    return coq_or;
  }
}

function build_coq_ex() {
  var tag = coq_ex.tag | 0;
  if (tag === 250) {
    return coq_ex[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_ex);
  } else {
    return coq_ex;
  }
}

function build_coq_iff() {
  var tag = coq_iff.tag | 0;
  if (tag === 250) {
    return coq_iff[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_iff);
  } else {
    return coq_iff;
  }
}

function build_coq_iff_left_proj() {
  var tag = coq_iff_left_proj.tag | 0;
  if (tag === 250) {
    return coq_iff_left_proj[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_iff_left_proj);
  } else {
    return coq_iff_left_proj;
  }
}

function build_coq_iff_right_proj() {
  var tag = coq_iff_right_proj.tag | 0;
  if (tag === 250) {
    return coq_iff_right_proj[0];
  } else if (tag === 246) {
    return CamlinternalLazy.force_lazy_block(coq_iff_right_proj);
  } else {
    return coq_iff_right_proj;
  }
}

var coq_eq_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "eq");
      })]);

var coq_identity_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Datatypes",
                    /* [] */0
                  ], "identity");
      })]);

var coq_jmeq_ref = Block.__(246, [(function () {
        return find_reference("Coqlib", /* :: */[
                    Libnames$ReactTemplate.coq_string,
                    /* :: */[
                      "Logic",
                      /* :: */[
                        "JMeq",
                        /* [] */0
                      ]
                    ]
                  ], "JMeq");
      })]);

var coq_eq_true_ref = Block.__(246, [(function () {
        return find_reference("Coqlib", /* :: */[
                    Libnames$ReactTemplate.coq_string,
                    /* :: */[
                      "Init",
                      /* :: */[
                        "Datatypes",
                        /* [] */0
                      ]
                    ]
                  ], "eq_true");
      })]);

var coq_existS_ref = Block.__(246, [(function () {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("use coq_existT_ref."));
      })]);

var coq_existT_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Specif",
                    /* [] */0
                  ], "existT");
      })]);

var coq_exist_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Specif",
                    /* [] */0
                  ], "exist");
      })]);

var coq_not_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "not");
      })]);

var coq_False_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "False");
      })]);

var coq_sumbool_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Specif",
                    /* [] */0
                  ], "sumbool");
      })]);

var coq_sig_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Specif",
                    /* [] */0
                  ], "sig");
      })]);

var coq_or_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "or");
      })]);

var coq_iff_ref = Block.__(246, [(function () {
        return init_reference(/* :: */[
                    "Logic",
                    /* [] */0
                  ], "iff");
      })]);

exports.find_reference = find_reference;
exports.coq_reference = coq_reference;
exports.check_required_library = check_required_library;
exports.gen_reference_in_modules = gen_reference_in_modules;
exports.arith_modules = arith_modules;
exports.zarith_base_modules = zarith_base_modules;
exports.init_modules = init_modules;
exports.prelude_module = prelude_module;
exports.logic_module = logic_module;
exports.logic_module_name = logic_module_name;
exports.logic_type_module = logic_type_module;
exports.jmeq_module = jmeq_module;
exports.jmeq_module_name = jmeq_module_name;
exports.datatypes_module_name = datatypes_module_name;
exports.id = id;
exports.type_of_id = type_of_id;
exports.nat_path = nat_path;
exports.glob_nat = glob_nat;
exports.path_of_O = path_of_O;
exports.path_of_S = path_of_S;
exports.glob_O = glob_O;
exports.glob_S = glob_S;
exports.glob_bool = glob_bool;
exports.path_of_true = path_of_true;
exports.path_of_false = path_of_false;
exports.glob_true = glob_true;
exports.glob_false = glob_false;
exports.glob_eq = glob_eq;
exports.glob_identity = glob_identity;
exports.glob_jmeq = glob_jmeq;
exports.build_bool_type = build_bool_type;
exports.build_sigma_set = build_sigma_set;
exports.build_sigma_type = build_sigma_type;
exports.build_sigma = build_sigma;
exports.build_prod = build_prod;
exports.build_coq_eq_data = build_coq_eq_data;
exports.build_coq_identity_data = build_coq_identity_data;
exports.build_coq_jmeq_data = build_coq_jmeq_data;
exports.build_coq_eq = build_coq_eq;
exports.build_coq_eq_refl = build_coq_eq_refl;
exports.build_coq_eq_sym = build_coq_eq_sym;
exports.build_coq_f_equal2 = build_coq_f_equal2;
exports.build_coq_inversion_eq_data = build_coq_inversion_eq_data;
exports.build_coq_inversion_identity_data = build_coq_inversion_identity_data;
exports.build_coq_inversion_jmeq_data = build_coq_inversion_jmeq_data;
exports.build_coq_inversion_eq_true_data = build_coq_inversion_eq_true_data;
exports.build_coq_sumbool = build_coq_sumbool;
exports.build_coq_False = build_coq_False;
exports.build_coq_True = build_coq_True;
exports.build_coq_I = build_coq_I;
exports.build_coq_not = build_coq_not;
exports.build_coq_and = build_coq_and;
exports.build_coq_conj = build_coq_conj;
exports.build_coq_iff = build_coq_iff;
exports.build_coq_iff_left_proj = build_coq_iff_left_proj;
exports.build_coq_iff_right_proj = build_coq_iff_right_proj;
exports.build_coq_or = build_coq_or;
exports.build_coq_ex = build_coq_ex;
exports.coq_eq_ref = coq_eq_ref;
exports.coq_identity_ref = coq_identity_ref;
exports.coq_jmeq_ref = coq_jmeq_ref;
exports.coq_eq_true_ref = coq_eq_true_ref;
exports.coq_existS_ref = coq_existS_ref;
exports.coq_existT_ref = coq_existT_ref;
exports.coq_exist_ref = coq_exist_ref;
exports.coq_not_ref = coq_not_ref;
exports.coq_False_ref = coq_False_ref;
exports.coq_sumbool_ref = coq_sumbool_ref;
exports.coq_sig_ref = coq_sig_ref;
exports.coq_or_ref = coq_or_ref;
exports.coq_iff_ref = coq_iff_ref;
/* init_modules Not a pure module */
