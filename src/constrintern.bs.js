// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Cases$ReactTemplate = require("./cases.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Impargs$ReactTemplate = require("./impargs.bs.js");
var Miscops$ReactTemplate = require("./miscops.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Program$ReactTemplate = require("./program.bs.js");
var Reserve$ReactTemplate = require("./reserve.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Notation$ReactTemplate = require("./notation.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Genintern$ReactTemplate = require("./genintern.bs.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Pretyping$ReactTemplate = require("./pretyping.bs.js");
var Recordops$ReactTemplate = require("./recordops.bs.js");
var Patternops$ReactTemplate = require("./patternops.bs.js");
var Syntax_def$ReactTemplate = require("./syntax_def.bs.js");
var Smartlocate$ReactTemplate = require("../shims/smartlocate.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Notation_ops$ReactTemplate = require("./notation_ops.bs.js");
var Constrexpr_ops$ReactTemplate = require("./constrexpr_ops.bs.js");
var Implicit_quantifiers$ReactTemplate = require("./implicit_quantifiers.bs.js");

var interning_grammar = [/* false */0];

function for_grammar(f, x) {
  interning_grammar[0] = /* true */1;
  var a = Curry._1(f, x);
  interning_grammar[0] = /* false */0;
  return a;
}

function locate_reference(qid) {
  return Curry._1(Smartlocate$ReactTemplate.global_of_extended_global, Nametab$ReactTemplate.locate_extended(qid));
}

function is_global(id) {
  try {
    var qid = Libnames$ReactTemplate.qualid_of_ident(id);
    Curry._1(Smartlocate$ReactTemplate.global_of_extended_global, Nametab$ReactTemplate.locate_extended(qid));
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function global_reference(id) {
  var qid = Libnames$ReactTemplate.qualid_of_ident(id);
  return Curry._1(Smartlocate$ReactTemplate.global_of_extended_global, Nametab$ReactTemplate.locate_extended(qid));
}

function construct_reference(ctx, id) {
  try {
    return /* VarRef */Block.__(0, [(Context$ReactTemplate.Named[/* lookup */4](id, ctx), id)]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var qid = Libnames$ReactTemplate.qualid_of_ident(id);
      return Curry._1(Smartlocate$ReactTemplate.global_of_extended_global, Nametab$ReactTemplate.locate_extended(qid));
    } else {
      throw exn;
    }
  }
}

function global_reference_in_absolute_module(dir, id) {
  return Nametab$ReactTemplate.global_of_path(Libnames$ReactTemplate.make_path(dir, id));
}

var InternalizationError = Caml_exceptions.create("Constrintern-ReactTemplate.InternalizationError");

function explain_variable_capture(id, id$prime) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is dependent in the type of ")), Names$ReactTemplate.Id[/* print */8](id$prime)), Pp$ReactTemplate.strbrk(": cannot interpret both of them with the same type"));
}

var explain_illegal_metavariable = Pp$ReactTemplate.str("Metavariables allowed only in patterns");

function explain_not_a_constructor(ref) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unknown constructor: "), Libnames$ReactTemplate.pr_reference(ref));
}

function explain_unbound_fix_name(is_cofix, id) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The name"), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("is not bound in the corresponding")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(is_cofix ? "co" : "")), Pp$ReactTemplate.str("fixpoint definition"));
}

function explain_non_linear_pattern(id) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The variable "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(" is bound several times in pattern"));
}

function explain_bad_patterns_number(n1, n2) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Expecting "), Pp$ReactTemplate.$$int(n1)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], n1, " pattern"))), Pp$ReactTemplate.str(" but found ")), Pp$ReactTemplate.$$int(n2));
}

function explain_internalization_error(e) {
  var pp;
  if (typeof e === "number") {
    pp = explain_illegal_metavariable;
  } else {
    switch (e.tag | 0) {
      case 0 : 
          pp = explain_variable_capture(e[0], e[1]);
          break;
      case 1 : 
          pp = explain_not_a_constructor(e[0]);
          break;
      case 2 : 
          pp = explain_unbound_fix_name(e[0], e[1]);
          break;
      case 3 : 
          pp = explain_non_linear_pattern(e[0]);
          break;
      case 4 : 
          pp = explain_bad_patterns_number(e[0], e[1]);
          break;
      
    }
  }
  return Pp$ReactTemplate.$plus$plus(pp, Pp$ReactTemplate.str("."));
}

function error_bad_inductive_type(loc) {
  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("This should be an inductive type applied to patterns."));
}

function error_ldots_var(loc) {
  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Special token "), Names$ReactTemplate.Id[/* print */8](Notation_ops$ReactTemplate.ldots_var)), Pp$ReactTemplate.str(" is for use in the Notation command.")));
}

var parsing_explicit = [/* false */0];

var empty_internalization_env = Names$ReactTemplate.Id[/* Map */10][/* empty */0];

function compute_explicitable_implicit(imps, param) {
  if (typeof param === "number") {
    return /* [] */0;
  } else {
    var match = Curry._2(Util$ReactTemplate.List[/* chop */99], Curry._1(Util$ReactTemplate.List[/* length */0], param[0]), imps);
    var sub_impl$prime = Curry._2(Util$ReactTemplate.List[/* filter */27], Impargs$ReactTemplate.is_status_implicit, match[0]);
    return Curry._2(Util$ReactTemplate.List[/* map */10], Impargs$ReactTemplate.name_of_implicit, sub_impl$prime);
  }
}

function compute_internalization_data(env, sigma, ty, typ, impl) {
  var impl$1 = Impargs$ReactTemplate.compute_implicits_with_manual(env, sigma, typ, Impargs$ReactTemplate.is_implicit_args(/* () */0), impl);
  var expls_impl = compute_explicitable_implicit(impl$1, ty);
  return /* tuple */[
          ty,
          expls_impl,
          impl$1,
          Notation$ReactTemplate.compute_arguments_scope(sigma, typ)
        ];
}

function compute_internalization_env(env, sigma, $staropt$star, ty) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  return Curry._2(Util$ReactTemplate.List[/* fold_left3 */84], (function (map, id, typ, impl) {
                return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, compute_internalization_data(env, sigma, ty, typ, impl), map);
              }), impls);
}

function wildcards(ntn, n) {
  if (n === ntn.length) {
    return /* [] */0;
  } else {
    var l = spaces(ntn, n + 1 | 0);
    if (Caml_string.get(ntn, n) === /* "_" */95) {
      return /* :: */[
              n,
              l
            ];
    } else {
      return l;
    }
  }
}

function spaces(ntn, _n) {
  while(true) {
    var n = _n;
    if (n === ntn.length) {
      return /* [] */0;
    } else if (Caml_string.get(ntn, n) === /* " " */32) {
      return wildcards(ntn, n + 1 | 0);
    } else {
      _n = n + 1 | 0;
      continue ;
      
    }
  };
}

function expand_notation_string(ntn, n) {
  var pos = Curry._2(Util$ReactTemplate.List[/* nth */3], wildcards(ntn, 0), n);
  var hd = pos ? Curry._3(Util$ReactTemplate.$$String[/* sub */3], ntn, 0, pos) : "";
  var tl = pos === ntn.length ? "" : Curry._3(Util$ReactTemplate.$$String[/* sub */3], ntn, pos + 1 | 0, (ntn.length - pos | 0) - 1 | 0);
  return hd + ("{ _ }" + tl);
}

function contract_curly_brackets(ntn, param) {
  var ntn$prime = [ntn];
  var contract_squash = function (n, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var a = param[0];
        var match = a[/* v */0];
        var exit = 0;
        if (match.tag === 17) {
          if (match[0] === "{ _ }") {
            var match$1 = match[1];
            var match$2 = match$1[0];
            if (match$2) {
              if (match$2[1]) {
                exit = 1;
              } else if (match$1[1]) {
                exit = 1;
              } else if (match$1[2]) {
                exit = 1;
              } else if (match$1[3]) {
                exit = 1;
              } else {
                ntn$prime[0] = expand_notation_string(ntn$prime[0], n);
                _param = /* :: */[
                  match$2[0],
                  param[1]
                ];
                continue ;
                
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          return /* :: */[
                  a,
                  contract_squash(n + 1 | 0, param[1])
                ];
        }
        
      } else {
        return /* [] */0;
      }
    };
  };
  var l = contract_squash(0, param[0]);
  return /* tuple */[
          ntn$prime[0],
          /* tuple */[
            l,
            param[1],
            param[2],
            param[3]
          ]
        ];
}

function contract_curly_brackets_pat(ntn, param) {
  var ntn$prime = [ntn];
  var contract_squash = function (n, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var a = param[0];
        var match = a[/* v */0];
        var exit = 0;
        if (match.tag === 4) {
          if (match[0] === "{ _ }") {
            var match$1 = match[1];
            var match$2 = match$1[0];
            if (match$2) {
              if (match$2[1]) {
                exit = 1;
              } else if (match$1[1]) {
                exit = 1;
              } else if (match[2]) {
                exit = 1;
              } else {
                ntn$prime[0] = expand_notation_string(ntn$prime[0], n);
                _param = /* :: */[
                  match$2[0],
                  param[1]
                ];
                continue ;
                
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          return /* :: */[
                  a,
                  contract_squash(n + 1 | 0, param[1])
                ];
        }
        
      } else {
        return /* [] */0;
      }
    };
  };
  var l = contract_squash(0, param[0]);
  return /* tuple */[
          ntn$prime[0],
          /* tuple */[
            l,
            param[1]
          ]
        ];
}

function make_current_scope(tmp, scopes) {
  if (tmp) {
    var tmp_scope = tmp[0];
    if (scopes) {
      if (scopes[0] === tmp_scope) {
        return scopes;
      } else {
        return /* :: */[
                tmp_scope,
                scopes
              ];
      }
    } else {
      return /* :: */[
              tmp_scope,
              scopes
            ];
    }
  } else {
    return scopes;
  }
}

function pr_scope_stack(l) {
  if (l) {
    if (l[1]) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("scope stack "), Pp$ReactTemplate.str("[")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, Pp$ReactTemplate.str, l)), Pp$ReactTemplate.str("]"));
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("scope "), Pp$ReactTemplate.str(l[0]));
    }
  } else {
    return Pp$ReactTemplate.str("the empty scope stack");
  }
}

function error_inconsistent_scope(loc, id, scopes1, scopes2) {
  return CErrors$ReactTemplate.user_err(loc, /* Some */["set_var_scope"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is here used in ")), pr_scope_stack(scopes2)), Pp$ReactTemplate.strbrk(" while it was elsewhere used in ")), pr_scope_stack(scopes1)));
}

function set_var_scope(loc, id, istermvar, scopes, ntnvars) {
  try {
    var match = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, ntnvars);
    var idscopes = match[1];
    if (!istermvar) {
      match[0][0] = /* true */1;
    }
    if (istermvar) {
      var match$1 = idscopes[0];
      if (match$1) {
        var match$2 = match$1[0];
        var s$prime = make_current_scope(match$2[0], match$2[1]);
        var s = make_current_scope(scopes[0], scopes[1]);
        if (!Curry._3(Util$ReactTemplate.List[/* equal */44], (function (prim, prim$1) {
                  return +(prim === prim$1);
                }), s$prime, s)) {
          error_inconsistent_scope(loc, id, s$prime, s);
        }
        
      } else {
        idscopes[0] = /* Some */[scopes];
      }
    }
    if (match[2] !== 0 && istermvar) {
      var loc$1 = loc;
      var id$1 = id;
      return CErrors$ReactTemplate.user_err(loc$1, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id$1), Pp$ReactTemplate.str(" is expected to occur in binding position in the right-hand side.")));
    } else {
      return /* () */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function set_type_scope(env) {
  return /* record */[
          /* ids */env[/* ids */0],
          /* unb */env[/* unb */1],
          /* tmp_scope */Notation$ReactTemplate.current_type_scope_name(/* () */0),
          /* scopes */env[/* scopes */3],
          /* impls */env[/* impls */4]
        ];
}

function reset_tmp_scope(env) {
  return /* record */[
          /* ids */env[/* ids */0],
          /* unb */env[/* unb */1],
          /* tmp_scope : None */0,
          /* scopes */env[/* scopes */3],
          /* impls */env[/* impls */4]
        ];
}

function set_env_scopes(env, param) {
  return /* record */[
          /* ids */env[/* ids */0],
          /* unb */env[/* unb */1],
          /* tmp_scope */param[0],
          /* scopes */Util$ReactTemplate.$at(param[1], env[/* scopes */3]),
          /* impls */env[/* impls */4]
        ];
}

function mkGProd(loc, param, body) {
  return DAst$ReactTemplate.make(loc, /* GProd */Block.__(6, [
                param[0],
                param[1],
                param[2],
                body
              ]));
}

function mkGLambda(loc, param, body) {
  return DAst$ReactTemplate.make(loc, /* GLambda */Block.__(5, [
                param[0],
                param[1],
                param[2],
                body
              ]));
}

function build_impls(param) {
  if (param !== 0) {
    return (function (param) {
        if (param) {
          return /* Some */[/* tuple */[
                    param[0],
                    /* Manual */0,
                    /* tuple */[
                      /* true */1,
                      /* true */1
                    ]
                  ]];
        } else {
          return /* Some */[/* tuple */[
                    Names$ReactTemplate.Id[/* of_string */5]("_"),
                    /* Manual */0,
                    /* tuple */[
                      /* true */1,
                      /* true */1
                    ]
                  ]];
        }
      });
  } else {
    return (function () {
        return /* None */0;
      });
  }
}

function impls_type_list($staropt$star) {
  var args = $staropt$star ? $staropt$star[0] : /* [] */0;
  return (function (param) {
      var _acc = /* [] */0;
      var _c = param;
      while(true) {
        var c = _c;
        var acc = _acc;
        var match = DAst$ReactTemplate.get(c);
        if (match.tag === 6) {
          _c = match[3];
          _acc = /* :: */[
            Curry._1(build_impls(match[1]), match[0]),
            acc
          ];
          continue ;
          
        } else {
          return /* tuple */[
                  /* Variable */2,
                  /* [] */0,
                  Curry._2(Util$ReactTemplate.List[/* append */5], args, Curry._1(Util$ReactTemplate.List[/* rev */4], acc)),
                  /* [] */0
                ];
        }
      };
    });
}

function impls_term_list($staropt$star) {
  var args = $staropt$star ? $staropt$star[0] : /* [] */0;
  return (function (param) {
      var _acc = /* [] */0;
      var _c = param;
      while(true) {
        var c = _c;
        var acc = _acc;
        var match = DAst$ReactTemplate.get(c);
        switch (match.tag | 0) {
          case 5 : 
              _c = match[3];
              _acc = /* :: */[
                Curry._1(build_impls(match[1]), match[0]),
                acc
              ];
              continue ;
              case 11 : 
              var fix_kind = match[0];
              var nb;
              nb = fix_kind.tag ? fix_kind[0] : fix_kind[0][1];
              var acc$prime = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (a, param) {
                      return /* :: */[
                              Curry._1(build_impls(param[1]), param[0]),
                              a
                            ];
                    }), acc, Caml_array.caml_array_get(match[2], nb));
              _c = Caml_array.caml_array_get(match[4], nb);
              _acc = acc$prime;
              continue ;
              default:
            return /* tuple */[
                    /* Variable */2,
                    /* [] */0,
                    Curry._2(Util$ReactTemplate.List[/* append */5], args, Curry._1(Util$ReactTemplate.List[/* rev */4], acc)),
                    /* [] */0
                  ];
        }
      };
    });
}

function check_capture(ty, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      var match$1 = match[/* v */0];
      if (match$1) {
        var match$2 = param[1];
        if (match$2) {
          var match$3 = match$2[0][/* v */0];
          if (match$3) {
            var id = match$1[0];
            if (Glob_ops$ReactTemplate.occur_glob_constr(id)(ty)) {
              throw [
                    InternalizationError,
                    /* tuple */[
                      match[/* loc */1],
                      /* VariableCapture */Block.__(0, [
                          id,
                          match$3[0]
                        ])
                    ]
                  ];
            } else {
              _param = param[1];
              continue ;
              
            }
          } else {
            _param = param[1];
            continue ;
            
          }
        } else {
          _param = param[1];
          continue ;
          
        }
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* () */0;
    }
  };
}

function locate_if_hole(loc, na, c) {
  var match = DAst$ReactTemplate.get(c);
  if (match.tag === 13) {
    try {
      if (na) {
        return Notation_ops$ReactTemplate.glob_constr_of_notation_constr(loc, Reserve$ReactTemplate.find_reserved_type(na[0]));
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return DAst$ReactTemplate.make(loc, /* GHole */Block.__(13, [
                      /* BinderType */Block.__(1, [na]),
                      match[1],
                      match[2]
                    ]));
      } else {
        throw exn;
      }
    }
  } else {
    return c;
  }
}

function reset_hidden_inductive_implicit_test(env) {
  return /* record */[
          /* ids */env[/* ids */0],
          /* unb */env[/* unb */1],
          /* tmp_scope */env[/* tmp_scope */2],
          /* scopes */env[/* scopes */3],
          /* impls */Curry._2(Names$ReactTemplate.Id[/* Map */10][/* map */22], (function (x) {
                  var match = x[0];
                  if (typeof match === "number") {
                    return x;
                  } else {
                    return /* tuple */[
                            /* Inductive */[
                              match[0],
                              /* false */0
                            ],
                            x[1],
                            x[2],
                            x[3]
                          ];
                  }
                }), env[/* impls */4])
        ];
}

function check_hidden_implicit_parameters(loc, id, impls) {
  if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* exists */12], (function (_, param) {
            var match = param[0];
            return typeof match === "number" || !match[1] ? /* false */0 : Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], id, match[0]);
          }), impls)) {
    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.strbrk(" is already used as name of ")), Pp$ReactTemplate.strbrk("a parameter of the inductive type; bound variables in ")), Pp$ReactTemplate.strbrk("the type of a constructor shall use a different name.")));
  } else {
    return 0;
  }
}

function push_name_env($staropt$star, ntnvars, implargs, env, param) {
  var global_level = $staropt$star ? $staropt$star[0] : /* false */0;
  var match = param[/* v */0];
  if (match) {
    var loc = param[/* loc */1];
    var id = match[0];
    check_hidden_implicit_parameters(loc, id, env[/* impls */4]);
    if (Curry._1(Names$ReactTemplate.Id[/* Map */10][/* is_empty */1], ntnvars) && Names$ReactTemplate.Id[/* equal */0](id, Notation_ops$ReactTemplate.ldots_var)) {
      error_ldots_var(loc);
    }
    set_var_scope(loc, id, /* false */0, /* tuple */[
          env[/* tmp_scope */2],
          env[/* scopes */3]
        ], ntnvars);
    return /* record */[
            /* ids */Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, env[/* ids */0]),
            /* unb */env[/* unb */1],
            /* tmp_scope */env[/* tmp_scope */2],
            /* scopes */env[/* scopes */3],
            /* impls */Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, implargs, env[/* impls */4])
          ];
  } else {
    if (global_level) {
      CErrors$ReactTemplate.user_err(param[/* loc */1], /* None */0, Pp$ReactTemplate.str("Anonymous variables not allowed"));
    }
    return env;
  }
}

function intern_generalized_binder($staropt$star, intern_type, ntnvars, env, param, b, b$prime, t, ty) {
  var loc = param[/* loc */1];
  var na = param[/* v */0];
  var global_level = $staropt$star ? $staropt$star[0] : /* false */0;
  var ids = Curry._1(na ? Curry._1(Names$ReactTemplate.Id[/* Set */9][/* add */3], na[0]) : (function (x) {
            return x;
          }), env[/* ids */0]);
  var match = t ? /* tuple */[
      ty,
      ids
    ] : Implicit_quantifiers$ReactTemplate.implicit_application(ids, /* None */0, Implicit_quantifiers$ReactTemplate.combine_params_freevar, ty);
  var ids$prime = match[1];
  var ty$1 = match[0];
  var ty$prime = Curry._2(intern_type, /* record */[
        /* ids */ids,
        /* unb : true */1,
        /* tmp_scope */env[/* tmp_scope */2],
        /* scopes */env[/* scopes */3],
        /* impls */env[/* impls */4]
      ], ty$1);
  var fvs = Implicit_quantifiers$ReactTemplate.generalizable_vars_of_glob_constr(/* Some */[ids], /* Some */[ids$prime])(ty$prime);
  var env$prime = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (env, param) {
          return push_name_env(/* Some */[global_level], ntnvars, /* tuple */[
                      /* Variable */2,
                      /* [] */0,
                      /* [] */0,
                      /* [] */0
                    ], env, CAst$ReactTemplate.make(param[/* loc */1], /* Name */[param[/* v */0]]));
        }), env, fvs);
  var bl = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return CAst$ReactTemplate.map((function (id) {
                        return /* tuple */[
                                /* Name */[id],
                                b,
                                DAst$ReactTemplate.make(loc, /* GHole */Block.__(13, [
                                        /* BinderType */Block.__(1, [/* Name */[id]]),
                                        /* IntroAnonymous */0,
                                        /* None */0
                                      ]))
                              ];
                      }), param);
        }), fvs);
  var na$1;
  if (na) {
    na$1 = na;
  } else if (global_level) {
    na$1 = na;
  } else {
    var match$1 = ty$1[/* v */0];
    var id;
    if (match$1.tag === 7) {
      var match$2 = match$1[0][1][/* v */0];
      if (match$2.tag) {
        id = Namegen$ReactTemplate.default_non_dependent_ident;
      } else {
        var match$3 = match$2[0][/* v */0];
        id = match$3.tag ? match$3[0] : Namegen$ReactTemplate.default_non_dependent_ident;
      }
    } else {
      id = Namegen$ReactTemplate.default_non_dependent_ident;
    }
    var name = Implicit_quantifiers$ReactTemplate.make_fresh(ids$prime, Global$ReactTemplate.env(/* () */0), id);
    na$1 = /* Name */[name];
  }
  return /* tuple */[
          push_name_env(/* Some */[global_level], ntnvars, impls_type_list(/* None */0)(ty$prime), env$prime, CAst$ReactTemplate.make(loc, na$1)),
          /* :: */[
            CAst$ReactTemplate.make(loc, /* tuple */[
                  na$1,
                  b$prime,
                  ty$prime
                ]),
            Curry._1(Util$ReactTemplate.List[/* rev */4], bl)
          ]
        ];
}

function intern_assumption(intern, ntnvars, env, nal, bk, ty) {
  var intern_type = function (env) {
    return Curry._1(intern, set_type_scope(env));
  };
  if (bk.tag) {
    var match = intern_generalized_binder(/* None */0, intern_type, ntnvars, env, Curry._1(Util$ReactTemplate.List[/* hd */1], nal), bk[0], bk[1], bk[2], ty);
    return /* tuple */[
            match[0],
            match[1]
          ];
  } else {
    var k = bk[0];
    var ty$1 = Curry._2(intern, set_type_scope(env), ty);
    check_capture(ty$1, nal);
    var impls = impls_type_list(/* None */0)(ty$1);
    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, locna) {
                  var loc = locna[/* loc */1];
                  var na = locna[/* v */0];
                  return /* tuple */[
                          push_name_env(/* None */0, ntnvars, impls, param[0], locna),
                          /* :: */[
                            CAst$ReactTemplate.make(loc, /* tuple */[
                                  na,
                                  k,
                                  locate_if_hole(loc, na, ty$1)
                                ]),
                            param[1]
                          ]
                        ];
                }), /* tuple */[
                env,
                /* [] */0
              ], nal);
  }
}

function glob_local_binder_of_extended(param) {
  return DAst$ReactTemplate.with_loc_val((function (loc, param) {
                switch (param.tag | 0) {
                  case 0 : 
                      return /* tuple */[
                              param[0],
                              param[1],
                              /* None */0,
                              param[2]
                            ];
                  case 1 : 
                      var match = param[3];
                      var c = param[2];
                      var bk = param[1];
                      var na = param[0];
                      if (match) {
                        return /* tuple */[
                                na,
                                bk,
                                /* Some */[c],
                                match[0]
                              ];
                      } else {
                        var t = DAst$ReactTemplate.make(loc, /* GHole */Block.__(13, [
                                /* BinderType */Block.__(1, [na]),
                                /* IntroAnonymous */0,
                                /* None */0
                              ]));
                        return /* tuple */[
                                na,
                                bk,
                                /* Some */[c],
                                t
                              ];
                      }
                      break;
                  case 2 : 
                      return Loc$ReactTemplate.raise(loc, [
                                  Stream.$$Error,
                                  "pattern with quote not allowed here."
                                ]);
                  
                }
              }), param);
}

var intern_cases_pattern_fwd = [(function () {
      return Pervasives.failwith("intern_cases_pattern_fwd");
    })];

function intern_letin_binder(intern, ntnvars, env, param) {
  var locna = param[0];
  var term = Curry._2(intern, env, param[1]);
  var ty = Option$ReactTemplate.map(Curry._1(intern, env), param[2]);
  return /* tuple */[
          push_name_env(/* None */0, ntnvars, impls_term_list(/* None */0)(term), env, locna),
          /* tuple */[
            locna[/* v */0],
            /* Explicit */0,
            term,
            ty
          ]
        ];
}

function intern_cases_pattern_as_binder(loc, ntnvars, env, p) {
  var match = Curry._3(intern_cases_pattern_fwd[0], ntnvars, /* tuple */[
        /* None */0,
        env[/* scopes */3]
      ], p);
  var il = match[0];
  var match$1 = Curry._1(Util$ReactTemplate.List[/* split */36], match[1]);
  var disjpat = match$1[1];
  if (!Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (subst) {
            return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* equal */8], Names$ReactTemplate.Id[/* equal */0], subst, Names$ReactTemplate.Id[/* Map */10][/* empty */0]);
          }), match$1[0])) {
    CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("Unsupported nested \"as\" clause."));
  }
  var env$1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, env) {
          return push_name_env(/* None */0, ntnvars, /* tuple */[
                      /* Variable */2,
                      /* [] */0,
                      /* [] */0,
                      /* [] */0
                    ], env, CAst$ReactTemplate.make(param[/* loc */1], /* Name */[param[/* v */0]]));
        }), il, env);
  var na = Glob_ops$ReactTemplate.alias_of_pat(Curry._1(Util$ReactTemplate.List[/* hd */1], disjpat));
  var ienv = Nameops$ReactTemplate.Name[/* fold_right */10](Names$ReactTemplate.Id[/* Set */9][/* remove */5], na, env$1[/* ids */0]);
  var id = Namegen$ReactTemplate.next_name_away_with_default("pat", na, ienv);
  var na$1 = CAst$ReactTemplate.make(loc, /* Name */[id]);
  return /* tuple */[
          env$1,
          /* tuple */[
            /* tuple */[
              disjpat,
              il
            ],
            id
          ],
          na$1
        ];
}

function intern_local_binder_aux(_, intern, ntnvars, param, param$1) {
  var bl = param[1];
  var env = param[0];
  switch (param$1.tag | 0) {
    case 0 : 
        var match = intern_assumption(intern, ntnvars, env, param$1[0], param$1[1], param$1[2]);
        var bl$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                var match = param[/* v */0];
                return DAst$ReactTemplate.make(param[/* loc */1], /* GLocalAssum */Block.__(0, [
                              match[0],
                              match[1],
                              match[2]
                            ]));
              }), match[1]);
        return /* tuple */[
                match[0],
                Util$ReactTemplate.$at(bl$prime, bl)
              ];
    case 1 : 
        var locna = param$1[0];
        var match$1 = intern_letin_binder(intern, ntnvars, env, /* tuple */[
              locna,
              param$1[1],
              param$1[2]
            ]);
        var match$2 = match$1[1];
        return /* tuple */[
                match$1[0],
                /* :: */[
                  DAst$ReactTemplate.make(locna[/* loc */1], /* GLocalDef */Block.__(1, [
                          match$2[0],
                          match$2[1],
                          match$2[2],
                          match$2[3]
                        ])),
                  bl
                ]
              ];
    case 2 : 
        var match$3 = param$1[0];
        var loc = match$3[/* loc */1];
        var match$4 = match$3[/* v */0];
        var ty = match$4[1];
        var tyc = ty ? ty[0] : CAst$ReactTemplate.make(loc, /* CHole */Block.__(12, [
                  /* None */0,
                  /* IntroAnonymous */0,
                  /* None */0
                ]));
        var match$5 = intern_cases_pattern_as_binder(loc, ntnvars, env, match$4[0]);
        var match$6 = match$5[1];
        var match$7 = match$6[0];
        var env$1 = match$5[0];
        var match$8 = intern_assumption(intern, ntnvars, env$1, /* :: */[
              match$5[2],
              /* [] */0
            ], /* Default */Block.__(0, [/* Explicit */0]), tyc);
        var match$9 = Curry._1(Util$ReactTemplate.List[/* hd */1], match$8[1]);
        var match$10 = match$9[/* v */0];
        return /* tuple */[
                env$1,
                /* :: */[
                  DAst$ReactTemplate.make(loc, /* GLocalPattern */Block.__(2, [
                          /* tuple */[
                            match$7[0],
                            Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                                    return x[/* v */0];
                                  }), match$7[1])
                          ],
                          match$6[1],
                          match$10[1],
                          match$10[2]
                        ])),
                  bl
                ]
              ];
    
  }
}

function expand_binders(loc, mk, _bl, _c) {
  while(true) {
    var c = _c;
    var bl = _bl;
    if (bl) {
      var bl$1 = bl[1];
      var match = DAst$ReactTemplate.get(bl[0]);
      switch (match.tag | 0) {
        case 0 : 
            _c = Curry._3(mk, loc, /* tuple */[
                  match[0],
                  match[1],
                  match[2]
                ], c);
            _bl = bl$1;
            continue ;
            case 1 : 
            _c = DAst$ReactTemplate.make(loc, /* GLetIn */Block.__(7, [
                    match[0],
                    match[2],
                    match[3],
                    c
                  ]));
            _bl = bl$1;
            continue ;
            case 2 : 
            var id = match[1];
            var match$1 = match[0];
            var ids = match$1[1];
            var tm = DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [id]));
            var eqnl = Curry._2(Util$ReactTemplate.List[/* map */10], (function(c,ids){
                return function (pat) {
                  return CAst$ReactTemplate.make(loc, /* tuple */[
                              ids,
                              /* :: */[
                                pat,
                                /* [] */0
                              ],
                              c
                            ]);
                }
                }(c,ids)), match$1[0]);
            var c$1 = DAst$ReactTemplate.make(loc, /* GCases */Block.__(8, [
                    /* LetPatternStyle */2,
                    /* None */0,
                    /* :: */[
                      /* tuple */[
                        tm,
                        /* tuple */[
                          /* Anonymous */0,
                          /* None */0
                        ]
                      ],
                      /* [] */0
                    ],
                    eqnl
                  ]));
            _c = Curry._3(mk, loc, /* tuple */[
                  /* Name */[id],
                  /* Explicit */0,
                  match[3]
                ], c$1);
            _bl = bl$1;
            continue ;
            
      }
    } else {
      return c;
    }
  };
}

function option_mem_assoc(id, param) {
  if (param) {
    return Names$ReactTemplate.Id[/* equal */0](id, param[0][0]);
  } else {
    return /* false */0;
  }
}

function find_fresh_name(renaming, param, avoid, id) {
  var fold1 = function (_, param, accu) {
    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], Constrexpr_ops$ReactTemplate.free_vars_of_constr_expr(param[0]), accu);
  };
  var fold2 = function (_, param, accu) {
    var fold = function (accu, c) {
      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], Constrexpr_ops$ReactTemplate.free_vars_of_constr_expr(c), accu);
    };
    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, accu, param[0]);
  };
  var fold3 = function (_, x, accu) {
    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], x, accu);
  };
  var fvs1 = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], fold1, param[0], avoid);
  var fvs2 = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], fold2, param[1], fvs1);
  var fvs3 = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], fold3, renaming, fvs2);
  return Namegen$ReactTemplate.next_ident_away_from(id, (function (id) {
                return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, fvs3);
              }));
}

function is_var(store, pat) {
  var match = DAst$ReactTemplate.get(pat);
  if (match.tag) {
    return /* false */0;
  } else {
    Curry._1(store, match[0]);
    return /* true */1;
  }
}

function out_var(pat) {
  var match = pat[/* v */0];
  if (match.tag === 2) {
    var match$1 = match[0];
    if (match$1) {
      var match$2 = match$1[0][/* v */0];
      if (match$2.tag) {
        return /* Name */[match$2[0]];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "constrintern.ml",
                562,
                9
              ]
            ];
      }
    } else {
      return /* Anonymous */0;
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "constrintern.ml",
            562,
            9
          ]
        ];
  }
}

function term_of_name(param) {
  if (param) {
    return DAst$ReactTemplate.make(/* None */0, /* GVar */Block.__(1, [param[0]]));
  } else {
    var st = /* Define */[1 - Program$ReactTemplate.get_proofs_transparency(/* () */0)];
    return DAst$ReactTemplate.make(/* None */0, /* GHole */Block.__(13, [
                  /* QuestionMark */Block.__(3, [
                      st,
                      /* Anonymous */0
                    ]),
                  /* IntroAnonymous */0,
                  /* None */0
                ]));
  }
}

function traverse_binder(intern_pat, ntnvars, subst, avoid, param, param$1) {
  var env = param[1];
  var renaming = param[0];
  if (param$1) {
    var id = param$1[0];
    var match = Util$ReactTemplate.set_temporary_memory(/* () */0);
    var get = match[1];
    var store = match[0];
    try {
      var pat = Constrexpr_ops$ReactTemplate.coerce_to_cases_pattern_expr(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, subst[0])[0]);
      var match$1 = Curry._3(intern_pat, ntnvars, env, pat);
      var match$2 = match$1[1];
      var match$3 = match$2[0];
      var disjpat = match$3[0];
      var match$4;
      var exit = 0;
      if (disjpat) {
        if (disjpat[1]) {
          exit = 1;
        } else if (is_var(store, disjpat[0])) {
          var na = Curry._1(get, /* () */0);
          match$4 = /* tuple */[
            /* None */0,
            na
          ];
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        match$4 = /* tuple */[
          /* Some */[/* tuple */[
              /* tuple */[
                Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                        return x[/* v */0];
                      }), match$3[1]),
                disjpat
              ],
              match$2[1]
            ]],
          match$1[2][/* v */0]
        ];
      }
      return /* tuple */[
              /* tuple */[
                renaming,
                match$1[0]
              ],
              match$4[0],
              match$4[1]
            ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        try {
          var match$5 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, subst[2]);
          var match$6 = match$5[1];
          var pat$1 = match$5[0];
          var env$1 = set_env_scopes(env, match$6[1]);
          if (match$6[0]) {
            var na$1 = out_var(pat$1);
            var env$2 = push_name_env(/* None */0, ntnvars, /* tuple */[
                  /* Variable */2,
                  /* [] */0,
                  /* [] */0,
                  /* [] */0
                ], env$1, CAst$ReactTemplate.make(pat$1[/* loc */1], na$1));
            return /* tuple */[
                    /* tuple */[
                      renaming,
                      env$2
                    ],
                    /* None */0,
                    na$1
                  ];
          } else {
            var match$7 = Curry._3(intern_pat, ntnvars, env$1, pat$1);
            var match$8 = match$7[1];
            var match$9 = match$8[0];
            var disjpat$1 = match$9[0];
            var match$10;
            var exit$1 = 0;
            if (disjpat$1) {
              if (disjpat$1[1]) {
                exit$1 = 1;
              } else if (is_var(store, disjpat$1[0])) {
                var na$2 = Curry._1(get, /* () */0);
                match$10 = /* tuple */[
                  /* None */0,
                  na$2
                ];
              } else {
                exit$1 = 1;
              }
            } else {
              exit$1 = 1;
            }
            if (exit$1 === 1) {
              match$10 = /* tuple */[
                /* Some */[/* tuple */[
                    /* tuple */[
                      Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                              return x[/* v */0];
                            }), match$9[1]),
                      disjpat$1
                    ],
                    match$8[1]
                  ]],
                match$7[2][/* v */0]
              ];
            }
            return /* tuple */[
                    /* tuple */[
                      renaming,
                      match$7[0]
                    ],
                    match$10[0],
                    match$10[1]
                  ];
          }
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            var id$prime = find_fresh_name(renaming, subst, avoid, id);
            var renaming$prime = Names$ReactTemplate.Id[/* equal */0](id, id$prime) ? renaming : Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, id$prime, renaming);
            return /* tuple */[
                    /* tuple */[
                      renaming$prime,
                      env
                    ],
                    /* None */0,
                    /* Name */[id$prime]
                  ];
          } else {
            throw exn$1;
          }
        }
      } else {
        throw exn;
      }
    }
  } else {
    return /* tuple */[
            /* tuple */[
              renaming,
              env
            ],
            /* None */0,
            /* Anonymous */0
          ];
  }
}

function error_cannot_coerce_wildcard_term(loc, _) {
  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("Cannot turn \"_\" into a term."));
}

function error_cannot_coerce_disjunctive_pattern_term(loc, _) {
  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("Cannot turn a disjunctive pattern into a term."));
}

function terms_of_binders(bl) {
  var term_of_pat = function (pt) {
    var f = function (loc, param) {
      if (param.tag) {
        var c = param[0];
        var r = CAst$ReactTemplate.make(loc, /* Qualid */Block.__(0, [Libnames$ReactTemplate.qualid_of_path(Nametab$ReactTemplate.path_of_global(/* ConstructRef */Block.__(3, [c])))]));
        var hole = CAst$ReactTemplate.make(loc, /* CHole */Block.__(12, [
                /* None */0,
                /* IntroAnonymous */0,
                /* None */0
              ]));
        var params = Curry._2(Util$ReactTemplate.List[/* make */56], Inductiveops$ReactTemplate.inductive_nparams(c[0]), hole);
        return /* CAppExpl */Block.__(6, [
                  /* tuple */[
                    /* None */0,
                    r,
                    /* None */0
                  ],
                  Util$ReactTemplate.$at(params, Curry._2(Util$ReactTemplate.List[/* map */10], term_of_pat, param[1]))
                ]);
      } else {
        var match = param[0];
        if (match) {
          var eta = /* Ident */Block.__(1, [match[0]]);
          return /* CRef */Block.__(0, [
                    CAst$ReactTemplate.make(/* None */0, eta),
                    /* None */0
                  ]);
        } else {
          return error_cannot_coerce_wildcard_term(loc, /* () */0);
        }
      }
    };
    var n = pt;
    return CAst$ReactTemplate.map_with_loc((function (loc, c) {
                  return Curry._2(f, loc, DAst$ReactTemplate.get_thunk(c));
                }), n);
  };
  var extract_variables = function (_l) {
    while(true) {
      var l = _l;
      if (l) {
        var l$1 = l[1];
        var bnd = l[0];
        var loc = bnd[/* loc */1];
        var match = DAst$ReactTemplate.get(bnd);
        switch (match.tag | 0) {
          case 0 : 
              var match$1 = match[0];
              if (match$1) {
                return /* :: */[
                        CAst$ReactTemplate.make(loc, /* CRef */Block.__(0, [
                                CAst$ReactTemplate.make(loc, /* Ident */Block.__(1, [match$1[0]])),
                                /* None */0
                              ])),
                        extract_variables(l$1)
                      ];
              } else {
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot turn \"_\" into a term."));
              }
          case 1 : 
              if (match[0]) {
                _l = l$1;
                continue ;
                
              } else {
                return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot turn \"_\" into a term."));
              }
              break;
          case 2 : 
              var match$2 = match[0][0];
              if (match$2 && !match$2[1]) {
                return /* :: */[
                        term_of_pat(match$2[0]),
                        extract_variables(l$1)
                      ];
              } else {
                return error_cannot_coerce_disjunctive_pattern_term(loc, /* () */0);
              }
          
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return extract_variables(bl);
}

function flatten_generalized_binders_if_any(y, l) {
  var match = Curry._1(Util$ReactTemplate.List[/* rev */4], l);
  if (match) {
    return /* tuple */[
            match[0],
            Curry._2(Util$ReactTemplate.List[/* map */10], (function (a) {
                    return /* AddBinderIter */Block.__(3, [
                              y,
                              a
                            ]);
                  }), match[1])
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "constrintern.ml",
            649,
            10
          ]
        ];
  }
}

function flatten_binders(bl) {
  var dispatch = function (a) {
    switch (a.tag | 0) {
      case 0 : 
          var t = a[2];
          var bk = a[1];
          return Curry._2(Util$ReactTemplate.List[/* map */10], (function (na) {
                        return /* CLocalAssum */Block.__(0, [
                                  /* :: */[
                                    na,
                                    /* [] */0
                                  ],
                                  bk,
                                  t
                                ]);
                      }), a[0]);
      case 1 : 
      case 2 : 
          return /* :: */[
                  a,
                  /* [] */0
                ];
      
    }
  };
  return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], dispatch, bl));
}

function instantiate_notation_constr(loc, intern, intern_pat, ntnvars, subst, infos, c) {
  var binderlists = subst[3];
  var binders = subst[2];
  var termlists = subst[1];
  var avoid = Curry._1(Names$ReactTemplate.Id[/* Map */10][/* domain */27], ntnvars);
  var aux = function (_subst$prime, _param, _c) {
    while(true) {
      var param = _param;
      var c = _c;
      var subst$prime = _subst$prime;
      var env = param[1];
      var renaming = param[0];
      var binderopt = subst$prime[1];
      var terms = subst$prime[0];
      var subinfos_001 = /* record */[
        /* ids */env[/* ids */0],
        /* unb */env[/* unb */1],
        /* tmp_scope : None */0,
        /* scopes */env[/* scopes */3],
        /* impls */env[/* impls */4]
      ];
      var subinfos = /* tuple */[
        renaming,
        subinfos_001
      ];
      var exit = 0;
      switch (c.tag | 0) {
        case 1 : 
            var id = c[0];
            if (Names$ReactTemplate.Id[/* equal */0](id, Notation_ops$ReactTemplate.ldots_var)) {
              var aux_letin = (function(terms,renaming){
              return function aux_letin(env, param) {
                var match = param[0];
                if (match) {
                  var match$1 = match[0];
                  switch (match$1.tag | 0) {
                    case 0 : 
                        var match$2 = intern_letin_binder(intern, ntnvars, env, /* tuple */[
                              match$1[0],
                              match$1[1],
                              match$1[2]
                            ]);
                        var match$3 = match$2[1];
                        return DAst$ReactTemplate.make(loc, /* GLetIn */Block.__(7, [
                                      match$3[0],
                                      match$3[2],
                                      match$3[3],
                                      aux_letin(match$2[0], /* tuple */[
                                            match[1],
                                            param[1],
                                            param[2]
                                          ])
                                    ]));
                    case 1 : 
                        var iter = param[2];
                        return aux(/* tuple */[
                                    match$1[0],
                                    /* None */0,
                                    /* Some */[/* tuple */[
                                        match[1],
                                        param[1],
                                        iter
                                      ]]
                                  ], /* tuple */[
                                    renaming,
                                    env
                                  ], iter);
                    case 2 : 
                        var iter$1 = param[2];
                        var y = match$1[0];
                        var match$4 = intern_local_binder_aux(/* None */0, intern, ntnvars, /* tuple */[
                              env,
                              /* [] */0
                            ], match$1[1]);
                        var match$5 = flatten_generalized_binders_if_any(y, match$4[1]);
                        return aux(/* tuple */[
                                    terms,
                                    /* Some */[/* tuple */[
                                        y,
                                        match$5[0]
                                      ]],
                                    /* Some */[/* tuple */[
                                        Util$ReactTemplate.$at(match$5[1], match[1]),
                                        param[1],
                                        iter$1
                                      ]]
                                  ], /* tuple */[
                                    renaming,
                                    match$4[0]
                                  ], iter$1);
                    case 3 : 
                        var iter$2 = param[2];
                        return aux(/* tuple */[
                                    terms,
                                    /* Some */[/* tuple */[
                                        match$1[0],
                                        match$1[1]
                                      ]],
                                    /* Some */[/* tuple */[
                                        match[1],
                                        param[1],
                                        iter$2
                                      ]]
                                  ], /* tuple */[
                                    renaming,
                                    env
                                  ], iter$2);
                    
                  }
                } else {
                  return aux(/* tuple */[
                              terms,
                              /* None */0,
                              /* None */0
                            ], /* tuple */[
                              renaming,
                              env
                            ], param[1]);
                }
              }
              }(terms,renaming));
              return aux_letin(env, Option$ReactTemplate.get(subst$prime[2]));
            } else {
              var param$1 = subst$prime;
              var param$2 = /* tuple */[
                renaming,
                env
              ];
              var id$1 = id;
              var env$1 = param$2[1];
              var binderopt$1 = param$1[1];
              try {
                var match = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$1, param$1[0]);
                var match$1 = match[1];
                return Curry._2(intern, /* record */[
                            /* ids */env$1[/* ids */0],
                            /* unb */env$1[/* unb */1],
                            /* tmp_scope */match$1[0],
                            /* scopes */Util$ReactTemplate.$at(match$1[1], env$1[/* scopes */3]),
                            /* impls */env$1[/* impls */4]
                          ], match[0]);
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  try {
                    var match$2 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$1, binders);
                    var match$3 = match$2[1];
                    var pat = match$2[0];
                    var env$2 = set_env_scopes(env$1, match$3[1]);
                    var env$3 = reset_hidden_inductive_implicit_test(env$2);
                    if (match$3[0]) {
                      return term_of_name(out_var(pat));
                    } else {
                      var match$4 = Curry._3(intern_pat, ntnvars, env$3, pat);
                      var disjpat = match$4[1][0][0];
                      if (disjpat && !disjpat[1]) {
                        return Glob_ops$ReactTemplate.glob_constr_of_cases_pattern(disjpat[0]);
                      } else {
                        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot turn a disjunctive pattern into a term."));
                      }
                    }
                  }
                  catch (exn$1){
                    if (exn$1 === Caml_builtin_exceptions.not_found) {
                      try {
                        if (binderopt$1) {
                          var match$5 = binderopt$1[0];
                          if (Names$ReactTemplate.Id[/* equal */0](match$5[0], id$1)) {
                            var terms$1 = terms_of_binders(/* :: */[
                                  match$5[1],
                                  /* [] */0
                                ]);
                            if (Curry._1(Util$ReactTemplate.List[/* length */0], terms$1) !== 1) {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "constrintern.ml",
                                      793,
                                      9
                                    ]
                                  ];
                            }
                            return Curry._2(intern, env$1, Curry._1(Util$ReactTemplate.List[/* hd */1], terms$1));
                          } else {
                            throw Caml_builtin_exceptions.not_found;
                          }
                        } else {
                          throw Caml_builtin_exceptions.not_found;
                        }
                      }
                      catch (exn$2){
                        if (exn$2 === Caml_builtin_exceptions.not_found) {
                          var tmp;
                          try {
                            tmp = /* GVar */Block.__(1, [Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$1, param$2[0])]);
                          }
                          catch (exn$3){
                            if (exn$3 === Caml_builtin_exceptions.not_found) {
                              tmp = /* GVar */Block.__(1, [id$1]);
                            } else {
                              throw exn$3;
                            }
                          }
                          return DAst$ReactTemplate.make(loc, tmp);
                        } else {
                          throw exn$2;
                        }
                      }
                    } else {
                      throw exn$1;
                    }
                  }
                } else {
                  throw exn;
                }
              }
            }
            break;
        case 3 : 
            var arg = c[2];
            var knd = c[0];
            var knd$1;
            if (typeof knd === "number") {
              knd$1 = knd;
            } else if (knd.tag === 1) {
              var na = knd[0];
              if (na) {
                var id$2 = na[0];
                var na$1;
                try {
                  na$1 = Constrexpr_ops$ReactTemplate.coerce_to_name(Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$2, terms)[0])[/* v */0];
                }
                catch (exn$4){
                  if (exn$4 === Caml_builtin_exceptions.not_found) {
                    try {
                      na$1 = /* Name */[Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id$2, renaming)];
                    }
                    catch (exn$5){
                      if (exn$5 === Caml_builtin_exceptions.not_found) {
                        na$1 = na;
                      } else {
                        throw exn$5;
                      }
                    }
                  } else {
                    throw exn$4;
                  }
                }
                knd$1 = /* BinderType */Block.__(1, [na$1]);
              } else {
                knd$1 = knd;
              }
            } else {
              knd$1 = knd;
            }
            var arg$1;
            if (arg) {
              var mk_env = (function(env){
              return function mk_env(param) {
                var match = param[1];
                var c = param[0];
                var nenv_000 = /* ids */env[/* ids */0];
                var nenv_001 = /* unb */env[/* unb */1];
                var nenv_002 = /* tmp_scope */match[0];
                var nenv_003 = /* scopes */Util$ReactTemplate.$at(match[1], env[/* scopes */3]);
                var nenv_004 = /* impls */env[/* impls */4];
                var nenv = /* record */[
                  nenv_000,
                  nenv_001,
                  nenv_002,
                  nenv_003,
                  nenv_004
                ];
                var gc = Curry._2(intern, nenv, c);
                return /* tuple */[
                        gc,
                        /* Some */[c]
                      ];
              }
              }(env));
              var mk_env$prime = (function(env){
              return function mk_env$prime(param) {
                var match = param[1];
                var match$1 = match[1];
                var c = param[0];
                var nenv_000 = /* ids */env[/* ids */0];
                var nenv_001 = /* unb */env[/* unb */1];
                var nenv_002 = /* tmp_scope */match$1[0];
                var nenv_003 = /* scopes */Util$ReactTemplate.$at(match$1[1], env[/* scopes */3]);
                var nenv_004 = /* impls */env[/* impls */4];
                var nenv = /* record */[
                  nenv_000,
                  nenv_001,
                  nenv_002,
                  nenv_003,
                  nenv_004
                ];
                if (match[0]) {
                  var na = out_var(c);
                  return /* tuple */[
                          term_of_name(na),
                          /* None */0
                        ];
                } else {
                  var match$2 = Curry._3(intern_pat, ntnvars, nenv, c);
                  var disjpat = match$2[1][0][0];
                  if (disjpat && !disjpat[1]) {
                    return /* tuple */[
                            Glob_ops$ReactTemplate.glob_constr_of_cases_pattern(disjpat[0]),
                            /* None */0
                          ];
                  } else {
                    return error_cannot_coerce_disjunctive_pattern_term(c[/* loc */1], /* () */0);
                  }
                }
              }
              }(env));
              var terms$2 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* map */22], mk_env, terms);
              var binders$1 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* map */22], mk_env$prime, binders);
              var bindings = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], Names$ReactTemplate.Id[/* Map */10][/* add */3], terms$2, binders$1);
              arg$1 = /* Some */[Genintern$ReactTemplate.generic_substitute_notation(bindings, arg[0])];
            } else {
              arg$1 = /* None */0;
            }
            return DAst$ReactTemplate.make(loc, /* GHole */Block.__(13, [
                          knd$1,
                          c[1],
                          arg$1
                        ]));
        case 4 : 
            var revert = c[4];
            var y = c[1];
            var x = c[0];
            var match$6;
            try {
              var match$7 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x, termlists);
              var l = match$7[0];
              match$6 = /* tuple */[
                revert ? Curry._1(Util$ReactTemplate.List[/* rev */4], l) : l,
                match$7[1]
              ];
            }
            catch (exn$6){
              if (exn$6 === Caml_builtin_exceptions.not_found) {
                try {
                  var match$8 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x, binderlists);
                  var match$9 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                          return intern_local_binder_aux(/* None */0, intern, ntnvars, param, param$1);
                        }), /* tuple */[
                        env,
                        /* [] */0
                      ], match$8[0]);
                  var bl$prime = match$9[1];
                  match$6 = /* tuple */[
                    terms_of_binders(revert ? bl$prime : Curry._1(Util$ReactTemplate.List[/* rev */4], bl$prime)),
                    /* tuple */[
                      /* None */0,
                      /* [] */0
                    ]
                  ];
                }
                catch (exn$7){
                  if (exn$7 === Caml_builtin_exceptions.not_found) {
                    match$6 = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Inconsistent substitution of recursive notation."));
                  } else {
                    throw exn$7;
                  }
                }
              } else {
                throw exn$6;
              }
            }
            var match$10 = match$6[1];
            var subscopes = match$10[1];
            var scopt = match$10[0];
            var l$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function(terms,y,scopt,subscopes){
                return function (a) {
                  return /* AddTermIter */Block.__(1, [Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], y, /* tuple */[
                                  a,
                                  /* tuple */[
                                    scopt,
                                    subscopes
                                  ]
                                ], terms)]);
                }
                }(terms,y,scopt,subscopes)), match$6[0]);
            _c = /* NVar */Block.__(1, [Notation_ops$ReactTemplate.ldots_var]);
            _param = subinfos;
            _subst$prime = /* tuple */[
              terms,
              /* None */0,
              /* Some */[/* tuple */[
                  l$1,
                  c[3],
                  c[2]
                ]]
            ];
            continue ;
            case 5 : 
            var na$2 = c[0];
            var exit$1 = 0;
            if (na$2) {
              if (c[1].tag === 3) {
                if (option_mem_assoc(na$2[0], binderopt)) {
                  var binder = Option$ReactTemplate.get(binderopt)[1];
                  return expand_binders(loc, mkGLambda, /* :: */[
                              binder,
                              /* [] */0
                            ], aux(subst$prime, /* tuple */[
                                  renaming,
                                  env
                                ], c[2]));
                } else {
                  exit$1 = 2;
                }
              } else {
                exit = 1;
              }
            } else {
              exit$1 = 2;
            }
            if (exit$1 === 2) {
              var match$11 = c[1];
              if (match$11.tag === 3) {
                var match$12 = match$11[0];
                if (typeof match$12 === "number") {
                  exit = 1;
                } else if (match$12.tag === 1) {
                  if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], na$2, match$12[0])) {
                    var match$13 = traverse_binder(intern_pat, ntnvars, subst, avoid, subinfos, na$2);
                    var na$3 = match$13[2];
                    var ty = DAst$ReactTemplate.make(loc, /* GHole */Block.__(13, [
                            /* BinderType */Block.__(1, [na$3]),
                            match$11[1],
                            match$11[2]
                          ]));
                    return DAst$ReactTemplate.make(loc, /* GLambda */Block.__(5, [
                                  na$3,
                                  /* Explicit */0,
                                  ty,
                                  Option$ReactTemplate.fold_right((function (eta) {
                                          return (function (param) {
                                              return Notation_ops$ReactTemplate.apply_cases_pattern(/* None */0, eta, param);
                                            });
                                        }), match$13[1], aux(subst$prime, match$13[0], c[2]))
                                ]));
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
            }
            break;
        case 6 : 
            var na$4 = c[0];
            var exit$2 = 0;
            if (na$4) {
              if (c[1].tag === 3) {
                if (option_mem_assoc(na$4[0], binderopt)) {
                  var binder$1 = Option$ReactTemplate.get(binderopt)[1];
                  return expand_binders(loc, mkGProd, /* :: */[
                              binder$1,
                              /* [] */0
                            ], aux(subst$prime, /* tuple */[
                                  renaming,
                                  env
                                ], c[2]));
                } else {
                  exit$2 = 2;
                }
              } else {
                exit = 1;
              }
            } else {
              exit$2 = 2;
            }
            if (exit$2 === 2) {
              var match$14 = c[1];
              if (match$14.tag === 3) {
                var match$15 = match$14[0];
                if (typeof match$15 === "number") {
                  exit = 1;
                } else if (match$15.tag === 1) {
                  if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], na$4, match$15[0])) {
                    var match$16 = traverse_binder(intern_pat, ntnvars, subst, avoid, subinfos, na$4);
                    var na$5 = match$16[2];
                    var ty$1 = DAst$ReactTemplate.make(loc, /* GHole */Block.__(13, [
                            /* BinderType */Block.__(1, [na$5]),
                            match$14[1],
                            match$14[2]
                          ]));
                    return DAst$ReactTemplate.make(loc, /* GProd */Block.__(6, [
                                  na$5,
                                  /* Explicit */0,
                                  ty$1,
                                  Option$ReactTemplate.fold_right((function (eta) {
                                          return (function (param) {
                                              return Notation_ops$ReactTemplate.apply_cases_pattern(/* None */0, eta, param);
                                            });
                                        }), match$16[1], aux(subst$prime, match$16[0], c[2]))
                                ]));
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
            }
            break;
        case 7 : 
            var y$1 = c[1];
            try {
              var match$17 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], c[0], binderlists);
              var bl = flatten_binders(match$17[0]);
              var bl$1 = c[4] ? Curry._1(Util$ReactTemplate.List[/* rev */4], bl) : bl;
              var l$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function(y$1){
                  return function (binder) {
                    switch (binder.tag | 0) {
                      case 1 : 
                          return /* AddLetIn */Block.__(0, [
                                    binder[0],
                                    binder[1],
                                    binder[2]
                                  ]);
                      case 0 : 
                      case 2 : 
                          return /* AddPreBinderIter */Block.__(2, [
                                    y$1,
                                    binder
                                  ]);
                      
                    }
                  }
                  }(y$1)), bl$1);
              return aux(/* tuple */[
                          terms,
                          /* None */0,
                          /* Some */[/* tuple */[
                              l$2,
                              c[3],
                              c[2]
                            ]]
                        ], subinfos, /* NVar */Block.__(1, [Notation_ops$ReactTemplate.ldots_var]));
            }
            catch (exn$8){
              if (exn$8 === Caml_builtin_exceptions.not_found) {
                return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Inconsistent substitution of recursive notation."));
              } else {
                throw exn$8;
              }
            }
            break;
        default:
          exit = 1;
      }
      if (exit === 1) {
        return Notation_ops$ReactTemplate.glob_constr_of_notation_constr_with_binders(loc, (function (param, param$1) {
                      return traverse_binder(intern_pat, ntnvars, subst, avoid, param, param$1);
                    }), (function(subst$prime){
                  return function (param, param$1) {
                    return aux(subst$prime, param, param$1);
                  }
                  }(subst$prime)), subinfos, c);
      }
      
    };
  };
  return aux(/* tuple */[
              subst[0],
              /* None */0,
              /* None */0
            ], infos, c);
}

function cases_pattern_of_name(param) {
  var loc = param[/* loc */1];
  var na = param[/* v */0];
  var atom = na ? /* Some */[CAst$ReactTemplate.make(loc, /* Ident */Block.__(1, [na[0]]))] : /* None */0;
  return CAst$ReactTemplate.make(loc, /* CPatAtom */Block.__(2, [atom]));
}

function split_by_type(ids, subst) {
  var bind = function (id, scl, l, s) {
    if (l) {
      return /* tuple */[
              l[1],
              Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, /* tuple */[
                    l[0],
                    scl
                  ], s)
            ];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "constrintern.ml",
              816,
              12
            ]
          ];
    }
  };
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
          var match = param$1[1];
          var typ = match[1];
          var scl = match[0];
          var id = param$1[0];
          var match$1 = param[1];
          var binderlists$prime = match$1[3];
          var binders$prime = match$1[2];
          var termlists$prime = match$1[1];
          var terms$prime = match$1[0];
          var match$2 = param[0];
          var binderlists = match$2[3];
          var binders = match$2[2];
          var termlists = match$2[1];
          var terms = match$2[0];
          if (typeof typ === "number") {
            switch (typ) {
              case 0 : 
                  var match$3 = bind(id, scl, terms, terms$prime);
                  return /* tuple */[
                          /* tuple */[
                            match$3[0],
                            termlists,
                            binders,
                            binderlists
                          ],
                          /* tuple */[
                            match$3[1],
                            termlists$prime,
                            binders$prime,
                            binderlists$prime
                          ]
                        ];
              case 1 : 
                  var match$4 = bind(id, scl, termlists, termlists$prime);
                  return /* tuple */[
                          /* tuple */[
                            terms,
                            match$4[0],
                            binders,
                            binderlists
                          ],
                          /* tuple */[
                            terms$prime,
                            match$4[1],
                            binders$prime,
                            binderlists$prime
                          ]
                        ];
              case 2 : 
                  var match$5 = bind(id, scl, binderlists, binderlists$prime);
                  return /* tuple */[
                          /* tuple */[
                            terms,
                            termlists,
                            binders,
                            match$5[0]
                          ],
                          /* tuple */[
                            terms$prime,
                            termlists$prime,
                            binders$prime,
                            match$5[1]
                          ]
                        ];
              
            }
          } else {
            var x = typ[0];
            var exit = 0;
            if (typeof x === "number") {
              exit = 1;
            } else if (x.tag) {
              if (x[0] !== 0) {
                var match$6;
                if (terms) {
                  match$6 = /* tuple */[
                    terms[0],
                    terms[1]
                  ];
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "constrintern.ml",
                          825,
                          65
                        ]
                      ];
                }
                var binders$prime$1 = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, /* tuple */[
                      Constrexpr_ops$ReactTemplate.coerce_to_cases_pattern_expr(match$6[0]),
                      /* tuple */[
                        /* false */0,
                        scl
                      ]
                    ], binders$prime);
                return /* tuple */[
                        /* tuple */[
                          match$6[1],
                          termlists,
                          binders,
                          binderlists
                        ],
                        /* tuple */[
                          terms$prime,
                          termlists$prime,
                          binders$prime$1,
                          binderlists$prime
                        ]
                      ];
              } else {
                var match$7;
                if (terms) {
                  match$7 = /* tuple */[
                    terms[0],
                    terms[1]
                  ];
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "constrintern.ml",
                          829,
                          65
                        ]
                      ];
                }
                var binders$prime$2 = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, /* tuple */[
                      cases_pattern_of_name(Constrexpr_ops$ReactTemplate.coerce_to_name(match$7[0])),
                      /* tuple */[
                        /* true */1,
                        scl
                      ]
                    ], binders$prime);
                return /* tuple */[
                        /* tuple */[
                          match$7[1],
                          termlists,
                          binders,
                          binderlists
                        ],
                        /* tuple */[
                          terms$prime,
                          termlists$prime,
                          binders$prime$2,
                          binderlists$prime
                        ]
                      ];
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              var onlyident = +(x === /* NtnParsedAsIdent */0);
              var match$8 = bind(id, /* tuple */[
                    onlyident,
                    scl
                  ], binders, binders$prime);
              return /* tuple */[
                      /* tuple */[
                        terms,
                        termlists,
                        match$8[0],
                        binderlists
                      ],
                      /* tuple */[
                        terms$prime,
                        termlists$prime,
                        match$8[1],
                        binderlists$prime
                      ]
                    ];
            }
            
          }
        }), /* tuple */[
        subst,
        /* tuple */[
          Names$ReactTemplate.Id[/* Map */10][/* empty */0],
          Names$ReactTemplate.Id[/* Map */10][/* empty */0],
          Names$ReactTemplate.Id[/* Map */10][/* empty */0],
          Names$ReactTemplate.Id[/* Map */10][/* empty */0]
        ]
      ], ids);
  var match$1 = match[0];
  if (!(match$1[0] === /* [] */0 && match$1[1] === /* [] */0 && match$1[2] === /* [] */0 && match$1[3] === /* [] */0)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "constrintern.ml",
            843,
            2
          ]
        ];
  }
  return match[1];
}

function split_by_type_pat(loc, ids, subst) {
  var bind = function (id, scl, l, s) {
    if (l) {
      return /* tuple */[
              l[1],
              Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, /* tuple */[
                    l[0],
                    scl
                  ], s)
            ];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "constrintern.ml",
              849,
              12
            ]
          ];
    }
  };
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
          var match = param$1[1];
          var typ = match[1];
          var scl = match[0];
          var id = param$1[0];
          var match$1 = param[1];
          var termlists$prime = match$1[1];
          var terms$prime = match$1[0];
          var match$2 = param[0];
          var termlists = match$2[1];
          var terms = match$2[0];
          var exit = 0;
          if (typeof typ === "number") {
            switch (typ) {
              case 0 : 
                  exit = 1;
                  break;
              case 1 : 
                  var match$3 = bind(id, scl, termlists, termlists$prime);
                  return /* tuple */[
                          /* tuple */[
                            terms,
                            match$3[0]
                          ],
                          /* tuple */[
                            terms$prime,
                            match$3[1]
                          ]
                        ];
              case 2 : 
                  return Constrexpr_ops$ReactTemplate.error_invalid_pattern_notation(loc, /* () */0);
              
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var match$4 = bind(id, scl, terms, terms$prime);
            return /* tuple */[
                    /* tuple */[
                      match$4[0],
                      termlists
                    ],
                    /* tuple */[
                      match$4[1],
                      termlists$prime
                    ]
                  ];
          }
          
        }), /* tuple */[
        subst,
        /* tuple */[
          Names$ReactTemplate.Id[/* Map */10][/* empty */0],
          Names$ReactTemplate.Id[/* Map */10][/* empty */0]
        ]
      ], ids);
  var match$1 = match[0];
  if (!(match$1[0] === /* [] */0 && match$1[1] === /* [] */0)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "constrintern.ml",
            862,
            2
          ]
        ];
  }
  return match[1];
}

function make_subst(ids, l) {
  var fold = function (accu, param, a) {
    return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], param[0], /* tuple */[
                a,
                param[1]
              ], accu);
  };
  return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], fold, Names$ReactTemplate.Id[/* Map */10][/* empty */0], ids, l);
}

function intern_notation(intern, env, ntnvars, loc, ntn, fullargs) {
  var match = contract_curly_brackets(ntn, fullargs);
  var match$1 = Notation$ReactTemplate.interp_notation(loc, match[0], /* tuple */[
        env[/* tmp_scope */2],
        env[/* scopes */3]
      ]);
  var match$2 = match$1[0];
  var subst = split_by_type(match$2[0], match[1]);
  return instantiate_notation_constr(loc, intern, (function (eta) {
                return (function (param, param$1) {
                    return intern_cases_pattern_as_binder(/* None */0, eta, param, param$1);
                  });
              }), ntnvars, subst, /* tuple */[
              Names$ReactTemplate.Id[/* Map */10][/* empty */0],
              env
            ], match$2[1]);
}

function string_of_ty(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return "def";
      case 1 : 
          return "meth";
      case 2 : 
          return "var";
      
    }
  } else {
    return "ind";
  }
}

function gvar(param, us) {
  var id = param[1];
  var loc = param[0];
  if (us) {
    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Variable "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(" cannot have a universe instance")));
  } else {
    return DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [id]));
  }
}

function intern_var(env, param, namedctx, loc, id, us) {
  var ntnvars = param[1];
  var ltacvars = param[0];
  if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id, ntnvars)) {
    if (!Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id, env[/* impls */4])) {
      set_var_scope(loc, id, /* true */1, /* tuple */[
            env[/* tmp_scope */2],
            env[/* scopes */3]
          ], ntnvars);
    }
    return /* tuple */[
            gvar(/* tuple */[
                  loc,
                  id
                ], us),
            /* [] */0,
            /* [] */0,
            /* [] */0
          ];
  } else {
    try {
      var match = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, env[/* impls */4]);
      var expl_impls = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
              return /* tuple */[
                      CAst$ReactTemplate.make(loc, /* CRef */Block.__(0, [
                              CAst$ReactTemplate.make(loc, /* Ident */Block.__(1, [id])),
                              /* None */0
                            ])),
                      /* Some */[CAst$ReactTemplate.make(loc, /* ExplByName */Block.__(1, [id]))]
                    ];
            }), match[1]);
      string_of_ty(match[0]);
      return /* tuple */[
              gvar(/* tuple */[
                    loc,
                    id
                  ], us),
              Impargs$ReactTemplate.make_implicits_list(match[2]),
              match[3],
              expl_impls
            ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, env[/* ids */0]) || Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, ltacvars[/* ltac_vars */0])) {
          return /* tuple */[
                  gvar(/* tuple */[
                        loc,
                        id
                      ], us),
                  /* [] */0,
                  /* [] */0,
                  /* [] */0
                ];
        } else if (Names$ReactTemplate.Id[/* equal */0](id, Notation_ops$ReactTemplate.ldots_var)) {
          if (Curry._1(Names$ReactTemplate.Id[/* Map */10][/* is_empty */1], ntnvars)) {
            return error_ldots_var(loc);
          } else {
            return /* tuple */[
                    gvar(/* tuple */[
                          loc,
                          id
                        ], us),
                    /* [] */0,
                    /* [] */0,
                    /* [] */0
                  ];
          }
        } else if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, ltacvars[/* ltac_bound */1])) {
          return CErrors$ReactTemplate.user_err(loc, /* Some */["intern_var"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("variable "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(" should be bound to a term.")));
        } else {
          Context$ReactTemplate.Named[/* lookup */4](id, namedctx);
          try {
            var ref = /* VarRef */Block.__(0, [id]);
            var impls = Impargs$ReactTemplate.implicits_of_global(ref);
            var scopes = Notation$ReactTemplate.find_arguments_scope(ref);
            return /* tuple */[
                    DAst$ReactTemplate.make(loc, /* GRef */Block.__(0, [
                            ref,
                            us
                          ])),
                    impls,
                    scopes,
                    /* [] */0
                  ];
          }
          catch (raw_e){
            var e = Js_exn.internalToOCamlException(raw_e);
            if (CErrors$ReactTemplate.noncritical(e)) {
              return /* tuple */[
                      gvar(/* tuple */[
                            loc,
                            id
                          ], us),
                      /* [] */0,
                      /* [] */0,
                      /* [] */0
                    ];
            } else {
              throw e;
            }
          }
        }
      } else {
        throw exn;
      }
    }
  }
}

function find_appl_head_data(c) {
  var match = DAst$ReactTemplate.get(c);
  switch (match.tag | 0) {
    case 0 : 
        var ref = match[0];
        var impls = Impargs$ReactTemplate.implicits_of_global(ref);
        var scopes = Notation$ReactTemplate.find_arguments_scope(ref);
        return /* tuple */[
                c,
                impls,
                scopes,
                /* [] */0
              ];
    case 4 : 
        var l = match[1];
        var match$1 = DAst$ReactTemplate.get(match[0]);
        if (match$1.tag) {
          return /* tuple */[
                  c,
                  /* [] */0,
                  /* [] */0,
                  /* [] */0
                ];
        } else if (l !== /* [] */0) {
          var ref$1 = match$1[0];
          var n = Curry._1(Util$ReactTemplate.List[/* length */0], l);
          var impls$1 = Impargs$ReactTemplate.implicits_of_global(ref$1);
          var scopes$1 = Notation$ReactTemplate.find_arguments_scope(ref$1);
          return /* tuple */[
                  c,
                  Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                          return Impargs$ReactTemplate.drop_first_implicits(n, param);
                        }), impls$1),
                  Curry._2(Util$ReactTemplate.List[/* skipn_at_least */108], n, scopes$1),
                  /* [] */0
                ];
        } else {
          return /* tuple */[
                  c,
                  /* [] */0,
                  /* [] */0,
                  /* [] */0
                ];
        }
        break;
    default:
      return /* tuple */[
              c,
              /* [] */0,
              /* [] */0,
              /* [] */0
            ];
  }
}

function error_not_enough_arguments(loc) {
  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("Abbreviation is not applied enough."));
}

function check_no_explicitation(l) {
  var is_unset = function (param) {
    if (param[1]) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  };
  var l$1 = Curry._2(Util$ReactTemplate.List[/* filter */27], is_unset, l);
  if (l$1) {
    var match = l$1[0][1];
    if (match) {
      return CErrors$ReactTemplate.user_err(match[0][/* loc */1], /* None */0, Pp$ReactTemplate.str("Unexpected explicitation of the argument of an abbreviation."));
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "constrintern.ml",
              966,
              22
            ]
          ];
    }
  } else {
    return /* () */0;
  }
}

function intern_extended_global_of_qualid() {
  return Pervasives.failwith("unimplemented: intern_extended_global_of_qualid");
}

function sort_info_of_level_info(info) {
  if (typeof info === "number") {
    return /* None */0;
  } else {
    return /* Some */[/* tuple */[
              info[0],
              0
            ]];
  }
}

function glob_sort_of_level(level) {
  if (typeof level === "number") {
    if (level !== 0) {
      return /* GSet */1;
    } else {
      return /* GProp */0;
    }
  } else {
    return /* GType */[/* :: */[
              sort_info_of_level_info(level[0]),
              /* [] */0
            ]];
  }
}

function intern_qualid(qid, intern, env, ntnvars, us, args) {
  var loc = qid[/* loc */1];
  var match = intern_extended_global_of_qualid(qid);
  if (match.tag) {
    var match$1 = Syntax_def$ReactTemplate.search_syntactic_definition(match[0]);
    var c = match$1[1];
    var ids = match$1[0];
    var nids = Curry._1(Util$ReactTemplate.List[/* length */0], ids);
    if (Curry._1(Util$ReactTemplate.List[/* length */0], args) < nids) {
      error_not_enough_arguments(loc);
    }
    var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], nids, args);
    var args1 = match$2[0];
    check_no_explicitation(args1);
    var terms = make_subst(ids, Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                return prim[0];
              }), args1));
    var subst_001 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];
    var subst_002 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];
    var subst_003 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];
    var subst = /* tuple */[
      terms,
      subst_001,
      subst_002,
      subst_003
    ];
    var infos_000 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];
    var infos = /* tuple */[
      infos_000,
      env
    ];
    var projapp;
    projapp = c.tag ? /* false */0 : /* true */1;
    var c$1 = instantiate_notation_constr(loc, intern, (function (eta) {
            return (function (param, param$1) {
                return intern_cases_pattern_as_binder(/* None */0, eta, param, param$1);
              });
          }), ntnvars, subst, infos, c);
    var loc$1 = c$1[/* loc */1];
    var err = function () {
      return CErrors$ReactTemplate.user_err(loc$1, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation "), Libnames$ReactTemplate.pr_qualid(qid[/* v */0])), Pp$ReactTemplate.str(" cannot have a universe instance,")), Pp$ReactTemplate.str(" its expanded head does not start with a reference")));
    };
    var match$3 = DAst$ReactTemplate.get(c$1);
    var c$2;
    if (us) {
      var match$4 = us[0];
      switch (match$3.tag | 0) {
        case 0 : 
            c$2 = match$3[1] ? err(/* () */0) : DAst$ReactTemplate.make(loc$1, /* GRef */Block.__(0, [
                      match$3[0],
                      us
                    ]));
            break;
        case 4 : 
            var r = match$3[0];
            var loc$prime = r[/* loc */1];
            var match$5 = DAst$ReactTemplate.get(r);
            c$2 = !match$5.tag && !match$5[1] ? DAst$ReactTemplate.make(loc$1, /* GApp */Block.__(4, [
                      DAst$ReactTemplate.make(loc$prime, /* GRef */Block.__(0, [
                              match$5[0],
                              us
                            ])),
                      match$3[1]
                    ])) : err(/* () */0);
            break;
        case 12 : 
            if (match$4) {
              if (match$4[1]) {
                c$2 = err(/* () */0);
              } else {
                var _new_sort = match$3[0];
                var exit = 0;
                if (typeof _new_sort === "number" || _new_sort[0]) {
                  exit = 1;
                } else {
                  c$2 = DAst$ReactTemplate.make(loc$1, /* GSort */Block.__(12, [glob_sort_of_level(match$4[0])]));
                }
                if (exit === 1) {
                  c$2 = CErrors$ReactTemplate.user_err(loc$1, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot change universe level of notation "), Libnames$ReactTemplate.pr_qualid(qid[/* v */0])));
                }
                
              }
            } else {
              c$2 = err(/* () */0);
            }
            break;
        default:
          c$2 = err(/* () */0);
      }
    } else {
      c$2 = c$1;
    }
    return /* tuple */[
            c$2,
            projapp,
            match$2[1]
          ];
  } else {
    return /* tuple */[
            DAst$ReactTemplate.make(loc, /* GRef */Block.__(0, [
                    match[0],
                    us
                  ])),
            /* true */1,
            args
          ];
  }
}

function intern_non_secvar_qualid(qid, intern, env, ntnvars, us, args) {
  var r = intern_qualid(qid, intern, env, ntnvars, us, args);
  var match = DAst$ReactTemplate.get(r[0]);
  if (match.tag) {
    return r;
  } else if (match[0].tag) {
    return r;
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function intern_applied_reference(intern, env, namedctx, lvar, us, args, param) {
  var match = param[/* v */0];
  var ntnvars = lvar[1];
  if (match.tag) {
    var loc = param[/* loc */1];
    var id = match[0];
    try {
      return /* tuple */[
              intern_var(env, lvar, namedctx, loc, id, us),
              args
            ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var qid = CAst$ReactTemplate.make(loc, Libnames$ReactTemplate.qualid_of_ident(id));
        try {
          var match$1 = intern_non_secvar_qualid(qid, intern, env, ntnvars, us, args);
          var match$2 = find_appl_head_data(match$1[0]);
          return /* tuple */[
                  /* tuple */[
                    match$2[0],
                    match$2[1],
                    match$2[2],
                    match$2[3]
                  ],
                  match$1[2]
                ];
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            if (interning_grammar[0] || env[/* unb */1]) {
              return /* tuple */[
                      /* tuple */[
                        gvar(/* tuple */[
                              loc,
                              id
                            ], us),
                        /* [] */0,
                        /* [] */0,
                        /* [] */0
                      ],
                      args
                    ];
            } else {
              return Nametab$ReactTemplate.error_global_not_found(qid);
            }
          } else {
            throw exn$1;
          }
        }
      } else {
        throw exn;
      }
    }
  } else {
    var qid$1 = CAst$ReactTemplate.make(param[/* loc */1], match[0]);
    var match$3;
    try {
      match$3 = intern_qualid(qid$1, intern, env, ntnvars, us, args);
    }
    catch (exn$2){
      if (exn$2 === Caml_builtin_exceptions.not_found) {
        match$3 = Nametab$ReactTemplate.error_global_not_found(qid$1);
      } else {
        throw exn$2;
      }
    }
    var match$4 = find_appl_head_data(match$3[0]);
    return /* tuple */[
            /* tuple */[
              match$4[0],
              match$4[1],
              match$4[2],
              match$4[3]
            ],
            match$3[2]
          ];
  }
}

function interp_reference(vars, r) {
  var match = intern_applied_reference((function () {
          return error_not_enough_arguments(/* None */0);
        }), /* record */[
        /* ids */Names$ReactTemplate.Id[/* Set */9][/* empty */0],
        /* unb : false */0,
        /* tmp_scope : None */0,
        /* scopes : [] */0,
        /* impls */empty_internalization_env
      ], /* [] */0, /* tuple */[
        vars,
        Names$ReactTemplate.Id[/* Map */10][/* empty */0]
      ], /* None */0, /* [] */0, r);
  return match[0][0];
}

function apply_scope_env(env, param) {
  if (param) {
    return /* tuple */[
            /* record */[
              /* ids */env[/* ids */0],
              /* unb */env[/* unb */1],
              /* tmp_scope */param[0],
              /* scopes */env[/* scopes */3],
              /* impls */env[/* impls */4]
            ],
            param[1]
          ];
  } else {
    return /* tuple */[
            /* record */[
              /* ids */env[/* ids */0],
              /* unb */env[/* unb */1],
              /* tmp_scope : None */0,
              /* scopes */env[/* scopes */3],
              /* impls */env[/* impls */4]
            ],
            /* [] */0
          ];
  }
}

function simple_adjust_scopes(n, scopes) {
  if (n) {
    if (scopes) {
      return /* :: */[
              scopes[0],
              simple_adjust_scopes(n - 1 | 0, scopes[1])
            ];
    } else {
      return /* :: */[
              /* None */0,
              simple_adjust_scopes(n - 1 | 0, /* [] */0)
            ];
    }
  } else {
    return /* [] */0;
  }
}

function find_remaining_scopes(pl1, pl2, ref) {
  var impls_st = Impargs$ReactTemplate.implicits_of_global(ref);
  var len_pl1 = Curry._1(Util$ReactTemplate.List[/* length */0], pl1);
  var len_pl2 = Curry._1(Util$ReactTemplate.List[/* length */0], pl2);
  var impl_list = len_pl1 ? Curry._2(Util$ReactTemplate.List[/* skipn_at_least */108], len_pl1, Impargs$ReactTemplate.select_stronger_impargs(impls_st)) : Impargs$ReactTemplate.select_impargs_size(len_pl2, impls_st);
  var allscs = Notation$ReactTemplate.find_arguments_scope(ref);
  var scope_list = Curry._2(Util$ReactTemplate.List[/* skipn_at_least */108], len_pl1, allscs);
  var aux = function (_param) {
    while(true) {
      var param = _param;
      var match = param[0];
      if (match) {
        var match$1 = param[1];
        if (match$1) {
          var tt = match$1[1];
          var t = match[1];
          if (Impargs$ReactTemplate.is_status_implicit(match[0])) {
            _param = /* tuple */[
              t,
              tt
            ];
            continue ;
            
          } else {
            return /* :: */[
                    match$1[0],
                    aux(/* tuple */[
                          t,
                          tt
                        ])
                  ];
          }
        } else {
          return /* [] */0;
        }
      } else {
        return param[1];
      }
    };
  };
  var tmp;
  try {
    tmp = Curry._2(Util$ReactTemplate.List[/* firstn */104], len_pl1, allscs);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      tmp = simple_adjust_scopes(len_pl1, allscs);
    } else {
      throw exn;
    }
  }
  return /* tuple */[
          tmp,
          simple_adjust_scopes(len_pl2, aux(/* tuple */[
                    impl_list,
                    scope_list
                  ]))
        ];
}

function has_duplicate(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      var x = param[0];
      if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], x, l)) {
        return /* Some */[x];
      } else {
        _param = l;
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function loc_of_multiple_pattern(pl) {
  return Loc$ReactTemplate.merge_opt(Constrexpr_ops$ReactTemplate.cases_pattern_expr_loc(Curry._1(Util$ReactTemplate.List[/* hd */1], pl)), Constrexpr_ops$ReactTemplate.cases_pattern_expr_loc(Curry._1(Util$ReactTemplate.List[/* last */105], pl)));
}

function loc_of_lhs(lhs) {
  return Loc$ReactTemplate.merge_opt(loc_of_multiple_pattern(Curry._1(Util$ReactTemplate.List[/* hd */1], lhs)), loc_of_multiple_pattern(Curry._1(Util$ReactTemplate.List[/* last */105], lhs)));
}

function check_linearity(lhs, ids) {
  var match = has_duplicate(ids);
  if (match) {
    throw [
          InternalizationError,
          /* tuple */[
            loc_of_lhs(lhs),
            /* NonLinearPattern */Block.__(3, [match[0]])
          ]
        ];
  } else {
    return /* () */0;
  }
}

function check_number_of_pattern(loc, n, l) {
  var p = Curry._1(Util$ReactTemplate.List[/* length */0], l);
  if (n !== p) {
    throw [
          InternalizationError,
          /* tuple */[
            loc,
            /* BadPatternsNumber */Block.__(4, [
                n,
                p
              ])
          ]
        ];
  } else {
    return 0;
  }
}

function check_or_pat_variables(loc, ids, idsl) {
  if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (ids$prime) {
            return 1 - Curry._3(Util$ReactTemplate.List[/* eq_set */49], (function (param, param$1) {
                          return Names$ReactTemplate.Id[/* equal */0](param[/* v */0], param$1[/* v */0]);
                        }), ids, ids$prime);
          }), idsl)) {
    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("The components of this disjunctive pattern must bind the same variables."));
  } else {
    return 0;
  }
}

function check_constructor_length(env, loc, cstr, len_pl, pl0) {
  var n = len_pl + Curry._1(Util$ReactTemplate.List[/* length */0], pl0) | 0;
  if (n === Inductiveops$ReactTemplate.constructor_nallargs(cstr)) {
    return /* false */0;
  } else if (n === Inductiveops$ReactTemplate.constructor_nalldecls(cstr)) {
    return /* true */1;
  } else {
    return Cases$ReactTemplate.error_wrong_numarg_constructor(loc, env, cstr, Inductiveops$ReactTemplate.constructor_nrealargs(cstr));
  }
}

function insert_local_defs_in_pattern(param, l) {
  var j = param[1];
  var match = Global$ReactTemplate.lookup_inductive(param[0]);
  var mip = match[1];
  if (Caml_array.caml_array_get(mip[/* mind_consnrealdecls */10], j - 1 | 0) === Caml_array.caml_array_get(mip[/* mind_consnrealargs */9], j - 1 | 0)) {
    return l;
  } else {
    var typi = Caml_array.caml_array_get(mip[/* mind_nf_lc */8], j - 1 | 0);
    var match$1 = Term$ReactTemplate.decompose_prod_n_assum(Curry._1(Context$ReactTemplate.Rel[/* length */3], match[0][/* mind_params_ctxt */7]))(typi);
    var match$2 = Term$ReactTemplate.decompose_prod_assum(match$1[1]);
    var aux = function (decls, args) {
      var exit = 0;
      if (decls) {
        if (decls[0].tag) {
          return /* :: */[
                  DAst$ReactTemplate.make(/* None */0, /* RCPatAtom */Block.__(2, [/* None */0])),
                  aux(decls[1], args)
                ];
        } else if (args) {
          return /* :: */[
                  args[0],
                  aux(decls[1], args[1])
                ];
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (args) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "constrintern.ml",
                  1178,
                  13
                ]
              ];
        } else {
          return /* [] */0;
        }
      }
      
    };
    return aux(Curry._1(Util$ReactTemplate.List[/* rev */4], match$2[0]), l);
  }
}

function add_local_defs_and_check_length(loc, env, g, pl, args) {
  if (g.tag === 3) {
    var cstr = g[0];
    var pl$prime = insert_local_defs_in_pattern(cstr, pl);
    var maxargs = Inductiveops$ReactTemplate.constructor_nalldecls(cstr);
    if ((Curry._1(Util$ReactTemplate.List[/* length */0], pl$prime) + Curry._1(Util$ReactTemplate.List[/* length */0], args) | 0) > maxargs) {
      Cases$ReactTemplate.error_wrong_numarg_constructor(loc, env, cstr, Inductiveops$ReactTemplate.constructor_nrealargs(cstr));
    }
    if ((Curry._1(Util$ReactTemplate.List[/* length */0], pl$prime) + Curry._1(Util$ReactTemplate.List[/* length */0], args) | 0) === maxargs) {
      return pl$prime;
    } else {
      return pl;
    }
  } else {
    return pl;
  }
}

function add_implicits_check_length(fail, nargs, nargs_with_letin, impls_st, len_pl1, pl2) {
  var impl_list = len_pl1 ? Curry._2(Util$ReactTemplate.List[/* skipn_at_least */108], len_pl1, Impargs$ReactTemplate.select_stronger_impargs(impls_st)) : Impargs$ReactTemplate.select_impargs_size(Curry._1(Util$ReactTemplate.List[/* length */0], pl2), impls_st);
  var remaining_args = Curry._1(Util$ReactTemplate.List[/* fold_left */13], (function (i, x) {
          if (Impargs$ReactTemplate.is_status_implicit(x)) {
            return i;
          } else {
            return i + 1 | 0;
          }
        }));
  var aux = function (i, param) {
    var il = param[0];
    if (il) {
      var l = param[1];
      var q = il[1];
      var imp = il[0];
      if (l) {
        if (Impargs$ReactTemplate.is_status_implicit(imp)) {
          var match = aux(i, /* tuple */[
                q,
                l
              ]);
          return /* tuple */[
                  match[0],
                  /* :: */[
                    DAst$ReactTemplate.make(/* None */0, /* RCPatAtom */Block.__(2, [/* None */0])),
                    match[1]
                  ]
                ];
        } else {
          var match$1 = aux(i + 1 | 0, /* tuple */[
                q,
                l[1]
              ]);
          return /* tuple */[
                  match$1[0],
                  /* :: */[
                    l[0],
                    match$1[1]
                  ]
                ];
        }
      } else if (Impargs$ReactTemplate.is_status_implicit(imp) && Impargs$ReactTemplate.maximal_insertion_of(imp)) {
        var match$2 = aux(i, /* tuple */[
              q,
              /* [] */0
            ]);
        return /* tuple */[
                match$2[0],
                /* :: */[
                  DAst$ReactTemplate.make(/* None */0, /* RCPatAtom */Block.__(2, [/* None */0])),
                  match$2[1]
                ]
              ];
      } else {
        return Curry._1(fail, Curry._2(remaining_args, len_pl1 + i | 0, il));
      }
    } else {
      var l$1 = param[1];
      var args_len = (Curry._1(Util$ReactTemplate.List[/* length */0], l$1) + Curry._1(Util$ReactTemplate.List[/* length */0], impl_list) | 0) + len_pl1 | 0;
      return /* tuple */[
              args_len === nargs ? /* false */0 : +(args_len === nargs_with_letin) || Curry._1(fail, (nargs - Curry._1(Util$ReactTemplate.List[/* length */0], impl_list) | 0) + i | 0)[0],
              l$1
            ];
    }
  };
  return aux(0, /* tuple */[
              impl_list,
              pl2
            ]);
}

function add_implicits_check_constructor_length(env, loc, c, len_pl1, pl2) {
  var nargs = Inductiveops$ReactTemplate.constructor_nallargs(c);
  var nargs$prime = Inductiveops$ReactTemplate.constructor_nalldecls(c);
  var impls_st = Impargs$ReactTemplate.implicits_of_global(/* ConstructRef */Block.__(3, [c]));
  return add_implicits_check_length((function (param) {
                return Cases$ReactTemplate.error_wrong_numarg_constructor(loc, env, c, param);
              }), nargs, nargs$prime, impls_st, len_pl1, pl2);
}

function add_implicits_check_ind_length(env, loc, c, len_pl1, pl2) {
  var nallargs = Inductiveops$ReactTemplate.inductive_nallargs_env(env, c);
  var nalldecls = Inductiveops$ReactTemplate.inductive_nalldecls_env(env, c);
  var impls_st = Impargs$ReactTemplate.implicits_of_global(/* IndRef */Block.__(2, [c]));
  return add_implicits_check_length((function (param) {
                return Cases$ReactTemplate.error_wrong_numarg_inductive(loc, env, c, param);
              }), nallargs, nalldecls, impls_st, len_pl1, pl2);
}

function chop_params_pattern(_, ind, args, with_letin) {
  var nparams = with_letin ? Inductiveops$ReactTemplate.inductive_nparamdecls(ind) : Inductiveops$ReactTemplate.inductive_nparams(ind);
  if (nparams > Curry._1(Util$ReactTemplate.List[/* length */0], args)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "constrintern.ml",
            1237,
            2
          ]
        ];
  }
  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], nparams, args);
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (c) {
          var match = DAst$ReactTemplate.get(c);
          if (!match.tag && !match[0]) {
            return /* () */0;
          } else {
            var loc = c[/* loc */1];
            return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The parameters do not bind in patterns;"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("they must be replaced by '_'.")));
          }
        }), match[0]);
  return match[1];
}

function find_constructor(loc, add_params, ref) {
  var cstr;
  var exit = 0;
  switch (ref.tag | 0) {
    case 0 : 
    case 1 : 
        exit = 1;
        break;
    case 2 : 
        var error = Pp$ReactTemplate.str("There is an inductive name deep in a \"in\" clause.");
        cstr = CErrors$ReactTemplate.user_err(loc, /* Some */["find_constructor"], error);
        break;
    case 3 : 
        cstr = ref[0];
        break;
    
  }
  if (exit === 1) {
    var error$1 = Pp$ReactTemplate.str("This reference is not a constructor.");
    cstr = CErrors$ReactTemplate.user_err(loc, /* Some */["find_constructor"], error$1);
  }
  var ind = cstr[0];
  var tmp;
  if (add_params) {
    var nb = add_params[0] === Inductiveops$ReactTemplate.constructor_nrealdecls(cstr) ? Inductiveops$ReactTemplate.inductive_nparamdecls(ind) : Inductiveops$ReactTemplate.inductive_nparams(ind);
    tmp = Curry._2(Util$ReactTemplate.List[/* make */56], nb, /* tuple */[
          /* [] */0,
          /* :: */[
            /* tuple */[
              Names$ReactTemplate.Id[/* Map */10][/* empty */0],
              DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0]))
            ],
            /* [] */0
          ]
        ]);
  } else {
    tmp = /* [] */0;
  }
  return /* tuple */[
          cstr,
          tmp
        ];
}

function find_pattern_variable(x) {
  var match = x[/* v */0];
  if (match.tag) {
    return match[0];
  } else {
    throw [
          InternalizationError,
          /* tuple */[
            x[/* loc */1],
            /* NotAConstructor */Block.__(1, [x])
          ]
        ];
  }
}

function check_duplicate(loc, fields) {
  var eq = function (param, param$1) {
    return Libnames$ReactTemplate.eq_reference(param[0], param$1[0]);
  };
  var dups = Curry._2(Util$ReactTemplate.List[/* duplicates */60], eq, fields);
  if (dups) {
    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("This record defines several times the field "), Libnames$ReactTemplate.pr_reference(dups[0][0])), Pp$ReactTemplate.str(".")));
  } else {
    return /* () */0;
  }
}

function sort_fields(complete, loc, fields, completer) {
  if (fields) {
    var match = fields[0];
    var first_field_ref = match[0];
    var match$1;
    try {
      var qid = Libnames$ReactTemplate.qualid_of_reference(first_field_ref)[/* v */0];
      var gr = Curry._1(Smartlocate$ReactTemplate.global_of_extended_global, Nametab$ReactTemplate.locate_extended(qid));
      match$1 = /* tuple */[
        gr,
        Recordops$ReactTemplate.find_projection(gr)
      ];
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        match$1 = CErrors$ReactTemplate.user_err(loc, /* Some */["intern"], Pp$ReactTemplate.$plus$plus(Libnames$ReactTemplate.pr_reference(first_field_ref), Pp$ReactTemplate.str(": Not a projection")));
      } else {
        throw exn;
      }
    }
    var record = match$1[1];
    var first_field_glob_ref = match$1[0];
    var nparams = record[/* s_EXPECTEDPARAM */1];
    var global_record_id = /* ConstructRef */Block.__(3, [record[/* s_CONST */0]]);
    var base_constructor;
    try {
      base_constructor = CAst$ReactTemplate.make(loc, /* Qualid */Block.__(0, [Nametab$ReactTemplate.shortest_qualid_of_global(Names$ReactTemplate.Id[/* Set */9][/* empty */0], global_record_id)]));
    }
    catch (exn$1){
      if (exn$1 === Caml_builtin_exceptions.not_found) {
        base_constructor = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Environment corruption for records."));
      } else {
        throw exn$1;
      }
    }
    check_duplicate(loc, fields);
    var build_proj_list = function (_projs, _proj_kinds, _idx, _acc_first_idx, _acc) {
      while(true) {
        var acc = _acc;
        var acc_first_idx = _acc_first_idx;
        var idx = _idx;
        var proj_kinds = _proj_kinds;
        var projs = _projs;
        if (projs) {
          var match = projs[0];
          if (match) {
            var projs$1 = projs[1];
            var field_glob_id = match[0];
            var field_glob_ref = /* ConstRef */Block.__(1, [field_glob_id]);
            var first_field = Globnames$ReactTemplate.eq_gr(field_glob_ref, first_field_glob_ref);
            if (proj_kinds) {
              var proj_kinds$1 = proj_kinds[1];
              var regular = proj_kinds[0][1];
              if (first_field && !regular && complete) {
                return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("No local fields allowed in a record construction."));
              } else if (first_field) {
                _acc_first_idx = idx;
                _idx = idx + 1 | 0;
                _proj_kinds = proj_kinds$1;
                _projs = projs$1;
                continue ;
                
              } else if (!regular && complete) {
                _proj_kinds = proj_kinds$1;
                _projs = projs$1;
                continue ;
                
              } else {
                _acc = /* :: */[
                  /* tuple */[
                    idx,
                    field_glob_id
                  ],
                  acc
                ];
                _idx = idx + 1 | 0;
                _proj_kinds = proj_kinds$1;
                _projs = projs$1;
                continue ;
                
              }
            } else {
              return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Number of projections mismatch."));
            }
          } else if (complete) {
            return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("This record contains anonymous fields."));
          } else {
            _idx = idx + 1 | 0;
            _projs = projs[1];
            continue ;
            
          }
        } else {
          return /* tuple */[
                  idx,
                  acc_first_idx,
                  acc
                ];
        }
      };
    };
    var match$2 = build_proj_list(record[/* s_PROJ */3], record[/* s_PROJKIND */2], 1, 0, /* [] */0);
    var index_fields = function (_fields, _remaining_projs, _acc) {
      while(true) {
        var acc = _acc;
        var remaining_projs = _remaining_projs;
        var fields = _fields;
        if (fields) {
          var match = fields[0];
          var field_ref = match[0];
          var field_glob_ref;
          try {
            var qid = Libnames$ReactTemplate.qualid_of_reference(field_ref)[/* v */0];
            field_glob_ref = Curry._1(Smartlocate$ReactTemplate.global_of_extended_global, Nametab$ReactTemplate.locate_extended(qid));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              field_glob_ref = CErrors$ReactTemplate.user_err(loc, /* Some */["intern"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The field \""), Libnames$ReactTemplate.pr_reference(field_ref)), Pp$ReactTemplate.str("\" does not exist.")));
            } else {
              throw exn;
            }
          }
          var the_proj = (function(field_glob_ref){
          return function the_proj(param) {
            return Globnames$ReactTemplate.eq_gr(field_glob_ref, /* ConstRef */Block.__(1, [param[1]]));
          }
          }(field_glob_ref));
          var match$1;
          try {
            match$1 = CList$ReactTemplate.extract_first(the_proj, remaining_projs);
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              match$1 = CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("This record contains fields of different records."));
            } else {
              throw exn$1;
            }
          }
          _acc = /* :: */[
            /* tuple */[
              match$1[1][0],
              match[1]
            ],
            acc
          ];
          _remaining_projs = match$1[0];
          _fields = fields[1];
          continue ;
          
        } else {
          var complete_field = function (param) {
            var idx = param[0];
            return /* tuple */[
                    idx,
                    Curry._1(completer, idx)
                  ];
          };
          var remaining_fields = Curry._2(Util$ReactTemplate.List[/* rev_map */12], complete_field, remaining_projs);
          return Curry._2(Util$ReactTemplate.List[/* rev_append */6], remaining_fields, acc);
        }
      };
    };
    var unsorted_indexed_fields = index_fields(fields[1], match$2[2], /* :: */[
          /* tuple */[
            match$2[1],
            match[1]
          ],
          /* [] */0
        ]);
    var cmp_by_index = function (param, param$1) {
      return Caml_primitive.caml_int_compare(param[0], param$1[0]);
    };
    var sorted_indexed_fields = Curry._2(Util$ReactTemplate.List[/* sort */38], cmp_by_index, unsorted_indexed_fields);
    var sorted_fields = Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
            return prim[1];
          }), sorted_indexed_fields);
    return /* Some */[/* tuple */[
              nparams,
              base_constructor,
              sorted_fields
            ]];
  } else {
    return /* None */0;
  }
}

var empty_alias_001 = /* alias_map */Names$ReactTemplate.Id[/* Map */10][/* empty */0];

var empty_alias = /* record */[
  /* alias_ids : [] */0,
  empty_alias_001
];

function merge_aliases(aliases, param) {
  var na = param[/* v */0];
  if (na) {
    var id = na[0];
    var alias_ids = Util$ReactTemplate.$at(aliases[/* alias_ids */0], /* :: */[
          CAst$ReactTemplate.make(param[/* loc */1], id),
          /* [] */0
        ]);
    var match = aliases[/* alias_ids */0];
    var alias_map = match ? Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, match[0][/* v */0], aliases[/* alias_map */1]) : aliases[/* alias_map */1];
    return /* record */[
            /* alias_ids */alias_ids,
            /* alias_map */alias_map
          ];
  } else {
    return aliases;
  }
}

function alias_of(als) {
  var match = als[/* alias_ids */0];
  if (match) {
    return /* Name */[match[0][/* v */0]];
  } else {
    return /* Anonymous */0;
  }
}

function is_zero(s) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (s.length === i) {
      return /* true */1;
    } else if (Caml_string.get(s, i) === /* "0" */48) {
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* false */0;
    }
  };
}

function merge_subst(s1, s2) {
  return Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], Names$ReactTemplate.Id[/* Map */10][/* add */3], s1, s2);
}

function product_of_cases_patterns(aliases, idspl) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                var ptaill = param$1[1];
                return /* tuple */[
                        Util$ReactTemplate.$at(param[0], param$1[0]),
                        Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                    var p = param[1];
                                    var subst = param[0];
                                    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                  return /* tuple */[
                                                          merge_subst(subst, param[0]),
                                                          /* :: */[
                                                            p,
                                                            param[1]
                                                          ]
                                                        ];
                                                }), ptaill);
                                  }), param[1]))
                      ];
              }), idspl, /* tuple */[
              aliases[/* alias_ids */0],
              /* :: */[
                /* tuple */[
                  aliases[/* alias_map */1],
                  /* [] */0
                ],
                /* [] */0
              ]
            ]);
}

function subst_pat_iterator(y, t) {
  return (function (param) {
      return DAst$ReactTemplate.map((function (p) {
                    switch (p.tag | 0) {
                      case 0 : 
                          return /* RCPatAlias */Block.__(0, [
                                    subst_pat_iterator(y, t)(p[0]),
                                    p[1]
                                  ]);
                      case 1 : 
                          return /* RCPatCstr */Block.__(1, [
                                    p[0],
                                    Curry._2(Util$ReactTemplate.List[/* map */10], subst_pat_iterator(y, t), p[1]),
                                    Curry._2(Util$ReactTemplate.List[/* map */10], subst_pat_iterator(y, t), p[2])
                                  ]);
                      case 2 : 
                          var id = p[0];
                          if (id && Names$ReactTemplate.Id[/* equal */0](id[0][0][/* v */0], y)) {
                            return DAst$ReactTemplate.get(t);
                          } else {
                            return p;
                          }
                      case 3 : 
                          return /* RCPatOr */Block.__(3, [Curry._2(Util$ReactTemplate.List[/* map */10], subst_pat_iterator(y, t), p[0])]);
                      
                    }
                  }), param);
    });
}

function is_non_zero(c) {
  var match = c[/* v */0];
  if (match.tag === 19) {
    var match$1 = match[0];
    if (!match$1.tag && match$1[1] !== 0) {
      return 1 - is_zero(match$1[0]);
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function is_non_zero_pat(c) {
  var match = c[/* v */0];
  if (match.tag === 5) {
    var match$1 = match[0];
    if (!match$1.tag && match$1[1] !== 0) {
      return 1 - is_zero(match$1[0]);
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function drop_notations_pattern(looked_for, genv) {
  var ensure_kind = function (top, loc, g) {
    try {
      if (top) {
        return Curry._1(looked_for, g);
      } else if (g.tag === 3) {
        return /* () */0;
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Constrexpr_ops$ReactTemplate.error_invalid_pattern_notation(loc, /* () */0);
      } else {
        throw exn;
      }
    }
  };
  var test_kind = function (top) {
    if (top) {
      return looked_for;
    } else {
      return (function (param) {
          if (param.tag === 3) {
            return /* () */0;
          } else {
            throw Caml_builtin_exceptions.not_found;
          }
        });
    }
  };
  var rcp_of_glob = function (scopes, x) {
    return DAst$ReactTemplate.map((function (param) {
                  switch (param.tag | 0) {
                    case 0 : 
                        return /* RCPatCstr */Block.__(1, [
                                  param[0],
                                  /* [] */0,
                                  /* [] */0
                                ]);
                    case 1 : 
                        return /* RCPatAtom */Block.__(2, [/* Some */[/* tuple */[
                                      CAst$ReactTemplate.make(x[/* loc */1], param[0]),
                                      scopes
                                    ]]]);
                    case 4 : 
                        var l = param[1];
                        var match = DAst$ReactTemplate.get(param[0]);
                        if (match.tag) {
                          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Invalid return pattern from Notation.interp_prim_token_cases_pattern_expr."));
                        } else {
                          var g = match[0];
                          var allscs = Notation$ReactTemplate.find_arguments_scope(g);
                          var allscs$1 = simple_adjust_scopes(Curry._1(Util$ReactTemplate.List[/* length */0], l), allscs);
                          return /* RCPatCstr */Block.__(1, [
                                    g,
                                    Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (sc, a) {
                                            return rcp_of_glob(/* tuple */[
                                                        sc,
                                                        scopes[1]
                                                      ], a);
                                          }), allscs$1, l),
                                    /* [] */0
                                  ]);
                        }
                        break;
                    case 13 : 
                        return /* RCPatAtom */Block.__(2, [/* None */0]);
                    default:
                      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Invalid return pattern from Notation.interp_prim_token_cases_pattern_expr."));
                  }
                }), x);
  };
  var drop_syndef = function (top, scopes, re, pats) {
    var qid = Libnames$ReactTemplate.qualid_of_reference(re);
    try {
      var match = Nametab$ReactTemplate.locate_extended(qid[/* v */0]);
      if (match.tag) {
        var match$1 = Syntax_def$ReactTemplate.search_syntactic_definition(match[0]);
        var a = match$1[1];
        var vars = match$1[0];
        switch (a.tag | 0) {
          case 0 : 
              var g = a[0];
              Curry._1(test_kind(top), g);
              if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], vars)) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "constrintern.ml",
                        1495,
                        12
                      ]
                    ];
              }
              var match$2 = find_remaining_scopes(/* [] */0, pats, g);
              return /* Some */[/* tuple */[
                        g,
                        /* [] */0,
                        Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param) {
                                return in_pat_sc(scopes, param);
                              }), match$2[1], pats)
                      ]];
          case 2 : 
              var match$3 = a[0];
              if (match$3.tag) {
                throw Caml_builtin_exceptions.not_found;
              } else {
                var args = a[1];
                var g$1 = match$3[0];
                Curry._1(test_kind(top), g$1);
                if (args) {
                  var nvars = Curry._1(Util$ReactTemplate.List[/* length */0], vars);
                  if (Curry._1(Util$ReactTemplate.List[/* length */0], pats) < nvars) {
                    error_not_enough_arguments(qid[/* loc */1]);
                  }
                  var match$4 = Curry._2(Util$ReactTemplate.List[/* chop */99], nvars, pats);
                  var pats2 = match$4[1];
                  var pats1 = match$4[0];
                  var subst = make_subst(vars, pats1);
                  var partial_arg_001 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];
                  var partial_arg = /* tuple */[
                    subst,
                    partial_arg_001
                  ];
                  var partial_arg$1 = qid[/* loc */1];
                  var idspl1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                          return in_not(/* false */0, partial_arg$1, scopes, partial_arg, /* [] */0, param);
                        }), args);
                  var match$5 = find_remaining_scopes(pats1, pats2, g$1);
                  return /* Some */[/* tuple */[
                            g$1,
                            idspl1,
                            Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param) {
                                    return in_pat_sc(scopes, param);
                                  }), match$5[1], pats2)
                          ]];
                } else {
                  if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], vars)) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "constrintern.ml",
                            1500,
                            23
                          ]
                        ];
                  }
                  return /* Some */[/* tuple */[
                            g$1,
                            Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                    return in_pat(/* false */0, scopes, param);
                                  }), pats),
                            /* [] */0
                          ]];
                }
              }
              break;
          default:
            throw Caml_builtin_exceptions.not_found;
        }
      } else {
        var g$2 = match[0];
        Curry._1(test_kind(top), g$2);
        var match$6 = find_remaining_scopes(/* [] */0, pats, g$2);
        return /* Some */[/* tuple */[
                  g$2,
                  /* [] */0,
                  Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (x) {
                          var partial_arg_001 = scopes[1];
                          var partial_arg = /* tuple */[
                            x,
                            partial_arg_001
                          ];
                          return (function (param) {
                              return in_pat(/* false */0, partial_arg, param);
                            });
                        }), match$6[1], pats)
                ]];
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
  };
  var in_pat = function (top, _scopes, _pt) {
    while(true) {
      var pt = _pt;
      var scopes = _scopes;
      var loc = pt[/* loc */1];
      var match = pt[/* v */0];
      switch (match.tag | 0) {
        case 0 : 
            return DAst$ReactTemplate.make(loc, /* RCPatAlias */Block.__(0, [
                          in_pat(top, scopes, match[0]),
                          match[1]
                        ]));
        case 1 : 
            var match$1 = match[1];
            var head = match[0];
            if (match$1) {
              var pl = match[2];
              var expl_pl = match$1[0];
              var g;
              try {
                g = Nametab$ReactTemplate.locate(Libnames$ReactTemplate.qualid_of_reference(head)[/* v */0]);
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  throw [
                        InternalizationError,
                        /* tuple */[
                          loc,
                          /* NotAConstructor */Block.__(1, [head])
                        ]
                      ];
                } else {
                  throw exn;
                }
              }
              if (expl_pl) {
                var match$2 = find_remaining_scopes(expl_pl, pl, g);
                return DAst$ReactTemplate.make(loc, /* RCPatCstr */Block.__(1, [
                              g,
                              Util$ReactTemplate.$at(Curry._3(Util$ReactTemplate.List[/* map2 */16], (function(scopes){
                                      return function (param) {
                                        return in_pat_sc(scopes, param);
                                      }
                                      }(scopes)), match$2[0], expl_pl), Curry._2(Util$ReactTemplate.List[/* map */10], (function(scopes){
                                      return function (param) {
                                        return in_pat(/* false */0, scopes, param);
                                      }
                                      }(scopes)), pl)),
                              /* [] */0
                            ]));
              } else {
                return DAst$ReactTemplate.make(loc, /* RCPatCstr */Block.__(1, [
                              g,
                              Curry._2(Util$ReactTemplate.List[/* map */10], (function(scopes){
                                  return function (param) {
                                    return in_pat(/* false */0, scopes, param);
                                  }
                                  }(scopes)), pl),
                              /* [] */0
                            ]));
              }
            } else {
              var match$3 = drop_syndef(top, scopes, head, match[2]);
              if (match$3) {
                var match$4 = match$3[0];
                return DAst$ReactTemplate.make(loc, /* RCPatCstr */Block.__(1, [
                              match$4[0],
                              match$4[1],
                              match$4[2]
                            ]));
              } else {
                throw [
                      InternalizationError,
                      /* tuple */[
                        loc,
                        /* NotAConstructor */Block.__(1, [head])
                      ]
                    ];
              }
            }
            break;
        case 2 : 
            var match$5 = match[0];
            if (match$5) {
              var id = match$5[0];
              var match$6 = drop_syndef(top, scopes, id, /* [] */0);
              if (match$6) {
                var match$7 = match$6[0];
                return DAst$ReactTemplate.make(loc, /* RCPatCstr */Block.__(1, [
                              match$7[0],
                              match$7[1],
                              match$7[2]
                            ]));
              } else {
                return DAst$ReactTemplate.make(loc, /* RCPatAtom */Block.__(2, [/* Some */[/* tuple */[
                                  CAst$ReactTemplate.make(loc, find_pattern_variable(id)),
                                  scopes
                                ]]]));
              }
            } else {
              return DAst$ReactTemplate.make(loc, /* RCPatAtom */Block.__(2, [/* None */0]));
            }
            break;
        case 3 : 
            return DAst$ReactTemplate.make(loc, /* RCPatOr */Block.__(3, [Curry._2(Util$ReactTemplate.List[/* map */10], (function(scopes){
                              return function (param) {
                                return in_pat(top, scopes, param);
                              }
                              }(scopes)), match[0])]));
        case 4 : 
            var ntn = match[0];
            var exit = 0;
            switch (ntn) {
              case "( _ )" : 
                  var match$8 = match[1];
                  var match$9 = match$8[0];
                  if (match$9) {
                    if (match$9[1]) {
                      exit = 1;
                    } else if (match$8[1]) {
                      exit = 1;
                    } else if (match[2]) {
                      exit = 1;
                    } else {
                      _pt = match$9[0];
                      continue ;
                      
                    }
                  } else {
                    exit = 1;
                  }
                  break;
              case "- _" : 
                  var match$10 = match[1];
                  var match$11 = match$10[0];
                  if (match$11) {
                    if (match$11[1]) {
                      exit = 1;
                    } else if (match$10[1]) {
                      exit = 1;
                    } else if (match[2]) {
                      exit = 1;
                    } else {
                      var a = match$11[0];
                      if (is_non_zero_pat(a)) {
                        var match$12 = a[/* v */0];
                        var p;
                        if (match$12.tag === 5) {
                          var match$13 = match$12[0];
                          if (match$13.tag) {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  [
                                    "constrintern.ml",
                                    1557,
                                    72
                                  ]
                                ];
                          } else {
                            p = match$13[0];
                          }
                        } else {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                [
                                  "constrintern.ml",
                                  1557,
                                  72
                                ]
                              ];
                        }
                        var match$14 = Notation$ReactTemplate.interp_prim_token_cases_pattern_expr(loc, (function(loc){
                              return function (param) {
                                return ensure_kind(/* false */0, loc, param);
                              }
                              }(loc)), /* Numeral */Block.__(0, [
                                  p,
                                  /* false */0
                                ]))(scopes);
                        return rcp_of_glob(scopes, match$14[0]);
                      } else {
                        exit = 1;
                      }
                    }
                  } else {
                    exit = 1;
                  }
                  break;
              default:
                exit = 1;
            }
            if (exit === 1) {
              var match$15 = contract_curly_brackets_pat(ntn, match[1]);
              var match$16 = match$15[1];
              var match$17 = Notation$ReactTemplate.interp_notation(loc, match$15[0], scopes);
              var match$18 = match$17[0];
              var match$19 = split_by_type_pat(loc, match$18[0], /* tuple */[
                    match$16[0],
                    match$16[1]
                  ]);
              return in_not(top, loc, scopes, /* tuple */[
                          match$19[0],
                          match$19[1]
                        ], match[2], match$18[1]);
            }
            break;
        case 5 : 
            var match$20 = Notation$ReactTemplate.interp_prim_token_cases_pattern_expr(loc, test_kind(/* false */0), match[0])(scopes);
            return rcp_of_glob(scopes, match$20[0]);
        case 6 : 
            var sorted_fields = sort_fields(/* false */0, loc, match[0], (function(loc){
                return function () {
                  return CAst$ReactTemplate.make(loc, /* CPatAtom */Block.__(2, [/* None */0]));
                }
                }(loc)));
            if (sorted_fields) {
              var match$21 = sorted_fields[0];
              var pl$1 = match$21[2];
              var head$1 = match$21[1];
              var pl$2;
              if (Constrexpr_ops$ReactTemplate.asymmetric_patterns[0]) {
                pl$2 = pl$1;
              } else {
                var pars = Curry._2(Util$ReactTemplate.List[/* make */56], match$21[0], CAst$ReactTemplate.make(loc, /* CPatAtom */Block.__(2, [/* None */0])));
                pl$2 = Curry._2(Util$ReactTemplate.List[/* rev_append */6], pars, pl$1);
              }
              var match$22 = drop_syndef(top, scopes, head$1, pl$2);
              if (match$22) {
                var match$23 = match$22[0];
                return DAst$ReactTemplate.make(loc, /* RCPatCstr */Block.__(1, [
                              match$23[0],
                              match$23[1],
                              match$23[2]
                            ]));
              } else {
                throw [
                      InternalizationError,
                      /* tuple */[
                        loc,
                        /* NotAConstructor */Block.__(1, [head$1])
                      ]
                    ];
              }
            } else {
              return DAst$ReactTemplate.make(loc, /* RCPatAtom */Block.__(2, [/* None */0]));
            }
            break;
        case 7 : 
            _pt = match[1];
            _scopes = /* tuple */[
              /* None */0,
              /* :: */[
                Notation$ReactTemplate.find_delimiters_scope(loc, match[0]),
                scopes[1]
              ]
            ];
            continue ;
            case 8 : 
            return CErrors$ReactTemplate.user_err(loc, /* Some */["drop_notations_pattern"], Pp$ReactTemplate.strbrk("Casts are not supported in this pattern."));
        
      }
    };
  };
  var in_pat_sc = function (scopes, x) {
    var partial_arg_001 = scopes[1];
    var partial_arg = /* tuple */[
      x,
      partial_arg_001
    ];
    return (function (param) {
        return in_pat(/* false */0, partial_arg, param);
      });
  };
  var in_not = function (top, loc, scopes, fullsubst, args, t) {
    var substlist = fullsubst[1];
    var subst = fullsubst[0];
    switch (t.tag | 0) {
      case 0 : 
          var g = t[0];
          ensure_kind(top, loc, g);
          var match = find_remaining_scopes(/* [] */0, args, g);
          return DAst$ReactTemplate.make(loc, /* RCPatCstr */Block.__(1, [
                        g,
                        /* [] */0,
                        Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param) {
                                return in_pat_sc(scopes, param);
                              }), match[1], args)
                      ]));
      case 1 : 
          var id = t[0];
          if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], args)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "constrintern.ml",
                    1599,
                    15
                  ]
                ];
          }
          try {
            var match$1 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, subst);
            var match$2 = match$1[1];
            return in_pat(top, /* tuple */[
                        match$2[0],
                        Util$ReactTemplate.$at(match$2[1], scopes[1])
                      ], match$1[0]);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              if (Names$ReactTemplate.Id[/* equal */0](id, Notation_ops$ReactTemplate.ldots_var)) {
                return DAst$ReactTemplate.make(loc, /* RCPatAtom */Block.__(2, [/* Some */[/* tuple */[
                                  CAst$ReactTemplate.make(loc, id),
                                  scopes
                                ]]]));
              } else {
                return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unbound pattern notation variable: "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str(".")));
              }
            } else {
              throw exn;
            }
          }
          break;
      case 2 : 
          var match$3 = t[0];
          if (match$3.tag) {
            return Constrexpr_ops$ReactTemplate.error_invalid_pattern_notation(loc, /* () */0);
          } else {
            var pl = t[1];
            var g$1 = match$3[0];
            ensure_kind(top, loc, g$1);
            var match$4 = find_remaining_scopes(pl, args, g$1);
            var pl$1 = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (x) {
                    var partial_arg_001 = scopes[1];
                    var partial_arg = /* tuple */[
                      x,
                      partial_arg_001
                    ];
                    return (function (param) {
                        return in_not(/* false */0, loc, partial_arg, fullsubst, /* [] */0, param);
                      });
                  }), match$4[0], pl);
            var pl$2 = add_local_defs_and_check_length(loc, genv, g$1, pl$1, args);
            return DAst$ReactTemplate.make(loc, /* RCPatCstr */Block.__(1, [
                          g$1,
                          Util$ReactTemplate.$at(pl$2, Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                      return in_pat(/* false */0, scopes, param);
                                    }), args)),
                          /* [] */0
                        ]));
          }
          break;
      case 3 : 
          if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], args)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "constrintern.ml",
                    1635,
                    15
                  ]
                ];
          }
          return DAst$ReactTemplate.make(loc, /* RCPatAtom */Block.__(2, [/* None */0]));
      case 4 : 
          var iter = t[2];
          var y = t[1];
          if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], args)) {
            CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.strbrk("Application of arguments to a recursive notation not supported in patterns."));
          }
          try {
            var match$5 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], t[0], substlist);
            var match$6 = match$5[1];
            var subscopes = match$6[1];
            var scopt = match$6[0];
            var l = match$5[0];
            var termin = in_not(top, loc, scopes, fullsubst, /* [] */0, t[3]);
            return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (a, t) {
                          var nsubst = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], y, /* tuple */[
                                a,
                                /* tuple */[
                                  scopt,
                                  subscopes
                                ]
                              ], subst);
                          return subst_pat_iterator(Notation_ops$ReactTemplate.ldots_var, t)(in_not(/* false */0, loc, scopes, /* tuple */[
                                          nsubst,
                                          substlist
                                        ], /* [] */0, iter));
                        }), t[4] ? Curry._1(Util$ReactTemplate.List[/* rev */4], l) : l, termin);
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Inconsistent substitution of recursive notation."));
            } else {
              throw exn$1;
            }
          }
          break;
      default:
        return Constrexpr_ops$ReactTemplate.error_invalid_pattern_notation(loc, /* () */0);
    }
  };
  return (function (param, param$1) {
      return in_pat(/* true */1, param, param$1);
    });
}

function intern_pat(genv, ntnvars, _aliases, _pat) {
  while(true) {
    var pat = _pat;
    var aliases = _aliases;
    var intern_cstr_with_all_args = (function(aliases){
    return function intern_cstr_with_all_args(loc, c, with_letin, idslpl1, pl2) {
      var idslpl2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return intern_pat(genv, ntnvars, empty_alias, param);
            }), pl2);
      var match = product_of_cases_patterns(aliases, Util$ReactTemplate.$at(idslpl1, idslpl2));
      var pl$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              return /* tuple */[
                      param[0],
                      DAst$ReactTemplate.make(loc, /* PatCstr */Block.__(1, [
                              c,
                              chop_params_pattern(loc, c[0], param[1], with_letin),
                              alias_of(aliases)
                            ]))
                    ];
            }), match[1]);
      return /* tuple */[
              match[0],
              pl$prime
            ];
    }
    }(aliases));
    var loc = pat[/* loc */1];
    var match = DAst$ReactTemplate.get(pat);
    switch (match.tag | 0) {
      case 0 : 
          var aliases$prime = merge_aliases(aliases, match[1]);
          _pat = match[0];
          _aliases = aliases$prime;
          continue ;
          case 1 : 
          var pl = match[2];
          var expl_pl = match[1];
          var head = match[0];
          if (Constrexpr_ops$ReactTemplate.asymmetric_patterns[0]) {
            var len = Curry._1(Util$ReactTemplate.List[/* is_empty */45], expl_pl) ? /* Some */[Curry._1(Util$ReactTemplate.List[/* length */0], pl)] : /* None */0;
            var match$1 = find_constructor(loc, len, head);
            var idslpl1 = match$1[1];
            var c = match$1[0];
            var with_letin = check_constructor_length(genv, loc, c, Curry._1(Util$ReactTemplate.List[/* length */0], idslpl1) + Curry._1(Util$ReactTemplate.List[/* length */0], expl_pl) | 0, pl);
            return intern_cstr_with_all_args(loc, c, with_letin, idslpl1, Util$ReactTemplate.$at(expl_pl, pl));
          } else {
            var match$2 = find_constructor(loc, /* None */0, head);
            var idslpl1$1 = match$2[1];
            var c$1 = match$2[0];
            var match$3 = add_implicits_check_constructor_length(genv, loc, c$1, Curry._1(Util$ReactTemplate.List[/* length */0], idslpl1$1) + Curry._1(Util$ReactTemplate.List[/* length */0], expl_pl) | 0, pl);
            return intern_cstr_with_all_args(loc, c$1, match$3[0], idslpl1$1, Util$ReactTemplate.$at(expl_pl, match$3[1]));
          }
          break;
      case 2 : 
          var match$4 = match[0];
          if (match$4) {
            var match$5 = match$4[0];
            var match$6 = match$5[0];
            var loc$1 = match$6[/* loc */1];
            var id = match$6[/* v */0];
            var aliases$1 = merge_aliases(aliases, CAst$ReactTemplate.make(loc$1, /* Name */[id]));
            set_var_scope(loc$1, id, /* false */0, match$5[1], ntnvars);
            return /* tuple */[
                    aliases$1[/* alias_ids */0],
                    /* :: */[
                      /* tuple */[
                        aliases$1[/* alias_map */1],
                        DAst$ReactTemplate.make(loc$1, /* PatVar */Block.__(0, [alias_of(aliases$1)]))
                      ],
                      /* [] */0
                    ]
                  ];
          } else {
            return /* tuple */[
                    aliases[/* alias_ids */0],
                    /* :: */[
                      /* tuple */[
                        aliases[/* alias_map */1],
                        DAst$ReactTemplate.make(loc, /* PatVar */Block.__(0, [alias_of(aliases)]))
                      ],
                      /* [] */0
                    ]
                  ];
          }
          break;
      case 3 : 
          var pl$1 = match[0];
          if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], pl$1)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "constrintern.ml",
                    1672,
                    6
                  ]
                ];
          }
          var pl$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function(aliases){
              return function (param) {
                return intern_pat(genv, ntnvars, aliases, param);
              }
              }(aliases)), pl$1);
          var match$7 = Curry._1(Util$ReactTemplate.List[/* split */36], pl$prime);
          var idsl = match$7[0];
          var ids = Curry._1(Util$ReactTemplate.List[/* hd */1], idsl);
          check_or_pat_variables(loc, ids, Curry._1(Util$ReactTemplate.List[/* tl */2], idsl));
          return /* tuple */[
                  ids,
                  Curry._1(Util$ReactTemplate.List[/* flatten */8], match$7[1])
                ];
      
    }
  };
}

function intern_cases_pattern(genv, ntnvars, scopes, aliases, pat) {
  return intern_pat(genv, ntnvars, aliases, drop_notations_pattern((function (param) {
                      if (param.tag === 3) {
                        return /* () */0;
                      } else {
                        throw Caml_builtin_exceptions.not_found;
                      }
                    }), genv)(scopes, pat));
}

intern_cases_pattern_fwd[0] = (function (ntnvars, scopes, p) {
    return intern_cases_pattern(Global$ReactTemplate.env(/* () */0), ntnvars, scopes, empty_alias, p);
  });

function intern_ind_pattern(genv, ntnvars, scopes, pat) {
  var no_not;
  try {
    no_not = drop_notations_pattern((function (param) {
              switch (param.tag | 0) {
                case 0 : 
                case 1 : 
                    throw Caml_builtin_exceptions.not_found;
                case 2 : 
                case 3 : 
                    return /* () */0;
                
              }
            }), genv)(scopes, pat);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === InternalizationError) {
      var match = exn[1];
      var tmp = match[1];
      if (typeof tmp === "number") {
        throw exn;
      } else if (tmp.tag === 1) {
        no_not = error_bad_inductive_type(match[0]);
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
  var loc = no_not[/* loc */1];
  var x = DAst$ReactTemplate.get(no_not);
  if (x.tag === 1) {
    var expl_pl = x[1];
    var head = x[0];
    var c;
    c = head.tag === 2 ? head[0] : error_bad_inductive_type(loc);
    var match$1 = add_implicits_check_ind_length(genv, loc, c, Curry._1(Util$ReactTemplate.List[/* length */0], expl_pl), x[2]);
    var with_letin = match$1[0];
    var idslpl = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            return intern_pat(genv, ntnvars, empty_alias, param);
          }), Util$ReactTemplate.$at(expl_pl, match$1[1]));
    var match$2 = product_of_cases_patterns(empty_alias, idslpl);
    var match$3 = match$2[1];
    return /* tuple */[
            with_letin,
            match$3 && !match$3[1] ? /* tuple */[
                c,
                chop_params_pattern(loc, c, match$3[0][1], with_letin)
              ] : error_bad_inductive_type(loc)
          ];
  } else {
    return error_bad_inductive_type(loc);
  }
}

function merge_impargs(l, args) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (a, l) {
                var match = a[1];
                if (match) {
                  var x = match[0][/* v */0];
                  if (x.tag) {
                    if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                              var x$1 = x;
                              var param$1 = param;
                              var match = param$1[1];
                              if (match) {
                                return Constrexpr_ops$ReactTemplate.explicitation_eq(x$1, match[0][/* v */0]);
                              } else {
                                return /* false */0;
                              }
                            }), args)) {
                      return l;
                    } else {
                      return /* :: */[
                              a,
                              l
                            ];
                    }
                  } else {
                    return /* :: */[
                            a,
                            l
                          ];
                  }
                } else {
                  return /* :: */[
                          a,
                          l
                        ];
                }
              }), l, args);
}

function get_implicit_name(n, imps) {
  return /* Some */[Impargs$ReactTemplate.name_of_implicit(Curry._2(Util$ReactTemplate.List[/* nth */3], imps, n - 1 | 0))];
}

function set_hole_implicit(i, b, c) {
  var loc = c[/* loc */1];
  var match = DAst$ReactTemplate.get(c);
  switch (match.tag | 0) {
    case 0 : 
        return Loc$ReactTemplate.tag(loc, /* tuple */[
                    /* ImplicitArg */Block.__(0, [
                        match[0],
                        i,
                        b
                      ]),
                    /* IntroAnonymous */0,
                    /* None */0
                  ]);
    case 1 : 
        return Loc$ReactTemplate.tag(loc, /* tuple */[
                    /* ImplicitArg */Block.__(0, [
                        /* VarRef */Block.__(0, [match[0]]),
                        i,
                        b
                      ]),
                    /* IntroAnonymous */0,
                    /* None */0
                  ]);
    case 4 : 
        var r = match[0];
        var loc$1 = r[/* loc */1];
        var match$1 = DAst$ReactTemplate.get(r);
        if (match$1.tag) {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Only refs have implicits."));
        } else {
          return Loc$ReactTemplate.tag(loc$1, /* tuple */[
                      /* ImplicitArg */Block.__(0, [
                          match$1[0],
                          i,
                          b
                        ]),
                      /* IntroAnonymous */0,
                      /* None */0
                    ]);
        }
        break;
    default:
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Only refs have implicits."));
  }
}

function exists_implicit_name(id) {
  return Curry._1(Util$ReactTemplate.List[/* exists */21], (function (imp) {
                if (Impargs$ReactTemplate.is_status_implicit(imp)) {
                  return Names$ReactTemplate.Id[/* equal */0](id, Impargs$ReactTemplate.name_of_implicit(imp));
                } else {
                  return /* false */0;
                }
              }));
}

function extract_explicit_arg(imps, args) {
  var aux = function (param) {
    if (param) {
      var match = param[0];
      var e = match[1];
      var a = match[0];
      var match$1 = aux(param[1]);
      var rargs = match$1[1];
      var eargs = match$1[0];
      if (e) {
        var match$2 = e[0];
        var loc = match$2[/* loc */1];
        var pos = match$2[/* v */0];
        var id;
        if (pos.tag) {
          var id$1 = pos[0];
          if (!Curry._1(exists_implicit_name(id$1), imps)) {
            CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Wrong argument name: "), Names$ReactTemplate.Id[/* print */8](id$1)), Pp$ReactTemplate.str(".")));
          }
          if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id$1, eargs)) {
            CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Argument name "), Names$ReactTemplate.Id[/* print */8](id$1)), Pp$ReactTemplate.str(" occurs more than once.")));
          }
          id = id$1;
        } else {
          var p = pos[0];
          var id$2;
          try {
            var imp = Curry._2(Util$ReactTemplate.List[/* nth */3], imps, p - 1 | 0);
            if (!Impargs$ReactTemplate.is_status_implicit(imp)) {
              Pervasives.failwith("imp");
            }
            id$2 = Impargs$ReactTemplate.name_of_implicit(imp);
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === Caml_builtin_exceptions.failure) {
              id$2 = CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Wrong argument position: "), Pp$ReactTemplate.$$int(p)), Pp$ReactTemplate.str(".")));
            } else {
              throw exn;
            }
          }
          if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id$2, eargs)) {
            CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Argument at position "), Pp$ReactTemplate.$$int(p)), Pp$ReactTemplate.str(" is mentioned more than once.")));
          }
          id = id$2;
        }
        return /* tuple */[
                Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, /* tuple */[
                      loc,
                      a
                    ], eargs),
                rargs
              ];
      } else {
        return /* tuple */[
                eargs,
                /* :: */[
                  a,
                  rargs
                ]
              ];
      }
    } else {
      return /* tuple */[
              Names$ReactTemplate.Id[/* Map */10][/* empty */0],
              /* [] */0
            ];
    }
  };
  return aux(args);
}

function internalize(globalenv, env, pattern_mode, lvar, c) {
  var ntnvars = lvar[1];
  var intern = function (env) {
    return (function (param) {
        return CAst$ReactTemplate.with_loc_val((function (loc, param) {
                      switch (param.tag | 0) {
                        case 0 : 
                            var match = intern_applied_reference(intern, env, Environ$ReactTemplate.named_context(globalenv), lvar, param[1], /* [] */0, param[0]);
                            var match$1 = match[0];
                            return apply_impargs(match$1[0], env, match$1[1], match$1[2], match$1[3], loc);
                        case 1 : 
                            var dl = param[1];
                            var match$2 = param[0];
                            var iddef = match$2[/* v */0];
                            var lf = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                    return param[0][/* v */0];
                                  }), dl);
                            var dl$1 = Util$ReactTemplate.$$Array[/* of_list */10](dl);
                            var n;
                            try {
                              n = Curry._3(Util$ReactTemplate.List[/* index0 */78], Names$ReactTemplate.Id[/* equal */0], iddef, lf);
                            }
                            catch (exn){
                              if (exn === Caml_builtin_exceptions.not_found) {
                                throw [
                                      InternalizationError,
                                      /* tuple */[
                                        match$2[/* loc */1],
                                        /* UnboundFixName */Block.__(2, [
                                            /* false */0,
                                            iddef
                                          ])
                                      ]
                                    ];
                              } else {
                                throw exn;
                              }
                            }
                            var idl_temp = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                    var bl = param[2];
                                    var match = param[1];
                                    var order = match[1];
                                    var n = match[0];
                                    var intern_ro_arg = function (f) {
                                      var match = Constrexpr_ops$ReactTemplate.split_at_annot(bl, n);
                                      var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], intern_local_binder, /* tuple */[
                                            env,
                                            /* [] */0
                                          ], match[0]);
                                      var rbefore = match$1[1];
                                      var env$prime = match$1[0];
                                      var ro = Curry._1(f, intern(env$prime));
                                      var n$prime = Option$ReactTemplate.map((function () {
                                              return Curry._2(Util$ReactTemplate.List[/* count */76], (function (c) {
                                                            var match = DAst$ReactTemplate.get(c);
                                                            switch (match.tag | 0) {
                                                              case 0 : 
                                                                  return /* true */1;
                                                              case 1 : 
                                                              case 2 : 
                                                                  return /* false */0;
                                                              
                                                            }
                                                          }), rbefore);
                                            }), n);
                                      return /* tuple */[
                                              n$prime,
                                              ro,
                                              Curry._3(Util$ReactTemplate.List[/* fold_left */13], intern_local_binder, /* tuple */[
                                                    env$prime,
                                                    rbefore
                                                  ], match[1])
                                            ];
                                    };
                                    var match$1;
                                    if (typeof order === "number") {
                                      match$1 = intern_ro_arg((function () {
                                              return /* GStructRec */0;
                                            }));
                                    } else if (order.tag) {
                                      var r = order[1];
                                      var m = order[0];
                                      match$1 = intern_ro_arg((function (f) {
                                              return /* GMeasureRec */Block.__(1, [
                                                        Curry._1(f, m),
                                                        Option$ReactTemplate.map(f, r)
                                                      ]);
                                            }));
                                    } else {
                                      var c = order[0];
                                      match$1 = intern_ro_arg((function (f) {
                                              return /* GWfRec */Block.__(0, [Curry._1(f, c)]);
                                            }));
                                    }
                                    var match$2 = match$1[2];
                                    var env$prime = match$2[0];
                                    var bl$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._2(Util$ReactTemplate.List[/* map */10], glob_local_binder_of_extended, match$2[1]));
                                    return /* tuple */[
                                            /* tuple */[
                                              match$1[0],
                                              match$1[1]
                                            ],
                                            bl$1,
                                            intern(set_type_scope(env$prime))(param[3]),
                                            env$prime
                                          ];
                                  }), dl$1);
                            var idl = Util$ReactTemplate.$$Array[/* map2 */49]((function (param, param$1) {
                                    var env$prime$prime = Curry._4(Util$ReactTemplate.List[/* fold_left_i */82], (function (i, en, name) {
                                            var match = Caml_array.caml_array_get(idl_temp, i);
                                            var fix_args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                    return Curry._1(build_impls(param[1]), param[0]);
                                                  }), match[1]);
                                            var eta = /* Name */[name];
                                            return push_name_env(/* None */0, ntnvars, impls_type_list(/* Some */[fix_args])(match[2]), en, CAst$ReactTemplate.make(/* None */0, eta));
                                          }), 0, param$1[3], lf);
                                    return /* tuple */[
                                            param$1[0],
                                            param$1[1],
                                            param$1[2],
                                            intern(/* record */[
                                                    /* ids */env$prime$prime[/* ids */0],
                                                    /* unb */env$prime$prime[/* unb */1],
                                                    /* tmp_scope : None */0,
                                                    /* scopes */env$prime$prime[/* scopes */3],
                                                    /* impls */env$prime$prime[/* impls */4]
                                                  ])(param[4])
                                          ];
                                  }), dl$1, idl_temp);
                            return DAst$ReactTemplate.make(loc, /* GRec */Block.__(11, [
                                          /* GFix */Block.__(0, [/* tuple */[
                                                Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                                        return param[0];
                                                      }), idl),
                                                n
                                              ]]),
                                          Util$ReactTemplate.$$Array[/* of_list */10](lf),
                                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                                  return param[1];
                                                }), idl),
                                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                                  return param[2];
                                                }), idl),
                                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                                  return param[3];
                                                }), idl)
                                        ]));
                        case 2 : 
                            var dl$2 = param[1];
                            var match$3 = param[0];
                            var iddef$1 = match$3[/* v */0];
                            var lf$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                    return param[0][/* v */0];
                                  }), dl$2);
                            var dl$3 = Util$ReactTemplate.$$Array[/* of_list */10](dl$2);
                            var n$1;
                            try {
                              n$1 = Curry._3(Util$ReactTemplate.List[/* index0 */78], Names$ReactTemplate.Id[/* equal */0], iddef$1, lf$1);
                            }
                            catch (exn$1){
                              if (exn$1 === Caml_builtin_exceptions.not_found) {
                                throw [
                                      InternalizationError,
                                      /* tuple */[
                                        match$3[/* loc */1],
                                        /* UnboundFixName */Block.__(2, [
                                            /* true */1,
                                            iddef$1
                                          ])
                                      ]
                                    ];
                              } else {
                                throw exn$1;
                              }
                            }
                            var idl_tmp = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                    var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], intern_local_binder, /* tuple */[
                                          env,
                                          /* [] */0
                                        ], param[1]);
                                    var env$prime = match[0];
                                    return /* tuple */[
                                            Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._2(Util$ReactTemplate.List[/* map */10], glob_local_binder_of_extended, match[1])),
                                            intern(set_type_scope(env$prime))(param[2]),
                                            env$prime
                                          ];
                                  }), dl$3);
                            var idl$1 = Util$ReactTemplate.$$Array[/* map2 */49]((function (param, param$1) {
                                    var env$prime$prime = Curry._4(Util$ReactTemplate.List[/* fold_left_i */82], (function (i, en, name) {
                                            var match = Caml_array.caml_array_get(idl_tmp, i);
                                            var cofix_args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                    return Curry._1(build_impls(param[1]), param[0]);
                                                  }), match[0]);
                                            var eta = /* Name */[name];
                                            return push_name_env(/* None */0, ntnvars, impls_type_list(/* Some */[cofix_args])(match[1]), en, CAst$ReactTemplate.make(/* None */0, eta));
                                          }), 0, param$1[2], lf$1);
                                    return /* tuple */[
                                            param$1[0],
                                            param$1[1],
                                            intern(/* record */[
                                                    /* ids */env$prime$prime[/* ids */0],
                                                    /* unb */env$prime$prime[/* unb */1],
                                                    /* tmp_scope : None */0,
                                                    /* scopes */env$prime$prime[/* scopes */3],
                                                    /* impls */env$prime$prime[/* impls */4]
                                                  ])(param[3])
                                          ];
                                  }), dl$3, idl_tmp);
                            return DAst$ReactTemplate.make(loc, /* GRec */Block.__(11, [
                                          /* GCoFix */Block.__(1, [n$1]),
                                          Util$ReactTemplate.$$Array[/* of_list */10](lf$1),
                                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                                  return param[0];
                                                }), idl$1),
                                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                                  return param[1];
                                                }), idl$1),
                                          Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                                                  return param[2];
                                                }), idl$1)
                                        ]));
                        case 3 : 
                            var match$4 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], intern_local_binder, /* tuple */[
                                  env,
                                  /* [] */0
                                ], param[0]);
                            return expand_binders(loc, mkGProd, match$4[1], intern(set_type_scope(match$4[0]))(param[1]));
                        case 4 : 
                            var bl = param[0];
                            if (bl) {
                              var match$5 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], intern_local_binder, /* tuple */[
                                    reset_tmp_scope(env),
                                    /* [] */0
                                  ], bl);
                              return expand_binders(loc, mkGLambda, match$5[1], intern(match$5[0])(param[1]));
                            } else {
                              return intern(env)(param[1]);
                            }
                            break;
                        case 5 : 
                            var na = param[0];
                            var inc1 = intern(reset_tmp_scope(env))(param[1]);
                            var $$int = Option$ReactTemplate.map(intern(set_type_scope(env)), param[2]);
                            return DAst$ReactTemplate.make(loc, /* GLetIn */Block.__(7, [
                                          na[/* v */0],
                                          inc1,
                                          $$int,
                                          intern(push_name_env(/* None */0, ntnvars, impls_term_list(/* None */0)(inc1), env, na))(param[3])
                                        ]));
                        case 6 : 
                            var match$6 = param[0];
                            var args = Curry._2(Util$ReactTemplate.List[/* map */10], (function (a) {
                                    return /* tuple */[
                                            a,
                                            /* None */0
                                          ];
                                  }), param[1]);
                            var match$7 = intern_applied_reference(intern, env, Environ$ReactTemplate.named_context(globalenv), lvar, match$6[2], args, match$6[1]);
                            var match$8 = match$7[0];
                            return DAst$ReactTemplate.make(loc, /* GApp */Block.__(4, [
                                          match$8[0],
                                          intern_args(env, match$8[2], Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                                      return prim[0];
                                                    }), match$7[1]))
                                        ]));
                        case 7 : 
                            var args$1 = param[1];
                            var match$9 = param[0];
                            var f = match$9[1];
                            var match$10 = f[/* v */0];
                            var match$11;
                            if (match$10.tag === 7) {
                              var match$12 = match$10[0];
                              match$11 = match$12[0] ? (
                                  Option$ReactTemplate.has_some(match$9[0]) ? /* tuple */[
                                      f,
                                      args$1
                                    ] : /* tuple */[
                                      match$12[1],
                                      Util$ReactTemplate.$at(match$10[1], args$1)
                                    ]
                                ) : /* tuple */[
                                  f,
                                  args$1
                                ];
                            } else {
                              match$11 = /* tuple */[
                                f,
                                args$1
                              ];
                            }
                            var args$2 = match$11[1];
                            var f$1 = match$11[0];
                            var match$13 = f$1[/* v */0];
                            var match$14;
                            var exit = 0;
                            switch (match$13.tag | 0) {
                              case 0 : 
                                  match$14 = intern_applied_reference(intern, env, Environ$ReactTemplate.named_context(globalenv), lvar, match$13[1], args$2, match$13[0]);
                                  break;
                              case 17 : 
                                  var match$15 = match$13[1];
                                  if (match$15[0]) {
                                    exit = 1;
                                  } else if (match$15[1]) {
                                    exit = 1;
                                  } else if (match$15[2]) {
                                    exit = 1;
                                  } else if (match$15[3]) {
                                    exit = 1;
                                  } else {
                                    var c = intern_notation(intern, env, ntnvars, loc, match$13[0], /* tuple */[
                                          /* [] */0,
                                          /* [] */0,
                                          /* [] */0,
                                          /* [] */0
                                        ]);
                                    var match$16 = find_appl_head_data(c);
                                    match$14 = /* tuple */[
                                      /* tuple */[
                                        match$16[0],
                                        match$16[1],
                                        match$16[2],
                                        match$16[3]
                                      ],
                                      args$2
                                    ];
                                  }
                                  break;
                              default:
                                exit = 1;
                            }
                            if (exit === 1) {
                              match$14 = /* tuple */[
                                /* tuple */[
                                  intern(env)(f$1),
                                  /* [] */0,
                                  /* [] */0,
                                  /* [] */0
                                ],
                                args$2
                              ];
                            }
                            var match$17 = match$14[0];
                            return apply_impargs(match$17[0], env, match$17[1], match$17[2], merge_impargs(match$17[3], match$14[1]), loc);
                        case 8 : 
                            var st = /* Define */[1 - Program$ReactTemplate.get_proofs_transparency(/* () */0)];
                            var fields = sort_fields(/* true */1, loc, param[0], (function () {
                                    return CAst$ReactTemplate.make(loc, /* CHole */Block.__(12, [
                                                  /* Some */[/* QuestionMark */Block.__(3, [
                                                        st,
                                                        /* Anonymous */0
                                                      ])],
                                                  /* IntroAnonymous */0,
                                                  /* None */0
                                                ]));
                                  }));
                            if (fields) {
                              var match$18 = fields[0];
                              var pars = Curry._2(Util$ReactTemplate.List[/* make */56], match$18[0], CAst$ReactTemplate.make(loc, /* CHole */Block.__(12, [
                                          /* None */0,
                                          /* IntroAnonymous */0,
                                          /* None */0
                                        ])));
                              return intern(env)(CAst$ReactTemplate.make(loc, /* CAppExpl */Block.__(6, [
                                                /* tuple */[
                                                  /* None */0,
                                                  match$18[1],
                                                  /* None */0
                                                ],
                                                Curry._2(Util$ReactTemplate.List[/* rev_append */6], pars, match$18[2])
                                              ])));
                            } else {
                              return CErrors$ReactTemplate.user_err(loc, /* Some */["intern"], Pp$ReactTemplate.str("No constructor inference."));
                            }
                            break;
                        case 9 : 
                            var tms = param[2];
                            var rtnpo = param[1];
                            var as_in_vars = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
                                    return Option$ReactTemplate.fold_left((function (acc, tt) {
                                                  return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], Constrexpr_ops$ReactTemplate.ids_of_cases_indtype(tt), acc);
                                                }), Option$ReactTemplate.fold_left((function (acc, param) {
                                                      return Nameops$ReactTemplate.Name[/* fold_right */10](Names$ReactTemplate.Id[/* Set */9][/* add */3], param[/* v */0], acc);
                                                    }), acc, param[1]), param[2]);
                                  }), Names$ReactTemplate.Id[/* Set */9][/* empty */0], tms);
                            var forbidden_vars = Option$ReactTemplate.cata(Constrexpr_ops$ReactTemplate.free_vars_of_constr_expr, as_in_vars, rtnpo);
                            var match$19 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (citm, param) {
                                    var match = intern_case_item(env, forbidden_vars, citm);
                                    var match$1 = match[0];
                                    return /* tuple */[
                                            /* :: */[
                                              /* tuple */[
                                                match$1[0],
                                                match$1[1]
                                              ],
                                              param[0]
                                            ],
                                            Option$ReactTemplate.fold_right(Names$ReactTemplate.Id[/* Set */9][/* add */3], match[1], param[1]),
                                            Curry._2(Util$ReactTemplate.List[/* rev_append */6], match[2], param[2])
                                          ];
                                  }), tms, /* tuple */[
                                  /* [] */0,
                                  Names$ReactTemplate.Id[/* Set */9][/* empty */0],
                                  /* [] */0
                                ]);
                            var tms$1 = match$19[0];
                            var env$prime = Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], (function ($$var, bli) {
                                    var eta = /* Name */[$$var];
                                    return push_name_env(/* None */0, ntnvars, /* tuple */[
                                                /* Variable */2,
                                                /* [] */0,
                                                /* [] */0,
                                                /* [] */0
                                              ], bli, CAst$ReactTemplate.make(/* None */0, eta));
                                  }), Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], match$19[1], as_in_vars), reset_hidden_inductive_implicit_test(env));
                            var is_patvar = function (c) {
                              var match = DAst$ReactTemplate.get(c);
                              if (match.tag) {
                                return /* false */0;
                              } else {
                                return /* true */1;
                              }
                            };
                            var aux = function (_l) {
                              while(true) {
                                var l = _l;
                                if (l) {
                                  if (is_patvar(l[0][1])) {
                                    _l = l[1];
                                    continue ;
                                    
                                  } else {
                                    return l;
                                  }
                                } else {
                                  return /* [] */0;
                                }
                              };
                            };
                            var stripped_match_from_in = aux(match$19[2]);
                            var rtnpo$1;
                            if (stripped_match_from_in) {
                              var match$20 = Curry._1(Util$ReactTemplate.List[/* split */36], stripped_match_from_in);
                              var thepats = match$20[1];
                              var sub_tms = Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
                                      var eta = /* GVar */Block.__(1, [id]);
                                      return /* tuple */[
                                              DAst$ReactTemplate.make(/* None */0, eta),
                                              /* tuple */[
                                                /* Name */[id],
                                                /* None */0
                                              ]
                                            ];
                                    }), match$20[0]);
                              var eta_002 = Option$ReactTemplate.cata(intern(set_type_scope(env$prime)), DAst$ReactTemplate.make(loc, /* GHole */Block.__(13, [
                                          /* CasesType */Block.__(4, [/* false */0]),
                                          /* IntroAnonymous */0,
                                          /* None */0
                                        ])), rtnpo);
                              var eta = /* tuple */[
                                /* [] */0,
                                thepats,
                                eta_002
                              ];
                              var main_sub_eqn = CAst$ReactTemplate.make(/* None */0, eta);
                              var catch_all_sub_eqn;
                              if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
                                        return Cases$ReactTemplate.irrefutable(globalenv, param);
                                      }), thepats)) {
                                catch_all_sub_eqn = /* [] */0;
                              } else {
                                var eta_001 = Curry._2(Util$ReactTemplate.List[/* make */56], Curry._1(Util$ReactTemplate.List[/* length */0], thepats), DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0])));
                                var eta_002$1 = DAst$ReactTemplate.make(/* None */0, /* GHole */Block.__(13, [
                                        /* ImpossibleCase */2,
                                        /* IntroAnonymous */0,
                                        /* None */0
                                      ]));
                                var eta$1 = /* tuple */[
                                  /* [] */0,
                                  eta_001,
                                  eta_002$1
                                ];
                                catch_all_sub_eqn = /* :: */[
                                  CAst$ReactTemplate.make(/* None */0, eta$1),
                                  /* [] */0
                                ];
                              }
                              var eta_003 = /* :: */[
                                main_sub_eqn,
                                catch_all_sub_eqn
                              ];
                              var eta$2 = /* GCases */Block.__(8, [
                                  /* RegularStyle */4,
                                  /* None */0,
                                  sub_tms,
                                  eta_003
                                ]);
                              rtnpo$1 = /* Some */[DAst$ReactTemplate.make(/* None */0, eta$2)];
                            } else {
                              rtnpo$1 = Option$ReactTemplate.map(intern(set_type_scope(env$prime)), rtnpo);
                            }
                            var partial_arg = Curry._1(Util$ReactTemplate.List[/* length */0], tms$1);
                            var eqns$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                    var n = partial_arg;
                                    var env$1 = env;
                                    var param$1 = param;
                                    var loc = param$1[/* loc */1];
                                    var match = param$1[/* v */0];
                                    var rhs = match[1];
                                    var lhs = match[0];
                                    var match$1 = intern_disjunctive_multiple_pattern(env$1, loc, n, lhs);
                                    var eqn_ids = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
                                            return x[/* v */0];
                                          }), match$1[0]);
                                    check_linearity(lhs, eqn_ids);
                                    var env_ids = Curry._3(Util$ReactTemplate.List[/* fold_right */14], Names$ReactTemplate.Id[/* Set */9][/* add */3], eqn_ids, env$1[/* ids */0]);
                                    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                  var rhs$1 = Constrexpr_ops$ReactTemplate.replace_vars_constr_expr(param[0], rhs);
                                                  var rhs$prime = intern(/* record */[
                                                          /* ids */env_ids,
                                                          /* unb */env$1[/* unb */1],
                                                          /* tmp_scope */env$1[/* tmp_scope */2],
                                                          /* scopes */env$1[/* scopes */3],
                                                          /* impls */env$1[/* impls */4]
                                                        ])(rhs$1);
                                                  return CAst$ReactTemplate.make(loc, /* tuple */[
                                                              eqn_ids,
                                                              param[1],
                                                              rhs$prime
                                                            ]);
                                                }), match$1[1]);
                                  }), param[3]);
                            return DAst$ReactTemplate.make(loc, /* GCases */Block.__(8, [
                                          param[0],
                                          rtnpo$1,
                                          tms$1,
                                          Curry._1(Util$ReactTemplate.List[/* flatten */8], eqns$prime)
                                        ]));
                        case 10 : 
                            var match$21 = param[1];
                            var nal = param[0];
                            var env$prime$1 = reset_tmp_scope(env);
                            var match$22 = intern_case_item(env$prime$1, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* tuple */[
                                  param[2],
                                  match$21[0],
                                  /* None */0
                                ]);
                            var match$23 = match$22[0];
                            var na$prime = match$23[1][0];
                            var p$prime = Option$ReactTemplate.map((function (u) {
                                    var env$prime$prime = push_name_env(/* None */0, ntnvars, /* tuple */[
                                          /* Variable */2,
                                          /* [] */0,
                                          /* [] */0,
                                          /* [] */0
                                        ], reset_hidden_inductive_implicit_test(env$prime$1), CAst$ReactTemplate.make(/* None */0, na$prime));
                                    return intern(set_type_scope(env$prime$prime))(u);
                                  }), match$21[1]);
                            var partial_arg$1 = /* tuple */[
                              /* Variable */2,
                              /* [] */0,
                              /* [] */0,
                              /* [] */0
                            ];
                            return DAst$ReactTemplate.make(loc, /* GLetTuple */Block.__(9, [
                                          Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                  return param[/* v */0];
                                                }), nal),
                                          /* tuple */[
                                            na$prime,
                                            p$prime
                                          ],
                                          match$23[0],
                                          intern(Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                                                        return push_name_env(/* None */0, ntnvars, partial_arg$1, param, param$1);
                                                      }), reset_hidden_inductive_implicit_test(env), nal))(param[3])
                                        ]));
                        case 11 : 
                            var match$24 = param[1];
                            var env$prime$2 = reset_tmp_scope(env);
                            var match$25 = intern_case_item(env$prime$2, Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* tuple */[
                                  param[0],
                                  match$24[0],
                                  /* None */0
                                ]);
                            var match$26 = match$25[0];
                            var na$prime$1 = match$26[1][0];
                            var p$prime$1 = Option$ReactTemplate.map((function (p) {
                                    var env$prime$prime = push_name_env(/* None */0, ntnvars, /* tuple */[
                                          /* Variable */2,
                                          /* [] */0,
                                          /* [] */0,
                                          /* [] */0
                                        ], reset_hidden_inductive_implicit_test(env), CAst$ReactTemplate.make(/* None */0, na$prime$1));
                                    return intern(set_type_scope(env$prime$prime))(p);
                                  }), match$24[1]);
                            return DAst$ReactTemplate.make(loc, /* GIf */Block.__(10, [
                                          match$26[0],
                                          /* tuple */[
                                            na$prime$1,
                                            p$prime$1
                                          ],
                                          intern(env)(param[2]),
                                          intern(env)(param[3])
                                        ]));
                        case 12 : 
                            var solve = param[2];
                            var naming = param[1];
                            var k = param[0];
                            var k$1;
                            if (k) {
                              k$1 = k[0];
                            } else {
                              var st$1 = /* Define */[1 - Program$ReactTemplate.get_proofs_transparency(/* () */0)];
                              k$1 = typeof naming === "number" ? /* QuestionMark */Block.__(3, [
                                    st$1,
                                    /* Anonymous */0
                                  ]) : (
                                  naming.tag ? /* QuestionMark */Block.__(3, [
                                        st$1,
                                        /* Anonymous */0
                                      ]) : /* NamedHole */Block.__(2, [naming[0]])
                                );
                            }
                            var solve$1;
                            if (solve) {
                              var ntnvars$1 = lvar[1];
                              var ltacvars = lvar[0];
                              Curry._2(Names$ReactTemplate.Id[/* Map */10][/* iter */9], (function (_, param) {
                                      param[0][0] = /* false */0;
                                      return /* () */0;
                                    }), ntnvars$1);
                              var ntnvars$2 = Curry._1(Names$ReactTemplate.Id[/* Map */10][/* domain */27], ntnvars$1);
                              var extra = ltacvars[/* ltac_extra */2];
                              var lvars = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], ltacvars[/* ltac_bound */1], ltacvars[/* ltac_vars */0]);
                              var lvars$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], lvars, ntnvars$2);
                              var ltacvars$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], lvars$1, env[/* ids */0]);
                              var ist = /* record */[
                                /* ltacvars */ltacvars$1,
                                /* genv */globalenv,
                                /* extra */extra
                              ];
                              var match$27 = Genintern$ReactTemplate.generic_intern(ist, solve[0]);
                              solve$1 = /* Some */[match$27[1]];
                            } else {
                              solve$1 = /* None */0;
                            }
                            return DAst$ReactTemplate.make(loc, /* GHole */Block.__(13, [
                                          k$1,
                                          naming,
                                          solve$1
                                        ]));
                        case 13 : 
                            if (pattern_mode) {
                              return DAst$ReactTemplate.make(loc, /* GPatVar */Block.__(3, [/* SecondOrderPatVar */Block.__(1, [param[0]])]));
                            } else {
                              throw [
                                    InternalizationError,
                                    /* tuple */[
                                      loc,
                                      /* IllegalMetavariable */0
                                    ]
                                  ];
                            }
                            break;
                        case 14 : 
                            var l = param[1];
                            var n$2 = param[0];
                            var exit$1 = 0;
                            if (l) {
                              exit$1 = 1;
                            } else if (pattern_mode) {
                              return DAst$ReactTemplate.make(loc, /* GPatVar */Block.__(3, [/* FirstOrderPatVar */Block.__(0, [n$2])]));
                            } else {
                              exit$1 = 1;
                            }
                            if (exit$1 === 1) {
                              var partial_arg$2 = intern(env);
                              return DAst$ReactTemplate.make(loc, /* GEvar */Block.__(2, [
                                            n$2,
                                            Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                    return Util$ReactTemplate.on_snd(partial_arg$2, param);
                                                  }), l)
                                          ]));
                            }
                            break;
                        case 15 : 
                            return DAst$ReactTemplate.make(loc, /* GSort */Block.__(12, [param[0]]));
                        case 16 : 
                            return DAst$ReactTemplate.make(loc, /* GCast */Block.__(14, [
                                          intern(env)(param[0]),
                                          Miscops$ReactTemplate.map_cast_type(intern(set_type_scope(env)), param[1])
                                        ]));
                        case 17 : 
                            var ntn = param[0];
                            var exit$2 = 0;
                            switch (ntn) {
                              case "( _ )" : 
                                  var match$28 = param[1];
                                  var match$29 = match$28[0];
                                  if (match$29) {
                                    if (match$29[1]) {
                                      exit$2 = 1;
                                    } else if (match$28[1]) {
                                      exit$2 = 1;
                                    } else if (match$28[2]) {
                                      exit$2 = 1;
                                    } else if (match$28[3]) {
                                      exit$2 = 1;
                                    } else {
                                      return intern(env)(match$29[0]);
                                    }
                                  } else {
                                    exit$2 = 1;
                                  }
                                  break;
                              case "- _" : 
                                  var match$30 = param[1];
                                  var match$31 = match$30[0];
                                  if (match$31) {
                                    if (match$31[1]) {
                                      exit$2 = 1;
                                    } else if (match$30[1]) {
                                      exit$2 = 1;
                                    } else if (match$30[2]) {
                                      exit$2 = 1;
                                    } else if (match$30[3]) {
                                      exit$2 = 1;
                                    } else {
                                      var a = match$31[0];
                                      if (is_non_zero(a)) {
                                        var match$32 = a[/* v */0];
                                        var p;
                                        if (match$32.tag === 19) {
                                          var match$33 = match$32[0];
                                          if (match$33.tag) {
                                            throw [
                                                  Caml_builtin_exceptions.assert_failure,
                                                  [
                                                    "constrintern.ml",
                                                    1874,
                                                    69
                                                  ]
                                                ];
                                          } else {
                                            p = match$33[0];
                                          }
                                        } else {
                                          throw [
                                                Caml_builtin_exceptions.assert_failure,
                                                [
                                                  "constrintern.ml",
                                                  1874,
                                                  69
                                                ]
                                              ];
                                        }
                                        return intern(env)(CAst$ReactTemplate.make(loc, /* CPrim */Block.__(19, [/* Numeral */Block.__(0, [
                                                              p,
                                                              /* false */0
                                                            ])])));
                                      } else {
                                        exit$2 = 1;
                                      }
                                    }
                                  } else {
                                    exit$2 = 1;
                                  }
                                  break;
                              default:
                                exit$2 = 1;
                            }
                            if (exit$2 === 1) {
                              return intern_notation(intern, env, ntnvars, loc, ntn, param[1]);
                            }
                            break;
                        case 18 : 
                            var intern$1 = intern;
                            var env$1 = env;
                            var ntnvars$3 = ntnvars;
                            var loc$1 = loc;
                            var bk = param[0];
                            var ak = param[1];
                            var c$1 = param[2];
                            var c$2 = Curry._2(intern$1, /* record */[
                                  /* ids */env$1[/* ids */0],
                                  /* unb : true */1,
                                  /* tmp_scope */env$1[/* tmp_scope */2],
                                  /* scopes */env$1[/* scopes */3],
                                  /* impls */env$1[/* impls */4]
                                ], c$1);
                            var fvs = Implicit_quantifiers$ReactTemplate.generalizable_vars_of_glob_constr(/* Some */[env$1[/* ids */0]], /* None */0)(c$2);
                            var pi;
                            if (ak) {
                              pi = ak[0] !== 0 ? /* true */1 : /* false */0;
                            } else {
                              var match$34 = Notation$ReactTemplate.current_type_scope_name(/* () */0);
                              if (match$34) {
                                var type_scope = match$34[0];
                                var match$35 = env$1[/* tmp_scope */2];
                                var is_type_scope = match$35 ? +(match$35[0] === type_scope) : /* false */0;
                                pi = is_type_scope || Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem */1], type_scope, env$1[/* scopes */3]);
                              } else {
                                pi = /* false */0;
                              }
                            }
                            var abs = pi ? (function (param, acc) {
                                  var loc$prime = param[/* loc */1];
                                  var id = param[/* v */0];
                                  return DAst$ReactTemplate.make(Loc$ReactTemplate.merge_opt(loc$prime, loc$1), /* GProd */Block.__(6, [
                                                /* Name */[id],
                                                bk,
                                                DAst$ReactTemplate.make(loc$prime, /* GHole */Block.__(13, [
                                                        /* BinderType */Block.__(1, [/* Name */[id]]),
                                                        /* IntroAnonymous */0,
                                                        /* None */0
                                                      ])),
                                                acc
                                              ]));
                                }) : (function (param, acc) {
                                  var loc$prime = param[/* loc */1];
                                  var id = param[/* v */0];
                                  return DAst$ReactTemplate.make(Loc$ReactTemplate.merge_opt(loc$prime, loc$1), /* GLambda */Block.__(5, [
                                                /* Name */[id],
                                                bk,
                                                DAst$ReactTemplate.make(loc$prime, /* GHole */Block.__(13, [
                                                        /* BinderType */Block.__(1, [/* Name */[id]]),
                                                        /* IntroAnonymous */0,
                                                        /* None */0
                                                      ])),
                                                acc
                                              ]));
                                });
                            return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (lid, param) {
                                            var eta = /* Name */[lid[/* v */0]];
                                            var env$prime = push_name_env(/* None */0, ntnvars$3, /* tuple */[
                                                  /* Variable */2,
                                                  /* [] */0,
                                                  /* [] */0,
                                                  /* [] */0
                                                ], param[0], CAst$ReactTemplate.make(/* None */0, eta));
                                            return /* tuple */[
                                                    env$prime,
                                                    Curry._2(abs, lid, param[1])
                                                  ];
                                          }), fvs, /* tuple */[
                                          env$1,
                                          c$2
                                        ])[1];
                        case 19 : 
                            return Notation$ReactTemplate.interp_prim_token(loc)(param[0], /* tuple */[
                                          env[/* tmp_scope */2],
                                          env[/* scopes */3]
                                        ])[0];
                        case 20 : 
                            return intern(/* record */[
                                          /* ids */env[/* ids */0],
                                          /* unb */env[/* unb */1],
                                          /* tmp_scope : None */0,
                                          /* scopes : :: */[
                                            Notation$ReactTemplate.find_delimiters_scope(loc, param[0]),
                                            env[/* scopes */3]
                                          ],
                                          /* impls */env[/* impls */4]
                                        ])(param[1]);
                        case 21 : 
                            throw [
                                  Caml_builtin_exceptions.match_failure,
                                  [
                                    "constrintern.ml",
                                    1779,
                                    54
                                  ]
                                ];
                        
                      }
                    }), param);
      });
  };
  var intern_args = function (env, subscopes, param) {
    if (param) {
      var match = apply_scope_env(env, subscopes);
      return /* :: */[
              intern(match[0])(param[0]),
              intern_args(env, match[1], param[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  var intern_case_item = function (env, forbidden_names_for_gen, param) {
    var t = param[2];
    var na = param[1];
    var tm$prime = intern(env)(param[0]);
    var loc = tm$prime[/* loc */1];
    var match = DAst$ReactTemplate.get(tm$prime);
    var match$1;
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          var match$2 = match[0];
          if (match$2.tag) {
            exit = 1;
          } else if (na) {
            exit = 1;
          } else {
            var id = match$2[0];
            match$1 = /* tuple */[
              /* Some */[id],
              CAst$ReactTemplate.make(loc, /* Name */[id])
            ];
          }
          break;
      case 1 : 
          if (na) {
            exit = 1;
          } else {
            var id$1 = match[0];
            if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id$1, lvar[1])) {
              exit = 1;
            } else {
              match$1 = /* tuple */[
                /* Some */[id$1],
                CAst$ReactTemplate.make(loc, /* Name */[id$1])
              ];
            }
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      match$1 = na ? /* tuple */[
          /* None */0,
          na[0]
        ] : /* tuple */[
          /* None */0,
          CAst$ReactTemplate.make(/* None */0, /* Anonymous */0)
        ];
    }
    var na$1 = match$1[1];
    var match$3;
    if (t) {
      var t$1 = t[0];
      var match$4 = intern_ind_pattern(globalenv, ntnvars, /* tuple */[
            /* None */0,
            env[/* scopes */3]
          ], t$1);
      var match$5 = match$4[1];
      var ind = match$5[0];
      var with_letin = match$4[0];
      var match$6 = Inductive$ReactTemplate.lookup_mind_specif(globalenv, ind);
      var nparams = Curry._1(Util$ReactTemplate.List[/* length */0], match$6[0][/* mind_params_ctxt */7]);
      var canonize_args = function (_case_rel_ctxt, _arg_pats, _forbidden_names, _match_acc, _var_acc) {
        while(true) {
          var var_acc = _var_acc;
          var match_acc = _match_acc;
          var forbidden_names = _forbidden_names;
          var arg_pats = _arg_pats;
          var case_rel_ctxt = _case_rel_ctxt;
          var add_name = function (l, param) {
            var x = param[/* v */0];
            if (x) {
              return /* :: */[
                      /* tuple */[
                        x[0],
                        DAst$ReactTemplate.make(param[/* loc */1], /* PatVar */Block.__(0, [x]))
                      ],
                      l
                    ];
            } else {
              return l;
            }
          };
          if (case_rel_ctxt) {
            var match = case_rel_ctxt[0];
            var exit = 0;
            var cano_name;
            var ty;
            if (match.tag) {
              if (with_letin) {
                cano_name = match[0];
                ty = match[2];
                exit = 1;
              } else {
                _var_acc = /* :: */[
                  CAst$ReactTemplate.make(/* None */0, /* Anonymous */0),
                  var_acc
                ];
                _case_rel_ctxt = case_rel_ctxt[1];
                continue ;
                
              }
            } else {
              cano_name = match[0];
              ty = match[1];
              exit = 1;
            }
            if (exit === 1) {
              if (arg_pats) {
                var tt = arg_pats[1];
                var c = arg_pats[0];
                var t = case_rel_ctxt[1];
                var match$1 = DAst$ReactTemplate.get(c);
                if (match$1.tag) {
                  var fresh = Namegen$ReactTemplate.next_name_away_with_default_using_types("iV", cano_name, forbidden_names, EConstr$ReactTemplate.of_constr(ty));
                  _var_acc = /* :: */[
                    CAst$ReactTemplate.make(Glob_ops$ReactTemplate.cases_pattern_loc(c), /* Name */[fresh]),
                    var_acc
                  ];
                  _match_acc = /* :: */[
                    /* tuple */[
                      fresh,
                      c
                    ],
                    match_acc
                  ];
                  _forbidden_names = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], fresh, forbidden_names);
                  _arg_pats = tt;
                  _case_rel_ctxt = t;
                  continue ;
                  
                } else {
                  var x = match$1[0];
                  var loc = c[/* loc */1];
                  _var_acc = /* :: */[
                    CAst$ReactTemplate.make(loc, x),
                    var_acc
                  ];
                  _match_acc = add_name(match_acc, CAst$ReactTemplate.make(loc, x));
                  _arg_pats = tt;
                  _case_rel_ctxt = t;
                  continue ;
                  
                }
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "constrintern.ml",
                        2137,
                        14
                      ]
                    ];
              }
            }
            
          } else if (arg_pats) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "constrintern.ml",
                    2137,
                    14
                  ]
                ];
          } else {
            return /* tuple */[
                    add_name(match_acc, na$1),
                    var_acc
                  ];
          }
        };
      };
      var match$7 = Curry._2(Util$ReactTemplate.List[/* chop */99], nparams, Curry._1(Util$ReactTemplate.List[/* rev */4], match$6[1][/* mind_arity_ctxt */1]));
      var match$8 = canonize_args(match$7[1], match$5[1], forbidden_names_for_gen, /* [] */0, /* [] */0);
      match$3 = /* tuple */[
        match$8[0],
        /* Some */[CAst$ReactTemplate.make(Constrexpr_ops$ReactTemplate.cases_pattern_expr_loc(t$1), /* tuple */[
                ind,
                Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (x) {
                        return x[/* v */0];
                      }), match$8[1])
              ])]
      ];
    } else {
      match$3 = /* tuple */[
        /* [] */0,
        /* None */0
      ];
    }
    return /* tuple */[
            /* tuple */[
              tm$prime,
              /* tuple */[
                na$1[/* v */0],
                match$3[1]
              ]
            ],
            match$1[0],
            match$3[0]
          ];
  };
  var apply_impargs = function (c, env, imp, subscopes, l, loc) {
    var imp$1 = Impargs$ReactTemplate.select_impargs_size(Curry._1(Util$ReactTemplate.List[/* length */0], Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                    return +(param[1] === /* None */0);
                  }), l)), imp);
    var l$1 = intern_impargs(c, env, imp$1, subscopes, l);
    var f = c;
    var loc$1 = loc;
    var l$2 = l$1;
    if (l$2) {
      var loc$prime = f[/* loc */1];
      var match = DAst$ReactTemplate.get(f);
      if (match.tag === 4) {
        return DAst$ReactTemplate.make(Loc$ReactTemplate.merge_opt(loc$prime, loc$1), /* GApp */Block.__(4, [
                      match[0],
                      Util$ReactTemplate.$at(match[1], l$2)
                    ]));
      } else {
        return DAst$ReactTemplate.make(Loc$ReactTemplate.merge_opt(Glob_ops$ReactTemplate.loc_of_glob_constr(f), loc$1), /* GApp */Block.__(4, [
                      f,
                      l$2
                    ]));
      }
    } else {
      return f;
    }
  };
  var intern_local_binder = function (env, bind) {
    return intern_local_binder_aux(/* None */0, intern, ntnvars, env, bind);
  };
  var intern_disjunctive_multiple_pattern = function (env, loc, n, mpl) {
    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], mpl)) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "constrintern.ml",
              2072,
              4
            ]
          ];
    }
    var mpl$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            var env$1 = env;
            var n$1 = n;
            var pl = param;
            var partial_arg_001 = env$1[/* scopes */3];
            var partial_arg = /* tuple */[
              /* None */0,
              partial_arg_001
            ];
            var idsl_pll = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return intern_cases_pattern(globalenv, ntnvars, partial_arg, empty_alias, param);
                  }), pl);
            var loc = loc_of_multiple_pattern(pl);
            check_number_of_pattern(loc, n$1, pl);
            return product_of_cases_patterns(empty_alias, idsl_pll);
          }), mpl);
    var match = Curry._1(Util$ReactTemplate.List[/* split */36], mpl$prime);
    var idsl = match[0];
    var ids = Curry._1(Util$ReactTemplate.List[/* hd */1], idsl);
    check_or_pat_variables(loc, ids, Curry._1(Util$ReactTemplate.List[/* tl */2], idsl));
    return /* tuple */[
            ids,
            Curry._1(Util$ReactTemplate.List[/* flatten */8], match[1])
          ];
  };
  var intern_impargs = function (c, env, l, subscopes, args) {
    var match = extract_explicit_arg(l, args);
    var rargs = match[1];
    var eargs = match[0];
    if (parsing_explicit[0]) {
      if (Curry._1(Names$ReactTemplate.Id[/* Map */10][/* is_empty */1], eargs)) {
        return intern_args(env, subscopes, rargs);
      } else {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Arguments given by name or position not supported in explicit mode."));
      }
    } else {
      var aux = function (n, impl, subscopes, eargs, rargs) {
        var match = apply_scope_env(env, subscopes);
        var subscopes$prime = match[1];
        var enva = match[0];
        if (impl) {
          var impl$prime = impl[1];
          var imp = impl[0];
          if (Impargs$ReactTemplate.is_status_implicit(imp)) {
            try {
              var id = Impargs$ReactTemplate.name_of_implicit(imp);
              var match$1 = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], id, eargs);
              var eargs$prime = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* remove */5], id, eargs);
              return /* :: */[
                      intern(enva)(match$1[1]),
                      aux(n + 1 | 0, impl$prime, subscopes$prime, eargs$prime, rargs)
                    ];
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], rargs) && Curry._1(Names$ReactTemplate.Id[/* Map */10][/* is_empty */1], eargs) && !Impargs$ReactTemplate.maximal_insertion_of(imp)) {
                  return /* [] */0;
                } else {
                  return /* :: */[
                          DAst$ReactTemplate.map_from_loc((function (_, param) {
                                  return /* GHole */Block.__(13, [
                                            param[0],
                                            param[1],
                                            param[2]
                                          ]);
                                }), set_hole_implicit(/* tuple */[
                                    n,
                                    get_implicit_name(n, l)
                                  ], Impargs$ReactTemplate.force_inference_of(imp), c)),
                          aux(n + 1 | 0, impl$prime, subscopes$prime, eargs, rargs)
                        ];
                }
              } else {
                throw exn;
              }
            }
          } else if (rargs) {
            return /* :: */[
                    intern(enva)(rargs[0]),
                    aux(n + 1 | 0, impl$prime, subscopes$prime, eargs, rargs[1])
                  ];
          } else {
            if (!Curry._1(Names$ReactTemplate.Id[/* Map */10][/* is_empty */1], eargs)) {
              var match$2 = Curry._1(Names$ReactTemplate.Id[/* Map */10][/* choose */19], eargs);
              CErrors$ReactTemplate.user_err(match$2[1][0], /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Not enough non implicit arguments to accept the argument bound to "), Names$ReactTemplate.Id[/* print */8](match$2[0])), Pp$ReactTemplate.str(".")));
            }
            return /* [] */0;
          }
        } else {
          if (!Curry._1(Names$ReactTemplate.Id[/* Map */10][/* is_empty */1], eargs)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "constrintern.ml",
                    2181,
                    3
                  ]
                ];
          }
          return intern_args(env, subscopes, rargs);
        }
      };
      return aux(1, l, subscopes, eargs, rargs);
    }
  };
  try {
    return intern(env)(c);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === InternalizationError) {
      var match = exn[1];
      return CErrors$ReactTemplate.user_err(match[0], /* Some */["internalize"], explain_internalization_error(match[1]));
    } else {
      throw exn;
    }
  }
}

function extract_ids(env) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], Names$ReactTemplate.Id[/* Set */9][/* add */3], Termops$ReactTemplate.ids_of_rel_context(Environ$ReactTemplate.rel_context(env)), Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
}

function scope_of_type_kind(sigma, param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return /* None */0;
    } else {
      return Notation$ReactTemplate.current_type_scope_name(/* () */0);
    }
  } else {
    return Notation$ReactTemplate.compute_type_scope(sigma, param[0]);
  }
}

var empty_ltac_sign_000 = /* ltac_vars */Names$ReactTemplate.Id[/* Set */9][/* empty */0];

var empty_ltac_sign_001 = /* ltac_bound */Names$ReactTemplate.Id[/* Set */9][/* empty */0];

var empty_ltac_sign_002 = /* ltac_extra */Genintern$ReactTemplate.Store[/* empty */0];

var empty_ltac_sign = /* record */[
  empty_ltac_sign_000,
  empty_ltac_sign_001,
  empty_ltac_sign_002
];

function intern_gen(kind, env, sigma, $staropt$star, $staropt$star$1, $staropt$star$2, c) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  var pattern_mode = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var ltacvars = $staropt$star$2 ? $staropt$star$2[0] : empty_ltac_sign;
  var tmp_scope = scope_of_type_kind(sigma, kind);
  return internalize(env, /* record */[
              /* ids */extract_ids(env),
              /* unb : false */0,
              /* tmp_scope */tmp_scope,
              /* scopes : [] */0,
              /* impls */impls
            ], pattern_mode, /* tuple */[
              ltacvars,
              Names$ReactTemplate.Id[/* Map */10][/* empty */0]
            ], c);
}

function intern_constr(env, sigma, c) {
  return intern_gen(/* WithoutTypeConstraint */1, env, sigma, /* None */0, /* None */0, /* None */0, c);
}

function intern_type(env, sigma, c) {
  return intern_gen(/* IsType */0, env, sigma, /* None */0, /* None */0, /* None */0, c);
}

function intern_pattern(globalenv, patt) {
  try {
    return intern_cases_pattern(globalenv, Names$ReactTemplate.Id[/* Map */10][/* empty */0], /* tuple */[
                /* None */0,
                /* [] */0
              ], empty_alias, patt);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === InternalizationError) {
      var match = exn[1];
      return CErrors$ReactTemplate.user_err(match[0], /* Some */["internalize"], explain_internalization_error(match[1]));
    } else {
      throw exn;
    }
  }
}

function interp_gen(kind, env, sigma, $staropt$star, c) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  var c$1 = intern_gen(kind, env, sigma, /* Some */[impls], /* None */0, /* None */0, c);
  return Pretyping$ReactTemplate.understand(/* None */0, /* Some */[kind], env, sigma, c$1);
}

function interp_constr(env, sigma, _, c) {
  return interp_gen(/* WithoutTypeConstraint */1, env, sigma, /* None */0, c);
}

function interp_type(env, sigma, $staropt$star, c) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  return interp_gen(/* IsType */0, env, sigma, /* Some */[impls], c);
}

function interp_casted_constr(env, sigma, $staropt$star, c, typ) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  return interp_gen(/* OfType */[typ], env, sigma, /* Some */[impls], c);
}

function interp_open_constr(env, sigma, c) {
  return Pretyping$ReactTemplate.understand_tcc(/* None */0, env, sigma, /* None */0, intern_constr(env, sigma, c));
}

function interp_constr_evars_gen_impls(env, sigma, $staropt$star, expected_type, c) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  var c$1 = intern_gen(expected_type, env, sigma, /* Some */[impls], /* None */0, /* None */0, c);
  var imps = Implicit_quantifiers$ReactTemplate.implicits_of_glob_constr(/* Some */[+(expected_type === /* IsType */0)], c$1);
  var match = Pretyping$ReactTemplate.understand_tcc(/* None */0, env, sigma, /* Some */[expected_type], c$1);
  return /* tuple */[
          match[0],
          /* tuple */[
            match[1],
            imps
          ]
        ];
}

function interp_constr_evars_impls(env, sigma, $staropt$star, c) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  return interp_constr_evars_gen_impls(env, sigma, /* Some */[impls], /* WithoutTypeConstraint */1, c);
}

function interp_casted_constr_evars_impls(env, evdref, $staropt$star, c, typ) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  return interp_constr_evars_gen_impls(env, evdref, /* Some */[impls], /* OfType */[typ], c);
}

function interp_type_evars_impls(env, sigma, $staropt$star, c) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  return interp_constr_evars_gen_impls(env, sigma, /* Some */[impls], /* IsType */0, c);
}

function interp_constr_evars_gen(env, sigma, $staropt$star, expected_type, c) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  var c$1 = intern_gen(expected_type, env, sigma, /* Some */[impls], /* None */0, /* None */0, c);
  return Pretyping$ReactTemplate.understand_tcc(/* None */0, env, sigma, /* Some */[expected_type], c$1);
}

function interp_constr_evars(env, evdref, $staropt$star, c) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  return interp_constr_evars_gen(env, evdref, /* Some */[impls], /* WithoutTypeConstraint */1, c);
}

function interp_casted_constr_evars(env, sigma, $staropt$star, c, typ) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  return interp_constr_evars_gen(env, sigma, /* Some */[impls], /* OfType */[typ], c);
}

function interp_type_evars(env, sigma, $staropt$star, c) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  return interp_constr_evars_gen(env, sigma, /* Some */[impls], /* IsType */0, c);
}

function intern_constr_pattern(env, sigma, $staropt$star, $staropt$star$1, c) {
  var as_type = $staropt$star ? $staropt$star[0] : /* false */0;
  var ltacvars = $staropt$star$1 ? $staropt$star$1[0] : empty_ltac_sign;
  return Patternops$ReactTemplate.pattern_of_glob_constr(intern_gen(as_type ? /* IsType */0 : /* WithoutTypeConstraint */1, env, sigma, /* None */0, /* Some */[/* true */1], /* Some */[ltacvars], c));
}

function interp_notation_constr(env, $staropt$star, nenv, a) {
  var impls = $staropt$star ? $staropt$star[0] : empty_internalization_env;
  var vl = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* map */22], (function (typ) {
          return /* tuple */[
                  [/* false */0],
                  [/* None */0],
                  typ
                ];
        }), nenv[/* ninterp_var_type */0]);
  var impls$1 = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], (function (id, _, impls) {
          return Curry._2(Names$ReactTemplate.Id[/* Map */10][/* remove */5], id, impls);
        }), nenv[/* ninterp_var_type */0], impls);
  var c = internalize(Global$ReactTemplate.env(/* () */0), /* record */[
        /* ids */extract_ids(env),
        /* unb : false */0,
        /* tmp_scope : None */0,
        /* scopes : [] */0,
        /* impls */impls$1
      ], /* false */0, /* tuple */[
        empty_ltac_sign,
        vl
      ], a);
  var match = Notation_ops$ReactTemplate.notation_constr_of_glob_constr(nenv, c);
  var reversible = match[1];
  var out_scope = function (param) {
    if (param) {
      var match = param[0];
      return /* tuple */[
              match[0],
              match[1]
            ];
    } else {
      return /* tuple */[
              /* None */0,
              /* [] */0
            ];
    }
  };
  var unused = typeof reversible === "number" ? /* [] */0 : reversible[0];
  var vars = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mapi */23], (function (id, param) {
          return /* tuple */[
                  param[0][0] && 1 - Curry._3(Util$ReactTemplate.List[/* mem_f */47], Names$ReactTemplate.Id[/* equal */0], id, unused),
                  out_scope(param[1][0])
                ];
        }), vl);
  return /* tuple */[
          vars,
          match[0],
          reversible
        ];
}

function interp_binder(env, sigma, na, t) {
  var t$1 = intern_gen(/* IsType */0, env, sigma, /* None */0, /* None */0, /* None */0, t);
  var t$prime = locate_if_hole(Glob_ops$ReactTemplate.loc_of_glob_constr(t$1), na, t$1);
  return Pretyping$ReactTemplate.understand(/* None */0, /* Some */[/* IsType */0], env, sigma, t$prime);
}

function interp_binder_evars(env, sigma, na, t) {
  var t$1 = intern_gen(/* IsType */0, env, sigma, /* None */0, /* None */0, /* None */0, t);
  var t$prime = locate_if_hole(Glob_ops$ReactTemplate.loc_of_glob_constr(t$1), na, t$1);
  return Pretyping$ReactTemplate.understand_tcc(/* None */0, env, sigma, /* Some */[/* IsType */0], t$prime);
}

function intern_context(global_level, env, impl_env, binders) {
  try {
    var lvar_001 = Names$ReactTemplate.Id[/* Map */10][/* empty */0];
    var lvar = /* tuple */[
      empty_ltac_sign,
      lvar_001
    ];
    var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, b) {
            var match = intern_local_binder_aux(/* Some */[global_level], (function (param, param$1) {
                    var env$1 = env;
                    var lvar$1 = lvar;
                    var acc = param;
                    var c = param$1;
                    return internalize(env$1, acc, /* false */0, lvar$1, c);
                  }), Names$ReactTemplate.Id[/* Map */10][/* empty */0], /* tuple */[
                  param[0],
                  param[1]
                ], b);
            return /* tuple */[
                    match[0],
                    match[1]
                  ];
          }), /* tuple */[
          /* record */[
            /* ids */extract_ids(env),
            /* unb : false */0,
            /* tmp_scope : None */0,
            /* scopes : [] */0,
            /* impls */impl_env
          ],
          /* [] */0
        ], binders);
    return /* tuple */[
            match[0][/* impls */4],
            Curry._2(Util$ReactTemplate.List[/* map */10], glob_local_binder_of_extended, match[1])
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === InternalizationError) {
      var match$1 = exn[1];
      return CErrors$ReactTemplate.user_err(match$1[0], /* Some */["internalize"], explain_internalization_error(match$1[1]));
    } else {
      throw exn;
    }
  }
}

function interp_glob_context_evars(env, sigma, k, bl) {
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
          var t = param$1[3];
          var b = param$1[2];
          var na = param$1[0];
          var impls = param[4];
          var n = param[3];
          var params = param[2];
          var env = param[0];
          var t$prime = Option$ReactTemplate.is_empty(b) ? locate_if_hole(Glob_ops$ReactTemplate.loc_of_glob_constr(t), na, t) : t;
          var match = Pretyping$ReactTemplate.understand_tcc(/* None */0, env, param[1], /* Some */[/* IsType */0], t$prime);
          var t$1 = match[1];
          var sigma = match[0];
          if (b) {
            var match$1 = Pretyping$ReactTemplate.understand_tcc(/* None */0, env, sigma, /* Some */[/* OfType */[t$1]], b[0]);
            var d_001 = match$1[1];
            var d = /* LocalDef */Block.__(1, [
                na,
                d_001,
                t$1
              ]);
            return /* tuple */[
                    EConstr$ReactTemplate.push_rel(d, env),
                    match$1[0],
                    /* :: */[
                      d,
                      params
                    ],
                    n,
                    impls
                  ];
          } else {
            var d$1 = /* LocalAssum */Block.__(0, [
                na,
                t$1
              ]);
            var impls$1;
            if (param$1[1] === /* Implicit */1) {
              var na$1 = na ? /* Some */[na[0]] : /* None */0;
              impls$1 = /* :: */[
                /* tuple */[
                  /* ExplByPos */Block.__(0, [
                      n,
                      na$1
                    ]),
                  /* tuple */[
                    /* true */1,
                    /* true */1,
                    /* true */1
                  ]
                ],
                impls
              ];
            } else {
              impls$1 = impls;
            }
            return /* tuple */[
                    EConstr$ReactTemplate.push_rel(d$1, env),
                    sigma,
                    /* :: */[
                      d$1,
                      params
                    ],
                    n + 1 | 0,
                    impls$1
                  ];
          }
        }), /* tuple */[
        env,
        sigma,
        /* [] */0,
        k + 1 | 0,
        /* [] */0
      ], Curry._1(Util$ReactTemplate.List[/* rev */4], bl));
  return /* tuple */[
          match[1],
          /* tuple */[
            /* tuple */[
              match[0],
              match[2]
            ],
            match[4]
          ]
        ];
}

function interp_context_evars($staropt$star, $staropt$star$1, $staropt$star$2, env, sigma, params) {
  var global_level = $staropt$star ? $staropt$star[0] : /* false */0;
  var impl_env = $staropt$star$1 ? $staropt$star$1[0] : empty_internalization_env;
  var shift = $staropt$star$2 ? $staropt$star$2[0] : 0;
  var match = intern_context(global_level, env, impl_env, params);
  var match$1 = interp_glob_context_evars(env, sigma, shift, match[1]);
  return /* tuple */[
          match$1[0],
          /* tuple */[
            match[0],
            match$1[1]
          ]
        ];
}

exports.empty_internalization_env = empty_internalization_env;
exports.compute_internalization_data = compute_internalization_data;
exports.compute_internalization_env = compute_internalization_env;
exports.empty_ltac_sign = empty_ltac_sign;
exports.intern_constr = intern_constr;
exports.intern_type = intern_type;
exports.intern_gen = intern_gen;
exports.intern_pattern = intern_pattern;
exports.intern_context = intern_context;
exports.interp_constr = interp_constr;
exports.interp_casted_constr = interp_casted_constr;
exports.interp_type = interp_type;
exports.interp_open_constr = interp_open_constr;
exports.interp_constr_evars = interp_constr_evars;
exports.interp_casted_constr_evars = interp_casted_constr_evars;
exports.interp_type_evars = interp_type_evars;
exports.interp_constr_evars_impls = interp_constr_evars_impls;
exports.interp_casted_constr_evars_impls = interp_casted_constr_evars_impls;
exports.interp_type_evars_impls = interp_type_evars_impls;
exports.intern_constr_pattern = intern_constr_pattern;
exports.interp_reference = interp_reference;
exports.interp_binder = interp_binder;
exports.interp_binder_evars = interp_binder_evars;
exports.interp_context_evars = interp_context_evars;
exports.locate_reference = locate_reference;
exports.is_global = is_global;
exports.construct_reference = construct_reference;
exports.global_reference = global_reference;
exports.global_reference_in_absolute_module = global_reference_in_absolute_module;
exports.interp_notation_constr = interp_notation_constr;
exports.parsing_explicit = parsing_explicit;
exports.for_grammar = for_grammar;
/* explain_illegal_metavariable Not a pure module */
