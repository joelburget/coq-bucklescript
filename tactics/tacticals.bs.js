// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Loc$ReactTemplate = require("../src/loc.bs.js");
var CAst$ReactTemplate = require("../src/cAst.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Clenv$ReactTemplate = require("../proofs/clenv.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Indrec$ReactTemplate = require("../src/indrec.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Exninfo$ReactTemplate = require("../src/exninfo.bs.js");
var Refiner$ReactTemplate = require("../src/refiner.bs.js");
var Tacmach$ReactTemplate = require("../proofs/tacmach.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Clenvtac$ReactTemplate = require("../proofs/clenvtac.bs.js");
var Locusops$ReactTemplate = require("../src/locusops.bs.js");
var Retyping$ReactTemplate = require("../src/retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Proofview$ReactTemplate = require("../src/proofview.bs.js");
var Declareops$ReactTemplate = require("../src/declareops.bs.js");
var Unification$ReactTemplate = require("../pretyping/unification.bs.js");
var Pretype_errors$ReactTemplate = require("../src/pretype_errors.bs.js");

function nthDecl(m, gl) {
  try {
    return Curry._2(Util$ReactTemplate.List[/* nth */3], Tacmach$ReactTemplate.pf_hyps(gl), m - 1 | 0);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such assumption."));
    } else {
      throw exn;
    }
  }
}

function nthHypId(m, gl) {
  return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], nthDecl(m, gl));
}

function lastDecl(gl) {
  return nthDecl(1, gl);
}

function lastHypId(gl) {
  return nthHypId(1, gl);
}

function lastHyp(gl) {
  return EConstr$ReactTemplate.mkVar(nthHypId(1, gl));
}

function nLastDecls(n, gl) {
  try {
    return Curry._2(Util$ReactTemplate.List[/* firstn */104], n, Tacmach$ReactTemplate.pf_hyps(gl));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough hypotheses in the goal."));
    } else {
      throw exn;
    }
  }
}

function nLastHypsId(n, gl) {
  return Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], nLastDecls(n, gl));
}

function nLastHyps(n, gl) {
  return Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.mkVar, nLastHypsId(n, gl));
}

function onNthDecl(m, tac, gl) {
  return Curry._2(tac, nthDecl(m, gl), gl);
}

function onNthHypId(m, tac, gl) {
  return Curry._2(tac, nthHypId(m, gl), gl);
}

function onNthHyp(m, tac, gl) {
  return Curry._2(tac, EConstr$ReactTemplate.mkVar(nthHypId(m, gl)), gl);
}

function onLastDecl(param, param$1) {
  return onNthDecl(1, param, param$1);
}

function onLastHypId(param, param$1) {
  return onNthHypId(1, param, param$1);
}

function onLastHyp(param, param$1) {
  return onNthHyp(1, param, param$1);
}

function onHyps(find, tac, gl) {
  return Curry._2(tac, Curry._1(find, gl), gl);
}

function onNLastDecls(n, tac) {
  return (function (param) {
      return Curry._2(tac, nLastDecls(n, param), param);
    });
}

function onNLastHypsId(n, tac) {
  return (function (param) {
      return Curry._2(tac, nLastHypsId(n, param), param);
    });
}

function onNLastHyps(n, tac) {
  return (function (param) {
      return Curry._2(tac, nLastHyps(n, param), param);
    });
}

function afterHyp(id, gl) {
  var partial_arg = Names$ReactTemplate.Id[/* equal */0];
  var partial_arg$1 = function (param) {
    return partial_arg(id, param);
  };
  var partial_arg$2 = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
  return Curry._2(Util$ReactTemplate.List[/* split_when */102], (function (param) {
                  return Util$ReactTemplate.$percent$great(partial_arg$2, partial_arg$1, param);
                }), Tacmach$ReactTemplate.pf_hyps(gl))[0];
}

function fullGoal(gl) {
  return /* :: */[
          /* None */0,
          Curry._2(Util$ReactTemplate.List[/* map */10], Option$ReactTemplate.make, Tacmach$ReactTemplate.pf_ids_of_hyps(gl))
        ];
}

function onAllHyps(tac, gl) {
  return Curry._1(Refiner$ReactTemplate.tclMAP(tac, Tacmach$ReactTemplate.pf_ids_of_hyps(gl)), gl);
}

function onAllHypsAndConcl(tac, gl) {
  return Curry._1(Refiner$ReactTemplate.tclMAP(tac, fullGoal(gl)), gl);
}

function onClause(tac, cl, gls) {
  var hyps = function () {
    return Tacmach$ReactTemplate.pf_ids_of_hyps(gls);
  };
  return Curry._1(Refiner$ReactTemplate.tclMAP(tac, Locusops$ReactTemplate.simple_clause_of(hyps, cl)), gls);
}

function onClauseLR(tac, cl, gls) {
  var hyps = function () {
    return Tacmach$ReactTemplate.pf_ids_of_hyps(gls);
  };
  return Curry._1(Refiner$ReactTemplate.tclMAP(tac, Curry._1(Util$ReactTemplate.List[/* rev */4], Locusops$ReactTemplate.simple_clause_of(hyps, cl))), gls);
}

function ifOnHyp(pred, tac1, tac2, id, gl) {
  if (Curry._1(pred, /* tuple */[
          id,
          Tacmach$ReactTemplate.pf_get_hyp_typ(gl, id)
        ])) {
    return Curry._2(tac1, id, gl);
  } else {
    return Curry._2(tac2, id, gl);
  }
}

function fix_empty_or_and_pattern(nv, l) {
  if (l.tag) {
    return l;
  } else {
    var match = l[0];
    if (match && !(match[0] || match[1])) {
      return /* IntroOrPattern */Block.__(0, [Curry._2(Util$ReactTemplate.List[/* make */56], nv, /* [] */0)]);
    } else {
      return l;
    }
  }
}

function check_or_and_pattern_size(loc, check_and, names, branchsigns) {
  var n = branchsigns.length;
  var msg = function (p1, p2) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("a conjunctive pattern made of "), Pp$ReactTemplate.$$int(p1)), p1 === p2 ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" or "), Pp$ReactTemplate.$$int(p2))), Pp$ReactTemplate.str(" patterns"));
  };
  var err1 = function (p1, p2) {
    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Expects "), msg(p1, p2)), Pp$ReactTemplate.str(".")));
  };
  var errn = function (n) {
    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Expects a disjunctive pattern with "), Pp$ReactTemplate.$$int(n)), Pp$ReactTemplate.str(" branches.")));
  };
  var err1$prime = function (p1, p2) {
    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Expects a disjunctive pattern with 1 branch or "), msg(p1, p2)), Pp$ReactTemplate.str(".")));
  };
  var errforthcoming = function (loc) {
    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.strbrk("Unexpected non atomic pattern."));
  };
  if (names.tag) {
    var l = names[0];
    if (n !== 1) {
      errn(n);
    }
    var l$prime = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
            switch (param[/* v */0].tag | 0) {
              case 0 : 
                  return /* true */1;
              case 1 : 
              case 2 : 
                  return /* false */0;
              
            }
          }), l);
    if (l$prime !== /* [] */0) {
      errforthcoming(Curry._1(Util$ReactTemplate.List[/* hd */1], l$prime)[/* loc */1]);
    }
    if (check_and) {
      var p1 = Curry._2(Util$ReactTemplate.List[/* count */76], (function (x) {
              return x;
            }), Caml_array.caml_array_get(branchsigns, 0));
      var p2 = Curry._1(Util$ReactTemplate.List[/* length */0], Caml_array.caml_array_get(branchsigns, 0));
      var p = Curry._1(Util$ReactTemplate.List[/* length */0], l);
      if (!(p === p1 || p === p2)) {
        err1(p1, p2);
      }
      if (p === p1) {
        return /* IntroAndPattern */Block.__(1, [Curry._3(Util$ReactTemplate.List[/* extend */75], Caml_array.caml_array_get(branchsigns, 0), CAst$ReactTemplate.make(/* None */0, /* IntroNaming */Block.__(1, [/* IntroAnonymous */0])), l)]);
      } else {
        return names;
      }
    } else {
      return names;
    }
  } else {
    if (n !== Curry._1(Util$ReactTemplate.List[/* length */0], names[0])) {
      if (n === 1) {
        var p1$1 = Curry._2(Util$ReactTemplate.List[/* count */76], (function (x) {
                return x;
              }), Caml_array.caml_array_get(branchsigns, 0));
        var p2$1 = Curry._1(Util$ReactTemplate.List[/* length */0], Caml_array.caml_array_get(branchsigns, 0));
        err1$prime(p1$1, p2$1);
      } else {
        errn(n);
      }
    }
    return names;
  }
}

function get_and_check_or_and_pattern_gen(loc, check_and, names, branchsigns) {
  var names$1 = check_or_and_pattern_size(loc, check_and, names, branchsigns);
  if (names$1.tag) {
    return /* array */[names$1[0]];
  } else {
    return Util$ReactTemplate.$$Array[/* of_list */10](names$1[0]);
  }
}

function get_and_check_or_and_pattern(loc) {
  return (function (param, param$1) {
      return get_and_check_or_and_pattern_gen(loc, /* true */1, param, param$1);
    });
}

function compute_induction_names_gen(check_and, branchletsigns, param) {
  if (param) {
    var match = param[0];
    var names = fix_empty_or_and_pattern(branchletsigns.length, match[/* v */0]);
    return get_and_check_or_and_pattern_gen(match[/* loc */1], check_and, names, branchletsigns);
  } else {
    return Caml_array.caml_make_vect(branchletsigns.length, /* [] */0);
  }
}

function compute_induction_names(param, param$1) {
  return compute_induction_names_gen(/* true */1, param, param$1);
}

function compute_constructor_signatures(isrec, param) {
  var ity = param[0];
  var k = ity[1];
  var analrec = function (c, recargs) {
    var match = Constr$ReactTemplate.kind(c);
    var exit = 0;
    switch (match.tag | 0) {
      case 6 : 
          if (recargs) {
            var rest = analrec(match[2], recargs[1]);
            var match$1 = Declareops$ReactTemplate.dest_recarg(recargs[0]);
            if (typeof match$1 === "number") {
              return /* :: */[
                      /* true */1,
                      rest
                    ];
            } else if (match$1.tag) {
              return /* :: */[
                      /* true */1,
                      rest
                    ];
            } else if (isrec && match$1[0][1] === k) {
              return /* :: */[
                      /* true */1,
                      /* :: */[
                        /* true */1,
                        rest
                      ]
                    ];
            } else {
              return /* :: */[
                      /* true */1,
                      rest
                    ];
            }
          } else {
            exit = 1;
          }
          break;
      case 8 : 
          return /* :: */[
                  /* false */0,
                  analrec(match[3], recargs)
                ];
      default:
        exit = 1;
    }
    if (exit === 1) {
      if (recargs) {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("compute_constructor_signatures."));
      } else {
        return /* [] */0;
      }
    }
    
  };
  var match = Global$ReactTemplate.lookup_inductive(ity);
  var mip = match[1];
  var n = match[0][/* mind_nparams */5];
  var lc = Util$ReactTemplate.$$Array[/* map */12]((function (c) {
          return Term$ReactTemplate.decompose_prod_n_assum(n)(c)[1];
        }), mip[/* mind_nf_lc */8]);
  var lrecargs = Declareops$ReactTemplate.dest_subterms(mip[/* mind_recargs */11]);
  return Util$ReactTemplate.$$Array[/* map2 */49](analrec, lc, lrecargs);
}

function elimination_sort_of_goal(gl) {
  return Curry._1(Tacmach$ReactTemplate.pf_apply((function (eta) {
                    return (function (param, param$1) {
                        return Retyping$ReactTemplate.get_sort_family_of(/* None */0, /* None */0, eta, param, param$1);
                      });
                  }), gl), Tacmach$ReactTemplate.pf_concl(gl));
}

function elimination_sort_of_hyp(id, gl) {
  return Curry._1(Tacmach$ReactTemplate.pf_apply((function (eta) {
                    return (function (param, param$1) {
                        return Retyping$ReactTemplate.get_sort_family_of(/* None */0, /* None */0, eta, param, param$1);
                      });
                  }), gl), Tacmach$ReactTemplate.pf_get_hyp_typ(gl, id));
}

function elimination_sort_of_clause(param) {
  if (param) {
    var partial_arg = param[0];
    return (function (param) {
        return elimination_sort_of_hyp(partial_arg, param);
      });
  } else {
    return elimination_sort_of_goal;
  }
}

function pf_with_evars(glsev, k, gls) {
  var match = Curry._1(glsev, gls);
  var evd = match[0];
  return Refiner$ReactTemplate.tclTHEN((function (param) {
                  return Refiner$ReactTemplate.tclEVARS(evd, param);
                }), Curry._1(k, match[1]))(gls);
}

function pf_constr_of_global(gr, k) {
  return (function (param) {
      return pf_with_evars((function (gls) {
                    return Util$ReactTemplate.on_snd(EConstr$ReactTemplate.of_constr, Curry._1(Tacmach$ReactTemplate.pf_apply((function (eta) {
                                          return (function (param, param$1) {
                                              return Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, eta, param, param$1);
                                            });
                                        }), gls), gr));
                  }), k, param);
    });
}

var tclIDTAC = Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);

function tclTHEN(t1, t2) {
  return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], t1, t2);
}

function tclFAIL(lvl, msg) {
  return Proofview$ReactTemplate.tclZERO(/* None */0, [
              Refiner$ReactTemplate.FailError,
              lvl,
              Block.__(250, [msg])
            ]);
}

function tclZEROMSG(loc, msg) {
  var err = [
    CErrors$ReactTemplate.UserError,
    /* None */0,
    msg
  ];
  var info = loc ? Loc$ReactTemplate.add_loc(Exninfo$ReactTemplate.$$null, loc[0]) : Exninfo$ReactTemplate.$$null;
  return Proofview$ReactTemplate.tclZERO(/* Some */[info], err);
}

function catch_failerror(e) {
  try {
    Refiner$ReactTemplate.catch_failerror(e);
    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
  }
  catch (raw_e){
    var e$1 = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e$1)) {
      return Proofview$ReactTemplate.tclZERO(/* None */0, e$1);
    } else {
      throw e$1;
    }
  }
}

function tclOR(t1, t2) {
  return Proofview$ReactTemplate.tclINDEPENDENT(Curry._2(Proofview$ReactTemplate.tclOR, t1, (function (e) {
                    return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], catch_failerror(e), t2);
                  })));
}

function tclORD(t1, t2) {
  return Proofview$ReactTemplate.tclINDEPENDENT(Curry._2(Proofview$ReactTemplate.tclOR, t1, (function (e) {
                    return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], catch_failerror(e), Curry._1(t2, /* () */0));
                  })));
}

function tclEXACTLY_ONCE(t) {
  return Proofview$ReactTemplate.tclEXACTLY_ONCE([
              Refiner$ReactTemplate.FailError,
              0,
              Block.__(246, [(function () {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "tacticals.ml",
                              321,
                              78
                            ]
                          ];
                    })])
            ], t);
}

function tclIFCATCH(t, tt, te) {
  return Proofview$ReactTemplate.tclINDEPENDENT(Proofview$ReactTemplate.tclIFCATCH(t, tt, (function (e) {
                    return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], catch_failerror(e), Curry._1(te, /* () */0));
                  })));
}

function tclORELSE0(t1, t2) {
  return Proofview$ReactTemplate.tclINDEPENDENT(Proofview$ReactTemplate.tclORELSE(t1, (function (e) {
                    return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], catch_failerror(e), t2);
                  })));
}

function tclORELSE(t1, t2) {
  return tclORELSE0(Proofview$ReactTemplate.tclPROGRESS(t1), t2);
}

function tclTHENS3PARTS(t1, l1, repeat, l2) {
  return Proofview$ReactTemplate.tclINDEPENDENT(Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], t1, Proofview$ReactTemplate.tclORELSE(Proofview$ReactTemplate.tclEXTEND(Util$ReactTemplate.$$Array[/* to_list */9](l1), repeat, Util$ReactTemplate.$$Array[/* to_list */9](l2)), (function (param) {
                        var e = param[0];
                        if (e[0] === Proofview$ReactTemplate.SizeMismatch) {
                          var i = e[1];
                          var errmsg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incorrect number of goals"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("(expected ")), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], i, " tactic"))), Pp$ReactTemplate.str(")"));
                          return tclFAIL(0, errmsg);
                        } else {
                          return Proofview$ReactTemplate.tclZERO(/* Some */[param[1]], e);
                        }
                      }))));
}

function tclTHENSFIRSTn(t1, l, repeat) {
  return tclTHENS3PARTS(t1, l, repeat, /* array */[]);
}

function tclTHENFIRSTn(t1, l) {
  return tclTHENSFIRSTn(t1, l, Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0));
}

function tclTHENFIRST(t1, t2) {
  return tclTHENFIRSTn(t1, /* array */[t2]);
}

function tclTHENLASTn(t1, l) {
  return tclTHENS3PARTS(t1, /* array */[], Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0), l);
}

function tclTHENLAST(t1, t2) {
  return tclTHENLASTn(t1, /* array */[t2]);
}

function tclTHENS(t, l) {
  return Proofview$ReactTemplate.tclINDEPENDENT(Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], t, Proofview$ReactTemplate.tclORELSE(Proofview$ReactTemplate.tclDISPATCH(l), (function (param) {
                        var e = param[0];
                        if (e[0] === Proofview$ReactTemplate.SizeMismatch) {
                          var i = e[1];
                          var errmsg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incorrect number of goals"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("(expected ")), Pp$ReactTemplate.$$int(i)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], i, " tactic"))), Pp$ReactTemplate.str(")"));
                          return tclFAIL(0, errmsg);
                        } else {
                          return Proofview$ReactTemplate.tclZERO(/* Some */[param[1]], e);
                        }
                      }))));
}

function tclTHENLIST(l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], tclTHEN, Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0), l);
}

function tclMAP(tacfun, l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (x) {
                var partial_arg = Curry._1(tacfun, x);
                return (function (param) {
                    return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], partial_arg, param);
                  });
              }), l, Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0));
}

function tclTRY(t) {
  return tclORELSE0(t, Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0));
}

function tclTRYb(t) {
  var t1 = Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], t, Curry._1(Proofview$ReactTemplate.tclUNIT, /* true */1));
  var t2 = Curry._1(Proofview$ReactTemplate.tclUNIT, /* false */0);
  return Proofview$ReactTemplate.tclINDEPENDENTL(Proofview$ReactTemplate.tclORELSE(t1, (function (e) {
                    return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], catch_failerror(e), t2);
                  })));
}

function tclIFTHENELSE(t1, t2, t3) {
  return Proofview$ReactTemplate.tclINDEPENDENT(Proofview$ReactTemplate.tclIFCATCH(t1, (function () {
                    return t2;
                  }), (function (param) {
                    var info = param[1];
                    var e = param[0];
                    return Proofview$ReactTemplate.tclORELSE(t3, (function () {
                                  return Proofview$ReactTemplate.tclZERO(/* Some */[info], e);
                                }));
                  })));
}

function tclIFTHENSVELSE(t1, a, t3) {
  return Proofview$ReactTemplate.tclIFCATCH(t1, (function () {
                return Proofview$ReactTemplate.tclDISPATCH(Util$ReactTemplate.$$Array[/* to_list */9](a));
              }), (function () {
                return t3;
              }));
}

function tclIFTHENTRYELSEMUST(t1, t2) {
  return tclIFTHENELSE(t1, tclORELSE0(t2, Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0)), t2);
}

function tclIFTHENFIRSTTRYELSEMUST(t1, t2) {
  var t1$1 = t1;
  var t2$1 = tclORELSE0(t2, Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0));
  var t3 = t2;
  return Proofview$ReactTemplate.tclIFCATCH(t1$1, (function () {
                return Proofview$ReactTemplate.tclEXTEND(/* :: */[
                            t2$1,
                            /* [] */0
                          ], Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0), /* [] */0);
              }), (function () {
                return t3;
              }));
}

function tclFIRST(param) {
  if (param) {
    return tclORELSE0(param[0], tclFIRST(param[1]));
  } else {
    return tclZEROMSG(/* None */0, Pp$ReactTemplate.str("No applicable tactic."));
  }
}

function tclFIRST_PROGRESS_ON(tac, param) {
  if (param) {
    var tl = param[1];
    var a = param[0];
    if (tl) {
      var t2 = tclFIRST_PROGRESS_ON(tac, tl);
      var t1 = Curry._1(tac, a);
      return tclORELSE0(Proofview$ReactTemplate.tclPROGRESS(t1), t2);
    } else {
      return Curry._1(tac, a);
    }
  } else {
    return tclFAIL(0, Pp$ReactTemplate.str("No applicable tactic"));
  }
}

function tclDO(n, t) {
  if (n < 0) {
    return tclZEROMSG(/* None */0, Pp$ReactTemplate.str("Wrong argument : Do needs a positive integer."));
  } else if (n) {
    if (n === 1) {
      return t;
    } else {
      var t2 = tclDO(n - 1 | 0, t);
      return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], t, t2);
    }
  } else {
    return Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0);
  }
}

function tclREPEAT0(t) {
  return Proofview$ReactTemplate.tclINDEPENDENT(Proofview$ReactTemplate.tclIFCATCH(t, (function () {
                    return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.tclCHECKINTERRUPT, tclREPEAT0(t));
                  }), (function (e) {
                    return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], catch_failerror(e), Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0));
                  })));
}

function tclREPEAT(t) {
  return tclREPEAT0(Proofview$ReactTemplate.tclPROGRESS(t));
}

function tclREPEAT_MAIN0(t) {
  return Proofview$ReactTemplate.tclIFCATCH(t, (function () {
                return Proofview$ReactTemplate.tclTRYFOCUS(1, 1, tclREPEAT_MAIN0(t));
              }), (function (e) {
                return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], catch_failerror(e), Curry._1(Proofview$ReactTemplate.tclUNIT, /* () */0));
              }));
}

function tclREPEAT_MAIN(t) {
  return tclREPEAT_MAIN0(Proofview$ReactTemplate.tclPROGRESS(t));
}

function tclCOMPLETE(t) {
  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], t, (function (res) {
                return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.tclINDEPENDENT(tclZEROMSG(/* None */0, Pp$ReactTemplate.str("Proof is not complete."))), Curry._1(Proofview$ReactTemplate.tclUNIT, res));
              }));
}

function tclSOLVE(tacl) {
  return tclFIRST(Curry._2(Util$ReactTemplate.List[/* map */10], tclCOMPLETE, tacl));
}

function tclPROGRESS(t) {
  return Proofview$ReactTemplate.tclINDEPENDENT(Proofview$ReactTemplate.tclPROGRESS(t));
}

function tclSELECT(param) {
  if (typeof param === "number") {
    return (function (tac) {
        return tac;
      });
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var i = param[0];
          return (function (param) {
              return Proofview$ReactTemplate.tclFOCUS(i, i, param);
            });
      case 1 : 
          var partial_arg = param[0];
          return (function (param) {
              return Proofview$ReactTemplate.tclFOCUSLIST(partial_arg, param);
            });
      case 2 : 
          var partial_arg$1 = param[0];
          return (function (param) {
              return Proofview$ReactTemplate.tclFOCUSID(partial_arg$1, param);
            });
      
    }
  }
}

function check_evars(env, sigma, extsigma, origsigma) {
  var is_undefined_up_to_restriction = function (sigma, _evk) {
    while(true) {
      var evk = _evk;
      if (Evd$ReactTemplate.mem(origsigma, evk)) {
        return /* None */0;
      } else {
        var evi = Evd$ReactTemplate.find(sigma, evk);
        var match = Evd$ReactTemplate.evar_body(evi);
        if (match) {
          var match$1 = Constr$ReactTemplate.kind(match[0]);
          if (match$1.tag === 3) {
            _evk = match$1[0][0];
            continue ;
            
          } else {
            return /* None */0;
          }
        } else {
          return /* Some */[/* tuple */[
                    evk,
                    evi
                  ]];
        }
      }
    };
  };
  var rest = Evd$ReactTemplate.fold_undefined((function (evk, _, acc) {
          var match = is_undefined_up_to_restriction(sigma, evk);
          if (match) {
            var match$1 = match[0];
            return /* :: */[
                    /* tuple */[
                      match$1[0],
                      match$1[1]
                    ],
                    acc
                  ];
          } else {
            return acc;
          }
        }), extsigma, /* [] */0);
  if (rest) {
    var match = rest[0];
    var match$1 = match[1][/* evar_source */4];
    return Pretype_errors$ReactTemplate.error_unsolvable_implicit(match$1[0], env, sigma, match[0], /* None */0);
  } else {
    return /* () */0;
  }
}

function tclWITHHOLES(accept_unresolved_holes, tac, sigma) {
  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma_initial) {
                if (sigma === sigma_initial) {
                  return tac;
                } else {
                  var check_evars_if = function (x) {
                    if (accept_unresolved_holes) {
                      return Curry._1(Proofview$ReactTemplate.tclUNIT, x);
                    } else {
                      return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma_final) {
                                    return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclENV, (function (env) {
                                                  try {
                                                    check_evars(env, sigma_final, sigma, sigma_initial);
                                                    return Curry._1(Proofview$ReactTemplate.tclUNIT, x);
                                                  }
                                                  catch (raw_e){
                                                    var e = Js_exn.internalToOCamlException(raw_e);
                                                    if (CErrors$ReactTemplate.noncritical(e)) {
                                                      return Proofview$ReactTemplate.tclZERO(/* None */0, e);
                                                    } else {
                                                      throw e;
                                                    }
                                                  }
                                                }));
                                  }));
                    }
                  };
                  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](sigma), tac), check_evars_if);
                }
              }));
}

function tclDELAYEDWITHHOLES(check, x, tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var env = Proofview$ReactTemplate.Goal[/* env */4](gl);
                var sigma = Proofview$ReactTemplate.Goal[/* sigma */5](gl);
                var match = Curry._2(x, env, sigma);
                return tclWITHHOLES(check, Curry._1(tac, match[1]), match[0]);
              }));
}

function tclTIMEOUT(n, t) {
  return Curry._2(Proofview$ReactTemplate.tclOR, Proofview$ReactTemplate.tclTIMEOUT(n, t), (function (param) {
                var e = param[0];
                if (e === Proofview$ReactTemplate.Timeout) {
                  return Proofview$ReactTemplate.tclZERO(/* None */0, [
                              Refiner$ReactTemplate.FailError,
                              0,
                              Block.__(246, [(function () {
                                      return CErrors$ReactTemplate.print(/* None */0, e);
                                    })])
                            ]);
                } else {
                  return Proofview$ReactTemplate.tclZERO(/* Some */[param[1]], e);
                }
              }));
}

var tclTIME = Proofview$ReactTemplate.tclTIME;

function nthDecl$1(m, gl) {
  var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
  try {
    return Curry._2(Util$ReactTemplate.List[/* nth */3], hyps, m - 1 | 0);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No such assumption."));
    } else {
      throw exn;
    }
  }
}

function nLastDecls$1(gl, n) {
  try {
    return Curry._2(Util$ReactTemplate.List[/* firstn */104], n, Proofview$ReactTemplate.Goal[/* hyps */3](gl));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough hypotheses in the goal."));
    } else {
      throw exn;
    }
  }
}

function nthHypId$1(m, gl) {
  return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], nthDecl$1(m, gl));
}

function onNthHypId$1(m, tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return Curry._1(tac, nthHypId$1(m, gl));
              }));
}

function onLastHypId$1(param) {
  return onNthHypId$1(1, param);
}

function onLastHyp$1(param) {
  var m = 1;
  var tac = param;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return Curry._1(tac, EConstr$ReactTemplate.mkVar(nthHypId$1(m, gl)));
              }));
}

function onLastDecl$1(param) {
  var m = 1;
  var tac = param;
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Curry._1(Proofview$ReactTemplate.tclUNIT, nthDecl$1(m, gl)), tac);
              }));
}

function ifOnHyp$1(pred, tac1, tac2, id) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var typ = Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](id, gl);
                if (Curry._1(pred, /* tuple */[
                        id,
                        typ
                      ])) {
                  return Curry._1(tac1, id);
                } else {
                  return Curry._1(tac2, id);
                }
              }));
}

function onHyps$1(find, tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return Curry._1(tac, Curry._1(find, gl));
              }));
}

function afterHyp$1(id, tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var hyps = Proofview$ReactTemplate.Goal[/* hyps */3](gl);
                var partial_arg = Names$ReactTemplate.Id[/* equal */0];
                var partial_arg$1 = function (param) {
                  return partial_arg(id, param);
                };
                var partial_arg$2 = Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0];
                var match = Curry._2(Util$ReactTemplate.List[/* split_when */102], (function (param) {
                        return Util$ReactTemplate.$percent$great(partial_arg$2, partial_arg$1, param);
                      }), hyps);
                return Curry._1(tac, match[0]);
              }));
}

function fullGoal$1(gl) {
  var hyps = Tacmach$ReactTemplate.New[/* pf_ids_of_hyps */11](gl);
  return /* :: */[
          /* None */0,
          Curry._2(Util$ReactTemplate.List[/* map */10], Option$ReactTemplate.make, hyps)
        ];
}

function tryAllHyps(tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var hyps = Tacmach$ReactTemplate.New[/* pf_ids_of_hyps */11](gl);
                return tclFIRST_PROGRESS_ON(tac, hyps);
              }));
}

function tryAllHypsAndConcl(tac) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return tclFIRST_PROGRESS_ON(tac, fullGoal$1(gl));
              }));
}

function onClause$1(tac, cl) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var hyps = Tacmach$ReactTemplate.New[/* pf_ids_of_hyps */11](gl);
                return tclMAP(tac, Locusops$ReactTemplate.simple_clause_of((function () {
                                  return hyps;
                                }), cl));
              }));
}

function general_elim_then_using(mk_elim, isrec, allnames, tac, predicate, ind, param) {
  var t = param[1];
  var c = param[0];
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var match = Curry._2(mk_elim, ind, gl);
                var elim = match[1];
                var sigma = match[0];
                var ind$1 = Util$ReactTemplate.on_snd((function (u) {
                        return EConstr$ReactTemplate.EInstance[/* kind */1](sigma, u);
                      }), ind);
                return Curry._2(Proofview$ReactTemplate.tclTHEN, Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](sigma), Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                                  var indclause = Clenv$ReactTemplate.mk_clenv_from(gl)(/* tuple */[
                                        c,
                                        t
                                      ]);
                                  var elimclause = Clenv$ReactTemplate.mk_clenv_from(gl)(/* tuple */[
                                        elim,
                                        Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, elim)
                                      ]);
                                  var match = EConstr$ReactTemplate.kind(elimclause[/* evd */1], Termops$ReactTemplate.last_arg(elimclause[/* evd */1], elimclause[/* templval */2][/* rebus */0]));
                                  var indmv;
                                  indmv = match.tag === 2 ? match[0] : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("elimination."));
                                  var match$1 = EConstr$ReactTemplate.decompose_app(elimclause[/* evd */1], elimclause[/* templtyp */3][/* rebus */0]);
                                  var match$2 = EConstr$ReactTemplate.kind(elimclause[/* evd */1], match$1[0]);
                                  var pmv;
                                  if (match$2.tag === 2) {
                                    pmv = match$2[0];
                                  } else {
                                    var match$3 = EConstr$ReactTemplate.kind(sigma, elim);
                                    var name_elim;
                                    switch (match$3.tag | 0) {
                                      case 1 : 
                                          name_elim = Names$ReactTemplate.Id[/* to_string */7](match$3[0]);
                                          break;
                                      case 10 : 
                                          name_elim = Names$ReactTemplate.Constant[/* to_string */15](match$3[0][0]);
                                          break;
                                      default:
                                        name_elim = "\b";
                                    }
                                    pmv = CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Tacticals.general_elim_then_using"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The elimination combinator "), Pp$ReactTemplate.str(name_elim)), Pp$ReactTemplate.str(" is unknown.")));
                                  }
                                  var elimclause$prime = Clenv$ReactTemplate.clenv_fchain(/* Some */[/* false */0], /* None */0, indmv, elimclause, indclause);
                                  var branchsigns = compute_constructor_signatures(isrec, ind$1);
                                  var brnames = compute_induction_names_gen(/* false */0, branchsigns, allnames);
                                  var flags = Unification$ReactTemplate.elim_flags(/* () */0);
                                  var elimclause$prime$1 = predicate ? Clenv$ReactTemplate.clenv_unify(/* Some */[flags], /* CONV */0, EConstr$ReactTemplate.mkMeta(pmv), predicate[0], elimclause$prime) : elimclause$prime;
                                  var clenv$prime = Clenv$ReactTemplate.clenv_unique_resolver(/* Some */[flags], elimclause$prime$1, gl);
                                  var after_tac = function (i) {
                                    var match = EConstr$ReactTemplate.decompose_app(clenv$prime[/* evd */1], clenv$prime[/* templtyp */3][/* rebus */0]);
                                    return Curry._1(tac, /* record */[
                                                /* ity */ind$1,
                                                /* largs */Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                                        return Clenv$ReactTemplate.clenv_nf_meta(clenv$prime, param);
                                                      }), match[1]),
                                                /* branchnum */i + 1 | 0,
                                                /* pred */Clenv$ReactTemplate.clenv_nf_meta(clenv$prime, match[0]),
                                                /* nassums */Curry._1(Util$ReactTemplate.List[/* length */0], Caml_array.caml_array_get(branchsigns, i)),
                                                /* branchsign */Caml_array.caml_array_get(branchsigns, i),
                                                /* branchnames */Caml_array.caml_array_get(brnames, i)
                                              ]);
                                  };
                                  var branchtacs = Curry._2(Util$ReactTemplate.List[/* init */46], branchsigns.length, after_tac);
                                  return Curry._2(Proofview$ReactTemplate.tclTHEN, Clenvtac$ReactTemplate.clenv_refine(/* false */0, /* None */0, clenv$prime), Proofview$ReactTemplate.tclEXTEND(/* [] */0, tclIDTAC, branchtacs));
                                })));
              }));
}

function elimination_sort_of_goal$1(gl) {
  return Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0]((function (eta) {
                    return (function (param, param$1) {
                        return Retyping$ReactTemplate.get_sort_family_of(/* None */0, /* None */0, eta, param, param$1);
                      });
                  }), gl), Proofview$ReactTemplate.Goal[/* concl */2](gl));
}

function elimination_sort_of_hyp$1(id, gl) {
  return Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0]((function (eta) {
                    return (function (param, param$1) {
                        return Retyping$ReactTemplate.get_sort_family_of(/* None */0, /* None */0, eta, param, param$1);
                      });
                  }), gl), Tacmach$ReactTemplate.New[/* pf_get_hyp_typ */15](id, gl));
}

function elimination_sort_of_clause$1(id, gl) {
  if (id) {
    return elimination_sort_of_hyp$1(id[0], gl);
  } else {
    return elimination_sort_of_goal$1(gl);
  }
}

function gl_make_elim(ind, gl) {
  var gr = Indrec$ReactTemplate.lookup_eliminator(ind[0], elimination_sort_of_goal$1(gl));
  var match = Curry._1(Tacmach$ReactTemplate.New[/* pf_apply */0]((function (eta) {
              return (function (param, param$1) {
                  return Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, eta, param, param$1);
                });
            }), gl), gr);
  return /* tuple */[
          match[0],
          EConstr$ReactTemplate.of_constr(match[1])
        ];
}

function gl_make_case_dep(param, gl) {
  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
  var u = EConstr$ReactTemplate.EInstance[/* kind */1](Tacmach$ReactTemplate.New[/* project */3](gl), param[1]);
  var match = Indrec$ReactTemplate.build_case_analysis_scheme(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), sigma, /* tuple */[
        param[0],
        u
      ], /* true */1, elimination_sort_of_goal$1(gl));
  return /* tuple */[
          match[0],
          EConstr$ReactTemplate.of_constr(match[1])
        ];
}

function gl_make_case_nodep(param, gl) {
  var sigma = Tacmach$ReactTemplate.New[/* project */3](gl);
  var u = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, param[1]);
  var match = Indrec$ReactTemplate.build_case_analysis_scheme(Curry._1(Tacmach$ReactTemplate.New[/* pf_env */4], gl), sigma, /* tuple */[
        param[0],
        u
      ], /* false */0, elimination_sort_of_goal$1(gl));
  return /* tuple */[
          match[0],
          EConstr$ReactTemplate.of_constr(match[1])
        ];
}

function make_elim_branch_assumptions(ba, hyps) {
  var assums;
  try {
    assums = Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._2(Util$ReactTemplate.List[/* firstn */104], ba[/* nassums */4], hyps));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      assums = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("make_elim_branch_assumptions."));
    } else {
      throw exn;
    }
  }
  return /* record */[
          /* ba */ba,
          /* assums */assums
        ];
}

function elim_on_ba(tac, ba) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return Curry._1(tac, make_elim_branch_assumptions(ba, Proofview$ReactTemplate.Goal[/* hyps */3](gl)));
              }));
}

function case_on_ba(tac, ba) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                return Curry._1(tac, make_elim_branch_assumptions(ba, Proofview$ReactTemplate.Goal[/* hyps */3](gl)));
              }));
}

function elimination_then(tac, c) {
  return Proofview$ReactTemplate.Goal[/* enter */9]((function (gl) {
                var match = Tacmach$ReactTemplate.New[/* pf_reduce_to_quantified_ind */18](gl, Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, c));
                var ind = match[0];
                var match$1 = Global$ReactTemplate.lookup_mind(ind[0][0])[/* mind_record */1];
                var match$2 = match$1 ? /* tuple */[
                    /* false */0,
                    gl_make_case_dep
                  ] : /* tuple */[
                    /* true */1,
                    gl_make_elim
                  ];
                return general_elim_then_using(match$2[1], match$2[0], /* None */0, tac, /* None */0, ind, /* tuple */[
                            c,
                            match[1]
                          ]);
              }));
}

function case_then_using(param, param$1, param$2, param$3, param$4) {
  return general_elim_then_using(gl_make_case_dep, /* false */0, param, param$1, param$2, param$3, param$4);
}

function case_nodep_then_using(param, param$1, param$2, param$3, param$4) {
  return general_elim_then_using(gl_make_case_nodep, /* false */0, param, param$1, param$2, param$3, param$4);
}

function pf_constr_of_global$1(ref) {
  return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclEVARMAP, (function (sigma) {
                return Curry._2(Proofview$ReactTemplate.Notations[/* >>= */0], Proofview$ReactTemplate.tclENV, (function (env) {
                              var match = Evd$ReactTemplate.fresh_global(/* None */0, /* None */0, /* None */0, env, sigma, ref);
                              var c = EConstr$ReactTemplate.of_constr(match[1]);
                              return Curry._2(Proofview$ReactTemplate.Notations[/* <*> */1], Proofview$ReactTemplate.Unsafe[/* tclEVARS */0](match[0]), Curry._1(Proofview$ReactTemplate.tclUNIT, c));
                            }));
              }));
}

var tclIDTAC$1 = Refiner$ReactTemplate.tclIDTAC;

var tclIDTAC_MESSAGE = Refiner$ReactTemplate.tclIDTAC_MESSAGE;

var tclORELSE0$1 = Refiner$ReactTemplate.tclORELSE0;

var tclORELSE$1 = Refiner$ReactTemplate.tclORELSE;

var tclTHEN$1 = Refiner$ReactTemplate.tclTHEN;

var tclTHENSEQ = Refiner$ReactTemplate.tclTHENLIST;

var tclTHENLIST$1 = Refiner$ReactTemplate.tclTHENLIST;

var tclTHEN_i = Refiner$ReactTemplate.tclTHEN_i;

var tclTHENFIRST$1 = Refiner$ReactTemplate.tclTHENFIRST;

var tclTHENLAST$1 = Refiner$ReactTemplate.tclTHENLAST;

var tclTHENS$1 = Refiner$ReactTemplate.tclTHENS;

var tclTHENSV = Refiner$ReactTemplate.tclTHENSV;

var tclTHENSLASTn = Refiner$ReactTemplate.tclTHENSLASTn;

var tclTHENLASTn$1 = Refiner$ReactTemplate.tclTHENLASTn;

var tclTHENSFIRSTn$1 = Refiner$ReactTemplate.tclTHENSFIRSTn;

var tclTHENFIRSTn$1 = Refiner$ReactTemplate.tclTHENFIRSTn;

var tclREPEAT$1 = Refiner$ReactTemplate.tclREPEAT;

var tclREPEAT_MAIN$1 = Refiner$ReactTemplate.tclREPEAT_MAIN;

var tclFIRST$1 = Refiner$ReactTemplate.tclFIRST;

var tclSOLVE$1 = Refiner$ReactTemplate.tclSOLVE;

var tclTRY$1 = Refiner$ReactTemplate.tclTRY;

var tclCOMPLETE$1 = Refiner$ReactTemplate.tclCOMPLETE;

var tclAT_LEAST_ONCE = Refiner$ReactTemplate.tclAT_LEAST_ONCE;

var tclFAIL$1 = Refiner$ReactTemplate.tclFAIL;

var tclFAIL_lazy = Refiner$ReactTemplate.tclFAIL_lazy;

var tclDO$1 = Refiner$ReactTemplate.tclDO;

var tclPROGRESS$1 = Refiner$ReactTemplate.tclPROGRESS;

var tclSHOWHYPS = Refiner$ReactTemplate.tclSHOWHYPS;

var tclTHENTRY = Refiner$ReactTemplate.tclTHENTRY;

var tclMAP$1 = Refiner$ReactTemplate.tclMAP;

var tclIFTHENELSE$1 = Refiner$ReactTemplate.tclIFTHENELSE;

var tclIFTHENSELSE = Refiner$ReactTemplate.tclIFTHENSELSE;

var tclIFTHENSVELSE$1 = Refiner$ReactTemplate.tclIFTHENSVELSE;

var tclIFTHENTRYELSEMUST$1 = Refiner$ReactTemplate.tclIFTHENTRYELSEMUST;

var New = [
  catch_failerror,
  tclIDTAC,
  tclTHEN,
  tclFAIL,
  tclZEROMSG,
  tclOR,
  tclORD,
  Proofview$ReactTemplate.tclONCE,
  tclEXACTLY_ONCE,
  tclIFCATCH,
  tclORELSE0,
  tclORELSE,
  tclTHENS3PARTS,
  tclTHENSFIRSTn,
  tclTHENFIRSTn,
  tclTHENFIRST,
  tclTHENLASTn,
  tclTHENLAST,
  tclTHENS,
  tclTHENLIST,
  tclMAP,
  tclTRY,
  tclTRYb,
  tclFIRST,
  tclIFTHENELSE,
  tclIFTHENSVELSE,
  tclIFTHENTRYELSEMUST,
  tclIFTHENFIRSTTRYELSEMUST,
  tclDO,
  tclREPEAT,
  tclREPEAT_MAIN,
  tclCOMPLETE,
  tclSOLVE,
  tclPROGRESS,
  tclSELECT,
  tclWITHHOLES,
  tclDELAYEDWITHHOLES,
  tclTIMEOUT,
  tclTIME,
  nLastDecls$1,
  ifOnHyp$1,
  onNthHypId$1,
  onLastHypId$1,
  onLastHyp$1,
  onLastDecl$1,
  onHyps$1,
  afterHyp$1,
  tryAllHyps,
  tryAllHypsAndConcl,
  onClause$1,
  elimination_sort_of_goal$1,
  elimination_sort_of_hyp$1,
  elimination_sort_of_clause$1,
  elimination_then,
  case_then_using,
  case_nodep_then_using,
  elim_on_ba,
  case_on_ba,
  pf_constr_of_global$1
];

exports.tclIDTAC = tclIDTAC$1;
exports.tclIDTAC_MESSAGE = tclIDTAC_MESSAGE;
exports.tclORELSE0 = tclORELSE0$1;
exports.tclORELSE = tclORELSE$1;
exports.tclTHEN = tclTHEN$1;
exports.tclTHENSEQ = tclTHENSEQ;
exports.tclTHENLIST = tclTHENLIST$1;
exports.tclTHEN_i = tclTHEN_i;
exports.tclTHENFIRST = tclTHENFIRST$1;
exports.tclTHENLAST = tclTHENLAST$1;
exports.tclTHENS = tclTHENS$1;
exports.tclTHENSV = tclTHENSV;
exports.tclTHENSLASTn = tclTHENSLASTn;
exports.tclTHENLASTn = tclTHENLASTn$1;
exports.tclTHENSFIRSTn = tclTHENSFIRSTn$1;
exports.tclTHENFIRSTn = tclTHENFIRSTn$1;
exports.tclREPEAT = tclREPEAT$1;
exports.tclREPEAT_MAIN = tclREPEAT_MAIN$1;
exports.tclFIRST = tclFIRST$1;
exports.tclSOLVE = tclSOLVE$1;
exports.tclTRY = tclTRY$1;
exports.tclCOMPLETE = tclCOMPLETE$1;
exports.tclAT_LEAST_ONCE = tclAT_LEAST_ONCE;
exports.tclFAIL = tclFAIL$1;
exports.tclFAIL_lazy = tclFAIL_lazy;
exports.tclDO = tclDO$1;
exports.tclPROGRESS = tclPROGRESS$1;
exports.tclSHOWHYPS = tclSHOWHYPS;
exports.tclTHENTRY = tclTHENTRY;
exports.tclMAP = tclMAP$1;
exports.tclIFTHENELSE = tclIFTHENELSE$1;
exports.tclIFTHENSELSE = tclIFTHENSELSE;
exports.tclIFTHENSVELSE = tclIFTHENSVELSE$1;
exports.tclIFTHENTRYELSEMUST = tclIFTHENTRYELSEMUST$1;
exports.onNthHypId = onNthHypId;
exports.onNthHyp = onNthHyp;
exports.onNthDecl = onNthDecl;
exports.onLastHypId = onLastHypId;
exports.onLastHyp = onLastHyp;
exports.onLastDecl = onLastDecl;
exports.onNLastHypsId = onNLastHypsId;
exports.onNLastHyps = onNLastHyps;
exports.onNLastDecls = onNLastDecls;
exports.lastHypId = lastHypId;
exports.lastHyp = lastHyp;
exports.lastDecl = lastDecl;
exports.nLastHypsId = nLastHypsId;
exports.nLastHyps = nLastHyps;
exports.nLastDecls = nLastDecls;
exports.afterHyp = afterHyp;
exports.ifOnHyp = ifOnHyp;
exports.onHyps = onHyps;
exports.onAllHyps = onAllHyps;
exports.onAllHypsAndConcl = onAllHypsAndConcl;
exports.onClause = onClause;
exports.onClauseLR = onClauseLR;
exports.get_and_check_or_and_pattern = get_and_check_or_and_pattern;
exports.fix_empty_or_and_pattern = fix_empty_or_and_pattern;
exports.compute_constructor_signatures = compute_constructor_signatures;
exports.compute_induction_names = compute_induction_names;
exports.elimination_sort_of_goal = elimination_sort_of_goal;
exports.elimination_sort_of_hyp = elimination_sort_of_hyp;
exports.elimination_sort_of_clause = elimination_sort_of_clause;
exports.pf_with_evars = pf_with_evars;
exports.pf_constr_of_global = pf_constr_of_global;
exports.New = New;
/* tclIDTAC Not a pure module */
