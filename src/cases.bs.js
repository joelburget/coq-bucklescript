// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Tacred$ReactTemplate = require("./tacred.bs.js");
var Typing$ReactTemplate = require("./typing.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Program$ReactTemplate = require("./program.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Coercion$ReactTemplate = require("./coercion.bs.js");
var Evarconv$ReactTemplate = require("./evarconv.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Retyping$ReactTemplate = require("./retyping.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Evarsolve$ReactTemplate = require("./evarsolve.bs.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Evardefine$ReactTemplate = require("./evardefine.bs.js");
var Type_errors$ReactTemplate = require("./type_errors.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");
var Pretype_errors$ReactTemplate = require("./pretype_errors.bs.js");

var PatternMatchingError = Caml_exceptions.create("Cases-ReactTemplate.PatternMatchingError");

function raise_pattern_matching_error(loc, param) {
  return Loc$ReactTemplate.raise(loc, [
              PatternMatchingError,
              param[0],
              param[1],
              param[2]
            ]);
}

function error_bad_constructor(loc, env, cstr, ind) {
  return raise_pattern_matching_error(loc, /* tuple */[
              env,
              Evd$ReactTemplate.empty,
              /* BadConstructor */Block.__(1, [
                  cstr,
                  ind
                ])
            ]);
}

function error_wrong_numarg_constructor(loc, env, c, n) {
  return raise_pattern_matching_error(loc, /* tuple */[
              env,
              Evd$ReactTemplate.empty,
              /* WrongNumargConstructor */Block.__(2, [
                  c,
                  n
                ])
            ]);
}

function error_wrong_numarg_inductive(loc, env, c, n) {
  return raise_pattern_matching_error(loc, /* tuple */[
              env,
              Evd$ReactTemplate.empty,
              /* WrongNumargInductive */Block.__(3, [
                  c,
                  n
                ])
            ]);
}

function list_try_compile(f, l) {
  var _errors = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var errors = _errors;
    if (param) {
      try {
        return Curry._1(f, param[0]);
      }
      catch (raw_e){
        var e = Js_exn.internalToOCamlException(raw_e);
        var exit = 0;
        if (e[0] === CErrors$ReactTemplate.UserError) {
          exit = 1;
        } else if (e[0] === Type_errors$ReactTemplate.TypeError) {
          exit = 1;
        } else if (e[0] === Pretype_errors$ReactTemplate.PretypeError) {
          exit = 1;
        } else if (e[0] === PatternMatchingError) {
          exit = 1;
        } else {
          throw e;
        }
        if (exit === 1) {
          var e$1 = CErrors$ReactTemplate.push(e);
          _param = param[1];
          _errors = /* :: */[
            e$1,
            errors
          ];
          continue ;
          
        }
        
      }
    } else if (errors) {
      return Util$ReactTemplate.iraise(Curry._1(Util$ReactTemplate.List[/* last */105], errors));
    } else {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("try_find_f."));
    }
  };
}

var nx = /* Name */[Namegen$ReactTemplate.default_dependent_ident];

function force_name(na) {
  if (na) {
    return na;
  } else {
    return nx;
  }
}

function make_anonymous_patvars(n) {
  return Curry._2(Util$ReactTemplate.List[/* make */56], n, DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0])));
}

function relocate_rel(n1, n2, k, j) {
  if (j === (n1 + k | 0)) {
    return n2 + k | 0;
  } else {
    return j;
  }
}

function relocate_index(sigma, n1, n2, k, t) {
  var match = EConstr$ReactTemplate.kind(sigma, t);
  var exit = 0;
  if (match.tag) {
    exit = 1;
  } else {
    var j = match[0];
    if (j === (n1 + k | 0)) {
      return EConstr$ReactTemplate.mkRel(n2 + k | 0);
    } else if (j < (n1 + k | 0)) {
      return t;
    } else if (j > (n1 + k | 0)) {
      return t;
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    return EConstr$ReactTemplate.map_with_binders(sigma, (function (prim) {
                  return prim + 1 | 0;
                }), (function (param, param$1) {
                  return relocate_index(sigma, n1, n2, param, param$1);
                }), k, t);
  }
  
}

function feed_history(arg, param) {
  if (param.tag) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Exhausted pattern history."));
  } else {
    var n = param[0];
    if (n >= 1) {
      return /* Continuation */Block.__(0, [
                n - 1 | 0,
                /* :: */[
                  arg,
                  param[1]
                ],
                param[2]
              ]);
    } else {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Bad number of expected remaining patterns: "), Pp$ReactTemplate.$$int(n)), Pp$ReactTemplate.str(".")));
    }
  }
}

function glob_pattern_of_partial_history(args2, param) {
  if (param.tag) {
    return param[0];
  } else {
    var args3 = make_anonymous_patvars(param[0] - Curry._1(Util$ReactTemplate.List[/* length */0], args2) | 0);
    var args = Curry._2(Util$ReactTemplate.List[/* rev_append */6], param[1], Util$ReactTemplate.$at(args2, args3));
    var param$1 = param[2];
    if (param$1) {
      var eta_000 = param$1[0];
      var eta = /* PatCstr */Block.__(1, [
          eta_000,
          args,
          /* Anonymous */0
        ]);
      return glob_pattern_of_partial_history(/* :: */[
                  DAst$ReactTemplate.make(/* None */0, eta),
                  /* [] */0
                ], param$1[1]);
    } else {
      return args;
    }
  }
}

function pop_history_pattern(param) {
  if (param.tag) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Constructor not yet filled with its arguments."));
  } else if (param[0] !== 0) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Constructor not yet filled with its arguments."));
  } else {
    var match = param[2];
    var l = param[1];
    if (match) {
      var eta_000 = match[0];
      var eta_001 = Curry._1(Util$ReactTemplate.List[/* rev */4], l);
      var eta = /* PatCstr */Block.__(1, [
          eta_000,
          eta_001,
          /* Anonymous */0
        ]);
      return feed_history(DAst$ReactTemplate.make(/* None */0, eta), match[1]);
    } else {
      return /* Result */Block.__(1, [Curry._1(Util$ReactTemplate.List[/* rev */4], l)]);
    }
  }
}

function pop_history(h) {
  return feed_history(DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0])), h);
}

function push_history_pattern(n, pci, cont) {
  return /* Continuation */Block.__(0, [
            n,
            /* [] */0,
            /* MakeConstructor */[
              pci,
              cont
            ]
          ]);
}

function find_row_ind(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var p = param[0];
      var match = DAst$ReactTemplate.get(p);
      if (match.tag) {
        return /* Some */[/* tuple */[
                  p[/* loc */1],
                  match[0]
                ]];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function inductive_template(evdref, env, tmloc, ind) {
  var indu = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
          return Evd$ReactTemplate.fresh_inductive_instance(/* None */0, env, param, param$1);
        }), evdref, ind);
  var arsign = Inductiveops$ReactTemplate.inductive_alldecls_env(env, indu);
  var indu$1 = Util$ReactTemplate.on_snd(EConstr$ReactTemplate.EInstance[/* make */0], indu);
  var hole_source = function (i) {
    if (tmloc) {
      return Loc$ReactTemplate.tag(/* Some */[tmloc[0]], /* TomatchTypeParameter */Block.__(5, [
                    ind,
                    i
                  ]));
    } else {
      var eta = /* TomatchTypeParameter */Block.__(5, [
          ind,
          i
        ]);
      return Loc$ReactTemplate.tag(/* None */0, eta);
    }
  };
  var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, param) {
          var n = param[2];
          var evarl = param[1];
          var subst = param[0];
          if (decl.tag) {
            var b = EConstr$ReactTemplate.of_constr(decl[1]);
            return /* tuple */[
                    /* :: */[
                      EConstr$ReactTemplate.Vars[/* substl */3](subst, b),
                      subst
                    ],
                    evarl,
                    n + 1 | 0
                  ];
          } else {
            var ty = EConstr$ReactTemplate.of_constr(decl[1]);
            var ty$prime = EConstr$ReactTemplate.Vars[/* substl */3](subst, ty);
            var e = Evarutil$ReactTemplate.e_new_evar(env, evdref, /* Some */[hole_source(n)], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, ty$prime);
            return /* tuple */[
                    /* :: */[
                      e,
                      subst
                    ],
                    /* :: */[
                      e,
                      evarl
                    ],
                    n + 1 | 0
                  ];
          }
        }), arsign, /* tuple */[
        /* [] */0,
        /* [] */0,
        1
      ]);
  return EConstr$ReactTemplate.applist(/* tuple */[
              EConstr$ReactTemplate.mkIndU(indu$1),
              Curry._1(Util$ReactTemplate.List[/* rev */4], match[1])
            ]);
}

function try_find_ind(env, sigma, typ, realnames) {
  var ind = Inductiveops$ReactTemplate.find_rectype(env, sigma, typ);
  var names;
  if (realnames) {
    names = realnames[0];
  } else {
    var ind$1 = Inductiveops$ReactTemplate.dest_ind_family(ind[0])[0][0];
    names = Curry._2(Util$ReactTemplate.List[/* make */56], Inductiveops$ReactTemplate.inductive_nrealdecls(ind$1), /* Anonymous */0);
  }
  return /* IsInd */Block.__(0, [
            typ,
            ind,
            names
          ]);
}

function inh_coerce_to_ind(evdref, env, loc, ty, tyi) {
  var sigma = evdref[0];
  var expected_typ = inductive_template(evdref, env, loc, tyi);
  if (Evarconv$ReactTemplate.e_cumul(env, /* None */0, evdref, expected_typ, ty)) {
    return 0;
  } else {
    evdref[0] = sigma;
    return /* () */0;
  }
}

function binding_vars_of_inductive(sigma, param) {
  if (param.tag) {
    return /* [] */0;
  } else {
    return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                  return EConstr$ReactTemplate.isRel(sigma, param);
                }), param[1][1]);
  }
}

function extract_inductive_data(env, sigma, decl) {
  if (decl.tag) {
    return /* tuple */[
            /* NotInd */Block.__(1, [
                /* None */0,
                decl[2]
              ]),
            /* [] */0
          ];
  } else {
    var t = decl[1];
    var tmtyp;
    try {
      tmtyp = try_find_ind(env, sigma, t, /* None */0);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        tmtyp = /* NotInd */Block.__(1, [
            /* None */0,
            t
          ]);
      } else {
        throw exn;
      }
    }
    var tmtypvars = binding_vars_of_inductive(sigma, tmtyp);
    return /* tuple */[
            tmtyp,
            tmtypvars
          ];
  }
}

function unify_tomatch_with_patterns(evdref, env, loc, typ, pats, realnames) {
  var match = find_row_ind(pats);
  if (match) {
    inh_coerce_to_ind(evdref, env, loc, typ, match[0][1][0]);
    try {
      return try_find_ind(env, evdref[0], typ, realnames);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* NotInd */Block.__(1, [
                  /* None */0,
                  typ
                ]);
      } else {
        throw exn;
      }
    }
  } else {
    return /* NotInd */Block.__(1, [
              /* None */0,
              typ
            ]);
  }
}

function find_tomatch_tycon(evdref, env, loc, param) {
  if (param) {
    var match = param[0][/* v */0];
    return /* tuple */[
            Evardefine$ReactTemplate.mk_tycon(inductive_template(evdref, env, loc, match[0])),
            /* Some */[Curry._1(Util$ReactTemplate.List[/* rev */4], match[1])]
          ];
  } else {
    return /* tuple */[
            Evardefine$ReactTemplate.empty_tycon,
            /* None */0
          ];
  }
}

function make_return_predicate_ltac_lvar(sigma, na, tm, c, lvar) {
  var match = DAst$ReactTemplate.get(tm);
  if (na) {
    var id = na[0];
    var exit = 0;
    var id$prime;
    switch (match.tag | 0) {
      case 0 : 
          var match$1 = match[0];
          if (match$1.tag) {
            return lvar;
          } else {
            id$prime = match$1[0];
            exit = 1;
          }
          break;
      case 1 : 
          id$prime = match[0];
          exit = 1;
          break;
      default:
        return lvar;
    }
    if (exit === 1) {
      if (Names$ReactTemplate.Id[/* equal */0](id, id$prime)) {
        if (Curry._2(Names$ReactTemplate.Id[/* Map */10][/* mem */2], id, lvar[/* ltac_genargs */3])) {
          var ltac_genargs = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* remove */5], id, lvar[/* ltac_genargs */3]);
          var match$2 = EConstr$ReactTemplate.kind(sigma, c);
          var ltac_idents;
          ltac_idents = match$2.tag === 1 ? Curry._3(Names$ReactTemplate.Id[/* Map */10][/* add */3], id, match$2[0], lvar[/* ltac_idents */2]) : lvar[/* ltac_idents */2];
          return /* record */[
                  /* ltac_constrs */lvar[/* ltac_constrs */0],
                  /* ltac_uconstrs */lvar[/* ltac_uconstrs */1],
                  /* ltac_idents */ltac_idents,
                  /* ltac_genargs */ltac_genargs
                ];
        } else {
          return lvar;
        }
      } else {
        return lvar;
      }
    }
    
  } else {
    return lvar;
  }
}

function coerce_to_indtype(typing_fun, evdref, env, lvar, matx, tomatchl) {
  var pats = Curry._2(Util$ReactTemplate.List[/* map */10], (function (r) {
          return r[/* patterns */0];
        }), matx);
  var m = Util$ReactTemplate.matrix_transpose(pats);
  var matx$prime = m ? m : Curry._2(Util$ReactTemplate.List[/* map */10], (function () {
            return /* [] */0;
          }), tomatchl);
  var lvar$1 = [lvar];
  var tms = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param, param$1) {
          var typing_fun$1 = typing_fun;
          var evdref$1 = evdref;
          var env$1 = env;
          var lvar$2 = lvar$1;
          var pats = param;
          var param$2 = param$1;
          var match = param$2[1];
          var tomatch = param$2[0];
          var loc = Glob_ops$ReactTemplate.loc_of_glob_constr(tomatch);
          var match$1 = find_tomatch_tycon(evdref$1, env$1, loc, match[1]);
          var realnames = match$1[1];
          var j = Curry._5(typing_fun$1, match$1[0], env$1, evdref$1, lvar$2[0], tomatch);
          var match$2 = Coercion$ReactTemplate.inh_coerce_to_base(Glob_ops$ReactTemplate.loc_of_glob_constr(tomatch), env$1, evdref$1[0], j);
          var j$1 = match$2[1];
          evdref$1[0] = match$2[0];
          var typ = Evarutil$ReactTemplate.nf_evar(evdref$1[0], j$1[/* uj_type */1]);
          lvar$2[0] = make_return_predicate_ltac_lvar(evdref$1[0], match[0], tomatch, j$1[/* uj_val */0], lvar$2[0]);
          var t;
          try {
            t = try_find_ind(env$1, evdref$1[0], typ, realnames);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              t = unify_tomatch_with_patterns(evdref$1, env$1, loc, typ, pats, realnames);
            } else {
              throw exn;
            }
          }
          return /* tuple */[
                  j$1[/* uj_val */0],
                  t
                ];
        }), matx$prime, tomatchl);
  var partial_arg = lvar$1[0];
  var tms$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var lvar = partial_arg;
          var x = param;
          var match = x[1];
          if (match.tag) {
            return x;
          } else {
            return /* tuple */[
                    x[0],
                    /* IsInd */Block.__(0, [
                        match[0],
                        match[1],
                        Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                return Glob_ops$ReactTemplate.ltac_interp_name(lvar, param);
                              }), match[2])
                      ])
                  ];
          }
        }), tms);
  return /* tuple */[
          lvar$1[0],
          tms$1
        ];
}

function mkExistential(env, $staropt$star, evdref) {
  var src = $staropt$star ? $staropt$star[0] : Loc$ReactTemplate.tag(/* None */0, /* InternalHole */0);
  return Evarutil$ReactTemplate.e_new_type_evar(env, evdref, /* Some */[src], /* None */0, /* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg)[0];
}

function evd_comb2(f, evdref, x, y) {
  var match = Curry._3(f, evdref[0], x, y);
  evdref[0] = match[0];
  return match[1];
}

function adjust_tomatch_to_pattern(pb, param) {
  var match = param[0];
  var typ = match[1];
  var current = match[0];
  var match$1;
  match$1 = typ.tag ? /* tuple */[
      typ[1],
      /* None */0
    ] : /* tuple */[
      typ[0],
      /* Some */[typ[2]]
    ];
  var names = match$1[1];
  var typ$1 = match$1[0];
  var tmtyp;
  try {
    tmtyp = try_find_ind(pb[/* env */0], pb[/* evdref */2][0], typ$1, names);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      tmtyp = /* NotInd */Block.__(1, [
          /* None */0,
          typ$1
        ]);
    } else {
      throw exn;
    }
  }
  if (tmtyp.tag) {
    if (tmtyp[0]) {
      return /* tuple */[
              current,
              tmtyp
            ];
    } else {
      var typ$2 = tmtyp[1];
      var tm1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (eqn) {
              return Curry._1(Util$ReactTemplate.List[/* hd */1], eqn[/* patterns */0]);
            }), pb[/* mat */6]);
      var match$2 = find_row_ind(tm1);
      if (match$2) {
        var indt = inductive_template(pb[/* evdref */2], pb[/* env */0], /* None */0, match$2[0][1][0]);
        var current$1;
        if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], param[1]) && EConstr$ReactTemplate.isEvar(pb[/* evdref */2][0], typ$2)) {
          Evarconv$ReactTemplate.e_cumul(pb[/* env */0], /* None */0, pb[/* evdref */2], indt, typ$2);
          current$1 = current;
        } else {
          var partial_arg = pb[/* env */0];
          var partial_arg$1 = Coercion$ReactTemplate.inh_conv_coerce_to(/* None */0, /* true */1);
          current$1 = evd_comb2((function (param, param$1, param$2) {
                    return partial_arg$1(partial_arg, param, param$1, param$2);
                  }), pb[/* evdref */2], Environ$ReactTemplate.make_judge(current, typ$2), indt)[/* uj_val */0];
        }
        var sigma = pb[/* evdref */2][0];
        return /* tuple */[
                current$1,
                try_find_ind(pb[/* env */0], sigma, indt, names)
              ];
      } else {
        return /* tuple */[
                current,
                tmtyp
              ];
      }
    }
  } else {
    return /* tuple */[
            current,
            tmtyp
          ];
  }
}

function type_of_tomatch(param) {
  if (param.tag) {
    return param[1];
  } else {
    return param[0];
  }
}

function map_tomatch_type(f, param) {
  if (param.tag) {
    return /* NotInd */Block.__(1, [
              Option$ReactTemplate.map(f, param[0]),
              Curry._1(f, param[1])
            ]);
  } else {
    return /* IsInd */Block.__(0, [
              Curry._1(f, param[0]),
              Inductiveops$ReactTemplate.map_inductive_type(f, param[1]),
              param[2]
            ]);
  }
}

function liftn_tomatch_type(n, depth) {
  var partial_arg = EConstr$ReactTemplate.Vars[/* liftn */1];
  var partial_arg$1 = function (param) {
    return partial_arg(n, depth, param);
  };
  return (function (param) {
      return map_tomatch_type(partial_arg$1, param);
    });
}

function current_pattern(eqn) {
  var match = eqn[/* patterns */0];
  if (match) {
    return match[0];
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Empty list of patterns."));
  }
}

function remove_current_pattern(eqn) {
  var match = eqn[/* patterns */0];
  if (match) {
    return /* record */[
            /* patterns */match[1],
            /* rhs */eqn[/* rhs */1],
            /* alias_stack : :: */[
              Glob_ops$ReactTemplate.alias_of_pat(match[0]),
              eqn[/* alias_stack */2]
            ],
            /* eqn_loc */eqn[/* eqn_loc */3],
            /* used */eqn[/* used */4]
          ];
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Empty list of patterns."));
  }
}

function push_noalias_current_pattern(eqn) {
  var match = eqn[/* patterns */0];
  if (match) {
    return /* record */[
            /* patterns */match[1],
            /* rhs */eqn[/* rhs */1],
            /* alias_stack */eqn[/* alias_stack */2],
            /* eqn_loc */eqn[/* eqn_loc */3],
            /* used */eqn[/* used */4]
          ];
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("push_noalias_current_pattern: Empty list of patterns."));
  }
}

var NotAdjustable = Caml_exceptions.create("Cases-ReactTemplate.NotAdjustable");

function adjust_local_defs(loc, param) {
  var pats = param[0];
  var exit = 0;
  if (pats) {
    var match = param[1];
    if (match) {
      if (match[0].tag) {
        exit = 1;
      } else {
        return /* :: */[
                pats[0],
                adjust_local_defs(loc, /* tuple */[
                      pats[1],
                      match[1]
                    ])
              ];
      }
    } else {
      throw NotAdjustable;
    }
  } else if (param[1]) {
    exit = 1;
  } else {
    return /* [] */0;
  }
  if (exit === 1) {
    var match$1 = param[1];
    if (match$1[0].tag) {
      return /* :: */[
              DAst$ReactTemplate.make(loc, /* PatVar */Block.__(0, [/* Anonymous */0])),
              adjust_local_defs(loc, /* tuple */[
                    pats,
                    match$1[1]
                  ])
            ];
    } else {
      throw NotAdjustable;
    }
  }
  
}

function check_and_adjust_constructor(env, ind, cstrs, pat) {
  var match = DAst$ReactTemplate.get(pat);
  if (match.tag) {
    var args = match[1];
    var cstr = match[0];
    var loc = pat[/* loc */1];
    var ind$prime = Names$ReactTemplate.inductive_of_constructor(cstr);
    if (Names$ReactTemplate.eq_ind(ind$prime, ind)) {
      var ci = Caml_array.caml_array_get(cstrs, cstr[1] - 1 | 0);
      var nb_args_constr = ci[/* cs_nargs */2];
      if (Curry._1(Util$ReactTemplate.List[/* length */0], args) === nb_args_constr) {
        return pat;
      } else {
        try {
          var args$prime = adjust_local_defs(loc, /* tuple */[
                args,
                Curry._1(Util$ReactTemplate.List[/* rev */4], ci[/* cs_args */3])
              ]);
          return DAst$ReactTemplate.make(loc, /* PatCstr */Block.__(1, [
                        cstr,
                        args$prime,
                        match[2]
                      ]));
        }
        catch (exn){
          if (exn === NotAdjustable) {
            return error_wrong_numarg_constructor(loc, env, cstr, nb_args_constr);
          } else {
            throw exn;
          }
        }
      }
    } else {
      try {
        return Coercion$ReactTemplate.inh_pattern_coerce_to(loc, env, pat, ind$prime, ind);
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          return error_bad_constructor(loc, env, cstr, ind);
        } else {
          throw exn$1;
        }
      }
    }
  } else {
    return pat;
  }
}

function check_all_variables(env, sigma, typ, mat) {
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (eqn) {
                var pat = current_pattern(eqn);
                var match = DAst$ReactTemplate.get(pat);
                if (match.tag) {
                  var loc = pat[/* loc */1];
                  var loc$1 = loc;
                  var env$1 = env;
                  var sigma$1 = sigma;
                  var cstr = match[0];
                  var ind = typ;
                  return raise_pattern_matching_error(loc$1, /* tuple */[
                              env$1,
                              sigma$1,
                              /* BadPattern */Block.__(0, [
                                  cstr,
                                  ind
                                ])
                            ]);
                } else {
                  return /* () */0;
                }
              }), mat);
}

function check_unused_pattern(env, eqn) {
  if (eqn[/* used */4][0]) {
    return 0;
  } else {
    return raise_pattern_matching_error(eqn[/* eqn_loc */3], /* tuple */[
                env,
                Evd$ReactTemplate.empty,
                /* UnusedClause */Block.__(4, [eqn[/* patterns */0]])
              ]);
  }
}

function extract_rhs(pb) {
  var match = pb[/* mat */6];
  if (match) {
    var eqn = match[0];
    eqn[/* used */4][0] = /* true */1;
    return eqn[/* rhs */1];
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["build_leaf"], Pp$ReactTemplate.strbrk("Found a matching with no clauses on a term unknown to have an empty inductive type."));
  }
}

function mk_dep_patt_row(param) {
  var eqn = param[2];
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                var eqn$1 = eqn;
                var pat = param;
                var match = DAst$ReactTemplate.get(pat);
                if (!match.tag && !Flags$ReactTemplate.is_program_mode(/* () */0)) {
                  var na = match[0];
                  var rhs = eqn$1[/* rhs */1];
                  if (na) {
                    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], na[0], rhs[/* rhs_vars */1]);
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* true */1;
                }
              }), param[0]);
}

function dependent_decl(sigma, a, param) {
  if (!param.tag || !Termops$ReactTemplate.dependent(sigma, a, param[2])) {
    return Termops$ReactTemplate.dependent(sigma, a, param[1]);
  } else {
    return /* true */1;
  }
}

function dep_in_tomatch(sigma, _n, _param) {
  while(true) {
    var param = _param;
    var n = _n;
    if (param) {
      var match = param[0];
      if (typeof match === "number") {
        _param = param[1];
        continue ;
        
      } else if (match.tag === 2) {
        if (dependent_decl(sigma, EConstr$ReactTemplate.mkRel(n), match[1])) {
          return /* true */1;
        } else {
          _param = param[1];
          _n = n + 1 | 0;
          continue ;
          
        }
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function dependencies_in_rhs(sigma, nargs, current, tms, eqns) {
  var match = EConstr$ReactTemplate.kind(sigma, current);
  if (!match.tag && dep_in_tomatch(sigma, match[0], tms)) {
    return Curry._2(Util$ReactTemplate.List[/* make */56], nargs, /* true */1);
  } else {
    var nargs$1 = nargs;
    var eqns$1 = eqns;
    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], eqns$1)) {
      return Curry._2(Util$ReactTemplate.List[/* make */56], nargs$1, 1 - Flags$ReactTemplate.is_program_mode(/* () */0));
    } else {
      var deps_rows = Curry._2(Util$ReactTemplate.List[/* map */10], mk_dep_patt_row, eqns$1);
      var deps_columns = Util$ReactTemplate.matrix_transpose(deps_rows);
      return Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Util$ReactTemplate.List[/* exists */21], (function (x) {
                        return x;
                      })), deps_columns);
    }
  }
}

function find_dependency_list(sigma, tmblock, param) {
  if (param) {
    var match = param[0];
    var d = match[3];
    var tdeps = match[1];
    var deps = find_dependency_list(sigma, tmblock, param[1]);
    if (match[0] && Curry._2(Util$ReactTemplate.List[/* exists */21], (function (x) {
              return dependent_decl(sigma, x, d);
            }), tmblock)) {
      var match$1 = EConstr$ReactTemplate.kind(sigma, match[2]);
      if (match$1.tag) {
        return Curry._3(Util$ReactTemplate.List[/* union */51], (function (prim, prim$1) {
                      return +(prim === prim$1);
                    }), deps, tdeps);
      } else {
        return Curry._3(Util$ReactTemplate.List[/* add_set */48], (function (prim, prim$1) {
                      return +(prim === prim$1);
                    }), match$1[0], Curry._3(Util$ReactTemplate.List[/* union */51], (function (prim, prim$1) {
                          return +(prim === prim$1);
                        }), deps, tdeps));
      }
    } else {
      return deps;
    }
  } else {
    return /* [] */0;
  }
}

function find_dependencies_signature(sigma, deps_in_rhs, typs) {
  var l = Curry._4(Util$ReactTemplate.List[/* fold_right2 */19], (function (param, param$1, param$2) {
          var sigma$1 = sigma;
          var is_dep_or_cstr_in_rhs = param;
          var param$3 = param$1;
          var nextlist = param$2;
          var d = param$3[2];
          var tm = param$3[0];
          var deps = find_dependency_list(sigma$1, /* :: */[
                tm,
                param$3[1][1]
              ], nextlist);
          if (is_dep_or_cstr_in_rhs || !Curry._1(Util$ReactTemplate.List[/* is_empty */45], deps)) {
            return /* :: */[
                    /* tuple */[
                      /* true */1,
                      deps,
                      tm,
                      d
                    ],
                    nextlist
                  ];
          } else {
            return /* :: */[
                    /* tuple */[
                      /* false */0,
                      /* [] */0,
                      tm,
                      d
                    ],
                    nextlist
                  ];
          }
        }), deps_in_rhs, typs, /* [] */0);
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                return param[1];
              }), l);
}

function relocate_index_tomatch(sigma, n1, n2) {
  var genrec = function (depth, param) {
    if (param) {
      var match = param[0];
      if (typeof match === "number") {
        return /* :: */[
                /* NonDepAlias */0,
                genrec(depth, param[1])
              ];
      } else {
        switch (match.tag | 0) {
          case 0 : 
              var match$1 = match[0];
              var match$2 = match$1[1];
              var match$3 = match$2[0];
              var c = relocate_index(sigma, n1, n2, depth, match$3[0]);
              var tm = map_tomatch_type((function (param) {
                      return relocate_index(sigma, n1, n2, depth, param);
                    }), match$3[1]);
              var l = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                      return relocate_rel(n1, n2, depth, param);
                    }), match$2[1]);
              return /* :: */[
                      /* Pushed */Block.__(0, [/* tuple */[
                            match$1[0],
                            /* tuple */[
                              /* tuple */[
                                c,
                                tm
                              ],
                              l,
                              match$2[2]
                            ]
                          ]]),
                      genrec(depth, param[1])
                    ];
          case 1 : 
              var match$4 = match[0];
              var match$5 = match$4[1];
              return /* :: */[
                      /* Alias */Block.__(1, [/* tuple */[
                            match$4[0],
                            /* tuple */[
                              match$5[0],
                              match$5[1],
                              Util$ReactTemplate.map_pair((function (param) {
                                      return relocate_index(sigma, n1, n2, depth, param);
                                    }), match$5[2])
                            ]
                          ]]),
                      genrec(depth, param[1])
                    ];
          case 2 : 
              var i = relocate_rel(n1, n2, depth, match[0]);
              return /* :: */[
                      /* Abstract */Block.__(2, [
                          i,
                          Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], (function (c) {
                                  return relocate_index(sigma, n1, n2, depth, c);
                                }), match[1])
                        ]),
                      genrec(depth + 1 | 0, param[1])
                    ];
          
        }
      }
    } else {
      return /* [] */0;
    }
  };
  return (function (param) {
      return genrec(0, param);
    });
}

function replace_term(sigma, n, c, k, t) {
  if (EConstr$ReactTemplate.isRel(sigma, t) && EConstr$ReactTemplate.destRel(sigma, t) === (n + k | 0)) {
    return EConstr$ReactTemplate.Vars[/* lift */0](k, c);
  } else {
    return EConstr$ReactTemplate.map_with_binders(sigma, (function (prim) {
                  return prim + 1 | 0;
                }), (function (param, param$1) {
                  return replace_term(sigma, n, c, param, param$1);
                }), k, t);
  }
}

function length_of_tomatch_type_sign(na, t) {
  var l = na ? 1 : 0;
  if (t.tag) {
    return l;
  } else {
    return Curry._1(Util$ReactTemplate.List[/* length */0], t[2]) + l | 0;
  }
}

function replace_tomatch(sigma, n, c) {
  var replrec = function (depth, param) {
    if (param) {
      var match = param[0];
      if (typeof match === "number") {
        return /* :: */[
                /* NonDepAlias */0,
                replrec(depth, param[1])
              ];
      } else {
        switch (match.tag | 0) {
          case 0 : 
              var match$1 = match[0];
              var match$2 = match$1[1];
              var l = match$2[1];
              var match$3 = match$2[0];
              var b = replace_term(sigma, n, c, depth, match$3[0]);
              var tm = map_tomatch_type((function (param) {
                      return replace_term(sigma, n, c, depth, param);
                    }), match$3[1]);
              Curry._2(Util$ReactTemplate.List[/* iter */9], (function (i) {
                      if (i === (n + depth | 0)) {
                        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("replace_tomatch."));
                      } else {
                        return 0;
                      }
                    }), l);
              return /* :: */[
                      /* Pushed */Block.__(0, [/* tuple */[
                            match$1[0],
                            /* tuple */[
                              /* tuple */[
                                b,
                                tm
                              ],
                              l,
                              match$2[2]
                            ]
                          ]]),
                      replrec(depth, param[1])
                    ];
          case 1 : 
              var match$4 = match[0];
              var match$5 = match$4[1];
              return /* :: */[
                      /* Alias */Block.__(1, [/* tuple */[
                            match$4[0],
                            /* tuple */[
                              match$5[0],
                              match$5[1],
                              Util$ReactTemplate.map_pair((function (param) {
                                      return replace_term(sigma, n, c, depth, param);
                                    }), match$5[2])
                            ]
                          ]]),
                      replrec(depth, param[1])
                    ];
          case 2 : 
              return /* :: */[
                      /* Abstract */Block.__(2, [
                          match[0],
                          Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], (function (t) {
                                  return replace_term(sigma, n, c, depth, t);
                                }), match[1])
                        ]),
                      replrec(depth + 1 | 0, param[1])
                    ];
          
        }
      }
    } else {
      return /* [] */0;
    }
  };
  return (function (param) {
      return replrec(0, param);
    });
}

function liftn_tomatch_stack(n, depth, param) {
  if (param) {
    var match = param[0];
    if (typeof match === "number") {
      return /* :: */[
              /* NonDepAlias */0,
              liftn_tomatch_stack(n, depth, param[1])
            ];
    } else {
      switch (match.tag | 0) {
        case 0 : 
            var match$1 = match[0];
            var match$2 = match$1[1];
            var match$3 = match$2[0];
            var c = EConstr$ReactTemplate.Vars[/* liftn */1](n, depth, match$3[0]);
            var tm = liftn_tomatch_type(n, depth)(match$3[1]);
            var l = Curry._2(Util$ReactTemplate.List[/* map */10], (function (i) {
                    if (i < depth) {
                      return i;
                    } else {
                      return i + n | 0;
                    }
                  }), match$2[1]);
            return /* :: */[
                    /* Pushed */Block.__(0, [/* tuple */[
                          match$1[0],
                          /* tuple */[
                            /* tuple */[
                              c,
                              tm
                            ],
                            l,
                            match$2[2]
                          ]
                        ]]),
                    liftn_tomatch_stack(n, depth, param[1])
                  ];
        case 1 : 
            var match$4 = match[0];
            var match$5 = match$4[1];
            var partial_arg = EConstr$ReactTemplate.Vars[/* liftn */1];
            return /* :: */[
                    /* Alias */Block.__(1, [/* tuple */[
                          match$4[0],
                          /* tuple */[
                            match$5[0],
                            EConstr$ReactTemplate.Vars[/* liftn */1](n, depth, match$5[1]),
                            Util$ReactTemplate.map_pair((function (param) {
                                    return partial_arg(n, depth, param);
                                  }), match$5[2])
                          ]
                        ]]),
                    liftn_tomatch_stack(n, depth, param[1])
                  ];
        case 2 : 
            var i = match[0];
            var i$1 = i < depth ? i : i + n | 0;
            var partial_arg$1 = EConstr$ReactTemplate.Vars[/* liftn */1];
            return /* :: */[
                    /* Abstract */Block.__(2, [
                        i$1,
                        Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], (function (param) {
                                return partial_arg$1(n, depth, param);
                              }), match[1])
                      ]),
                    liftn_tomatch_stack(n, depth + 1 | 0, param[1])
                  ];
        
      }
    }
  } else {
    return /* [] */0;
  }
}

function merge_name(get_name, obj, na) {
  if (na) {
    return na;
  } else {
    return Curry._1(get_name, obj);
  }
}

function get_names(env, sigma, sign, eqns) {
  var names1 = Curry._2(Util$ReactTemplate.List[/* make */56], Curry._1(Context$ReactTemplate.Rel[/* length */3], sign), /* Anonymous */0);
  var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
          return /* tuple */[
                  Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param, param$1) {
                          return merge_name(Glob_ops$ReactTemplate.alias_of_pat, param, param$1);
                        }), param[0], param$1[0]),
                  merge_name((function (x) {
                          return x;
                        }), param[1], param$1[1])
                ];
        }), eqns, /* tuple */[
        names1,
        /* Anonymous */0
      ]);
  var allvars = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (l, param) {
          return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], l, param[2][/* rhs */1][/* avoid_ids */2]);
        }), Names$ReactTemplate.Id[/* Set */9][/* empty */0], eqns);
  var match$1 = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, d, na) {
          var avoid = param[1];
          var na$1 = merge_name((function (param) {
                  var exit = 0;
                  var na;
                  var t;
                  na = param[0];
                  if (param.tag) {
                    t = param[2];
                    exit = 1;
                  } else {
                    t = param[1];
                    exit = 1;
                  }
                  if (exit === 1) {
                    return /* Name */[Namegen$ReactTemplate.next_name_away(Namegen$ReactTemplate.named_hd(env, sigma, t, na), avoid)];
                  }
                  
                }), d, na);
          return /* tuple */[
                  /* :: */[
                    na$1,
                    param[0]
                  ],
                  Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], Nameops$ReactTemplate.Name[/* get_id */15](na$1), avoid)
                ];
        }), /* tuple */[
        /* [] */0,
        allvars
      ], Curry._1(Util$ReactTemplate.List[/* rev */4], sign), match[0]);
  return /* tuple */[
          match$1[0],
          match[1]
        ];
}

var recover_initial_subpattern_names = Curry._1(Util$ReactTemplate.List[/* map2 */16], Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3]);

function recover_and_adjust_alias_names(names, sign) {
  var aux = function (param) {
    var names = param[0];
    var exit = 0;
    if (names) {
      var match = param[1];
      if (match) {
        var match$1 = match[0];
        var x = names[0];
        if (match$1.tag) {
          exit = 1;
        } else {
          return /* :: */[
                  /* tuple */[
                    x,
                    /* LocalAssum */Block.__(0, [
                        Glob_ops$ReactTemplate.alias_of_pat(x),
                        match$1[1]
                      ])
                  ],
                  aux(/* tuple */[
                        names[1],
                        match[1]
                      ])
                ];
        }
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cases.ml",
                779,
                9
              ]
            ];
      }
    } else if (param[1]) {
      exit = 1;
    } else {
      return /* [] */0;
    }
    if (exit === 1) {
      var match$2 = param[1];
      var decl = match$2[0];
      if (decl.tag) {
        var eta = /* PatVar */Block.__(0, [decl[0]]);
        return /* :: */[
                /* tuple */[
                  DAst$ReactTemplate.make(/* None */0, eta),
                  decl
                ],
                aux(/* tuple */[
                      names,
                      match$2[1]
                    ])
              ];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cases.ml",
                779,
                9
              ]
            ];
      }
    }
    
  };
  return Curry._1(Util$ReactTemplate.List[/* split */36], aux(/* tuple */[
                  names,
                  sign
                ]));
}

function push_rels_eqn(sign, eqn) {
  var init = eqn[/* rhs */1];
  return /* record */[
          /* patterns */eqn[/* patterns */0],
          /* rhs : record */[
            /* rhs_env */EConstr$ReactTemplate.push_rel_context(sign, eqn[/* rhs */1][/* rhs_env */0]),
            /* rhs_vars */init[/* rhs_vars */1],
            /* avoid_ids */init[/* avoid_ids */2],
            /* it */init[/* it */3]
          ],
          /* alias_stack */eqn[/* alias_stack */2],
          /* eqn_loc */eqn[/* eqn_loc */3],
          /* used */eqn[/* used */4]
        ];
}

function drop_alias_eqn(eqn) {
  return /* record */[
          /* patterns */eqn[/* patterns */0],
          /* rhs */eqn[/* rhs */1],
          /* alias_stack */Curry._1(Util$ReactTemplate.List[/* tl */2], eqn[/* alias_stack */2]),
          /* eqn_loc */eqn[/* eqn_loc */3],
          /* used */eqn[/* used */4]
        ];
}

function map_predicate(f, _k, ccl, _param) {
  while(true) {
    var param = _param;
    var k = _k;
    if (param) {
      var match = param[0];
      if (typeof match === "number") {
        _param = param[1];
        continue ;
        
      } else {
        switch (match.tag | 0) {
          case 0 : 
              var match$1 = match[0][1];
              var k$prime = length_of_tomatch_type_sign(match$1[2], match$1[0][1]);
              _param = param[1];
              _k = k + k$prime | 0;
              continue ;
              case 1 : 
              _param = param[1];
              continue ;
              case 2 : 
              _param = param[1];
              _k = k + 1 | 0;
              continue ;
              
        }
      }
    } else {
      return Curry._2(f, k, ccl);
    }
  };
}

function noccur_predicate_between(sigma, n) {
  var partial_arg = EConstr$ReactTemplate.Vars[/* noccur_between */13];
  var partial_arg$1 = function (param, param$1) {
    return partial_arg(sigma, n, param, param$1);
  };
  return (function (param, param$1, param$2) {
      return map_predicate(partial_arg$1, param, param$1, param$2);
    });
}

function liftn_predicate(n) {
  var partial_arg = EConstr$ReactTemplate.Vars[/* liftn */1];
  var partial_arg$1 = function (param, param$1) {
    return partial_arg(n, param, param$1);
  };
  return (function (param, param$1, param$2) {
      return map_predicate(partial_arg$1, param, param$1, param$2);
    });
}

function regeneralize_index_predicate(sigma, n) {
  return (function (param, param$1) {
      return map_predicate((function (param, param$1) {
                    return relocate_index(sigma, n, 1, param, param$1);
                  }), 0, param, param$1);
    });
}

function subst_predicate(param, ccl, tms) {
  var copt = param[1];
  var subst = param[0];
  var sigma = copt ? /* :: */[
      copt[0],
      subst
    ] : subst;
  var partial_arg = EConstr$ReactTemplate.Vars[/* substnl */2];
  var partial_arg$1 = function (param, param$1) {
    return partial_arg(sigma, param, param$1);
  };
  return (function (param, param$1, param$2) {
              return map_predicate(partial_arg$1, param, param$1, param$2);
            })(0, ccl, tms);
}

function specialize_predicate_var(param, env, tms, ccl) {
  var typ = param[1];
  var c = param[2] ? /* Some */[param[0]] : /* None */0;
  var l;
  if (typ.tag) {
    l = /* [] */0;
  } else {
    var match = typ[1];
    if (typ[2]) {
      var match$1 = Inductiveops$ReactTemplate.get_arity(env, match[0]);
      var arsign = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_rel_decl, match$1[0]);
      l = EConstr$ReactTemplate.Vars[/* subst_of_rel_context_instance */17](arsign, match[1]);
    } else {
      l = /* [] */0;
    }
  }
  return subst_predicate(/* tuple */[
              l,
              c
            ], ccl, tms);
}

function generalize_predicate(sigma, param, ny, _, tms, ccl) {
  if (!param[1]) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Undetected dependency."));
  }
  var p = Curry._1(Util$ReactTemplate.List[/* length */0], param[0]) + 1 | 0;
  var ccl$1 = Curry._1(liftn_predicate(1), 1)(ccl, tms);
  return regeneralize_index_predicate(sigma, (ny + p | 0) + 1 | 0)(ccl$1, tms);
}

function extract_predicate(ccl, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (typeof match === "number") {
        _param = param[1];
        continue ;
        
      } else {
        switch (match.tag | 0) {
          case 0 : 
              var match$1 = match[0][1];
              var match$2 = match$1[0];
              var match$3 = match$2[1];
              var cur = match$2[0];
              if (match$3.tag) {
                var tms = param[1];
                if (match$1[2]) {
                  var tms$1 = liftn_tomatch_stack(1, 1, tms);
                  var pred = extract_predicate(ccl, tms$1);
                  return EConstr$ReactTemplate.Vars[/* subst1 */4](cur, pred);
                } else {
                  _param = tms;
                  continue ;
                  
                }
              } else {
                var realargs = Curry._1(Util$ReactTemplate.List[/* rev */4], match$3[1][1]);
                var match$4 = match$1[2] ? /* tuple */[
                    1,
                    /* :: */[
                      cur,
                      realargs
                    ]
                  ] : /* tuple */[
                    0,
                    realargs
                  ];
                var partial_arg = Curry._1(Util$ReactTemplate.List[/* length */0], realargs) + match$4[0] | 0;
                var tms$2 = (function(partial_arg){
                  return function (param) {
                    return liftn_tomatch_stack(partial_arg, 1, param);
                  }
                  }(partial_arg))(param[1]);
                var pred$1 = extract_predicate(ccl, tms$2);
                return EConstr$ReactTemplate.Vars[/* substl */3](match$4[1], pred$1);
              }
              break;
          case 1 : 
              _param = param[1];
              continue ;
              case 2 : 
              return Termops$ReactTemplate.mkProd_wo_LetIn(match[1], extract_predicate(ccl, param[1]));
          
        }
      }
    } else {
      return ccl;
    }
  };
}

function abstract_predicate(env, sigma, indf, cur, realargs, param, tms, ccl) {
  var na = param[1];
  var sign = Inductiveops$ReactTemplate.make_arity_signature(env, sigma, /* true */1, indf);
  var n = Curry._1(Util$ReactTemplate.List[/* length */0], sign);
  var tms$1 = Curry._4(Util$ReactTemplate.List[/* fold_right2 */19], (function (par, arg, tomatch) {
          var match = EConstr$ReactTemplate.kind(sigma, par);
          if (match.tag) {
            return tomatch;
          } else {
            return relocate_index_tomatch(sigma, match[0] + n | 0, EConstr$ReactTemplate.destRel(sigma, arg))(tomatch);
          }
        }), Util$ReactTemplate.$at(realargs, /* :: */[
            cur,
            /* [] */0
          ]), Context$ReactTemplate.Rel[/* to_extended_list */12](EConstr$ReactTemplate.mkRel, 0, sign), liftn_tomatch_stack(n, 1, tms));
  var ccl$1 = na ? ccl : Curry._1(liftn_predicate(1), 1)(ccl, tms$1);
  var pred = extract_predicate(ccl$1, tms$1);
  var sign$1 = Curry._3(Util$ReactTemplate.List[/* map2 */16], Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], /* :: */[
        na,
        param[0]
      ], sign);
  return Namegen$ReactTemplate.it_mkLambda_or_LetIn_name(env, sigma, pred, sign$1);
}

function use_unit_judge(evd) {
  var match = Evarconv$ReactTemplate.coq_unit_judge(/* () */0);
  var evd$prime = Evd$ReactTemplate.merge_context_set(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg, evd, match[1]);
  return /* tuple */[
          evd$prime,
          match[0]
        ];
}

function adjust_impossible_cases(pb, pred, tomatch, submat) {
  if (submat) {
    return submat;
  } else {
    var pred$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](pred);
    var match = Constr$ReactTemplate.kind(pred$1);
    if (match.tag === 3) {
      var evk = match[0][0];
      if (Evd$ReactTemplate.evar_source(evk, pb[/* evdref */2][0])[1] === /* ImpossibleCase */2) {
        if (!Evd$ReactTemplate.is_defined(pb[/* evdref */2][0], evk)) {
          var match$1 = use_unit_judge(pb[/* evdref */2][0]);
          pb[/* evdref */2][0] = Evd$ReactTemplate.define(evk, EConstr$ReactTemplate.Unsafe[/* to_constr */0](match$1[1][/* uj_type */1]), match$1[0]);
        }
        var pb$1 = pb;
        var tomatch$1 = tomatch;
        var pats = Curry._2(Util$ReactTemplate.List[/* map */10], (function () {
                return DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0]));
              }), tomatch$1);
        var aliasnames = Curry._2(Util$ReactTemplate.List[/* map_filter */62], (function (param) {
                if (typeof param === "number") {
                  return /* Some */[/* Anonymous */0];
                } else {
                  switch (param.tag | 0) {
                    case 1 : 
                        return /* Some */[/* Anonymous */0];
                    case 0 : 
                    case 2 : 
                        return /* None */0;
                    
                  }
                }
              }), tomatch$1);
        return /* :: */[
                /* record */[
                  /* patterns */pats,
                  /* rhs : record */[
                    /* rhs_env */pb$1[/* env */0],
                    /* rhs_vars */Names$ReactTemplate.Id[/* Set */9][/* empty */0],
                    /* avoid_ids */Names$ReactTemplate.Id[/* Set */9][/* empty */0],
                    /* it : None */0
                  ],
                  /* alias_stack : :: */[
                    /* Anonymous */0,
                    aliasnames
                  ],
                  /* eqn_loc : None */0,
                  /* used */[/* false */0]
                ],
                /* [] */0
              ];
      } else {
        return submat;
      }
    } else {
      return submat;
    }
  }
}

function specialize_predicate(newtomatchs, param, arsign, cs, tms, ccl) {
  var depna = param[1];
  var nrealargs = Curry._1(Util$ReactTemplate.List[/* length */0], param[0]);
  var l = depna ? 1 : 0;
  var k = nrealargs + l | 0;
  var n = cs[/* cs_nargs */2];
  var partial_arg = EConstr$ReactTemplate.Vars[/* liftn */1];
  var partial_arg$1 = function (param, param$1) {
    return partial_arg(n, param, param$1);
  };
  var ccl$prime = (function (param, param$1, param$2) {
        return map_predicate(partial_arg$1, param, param$1, param$2);
      })(k + 1 | 0, ccl, tms);
  var realargsi = nrealargs !== 0 ? Vars$ReactTemplate.subst_of_rel_context_instance(arsign, Util$ReactTemplate.$$Array[/* to_list */9](cs[/* cs_concl_realargs */4])) : /* [] */0;
  var realargsi$1 = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, realargsi);
  var copti = depna ? /* Some */[EConstr$ReactTemplate.of_constr(Inductiveops$ReactTemplate.build_dependent_constructor(cs))] : /* None */0;
  var ccl$prime$prime = Reductionops$ReactTemplate.whd_betaiota(Evd$ReactTemplate.empty, subst_predicate(/* tuple */[
            realargsi$1,
            copti
          ], ccl$prime, tms));
  var partial_arg$2 = EConstr$ReactTemplate.Vars[/* liftn */1];
  var partial_arg$3 = function (param, param$1) {
    return partial_arg$2(n, param, param$1);
  };
  var ccl$prime$prime$prime = (function (param, param$1, param$2) {
        return map_predicate(partial_arg$3, param, param$1, param$2);
      })(n + 1 | 0, ccl$prime$prime, tms);
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                  var tms$1 = tms;
                  var param$2 = param;
                  var param$3 = param$1;
                  var p = param$2[0];
                  var k = length_of_tomatch_type_sign(param$3[2], param$3[0][1]);
                  var partial_arg = k - 1 | 0;
                  var partial_arg$1 = EConstr$ReactTemplate.Vars[/* liftn */1];
                  var partial_arg$2 = function (param, param$1) {
                    return partial_arg$1(partial_arg, param, param$1);
                  };
                  return /* tuple */[
                          p + k | 0,
                          (function (param, param$1, param$2) {
                                return map_predicate(partial_arg$2, param, param$1, param$2);
                              })(p + 1 | 0, param$2[1], tms$1)
                        ];
                }), /* tuple */[
                1,
                ccl$prime$prime$prime
              ], newtomatchs)[1];
}

function find_predicate(_, env, evdref, p, current, param, dep, tms) {
  var realargs = param[1];
  var pred = abstract_predicate(env, evdref[0], param[0], current, realargs, dep, tms, p);
  return /* tuple */[
          pred,
          Reductionops$ReactTemplate.whd_betaiota(evdref[0], EConstr$ReactTemplate.applist(/* tuple */[
                    pred,
                    Util$ReactTemplate.$at(realargs, /* :: */[
                          current,
                          /* [] */0
                        ])
                  ]))
        ];
}

function adjust_predicate_from_tomatch(tomatch, ct, pb) {
  var na = tomatch[2];
  var deps = tomatch[1];
  var typ = ct[1];
  if (typ.tag) {
    return /* tuple */[
            pb,
            /* tuple */[
              ct,
              deps,
              na
            ]
          ];
  } else if (tomatch[0][1].tag) {
    var k = na ? 2 : 1;
    var n = Curry._1(Util$ReactTemplate.List[/* length */0], typ[2]);
    var newrecord = pb.slice();
    var partial_arg = EConstr$ReactTemplate.Vars[/* liftn */1];
    var partial_arg$1 = function (param, param$1) {
      return partial_arg(n, param, param$1);
    };
    newrecord[/* pred */3] = (function (param, param$1, param$2) {
          return map_predicate(partial_arg$1, param, param$1, param$2);
        })(k, pb[/* pred */3], pb[/* tomatch */4]);
    return /* tuple */[
            newrecord,
            /* tuple */[
              ct,
              Curry._2(Util$ReactTemplate.List[/* map */10], (function (i) {
                      if (i >= k) {
                        return i + n | 0;
                      } else {
                        return i;
                      }
                    }), deps),
              na
            ]
          ];
  } else {
    return /* tuple */[
            pb,
            /* tuple */[
              ct,
              deps,
              na
            ]
          ];
  }
}

function ungeneralize(sigma, n, ng, body) {
  var match = EConstr$ReactTemplate.kind(sigma, body);
  switch (match.tag | 0) {
    case 7 : 
        var c = match[2];
        if (ng) {
          return EConstr$ReactTemplate.mkLambda(/* tuple */[
                      match[0],
                      match[1],
                      ungeneralize(sigma, n + 1 | 0, ng - 1 | 0, c)
                    ]);
        } else {
          return EConstr$ReactTemplate.Vars[/* subst1 */4](EConstr$ReactTemplate.mkRel(n), c);
        }
    case 8 : 
        return EConstr$ReactTemplate.mkLetIn(/* tuple */[
                    match[0],
                    match[1],
                    match[2],
                    ungeneralize(sigma, n + 1 | 0, ng, match[3])
                  ]);
    case 9 : 
        var args = match[1];
        var f = match[0];
        if (!EConstr$ReactTemplate.isCase(sigma, f)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "cases.ml",
                  1129,
                  6
                ]
              ];
        }
        return EConstr$ReactTemplate.mkApp(/* tuple */[
                    ungeneralize(sigma, n, ng + args.length | 0, f),
                    args
                  ]);
    case 13 : 
        var ci = match[0];
        var match$1 = EConstr$ReactTemplate.decompose_lam_assum(sigma, match[1]);
        var sign = match$1[0];
        var match$2 = EConstr$ReactTemplate.decompose_prod_n_assum(sigma, ng, match$1[1]);
        var p = Termops$ReactTemplate.prod_applist(sigma, match$2[1], /* :: */[
              EConstr$ReactTemplate.mkRel((n + Curry._1(Util$ReactTemplate.List[/* length */0], sign) | 0) + ng | 0),
              /* [] */0
            ]);
        var p$1 = EConstr$ReactTemplate.it_mkLambda_or_LetIn(EConstr$ReactTemplate.it_mkProd_or_LetIn(p, match$2[0]), sign);
        return EConstr$ReactTemplate.mkCase(/* tuple */[
                    ci,
                    p$1,
                    match[2],
                    Util$ReactTemplate.$$Array[/* map2 */49]((function (q, c) {
                            var match = EConstr$ReactTemplate.decompose_lam_n_decls(sigma, q)(c);
                            return EConstr$ReactTemplate.it_mkLambda_or_LetIn(ungeneralize(sigma, n + q | 0, ng, match[1]), match[0]);
                          }), ci[/* ci_cstr_ndecls */2], match[3])
                  ]);
    default:
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cases.ml",
              1131,
              9
            ]
          ];
  }
}

function is_dependent_generalization(sigma, _ng, _body) {
  while(true) {
    var body = _body;
    var ng = _ng;
    var match = EConstr$ReactTemplate.kind(sigma, body);
    switch (match.tag | 0) {
      case 7 : 
          var c = match[2];
          if (ng) {
            _body = c;
            _ng = ng - 1 | 0;
            continue ;
            
          } else {
            return 1 - EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, c);
          }
          break;
      case 8 : 
          _body = match[3];
          continue ;
          case 9 : 
          var g = match[0];
          if (!EConstr$ReactTemplate.isCase(sigma, g)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "cases.ml",
                    1154,
                    6
                  ]
                ];
          }
          _body = g;
          _ng = ng + match[1].length | 0;
          continue ;
          case 13 : 
          return Util$ReactTemplate.$$Array[/* exists2 */25]((function(ng){
                    return function (q, c) {
                      var match = EConstr$ReactTemplate.decompose_lam_n_decls(sigma, q)(c);
                      return is_dependent_generalization(sigma, ng, match[1]);
                    }
                    }(ng)), match[0][/* ci_cstr_ndecls */2], match[3]);
      default:
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cases.ml",
                1156,
                9
              ]
            ];
    }
  };
}

function postprocess_dependencies(evd, tocheck, brs, tomatch, pred, deps, cs) {
  var aux = function (k, _brs, _tomatch, _pred, tocheck, _deps) {
    while(true) {
      var deps = _deps;
      var pred = _pred;
      var tomatch = _tomatch;
      var brs = _brs;
      var exit = 0;
      if (deps) {
        if (tomatch) {
          var match = tomatch[0];
          if (typeof match === "number") {
            exit = 1;
          } else if (match.tag === 2) {
            var tomatch$1 = tomatch[1];
            var deps$1 = deps[1];
            var n = deps[0];
            var d = Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], (function (c) {
                    return Evarutil$ReactTemplate.nf_evar(evd, c);
                  }), match[1]);
            var is_d;
            is_d = d.tag ? /* true */1 : /* false */0;
            if (is_d || Curry._2(Util$ReactTemplate.List[/* exists */21], (function(d){
                  return function (c) {
                    return dependent_decl(evd, EConstr$ReactTemplate.Vars[/* lift */0](k, c), d);
                  }
                  }(d)), tocheck) && Util$ReactTemplate.$$Array[/* exists */24]((function (param) {
                      var sigma = evd;
                      var k$1 = k;
                      var param$1 = param;
                      return is_dependent_generalization(sigma, k$1, param$1[1]);
                    }), brs)) {
              var match$1 = aux(k + 1 | 0, brs, tomatch$1, pred, /* :: */[
                    EConstr$ReactTemplate.mkRel(n),
                    tocheck
                  ], deps$1);
              var inst = match$1[3];
              var inst$1;
              inst$1 = d.tag ? inst : /* :: */[
                  EConstr$ReactTemplate.mkRel(n),
                  inst
                ];
              return /* tuple */[
                      match$1[0],
                      /* :: */[
                        /* Abstract */Block.__(2, [
                            match[0],
                            d
                          ]),
                        match$1[1]
                      ],
                      match$1[2],
                      inst$1
                    ];
            } else {
              var pred$1 = Curry._1(liftn_predicate(-1), 1)(pred, tomatch$1);
              var tomatch$2 = relocate_index_tomatch(evd, 1, n + 1 | 0)(tomatch$1);
              var tomatch$3 = liftn_tomatch_stack(-1, 1, tomatch$2);
              var brs$1 = Util$ReactTemplate.$$Array[/* map2 */49]((function(n){
                  return function (param, param$1) {
                    var sigma = evd;
                    var n$1 = n;
                    var k$1 = k;
                    var param$2 = param;
                    var cs = param$1;
                    return /* tuple */[
                            param$2[0],
                            ungeneralize(sigma, n$1 + cs[/* cs_nargs */2] | 0, k$1, param$2[1])
                          ];
                  }
                  }(n)), brs, cs);
              _deps = deps$1;
              _pred = pred$1;
              _tomatch = tomatch$3;
              _brs = brs$1;
              continue ;
              
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        return /* tuple */[
                brs,
                tomatch,
                pred,
                /* [] */0
              ];
      }
      if (exit === 1) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cases.ml",
                1185,
                9
              ]
            ];
      }
      
    };
  };
  return aux(0, brs, tomatch, pred, tocheck, deps);
}

function irrefutable(env, pat) {
  var match = DAst$ReactTemplate.get(pat);
  if (match.tag) {
    var ind = Names$ReactTemplate.inductive_of_constructor(match[0]);
    var match$1 = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
    var one_constr = +(match$1[1][/* mind_user_lc */4].length === 1);
    if (one_constr) {
      return Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
                    return irrefutable(env, param);
                  }), match[1]);
    } else {
      return /* false */0;
    }
  } else {
    return /* true */1;
  }
}

function first_clause_irrefutable(env, param) {
  if (param) {
    return Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
                  return irrefutable(env, param);
                }), param[0][/* patterns */0]);
  } else {
    return /* false */0;
  }
}

function group_equations(pb, ind, _, cstrs, mat) {
  var mat$1 = first_clause_irrefutable(pb[/* env */0], mat) ? /* :: */[
      Curry._1(Util$ReactTemplate.List[/* hd */1], mat),
      /* [] */0
    ] : mat;
  var brs = Caml_array.caml_make_vect(cstrs.length, /* [] */0);
  var only_default = [/* None */0];
  Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (eqn, _) {
          var rest = remove_current_pattern(eqn);
          var pat = current_pattern(eqn);
          var match = DAst$ReactTemplate.get(check_and_adjust_constructor(pb[/* env */0], ind, cstrs, pat));
          if (match.tag) {
            var i = match[0][1];
            only_default[0] = /* Some */[/* false */0];
            return Caml_array.caml_array_set(brs, i - 1 | 0, /* :: */[
                        /* tuple */[
                          match[1],
                          match[2],
                          rest
                        ],
                        Caml_array.caml_array_get(brs, i - 1 | 0)
                      ]);
          } else {
            var name = match[0];
            for(var i$1 = 1 ,i_finish = cstrs.length; i$1 <= i_finish; ++i$1){
              var args = make_anonymous_patvars(Caml_array.caml_array_get(cstrs, i$1 - 1 | 0)[/* cs_nargs */2]);
              Caml_array.caml_array_set(brs, i$1 - 1 | 0, /* :: */[
                    /* tuple */[
                      args,
                      name,
                      rest
                    ],
                    Caml_array.caml_array_get(brs, i$1 - 1 | 0)
                  ]);
            }
            if (only_default[0]) {
              return 0;
            } else {
              only_default[0] = /* Some */[/* true */1];
              return /* () */0;
            }
          }
        }), mat$1, /* () */0);
  return /* tuple */[
          brs,
          Option$ReactTemplate.$$default(/* false */0, only_default[0])
        ];
}

function generalize_problem(names, pb, param) {
  if (param) {
    var i = param[0];
    var match = generalize_problem(names, pb, param[1]);
    var deps = match[1];
    var pb$prime = match[0];
    var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
    var d = Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], (function (param) {
            return partial_arg(i, param);
          }), EConstr$ReactTemplate.lookup_rel(i, pb[/* env */0]));
    var exit = 0;
    if (d.tag) {
      if (d[0]) {
        exit = 1;
      } else {
        return /* tuple */[
                pb$prime,
                deps
              ];
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var d$1 = Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_type */12], (function (c) {
              return Reductionops$ReactTemplate.whd_betaiota(pb[/* evdref */2][0], c);
            }), d);
      var tomatch = liftn_tomatch_stack(1, 1, pb$prime[/* tomatch */4]);
      var tomatch$1 = relocate_index_tomatch(pb[/* evdref */2][0], i + 1 | 0, 1)(tomatch);
      var newrecord = pb$prime.slice();
      return /* tuple */[
              (newrecord[/* pred */3] = generalize_predicate(pb$prime[/* evdref */2][0], names, i, d$1, pb$prime[/* tomatch */4], pb$prime[/* pred */3]), newrecord[/* tomatch */4] = /* :: */[
                  /* Abstract */Block.__(2, [
                      i,
                      d$1
                    ]),
                  tomatch$1
                ], newrecord),
              /* :: */[
                i,
                deps
              ]
            ];
    }
    
  } else {
    return /* tuple */[
            pb,
            /* [] */0
          ];
  }
}

function build_branch(initial, current, realargs, _, param, pb, arsign, eqns, const_info) {
  var curname = param[1];
  var realnames = param[0];
  var history = push_history_pattern(const_info[/* cs_nargs */2], const_info[/* cs_cstr */0][0], pb[/* history */5]);
  var cs_args = const_info[/* cs_args */3];
  var cs_args$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
          return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
        }), cs_args);
  var match = get_names(pb[/* env */0], pb[/* evdref */2][0], cs_args$1, eqns);
  var aliasname = match[1];
  var typs = Curry._3(Util$ReactTemplate.List[/* map2 */16], Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], match[0], cs_args$1);
  var partial_arg = pb[/* evdref */2][0];
  var partial_arg$1 = pb[/* env */0];
  var typs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* map_type */12], (function (param) {
              return Reductionops$ReactTemplate.nf_betaiota(partial_arg$1, partial_arg, param);
            })), typs);
  var submat = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var tms = param[0];
          var eqn = param[2];
          return /* record */[
                  /* patterns */Util$ReactTemplate.$at(tms, eqn[/* patterns */0]),
                  /* rhs */eqn[/* rhs */1],
                  /* alias_stack */eqn[/* alias_stack */2],
                  /* eqn_loc */eqn[/* eqn_loc */3],
                  /* used */eqn[/* used */4]
                ];
        }), eqns);
  var typs$prime = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, d) {
          var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
          return /* tuple */[
                  EConstr$ReactTemplate.mkRel(i),
                  Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], (function (param) {
                          return partial_arg(i, param);
                        }), d)
                ];
        }), 1, typs$1);
  var extenv = EConstr$ReactTemplate.push_rel_context(typs$1, pb[/* env */0]);
  var typs$prime$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var d = param[1];
          return /* tuple */[
                  param[0],
                  extract_inductive_data(extenv, pb[/* evdref */2][0], d),
                  d
                ];
        }), typs$prime);
  var dep_sign = find_dependencies_signature(pb[/* evdref */2][0], dependencies_in_rhs(pb[/* evdref */2][0], const_info[/* cs_nargs */2], current, pb[/* tomatch */4], eqns), Curry._1(Util$ReactTemplate.List[/* rev */4], typs$prime$1));
  var ci = EConstr$ReactTemplate.of_constr(Inductiveops$ReactTemplate.build_dependent_constructor(const_info));
  var cirealargs = Util$ReactTemplate.$$Array[/* map_to_list */44](EConstr$ReactTemplate.of_constr, const_info[/* cs_concl_realargs */4]);
  var partial_arg$2 = const_info[/* cs_nargs */2];
  var tomatch = Curry._4(Util$ReactTemplate.List[/* fold_right2 */19], (function (par, arg, tomatch) {
          var match = EConstr$ReactTemplate.kind(pb[/* evdref */2][0], par);
          if (match.tag) {
            return tomatch;
          } else {
            return replace_tomatch(pb[/* evdref */2][0], match[0] + const_info[/* cs_nargs */2] | 0, arg)(tomatch);
          }
        }), /* :: */[
        current,
        realargs
      ], /* :: */[
        ci,
        cirealargs
      ], (function (param) {
            return liftn_tomatch_stack(partial_arg$2, 1, param);
          })(pb[/* tomatch */4]));
  var pred_is_not_dep = noccur_predicate_between(pb[/* evdref */2][0], 1)(Curry._1(Util$ReactTemplate.List[/* length */0], realnames) + 1 | 0, pb[/* pred */3], tomatch);
  var typs$prime$2 = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param, deps) {
          var na = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], param[2]);
          var na$1 = curname ? (
              na ? na : curname
            ) : (
              Curry._1(Util$ReactTemplate.List[/* is_empty */45], deps) && pred_is_not_dep ? /* Anonymous */0 : force_name(na)
            );
          return /* tuple */[
                  /* tuple */[
                    param[0],
                    param[1][0]
                  ],
                  deps,
                  na$1
                ];
        }), typs$prime$1, Curry._1(Util$ReactTemplate.List[/* rev */4], dep_sign));
  var pred = specialize_predicate(typs$prime$2, /* tuple */[
        realnames,
        curname
      ], arsign, const_info, tomatch, pb[/* pred */3]);
  var currents = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
          return /* Pushed */Block.__(0, [/* tuple */[
                      /* false */0,
                      x
                    ]]);
        }), typs$prime$2);
  var alias;
  if (aliasname) {
    var cur_alias = EConstr$ReactTemplate.Vars[/* lift */0](const_info[/* cs_nargs */2], current);
    var partial_arg$3 = const_info[/* cs_nargs */2];
    var partial_arg$4 = EConstr$ReactTemplate.Vars[/* lift */0];
    var partial_arg$5 = function (param) {
      return partial_arg$4(partial_arg$3, param);
    };
    var ind = EConstr$ReactTemplate.mkApp(/* tuple */[
          EConstr$ReactTemplate.applist(/* tuple */[
                EConstr$ReactTemplate.mkIndU(/* tuple */[
                      Names$ReactTemplate.inductive_of_constructor(const_info[/* cs_cstr */0][0]),
                      EConstr$ReactTemplate.EInstance[/* make */0](const_info[/* cs_cstr */0][1])
                    ]),
                Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                        return Util$ReactTemplate.$percent$great(EConstr$ReactTemplate.of_constr, partial_arg$5, param);
                      }), const_info[/* cs_params */1])
              ]),
          Util$ReactTemplate.$$Array[/* map */12](EConstr$ReactTemplate.of_constr, const_info[/* cs_concl_realargs */4])
        ]);
    alias = /* Alias */Block.__(1, [/* tuple */[
          initial,
          /* tuple */[
            aliasname,
            cur_alias,
            /* tuple */[
              ci,
              ind
            ]
          ]
        ]]);
  } else {
    alias = /* NonDepAlias */0;
  }
  var tomatch$1 = Curry._2(Util$ReactTemplate.List[/* rev_append */6], /* :: */[
        alias,
        currents
      ], tomatch);
  var submat$1 = adjust_impossible_cases(pb, pred, tomatch$1, submat);
  if (!submat$1) {
    raise_pattern_matching_error(/* None */0, /* tuple */[
          pb[/* env */0],
          Evd$ReactTemplate.empty,
          /* NonExhaustive */Block.__(5, [glob_pattern_of_partial_history(/* [] */0, history)])
        ]);
  }
  return /* tuple */[
          typs$1,
          /* record */[
            /* env */extenv,
            /* lvar */pb[/* lvar */1],
            /* evdref */pb[/* evdref */2],
            /* pred */pred,
            /* tomatch */tomatch$1,
            /* history */history,
            /* mat */Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    var sign = typs$1;
                    var eqn = param;
                    var subpats = Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._2(Util$ReactTemplate.List[/* firstn */104], Curry._1(Util$ReactTemplate.List[/* length */0], sign), eqn[/* patterns */0]));
                    var subpatnames = Curry._2(Util$ReactTemplate.List[/* map */10], Glob_ops$ReactTemplate.alias_of_pat, subpats);
                    var sign$1 = Curry._2(recover_initial_subpattern_names, subpatnames, sign);
                    return push_rels_eqn(sign$1, eqn);
                  }), submat$1),
            /* caseloc */pb[/* caseloc */7],
            /* casestyle */pb[/* casestyle */8],
            /* typing_function */pb[/* typing_function */9]
          ]
        ];
}

function compile(pb) {
  var match = pb[/* tomatch */4];
  if (match) {
    var match$1 = match[0];
    if (typeof match$1 === "number") {
      var pb$1 = pb;
      var rest = match[1];
      var newrecord = pb$1.slice();
      newrecord[/* tomatch */4] = rest;
      newrecord[/* history */5] = pop_history_pattern(pb$1[/* history */5]);
      newrecord[/* mat */6] = Curry._2(Util$ReactTemplate.List[/* map */10], drop_alias_eqn, pb$1[/* mat */6]);
      return compile(newrecord);
    } else {
      switch (match$1.tag | 0) {
        case 0 : 
            var newrecord$1 = pb.slice();
            var pb$2 = (newrecord$1[/* tomatch */4] = match[1], newrecord$1);
            var param = match$1[0];
            var tomatch = param[1];
            var initial = param[0];
            var tm = adjust_tomatch_to_pattern(pb$2, tomatch);
            var match$2 = adjust_predicate_from_tomatch(tomatch, tm, pb$2);
            var tomatch$1 = match$2[1];
            var dep = tomatch$1[2];
            var match$3 = tomatch$1[0];
            var typ = match$3[1];
            var current = match$3[0];
            var pb$3 = match$2[0];
            if (typ.tag) {
              check_all_variables(pb$3[/* env */0], pb$3[/* evdref */2][0], typ[1], pb$3[/* mat */6]);
              return compile_all_variables(initial, tomatch$1, pb$3);
            } else {
              var names = typ[2];
              var indt = typ[1];
              var realargs = indt[1];
              var indf = indt[0];
              var match$4 = Inductiveops$ReactTemplate.dest_ind_family(indf);
              var mind = Tacred$ReactTemplate.check_privacy(pb$3[/* env */0], match$4[0]);
              var cstrs = Inductiveops$ReactTemplate.get_constructors(pb$3[/* env */0], indf);
              var match$5 = Inductiveops$ReactTemplate.get_arity(pb$3[/* env */0], indf);
              var arsign = match$5[0];
              var match$6 = group_equations(pb$3, mind[0], current, cstrs, pb$3[/* mat */6]);
              var no_cstr = +(cstrs.length === 0);
              if ((!no_cstr || !Curry._1(Util$ReactTemplate.List[/* is_empty */45], pb$3[/* mat */6])) && match$6[1]) {
                return compile_all_variables(initial, tomatch$1, pb$3);
              } else {
                var match$7 = generalize_problem(/* tuple */[
                      names,
                      dep
                    ], pb$3, tomatch$1[1]);
                var deps = match$7[1];
                var pb$4 = match$7[0];
                var partial_arg = /* tuple */[
                  names,
                  dep
                ];
                var brvals = Util$ReactTemplate.$$Array[/* map2 */49]((function (param, param$1) {
                        var initial$1 = initial;
                        var current$1 = current;
                        var realargs$1 = realargs;
                        var names = partial_arg;
                        var deps$1 = deps;
                        var pb$5 = pb$4;
                        var arsign$1 = arsign;
                        var eqns = param;
                        var cstr = param$1;
                        var match = build_branch(initial$1, current$1, realargs$1, deps$1, names, pb$5, arsign$1, eqns, cstr);
                        return /* tuple */[
                                match[0],
                                compile(match[1])[/* uj_val */0]
                              ];
                      }), match$6[0], cstrs);
                var depstocheck_001 = binding_vars_of_inductive(pb$4[/* evdref */2][0], typ);
                var depstocheck = /* :: */[
                  current,
                  depstocheck_001
                ];
                var match$8 = postprocess_dependencies(pb$4[/* evdref */2][0], depstocheck, brvals, pb$4[/* tomatch */4], pb$4[/* pred */3], deps, cstrs);
                var inst = match$8[3];
                var brvals$1 = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
                        var partial_arg = pb$4[/* lvar */1];
                        var sign = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* map_name */10], (function (param) {
                                    return Glob_ops$ReactTemplate.ltac_interp_name(partial_arg, param);
                                  })), param[0]);
                        return EConstr$ReactTemplate.it_mkLambda_or_LetIn(param[1], sign);
                      }), match$8[0]);
                var match$9 = find_predicate(pb$4[/* caseloc */7], pb$4[/* env */0], pb$4[/* evdref */2], match$8[2], current, indt, /* tuple */[
                      names,
                      dep
                    ], match$8[1]);
                var ci = Inductiveops$ReactTemplate.make_case_info(pb$4[/* env */0], mind[0], pb$4[/* casestyle */8]);
                var pred = Reductionops$ReactTemplate.nf_betaiota(pb$4[/* env */0], pb$4[/* evdref */2][0], match$9[0]);
                var $$case = Inductiveops$ReactTemplate.make_case_or_project(pb$4[/* env */0], pb$4[/* evdref */2][0], indf, ci, pred, current, brvals$1);
                Typing$ReactTemplate.check_allowed_sort(pb$4[/* env */0], pb$4[/* evdref */2][0], mind, current, pred);
                return /* record */[
                        /* uj_val */EConstr$ReactTemplate.applist(/* tuple */[
                              $$case,
                              inst
                            ]),
                        /* uj_type */Termops$ReactTemplate.prod_applist(pb$4[/* evdref */2][0], match$9[1], inst)
                      ];
              }
            }
        case 1 : 
            var match$10 = match$1[0];
            var initial$1 = match$10[0];
            var pb$5 = pb;
            var param$1 = match$10[1];
            var rest$1 = match[1];
            var match$11 = param$1[2];
            var expanded_typ = match$11[1];
            var expanded = match$11[0];
            var orig = param$1[1];
            var na = param$1[0];
            var f = function (c, t) {
              var alias = /* LocalDef */Block.__(1, [
                  na,
                  c,
                  t
                ]);
              var pb_000 = /* env */EConstr$ReactTemplate.push_rel(alias, pb$5[/* env */0]);
              var pb_001 = /* lvar */pb$5[/* lvar */1];
              var pb_002 = /* evdref */pb$5[/* evdref */2];
              var pb_003 = /* pred */Curry._1(liftn_predicate(1), 1)(pb$5[/* pred */3], pb$5[/* tomatch */4]);
              var pb_004 = /* tomatch */liftn_tomatch_stack(1, 1, rest$1);
              var pb_005 = /* history */pop_history_pattern(pb$5[/* history */5]);
              var pb_006 = /* mat */Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                      var alias$1 = alias;
                      var eqn = param;
                      var aliasname = Curry._1(Util$ReactTemplate.List[/* hd */1], eqn[/* alias_stack */2]);
                      var eqn$1 = drop_alias_eqn(eqn);
                      var alias$2 = Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], aliasname, alias$1);
                      return push_rels_eqn(/* :: */[
                                  alias$2,
                                  /* [] */0
                                ], eqn$1);
                    }), pb$5[/* mat */6]);
              var pb_007 = /* caseloc */pb$5[/* caseloc */7];
              var pb_008 = /* casestyle */pb$5[/* casestyle */8];
              var pb_009 = /* typing_function */pb$5[/* typing_function */9];
              var pb$6 = /* record */[
                pb_000,
                pb_001,
                pb_002,
                pb_003,
                pb_004,
                pb_005,
                pb_006,
                pb_007,
                pb_008,
                pb_009
              ];
              var j = compile(pb$6);
              var sigma = pb_002[0];
              return /* record */[
                      /* uj_val */EConstr$ReactTemplate.isRel(sigma, c) || EConstr$ReactTemplate.isVar(sigma, c) || Termops$ReactTemplate.count_occurrences(sigma, EConstr$ReactTemplate.mkRel(1), j[/* uj_val */0]) <= 1 ? EConstr$ReactTemplate.Vars[/* subst1 */4](c, j[/* uj_val */0]) : EConstr$ReactTemplate.mkLetIn(/* tuple */[
                              na,
                              c,
                              t,
                              j[/* uj_val */0]
                            ]),
                      /* uj_type */EConstr$ReactTemplate.Vars[/* subst1 */4](c, j[/* uj_type */1])
                    ];
            };
            var just_pop = function () {
              var newrecord = pb$5.slice();
              newrecord[/* tomatch */4] = rest$1;
              newrecord[/* history */5] = pop_history_pattern(pb$5[/* history */5]);
              newrecord[/* mat */6] = Curry._2(Util$ReactTemplate.List[/* map */10], drop_alias_eqn, pb$5[/* mat */6]);
              return compile(newrecord);
            };
            var sigma = pb$5[/* evdref */2][0];
            if (!Flags$ReactTemplate.is_program_mode(/* () */0) && (EConstr$ReactTemplate.isRel(sigma, orig) || EConstr$ReactTemplate.isVar(sigma, orig))) {
              try {
                if (initial$1) {
                  return f(orig, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, pb$5[/* env */0], sigma, orig));
                } else {
                  return just_pop(/* () */0);
                }
              }
              catch (raw_e){
                var e = Js_exn.internalToOCamlException(raw_e);
                if (Pretype_errors$ReactTemplate.precatchable_exception(e)) {
                  pb$5[/* evdref */2][0] = sigma;
                  return f(expanded, expanded_typ);
                } else {
                  throw e;
                }
              }
            } else {
              try {
                return f(expanded, expanded_typ);
              }
              catch (raw_e$1){
                var e$1 = Js_exn.internalToOCamlException(raw_e$1);
                if (Pretype_errors$ReactTemplate.precatchable_exception(e$1)) {
                  pb$5[/* evdref */2][0] = sigma;
                  if (initial$1) {
                    return f(orig, Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, pb$5[/* env */0], pb$5[/* evdref */2][0], orig));
                  } else {
                    return just_pop(/* () */0);
                  }
                } else {
                  throw e$1;
                }
              }
            }
        case 2 : 
            var pb$6 = pb;
            var i = match$1[0];
            var d = match$1[1];
            var rest$2 = match[1];
            var newrecord$2 = pb$6.slice();
            newrecord$2[/* env */0] = EConstr$ReactTemplate.push_rel(d, pb$6[/* env */0]);
            newrecord$2[/* tomatch */4] = rest$2;
            var partial_arg$1 = pb$6[/* env */0];
            newrecord$2[/* mat */6] = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    var n = i;
                    var decl = d;
                    var eqn = param;
                    var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
                    if (match) {
                      return push_rels_eqn(/* :: */[
                                  Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], Environ$ReactTemplate.lookup_rel(n, eqn[/* rhs */1][/* rhs_env */0])), decl),
                                  /* [] */0
                                ], eqn);
                    } else {
                      return push_rels_eqn(/* :: */[
                                  decl,
                                  /* [] */0
                                ], eqn);
                    }
                  }), pb$6[/* mat */6]);
            var j = compile(newrecord$2);
            return /* record */[
                    /* uj_val */EConstr$ReactTemplate.mkLambda_or_LetIn(d, j[/* uj_val */0]),
                    /* uj_type */Termops$ReactTemplate.mkProd_wo_LetIn(d, j[/* uj_type */1])
                  ];
        
      }
    }
  } else {
    var pb$7 = pb;
    var rhs = extract_rhs(pb$7);
    var j$1 = Curry._4(pb$7[/* typing_function */9], Evardefine$ReactTemplate.mk_tycon(pb$7[/* pred */3]), rhs[/* rhs_env */0], pb$7[/* evdref */2], rhs[/* it */3]);
    return Evarutil$ReactTemplate.j_nf_evar(pb$7[/* evdref */2][0], j$1);
  }
}

function compile_all_variables(initial, cur, pb) {
  if (initial) {
    var param = cur;
    var pb$1 = pb;
    var na = param[2];
    var match = param[0];
    var t = match[1];
    var current = match[0];
    var ty = type_of_tomatch(t);
    var tomatch = liftn_tomatch_stack(1, 1, pb$1[/* tomatch */4]);
    var pred = specialize_predicate_var(/* tuple */[
          current,
          t,
          na
        ], pb$1[/* env */0], pb$1[/* tomatch */4], pb$1[/* pred */3]);
    var partial_arg = /* tuple */[
      current,
      ty
    ];
    var pb_000 = /* env */EConstr$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
            na,
            current,
            ty
          ]), pb$1[/* env */0]);
    var pb_001 = /* lvar */pb$1[/* lvar */1];
    var pb_002 = /* evdref */pb$1[/* evdref */2];
    var pb_003 = /* pred */Curry._1(liftn_predicate(1), 1)(pred, tomatch);
    var pb_005 = /* history */pop_history(pb$1[/* history */5]);
    var pb_006 = /* mat */Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            var param$1 = partial_arg;
            var eqn = param;
            var match = eqn[/* patterns */0];
            if (match) {
              var rhs_env = EConstr$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                      Glob_ops$ReactTemplate.alias_of_pat(match[0]),
                      param$1[0],
                      param$1[1]
                    ]), eqn[/* rhs */1][/* rhs_env */0]);
              var init = eqn[/* rhs */1];
              return /* record */[
                      /* patterns */match[1],
                      /* rhs : record */[
                        /* rhs_env */rhs_env,
                        /* rhs_vars */init[/* rhs_vars */1],
                        /* avoid_ids */init[/* avoid_ids */2],
                        /* it */init[/* it */3]
                      ],
                      /* alias_stack */eqn[/* alias_stack */2],
                      /* eqn_loc */eqn[/* eqn_loc */3],
                      /* used */eqn[/* used */4]
                    ];
            } else {
              return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Empty list of patterns."));
            }
          }), pb$1[/* mat */6]);
    var pb_007 = /* caseloc */pb$1[/* caseloc */7];
    var pb_008 = /* casestyle */pb$1[/* casestyle */8];
    var pb_009 = /* typing_function */pb$1[/* typing_function */9];
    var pb$2 = /* record */[
      pb_000,
      pb_001,
      pb_002,
      pb_003,
      /* tomatch */tomatch,
      pb_005,
      pb_006,
      pb_007,
      pb_008,
      pb_009
    ];
    var j = compile(pb$2);
    return /* record */[
            /* uj_val */EConstr$ReactTemplate.Vars[/* subst1 */4](current, j[/* uj_val */0]),
            /* uj_type */EConstr$ReactTemplate.Vars[/* subst1 */4](current, j[/* uj_type */1])
          ];
  } else {
    var param$1 = cur;
    var pb$3 = pb;
    var match$1 = param$1[0];
    var pred$1 = specialize_predicate_var(/* tuple */[
          match$1[0],
          match$1[1],
          param$1[2]
        ], pb$3[/* env */0], pb$3[/* tomatch */4], pb$3[/* pred */3]);
    var newrecord = pb$3.slice();
    newrecord[/* pred */3] = pred$1;
    newrecord[/* history */5] = pop_history(pb$3[/* history */5]);
    newrecord[/* mat */6] = Curry._2(Util$ReactTemplate.List[/* map */10], push_noalias_current_pattern, pb$3[/* mat */6]);
    return compile(newrecord);
  }
}

function matx_of_eqns(env, eqns) {
  var build_eqn = function (param) {
    var match = param[/* v */0];
    var initial_rhs = match[2];
    var avoid = Environ$ReactTemplate.ids_of_named_context_val(Environ$ReactTemplate.named_context_val(env));
    var avoid$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (accu, id) {
            return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, accu);
          }), avoid, match[0]);
    var rhs_001 = /* rhs_vars */Glob_ops$ReactTemplate.free_glob_vars(initial_rhs);
    var rhs_003 = /* it : Some */[initial_rhs];
    var rhs = /* record */[
      /* rhs_env */env,
      rhs_001,
      /* avoid_ids */avoid$1,
      rhs_003
    ];
    return /* record */[
            /* patterns */match[1],
            /* rhs */rhs,
            /* alias_stack : [] */0,
            /* eqn_loc */param[/* loc */1],
            /* used */[/* false */0]
          ];
  };
  return Curry._2(Util$ReactTemplate.List[/* map */10], build_eqn, eqns);
}

function adjust_to_extended_env_and_remove_deps(env, extenv, sigma, subst, t) {
  var n = Curry._1(Context$ReactTemplate.Rel[/* length */3], EConstr$ReactTemplate.rel_context(env));
  var n$prime = Curry._1(Context$ReactTemplate.Rel[/* length */3], EConstr$ReactTemplate.rel_context(extenv));
  var map = function (param) {
    var match = Termops$ReactTemplate.lookup_rel_id(param[0], EConstr$ReactTemplate.rel_context(extenv));
    var traverse_local_defs = function (_p) {
      while(true) {
        var p = _p;
        var match = EConstr$ReactTemplate.lookup_rel(p, extenv);
        if (match.tag) {
          var c = match[1];
          if (!EConstr$ReactTemplate.isRel(sigma, c)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "cases.ml",
                    1629,
                    28
                  ]
                ];
          }
          _p = p + EConstr$ReactTemplate.destRel(sigma, c) | 0;
          continue ;
          
        } else {
          return p;
        }
      };
    };
    var p = traverse_local_defs(match[0]);
    var u = EConstr$ReactTemplate.Vars[/* lift */0](n$prime - n | 0, param[1]);
    try {
      return /* Some */[/* tuple */[
                p,
                u,
                Evarsolve$ReactTemplate.expand_vars_in_term(extenv, sigma)(u)
              ]];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
  };
  var subst0 = Curry._2(Util$ReactTemplate.List[/* map_filter */62], map, subst);
  var t0 = EConstr$ReactTemplate.Vars[/* lift */0](n$prime - n | 0, t);
  return /* tuple */[
          subst0,
          t0
        ];
}

function push_binder(d, param) {
  return /* tuple */[
          param[0] + 1 | 0,
          EConstr$ReactTemplate.push_rel(d, param[1]),
          Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return /* tuple */[
                          param[0],
                          EConstr$ReactTemplate.Vars[/* lift */0](1, param[1]),
                          param[2]
                        ];
                }), param[2])
        ];
}

function abstract_tycon(loc, env, evdref, subst, _, extenv, t) {
  var t$1 = Reductionops$ReactTemplate.nf_betaiota(env, evdref[0], t);
  var match = EConstr$ReactTemplate.kind(evdref[0], t$1);
  var src;
  src = match.tag === 3 ? Loc$ReactTemplate.tag(loc, /* SubEvar */Block.__(8, [match[0][0]])) : Loc$ReactTemplate.tag(loc, /* CasesType */Block.__(4, [/* true */1]));
  var match$1 = adjust_to_extended_env_and_remove_deps(env, extenv, evdref[0], subst, t$1);
  var subst0 = match$1[0];
  var aux = function (x, t) {
    var env = x[1];
    var k = x[0];
    var match = EConstr$ReactTemplate.kind(evdref[0], t);
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          if (Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_def */6], EConstr$ReactTemplate.lookup_rel(match[0], env))) {
            return t;
          } else {
            exit = 1;
          }
          break;
      case 3 : 
          var ty = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, evdref[0], t);
          var partial_arg = /* Some */[/* false */0];
          var ty$1 = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                  return Evarsolve$ReactTemplate.refresh_universes(/* None */0, /* None */0, /* None */0, partial_arg, env, param, param$1);
                }), evdref, ty);
          var inst = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, _) {
                  try {
                    var x = i;
                    var _param = subst0;
                    while(true) {
                      var param = _param;
                      if (param) {
                        var match = param[0];
                        if (match[0] === x) {
                          return match[1];
                        } else {
                          _param = param[1];
                          continue ;
                          
                        }
                      } else {
                        throw Caml_builtin_exceptions.not_found;
                      }
                    };
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      return EConstr$ReactTemplate.mkRel(i);
                    } else {
                      throw exn;
                    }
                  }
                }), 1, EConstr$ReactTemplate.rel_context(env));
          var ev$prime = Evarutil$ReactTemplate.e_new_evar(env, evdref, /* Some */[src], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, ty$1);
          var match$1 = Evarsolve$ReactTemplate.solve_simple_eqn(Evarconv$ReactTemplate.evar_conv_x(Names$ReactTemplate.full_transparent_state), /* None */0, env, evdref[0], /* tuple */[
                /* None */0,
                match[0],
                EConstr$ReactTemplate.Vars[/* substl */3](inst, ev$prime)
              ]);
          if (match$1.tag) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "cases.ml",
                    1687,
                    27
                  ]
                ];
          } else {
            evdref[0] = match$1[0];
          }
          return ev$prime;
      default:
        exit = 1;
    }
    if (exit === 1) {
      var good = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
              return Reductionops$ReactTemplate.is_conv_leq(/* None */0, env, evdref[0])(t, param[1]);
            }), x[2]);
      if (good) {
        var u = good[0][2];
        var vl = Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi1, good);
        var ty$2 = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, evdref[0], t);
        var partial_arg$1 = /* Some */[/* false */0];
        var ty$3 = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                return Evarsolve$ReactTemplate.refresh_universes(/* None */0, /* None */0, /* None */0, partial_arg$1, env, param, param$1);
              }), evdref, ty$2);
        var ty$4 = EConstr$ReactTemplate.Vars[/* lift */0](-k | 0, aux(x, ty$3));
        var depvl = Termops$ReactTemplate.free_rels(evdref[0], ty$4);
        var inst$1 = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, _) {
                if (Curry._2(Int$ReactTemplate.List[/* mem */0], i, vl)) {
                  return u;
                } else {
                  return EConstr$ReactTemplate.mkRel(i);
                }
              }), 1, EConstr$ReactTemplate.rel_context(extenv));
        var rel_filter = Curry._2(Util$ReactTemplate.List[/* map */10], (function (a) {
                if (!EConstr$ReactTemplate.isRel(evdref[0], a) || Termops$ReactTemplate.dependent(evdref[0], a, u)) {
                  return /* true */1;
                } else {
                  return Curry._2(Int$ReactTemplate.$$Set[/* mem */2], EConstr$ReactTemplate.destRel(evdref[0], a), depvl);
                }
              }), inst$1);
        var named_filter = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
                return Termops$ReactTemplate.local_occur_var(evdref[0], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d), u);
              }), EConstr$ReactTemplate.named_context(extenv));
        var filter = Evd$ReactTemplate.Filter[/* make */9](Util$ReactTemplate.$at(rel_filter, named_filter));
        var candidates_001 = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.mkRel, vl);
        var candidates = /* :: */[
          u,
          candidates_001
        ];
        var ev = Evarutil$ReactTemplate.e_new_evar(extenv, evdref, /* Some */[src], /* Some */[filter], /* Some */[candidates], /* None */0, /* None */0, /* None */0, ty$4);
        return EConstr$ReactTemplate.Vars[/* lift */0](k, ev);
      } else {
        return Termops$ReactTemplate.map_constr_with_full_binders(evdref[0], push_binder, aux, x, t);
      }
    }
    
  };
  return aux(/* tuple */[
              0,
              extenv,
              subst0
            ], match$1[1]);
}

function build_inversion_problem(loc, env, sigma, tms, t) {
  var make_patvar = function (t, param) {
    var avoid = param[1];
    var id = Namegen$ReactTemplate.next_name_away(Namegen$ReactTemplate.named_hd(env, sigma, t, /* Anonymous */0), avoid);
    var eta = /* PatVar */Block.__(0, [/* Name */[id]]);
    return /* tuple */[
            DAst$ReactTemplate.make(/* None */0, eta),
            /* tuple */[
              /* :: */[
                /* tuple */[
                  id,
                  t
                ],
                param[0]
              ],
              Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid)
            ]
          ];
  };
  var reveal_pattern = function (t, acc) {
    var match = EConstr$ReactTemplate.kind(sigma, Reductionops$ReactTemplate.whd_all(env)(sigma, t));
    switch (match.tag | 0) {
      case 9 : 
          var f = match[0];
          if (EConstr$ReactTemplate.isConstruct(sigma, f)) {
            var match$1 = EConstr$ReactTemplate.destConstruct(sigma, f);
            var cstr = match$1[0];
            var n = Inductiveops$ReactTemplate.constructor_nrealargs_env(env, cstr);
            var l = Curry._2(Util$ReactTemplate.List[/* lastn */106], n, Util$ReactTemplate.$$Array[/* to_list */9](match[1]));
            var match$2 = Curry._3(Util$ReactTemplate.List[/* fold_right_map */117], reveal_pattern, l, acc);
            return /* tuple */[
                    DAst$ReactTemplate.make(/* None */0, /* PatCstr */Block.__(1, [
                            cstr,
                            match$2[0],
                            /* Anonymous */0
                          ])),
                    match$2[1]
                  ];
          } else {
            return make_patvar(t, acc);
          }
          break;
      case 12 : 
          return /* tuple */[
                  DAst$ReactTemplate.make(/* None */0, /* PatCstr */Block.__(1, [
                          match[0][0],
                          /* [] */0,
                          /* Anonymous */0
                        ])),
                  acc
                ];
      default:
        return make_patvar(t, acc);
    }
  };
  var aux = function (n, env, acc_sign, tms, acc) {
    if (tms) {
      var match = tms[0];
      var match$1 = match[1];
      var t = match[0];
      if (match$1.tag) {
        var match$2 = make_patvar(t, acc);
        var pat = match$2[0];
        var d_000 = Glob_ops$ReactTemplate.alias_of_pat(pat);
        var d_001 = match$1[1];
        var d = /* LocalAssum */Block.__(0, [
            d_000,
            d_001
          ]);
        var match$3 = aux(n + 1 | 0, EConstr$ReactTemplate.push_rel(d, env), /* :: */[
              d,
              acc_sign
            ], tms[1], match$2[1]);
        return /* tuple */[
                /* :: */[
                  pat,
                  match$3[0]
                ],
                match$3[1],
                match$3[2]
              ];
      } else {
        var match$4 = match$1[1];
        var match$5 = Curry._3(Util$ReactTemplate.List[/* fold_right_map */117], reveal_pattern, match$4[1], acc);
        var match$6 = make_patvar(t, match$5[1]);
        var indf$prime = Inductiveops$ReactTemplate.lift_inductive_family(n)(match$4[0]);
        var sign = Inductiveops$ReactTemplate.make_arity_signature(env, sigma, /* true */1, indf$prime);
        var patl_000 = match$6[0];
        var patl_001 = Curry._1(Util$ReactTemplate.List[/* rev */4], match$5[0]);
        var patl = /* :: */[
          patl_000,
          patl_001
        ];
        var match$7 = recover_and_adjust_alias_names(patl, sign);
        var sign$1 = match$7[1];
        var patl$1 = match$7[0];
        var p = Curry._1(Util$ReactTemplate.List[/* length */0], patl$1);
        var env$prime = EConstr$ReactTemplate.push_rel_context(sign$1, env);
        var match$8 = aux(n + p | 0, env$prime, Util$ReactTemplate.$at(sign$1, acc_sign), tms[1], match$6[1]);
        return /* tuple */[
                Curry._2(Util$ReactTemplate.List[/* rev_append */6], patl$1, match$8[0]),
                match$8[1],
                match$8[2]
              ];
      }
    } else {
      return /* tuple */[
              /* [] */0,
              acc_sign,
              acc
            ];
    }
  };
  var avoid0 = Termops$ReactTemplate.vars_of_env(env);
  var match = aux(0, env, /* [] */0, tms, /* tuple */[
        /* [] */0,
        avoid0
      ]);
  var match$1 = match[2];
  var sign = match[1];
  var patl = match[0];
  var n = Curry._1(Util$ReactTemplate.List[/* length */0], sign);
  var decls = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, d) {
          var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
          return /* tuple */[
                  EConstr$ReactTemplate.mkRel(i),
                  Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], (function (param) {
                          return partial_arg(i, param);
                        }), d)
                ];
        }), 1, sign);
  var pb_env = EConstr$ReactTemplate.push_rel_context(sign, env);
  var decls$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var d = param[1];
          return /* tuple */[
                  param[0],
                  extract_inductive_data(pb_env, sigma, d),
                  d
                ];
        }), decls);
  var decls$2 = Curry._1(Util$ReactTemplate.List[/* rev */4], decls$1);
  var dep_sign = find_dependencies_signature(sigma, Curry._2(Util$ReactTemplate.List[/* make */56], n, /* true */1), decls$2);
  var sub_tms = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (deps, param) {
          var na = Curry._1(Util$ReactTemplate.List[/* is_empty */45], deps) ? /* Anonymous */0 : force_name(Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], param[2]));
          return /* Pushed */Block.__(0, [/* tuple */[
                      /* true */1,
                      /* tuple */[
                        /* tuple */[
                          param[0],
                          param[1][0]
                        ],
                        deps,
                        na
                      ]
                    ]]);
        }), dep_sign, decls$2);
  var subst = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[0],
                  EConstr$ReactTemplate.Vars[/* lift */0](n, param[1])
                ];
        }), match$1[0]);
  var main_eqn_001 = /* rhs : record */[
    /* rhs_env */pb_env,
    /* rhs_vars */Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (accu, param) {
            return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], param[0], accu);
          }), Names$ReactTemplate.Id[/* Set */9][/* empty */0], subst),
    /* avoid_ids */match$1[1],
    /* it : Some */[EConstr$ReactTemplate.Vars[/* lift */0](n, t)]
  ];
  var main_eqn_004 = /* used */[/* false */0];
  var main_eqn = /* record */[
    /* patterns */patl,
    main_eqn_001,
    /* alias_stack : [] */0,
    /* eqn_loc : None */0,
    main_eqn_004
  ];
  var catch_all_eqn = Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
          return irrefutable(env, param);
        }), patl) ? /* [] */0 : /* :: */[
      /* record */[
        /* patterns */Curry._2(Util$ReactTemplate.List[/* map */10], (function () {
                return DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [/* Anonymous */0]));
              }), patl),
        /* rhs : record */[
          /* rhs_env */pb_env,
          /* rhs_vars */Names$ReactTemplate.Id[/* Set */9][/* empty */0],
          /* avoid_ids */avoid0,
          /* it : None */0
        ],
        /* alias_stack : [] */0,
        /* eqn_loc : None */0,
        /* used */[/* false */0]
      ],
      /* [] */0
    ];
  var s$prime = Retyping$ReactTemplate.get_sort_of(/* None */0, env, sigma, t);
  var match$2 = Evd$ReactTemplate.new_sort_variable(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg, sigma);
  var s = match$2[1];
  var sigma$1 = Evd$ReactTemplate.set_leq_sort(env, match$2[0], s$prime, s);
  var evdref = [sigma$1];
  var pb_003 = /* pred */EConstr$ReactTemplate.mkSort(s);
  var pb_005 = /* history : Continuation */Block.__(0, [
      n,
      /* [] */0,
      /* Top */0
    ]);
  var pb_006 = /* mat : :: */[
    main_eqn,
    catch_all_eqn
  ];
  var pb_009 = function (param, param$1, param$2, param$3) {
    var loc$1 = loc;
    var env$1 = env;
    var tycon_env = pb_env;
    var s$1 = s;
    var subst$1 = subst;
    var tycon = param;
    var extenv = param$1;
    var evdref = param$2;
    var t = param$3;
    var match;
    if (t) {
      var t$1 = abstract_tycon(loc$1, tycon_env, evdref, subst$1, tycon, extenv, t[0]);
      var match$1 = Typing$ReactTemplate.type_of(/* None */0, extenv, evdref[0], t$1);
      evdref[0] = match$1[0];
      match = /* tuple */[
        t$1,
        match$1[1]
      ];
    } else {
      var n = Curry._1(Context$ReactTemplate.Rel[/* length */3], EConstr$ReactTemplate.rel_context(env$1));
      var n$prime = Curry._1(Context$ReactTemplate.Rel[/* length */3], EConstr$ReactTemplate.rel_context(tycon_env));
      var match$2 = Evarutil$ReactTemplate.e_new_type_evar(Environ$ReactTemplate.reset_context(env$1), evdref, /* Some */[Loc$ReactTemplate.tag(loc$1, /* ImpossibleCase */2)], /* None */0, /* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg);
      match = /* tuple */[
        EConstr$ReactTemplate.Vars[/* lift */0](n$prime - n | 0, match$2[0]),
        EConstr$ReactTemplate.mkSort(match$2[1])
      ];
    }
    var tt = match[1];
    var b = Evarconv$ReactTemplate.e_cumul(env$1, /* None */0, evdref, tt, EConstr$ReactTemplate.mkSort(s$1));
    if (!b) {
      CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Build_tycon: should be a type."));
    }
    return /* record */[
            /* uj_val */match[0],
            /* uj_type */tt
          ];
  };
  var pb = /* record */[
    /* env */pb_env,
    /* lvar */Glob_ops$ReactTemplate.empty_lvar,
    /* evdref */evdref,
    pb_003,
    /* tomatch */sub_tms,
    pb_005,
    pb_006,
    /* caseloc */loc,
    /* casestyle : RegularStyle */4,
    pb_009
  ];
  var pred = compile(pb)[/* uj_val */0];
  return /* tuple */[
          evdref[0],
          pred
        ];
}

function build_initial_predicate(arsign, pred) {
  var _n = 0;
  var pred$1 = pred;
  var _tmnames = /* [] */0;
  var _param = Curry._1(Util$ReactTemplate.List[/* rev */4], arsign);
  while(true) {
    var param = _param;
    var tmnames = _tmnames;
    var n = _n;
    if (param) {
      var match = param[0];
      if (match) {
        var na = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], match[0]);
        var n$prime = n + Curry._1(Util$ReactTemplate.List[/* length */0], match[1]) | 0;
        _param = param[1];
        _tmnames = /* :: */[
          force_name(na),
          tmnames
        ];
        _n = n$prime + 1 | 0;
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cases.ml",
                1874,
                11
              ]
            ];
      }
    } else {
      return /* tuple */[
              Curry._1(Util$ReactTemplate.List[/* rev */4], tmnames),
              pred$1
            ];
    }
  };
}

function extract_arity_signature($staropt$star, env0, lvar, tomatchl, tmsign) {
  var dolift = $staropt$star ? $staropt$star[0] : /* true */1;
  var lift = dolift ? EConstr$ReactTemplate.Vars[/* lift */0] : (function (_, t) {
        return t;
      });
  var get_one_sign = function (n, tm, param) {
    var t = param[1];
    var na = param[0];
    if (tm.tag) {
      var typ = tm[1];
      var bo = tm[0];
      if (t) {
        return CErrors$ReactTemplate.user_err(t[0][/* loc */1], /* None */0, Pp$ReactTemplate.str("Unexpected type annotation for a term of non inductive type."));
      } else {
        var sign = bo ? /* :: */[
            /* LocalDef */Block.__(1, [
                na,
                Curry._2(lift, n, bo[0]),
                Curry._2(lift, n, typ)
              ]),
            /* [] */0
          ] : /* :: */[
            /* LocalAssum */Block.__(0, [
                na,
                Curry._2(lift, n, typ)
              ]),
            /* [] */0
          ];
        return /* tuple */[
                sign,
                sign
              ];
      }
    } else {
      var indf = tm[1][0];
      var indf$prime = dolift ? Inductiveops$ReactTemplate.lift_inductive_family(n)(indf) : indf;
      var match = Inductiveops$ReactTemplate.dest_ind_family(indf$prime);
      var ind = match[0][0];
      var nrealargs_ctxt = Inductiveops$ReactTemplate.inductive_nrealdecls_env(env0, ind);
      var arsign = Inductiveops$ReactTemplate.get_arity(env0, indf$prime)[0];
      var arsign$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (d) {
              return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, d);
            }), arsign);
      var match$1;
      if (t) {
        var match$2 = t[0];
        var match$3 = match$2[/* v */0];
        var realnal = match$3[1];
        if (!Names$ReactTemplate.eq_ind(ind, match$3[0])) {
          CErrors$ReactTemplate.user_err(match$2[/* loc */1], /* None */0, Pp$ReactTemplate.str("Wrong inductive type."));
        }
        if (nrealargs_ctxt !== Curry._1(Util$ReactTemplate.List[/* length */0], realnal)) {
          CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Ill-formed 'in' clause in cases."));
        }
        var realnal$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], realnal);
        var realnal$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                return Glob_ops$ReactTemplate.ltac_interp_name(lvar, param);
              }), realnal$1);
        match$1 = /* tuple */[
          realnal$1,
          realnal$prime
        ];
      } else {
        var realnal$2 = Curry._2(Util$ReactTemplate.List[/* make */56], nrealargs_ctxt, /* Anonymous */0);
        match$1 = /* tuple */[
          realnal$2,
          realnal$2
        ];
      }
      var na$prime = Glob_ops$ReactTemplate.ltac_interp_name(lvar, na);
      var t$1 = EConstr$ReactTemplate.of_constr(Inductiveops$ReactTemplate.build_dependent_inductive(env0, indf$prime));
      var arsign1_000 = /* LocalAssum */Block.__(0, [
          na,
          t$1
        ]);
      var arsign1_001 = Curry._3(Util$ReactTemplate.List[/* map2 */16], Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], match$1[0], arsign$1);
      var arsign1 = /* :: */[
        arsign1_000,
        arsign1_001
      ];
      var arsign2_000 = /* LocalAssum */Block.__(0, [
          na$prime,
          t$1
        ]);
      var arsign2_001 = Curry._3(Util$ReactTemplate.List[/* map2 */16], Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], match$1[1], arsign$1);
      var arsign2 = /* :: */[
        arsign2_000,
        arsign2_001
      ];
      return /* tuple */[
              arsign1,
              arsign2
            ];
    }
  };
  var buildrec = function (n, param) {
    var match = param[0];
    if (match) {
      var match$1 = param[1];
      if (match$1) {
        var l = get_one_sign(n, match[0][1], match$1[0][1]);
        return /* :: */[
                l,
                buildrec(n + Curry._1(Util$ReactTemplate.List[/* length */0], l[0]) | 0, /* tuple */[
                      match[1],
                      match$1[1]
                    ])
              ];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cases.ml",
                1920,
                11
              ]
            ];
      }
    } else if (param[1]) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cases.ml",
              1920,
              11
            ]
          ];
    } else {
      return /* [] */0;
    }
  };
  return Curry._1(Util$ReactTemplate.List[/* rev */4], buildrec(0, /* tuple */[
                  tomatchl,
                  tmsign
                ]));
}

function inh_conv_coerce_to_tycon(loc, env, evdref, j, tycon) {
  if (tycon) {
    var match = Coercion$ReactTemplate.inh_conv_coerce_to(loc, /* true */1)(env, evdref[0], j, tycon[0]);
    evdref[0] = match[0];
    return match[1];
  } else {
    return j;
  }
}

function prepare_predicate_from_arsign_tycon(env, sigma, _, tomatchs, arsign, c) {
  var nar = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (n, sign) {
          return Context$ReactTemplate.Rel[/* nhyps */5](sign) + n | 0;
        }), 0, arsign);
  var match = Curry._4(Util$ReactTemplate.List[/* fold_right2 */19], (function (param, sign, param$1) {
          var len = param$1[1];
          var subst = param$1[0];
          var tmtype = param[1];
          var tm = param[0];
          var signlen = Curry._1(Util$ReactTemplate.List[/* length */0], sign);
          var match = EConstr$ReactTemplate.kind(sigma, tm);
          if (match.tag) {
            return /* tuple */[
                    subst,
                    len - signlen | 0
                  ];
          } else {
            var n = match[0];
            if (Termops$ReactTemplate.dependent(sigma, tm, c) && signlen === 1) {
              return /* tuple */[
                      /* :: */[
                        /* tuple */[
                          n,
                          len
                        ],
                        subst
                      ],
                      len - signlen | 0
                    ];
            } else if (signlen > 1) {
              if (tmtype.tag) {
                return /* tuple */[
                        subst,
                        len - signlen | 0
                      ];
              } else {
                var realargs = tmtype[1][1];
                var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, arg) {
                        var len = param[1];
                        var subst = param[0];
                        var match = EConstr$ReactTemplate.kind(sigma, arg);
                        if (match.tag) {
                          return /* tuple */[
                                  subst,
                                  len - 1 | 0
                                ];
                        } else if (Termops$ReactTemplate.dependent(sigma, arg, c)) {
                          return /* tuple */[
                                  /* :: */[
                                    /* tuple */[
                                      match[0],
                                      len
                                    ],
                                    subst
                                  ],
                                  len - 1 | 0
                                ];
                        } else {
                          return /* tuple */[
                                  subst,
                                  len - 1 | 0
                                ];
                        }
                      }), /* tuple */[
                      subst,
                      len
                    ], realargs);
                var len$1 = match$1[1];
                var subst$1 = match$1[0];
                var subst$2 = Termops$ReactTemplate.dependent(sigma, tm, c) && Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
                        return EConstr$ReactTemplate.isRel(sigma, param);
                      }), realargs) ? /* :: */[
                    /* tuple */[
                      n,
                      len$1
                    ],
                    subst$1
                  ] : subst$1;
                return /* tuple */[
                        subst$2,
                        len$1 - 1 | 0
                      ];
              }
            } else {
              return /* tuple */[
                      subst,
                      len - signlen | 0
                    ];
            }
          }
        }), Curry._1(Util$ReactTemplate.List[/* rev */4], tomatchs), arsign, /* tuple */[
        /* [] */0,
        nar
      ]);
  var subst = match[0];
  var predicate = function (lift, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    var exit = 0;
    if (match.tag) {
      exit = 1;
    } else {
      var n = match[0];
      if (n > lift) {
        try {
          var idx = Curry._2(Int$ReactTemplate.List[/* assoc */1], n - lift | 0, subst);
          return EConstr$ReactTemplate.mkRel(idx + lift | 0);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return EConstr$ReactTemplate.mkRel(n + nar | 0);
          } else {
            throw exn;
          }
        }
      } else {
        exit = 1;
      }
    }
    if (exit === 1) {
      return EConstr$ReactTemplate.map_with_binders(sigma, (function (prim) {
                    return prim + 1 | 0;
                  }), predicate, lift, c);
    }
    
  };
  if (match[1] !== 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "cases.ml",
            1976,
            2
          ]
        ];
  }
  var p = predicate(0, c);
  var env$prime = Curry._3(Util$ReactTemplate.List[/* fold_right */14], EConstr$ReactTemplate.push_rel_context, arsign, env);
  try {
    var sigma$prime = Typing$ReactTemplate.type_of(/* None */0, env$prime, sigma, p)[0];
    return /* Some */[/* tuple */[
              sigma$prime,
              p
            ]];
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (Pretype_errors$ReactTemplate.precatchable_exception(e)) {
      return /* None */0;
    } else {
      throw e;
    }
  }
}

var LocalOccur = Caml_exceptions.create("Cases-ReactTemplate.LocalOccur");

function noccur_with_meta(sigma, n, m, term) {
  var occur_rec = function (n, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 0 : 
          var p = match[0];
          if (n <= p && p < (n + m | 0)) {
            throw LocalOccur;
          } else {
            return 0;
          }
          break;
      case 3 : 
          return /* () */0;
      case 9 : 
          var match$1 = EConstr$ReactTemplate.kind(sigma, match[0]);
          var exit = 0;
          switch (match$1.tag | 0) {
            case 2 : 
                return /* () */0;
            case 5 : 
                if (EConstr$ReactTemplate.isMeta(sigma, match$1[0])) {
                  return /* () */0;
                } else {
                  exit = 1;
                }
                break;
            default:
              exit = 1;
          }
          if (exit === 1) {
            return EConstr$ReactTemplate.iter_with_binders(sigma, (function (prim) {
                          return prim + 1 | 0;
                        }), occur_rec, n, c);
          }
          break;
      default:
        return EConstr$ReactTemplate.iter_with_binders(sigma, (function (prim) {
                      return prim + 1 | 0;
                    }), occur_rec, n, c);
    }
  };
  try {
    occur_rec(n, term);
    return /* true */1;
  }
  catch (exn){
    if (exn === LocalOccur) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function prepare_predicate(loc, typing_fun, env, sigma, lvar, tomatchs, arsign, tycon, pred) {
  var refresh_tycon = function (sigma, t) {
    return Evarsolve$ReactTemplate.refresh_universes(/* Some */[Evd$ReactTemplate.univ_flexible], /* Some */[/* true */1], /* None */0, /* Some */[/* true */1], env, sigma, t);
  };
  var match = Curry._1(Util$ReactTemplate.List[/* split */36], arsign);
  var building_arsign = match[1];
  var typing_arsign = match[0];
  var preds;
  if (pred) {
    var envar = Curry._3(Util$ReactTemplate.List[/* fold_right */14], EConstr$ReactTemplate.push_rel_context, typing_arsign, env);
    var match$1 = Evd$ReactTemplate.new_sort_variable(/* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg, sigma);
    var evdref = [match$1[0]];
    var predcclj = Curry._5(typing_fun, Evardefine$ReactTemplate.mk_tycon(EConstr$ReactTemplate.mkSort(match$1[1])), envar, evdref, lvar, pred[0]);
    var sigma$1 = evdref[0];
    var predccl = Evarutil$ReactTemplate.nf_evar(sigma$1, predcclj[/* uj_val */0]);
    preds = /* :: */[
      /* tuple */[
        sigma$1,
        predccl
      ],
      /* [] */0
    ];
  } else {
    var exit = 0;
    if (tycon) {
      var t = tycon[0];
      if (noccur_with_meta(sigma, 0, Pervasives.max_int, t)) {
        exit = 1;
      } else {
        var match$2 = refresh_tycon(sigma, t);
        var t$1 = match$2[1];
        var sigma$2 = match$2[0];
        var p1 = prepare_predicate_from_arsign_tycon(env, sigma$2, loc, tomatchs, typing_arsign, t$1);
        var match$3 = build_inversion_problem(loc, env, sigma$2, tomatchs, t$1);
        var pred2 = match$3[1];
        var sigma2 = match$3[0];
        if (p1) {
          var match$4 = p1[0];
          preds = /* :: */[
            /* tuple */[
              match$4[0],
              match$4[1]
            ],
            /* :: */[
              /* tuple */[
                sigma2,
                pred2
              ],
              /* [] */0
            ]
          ];
        } else {
          preds = /* :: */[
            /* tuple */[
              sigma2,
              pred2
            ],
            /* [] */0
          ];
        }
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$5;
      if (tycon) {
        match$5 = refresh_tycon(sigma, tycon[0]);
      } else {
        var match$6 = Evarutil$ReactTemplate.new_type_evar(env, sigma, /* Some */[Loc$ReactTemplate.tag(loc, /* CasesType */Block.__(4, [/* false */0]))], /* None */0, /* None */0, /* None */0, Evd$ReactTemplate.univ_flexible_alg);
        match$5 = /* tuple */[
          match$6[0],
          match$6[1][0]
        ];
      }
      var t$2 = match$5[1];
      var sigma$3 = match$5[0];
      var match$7 = build_inversion_problem(loc, env, sigma$3, tomatchs, t$2);
      var pred2$1 = EConstr$ReactTemplate.Vars[/* lift */0](Curry._1(Util$ReactTemplate.List[/* length */0], Curry._1(Util$ReactTemplate.List[/* flatten */8], typing_arsign)), t$2);
      preds = /* :: */[
        /* tuple */[
          match$7[0],
          match$7[1]
        ],
        /* :: */[
          /* tuple */[
            sigma$3,
            pred2$1
          ],
          /* [] */0
        ]
      ];
    }
    
  }
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                var match = build_initial_predicate(building_arsign, param[1]);
                return /* tuple */[
                        param[0],
                        match[0],
                        match[1]
                      ];
              }), preds);
}

function string_of_name(name) {
  if (name) {
    return Names$ReactTemplate.Id[/* to_string */7](name[0]);
  } else {
    return "anonymous";
  }
}

function make_prime_id(name) {
  var str = string_of_name(name);
  return /* tuple */[
          Names$ReactTemplate.Id[/* of_string */5](str),
          Names$ReactTemplate.Id[/* of_string */5](str + "'")
        ];
}

function prime(avoid, name) {
  var match = make_prime_id(name);
  return /* tuple */[
          match[0],
          Namegen$ReactTemplate.next_ident_away(match[1], avoid)
        ];
}

function make_prime(avoid, prevname) {
  var match = prime(avoid[0], prevname);
  var id = match[1];
  avoid[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid[0]);
  return /* tuple */[
          match[0],
          id
        ];
}

function eq_id(avoid, id) {
  var hid = Names$ReactTemplate.Id[/* of_string */5]("Heq_" + Names$ReactTemplate.Id[/* to_string */7](id));
  return Namegen$ReactTemplate.next_ident_away(hid, avoid);
}

function mk_eq(evdref, typ, x, y) {
  return Program$ReactTemplate.papp(evdref, Program$ReactTemplate.coq_eq_ind, /* array */[
              typ,
              x,
              y
            ]);
}

function mk_eq_refl(evdref, typ, x) {
  return Program$ReactTemplate.papp(evdref, Program$ReactTemplate.coq_eq_refl, /* array */[
              typ,
              x
            ]);
}

function mk_JMeq(evdref, typ, x, typ$prime, y) {
  return Program$ReactTemplate.papp(evdref, Program$ReactTemplate.coq_JMeq_ind, /* array */[
              typ,
              x,
              typ$prime,
              y
            ]);
}

function mk_JMeq_refl(evdref, typ, x) {
  return Program$ReactTemplate.papp(evdref, Program$ReactTemplate.coq_JMeq_refl, /* array */[
              typ,
              x
            ]);
}

function hole(na) {
  var eta_000 = /* QuestionMark */Block.__(3, [
      /* Define */[/* false */0],
      na
    ]);
  var eta = /* GHole */Block.__(13, [
      eta_000,
      /* IntroAnonymous */0,
      /* None */0
    ]);
  return DAst$ReactTemplate.make(/* None */0, eta);
}

function constr_of_pat(env, evdref, arsign, pat, avoid) {
  var typ = function (env, param, pat, avoid) {
    var realargs = param[1];
    var ty = param[0];
    var loc = pat[/* loc */1];
    var match = DAst$ReactTemplate.get(pat);
    if (match.tag) {
      var alias = match[2];
      var args = match[1];
      var cstr = match[0];
      var cind = Names$ReactTemplate.inductive_of_constructor(cstr);
      var match$1;
      try {
        match$1 = Inductiveops$ReactTemplate.find_rectype(env, evdref[0], EConstr$ReactTemplate.Vars[/* lift */0](-Curry._1(Util$ReactTemplate.List[/* length */0], realargs) | 0, ty));
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          match$1 = Pretype_errors$ReactTemplate.error_case_not_inductive(/* None */0, env, evdref[0], /* record */[
                /* uj_val */ty,
                /* uj_type */Typing$ReactTemplate.unsafe_type_of(env, evdref[0], ty)
              ]);
        } else {
          throw exn;
        }
      }
      var indf = match$1[0];
      var match$2 = Inductiveops$ReactTemplate.dest_ind_family(indf);
      var ind = match$2[0][0];
      var params = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, match$2[1]);
      if (!Names$ReactTemplate.eq_ind(ind, cind)) {
        error_bad_constructor(loc, env, cstr, ind);
      }
      var cstrs = Inductiveops$ReactTemplate.get_constructors(env, indf);
      var ci = Caml_array.caml_array_get(cstrs, cstr[1] - 1 | 0);
      var nb_args_constr = ci[/* cs_nargs */2];
      if (nb_args_constr !== Curry._1(Util$ReactTemplate.List[/* length */0], args)) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "cases.ml",
                2131,
                1
              ]
            ];
      }
      var match$3 = Curry._4(Util$ReactTemplate.List[/* fold_right2 */19], (function (decl, ua, param) {
              var env = param[3];
              var sign = param[2];
              var args = param[1];
              var t = EConstr$ReactTemplate.of_constr(Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl));
              var liftt = EConstr$ReactTemplate.Vars[/* liftn */1](Curry._1(Util$ReactTemplate.List[/* length */0], sign), Curry._1(Util$ReactTemplate.List[/* length */0], args) + 1 | 0, t);
              var match = typ(env, /* tuple */[
                    EConstr$ReactTemplate.Vars[/* substl */3](args, liftt),
                    /* [] */0
                  ], ua, param[6]);
              var n$prime = match[5];
              var sign$prime = match[1];
              var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
              var args$prime_000 = match[2];
              var args$prime_001 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                      return partial_arg(n$prime, param);
                    }), args);
              var args$prime = /* :: */[
                args$prime_000,
                args$prime_001
              ];
              var env$prime = EConstr$ReactTemplate.push_rel_context(sign$prime, env);
              return /* tuple */[
                      /* :: */[
                        match[0],
                        param[0]
                      ],
                      args$prime,
                      Util$ReactTemplate.$at(sign$prime, sign),
                      env$prime,
                      n$prime + param[4] | 0,
                      param[5] + 1 | 0,
                      match[6]
                    ];
            }), ci[/* cs_args */3], Curry._1(Util$ReactTemplate.List[/* rev */4], args), /* tuple */[
            /* [] */0,
            /* [] */0,
            /* [] */0,
            env,
            0,
            0,
            avoid
          ]);
      var avoid$1 = match$3[6];
      var m = match$3[5];
      var n = match$3[4];
      var env$1 = match$3[3];
      var sign = match$3[2];
      var args$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], match$3[1]);
      var patargs = Curry._1(Util$ReactTemplate.List[/* rev */4], match$3[0]);
      var pat$prime = DAst$ReactTemplate.make(loc, /* PatCstr */Block.__(1, [
              cstr,
              patargs,
              alias
            ]));
      var cstr$1 = EConstr$ReactTemplate.mkConstructU(Util$ReactTemplate.on_snd(EConstr$ReactTemplate.EInstance[/* make */0], ci[/* cs_cstr */0]));
      var partial_arg = Curry._1(Util$ReactTemplate.List[/* length */0], sign);
      var partial_arg$1 = EConstr$ReactTemplate.Vars[/* lift */0];
      var app = EConstr$ReactTemplate.applist(/* tuple */[
            cstr$1,
            Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return partial_arg$1(partial_arg, param);
                  }), params)
          ]);
      var app$1 = EConstr$ReactTemplate.applist(/* tuple */[
            app,
            args$1
          ]);
      var apptype = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env$1, evdref[0], app$1);
      var match$4 = Inductiveops$ReactTemplate.find_rectype(env$1, evdref[0], apptype);
      var realargs$1 = match$4[1];
      if (alias) {
        var id = alias[0];
        var sign_000 = /* LocalAssum */Block.__(0, [
            alias,
            EConstr$ReactTemplate.Vars[/* lift */0](m, ty)
          ]);
        var sign$1 = /* :: */[
          sign_000,
          sign
        ];
        var avoid$2 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, avoid$1);
        var match$5;
        try {
          var env$2 = EConstr$ReactTemplate.push_rel_context(sign$1, env$1);
          evdref[0] = Evarconv$ReactTemplate.the_conv_x_leq(EConstr$ReactTemplate.push_rel_context(sign$1, env$2), /* None */0, EConstr$ReactTemplate.Vars[/* lift */0](m + 1 | 0, ty), EConstr$ReactTemplate.Vars[/* lift */0](1, apptype), evdref[0]);
          var eq_t = mk_eq(evdref, EConstr$ReactTemplate.Vars[/* lift */0](m + 1 | 0, ty), EConstr$ReactTemplate.mkRel(1), EConstr$ReactTemplate.Vars[/* lift */0](1, app$1));
          var neq = eq_id(avoid$2, id);
          match$5 = /* tuple */[
            /* :: */[
              /* LocalDef */Block.__(1, [
                  /* Name */[neq],
                  EConstr$ReactTemplate.mkRel(0),
                  eq_t
                ]),
              sign$1
            ],
            2,
            Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], neq, avoid$2)
          ];
        }
        catch (exn$1){
          if (exn$1 === Reduction$ReactTemplate.NotConvertible) {
            match$5 = /* tuple */[
              sign$1,
              1,
              avoid$2
            ];
          } else {
            throw exn$1;
          }
        }
        var i = match$5[1];
        return /* tuple */[
                pat$prime,
                match$5[0],
                EConstr$ReactTemplate.Vars[/* lift */0](i, app$1),
                EConstr$ReactTemplate.Vars[/* lift */0](i, apptype),
                realargs$1,
                n + i | 0,
                match$5[2]
              ];
      } else {
        return /* tuple */[
                pat$prime,
                sign,
                app$1,
                apptype,
                realargs$1,
                n,
                avoid$1
              ];
      }
    } else {
      var name = match[0];
      var match$6;
      if (name) {
        match$6 = /* tuple */[
          name,
          avoid
        ];
      } else {
        var match$7 = prime(avoid, /* Name */[Names$ReactTemplate.Id[/* of_string */5]("wildcard")]);
        var id$1 = match$7[1];
        match$6 = /* tuple */[
          /* Name */[id$1],
          Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id$1, avoid)
        ];
      }
      var name$1 = match$6[0];
      return /* tuple */[
              DAst$ReactTemplate.make(loc, /* PatVar */Block.__(0, [name$1])),
              Util$ReactTemplate.$at(/* :: */[
                    /* LocalAssum */Block.__(0, [
                        name$1,
                        ty
                      ]),
                    /* [] */0
                  ], realargs),
              EConstr$ReactTemplate.mkRel(1),
              ty,
              Curry._2(Util$ReactTemplate.List[/* map */10], (function () {
                      return EConstr$ReactTemplate.mkRel(1);
                    }), realargs),
              1,
              match$6[1]
            ];
    }
  };
  var match = typ(env, /* tuple */[
        Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], Curry._1(Util$ReactTemplate.List[/* hd */1], arsign)),
        Curry._1(Util$ReactTemplate.List[/* tl */2], arsign)
      ], pat, avoid);
  var pat$prime = match[0];
  return /* tuple */[
          pat$prime,
          /* tuple */[
            match[1],
            match[2],
            /* tuple */[
              Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], Curry._1(Util$ReactTemplate.List[/* hd */1], arsign)),
              match[4]
            ],
            pat$prime
          ],
          match[6]
        ];
}

function eq_id$1(avoid, id) {
  var hid = Names$ReactTemplate.Id[/* of_string */5]("Heq_" + Names$ReactTemplate.Id[/* to_string */7](id));
  var hid$prime = Namegen$ReactTemplate.next_ident_away(hid, avoid[0]);
  avoid[0] = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], hid$prime, avoid[0]);
  return hid$prime;
}

function is_topvar(sigma, t) {
  var match = EConstr$ReactTemplate.kind(sigma, t);
  if (!match.tag && match[0] === 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function rels_of_patsign(sigma) {
  return Curry._1(Util$ReactTemplate.List[/* map */10], (function (decl) {
                if (!decl.tag || !is_topvar(sigma, decl[1])) {
                  return decl;
                } else {
                  return /* LocalAssum */Block.__(0, [
                            decl[0],
                            decl[2]
                          ]);
                }
              }));
}

function vars_of_ctx(sigma, ctx) {
  var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, param) {
          var vars = param[1];
          var prev = param[0];
          var exit = 0;
          if (decl.tag) {
            if (is_topvar(sigma, decl[1])) {
              var eta_000 = Util$ReactTemplate.delayed_force(Program$ReactTemplate.coq_eq_refl_ref);
              var eta = /* GRef */Block.__(0, [
                  eta_000,
                  /* None */0
                ]);
              var eta$1 = /* GVar */Block.__(1, [prev]);
              var eta_000$1 = DAst$ReactTemplate.make(/* None */0, eta);
              var eta_001 = /* :: */[
                hole(decl[0]),
                /* :: */[
                  DAst$ReactTemplate.make(/* None */0, eta$1),
                  /* [] */0
                ]
              ];
              var eta$2 = /* GApp */Block.__(4, [
                  eta_000$1,
                  eta_001
                ]);
              return /* tuple */[
                      prev,
                      /* :: */[
                        DAst$ReactTemplate.make(/* None */0, eta$2),
                        vars
                      ]
                    ];
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
            if (match) {
              var n = match[0];
              var eta$3 = /* GVar */Block.__(1, [n]);
              return /* tuple */[
                      n,
                      /* :: */[
                        DAst$ReactTemplate.make(/* None */0, eta$3),
                        vars
                      ]
                    ];
            } else {
              return CErrors$ReactTemplate.invalid_arg(/* None */0, "vars_of_ctx");
            }
          }
          
        }), ctx, /* tuple */[
        Names$ReactTemplate.Id[/* of_string */5]("vars_of_ctx_error"),
        /* [] */0
      ]);
  return Curry._1(Util$ReactTemplate.List[/* rev */4], match[1]);
}

function is_included(x, y) {
  var match = DAst$ReactTemplate.get(x);
  var match$1 = DAst$ReactTemplate.get(y);
  if (!match.tag || !match$1.tag) {
    return /* true */1;
  } else if (match[0][1] === match$1[0][1]) {
    return Curry._3(Util$ReactTemplate.List[/* for_all2 */22], is_included, match[1], match$1[1]);
  } else {
    return /* false */0;
  }
}

function lift_rel_context(n, l) {
  var partial_arg = EConstr$ReactTemplate.Vars[/* liftn */1];
  return Termops$ReactTemplate.map_rel_context_with_binders((function (param, param$1) {
                return partial_arg(n, param, param$1);
              }), l);
}

function build_ineqs(evdref, prevpatterns, pats, liftsign) {
  Curry._1(Util$ReactTemplate.List[/* length */0], pats);
  var diffs = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (c, eqnpats) {
          var acc = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (acc, param, param$1) {
                  if (acc) {
                    var match = acc[0];
                    var len = match[1];
                    var ppat_sign = param[0];
                    if (is_included(param$1[3], param[3])) {
                      var lens = Curry._1(Util$ReactTemplate.List[/* length */0], ppat_sign);
                      var len$prime = lens + len | 0;
                      var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
                      var acc_000 = Util$ReactTemplate.$at(lift_rel_context(len, ppat_sign), match[0]);
                      var acc_002 = match[2] + 1 | 0;
                      var acc_003 = /* :: */[
                        Program$ReactTemplate.papp(evdref, Program$ReactTemplate.coq_eq_ind, /* array */[
                              EConstr$ReactTemplate.Vars[/* lift */0](len$prime + liftsign | 0, param$1[2][0]),
                              EConstr$ReactTemplate.Vars[/* liftn */1](len + liftsign | 0, lens + 1 | 0, param[1]),
                              EConstr$ReactTemplate.Vars[/* lift */0](len$prime, param$1[1])
                            ]),
                        Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                return partial_arg(lens, param);
                              }), match[3])
                      ];
                      var acc$1 = /* tuple */[
                        acc_000,
                        len$prime,
                        acc_002,
                        acc_003
                      ];
                      return /* Some */[acc$1];
                    } else {
                      return /* None */0;
                    }
                  } else {
                    return /* None */0;
                  }
                }), /* Some */[/* tuple */[
                  /* [] */0,
                  0,
                  0,
                  /* [] */0
                ]], eqnpats, pats);
          if (acc) {
            var match = acc[0];
            var match$1 = Program$ReactTemplate.mk_coq_and(evdref[0], match[3]);
            var match$2 = Program$ReactTemplate.mk_coq_not(match$1[0], match$1[1]);
            var conj = EConstr$ReactTemplate.it_mkProd_or_LetIn(match$2[1], lift_rel_context(liftsign, match[0]));
            evdref[0] = match$2[0];
            return /* :: */[
                    conj,
                    c
                  ];
          } else {
            return c;
          }
        }), /* [] */0, prevpatterns);
  if (diffs) {
    var match = Program$ReactTemplate.mk_coq_and(evdref[0], diffs);
    return /* Some */[(evdref[0] = match[0], match[1])];
  } else {
    return /* None */0;
  }
}

function constrs_of_pats(typing_fun, env, evdref, eqns, _, sign, neqs, arity) {
  var i = [0];
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, eqn) {
          var prevpatterns = param[2];
          var match = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, pat, arsign) {
                  var match = constr_of_pat(env, evdref, arsign, pat, param[0]);
                  return /* tuple */[
                          match[2],
                          /* :: */[
                            match[0],
                            param[1]
                          ],
                          /* :: */[
                            match[1],
                            param[2]
                          ]
                        ];
                }), /* tuple */[
                Names$ReactTemplate.Id[/* Set */9][/* empty */0],
                /* [] */0,
                /* [] */0
              ], eqn[/* patterns */0], sign);
          var newpatterns = Curry._1(Util$ReactTemplate.List[/* rev */4], match[1]);
          var opats = Curry._1(Util$ReactTemplate.List[/* rev */4], match[2]);
          var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                  var match = param$1[2];
                  var n = param[2];
                  var sign$prime = lift_rel_context(n, param$1[0]);
                  var len = Curry._1(Util$ReactTemplate.List[/* length */0], sign$prime);
                  var partial_arg = len + 1 | 0;
                  var partial_arg$1 = EConstr$ReactTemplate.Vars[/* liftn */1];
                  return /* tuple */[
                          Util$ReactTemplate.$at(sign$prime, param[0]),
                          /* :: */[
                            /* tuple */[
                              sign$prime,
                              EConstr$ReactTemplate.Vars[/* liftn */1](n, len + 1 | 0, param$1[1]),
                              /* tuple */[
                                match[0],
                                Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                        return partial_arg$1(n, partial_arg, param);
                                      }), match[1])
                              ],
                              param$1[3]
                            ],
                            param[1]
                          ],
                          len + n | 0
                        ];
                }), /* tuple */[
                /* [] */0,
                /* [] */0,
                0
              ], opats);
          var signlen = match$1[2];
          var rhs_rels = match$1[0];
          var match$2 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                  var match = param$1[2];
                  var sign = param$1[0];
                  var n = param[1];
                  var len = Curry._1(Util$ReactTemplate.List[/* length */0], sign);
                  var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
                  return /* tuple */[
                          /* :: */[
                            /* tuple */[
                              Curry._1(rels_of_patsign(evdref[0]), sign),
                              EConstr$ReactTemplate.Vars[/* lift */0](n, param$1[1]),
                              /* tuple */[
                                match[0],
                                Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                        return partial_arg(n, param);
                                      }), match[1])
                              ],
                              param$1[3]
                            ],
                            param[0]
                          ],
                          len + n | 0
                        ];
                }), /* tuple */[
                /* [] */0,
                0
              ], match$1[1]);
          var pats = match$2[0];
          var ineqs = build_ineqs(evdref, prevpatterns, pats, signlen);
          var rhs_rels$prime = Curry._1(rels_of_patsign(evdref[0]), rhs_rels);
          EConstr$ReactTemplate.push_rel_context(rhs_rels$prime, env);
          var match$3 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                  var args = param[2][1];
                  return /* tuple */[
                          Util$ReactTemplate.$at(args, /* :: */[
                                param[1],
                                param$1[0]
                              ]),
                          Curry._1(Util$ReactTemplate.List[/* length */0], args) + (param$1[1] + 1 | 0) | 0
                        ];
                }), pats, /* tuple */[
                /* [] */0,
                0
              ]);
          var args = Curry._1(Util$ReactTemplate.List[/* rev */4], match$3[0]);
          var arity$1 = EConstr$ReactTemplate.Vars[/* substl */3](args, EConstr$ReactTemplate.Vars[/* liftn */1](signlen, match$3[1] + 1 | 0, arity));
          var match$4 = ineqs ? /* tuple */[
              /* :: */[
                /* LocalAssum */Block.__(0, [
                    /* Anonymous */0,
                    ineqs[0]
                  ]),
                /* [] */0
              ],
              EConstr$ReactTemplate.Vars[/* lift */0](1, arity$1)
            ] : /* tuple */[
              /* [] */0,
              arity$1
            ];
          var match$5 = EConstr$ReactTemplate.decompose_prod_n_assum(evdref[0], neqs, match$4[1]);
          var arity$2 = match$5[1];
          var match_000 = Util$ReactTemplate.$at(match$5[0], Util$ReactTemplate.$at(match$4[0], rhs_rels$prime));
          var rhs_rels$prime$1 = match_000;
          var rhs_env = EConstr$ReactTemplate.push_rel_context(rhs_rels$prime$1, env);
          var j = Curry._3(typing_fun, Evardefine$ReactTemplate.mk_tycon(arity$2), rhs_env, eqn[/* rhs */1][/* it */3]);
          var bbody = EConstr$ReactTemplate.it_mkLambda_or_LetIn(j[/* uj_val */0], rhs_rels$prime$1);
          var btype = EConstr$ReactTemplate.it_mkProd_or_LetIn(j[/* uj_type */1], rhs_rels$prime$1);
          Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                  return Typing$ReactTemplate.type_of(/* None */0, env, param, param$1);
                }), evdref, bbody);
          var branch_name = Names$ReactTemplate.Id[/* of_string */5]("program_branch_" + Pervasives.string_of_int(i[0]));
          var branch_decl_000 = /* Name */[branch_name];
          var branch_decl_001 = EConstr$ReactTemplate.Vars[/* lift */0](i[0], bbody);
          var branch_decl_002 = EConstr$ReactTemplate.Vars[/* lift */0](i[0], btype);
          var branch_decl = /* LocalDef */Block.__(1, [
              branch_decl_000,
              branch_decl_001,
              branch_decl_002
            ]);
          var eta = /* GVar */Block.__(1, [branch_name]);
          var bref = DAst$ReactTemplate.make(/* None */0, eta);
          var l = vars_of_ctx(evdref[0], rhs_rels);
          var branch;
          if (l) {
            var eta$1 = /* GApp */Block.__(4, [
                bref,
                l
              ]);
            branch = DAst$ReactTemplate.make(/* None */0, eta$1);
          } else {
            branch = bref;
          }
          var branch$1;
          if (ineqs) {
            var eta_001 = /* :: */[
              hole(/* Anonymous */0),
              /* [] */0
            ];
            var eta$2 = /* GApp */Block.__(4, [
                branch,
                eta_001
              ]);
            branch$1 = DAst$ReactTemplate.make(/* None */0, eta$2);
          } else {
            branch$1 = branch;
          }
          i[0] = i[0] + 1 | 0;
          var init = eqn[/* rhs */1];
          var rhs_000 = /* rhs_env */init[/* rhs_env */0];
          var rhs_001 = /* rhs_vars */init[/* rhs_vars */1];
          var rhs_002 = /* avoid_ids */init[/* avoid_ids */2];
          var rhs_003 = /* it : Some */[branch$1];
          var rhs = /* record */[
            rhs_000,
            rhs_001,
            rhs_002,
            rhs_003
          ];
          return /* tuple */[
                  /* :: */[
                    branch_decl,
                    param[0]
                  ],
                  /* :: */[
                    /* record */[
                      /* patterns */newpatterns,
                      /* rhs */rhs,
                      /* alias_stack */eqn[/* alias_stack */2],
                      /* eqn_loc */eqn[/* eqn_loc */3],
                      /* used */eqn[/* used */4]
                    ],
                    param[1]
                  ],
                  /* :: */[
                    opats,
                    prevpatterns
                  ]
                ];
        }), /* tuple */[
        /* [] */0,
        /* [] */0,
        /* [] */0
      ], eqns);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function lift_ctx(n, ctx) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                  var n$prime = param$1[1];
                  return /* tuple */[
                          /* :: */[
                            /* tuple */[
                              EConstr$ReactTemplate.Vars[/* liftn */1](n, n$prime, param[0]),
                              liftn_tomatch_type(n, n$prime)(param[1])
                            ],
                            param$1[0]
                          ],
                          n$prime + 1 | 0
                        ];
                }), ctx, /* tuple */[
                /* [] */0,
                0
              ])[0];
}

function abstract_tomatch(_, sigma, tomatchs, tycon) {
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
          var t = param$1[1];
          var c = param$1[0];
          var tycon = param[3];
          var names = param[2];
          var ctx = param[1];
          var prev = param[0];
          var lenctx = Curry._1(Util$ReactTemplate.List[/* length */0], ctx);
          var match = EConstr$ReactTemplate.kind(sigma, c);
          if (match.tag) {
            var tycon$1 = Option$ReactTemplate.map((function (t) {
                    return Termops$ReactTemplate.subst_term(sigma, EConstr$ReactTemplate.Vars[/* lift */0](1, c), EConstr$ReactTemplate.Vars[/* lift */0](1, t));
                  }), tycon);
            var name = Namegen$ReactTemplate.next_ident_away(Names$ReactTemplate.Id[/* of_string */5]("filtered_var"), names);
            var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
            return /* tuple */[
                    /* :: */[
                      /* tuple */[
                        EConstr$ReactTemplate.mkRel(1),
                        liftn_tomatch_type(lenctx + 1 | 0, 1)(t)
                      ],
                      lift_ctx(1, prev)
                    ],
                    /* :: */[
                      /* LocalDef */Block.__(1, [
                          /* Name */[name],
                          EConstr$ReactTemplate.Vars[/* lift */0](lenctx, c),
                          (function (param) {
                                return partial_arg(lenctx, param);
                              })(type_of_tomatch(t))
                        ]),
                      ctx
                    ],
                    Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], name, names),
                    tycon$1
                  ];
          } else {
            return /* tuple */[
                    /* :: */[
                      /* tuple */[
                        EConstr$ReactTemplate.Vars[/* lift */0](lenctx, c),
                        liftn_tomatch_type(lenctx, 1)(t)
                      ],
                      prev
                    ],
                    ctx,
                    names,
                    tycon
                  ];
          }
        }), /* tuple */[
        /* [] */0,
        /* [] */0,
        Names$ReactTemplate.Id[/* Set */9][/* empty */0],
        tycon
      ], tomatchs);
  return /* tuple */[
          Curry._1(Util$ReactTemplate.List[/* rev */4], match[0]),
          match[1],
          match[3]
        ];
}

function build_dependent_signature(env, evdref, avoid, tomatchs, arsign) {
  var avoid$1 = [avoid];
  var arsign$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], arsign);
  var allnames = Curry._2(Util$ReactTemplate.List[/* rev_map */12], Curry._1(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0]), arsign$1);
  var nar = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (n, names) {
          return Curry._1(Util$ReactTemplate.List[/* length */0], names) + n | 0;
        }), 0, allnames);
  var match = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, param$1, arsign) {
          var ty = param$1[1];
          var tm = param$1[0];
          var arsigns = param[4];
          var slift = param[3];
          var neqs = param[1];
          var eqs = param[0];
          var exit = 0;
          if (ty.tag) {
            exit = 1;
          } else {
            var args = ty[1][1];
            var ty$1 = ty[0];
            if (Curry._1(Util$ReactTemplate.List[/* length */0], args) > 0) {
              var argsign = Curry._1(Util$ReactTemplate.List[/* tl */2], arsign);
              var app_decl = Curry._1(Util$ReactTemplate.List[/* hd */1], arsign);
              var appn = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], app_decl);
              var appt = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], app_decl);
              var argsign$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], argsign);
              var match = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, arg, decl) {
                      var slift = param[4];
                      var nargeqs = param[1];
                      var env = param[0];
                      var name = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
                      var t = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl);
                      var argt = Retyping$ReactTemplate.get_type_of(/* None */0, /* None */0, env, evdref[0], arg);
                      var match = Reductionops$ReactTemplate.is_conv(/* None */0, env, evdref[0])(argt, t) ? /* tuple */[
                          mk_eq(evdref, EConstr$ReactTemplate.Vars[/* lift */0](nargeqs + slift | 0, argt), EConstr$ReactTemplate.mkRel(nargeqs + slift | 0), EConstr$ReactTemplate.Vars[/* lift */0](nargeqs + nar | 0, arg)),
                          mk_eq_refl(evdref, argt, arg)
                        ] : /* tuple */[
                          mk_JMeq(evdref, EConstr$ReactTemplate.Vars[/* lift */0](nargeqs + slift | 0, t), EConstr$ReactTemplate.mkRel(nargeqs + slift | 0), EConstr$ReactTemplate.Vars[/* lift */0](nargeqs + nar | 0, argt), EConstr$ReactTemplate.Vars[/* lift */0](nargeqs + nar | 0, arg)),
                          mk_JMeq_refl(evdref, argt, arg)
                        ];
                      var match$1 = EConstr$ReactTemplate.kind(evdref[0], arg);
                      var name$1;
                      name$1 = match$1.tag ? name : Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], EConstr$ReactTemplate.lookup_rel(match$1[0], env));
                      var match$2 = make_prime(avoid$1, name$1);
                      return /* tuple */[
                              env,
                              nargeqs + 1 | 0,
                              /* :: */[
                                /* LocalAssum */Block.__(0, [
                                    /* Name */[eq_id$1(avoid$1, match$2[0])],
                                    match[0]
                                  ]),
                                param[2]
                              ],
                              /* :: */[
                                match[1],
                                param[3]
                              ],
                              slift - 1 | 0,
                              /* :: */[
                                Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], /* Name */[match$2[1]], decl),
                                param[5]
                              ]
                            ];
                    }), /* tuple */[
                    env,
                    neqs,
                    /* [] */0,
                    /* [] */0,
                    slift,
                    /* [] */0
                  ], args, argsign$1);
              var slift$1 = match[4];
              var nargeqs = match[1];
              var eq = mk_JMeq(evdref, EConstr$ReactTemplate.Vars[/* lift */0](nargeqs + slift$1 | 0, appt), EConstr$ReactTemplate.mkRel(nargeqs + slift$1 | 0), EConstr$ReactTemplate.Vars[/* lift */0](nargeqs + nar | 0, ty$1), EConstr$ReactTemplate.Vars[/* lift */0](nargeqs + nar | 0, tm));
              var refl_eq = mk_JMeq_refl(evdref, ty$1, tm);
              var match$1 = make_prime(avoid$1, appn);
              return /* tuple */[
                      /* :: */[
                        /* :: */[
                          /* LocalAssum */Block.__(0, [
                              /* Name */[eq_id$1(avoid$1, match$1[0])],
                              eq
                            ]),
                          match[2]
                        ],
                        eqs
                      ],
                      nargeqs + 1 | 0,
                      /* :: */[
                        refl_eq,
                        match[3]
                      ],
                      slift$1 - 1 | 0,
                      /* :: */[
                        /* :: */[
                          Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], /* Name */[match$1[1]], app_decl),
                          match[5]
                        ],
                        arsigns
                      ]
                    ];
            } else {
              exit = 1;
            }
          }
          if (exit === 1) {
            var decl;
            if (arsign) {
              if (arsign[1]) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "cases.ml",
                        2456,
                        51
                      ]
                    ];
              } else {
                decl = arsign[0];
              }
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "cases.ml",
                      2456,
                      51
                    ]
                  ];
            }
            var name = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
            var match$2 = make_prime(avoid$1, name);
            var arsign$prime = Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* set_name */3], /* Name */[match$2[1]], decl);
            var tomatch_ty = type_of_tomatch(ty);
            var eq$1 = mk_eq(evdref, EConstr$ReactTemplate.Vars[/* lift */0](nar, tomatch_ty), EConstr$ReactTemplate.mkRel(slift), EConstr$ReactTemplate.Vars[/* lift */0](nar, tm));
            return /* tuple */[
                    /* :: */[
                      /* :: */[
                        /* LocalAssum */Block.__(0, [
                            /* Name */[eq_id$1(avoid$1, match$2[0])],
                            eq$1
                          ]),
                        /* [] */0
                      ],
                      eqs
                    ],
                    neqs + 1 | 0,
                    /* :: */[
                      mk_eq_refl(evdref, tomatch_ty, tm),
                      param[2]
                    ],
                    slift - 1 | 0,
                    /* :: */[
                      /* :: */[
                        arsign$prime,
                        /* [] */0
                      ],
                      arsigns
                    ]
                  ];
          }
          
        }), /* tuple */[
        /* [] */0,
        0,
        /* [] */0,
        nar,
        /* [] */0
      ], tomatchs, arsign$1);
  var arsign$prime$prime = Curry._1(Util$ReactTemplate.List[/* rev */4], match[4]);
  if (match[3] !== 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "cases.ml",
            2471,
            4
          ]
        ];
  }
  return /* tuple */[
          arsign$prime$prime,
          allnames,
          nar,
          match[0],
          match[1],
          match[2]
        ];
}

function context_of_arsign(l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (c, param) {
                  var n = param[1];
                  return /* tuple */[
                          Util$ReactTemplate.$at(lift_rel_context(n, c), param[0]),
                          Curry._1(Util$ReactTemplate.List[/* length */0], c) + n | 0
                        ];
                }), l, /* tuple */[
                /* [] */0,
                0
              ])[0];
}

function compile_cases(loc, style, param, tycon, env, lvar, param$1) {
  var eqns = param$1[2];
  var tomatchl = param$1[1];
  var predopt = param$1[0];
  var evdref = param[1];
  var typing_fun = param[0];
  if (predopt === /* None */0 && Flags$ReactTemplate.is_program_mode(/* () */0) && Program$ReactTemplate.is_program_cases(/* () */0)) {
    var loc$1 = loc;
    var style$1 = style;
    var param$2 = /* tuple */[
      typing_fun,
      evdref
    ];
    var tycon$1 = tycon;
    var env$1 = env;
    var lvar$1 = lvar;
    var param$3 = /* tuple */[
      predopt,
      tomatchl,
      eqns
    ];
    var eqns$1 = param$3[2];
    var tomatchl$1 = param$3[1];
    var evdref$1 = param$2[1];
    var typing_function = param$2[0];
    var typing_fun$1 = function (tycon, env, param) {
      if (param) {
        return Curry._5(typing_function, tycon, env, evdref$1, lvar$1, param[0]);
      } else {
        return Evarutil$ReactTemplate.evd_comb0(use_unit_judge, evdref$1);
      }
    };
    var matx = matx_of_eqns(env$1, eqns$1);
    var match = coerce_to_indtype(typing_function, evdref$1, env$1, lvar$1, matx, tomatchl$1);
    var tycon$2 = Evardefine$ReactTemplate.valcon_of_tycon(tycon$1);
    var match$1 = abstract_tomatch(env$1, evdref$1[0], match[1], tycon$2);
    var tycon$prime = match$1[2];
    var tomatchs_lets = match$1[1];
    var tomatchs = match$1[0];
    var env$2 = EConstr$ReactTemplate.push_rel_context(tomatchs_lets, env$1);
    var len = Curry._1(Util$ReactTemplate.List[/* length */0], eqns$1);
    var arsign = extract_arity_signature(/* Some */[/* false */0], env$2, match[0], tomatchs, tomatchl$1);
    var arsign$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
            return prim[0];
          }), arsign);
    var avoid = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
    var match$2 = build_dependent_signature(env$2, evdref$1, avoid, tomatchs, arsign$1);
    var sign = match$2[0];
    var nar = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (n, sign) {
            return Curry._1(Util$ReactTemplate.List[/* length */0], sign) + n | 0;
          }), 0, sign);
    var match$3;
    if (tycon$prime) {
      var t = tycon$prime[0];
      var match$4 = prepare_predicate_from_arsign_tycon(env$2, evdref$1[0], loc$1, tomatchs, sign, t);
      var pred;
      if (match$4) {
        var match$5 = match$4[0];
        evdref$1[0] = match$5[0];
        pred = match$5[1];
      } else {
        pred = EConstr$ReactTemplate.Vars[/* lift */0](nar, t);
      }
      match$3 = /* tuple */[
        Option$ReactTemplate.get(tycon$2),
        pred
      ];
    } else {
      var ev = mkExistential(env$2, /* None */0, evdref$1);
      match$3 = /* tuple */[
        ev,
        EConstr$ReactTemplate.Vars[/* lift */0](nar, ev)
      ];
    }
    var ctx = context_of_arsign(match$2[3]);
    var neqs = Curry._1(Util$ReactTemplate.List[/* length */0], ctx);
    var match_001 = EConstr$ReactTemplate.it_mkProd_or_LetIn(EConstr$ReactTemplate.Vars[/* lift */0](neqs, match$3[1]), ctx);
    var arity = match_001;
    var match$6 = constrs_of_pats(typing_fun$1, env$2, evdref$1, matx, tomatchs, sign, neqs, arity);
    var lets = match$6[0];
    var matx$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], match$6[1]);
    if (len !== Curry._1(Util$ReactTemplate.List[/* length */0], lets)) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "cases.ml",
              2529,
              10
            ]
          ];
    }
    var env$3 = EConstr$ReactTemplate.push_rel_context(lets, env$2);
    var matx$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (eqn) {
            var init = eqn[/* rhs */1];
            return /* record */[
                    /* patterns */eqn[/* patterns */0],
                    /* rhs : record */[
                      /* rhs_env */env$3,
                      /* rhs_vars */init[/* rhs_vars */1],
                      /* avoid_ids */init[/* avoid_ids */2],
                      /* it */init[/* it */3]
                    ],
                    /* alias_stack */eqn[/* alias_stack */2],
                    /* eqn_loc */eqn[/* eqn_loc */3],
                    /* used */eqn[/* used */4]
                  ];
          }), matx$1);
    var tomatchs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            return /* tuple */[
                    EConstr$ReactTemplate.Vars[/* lift */0](len, param[0]),
                    liftn_tomatch_type(len, 1)(param[1])
                  ];
          }), tomatchs);
    var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
    var args = Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (param) {
            return partial_arg(len, param);
          }), match$2[5]);
    var pred$1 = EConstr$ReactTemplate.Vars[/* liftn */1](len, match$2[2] + 1 | 0, arity);
    var match$7 = build_initial_predicate(sign, pred$1);
    var nal = match$7[0];
    var out_tmt = function (na, param) {
      if (param.tag) {
        var match = param[0];
        if (match) {
          return /* LocalDef */Block.__(1, [
                    na,
                    match[0],
                    param[1]
                  ]);
        } else {
          return /* LocalAssum */Block.__(0, [
                    na,
                    param[1]
                  ]);
        }
      } else {
        return /* LocalAssum */Block.__(0, [
                  na,
                  param[0]
                ]);
      }
    };
    var typs = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (na, param) {
            return /* tuple */[
                    param[0],
                    out_tmt(na, param[1])
                  ];
          }), nal, tomatchs$1);
    var typs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            var d = param[1];
            return /* tuple */[
                    param[0],
                    extract_inductive_data(env$3, evdref$1[0], d),
                    d
                  ];
          }), typs);
    var dep_sign = find_dependencies_signature(evdref$1[0], Curry._2(Util$ReactTemplate.List[/* make */56], Curry._1(Util$ReactTemplate.List[/* length */0], typs$1), /* true */1), typs$1);
    var typs$prime = Curry._4(Util$ReactTemplate.List[/* map3 */69], (function (param, deps, na) {
            var tm = param[0];
            var deps$1 = EConstr$ReactTemplate.isRel(evdref$1[0], tm) ? deps : /* [] */0;
            return /* tuple */[
                    /* tuple */[
                      tm,
                      param[1]
                    ],
                    deps$1,
                    na
                  ];
          }), tomatchs$1, dep_sign, nal);
    var initial_pushed = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
            return /* Pushed */Block.__(0, [/* tuple */[
                        /* true */1,
                        x
                      ]]);
          }), typs$prime);
    var typing_function$1 = function (tycon, env, evdref, param) {
      if (param) {
        return Curry._5(typing_function, tycon, env, evdref, lvar$1, param[0]);
      } else {
        return Evarutil$ReactTemplate.evd_comb0(use_unit_judge, evdref);
      }
    };
    var pb_003 = /* pred */match$7[1];
    var pb_005 = /* history : Continuation */Block.__(0, [
        Curry._1(Util$ReactTemplate.List[/* length */0], initial_pushed),
        /* [] */0,
        /* Top */0
      ]);
    var pb = /* record */[
      /* env */env$3,
      /* lvar */lvar$1,
      /* evdref */evdref$1,
      pb_003,
      /* tomatch */initial_pushed,
      pb_005,
      /* mat */matx$2,
      /* caseloc */loc$1,
      /* casestyle */style$1,
      /* typing_function */typing_function$1
    ];
    var j = compile(pb);
    Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
            return check_unused_pattern(env$3, param);
          }), matx$2);
    var body = EConstr$ReactTemplate.it_mkLambda_or_LetIn(EConstr$ReactTemplate.applist(/* tuple */[
              j[/* uj_val */0],
              args
            ]), lets);
    return /* record */[
            /* uj_val */EConstr$ReactTemplate.it_mkLambda_or_LetIn(body, tomatchs_lets),
            /* uj_type */EConstr$ReactTemplate.of_constr(EConstr$ReactTemplate.to_constr(evdref$1[0], match$3[0]))
          ];
  } else {
    var matx$3 = matx_of_eqns(env, eqns);
    var match$8 = coerce_to_indtype(typing_fun, evdref, env, lvar, matx$3, tomatchl);
    var tomatchs$2 = match$8[1];
    var predlvar = match$8[0];
    var arsign$2 = extract_arity_signature(/* None */0, env, predlvar, tomatchs$2, tomatchl);
    var preds = prepare_predicate(loc, typing_fun, env, evdref[0], predlvar, tomatchs$2, arsign$2, tycon, predopt);
    var compile_for_one_predicate = function (param) {
      var nal = param[1];
      var sigma = param[0];
      var out_tmt = function (na, param) {
        if (param.tag) {
          var match = param[0];
          if (match) {
            return /* LocalDef */Block.__(1, [
                      na,
                      match[0],
                      param[1]
                    ]);
          } else {
            return /* LocalAssum */Block.__(0, [
                      na,
                      param[1]
                    ]);
          }
        } else {
          return /* LocalAssum */Block.__(0, [
                    na,
                    param[0]
                  ]);
        }
      };
      var typs = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (na, param) {
              return /* tuple */[
                      param[0],
                      out_tmt(na, param[1])
                    ];
            }), nal, tomatchs$2);
      var typs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
              var d = param[1];
              return /* tuple */[
                      param[0],
                      extract_inductive_data(env, sigma, d),
                      d
                    ];
            }), typs);
      var dep_sign = find_dependencies_signature(evdref[0], Curry._2(Util$ReactTemplate.List[/* make */56], Curry._1(Util$ReactTemplate.List[/* length */0], typs$1), /* true */1), typs$1);
      var typs$prime = Curry._4(Util$ReactTemplate.List[/* map3 */69], (function (param, deps, na) {
              var tm = param[0];
              var deps$1 = EConstr$ReactTemplate.isRel(evdref[0], tm) ? deps : /* [] */0;
              return /* tuple */[
                      /* tuple */[
                        tm,
                        param[1]
                      ],
                      deps$1,
                      na
                    ];
            }), tomatchs$2, dep_sign, nal);
      var initial_pushed = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
              return /* Pushed */Block.__(0, [/* tuple */[
                          /* true */1,
                          x
                        ]]);
            }), typs$prime);
      var typing_fun$2 = function (tycon, env, evdref, param) {
        if (param) {
          return Curry._5(typing_fun, tycon, env, evdref, lvar, param[0]);
        } else {
          return Evarutil$ReactTemplate.evd_comb0(use_unit_judge, evdref);
        }
      };
      var myevdref = [sigma];
      var pb_003 = /* pred */param[2];
      var pb_005 = /* history : Continuation */Block.__(0, [
          Curry._1(Util$ReactTemplate.List[/* length */0], initial_pushed),
          /* [] */0,
          /* Top */0
        ]);
      var pb = /* record */[
        /* env */env,
        /* lvar */lvar,
        /* evdref */myevdref,
        pb_003,
        /* tomatch */initial_pushed,
        pb_005,
        /* mat */matx$3,
        /* caseloc */loc,
        /* casestyle */style,
        /* typing_function */typing_fun$2
      ];
      var j = compile(pb);
      var j$1 = inh_conv_coerce_to_tycon(loc, env, myevdref, j, tycon);
      evdref[0] = myevdref[0];
      return j$1;
    };
    var j$1 = list_try_compile(compile_for_one_predicate, preds);
    Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
            return check_unused_pattern(env, param);
          }), matx$3);
    return j$1;
  }
}

exports.PatternMatchingError = PatternMatchingError;
exports.error_wrong_numarg_constructor = error_wrong_numarg_constructor;
exports.error_wrong_numarg_inductive = error_wrong_numarg_inductive;
exports.irrefutable = irrefutable;
exports.compile_cases = compile_cases;
exports.constr_of_pat = constr_of_pat;
exports.compile = compile;
exports.prepare_predicate = prepare_predicate;
exports.make_return_predicate_ltac_lvar = make_return_predicate_ltac_lvar;
/* recover_initial_subpattern_names Not a pure module */
