// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Typeclasses$ReactTemplate = require("./typeclasses.bs.js");
var Constrexpr_ops$ReactTemplate = require("./constrexpr_ops.bs.js");
var Typeclasses_errors$ReactTemplate = require("./typeclasses_errors.bs.js");

var generalizable_table = Summary$ReactTemplate.ref(/* None */0, "generalizable-ident", Names$ReactTemplate.Id[/* Pred */11][/* empty */0]);

function add_generalizable(gen, table) {
  if (gen) {
    var l = gen[0];
    if (l) {
      return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (table, lid) {
                    var table$1 = table;
                    var param = lid;
                    var loc = param[/* loc */1];
                    var id = param[/* v */0];
                    if (!Names$ReactTemplate.Id[/* equal */0](id, Nameops$ReactTemplate.root_of_id(id))) {
                      CErrors$ReactTemplate.user_err(loc, /* Some */["declare_generalizable_ident"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is not declarable as generalizable identifier: it must have no trailing digits, quote, or _")));
                    }
                    if (Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], id, table$1)) {
                      return CErrors$ReactTemplate.user_err(loc, /* Some */["declare_generalizable_ident"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" is already declared as a generalizable identifier")));
                    } else {
                      return Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* add */6], id, table$1);
                    }
                  }), table, l);
    } else {
      return Names$ReactTemplate.Id[/* Pred */11][/* full */1];
    }
  } else {
    return Names$ReactTemplate.Id[/* Pred */11][/* empty */0];
  }
}

function cache_generalizable_type(param) {
  generalizable_table[0] = add_generalizable(param[1][1], generalizable_table[0]);
  return /* () */0;
}

function load_generalizable_type(_, param) {
  generalizable_table[0] = add_generalizable(param[1][1], generalizable_table[0]);
  return /* () */0;
}

var init = Libobject$ReactTemplate.default_object("GENERALIZED-IDENT");

var in_generalizable = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_generalizable_type,
      /* load_function */load_generalizable_type,
      /* open_function */init[/* open_function */3],
      /* classify_function */(function (obj) {
          if (obj[0]) {
            return /* Dispose */0;
          } else {
            return /* Keep */Block.__(1, [obj]);
          }
        }),
      /* subst_function */init[/* subst_function */5],
      /* discharge_function */init[/* discharge_function */6],
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

function declare_generalizable(local, gen) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(in_generalizable, /* tuple */[
                  local,
                  gen
                ]));
}

function find_generalizable_ident(id) {
  return Curry._2(Names$ReactTemplate.Id[/* Pred */11][/* mem */4], Nameops$ReactTemplate.root_of_id(id), generalizable_table[0]);
}

function ids_of_list(l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], Names$ReactTemplate.Id[/* Set */9][/* add */3], l, Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
}

function is_global(id) {
  try {
    Nametab$ReactTemplate.locate_extended(Libnames$ReactTemplate.qualid_of_ident(id));
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_named(id, env) {
  try {
    Environ$ReactTemplate.lookup_named(id, env);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_freevar(ids, env, x) {
  return 1 - (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], x, ids) || is_named(x, env) || is_global(x));
}

function ungeneralizable(loc, id) {
  return CErrors$ReactTemplate.user_err(loc, /* Some */["Generalization"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unbound and ungeneralizable variable "), Names$ReactTemplate.Id[/* print */8](id)));
}

function free_vars_of_constr_expr(c, $staropt$star, l) {
  var bound = $staropt$star ? $staropt$star[0] : Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var aux = function (bdvars, l, c) {
    var match = c[/* v */0];
    var exit = 0;
    switch (match.tag | 0) {
      case 0 : 
          var match$1 = match[0][/* v */0];
          if (match$1.tag) {
            var loc = c[/* loc */1];
            var id = match$1[0];
            var bdvars$1 = bdvars;
            var l$1 = l;
            if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], id, l$1) || !is_freevar(bdvars$1, Global$ReactTemplate.env(/* () */0), id)) {
              return l$1;
            } else if (find_generalizable_ident(id)) {
              return /* :: */[
                      id,
                      l$1
                    ];
            } else {
              return ungeneralizable(loc, id);
            }
          } else {
            exit = 1;
          }
          break;
      case 17 : 
          if (match[0] === "{ _ : _ | _ }") {
            var match$2 = match[1];
            var match$3 = match$2[0];
            if (match$3) {
              var match$4 = match$3[0][/* v */0];
              if (match$4.tag) {
                exit = 1;
              } else {
                var match$5 = match$4[0][/* v */0];
                if (match$5.tag) {
                  if (match$2[1]) {
                    exit = 1;
                  } else if (match$2[2]) {
                    exit = 1;
                  } else if (match$2[3]) {
                    exit = 1;
                  } else {
                    var id$1 = match$5[0];
                    if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id$1, bdvars)) {
                      exit = 1;
                    } else {
                      return Constrexpr_ops$ReactTemplate.fold_constr_expr_with_binders((function (a, l) {
                                      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], a, l);
                                    }), aux, Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id$1, bdvars), l)(c);
                    }
                  }
                } else {
                  exit = 1;
                }
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      return Constrexpr_ops$ReactTemplate.fold_constr_expr_with_binders((function (a, l) {
                      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], a, l);
                    }), aux, bdvars, l)(c);
    }
    
  };
  return aux(bound, l, c);
}

function ids_of_names(l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, x) {
                var match = x[/* v */0];
                if (match) {
                  return /* :: */[
                          match[0],
                          acc
                        ];
                } else {
                  return acc;
                }
              }), /* [] */0, l);
}

function free_vars_of_binders($staropt$star, l, binders) {
  var bound = $staropt$star ? $staropt$star[0] : Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var _bdvars = bound;
  var _l = l;
  var _c = binders;
  while(true) {
    var c = _c;
    var l$1 = _l;
    var bdvars = _bdvars;
    if (c) {
      var match = c[0];
      switch (match.tag | 0) {
        case 0 : 
            var bound$1 = ids_of_names(match[0]);
            var l$prime = free_vars_of_constr_expr(match[2], /* Some */[bdvars], l$1);
            _c = c[1];
            _l = l$prime;
            _bdvars = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], ids_of_list(bound$1), bdvars);
            continue ;
            case 1 : 
            var match$1 = match[0][/* v */0];
            var bound$2 = match$1 ? /* :: */[
                match$1[0],
                /* [] */0
              ] : /* [] */0;
            var l$prime$1 = free_vars_of_constr_expr(match[1], /* Some */[bdvars], l$1);
            var l$prime$prime = Option$ReactTemplate.fold_left((function(bdvars){
                return function (l, t) {
                  return free_vars_of_constr_expr(t, /* Some */[bdvars], l);
                }
                }(bdvars)), l$prime$1, match[2]);
            _c = c[1];
            _l = l$prime$prime;
            _bdvars = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], ids_of_list(bound$2), bdvars);
            continue ;
            case 2 : 
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "implicit_quantifiers.ml",
                    119,
                    31
                  ]
                ];
        
      }
    } else {
      return /* tuple */[
              bdvars,
              l$1
            ];
    }
  };
}

function generalizable_vars_of_glob_constr($staropt$star, $staropt$star$1) {
  var bound = $staropt$star ? $staropt$star[0] : Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var allowed = $staropt$star$1 ? $staropt$star$1[0] : Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var vars = function (bound, vs, c) {
    var match = DAst$ReactTemplate.get(c);
    if (match.tag === 1) {
      var id = match[0];
      var loc = c[/* loc */1];
      if (is_freevar(bound, Global$ReactTemplate.env(/* () */0), id) && !Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                return Names$ReactTemplate.Id[/* equal */0](param[/* v */0], id);
              }), vs)) {
        return /* :: */[
                CAst$ReactTemplate.make(loc, id),
                vs
              ];
      } else {
        return vs;
      }
    } else {
      return Glob_ops$ReactTemplate.fold_glob_constr_with_binders(Names$ReactTemplate.Id[/* Set */9][/* add */3], vars, bound, vs)(c);
    }
  };
  return (function (rt) {
      var vars$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], vars(bound, /* [] */0, rt));
      Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
              var id = param[/* v */0];
              if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, allowed) || find_generalizable_ident(id)) {
                return 0;
              } else {
                return ungeneralizable(param[/* loc */1], id);
              }
            }), vars$1);
      return vars$1;
    });
}

function make_fresh(ids, env, _x) {
  while(true) {
    var x = _x;
    if (is_freevar(ids, env, x)) {
      return x;
    } else {
      _x = Nameops$ReactTemplate.increment_subscript(x);
      continue ;
      
    }
  };
}

function next_name_away_from(na, avoid) {
  if (na) {
    return make_fresh(avoid, Global$ReactTemplate.env(/* () */0), na[0]);
  } else {
    return make_fresh(avoid, Global$ReactTemplate.env(/* () */0), Names$ReactTemplate.Id[/* of_string */5]("anon"));
  }
}

function combine_params(avoid, fn, applied, needed) {
  var match = Curry._2(Util$ReactTemplate.List[/* partition */29], (function (param) {
          var match = param[1];
          if (match) {
            var match$1 = match[0];
            var match$2 = match$1[/* v */0];
            if (match$2.tag) {
              var id = match$2[0];
              var is_id = function (param) {
                var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], param[1]);
                if (match) {
                  return Names$ReactTemplate.Id[/* equal */0](id, match[0]);
                } else {
                  return /* false */0;
                }
              };
              if (!Curry._2(Util$ReactTemplate.List[/* exists */21], is_id, needed)) {
                CErrors$ReactTemplate.user_err(match$1[/* loc */1], /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Wrong argument name: "), Names$ReactTemplate.Id[/* print */8](id)));
              }
              return /* true */1;
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
        }), applied);
  var named = Curry._2(Util$ReactTemplate.List[/* map */10], (function (x) {
          var match = x[1];
          if (match) {
            var match$1 = match[0][/* v */0];
            if (match$1.tag) {
              return /* tuple */[
                      match$1[0],
                      x[0]
                    ];
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "implicit_quantifiers.ml",
                      162,
                      80
                    ]
                  ];
            }
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "implicit_quantifiers.ml",
                    162,
                    80
                  ]
                ];
          }
        }), match[0]);
  var is_unset = function (param) {
    if (param[1].tag) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
  var needed$1 = Curry._2(Util$ReactTemplate.List[/* filter */27], is_unset, needed);
  var _ids = /* [] */0;
  var _avoid = avoid;
  var _app = match[1];
  var _need = needed$1;
  while(true) {
    var need = _need;
    var app = _app;
    var avoid$1 = _avoid;
    var ids = _ids;
    var exit = 0;
    if (app) {
      if (need) {
        exit = 1;
      } else {
        return CErrors$ReactTemplate.user_err(Constrexpr_ops$ReactTemplate.constr_loc(app[0][0]), /* None */0, Pp$ReactTemplate.str("Typeclass does not expect more arguments"));
      }
    } else if (need) {
      exit = 1;
    } else {
      return /* tuple */[
              Curry._1(Util$ReactTemplate.List[/* rev */4], ids),
              avoid$1
            ];
    }
    if (exit === 1) {
      var d = need[0];
      var exit$1 = 0;
      var match$1 = d[1][0];
      if (match$1) {
        var id = match$1[0];
        if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc */3], id, named)) {
          _need = need[1];
          _ids = /* :: */[
            Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id, named),
            ids
          ];
          continue ;
          
        } else {
          exit$1 = 2;
        }
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        if (d[0]) {
          var match$2 = Curry._2(fn, avoid$1, d);
          _need = need[1];
          _avoid = match$2[1];
          _ids = /* :: */[
            match$2[0],
            ids
          ];
          continue ;
          
        } else if (app) {
          var x = app[0];
          var exit$2 = 0;
          if (x[1]) {
            exit$2 = 3;
          } else if (need[0][1][0]) {
            _need = need[1];
            _app = app[1];
            _ids = /* :: */[
              x[0],
              ids
            ];
            continue ;
            
          } else {
            exit$2 = 3;
          }
          if (exit$2 === 3) {
            _need = need[1];
            _app = app[1];
            _ids = /* :: */[
              x[0],
              ids
            ];
            continue ;
            
          }
          
        } else {
          var match$3 = Curry._2(fn, avoid$1, need[0]);
          _need = need[1];
          _avoid = match$3[1];
          _ids = /* :: */[
            match$3[0],
            ids
          ];
          continue ;
          
        }
      }
      
    }
    
  };
}

function combine_params_freevar(avoid, param) {
  var id$prime = next_name_away_from(Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], param[1]), avoid);
  var eta = /* Ident */Block.__(1, [id$prime]);
  var eta_000 = CAst$ReactTemplate.make(/* None */0, eta);
  var eta$1 = /* CRef */Block.__(0, [
      eta_000,
      /* None */0
    ]);
  return /* tuple */[
          CAst$ReactTemplate.make(/* None */0, eta$1),
          Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id$prime, avoid)
        ];
}

function destClassApp(cl) {
  var loc = cl[/* loc */1];
  var match = cl[/* v */0];
  switch (match.tag | 0) {
    case 0 : 
        return CAst$ReactTemplate.make(cl[/* loc */1], /* tuple */[
                    match[0],
                    /* [] */0,
                    match[1]
                  ]);
    case 6 : 
        var match$1 = match[0];
        if (match$1[0]) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          return CAst$ReactTemplate.make(loc, /* tuple */[
                      match$1[1],
                      match[1],
                      match$1[2]
                    ]);
        }
        break;
    case 7 : 
        var match$2 = match[0];
        if (match$2[0]) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          var match$3 = match$2[1][/* v */0];
          if (match$3.tag) {
            throw Caml_builtin_exceptions.not_found;
          } else {
            return CAst$ReactTemplate.make(loc, /* tuple */[
                        match$3[0],
                        Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                                return prim[0];
                              }), match[1]),
                        match$3[1]
                      ]);
          }
        }
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function destClassAppExpl(cl) {
  var loc = cl[/* loc */1];
  var match = cl[/* v */0];
  switch (match.tag | 0) {
    case 0 : 
        return CAst$ReactTemplate.make(cl[/* loc */1], /* tuple */[
                    match[0],
                    /* [] */0,
                    match[1]
                  ]);
    case 7 : 
        var match$1 = match[0];
        if (match$1[0]) {
          throw Caml_builtin_exceptions.not_found;
        } else {
          var match$2 = match$1[1][/* v */0];
          if (match$2.tag) {
            throw Caml_builtin_exceptions.not_found;
          } else {
            return CAst$ReactTemplate.make(loc, /* tuple */[
                        match$2[0],
                        match[1],
                        match$2[1]
                      ]);
          }
        }
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function implicit_application(env, $staropt$star, f, ty) {
  var allow_partial = $staropt$star ? $staropt$star[0] : /* true */1;
  var is_class;
  try {
    var clapp = destClassAppExpl(ty);
    var qid = Libnames$ReactTemplate.qualid_of_reference(clapp[/* v */0][0]);
    var gr = Nametab$ReactTemplate.locate(qid[/* v */0]);
    is_class = Typeclasses$ReactTemplate.is_class(gr) ? /* Some */[/* tuple */[
          clapp,
          gr
        ]] : /* None */0;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      is_class = /* None */0;
    } else {
      throw exn;
    }
  }
  if (is_class) {
    var match = is_class[0];
    var match$1 = match[0];
    var match$2 = match$1[/* v */0];
    var par = match$2[1];
    var avoid = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], env, ids_of_list(free_vars_of_constr_expr(ty, /* Some */[env], /* [] */0)));
    var c = Typeclasses$ReactTemplate.class_info(match[1]);
    var match$3 = c[/* cl_context */2];
    var rd = match$3[1];
    var ci = match$3[0];
    if (!allow_partial) {
      var opt_succ = function (x, n) {
        if (x) {
          return n;
        } else {
          return n + 1 | 0;
        }
      };
      var applen = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, param) {
              return opt_succ(param[1], acc);
            }), 0, par);
      var needlen = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, x) {
              return opt_succ(x, acc);
            }), 0, ci);
      if (needlen !== applen) {
        Typeclasses_errors$ReactTemplate.mismatched_ctx_inst(Global$ReactTemplate.env(/* () */0), /* Parameters */0, Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                    return prim[0];
                  }), par), rd);
      }
      
    }
    var pars = Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._2(Util$ReactTemplate.List[/* combine */37], ci, rd));
    var match$4 = combine_params(avoid, f, par, pars);
    var avoid$1 = match$4[1];
    var match_000 = CAst$ReactTemplate.make(match$1[/* loc */1], /* CAppExpl */Block.__(6, [
            /* tuple */[
              /* None */0,
              match$2[0],
              match$2[2]
            ],
            match$4[0]
          ]));
    return /* tuple */[
            match_000,
            avoid$1
          ];
  } else {
    return /* tuple */[
            ty,
            env
          ];
  }
}

function implicits_of_glob_constr($staropt$star, l) {
  var with_products = $staropt$star ? $staropt$star[0] : /* true */1;
  var add_impl = function (i, na, bk, l) {
    if (bk !== 0) {
      var name = na ? /* Some */[na[0]] : /* None */0;
      return /* :: */[
              /* tuple */[
                /* ExplByPos */Block.__(0, [
                    i,
                    name
                  ]),
                /* tuple */[
                  /* true */1,
                  /* true */1,
                  /* true */1
                ]
              ],
              l
            ];
    } else {
      return l;
    }
  };
  var aux = function (i, _c) {
    while(true) {
      var c = _c;
      var abs = function (na, bk, b) {
        return add_impl(i, na, bk, aux(i + 1 | 0, b));
      };
      var match = DAst$ReactTemplate.get(c);
      switch (match.tag | 0) {
        case 5 : 
            return abs(match[0], match[1], match[3]);
        case 6 : 
            var bk = match[1];
            var na = match[0];
            if (with_products) {
              return abs(na, bk, match[3]);
            } else {
              if (bk !== 0) {
                Feedback$ReactTemplate.msg_warning(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Ignoring implicit status of product binder "), Curry._1(Nameops$ReactTemplate.Name[/* print */7], na)), Pp$ReactTemplate.strbrk(" and following binders")));
              }
              return /* [] */0;
            }
            break;
        case 7 : 
            _c = match[1];
            continue ;
            case 11 : 
            var args = match[2];
            var fix_kind = match[0];
            var nb;
            nb = fix_kind.tag ? fix_kind[0] : fix_kind[0][1];
            return Curry._4(Util$ReactTemplate.List[/* fold_left_i */82], (function (i, l, param) {
                          return add_impl(i, param[0], param[1], l);
                        }), i, aux(Curry._1(Util$ReactTemplate.List[/* length */0], Caml_array.caml_array_get(args, nb)) + i | 0, Caml_array.caml_array_get(match[4], nb)), Caml_array.caml_array_get(args, nb));
        default:
          return /* [] */0;
      }
    };
  };
  return aux(1, l);
}

exports.declare_generalizable = declare_generalizable;
exports.ids_of_list = ids_of_list;
exports.destClassApp = destClassApp;
exports.destClassAppExpl = destClassAppExpl;
exports.free_vars_of_constr_expr = free_vars_of_constr_expr;
exports.free_vars_of_binders = free_vars_of_binders;
exports.generalizable_vars_of_glob_constr = generalizable_vars_of_glob_constr;
exports.make_fresh = make_fresh;
exports.implicits_of_glob_constr = implicits_of_glob_constr;
exports.combine_params_freevar = combine_params_freevar;
exports.implicit_application = implicit_application;
/* generalizable_table Not a pure module */
