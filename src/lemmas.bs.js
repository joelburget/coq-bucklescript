// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Decls$ReactTemplate = require("./decls.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Proof$ReactTemplate = require("./proof.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Future$ReactTemplate = require("./future.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Pfedit$ReactTemplate = require("./pfedit.bs.js");
var UState$ReactTemplate = require("./uState.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Declare$ReactTemplate = require("./declare.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Impargs$ReactTemplate = require("./impargs.bs.js");
var Kindops$ReactTemplate = require("./kindops.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Printer$ReactTemplate = require("./printer.bs.js");
var Tactics$ReactTemplate = require("./tactics.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Pretyping$ReactTemplate = require("./pretyping.bs.js");
var Tacticals$ReactTemplate = require("../tactics/tacticals.bs.js");
var Univdecls$ReactTemplate = require("./univdecls.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");
var Proof_using$ReactTemplate = require("./proof_using.bs.js");
var Safe_typing$ReactTemplate = require("./safe_typing.bs.js");
var Constrintern$ReactTemplate = require("./constrintern.bs.js");
var Proof_global$ReactTemplate = require("./proof_global.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");

function mk_hook(hook) {
  return hook;
}

function call_hook(fix_exn, hook, l, c) {
  try {
    return Curry._2(hook, l, c);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      var e$1 = CErrors$ReactTemplate.push(e);
      return Util$ReactTemplate.iraise(Curry._1(fix_exn, e$1));
    } else {
      throw e;
    }
  }
}

function retrieve_first_recthm(uctx, param) {
  switch (param.tag | 0) {
    case 0 : 
        var id = param[0];
        return /* tuple */[
                Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], Global$ReactTemplate.lookup_named(id)),
                Decls$ReactTemplate.variable_opacity(id)
              ];
    case 1 : 
        var cb = Global$ReactTemplate.lookup_constant(param[0]);
        var uctx$1 = UState$ReactTemplate.context(uctx);
        var inst = Univ$ReactTemplate.UContext[/* instance */3](uctx$1);
        var map = function (param) {
          return Vars$ReactTemplate.subst_instance_constr(inst, param[0]);
        };
        return /* tuple */[
                Option$ReactTemplate.map(map, Global$ReactTemplate.body_of_constant_body(cb)),
                Declareops$ReactTemplate.is_opaque(cb)
              ];
    case 2 : 
    case 3 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "lemmas.ml",
                57,
                9
              ]
            ];
    
  }
}

function adjust_guardness_conditions($$const, possible_indexes) {
  if (possible_indexes) {
    var env = Global$ReactTemplate.env(/* () */0);
    var newrecord = $$const.slice();
    newrecord[/* const_entry_body */0] = Future$ReactTemplate.chain($$const[/* const_entry_body */0], (function (param) {
            var eff = param[1];
            var match = param[0];
            var ctx = match[1];
            var body = match[0];
            var match$1 = Constr$ReactTemplate.kind(body);
            if (match$1.tag === 14) {
              var match$2 = match$1[0];
              if (match$2[0][1] !== 0) {
                return /* tuple */[
                        /* tuple */[
                          body,
                          ctx
                        ],
                        eff
                      ];
              } else {
                var fixdecls = match$2[1];
                var add = function (c, cb, e) {
                  var exists = function (c, e) {
                    try {
                      Environ$ReactTemplate.lookup_constant(c, e);
                      return /* true */1;
                    }
                    catch (exn){
                      if (exn === Caml_builtin_exceptions.not_found) {
                        return /* false */0;
                      } else {
                        throw exn;
                      }
                    }
                  };
                  if (exists(c, e)) {
                    return e;
                  } else {
                    return Environ$ReactTemplate.add_constant(c, cb, e);
                  }
                };
                var env$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (env, param) {
                        var eff = param[/* eff */1];
                        if (eff.tag) {
                          return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (e, param) {
                                        return add(param[1], param[2], e);
                                      }), env, eff[0]);
                        } else {
                          return add(eff[0], eff[1], env);
                        }
                      }), env, Safe_typing$ReactTemplate.side_effects_of_private_constants(eff));
                var indexes = Pretyping$ReactTemplate.search_guard(/* None */0, env$1, possible_indexes, fixdecls);
                return /* tuple */[
                        /* tuple */[
                          Constr$ReactTemplate.mkFix(/* tuple */[
                                /* tuple */[
                                  indexes,
                                  0
                                ],
                                fixdecls
                              ]),
                          ctx
                        ],
                        eff
                      ];
              }
            } else {
              return /* tuple */[
                      /* tuple */[
                        body,
                        ctx
                      ],
                      eff
                    ];
            }
          }));
    return newrecord;
  } else {
    return $$const;
  }
}

function find_mutually_recursive_statements(sigma, thms) {
  var n = Curry._1(Util$ReactTemplate.List[/* length */0], thms);
  var inds = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var match = param[1];
          var t = match[0];
          var match$1 = EConstr$ReactTemplate.decompose_prod_assum(sigma, t);
          var hyps = match$1[0];
          var x_000 = param[0];
          var x_001 = /* tuple */[
            t,
            match[1]
          ];
          var x = /* tuple */[
            x_000,
            x_001
          ];
          var whnf_hyp_hds = EConstr$ReactTemplate.map_rel_context_in_env((function (env, c) {
                  return Reductionops$ReactTemplate.whd_all_stack(env)(sigma, c)[0];
                }), Global$ReactTemplate.env(/* () */0), hyps);
          var ind_hyps = Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (i, decl) {
                      var t = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl);
                      var match = EConstr$ReactTemplate.kind(sigma, t);
                      if (match.tag === 11) {
                        var ind = match[0][0];
                        var mind = Global$ReactTemplate.lookup_mind(ind[0]);
                        if (mind[/* mind_finite */2] !== /* CoFinite */1) {
                          return /* :: */[
                                  /* tuple */[
                                    ind,
                                    x,
                                    i
                                  ],
                                  /* [] */0
                                ];
                        } else {
                          return /* [] */0;
                        }
                      } else {
                        return /* [] */0;
                      }
                    }), 0, Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._2(Util$ReactTemplate.List[/* filter */27], Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], whnf_hyp_hds))));
          var cclenv = EConstr$ReactTemplate.push_rel_context(hyps, Global$ReactTemplate.env(/* () */0));
          var match$2 = Reductionops$ReactTemplate.whd_all_stack(cclenv)(Evd$ReactTemplate.empty, match$1[1]);
          var match$3 = EConstr$ReactTemplate.kind(sigma, match$2[0]);
          var ind_ccl;
          if (match$3.tag === 11) {
            var ind = match$3[0][0];
            var mind = Global$ReactTemplate.lookup_mind(ind[0]);
            ind_ccl = mind[/* mind_ntypes */3] === n && mind[/* mind_finite */2] === /* CoFinite */1 ? /* :: */[
                /* tuple */[
                  ind,
                  x,
                  0
                ],
                /* [] */0
              ] : /* [] */0;
          } else {
            ind_ccl = /* [] */0;
          }
          return /* tuple */[
                  ind_hyps,
                  ind_ccl
                ];
        }), thms);
  var match = Curry._1(Util$ReactTemplate.List[/* split */36], inds);
  var inds_hyps = match[0];
  var of_same_mutind = function (param, param$1) {
    return Names$ReactTemplate.MutInd[/* equal */12](param[0][0], param$1[0][0]);
  };
  var same_indccl = Curry._3(Util$ReactTemplate.List[/* cartesians_filter */132], (function (hyp, oks) {
          if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
                    return of_same_mutind(hyp, param);
                  }), oks)) {
            return /* Some */[/* :: */[
                      hyp,
                      oks
                    ]];
          } else {
            return /* None */0;
          }
        }), /* [] */0, match[1]);
  var ordered_same_indccl = Curry._2(Util$ReactTemplate.List[/* filter */27], Curry._2(Util$ReactTemplate.List[/* for_all_i */86], (function (i, param) {
              return +(i === param[0][1]);
            }), 0), same_indccl);
  var common_same_indhyp = Curry._3(Util$ReactTemplate.List[/* cartesians_filter */132], (function (hyp, oks) {
          if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (param) {
                    return of_same_mutind(hyp, param);
                  }), oks)) {
            return /* Some */[/* :: */[
                      hyp,
                      oks
                    ]];
          } else {
            return /* None */0;
          }
        }), /* [] */0, inds_hyps);
  var match$1;
  if (ordered_same_indccl) {
    if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], ordered_same_indccl[1])) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "lemmas.ml",
              138,
              3
            ]
          ];
    }
    if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], common_same_indhyp)) {
      Flags$ReactTemplate.if_verbose((function (eta) {
              return Feedback$ReactTemplate.msg_info(/* None */0, eta);
            }), Pp$ReactTemplate.str("Assuming mutual coinductive statements."));
    }
    Pervasives.flush_all(/* () */0);
    match$1 = /* tuple */[
      ordered_same_indccl[0],
      /* true */1,
      /* [] */0
    ];
  } else if (common_same_indhyp) {
    if (same_indccl) {
      if (Curry._2(Util$ReactTemplate.List[/* distinct_f */59], Names$ReactTemplate.ind_ord, Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi1, same_indccl[0]))) {
        Flags$ReactTemplate.if_verbose((function (eta) {
                return Feedback$ReactTemplate.msg_info(/* None */0, eta);
              }), Pp$ReactTemplate.strbrk("Coinductive statements do not follow the order of definition, assuming the proof to be by induction."));
      }
      Pervasives.flush_all(/* () */0);
    }
    var possible_guards = Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi3), inds_hyps);
    match$1 = /* tuple */[
      Curry._1(Util$ReactTemplate.List[/* last */105], common_same_indhyp),
      /* false */0,
      possible_guards
    ];
  } else {
    match$1 = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Cannot find common (mutual) inductive premises or coinductive conclusions in the statements."));
  }
  return /* tuple */[
          /* tuple */[
            match$1[1],
            match$1[2],
            /* None */0
          ],
          match$1[0]
        ];
}

function look_for_possibly_mutual_statements(sigma, thms) {
  if (thms) {
    var match = thms[0];
    var match$1 = match[1];
    if (thms[1]) {
      var match$2 = find_mutually_recursive_statements(sigma, thms);
      var ordered_inds = match$2[1];
      var thms$1 = Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.pi2, ordered_inds);
      return /* tuple */[
              /* Some */[match$2[0]],
              thms$1,
              /* Some */[Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                        return param[2] + 1 | 0;
                      }), ordered_inds)]
            ];
    } else {
      return /* tuple */[
              /* None */0,
              /* :: */[
                /* tuple */[
                  match[0],
                  /* tuple */[
                    match$1[0],
                    match$1[1]
                  ]
                ],
                /* [] */0
              ],
              /* None */0
            ];
    }
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Empty list of theorems."));
  }
}

function save(export_seff, id, $$const, uctx, do_guard, param, hook) {
  var locality = param[0];
  var fix_exn = Future$ReactTemplate.fix_exn_of($$const[/* const_entry_body */0]);
  try {
    var $$const$1 = adjust_guardness_conditions($$const, do_guard);
    var k = Kindops$ReactTemplate.logical_kind_of_goal_kind(param[2]);
    var should_suggest = $$const$1[/* const_entry_opaque */5] && Option$ReactTemplate.is_empty($$const$1[/* const_entry_secctx */1]);
    var match;
    var exit = 0;
    if (locality !== 0) {
      exit = 1;
    } else if (Lib$ReactTemplate.sections_are_opened(/* () */0)) {
      var c = /* SectionLocalDef */Block.__(0, [$$const$1]);
      Declare$ReactTemplate.declare_variable(id, /* tuple */[
            Lib$ReactTemplate.cwd(/* () */0),
            c,
            k
          ]);
      if (should_suggest) {
        Proof_using$ReactTemplate.suggest_variable(Global$ReactTemplate.env(/* () */0), id);
      }
      match = /* tuple */[
        /* Local */1,
        /* VarRef */Block.__(0, [id])
      ];
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var local = locality >= 2 ? /* false */0 : /* true */1;
      var kn = Declare$ReactTemplate.declare_constant(/* None */0, /* Some */[local], id, export_seff, /* tuple */[
            /* DefinitionEntry */Block.__(0, [$$const$1]),
            k
          ]);
      if (should_suggest) {
        Proof_using$ReactTemplate.suggest_constant(Global$ReactTemplate.env(/* () */0), kn);
      }
      match = /* tuple */[
        locality,
        /* ConstRef */Block.__(1, [kn])
      ];
    }
    var r = match[1];
    Declare$ReactTemplate.definition_message(id);
    Declare$ReactTemplate.declare_univ_binders(r, UState$ReactTemplate.universe_binders(uctx));
    return call_hook((function (exn) {
                  return exn;
                }), hook, match[0], r);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      var e$1 = CErrors$ReactTemplate.push(e);
      return Util$ReactTemplate.iraise(Curry._1(fix_exn, e$1));
    } else {
      throw e;
    }
  }
}

var default_thm_id = Names$ReactTemplate.Id[/* of_string */5]("Unnamed_thm");

function fresh_name_for_anonymous_theorem() {
  var avoid = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* of_list */25], Proof_global$ReactTemplate.get_all_proof_names(/* () */0));
  return Namegen$ReactTemplate.next_global_ident_away(default_thm_id, avoid);
}

function check_name_freshness(locality, param) {
  var id = param[/* v */0];
  if (Nametab$ReactTemplate.exists_cci(Lib$ReactTemplate.make_path(id)) || Termops$ReactTemplate.is_section_variable(id) || locality === /* Global */2 && Nametab$ReactTemplate.exists_cci(Lib$ReactTemplate.make_path_except_section(id))) {
    return CErrors$ReactTemplate.user_err(param[/* loc */1], /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" already exists.")));
  } else {
    return 0;
  }
}

var save_hook = [(function () {
      return /* () */0;
    })];

function set_save_hook(f) {
  save_hook[0] = f;
  return /* () */0;
}

function check_anonymity(id, _) {
  if (Nameops$ReactTemplate.atompart_of_id(id) !== Names$ReactTemplate.Id[/* to_string */7](default_thm_id)) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This command can only be used for unnamed theorem."));
  } else {
    return 0;
  }
}

var warn_let_as_axiom = CWarnings$ReactTemplate.create("let-as-axiom", "vernacular", /* None */0, (function (id) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Let definition"), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.strbrk("declared as an axiom."));
      }));

function admit(param, pl, hook, _) {
  var id = param[0];
  var kn = Declare$ReactTemplate.declare_constant(/* None */0, /* None */0, id, /* None */0, /* tuple */[
        /* ParameterEntry */Block.__(1, [param[2]]),
        /* IsAssumption */Block.__(0, [/* Conjectural */2])
      ]);
  if (param[1][0] < 2) {
    Curry._2(warn_let_as_axiom, /* None */0, id);
  }
  Declare$ReactTemplate.assumption_message(id);
  Declare$ReactTemplate.declare_univ_binders(/* ConstRef */Block.__(1, [kn]), pl);
  return call_hook((function (exn) {
                return exn;
              }), hook, /* Global */2, /* ConstRef */Block.__(1, [kn]));
}

var start_hook = [(function () {
      return /* () */0;
    })];

function set_start_hook(param) {
  start_hook[0] = param;
  return /* () */0;
}

function get_proof(proof, do_guard, hook, opacity) {
  var match = Pfedit$ReactTemplate.cook_this_proof(proof);
  var match$1 = match[1];
  var newrecord = match$1[0].slice();
  return /* tuple */[
          match[0],
          (newrecord[/* const_entry_opaque */5] = opacity, newrecord),
          match$1[1],
          do_guard,
          match$1[2],
          hook
        ];
}

function universe_proof_terminator(compute_guard, hook) {
  return Proof_global$ReactTemplate.make_terminator((function (param) {
                if (param.tag) {
                  var proof = param[2];
                  var idopt = param[1];
                  var match = param[0] !== 0 ? /* tuple */[
                      /* false */0,
                      /* true */1
                    ] : /* tuple */[
                      /* true */1,
                      /* false */0
                    ];
                  var export_seff = match[1];
                  var proof$1 = get_proof(proof, compute_guard, Curry._1(hook, /* Some */[proof[/* universes */3]]), match[0]);
                  if (idopt) {
                    var export_seff$1 = /* Some */[export_seff];
                    var proof$2 = proof$1;
                    var save_ident = idopt[0][/* v */0];
                    check_anonymity(proof$2[0], save_ident);
                    return save(export_seff$1, save_ident, proof$2[1], proof$2[2], proof$2[3], proof$2[4], proof$2[5]);
                  } else {
                    var export_seff$2 = /* Some */[export_seff];
                    var proof$3 = proof$1;
                    return save(export_seff$2, proof$3[0], proof$3[1], proof$3[2], proof$3[3], proof$3[4], proof$3[5]);
                  }
                } else {
                  var ctx = param[3];
                  admit(/* tuple */[
                        param[0],
                        param[1],
                        param[2]
                      ], UState$ReactTemplate.universe_binders(ctx), Curry._1(hook, /* Some */[ctx]), /* () */0);
                  return Feedback$ReactTemplate.feedback(/* None */0, /* None */0, /* None */0, /* AddedAxiom */3);
                }
              }));
}

function standard_proof_terminator(compute_guard, hook) {
  return universe_proof_terminator(compute_guard, (function () {
                return hook;
              }));
}

function start_proof(id, pl, kind, sigma, terminator, sign, c, init_tac, $staropt$star, hook) {
  var compute_guard = $staropt$star ? $staropt$star[0] : /* [] */0;
  var terminator$1 = terminator ? Curry._2(terminator[0], compute_guard, hook) : universe_proof_terminator(compute_guard, (function () {
            return hook;
          }));
  var sign$1 = sign ? sign[0] : Decls$ReactTemplate.initialize_named_context_for_proof(/* () */0);
  Curry._1(start_hook[0], c);
  return Pfedit$ReactTemplate.start_proof(id, pl, kind, sigma, sign$1, c, init_tac, terminator$1);
}

function start_proof_univs(id, pl, kind, sigma, terminator, sign, c, init_tac, $staropt$star, hook) {
  var compute_guard = $staropt$star ? $staropt$star[0] : /* [] */0;
  var terminator$1 = terminator ? Curry._2(terminator[0], compute_guard, hook) : universe_proof_terminator(compute_guard, hook);
  var sign$1 = sign ? sign[0] : Decls$ReactTemplate.initialize_named_context_for_proof(/* () */0);
  Curry._1(start_hook[0], c);
  return Pfedit$ReactTemplate.start_proof(id, pl, kind, sigma, sign$1, c, init_tac, terminator$1);
}

function rec_tac_initializer(finite, guard, thms, snl) {
  if (finite) {
    var match = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            return /* tuple */[
                    param[0],
                    param[1][0]
                  ];
          }), thms);
    if (match) {
      return Tactics$ReactTemplate.mutual_cofix(match[0][0], match[1], 0);
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "lemmas.ml",
              381,
              11
            ]
          ];
    }
  } else {
    var nl = snl ? snl[0] : Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
              return prim + 1 | 0;
            }), Curry._2(Util$ReactTemplate.List[/* map */10], Util$ReactTemplate.List[/* last */105], guard));
    var match$1 = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param, n) {
            return /* tuple */[
                    param[0],
                    n,
                    param[1][0]
                  ];
          }), thms, nl);
    if (match$1) {
      var match$2 = match$1[0];
      return Tactics$ReactTemplate.mutual_fix(match$2[0], match$2[1], match$1[1], 0);
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "lemmas.ml",
              389,
              14
            ]
          ];
    }
  }
}

function start_proof_with_initialization(kind, sigma, decl, recguard, thms, snl, hook) {
  var intro_tac = function (param) {
    return Tacticals$ReactTemplate.New[/* tclMAP */20]((function (param) {
                  if (param) {
                    return Tactics$ReactTemplate.intro_mustbe_force(param[0]);
                  } else {
                    return Tactics$ReactTemplate.intro;
                  }
                }), Curry._1(Util$ReactTemplate.List[/* rev */4], param[1][1][0]));
  };
  var match;
  if (recguard) {
    var match$1 = recguard[0];
    var init_tac = match$1[2];
    var guard = match$1[1];
    var rec_tac = rec_tac_initializer(match$1[0], guard, thms, snl);
    var tmp;
    if (init_tac) {
      var tacl = init_tac[0];
      tmp = Tacticals$ReactTemplate.New[/* tclTHENS */18](rec_tac, Flags$ReactTemplate.is_auto_intros(/* () */0) ? Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (tac, thm) {
                    return Tacticals$ReactTemplate.New[/* tclTHEN */2](tac, intro_tac(thm));
                  }), tacl, thms) : tacl);
    } else {
      tmp = Flags$ReactTemplate.is_auto_intros(/* () */0) ? Tacticals$ReactTemplate.New[/* tclTHENS */18](rec_tac, Curry._2(Util$ReactTemplate.List[/* map */10], intro_tac, thms)) : rec_tac;
    }
    match = /* tuple */[
      /* Some */[tmp],
      guard
    ];
  } else {
    if (thms) {
      if (thms[1]) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "lemmas.ml",
                412,
                48
              ]
            ];
      }
      
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "lemmas.ml",
              412,
              48
            ]
          ];
    }
    match = /* tuple */[
      Flags$ReactTemplate.is_auto_intros(/* () */0) ? /* Some */[intro_tac(Curry._1(Util$ReactTemplate.List[/* hd */1], thms))] : /* None */0,
      /* [] */0
    ];
  }
  if (thms) {
    var other_thms = thms[1];
    var match$2 = thms[0];
    var match$3 = match$2[1];
    var imps = match$3[1][1];
    return start_proof_univs(match$2[0], /* Some */[decl], kind, sigma, /* None */0, /* None */0, match$3[0], match[0], /* Some */[match[1]], (function (ctx) {
                  return (function (param, param$1) {
                      var ctx$1 = ctx;
                      var strength = param;
                      var ref = param$1;
                      var ctx$2 = ctx$1 ? ctx$1[0] : UState$ReactTemplate.empty;
                      var other_thms_data;
                      if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], other_thms)) {
                        other_thms_data = /* [] */0;
                      } else {
                        var match = retrieve_first_recthm(ctx$2, ref);
                        var opaq = match[1];
                        var norm = function (c) {
                          return EConstr$ReactTemplate.to_constr(Evd$ReactTemplate.from_ctx(ctx$2), c);
                        };
                        var body = Option$ReactTemplate.map(EConstr$ReactTemplate.of_constr, match[0]);
                        var uctx = UState$ReactTemplate.check_univ_decl(Util$ReactTemplate.pi2(kind), ctx$2, decl);
                        other_thms_data = Curry._3(Util$ReactTemplate.List[/* map_i */67], (function (param, param$1) {
                                var param$2 = kind;
                                var norm$1 = norm;
                                var univs = uctx;
                                var body$1 = body;
                                var opaq$1 = opaq;
                                var i = param;
                                var param$3 = param$1;
                                var match = param$3[1];
                                var imps = match[1][1];
                                var id = param$3[0];
                                var locality = param$2[0];
                                var t_i = Curry._1(norm$1, match[0]);
                                if (body$1) {
                                  var body$2 = Curry._1(norm$1, body$1[0]);
                                  var k = Kindops$ReactTemplate.logical_kind_of_goal_kind(param$2[2]);
                                  var body_i = function (t) {
                                    var match = Constr$ReactTemplate.kind(t);
                                    var exit = 0;
                                    switch (match.tag | 0) {
                                      case 7 : 
                                          return Constr$ReactTemplate.mkLambda(/* tuple */[
                                                      match[0],
                                                      match[1],
                                                      body_i(match[2])
                                                    ]);
                                      case 8 : 
                                          return Constr$ReactTemplate.mkLetIn(/* tuple */[
                                                      match[0],
                                                      match[1],
                                                      match[2],
                                                      body_i(match[3])
                                                    ]);
                                      case 9 : 
                                          return Constr$ReactTemplate.mkApp(/* tuple */[
                                                      body_i(match[0]),
                                                      match[1]
                                                    ]);
                                      case 14 : 
                                          var match$1 = match[0];
                                          var match$2 = match$1[0];
                                          if (match$2[1] !== 0) {
                                            exit = 1;
                                          } else {
                                            return Constr$ReactTemplate.mkFix(/* tuple */[
                                                        /* tuple */[
                                                          match$2[0],
                                                          i
                                                        ],
                                                        match$1[1]
                                                      ]);
                                          }
                                          break;
                                      case 15 : 
                                          var match$3 = match[0];
                                          if (match$3[0] !== 0) {
                                            exit = 1;
                                          } else {
                                            return Constr$ReactTemplate.mkCoFix(/* tuple */[
                                                        i,
                                                        match$3[1]
                                                      ]);
                                          }
                                          break;
                                      default:
                                        exit = 1;
                                    }
                                    if (exit === 1) {
                                      var match$4 = Pfedit$ReactTemplate.get_current_context(/* () */0);
                                      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Not a proof by induction: "), Printer$ReactTemplate.pr_constr_env(match$4[1], match$4[0], body$2)), Pp$ReactTemplate.str(".")));
                                    }
                                    
                                  };
                                  var body_i$1 = body_i(body$2);
                                  if (locality !== 0) {
                                    var local;
                                    switch (locality) {
                                      case 0 : 
                                          throw [
                                                Caml_builtin_exceptions.assert_failure,
                                                [
                                                  "lemmas.ml",
                                                  276,
                                                  23
                                                ]
                                              ];
                                      case 1 : 
                                          local = /* true */1;
                                          break;
                                      case 2 : 
                                          local = /* false */0;
                                          break;
                                      
                                    }
                                    var $$const = Declare$ReactTemplate.definition_entry(/* None */0, /* Some */[opaq$1], /* None */0, /* Some */[t_i], /* Some */[univs], /* None */0, body_i$1);
                                    var kn = Declare$ReactTemplate.declare_constant(/* None */0, /* Some */[local], id, /* None */0, /* tuple */[
                                          /* DefinitionEntry */Block.__(0, [$$const]),
                                          k
                                        ]);
                                    return /* tuple */[
                                            locality,
                                            /* ConstRef */Block.__(1, [kn]),
                                            imps
                                          ];
                                  } else {
                                    var $$const$1 = Declare$ReactTemplate.definition_entry(/* None */0, /* Some */[opaq$1], /* None */0, /* Some */[t_i], /* Some */[univs], /* None */0, body_i$1);
                                    var c = /* SectionLocalDef */Block.__(0, [$$const$1]);
                                    Declare$ReactTemplate.declare_variable(id, /* tuple */[
                                          Lib$ReactTemplate.cwd(/* () */0),
                                          c,
                                          k
                                        ]);
                                    return /* tuple */[
                                            /* Discharge */0,
                                            /* VarRef */Block.__(0, [id]),
                                            imps
                                          ];
                                  }
                                } else if (locality !== 0) {
                                  var local$1;
                                  switch (locality) {
                                    case 0 : 
                                        throw [
                                              Caml_builtin_exceptions.assert_failure,
                                              [
                                                "lemmas.ml",
                                                248,
                                                25
                                              ]
                                            ];
                                    case 1 : 
                                        local$1 = /* true */1;
                                        break;
                                    case 2 : 
                                        local$1 = /* false */0;
                                        break;
                                    
                                  }
                                  var decl_000 = /* ParameterEntry */Block.__(1, [/* tuple */[
                                        /* None */0,
                                        /* tuple */[
                                          t_i,
                                          univs
                                        ],
                                        /* None */0
                                      ]]);
                                  var decl_001 = /* IsAssumption */Block.__(0, [/* Conjectural */2]);
                                  var decl = /* tuple */[
                                    decl_000,
                                    decl_001
                                  ];
                                  var kn$1 = Declare$ReactTemplate.declare_constant(/* None */0, /* Some */[local$1], id, /* None */0, decl);
                                  return /* tuple */[
                                          locality,
                                          /* ConstRef */Block.__(1, [kn$1]),
                                          imps
                                        ];
                                } else {
                                  var univs$1;
                                  univs$1 = univs.tag ? Univ$ReactTemplate.ContextSet[/* of_context */14](univs[0]) : univs[0];
                                  var c_000 = /* tuple */[
                                    t_i,
                                    univs$1
                                  ];
                                  var c_001 = param$2[1];
                                  var c$1 = /* SectionLocalAssum */Block.__(1, [
                                      c_000,
                                      c_001,
                                      /* false */0
                                    ]);
                                  Declare$ReactTemplate.declare_variable(id, /* tuple */[
                                        Lib$ReactTemplate.cwd(/* () */0),
                                        c$1,
                                        /* IsAssumption */Block.__(0, [/* Conjectural */2])
                                      ]);
                                  return /* tuple */[
                                          /* Discharge */0,
                                          /* VarRef */Block.__(0, [id]),
                                          imps
                                        ];
                                }
                              }), 1, other_thms);
                      }
                      var thms_data_000 = /* tuple */[
                        strength,
                        ref,
                        imps
                      ];
                      var thms_data = /* :: */[
                        thms_data_000,
                        other_thms_data
                      ];
                      return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                                    var ref = param[1];
                                    Impargs$ReactTemplate.maybe_declare_manual_implicits(/* false */0, ref, /* None */0, param[2]);
                                    return call_hook((function (exn) {
                                                  return exn;
                                                }), hook, param[0], ref);
                                  }), thms_data);
                    });
                }));
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("No proof to start."));
  }
}

function start_proof_com(inference_hook, kind, thms, hook) {
  var env0 = Global$ReactTemplate.env(/* () */0);
  var decl = Curry._1(Util$ReactTemplate.List[/* hd */1], thms)[0];
  var match = Univdecls$ReactTemplate.interp_univ_decl_opt(env0, decl[1]);
  var decl$1 = match[1];
  var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left_map */116], (function (evd, param) {
          var match = param[1];
          var id = param[0][0];
          var match$1 = Constrintern$ReactTemplate.interp_context_evars(/* None */0, /* None */0, /* None */0, env0, evd, match[0]);
          var match$2 = match$1[1];
          var match$3 = match$2[1];
          var match$4 = match$3[0];
          var ctx = match$4[1];
          var env = match$4[0];
          var match$5 = Constrintern$ReactTemplate.interp_type_evars_impls(env, match$1[0], /* Some */[match$2[0]], match[1]);
          var match$6 = match$5[1];
          var flags_000 = /* use_typeclasses */Pretyping$ReactTemplate.all_and_fail_flags[/* use_typeclasses */0];
          var flags_001 = /* solve_unification_constraints */Pretyping$ReactTemplate.all_and_fail_flags[/* solve_unification_constraints */1];
          var flags_003 = /* fail_evar */Pretyping$ReactTemplate.all_and_fail_flags[/* fail_evar */3];
          var flags_004 = /* expand_evars */Pretyping$ReactTemplate.all_and_fail_flags[/* expand_evars */4];
          var flags = /* record */[
            flags_000,
            flags_001,
            /* use_hook */inference_hook,
            flags_003,
            flags_004
          ];
          var evd$1 = Pretyping$ReactTemplate.solve_remaining_evars(flags, env, match$5[0], Evd$ReactTemplate.empty);
          var ids = Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], ctx);
          check_name_freshness(Util$ReactTemplate.pi1(kind), id);
          return /* tuple */[
                  evd$1,
                  /* tuple */[
                    id[/* v */0],
                    /* tuple */[
                      Evarutil$ReactTemplate.nf_evar(evd$1, EConstr$ReactTemplate.it_mkProd_or_LetIn(match$6[0], ctx)),
                      /* tuple */[
                        ids,
                        Util$ReactTemplate.$at(match$3[1], Curry._1(Impargs$ReactTemplate.lift_implicits(Context$ReactTemplate.Rel[/* nhyps */5](ctx)), match$6[1]))
                      ]
                    ]
                  ]
                ];
        }), match[0], thms);
  var evd = match$1[0];
  var match$2 = look_for_possibly_mutual_statements(evd, match$1[1]);
  var match$3 = Evarutil$ReactTemplate.nf_evars_and_universes(evd);
  var evd$1 = match$3[0];
  var thms$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var match = param[1];
          return /* tuple */[
                  param[0],
                  /* tuple */[
                    Reductionops$ReactTemplate.nf_evar(evd$1, match[0]),
                    match[1]
                  ]
                ];
        }), match$2[1]);
  if (!(decl$1[/* univdecl_extensible_instance */1] && decl$1[/* univdecl_extensible_constraints */3])) {
    Evd$ReactTemplate.check_univ_decl(Util$ReactTemplate.pi2(kind), evd$1, decl$1);
  }
  var evd$2 = Util$ReactTemplate.pi2(kind) ? evd$1 : Evd$ReactTemplate.fix_undefined_variables(evd$1);
  return start_proof_with_initialization(kind, evd$2, decl$1, match$2[0], thms$1, match$2[2], hook);
}

var keep_admitted_vars = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"keep section variables in admitted proofs",
      /* optkey : :: */[
        "Keep",
        /* :: */[
          "Admitted",
          /* :: */[
            "Variables",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return keep_admitted_vars[0];
        }),
      /* optwrite */(function (b) {
          keep_admitted_vars[0] = b;
          return /* () */0;
        })
    ]);

function save_proof(proof, param) {
  if (param) {
    var match = proof ? proof[0] : Proof_global$ReactTemplate.close_proof(/* false */0, (function (x) {
              return x;
            }));
    if (Option$ReactTemplate.is_empty(proof)) {
      Proof_global$ReactTemplate.discard_current(/* () */0);
    }
    return Curry._1(Proof_global$ReactTemplate.apply_terminator(match[1]), /* Proved */Block.__(1, [
                  param[0],
                  param[1],
                  match[0]
                ]));
  } else {
    var tmp;
    if (proof) {
      var match$1 = proof[0][0];
      var universes = match$1[/* universes */3];
      var k = match$1[/* persistence */2];
      var entries = match$1[/* entries */1];
      if (Curry._1(Util$ReactTemplate.List[/* length */0], entries) !== 1) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Admitted does not support multiple statements"));
      }
      var match$2 = Curry._1(Util$ReactTemplate.List[/* hd */1], entries);
      var const_entry_type = match$2[/* const_entry_type */3];
      if (!const_entry_type) {
        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Admitted requires an explicit statement"));
      }
      var typ = Option$ReactTemplate.get(const_entry_type);
      var ctx = UState$ReactTemplate.const_univ_entry(Util$ReactTemplate.pi2(k), universes);
      var sec_vars = keep_admitted_vars[0] ? match$2[/* const_entry_secctx */1] : /* None */0;
      tmp = /* Admitted */Block.__(0, [
          match$1[/* id */0],
          k,
          /* tuple */[
            sec_vars,
            /* tuple */[
              typ,
              ctx
            ],
            /* None */0
          ],
          universes
        ]);
    } else {
      var pftree = Proof_global$ReactTemplate.give_me_the_proof(/* () */0);
      var match$3 = Pfedit$ReactTemplate.current_proof_statement(/* () */0);
      var k$1 = match$3[1];
      var typ$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match$3[2]);
      var universes$1 = Proof$ReactTemplate.initial_euctx(pftree);
      var match$4 = Proof_global$ReactTemplate.return_proof(/* Some */[/* true */1], /* () */0);
      var pproofs = match$4[0];
      var sec_vars$1;
      if (keep_admitted_vars[0]) {
        var match$5 = Proof_global$ReactTemplate.get_used_variables(/* () */0);
        if (match$5) {
          sec_vars$1 = match$5;
        } else if (pproofs) {
          var env = Global$ReactTemplate.env(/* () */0);
          var ids_typ = Environ$ReactTemplate.global_vars_set(env, typ$1);
          var ids_def = Environ$ReactTemplate.global_vars_set(env, pproofs[0][0]);
          sec_vars$1 = /* Some */[Environ$ReactTemplate.keep_hyps(env, Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], ids_typ, ids_def))];
        } else {
          sec_vars$1 = /* None */0;
        }
      } else {
        sec_vars$1 = /* None */0;
      }
      var decl = Proof_global$ReactTemplate.get_universe_decl(/* () */0);
      var poly = Util$ReactTemplate.pi2(k$1);
      var ctx$1 = UState$ReactTemplate.check_univ_decl(poly, universes$1, decl);
      tmp = /* Admitted */Block.__(0, [
          match$3[0],
          k$1,
          /* tuple */[
            sec_vars$1,
            /* tuple */[
              typ$1,
              ctx$1
            ],
            /* None */0
          ],
          universes$1
        ]);
    }
    return Curry._1(Proof_global$ReactTemplate.apply_terminator(Proof_global$ReactTemplate.get_terminator(/* () */0)), tmp);
  }
}

function get_current_context() {
  return Pfedit$ReactTemplate.get_current_context(/* () */0);
}

exports.mk_hook = mk_hook;
exports.call_hook = call_hook;
exports.set_start_hook = set_start_hook;
exports.start_proof = start_proof;
exports.start_proof_univs = start_proof_univs;
exports.start_proof_com = start_proof_com;
exports.start_proof_with_initialization = start_proof_with_initialization;
exports.universe_proof_terminator = universe_proof_terminator;
exports.standard_proof_terminator = standard_proof_terminator;
exports.fresh_name_for_anonymous_theorem = fresh_name_for_anonymous_theorem;
exports.set_save_hook = set_save_hook;
exports.save_proof = save_proof;
exports.get_current_context = get_current_context;
/* default_thm_id Not a pure module */
