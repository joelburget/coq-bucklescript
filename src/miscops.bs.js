// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");

function map_cast_type(f, param) {
  if (typeof param === "number") {
    return /* CastCoerce */0;
  } else if (param.tag) {
    return /* CastVM */Block.__(1, [Curry._1(f, param[0])]);
  } else {
    return /* CastConv */Block.__(0, [Curry._1(f, param[0])]);
  }
}

function smartmap_cast_type(f, c) {
  if (typeof c === "number") {
    return /* CastCoerce */0;
  } else if (c.tag) {
    var a = c[0];
    var a$prime = Curry._1(f, a);
    if (a$prime === a) {
      return c;
    } else {
      return /* CastVM */Block.__(1, [a$prime]);
    }
  } else {
    var a$1 = c[0];
    var a$prime$1 = Curry._1(f, a$1);
    if (a$prime$1 === a$1) {
      return c;
    } else {
      return /* CastConv */Block.__(0, [a$prime$1]);
    }
  }
}

function glob_sort_eq(g1, g2) {
  if (typeof g1 === "number") {
    if (g1 !== 0) {
      if (typeof g2 === "number" && g2 !== 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else if (typeof g2 === "number" && g2 === 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (typeof g2 === "number") {
    return /* false */0;
  } else {
    return Curry._3(Util$ReactTemplate.List[/* equal */44], (function (param, param$1) {
                  return Option$ReactTemplate.equal((function (param, param$1) {
                                if (Libnames$ReactTemplate.eq_reference(param[0], param$1[0])) {
                                  return +(param[1] === param$1[1]);
                                } else {
                                  return /* false */0;
                                }
                              }), param, param$1);
                }), g1[0], g2[0]);
  }
}

function intro_pattern_naming_eq(nam1, nam2) {
  if (typeof nam1 === "number") {
    if (typeof nam2 === "number") {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (nam1.tag) {
    if (typeof nam2 === "number" || !nam2.tag) {
      return /* false */0;
    } else {
      return Names$ReactTemplate.Id[/* equal */0](nam1[0], nam2[0]);
    }
  } else if (typeof nam2 === "number" || nam2.tag) {
    return /* false */0;
  } else {
    return Names$ReactTemplate.Id[/* equal */0](nam1[0], nam2[0]);
  }
}

function map_flags(f, flags) {
  var newrecord = flags.slice();
  newrecord[/* rConst */6] = Curry._2(Util$ReactTemplate.List[/* map */10], f, flags[/* rConst */6]);
  return newrecord;
}

function map_occs(f, param) {
  return /* tuple */[
          param[0],
          Curry._1(f, param[1])
        ];
}

function map_red_expr_gen(f, g, h, x) {
  if (typeof x === "number") {
    return x;
  } else {
    switch (x.tag | 0) {
      case 1 : 
          return /* Simpl */Block.__(1, [
                    map_flags(g, x[0]),
                    Option$ReactTemplate.map((function (param) {
                            return map_occs((function (param) {
                                          return Util$ReactTemplate.map_union(g, h, param);
                                        }), param);
                          }), x[1])
                  ]);
      case 2 : 
          return /* Cbv */Block.__(2, [map_flags(g, x[0])]);
      case 3 : 
          return /* Cbn */Block.__(3, [map_flags(g, x[0])]);
      case 4 : 
          return /* Lazy */Block.__(4, [map_flags(g, x[0])]);
      case 5 : 
          return /* Unfold */Block.__(5, [Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                            return map_occs(g, param);
                          }), x[0])]);
      case 6 : 
          return /* Fold */Block.__(6, [Curry._2(Util$ReactTemplate.List[/* map */10], f, x[0])]);
      case 7 : 
          return /* Pattern */Block.__(7, [Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                            return map_occs(f, param);
                          }), x[0])]);
      case 9 : 
          return /* CbvVm */Block.__(9, [Option$ReactTemplate.map((function (param) {
                            return map_occs((function (param) {
                                          return Util$ReactTemplate.map_union(g, h, param);
                                        }), param);
                          }), x[0])]);
      default:
        return x;
    }
  }
}

function map_explicit_bindings(f, l) {
  var map = function (param) {
    return CAst$ReactTemplate.map((function (param) {
                  return /* tuple */[
                          param[0],
                          Curry._1(f, param[1])
                        ];
                }), param);
  };
  return Curry._2(Util$ReactTemplate.List[/* map */10], map, l);
}

function map_bindings(f, param) {
  if (typeof param === "number") {
    return /* NoBindings */0;
  } else if (param.tag) {
    return /* ExplicitBindings */Block.__(1, [map_explicit_bindings(f, param[0])]);
  } else {
    return /* ImplicitBindings */Block.__(0, [Curry._2(Util$ReactTemplate.List[/* map */10], f, param[0])]);
  }
}

function map_with_bindings(f, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          map_bindings(f, param[1])
        ];
}

exports.map_cast_type = map_cast_type;
exports.smartmap_cast_type = smartmap_cast_type;
exports.glob_sort_eq = glob_sort_eq;
exports.intro_pattern_naming_eq = intro_pattern_naming_eq;
exports.map_red_expr_gen = map_red_expr_gen;
exports.map_bindings = map_bindings;
exports.map_with_bindings = map_with_bindings;
/* Util-ReactTemplate Not a pure module */
