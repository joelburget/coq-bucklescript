// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Locusops$ReactTemplate = require("./locusops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function explain_occurrence_error(param) {
  if (param.tag) {
    var id = param[0];
    return Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id), Pp$ReactTemplate.str(" has no value."));
  } else {
    var l = param[0];
    var l$1 = Curry._2(Util$ReactTemplate.List[/* sort_uniquize */96], Caml_primitive.caml_int_compare, l);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Invalid occurrence " + (Curry._2(Util$ReactTemplate.$$String[/* plural */33], Curry._1(Util$ReactTemplate.List[/* length */0], l$1), "number") + ": ")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Pp$ReactTemplate.$$int, l$1)), Pp$ReactTemplate.str("."));
  }
}

function error_occurrences_error(e) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, explain_occurrence_error(e));
}

function error_invalid_occurrence(occ) {
  return error_occurrences_error(/* InvalidOccurrence */Block.__(0, [occ]));
}

function check_used_occurrences(nbocc, param) {
  var rest = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (o) {
          return +(o >= nbocc);
        }), param[1]);
  if (rest) {
    return error_occurrences_error(/* InvalidOccurrence */Block.__(0, [rest]));
  } else {
    return /* () */0;
  }
}

function proceed_with_occurrences(f, occs, x) {
  var exit = 0;
  if (typeof occs === "number") {
    if (occs !== 0) {
      return x;
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var plocs = Locusops$ReactTemplate.convert_occs(occs);
    if (!Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (x) {
              return +(x >= 0);
            }), plocs[1])) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "find_subterm.ml",
              57,
              4
            ]
          ];
    }
    var match = Curry._2(f, 1, x);
    check_used_occurrences(match[0], plocs);
    return match[1];
  }
  
}

function map_named_declaration_with_hyploc(f, hyploc, acc, decl) {
  var f$1 = function (acc, typ) {
    var match = Curry._3(f, /* Some */[/* tuple */[
            Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl),
            hyploc
          ]], acc, typ);
    return /* tuple */[
            match[0],
            match[1]
          ];
  };
  if (decl.tag) {
    var typ = decl[2];
    var body = decl[1];
    var id = decl[0];
    switch (hyploc) {
      case 0 : 
          var match = f$1(acc, body);
          var match$1 = f$1(match[0], typ);
          return /* tuple */[
                  match$1[0],
                  /* LocalDef */Block.__(1, [
                      id,
                      match[1],
                      match$1[1]
                    ])
                ];
      case 1 : 
          var match$2 = f$1(acc, typ);
          return /* tuple */[
                  match$2[0],
                  /* LocalDef */Block.__(1, [
                      id,
                      body,
                      match$2[1]
                    ])
                ];
      case 2 : 
          var match$3 = f$1(acc, body);
          return /* tuple */[
                  match$3[0],
                  /* LocalDef */Block.__(1, [
                      id,
                      match$3[1],
                      typ
                    ])
                ];
      
    }
  } else {
    var id$1 = decl[0];
    if (hyploc >= 2) {
      return error_occurrences_error(/* IncorrectInValueOccurrence */Block.__(1, [id$1]));
    } else {
      var match$4 = f$1(acc, decl[1]);
      return /* tuple */[
              match$4[0],
              /* LocalAssum */Block.__(0, [
                  id$1,
                  match$4[1]
                ])
            ];
    }
  }
}

var SubtermUnificationError = Caml_exceptions.create("Find_subterm-ReactTemplate.SubtermUnificationError");

var NotUnifiable = Caml_exceptions.create("Find_subterm-ReactTemplate.NotUnifiable");

function replace_term_occ_gen_modulo(sigma, occs, like_first, test, bywhat, cl, occ, t) {
  var match = Locusops$ReactTemplate.convert_occs(occs);
  var nowhere_except_in = match[0];
  var maxocc = Curry._3(Util$ReactTemplate.List[/* fold_right */14], Caml_obj.caml_max, match[1], 0);
  var pos = [occ];
  var nested = [/* false */0];
  var add_subst = function (t, subst) {
    try {
      test[/* testing_state */2] = Curry._2(test[/* merge_fun */1], subst, test[/* testing_state */2]);
      test[/* last_found */3] = /* Some */[/* tuple */[
          /* tuple */[
            cl,
            pos[0]
          ],
          t
        ]];
      return /* () */0;
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === NotUnifiable) {
        if (like_first) {
          throw exn;
        } else {
          var lastpos = Option$ReactTemplate.get(test[/* last_found */3]);
          throw [
                SubtermUnificationError,
                /* tuple */[
                  nested[0],
                  /* tuple */[
                    /* tuple */[
                      cl,
                      pos[0]
                    ],
                    t
                  ],
                  lastpos,
                  exn[1]
                ]
              ];
        }
      } else {
        throw exn;
      }
    }
  };
  var substrec = function (k, t) {
    if (nowhere_except_in && pos[0] > maxocc) {
      return t;
    } else {
      try {
        var subst = Curry._2(test[/* match_fun */0], test[/* testing_state */2], t);
        if (Locusops$ReactTemplate.is_selected(pos[0], occs)) {
          if (nested[0]) {
            var lastpos = Option$ReactTemplate.get(test[/* last_found */3]);
            throw [
                  SubtermUnificationError,
                  /* tuple */[
                    nested[0],
                    /* tuple */[
                      /* tuple */[
                        cl,
                        pos[0]
                      ],
                      t
                    ],
                    lastpos,
                    /* None */0
                  ]
                ];
          }
          add_subst(t, subst);
          pos[0] = pos[0] + 1 | 0;
          if (occs !== /* AllOccurrences */0 && occs !== /* NoOccurrences */1) {
            nested[0] = /* true */1;
            subst_below(k, t);
            nested[0] = /* false */0;
          }
          return EConstr$ReactTemplate.Vars[/* lift */0](k, Curry._1(bywhat, /* () */0));
        } else {
          pos[0] = pos[0] + 1 | 0;
          return subst_below(k, t);
        }
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === NotUnifiable) {
          return subst_below(k, t);
        } else {
          throw exn;
        }
      }
    }
  };
  var subst_below = function (k, t) {
    return Termops$ReactTemplate.map_constr_with_binders_left_to_right(sigma, (function (_, k) {
                  return k + 1 | 0;
                }), substrec, k, t);
  };
  var t$prime = substrec(0, t);
  return /* tuple */[
          pos[0],
          t$prime
        ];
}

function replace_term_occ_modulo(evd, occs, test, bywhat, t) {
  var match = occs ? /* tuple */[
      occs[0],
      /* false */0
    ] : /* tuple */[
      /* AllOccurrences */0,
      /* true */1
    ];
  var like_first = match[1];
  var occs$prime = match[0];
  return proceed_with_occurrences((function (param, param$1) {
                return replace_term_occ_gen_modulo(evd, occs$prime, like_first, test, bywhat, /* None */0, param, param$1);
              }), occs$prime, t);
}

function replace_term_occ_decl_modulo(evd, occs, test, bywhat, d) {
  var match = occs ? /* tuple */[
      occs[0],
      /* false */0
    ] : /* tuple */[
      /* tuple */[
        /* AllOccurrences */0,
        /* InHyp */0
      ],
      /* true */1
    ];
  var like_first = match[1];
  var match$1 = match[0];
  var hyploc = match$1[1];
  var plocs = match$1[0];
  return proceed_with_occurrences((function (param, param$1) {
                return map_named_declaration_with_hyploc((function (param, param$1, param$2) {
                              return replace_term_occ_gen_modulo(evd, plocs, like_first, test, bywhat, param, param$1, param$2);
                            }), hyploc, param, param$1);
              }), plocs, d);
}

function make_eq_univs_test(env, evd, c) {
  return /* record */[
          /* match_fun */(function (evd, c$prime) {
              var match = EConstr$ReactTemplate.eq_constr_universes_proj(env, evd, c, c$prime);
              if (match) {
                try {
                  return Evd$ReactTemplate.add_universe_constraints(evd, match[0]);
                }
                catch (exn){
                  if (exn === Evd$ReactTemplate.UniversesDiffer) {
                    throw [
                          NotUnifiable,
                          /* None */0
                        ];
                  } else {
                    throw exn;
                  }
                }
              } else {
                throw [
                      NotUnifiable,
                      /* None */0
                    ];
              }
            }),
          /* merge_fun */(function (evd, _) {
              return evd;
            }),
          /* testing_state */evd,
          /* last_found : None */0
        ];
}

function subst_closed_term_occ(env, evd, occs, c, t) {
  var test = make_eq_univs_test(env, evd, c);
  var bywhat = function () {
    return EConstr$ReactTemplate.mkRel(1);
  };
  var t$prime = replace_term_occ_modulo(evd, occs, test, bywhat, t);
  return /* tuple */[
          t$prime,
          test[/* testing_state */2]
        ];
}

function subst_closed_term_occ_decl(env, evd, occs, c, d) {
  var test = make_eq_univs_test(env, evd, c);
  var match = occs ? /* tuple */[
      occs[0],
      /* false */0
    ] : /* tuple */[
      /* tuple */[
        /* AllOccurrences */0,
        /* InHyp */0
      ],
      /* true */1
    ];
  var like_first = match[1];
  var match$1 = match[0];
  var hyploc = match$1[1];
  var plocs = match$1[0];
  var bywhat = function () {
    return EConstr$ReactTemplate.mkRel(1);
  };
  return /* tuple */[
          proceed_with_occurrences((function (param, param$1) {
                  return map_named_declaration_with_hyploc((function () {
                                return (function (param, param$1) {
                                    return replace_term_occ_gen_modulo(evd, plocs, like_first, test, bywhat, /* None */0, param, param$1);
                                  });
                              }), hyploc, param, param$1);
                }), plocs, d),
          test[/* testing_state */2]
        ];
}

exports.NotUnifiable = NotUnifiable;
exports.SubtermUnificationError = SubtermUnificationError;
exports.make_eq_univs_test = make_eq_univs_test;
exports.replace_term_occ_modulo = replace_term_occ_modulo;
exports.replace_term_occ_decl_modulo = replace_term_occ_decl_modulo;
exports.subst_closed_term_occ = subst_closed_term_occ;
exports.subst_closed_term_occ_decl = subst_closed_term_occ_decl;
exports.error_invalid_occurrence = error_invalid_occurrence;
/* Pp-ReactTemplate Not a pure module */
