// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var CMap$ReactTemplate = require("./cMap.bs.js");
var HMap$ReactTemplate = require("./hMap.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Canary$ReactTemplate = require("./canary.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Hashset$ReactTemplate = require("./hashset.bs.js");
var Unicode$ReactTemplate = require("./unicode.bs.js");
var Hashcons$ReactTemplate = require("./hashcons.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Predicate$ReactTemplate = require("./predicate.bs.js");

function equal(a, b) {
  return +(Curry._2(Util$ReactTemplate.$$String[/* compare */24], a, b) === 0);
}

var compare = Util$ReactTemplate.$$String[/* compare */24];

var hash = Util$ReactTemplate.$$String[/* hash */25];

function check_valid($staropt$star, x) {
  var strict = $staropt$star ? $staropt$star[0] : /* true */1;
  var iter = function (param) {
    if (param[0] || strict) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(param[1]));
    } else {
      return 0;
    }
  };
  return Option$ReactTemplate.iter(iter, Unicode$ReactTemplate.ident_refutation(x));
}

function is_valid(s) {
  var match = Unicode$ReactTemplate.ident_refutation(s);
  if (match) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function of_bytes(s) {
  var s$1 = Bytes.to_string(s);
  check_valid(/* None */0, s$1);
  return Curry._1(Util$ReactTemplate.$$String[/* hcons */41], s$1);
}

function of_string(s) {
  check_valid(/* None */0, s);
  return Curry._1(Util$ReactTemplate.$$String[/* hcons */41], s);
}

function of_string_soft(s) {
  check_valid(/* Some */[/* false */0], s);
  return Curry._1(Util$ReactTemplate.$$String[/* hcons */41], s);
}

function to_string(id) {
  return id;
}

var print = Pp$ReactTemplate.str;

var Self = /* module */[/* compare */compare];

var $$Set = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], Self);

var $$Map = CMap$ReactTemplate.Make(Self);

var Pred = Predicate$ReactTemplate.Make(Self);

var hcons = Util$ReactTemplate.$$String[/* hcons */41];

function mk_name(id) {
  return /* Name */[id];
}

function is_anonymous(param) {
  if (param) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function is_name(param) {
  return Util$ReactTemplate.$percent$great(is_anonymous, (function (prim) {
                return 1 - prim;
              }), param);
}

function compare$1(n1, n2) {
  if (n1) {
    if (n2) {
      return Curry._2(compare, n1[0], n2[0]);
    } else {
      return 1;
    }
  } else if (n2) {
    return -1;
  } else {
    return 0;
  }
}

function equal$1(n1, n2) {
  if (n1) {
    if (n2) {
      return +(n1[0] === n2[0]);
    } else {
      return /* false */0;
    }
  } else if (n2) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function hash$1(param) {
  if (param) {
    return Curry._1(hash, param[0]);
  } else {
    return 0;
  }
}

function print$1(param) {
  if (param) {
    return Pp$ReactTemplate.str(param[0]);
  } else {
    return Pp$ReactTemplate.str("_");
  }
}

function hashcons(hident, n) {
  if (n) {
    return /* Name */[Curry._1(hident, n[0])];
  } else {
    return n;
  }
}

function eq(n1, n2) {
  if (n1 === n2) {
    return /* true */1;
  } else if (n1) {
    if (n2) {
      return +(n1[0] === n2[0]);
    } else {
      return /* false */0;
    }
  } else if (n2) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

var Self_Hashcons = /* module */[
  /* hashcons */hashcons,
  /* eq */eq,
  /* hash */hash$1
];

var Hname = Hashcons$ReactTemplate.Make(Self_Hashcons);

var hcons$1 = Hashcons$ReactTemplate.simple_hcons(Hname[/* generate */0], Hname[/* hcons */1], hcons);

var compare$2 = Curry._1(Util$ReactTemplate.List[/* compare */43], compare);

var equal$2 = Curry._1(Util$ReactTemplate.List[/* equal */44], equal);

function hash$2(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      var accu$1 = Hashset$ReactTemplate.Combine[/* combine */0](Curry._1(hash, param[0]), accu);
      _param = param[1];
      _accu = accu$1;
      continue ;
      
    } else {
      return accu;
    }
  };
}

function hash$3(dp) {
  return hash$2(0, dp);
}

function make(x) {
  return x;
}

function repr(x) {
  return x;
}

var is_empty = Util$ReactTemplate.List[/* is_empty */45];

function to_string$1(sl) {
  if (sl) {
    return Curry._2(Util$ReactTemplate.$$String[/* concat */6], ".", Curry._2(Util$ReactTemplate.List[/* rev_map */12], to_string, sl));
  } else {
    return "<>";
  }
}

function print$2(dp) {
  return Pp$ReactTemplate.str(to_string$1(dp));
}

var initial = /* :: */[
  "If you see this, it's a bug",
  /* [] */0
];

var Hdir = Hashcons$ReactTemplate.Hlist([hash]);

var hcons$2 = Hashcons$ReactTemplate.recursive_hcons(Hdir[/* generate */0], Hdir[/* hcons */1], hcons);

var seed = [0];

function gen() {
  var ans = seed[0];
  seed[0] = seed[0] + 1 | 0;
  return ans;
}

function make$1(dir, s) {
  return /* tuple */[
          gen(/* () */0),
          s,
          dir
        ];
}

function repr$1(mbid) {
  return mbid;
}

function to_string$2(param) {
  return to_string$1(param[2]) + ("." + param[1]);
}

function debug_to_string(param) {
  return "<" + (to_string$1(param[2]) + ("#" + (param[1] + ("#" + (Pervasives.string_of_int(param[0]) + ">")))));
}

function compare$3(x, y) {
  if (x === y) {
    return 0;
  } else {
    var ans = Caml_primitive.caml_int_compare(x[0], y[0]);
    if (ans !== 0) {
      return ans;
    } else {
      var ans$1 = Curry._2(compare, x[1], y[1]);
      if (ans$1 !== 0) {
        return ans$1;
      } else {
        return Curry._2(compare$2, x[2], y[2]);
      }
    }
  }
}

function equal$3(x, y) {
  if (x === y) {
    return /* true */1;
  } else if (x[0] === y[0] && equal(x[1], y[1])) {
    return Curry._2(equal$2, x[2], y[2]);
  } else {
    return /* false */0;
  }
}

function to_id(param) {
  return param[1];
}

function hash$4(param) {
  return Hashset$ReactTemplate.Combine[/* combine3 */2](Int$ReactTemplate.hash(param[0]), Curry._1(hash, param[1]), hash$2(0, param[2]));
}

function hashcons$1(param, param$1) {
  return /* tuple */[
          param$1[0],
          Curry._1(param[0], param$1[1]),
          Curry._1(param[1], param$1[2])
        ];
}

function eq$1(x, y) {
  if (x === y) {
    return /* true */1;
  } else if (x[0] === y[0] && x[1] === y[1]) {
    return +(x[2] === y[2]);
  } else {
    return /* false */0;
  }
}

var Self_Hashcons$1 = /* module */[
  /* hashcons */hashcons$1,
  /* eq */eq$1,
  /* hash */hash$4
];

var HashMBId = Hashcons$ReactTemplate.Make(Self_Hashcons$1);

var hcons$3 = Hashcons$ReactTemplate.simple_hcons(HashMBId[/* generate */0], HashMBId[/* hcons */1], /* tuple */[
      hcons,
      hcons$2
    ]);

var MBImap = CMap$ReactTemplate.Make([compare$3]);

var MBIset = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], [compare$3]);

function of_id(id) {
  return id;
}

function to_id$1(id) {
  return id;
}

function is_bound(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return /* false */0;
      case 1 : 
          return /* true */1;
      case 2 : 
          _param = param[0];
          continue ;
          
    }
  };
}

function to_string$3(param) {
  switch (param.tag | 0) {
    case 0 : 
        return to_string$1(param[0]);
    case 1 : 
        return to_string$2(param[0]);
    case 2 : 
        return to_string$3(param[0]) + ("." + param[1]);
    
  }
}

function debug_to_string$1(param) {
  switch (param.tag | 0) {
    case 0 : 
        return to_string$1(param[0]);
    case 1 : 
        return debug_to_string(param[0]);
    case 2 : 
        return debug_to_string$1(param[0]) + ("." + param[1]);
    
  }
}

function compare$4(_mp1, _mp2) {
  while(true) {
    var mp2 = _mp2;
    var mp1 = _mp1;
    if (mp1 === mp2) {
      return 0;
    } else {
      switch (mp1.tag | 0) {
        case 0 : 
            switch (mp2.tag | 0) {
              case 0 : 
                  return Curry._2(compare$2, mp1[0], mp2[0]);
              case 1 : 
              case 2 : 
                  return -1;
              
            }
            break;
        case 1 : 
            switch (mp2.tag | 0) {
              case 0 : 
                  return 1;
              case 1 : 
                  return compare$3(mp1[0], mp2[0]);
              case 2 : 
                  return -1;
              
            }
            break;
        case 2 : 
            switch (mp2.tag | 0) {
              case 0 : 
              case 1 : 
                  return 1;
              case 2 : 
                  var c = Curry._2(Util$ReactTemplate.$$String[/* compare */24], mp1[1], mp2[1]);
                  if (c !== 0) {
                    return c;
                  } else {
                    _mp2 = mp2[0];
                    _mp1 = mp1[0];
                    continue ;
                    
                  }
                  break;
              
            }
            break;
        
      }
    }
  };
}

function equal$4(_mp1, _mp2) {
  while(true) {
    var mp2 = _mp2;
    var mp1 = _mp1;
    if (mp1 === mp2) {
      return /* true */1;
    } else {
      switch (mp1.tag | 0) {
        case 0 : 
            switch (mp2.tag | 0) {
              case 0 : 
                  return Curry._2(equal$2, mp1[0], mp2[0]);
              case 1 : 
              case 2 : 
                  return /* false */0;
              
            }
            break;
        case 1 : 
            switch (mp2.tag | 0) {
              case 1 : 
                  return equal$3(mp1[0], mp2[0]);
              case 0 : 
              case 2 : 
                  return /* false */0;
              
            }
            break;
        case 2 : 
            switch (mp2.tag | 0) {
              case 0 : 
              case 1 : 
                  return /* false */0;
              case 2 : 
                  if (mp1[1] === mp2[1]) {
                    _mp2 = mp2[0];
                    _mp1 = mp1[0];
                    continue ;
                    
                  } else {
                    return /* false */0;
                  }
                  break;
              
            }
            break;
        
      }
    }
  };
}

function hash$5(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, hash$2(0, param[0]));
    case 1 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](2, hash$4(param[0]));
    case 2 : 
        return Hashset$ReactTemplate.Combine[/* combinesmall */1](3, Hashset$ReactTemplate.Combine[/* combine */0](hash$5(param[0]), Curry._1(hash, param[1])));
    
  }
}

var initial$1 = /* MPfile */Block.__(0, [initial]);

function dp(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return param[0];
      case 1 : 
          return param[0][2];
      case 2 : 
          _param = param[0];
          continue ;
          
    }
  };
}

function hashcons$2(hfuns, param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* MPfile */Block.__(0, [Curry._1(hfuns[0], param[0])]);
    case 1 : 
        return /* MPbound */Block.__(1, [Curry._1(hfuns[1], param[0])]);
    case 2 : 
        return /* MPdot */Block.__(2, [
                  hashcons$2(hfuns, param[0]),
                  Curry._1(hfuns[2], param[1])
                ]);
    
  }
}

function eq$2(d1, d2) {
  if (d1 === d2) {
    return /* true */1;
  } else {
    switch (d1.tag | 0) {
      case 0 : 
          switch (d2.tag | 0) {
            case 0 : 
                return +(d1[0] === d2[0]);
            case 1 : 
            case 2 : 
                return /* false */0;
            
          }
          break;
      case 1 : 
          switch (d2.tag | 0) {
            case 1 : 
                return +(d1[0] === d2[0]);
            case 0 : 
            case 2 : 
                return /* false */0;
            
          }
          break;
      case 2 : 
          switch (d2.tag | 0) {
            case 0 : 
            case 1 : 
                return /* false */0;
            case 2 : 
                if (d1[1] === d2[1]) {
                  return equal$4(d1[0], d2[0]);
                } else {
                  return /* false */0;
                }
            
          }
          break;
      
    }
  }
}

var Self_Hashcons$2 = /* module */[
  /* hashcons */hashcons$2,
  /* eq */eq$2,
  /* hash */hash$5
];

var HashMP = Hashcons$ReactTemplate.Make(Self_Hashcons$2);

var hcons$4 = Hashcons$ReactTemplate.simple_hcons(HashMP[/* generate */0], HashMP[/* hcons */1], /* tuple */[
      hcons$2,
      hcons$3,
      Util$ReactTemplate.$$String[/* hcons */41]
    ]);

var MPset = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], [compare$4]);

var MPmap = CMap$ReactTemplate.Make([compare$4]);

function make$2(modpath, dirpath, knlabel) {
  return /* record */[
          /* canary */Canary$ReactTemplate.obj,
          /* modpath */modpath,
          /* dirpath */dirpath,
          /* knlabel */knlabel,
          /* refhash */-1
        ];
}

function repr$2(kn) {
  return /* tuple */[
          kn[/* modpath */1],
          kn[/* dirpath */2],
          kn[/* knlabel */3]
        ];
}

function make2(modpath, knlabel) {
  return /* record */[
          /* canary */Canary$ReactTemplate.obj,
          /* modpath */modpath,
          /* dirpath : [] */0,
          /* knlabel */knlabel,
          /* refhash */-1
        ];
}

function modpath(kn) {
  return kn[/* modpath */1];
}

function label(kn) {
  return kn[/* knlabel */3];
}

function to_string_gen(mp_to_string, kn) {
  var dp = Curry._1(is_empty, kn[/* dirpath */2]) ? "." : "#" + (to_string$1(kn[/* dirpath */2]) + "#");
  return Curry._1(mp_to_string, kn[/* modpath */1]) + (dp + kn[/* knlabel */3]);
}

function to_string$4(kn) {
  return to_string_gen(to_string$3, kn);
}

function debug_to_string$2(kn) {
  return to_string_gen(debug_to_string$1, kn);
}

function print$3(kn) {
  return Pp$ReactTemplate.str(to_string_gen(to_string$3, kn));
}

function compare$5(kn1, kn2) {
  if (kn1 === kn2) {
    return 0;
  } else {
    var c = Curry._2(Util$ReactTemplate.$$String[/* compare */24], kn1[/* knlabel */3], kn2[/* knlabel */3]);
    if (c !== 0) {
      return c;
    } else {
      var c$1 = Curry._2(compare$2, kn1[/* dirpath */2], kn2[/* dirpath */2]);
      if (c$1 !== 0) {
        return c$1;
      } else {
        return compare$4(kn1[/* modpath */1], kn2[/* modpath */1]);
      }
    }
  }
}

function equal$5(kn1, kn2) {
  var h1 = kn1[/* refhash */4];
  var h2 = kn2[/* refhash */4];
  if (0 <= h1 && 0 <= h2 && h1 !== h2 || !(equal(kn1[/* knlabel */3], kn2[/* knlabel */3]) && Curry._2(equal$2, kn1[/* dirpath */2], kn2[/* dirpath */2]))) {
    return /* false */0;
  } else {
    return equal$4(kn1[/* modpath */1], kn2[/* modpath */1]);
  }
}

function hash$6(kn) {
  var h = kn[/* refhash */4];
  if (h < 0) {
    var h$1 = Hashset$ReactTemplate.Combine[/* combine3 */2](hash$5(kn[/* modpath */1]), hash$2(0, kn[/* dirpath */2]), Curry._1(hash, kn[/* knlabel */3]));
    var h$2 = h$1 & 1073741823;
    kn[/* refhash */4] = h$2;
    return h$2;
  } else {
    return h;
  }
}

function hashcons$3(param, kn) {
  var refhash = kn[/* refhash */4];
  return /* record */[
          /* canary */Canary$ReactTemplate.obj,
          /* modpath */Curry._1(param[0], kn[/* modpath */1]),
          /* dirpath */Curry._1(param[1], kn[/* dirpath */2]),
          /* knlabel */Curry._1(param[2], kn[/* knlabel */3]),
          /* refhash */refhash
        ];
}

function eq$3(kn1, kn2) {
  if (kn1[/* modpath */1] === kn2[/* modpath */1] && kn1[/* dirpath */2] === kn2[/* dirpath */2]) {
    return +(kn1[/* knlabel */3] === kn2[/* knlabel */3]);
  } else {
    return /* false */0;
  }
}

var Self_Hashcons$3 = /* module */[
  /* hashcons */hashcons$3,
  /* eq */eq$3,
  /* hash */hash$6
];

var HashKN = Hashcons$ReactTemplate.Make(Self_Hashcons$3);

var hcons$5 = Hashcons$ReactTemplate.simple_hcons(HashKN[/* generate */0], HashKN[/* hcons */1], /* tuple */[
      hcons$4,
      hcons$2,
      Util$ReactTemplate.$$String[/* hcons */41]
    ]);

var KNmap = HMap$ReactTemplate.Make([
      compare$5,
      hash$6
    ]);

var KNpred = Predicate$ReactTemplate.Make([compare$5]);

function canonical(param) {
  if (param.tag) {
    return param[1];
  } else {
    return param[0];
  }
}

function user(param) {
  return param[0];
}

function same(kn) {
  return /* Same */Block.__(0, [kn]);
}

function make$3(knu, knc) {
  if (equal$5(knu, knc)) {
    return /* Same */Block.__(0, [knc]);
  } else {
    return /* Dual */Block.__(1, [
              knu,
              knc
            ]);
  }
}

function make2$1(mp, l) {
  return /* Same */Block.__(0, [make2(mp, l)]);
}

function make3(mp, dir, l) {
  return /* Same */Block.__(0, [make$2(mp, dir, l)]);
}

function repr3(kp) {
  return repr$2(kp[0]);
}

function label$1(kp) {
  return kp[0][/* knlabel */3];
}

function modpath$1(kp) {
  return kp[0][/* modpath */1];
}

function change_label(kp, lbl) {
  var match = repr$2(kp[0]);
  var l1 = match[2];
  var dp1 = match[1];
  var mp1 = match[0];
  var match$1 = repr$2(canonical(kp));
  var dp2 = match$1[1];
  var mp2 = match$1[0];
  if (!(l1 === match$1[2] && Curry._2(equal$2, dp1, dp2))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "names.ml",
            507,
            4
          ]
        ];
  }
  if (lbl === l1) {
    return kp;
  } else {
    var kn = make$2(mp1, dp1, lbl);
    if (mp1 === mp2) {
      return /* Same */Block.__(0, [kn]);
    } else {
      return make$3(kn, make$2(mp2, dp2, lbl));
    }
  }
}

function to_string$5(kp) {
  return to_string_gen(to_string$3, kp[0]);
}

function print$4(kp) {
  return Pp$ReactTemplate.str(to_string_gen(to_string$3, kp[0]));
}

function debug_to_string$3(param) {
  if (param.tag) {
    return "(" + (to_string_gen(debug_to_string$1, param[0]) + ("," + (to_string_gen(debug_to_string$1, param[1]) + ")")));
  } else {
    return "(" + (to_string_gen(debug_to_string$1, param[0]) + ")");
  }
}

function debug_print(kp) {
  return Pp$ReactTemplate.str(debug_to_string$3(kp));
}

function compare$6(x, y) {
  return compare$5(x[0], y[0]);
}

function equal$6(x, y) {
  if (x === y) {
    return /* true */1;
  } else {
    return equal$5(x[0], y[0]);
  }
}

function hash$7(x) {
  return hash$6(x[0]);
}

var UserOrd = /* module */[
  /* compare */compare$6,
  /* equal */equal$6,
  /* hash */hash$7
];

function compare$7(x, y) {
  return compare$5(canonical(x), canonical(y));
}

function equal$7(x, y) {
  if (x === y) {
    return /* true */1;
  } else {
    return equal$5(canonical(x), canonical(y));
  }
}

function hash$8(x) {
  return hash$6(canonical(x));
}

var CanOrd = /* module */[
  /* compare */compare$7,
  /* equal */equal$7,
  /* hash */hash$8
];

function compare$8(x, y) {
  if (x.tag) {
    if (y.tag) {
      var c = compare$5(x[0], y[0]);
      if (c !== 0) {
        return c;
      } else {
        return compare$5(x[1], y[1]);
      }
    } else {
      return 1;
    }
  } else if (y.tag) {
    return -1;
  } else {
    return compare$5(x[0], y[0]);
  }
}

function equal$8(x, y) {
  if (x === y) {
    return /* true */1;
  } else {
    return +(compare$8(x, y) === 0);
  }
}

function hash$9(param) {
  if (param.tag) {
    return Hashset$ReactTemplate.Combine[/* combine */0](hash$6(param[0]), hash$6(param[1]));
  } else {
    return hash$6(param[0]);
  }
}

var SyntacticOrd = /* module */[
  /* compare */compare$8,
  /* equal */equal$8,
  /* hash */hash$9
];

function hashcons$4(hkn, param) {
  if (param.tag) {
    return make$3(Curry._1(hkn, param[0]), Curry._1(hkn, param[1]));
  } else {
    return /* Same */Block.__(0, [Curry._1(hkn, param[0])]);
  }
}

function eq$4(x, y) {
  if (x === y) {
    return /* true */1;
  } else if (x.tag) {
    if (!y.tag || x[0] !== y[0]) {
      return /* false */0;
    } else {
      return +(x[1] === y[1]);
    }
  } else if (y.tag) {
    return /* false */0;
  } else {
    return +(x[0] === y[0]);
  }
}

function hash$10(param) {
  if (param.tag) {
    return Hashset$ReactTemplate.Combine[/* combine */0](hash$6(param[0]), hash$6(param[1]));
  } else {
    return hash$6(param[0]);
  }
}

var Self_Hashcons$4 = /* module */[
  /* hashcons */hashcons$4,
  /* eq */eq$4,
  /* hash */hash$10
];

var HashKP = Hashcons$ReactTemplate.Make(Self_Hashcons$4);

var Cmap = HMap$ReactTemplate.Make([
      compare$7,
      hash$8
    ]);

var Cmap_env = HMap$ReactTemplate.Make([
      compare$6,
      hash$7
    ]);

var Cpred = Predicate$ReactTemplate.Make([compare$7]);

var Mindmap = HMap$ReactTemplate.Make([
      compare$7,
      hash$8
    ]);

var Mindmap_env = HMap$ReactTemplate.Make([
      compare$6,
      hash$7
    ]);

function ind_modpath(param) {
  return param[0][0][/* modpath */1];
}

function constr_modpath(param) {
  return ind_modpath(param[0]);
}

function ith_mutual_inductive(param, i) {
  return /* tuple */[
          param[0],
          i
        ];
}

function ith_constructor_of_inductive(ind, i) {
  return /* tuple */[
          ind,
          i
        ];
}

function inductive_of_constructor(param) {
  return param[0];
}

function index_of_constructor(param) {
  return param[1];
}

function eq_ind(param, param$1) {
  if (param[1] === param$1[1]) {
    return equal$7(param[0], param$1[0]);
  } else {
    return /* false */0;
  }
}

function eq_user_ind(param, param$1) {
  if (param[1] === param$1[1]) {
    return equal$6(param[0], param$1[0]);
  } else {
    return /* false */0;
  }
}

function eq_syntactic_ind(param, param$1) {
  if (param[1] === param$1[1]) {
    return equal$8(param[0], param$1[0]);
  } else {
    return /* false */0;
  }
}

function ind_ord(param, param$1) {
  var c = Caml_primitive.caml_int_compare(param[1], param$1[1]);
  if (c) {
    return c;
  } else {
    return compare$7(param[0], param$1[0]);
  }
}

function ind_user_ord(param, param$1) {
  var c = Caml_primitive.caml_int_compare(param[1], param$1[1]);
  if (c) {
    return c;
  } else {
    return compare$6(param[0], param$1[0]);
  }
}

function ind_syntactic_ord(param, param$1) {
  var c = Caml_primitive.caml_int_compare(param[1], param$1[1]);
  if (c) {
    return c;
  } else {
    return compare$8(param[0], param$1[0]);
  }
}

function ind_hash(param) {
  return Hashset$ReactTemplate.Combine[/* combine */0](hash$6(canonical(param[0])), Int$ReactTemplate.hash(param[1]));
}

function ind_user_hash(param) {
  return Hashset$ReactTemplate.Combine[/* combine */0](hash$6(param[0][0]), Int$ReactTemplate.hash(param[1]));
}

function ind_syntactic_hash(param) {
  return Hashset$ReactTemplate.Combine[/* combine */0](hash$9(param[0]), Int$ReactTemplate.hash(param[1]));
}

function eq_constructor(param, param$1) {
  if (param[1] === param$1[1]) {
    return eq_ind(param[0], param$1[0]);
  } else {
    return /* false */0;
  }
}

function eq_user_constructor(param, param$1) {
  if (param[1] === param$1[1]) {
    return eq_user_ind(param[0], param$1[0]);
  } else {
    return /* false */0;
  }
}

function eq_syntactic_constructor(param, param$1) {
  if (param[1] === param$1[1]) {
    return eq_syntactic_ind(param[0], param$1[0]);
  } else {
    return /* false */0;
  }
}

function constructor_ord(param, param$1) {
  var c = Caml_primitive.caml_int_compare(param[1], param$1[1]);
  if (c) {
    return c;
  } else {
    return ind_ord(param[0], param$1[0]);
  }
}

function constructor_user_ord(param, param$1) {
  var c = Caml_primitive.caml_int_compare(param[1], param$1[1]);
  if (c) {
    return c;
  } else {
    return ind_user_ord(param[0], param$1[0]);
  }
}

function constructor_syntactic_ord(param, param$1) {
  var c = Caml_primitive.caml_int_compare(param[1], param$1[1]);
  if (c) {
    return c;
  } else {
    return ind_syntactic_ord(param[0], param$1[0]);
  }
}

function constructor_hash(param) {
  return Hashset$ReactTemplate.Combine[/* combine */0](ind_hash(param[0]), Int$ReactTemplate.hash(param[1]));
}

function constructor_user_hash(param) {
  return Hashset$ReactTemplate.Combine[/* combine */0](ind_user_hash(param[0]), Int$ReactTemplate.hash(param[1]));
}

function constructor_syntactic_hash(param) {
  return Hashset$ReactTemplate.Combine[/* combine */0](ind_syntactic_hash(param[0]), Int$ReactTemplate.hash(param[1]));
}

var InductiveOrdered = /* module */[/* compare */ind_ord];

var InductiveOrdered_env = /* module */[/* compare */ind_user_ord];

var Indmap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], InductiveOrdered);

var Indmap_env = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], InductiveOrdered_env);

var ConstructorOrdered = /* module */[/* compare */constructor_ord];

var ConstructorOrdered_env = /* module */[/* compare */constructor_user_ord];

var Constrmap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], ConstructorOrdered);

var Constrmap_env = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], ConstructorOrdered_env);

function eq_egr(e1, e2) {
  if (e1.tag) {
    if (e2.tag) {
      return equal$7(e1[0], e2[0]);
    } else {
      return /* false */0;
    }
  } else if (e2.tag) {
    return /* false */0;
  } else {
    return equal(e1[0], e2[0]);
  }
}

function hashcons$5(hmind, param) {
  return /* tuple */[
          Curry._1(hmind, param[0]),
          param[1]
        ];
}

function eq$5(param, param$1) {
  if (param[0] === param$1[0]) {
    return +(param[1] === param$1[1]);
  } else {
    return /* false */0;
  }
}

var Hind = Hashcons$ReactTemplate.Make(/* module */[
      /* hashcons */hashcons$5,
      /* eq */eq$5,
      /* hash */ind_hash
    ]);

function hashcons$6(hind, param) {
  return /* tuple */[
          Curry._1(hind, param[0]),
          param[1]
        ];
}

function eq$6(param, param$1) {
  if (param[0] === param$1[0]) {
    return +(param[1] === param$1[1]);
  } else {
    return /* false */0;
  }
}

var Hconstruct = Hashcons$ReactTemplate.Make(/* module */[
      /* hashcons */hashcons$6,
      /* eq */eq$6,
      /* hash */constructor_hash
    ]);

var hcons_con = Hashcons$ReactTemplate.simple_hcons(HashKP[/* generate */0], HashKP[/* hcons */1], hcons$5);

var hcons_mind = Hashcons$ReactTemplate.simple_hcons(HashKP[/* generate */0], HashKP[/* hcons */1], hcons$5);

var hcons_ind = Hashcons$ReactTemplate.simple_hcons(Hind[/* generate */0], Hind[/* hcons */1], hcons_mind);

var hcons_construct = Hashcons$ReactTemplate.simple_hcons(Hconstruct[/* generate */0], Hconstruct[/* hcons */1], hcons_ind);

var empty_transparent_state_000 = Pred[/* empty */0];

var empty_transparent_state_001 = Cpred[/* empty */0];

var empty_transparent_state = /* tuple */[
  empty_transparent_state_000,
  empty_transparent_state_001
];

var full_transparent_state_000 = Pred[/* full */1];

var full_transparent_state_001 = Cpred[/* full */1];

var full_transparent_state = /* tuple */[
  full_transparent_state_000,
  full_transparent_state_001
];

var var_full_transparent_state_000 = Pred[/* full */1];

var var_full_transparent_state_001 = Cpred[/* empty */0];

var var_full_transparent_state = /* tuple */[
  var_full_transparent_state_000,
  var_full_transparent_state_001
];

var cst_full_transparent_state_000 = Pred[/* empty */0];

var cst_full_transparent_state_001 = Cpred[/* full */1];

var cst_full_transparent_state = /* tuple */[
  cst_full_transparent_state_000,
  cst_full_transparent_state_001
];

function eq_table_key(f, ik1, ik2) {
  if (ik1 === ik2) {
    return /* true */1;
  } else {
    switch (ik1.tag | 0) {
      case 0 : 
          switch (ik2.tag | 0) {
            case 0 : 
                return Curry._2(f, ik1[0], ik2[0]);
            case 1 : 
            case 2 : 
                return /* false */0;
            
          }
          break;
      case 1 : 
          switch (ik2.tag | 0) {
            case 1 : 
                return equal(ik1[0], ik2[0]);
            case 0 : 
            case 2 : 
                return /* false */0;
            
          }
          break;
      case 2 : 
          switch (ik2.tag | 0) {
            case 0 : 
            case 1 : 
                return /* false */0;
            case 2 : 
                return +(ik1[0] === ik2[0]);
            
          }
          break;
      
    }
  }
}

function eq_ind_chk(param, param$1) {
  if (param[1] === param$1[1]) {
    return equal$6(param[0], param$1[0]);
  } else {
    return /* false */0;
  }
}

function make$4(c, b) {
  return /* tuple */[
          c,
          b
        ];
}

function constant(prim) {
  return prim[0];
}

function unfolded(prim) {
  return prim[1];
}

function unfold(p) {
  if (p[1]) {
    return p;
  } else {
    return /* tuple */[
            p[0],
            /* true */1
          ];
  }
}

function equal$9(param, param$1) {
  if (equal$7(param[0], param$1[0])) {
    return +(param[1] === param$1[1]);
  } else {
    return /* false */0;
  }
}

function hash$11(param) {
  return (
          param[1] ? 0 : 1
        ) + hash$6(canonical(param[0])) | 0;
}

function compare$9(param, param$1) {
  if (Caml_obj.caml_equal(param[1], param$1[1])) {
    return compare$8(param[0], param$1[0]);
  } else {
    return -1;
  }
}

function equal$10(x, x$prime) {
  if (x === x$prime) {
    return /* true */1;
  } else if (Caml_obj.caml_equal(x[1], x$prime[1])) {
    return equal$8(x[0], x$prime[0]);
  } else {
    return /* false */0;
  }
}

function hash$12(param) {
  return (
          param[1] ? 0 : 1
        ) + hash$9(param[0]) | 0;
}

var SyntacticOrd$1 = /* module */[
  /* compare */compare$9,
  /* equal */equal$10,
  /* hash */hash$12
];

function hashcons$7(hc, param) {
  return /* tuple */[
          Curry._1(hc, param[0]),
          param[1]
        ];
}

function eq$7(x, y) {
  if (x === y) {
    return /* true */1;
  } else if (x[0] === y[0]) {
    return +(x[1] === y[1]);
  } else {
    return /* false */0;
  }
}

var Self_Hashcons$5 = /* module */[
  /* hashcons */hashcons$7,
  /* eq */eq$7,
  /* hash */hash$11
];

var HashProjection = Hashcons$ReactTemplate.Make(Self_Hashcons$5);

var hcons$6 = Hashcons$ReactTemplate.simple_hcons(HashProjection[/* generate */0], HashProjection[/* hcons */1], hcons_con);

function compare$10(param, param$1) {
  var b = param[1];
  if (b === param$1[1]) {
    return compare$7(param[0], param$1[0]);
  } else if (b) {
    return 1;
  } else {
    return -1;
  }
}

function map(f, x) {
  var c = x[0];
  var c$prime = Curry._1(f, c);
  if (c$prime === c) {
    return x;
  } else {
    return /* tuple */[
            c$prime,
            x[1]
          ];
  }
}

function to_string$6(p) {
  return to_string_gen(to_string$3, p[0][0]);
}

function print$5(p) {
  return Pp$ReactTemplate.str(to_string_gen(to_string$3, p[0][0]));
}

var Id_012 = Util$ReactTemplate.$$String[/* List */40];

var Id = [
  equal,
  compare,
  hash,
  is_valid,
  of_bytes,
  of_string,
  of_string_soft,
  to_string,
  print,
  $$Set,
  $$Map,
  Pred,
  Id_012,
  hcons
];

var Name = [
  mk_name,
  is_anonymous,
  is_name,
  compare$1,
  equal$1,
  hash$1,
  hcons$1,
  print$1
];

var ModIdset = $$Set;

var ModIdmap = $$Map;

var DirPath = [
  equal$2,
  compare$2,
  hash$3,
  make,
  repr,
  /* [] */0,
  is_empty,
  to_string$1,
  initial,
  hcons$2,
  print$2
];

var Label = [
  equal,
  compare,
  hash,
  of_string,
  to_string,
  of_id,
  to_id$1,
  print,
  $$Set,
  $$Map,
  hcons
];

var MBId = [
  equal$3,
  compare$3,
  hash$4,
  make$1,
  repr$1,
  to_id,
  to_string$2,
  debug_to_string
];

var ModPath = [
  compare$4,
  equal$4,
  hash$5,
  is_bound,
  to_string$3,
  debug_to_string$1,
  initial$1,
  dp
];

var KerName = [
  make$2,
  make2,
  repr$2,
  modpath,
  label,
  to_string$4,
  debug_to_string$2,
  print$3,
  compare$5,
  equal$5,
  hash$6
];

var KNset = KNmap[/* Set */24];

var KNmap_000 = KNmap[0];

var KNmap_001 = KNmap[1];

var KNmap_002 = KNmap[2];

var KNmap_003 = KNmap[3];

var KNmap_004 = KNmap[4];

var KNmap_005 = KNmap[5];

var KNmap_006 = KNmap[6];

var KNmap_007 = KNmap[7];

var KNmap_008 = KNmap[8];

var KNmap_009 = KNmap[9];

var KNmap_010 = KNmap[10];

var KNmap_011 = KNmap[11];

var KNmap_012 = KNmap[12];

var KNmap_013 = KNmap[13];

var KNmap_014 = KNmap[14];

var KNmap_015 = KNmap[15];

var KNmap_016 = KNmap[16];

var KNmap_017 = KNmap[17];

var KNmap_018 = KNmap[18];

var KNmap_019 = KNmap[19];

var KNmap_020 = KNmap[20];

var KNmap_021 = KNmap[21];

var KNmap_022 = KNmap[22];

var KNmap_023 = KNmap[23];

var KNmap_024 = KNmap[25];

var KNmap_025 = KNmap[26];

var KNmap_026 = KNmap[27];

var KNmap_027 = KNmap[28];

var KNmap_028 = KNmap[29];

var KNmap_029 = KNmap[30];

var KNmap_030 = KNmap[31];

var KNmap_031 = KNmap[32];

var KNmap_032 = KNmap[33];

var KNmap_033 = KNmap[34];

var KNmap_034 = KNmap[35];

var KNmap_035 = KNmap[36];

var KNmap$1 = [
  KNmap_000,
  KNmap_001,
  KNmap_002,
  KNmap_003,
  KNmap_004,
  KNmap_005,
  KNmap_006,
  KNmap_007,
  KNmap_008,
  KNmap_009,
  KNmap_010,
  KNmap_011,
  KNmap_012,
  KNmap_013,
  KNmap_014,
  KNmap_015,
  KNmap_016,
  KNmap_017,
  KNmap_018,
  KNmap_019,
  KNmap_020,
  KNmap_021,
  KNmap_022,
  KNmap_023,
  KNmap_024,
  KNmap_025,
  KNmap_026,
  KNmap_027,
  KNmap_028,
  KNmap_029,
  KNmap_030,
  KNmap_031,
  KNmap_032,
  KNmap_033,
  KNmap_034,
  KNmap_035
];

var Constant = [
  make$3,
  same,
  make2$1,
  make3,
  user,
  canonical,
  repr3,
  modpath$1,
  label$1,
  CanOrd,
  UserOrd,
  SyntacticOrd,
  equal$7,
  hash$8,
  change_label,
  to_string$5,
  print$4,
  debug_to_string$3,
  debug_print
];

var Cset = Cmap[/* Set */24];

var Cset_env = Cmap_env[/* Set */24];

var Cmap_000 = Cmap[0];

var Cmap_001 = Cmap[1];

var Cmap_002 = Cmap[2];

var Cmap_003 = Cmap[3];

var Cmap_004 = Cmap[4];

var Cmap_005 = Cmap[5];

var Cmap_006 = Cmap[6];

var Cmap_007 = Cmap[7];

var Cmap_008 = Cmap[8];

var Cmap_009 = Cmap[9];

var Cmap_010 = Cmap[10];

var Cmap_011 = Cmap[11];

var Cmap_012 = Cmap[12];

var Cmap_013 = Cmap[13];

var Cmap_014 = Cmap[14];

var Cmap_015 = Cmap[15];

var Cmap_016 = Cmap[16];

var Cmap_017 = Cmap[17];

var Cmap_018 = Cmap[18];

var Cmap_019 = Cmap[19];

var Cmap_020 = Cmap[20];

var Cmap_021 = Cmap[21];

var Cmap_022 = Cmap[22];

var Cmap_023 = Cmap[23];

var Cmap_024 = Cmap[25];

var Cmap_025 = Cmap[26];

var Cmap_026 = Cmap[27];

var Cmap_027 = Cmap[28];

var Cmap_028 = Cmap[29];

var Cmap_029 = Cmap[30];

var Cmap_030 = Cmap[31];

var Cmap_031 = Cmap[32];

var Cmap_032 = Cmap[33];

var Cmap_033 = Cmap[34];

var Cmap_034 = Cmap[35];

var Cmap_035 = Cmap[36];

var Cmap$1 = [
  Cmap_000,
  Cmap_001,
  Cmap_002,
  Cmap_003,
  Cmap_004,
  Cmap_005,
  Cmap_006,
  Cmap_007,
  Cmap_008,
  Cmap_009,
  Cmap_010,
  Cmap_011,
  Cmap_012,
  Cmap_013,
  Cmap_014,
  Cmap_015,
  Cmap_016,
  Cmap_017,
  Cmap_018,
  Cmap_019,
  Cmap_020,
  Cmap_021,
  Cmap_022,
  Cmap_023,
  Cmap_024,
  Cmap_025,
  Cmap_026,
  Cmap_027,
  Cmap_028,
  Cmap_029,
  Cmap_030,
  Cmap_031,
  Cmap_032,
  Cmap_033,
  Cmap_034,
  Cmap_035
];

var Cmap_env_000 = Cmap_env[0];

var Cmap_env_001 = Cmap_env[1];

var Cmap_env_002 = Cmap_env[2];

var Cmap_env_003 = Cmap_env[3];

var Cmap_env_004 = Cmap_env[4];

var Cmap_env_005 = Cmap_env[5];

var Cmap_env_006 = Cmap_env[6];

var Cmap_env_007 = Cmap_env[7];

var Cmap_env_008 = Cmap_env[8];

var Cmap_env_009 = Cmap_env[9];

var Cmap_env_010 = Cmap_env[10];

var Cmap_env_011 = Cmap_env[11];

var Cmap_env_012 = Cmap_env[12];

var Cmap_env_013 = Cmap_env[13];

var Cmap_env_014 = Cmap_env[14];

var Cmap_env_015 = Cmap_env[15];

var Cmap_env_016 = Cmap_env[16];

var Cmap_env_017 = Cmap_env[17];

var Cmap_env_018 = Cmap_env[18];

var Cmap_env_019 = Cmap_env[19];

var Cmap_env_020 = Cmap_env[20];

var Cmap_env_021 = Cmap_env[21];

var Cmap_env_022 = Cmap_env[22];

var Cmap_env_023 = Cmap_env[23];

var Cmap_env_024 = Cmap_env[25];

var Cmap_env_025 = Cmap_env[26];

var Cmap_env_026 = Cmap_env[27];

var Cmap_env_027 = Cmap_env[28];

var Cmap_env_028 = Cmap_env[29];

var Cmap_env_029 = Cmap_env[30];

var Cmap_env_030 = Cmap_env[31];

var Cmap_env_031 = Cmap_env[32];

var Cmap_env_032 = Cmap_env[33];

var Cmap_env_033 = Cmap_env[34];

var Cmap_env_034 = Cmap_env[35];

var Cmap_env_035 = Cmap_env[36];

var Cmap_env$1 = [
  Cmap_env_000,
  Cmap_env_001,
  Cmap_env_002,
  Cmap_env_003,
  Cmap_env_004,
  Cmap_env_005,
  Cmap_env_006,
  Cmap_env_007,
  Cmap_env_008,
  Cmap_env_009,
  Cmap_env_010,
  Cmap_env_011,
  Cmap_env_012,
  Cmap_env_013,
  Cmap_env_014,
  Cmap_env_015,
  Cmap_env_016,
  Cmap_env_017,
  Cmap_env_018,
  Cmap_env_019,
  Cmap_env_020,
  Cmap_env_021,
  Cmap_env_022,
  Cmap_env_023,
  Cmap_env_024,
  Cmap_env_025,
  Cmap_env_026,
  Cmap_env_027,
  Cmap_env_028,
  Cmap_env_029,
  Cmap_env_030,
  Cmap_env_031,
  Cmap_env_032,
  Cmap_env_033,
  Cmap_env_034,
  Cmap_env_035
];

var MutInd = [
  make$3,
  same,
  make2$1,
  make3,
  user,
  canonical,
  repr3,
  modpath$1,
  label$1,
  CanOrd,
  UserOrd,
  SyntacticOrd,
  equal$7,
  hash$8,
  to_string$5,
  print$4,
  debug_to_string$3,
  debug_print
];

var Mindset = Mindmap[/* Set */24];

var Mindmap_000 = Mindmap[0];

var Mindmap_001 = Mindmap[1];

var Mindmap_002 = Mindmap[2];

var Mindmap_003 = Mindmap[3];

var Mindmap_004 = Mindmap[4];

var Mindmap_005 = Mindmap[5];

var Mindmap_006 = Mindmap[6];

var Mindmap_007 = Mindmap[7];

var Mindmap_008 = Mindmap[8];

var Mindmap_009 = Mindmap[9];

var Mindmap_010 = Mindmap[10];

var Mindmap_011 = Mindmap[11];

var Mindmap_012 = Mindmap[12];

var Mindmap_013 = Mindmap[13];

var Mindmap_014 = Mindmap[14];

var Mindmap_015 = Mindmap[15];

var Mindmap_016 = Mindmap[16];

var Mindmap_017 = Mindmap[17];

var Mindmap_018 = Mindmap[18];

var Mindmap_019 = Mindmap[19];

var Mindmap_020 = Mindmap[20];

var Mindmap_021 = Mindmap[21];

var Mindmap_022 = Mindmap[22];

var Mindmap_023 = Mindmap[23];

var Mindmap_024 = Mindmap[25];

var Mindmap_025 = Mindmap[26];

var Mindmap_026 = Mindmap[27];

var Mindmap_027 = Mindmap[28];

var Mindmap_028 = Mindmap[29];

var Mindmap_029 = Mindmap[30];

var Mindmap_030 = Mindmap[31];

var Mindmap_031 = Mindmap[32];

var Mindmap_032 = Mindmap[33];

var Mindmap_033 = Mindmap[34];

var Mindmap_034 = Mindmap[35];

var Mindmap_035 = Mindmap[36];

var Mindmap$1 = [
  Mindmap_000,
  Mindmap_001,
  Mindmap_002,
  Mindmap_003,
  Mindmap_004,
  Mindmap_005,
  Mindmap_006,
  Mindmap_007,
  Mindmap_008,
  Mindmap_009,
  Mindmap_010,
  Mindmap_011,
  Mindmap_012,
  Mindmap_013,
  Mindmap_014,
  Mindmap_015,
  Mindmap_016,
  Mindmap_017,
  Mindmap_018,
  Mindmap_019,
  Mindmap_020,
  Mindmap_021,
  Mindmap_022,
  Mindmap_023,
  Mindmap_024,
  Mindmap_025,
  Mindmap_026,
  Mindmap_027,
  Mindmap_028,
  Mindmap_029,
  Mindmap_030,
  Mindmap_031,
  Mindmap_032,
  Mindmap_033,
  Mindmap_034,
  Mindmap_035
];

var Mindmap_env_000 = Mindmap_env[0];

var Mindmap_env_001 = Mindmap_env[1];

var Mindmap_env_002 = Mindmap_env[2];

var Mindmap_env_003 = Mindmap_env[3];

var Mindmap_env_004 = Mindmap_env[4];

var Mindmap_env_005 = Mindmap_env[5];

var Mindmap_env_006 = Mindmap_env[6];

var Mindmap_env_007 = Mindmap_env[7];

var Mindmap_env_008 = Mindmap_env[8];

var Mindmap_env_009 = Mindmap_env[9];

var Mindmap_env_010 = Mindmap_env[10];

var Mindmap_env_011 = Mindmap_env[11];

var Mindmap_env_012 = Mindmap_env[12];

var Mindmap_env_013 = Mindmap_env[13];

var Mindmap_env_014 = Mindmap_env[14];

var Mindmap_env_015 = Mindmap_env[15];

var Mindmap_env_016 = Mindmap_env[16];

var Mindmap_env_017 = Mindmap_env[17];

var Mindmap_env_018 = Mindmap_env[18];

var Mindmap_env_019 = Mindmap_env[19];

var Mindmap_env_020 = Mindmap_env[20];

var Mindmap_env_021 = Mindmap_env[21];

var Mindmap_env_022 = Mindmap_env[22];

var Mindmap_env_023 = Mindmap_env[23];

var Mindmap_env$1 = [
  Mindmap_env_000,
  Mindmap_env_001,
  Mindmap_env_002,
  Mindmap_env_003,
  Mindmap_env_004,
  Mindmap_env_005,
  Mindmap_env_006,
  Mindmap_env_007,
  Mindmap_env_008,
  Mindmap_env_009,
  Mindmap_env_010,
  Mindmap_env_011,
  Mindmap_env_012,
  Mindmap_env_013,
  Mindmap_env_014,
  Mindmap_env_015,
  Mindmap_env_016,
  Mindmap_env_017,
  Mindmap_env_018,
  Mindmap_env_019,
  Mindmap_env_020,
  Mindmap_env_021,
  Mindmap_env_022,
  Mindmap_env_023
];

var Indmap_000 = Indmap[0];

var Indmap_001 = Indmap[1];

var Indmap_002 = Indmap[2];

var Indmap_003 = Indmap[3];

var Indmap_004 = Indmap[4];

var Indmap_005 = Indmap[5];

var Indmap_006 = Indmap[6];

var Indmap_007 = Indmap[7];

var Indmap_008 = Indmap[8];

var Indmap_009 = Indmap[9];

var Indmap_010 = Indmap[10];

var Indmap_011 = Indmap[11];

var Indmap_012 = Indmap[12];

var Indmap_013 = Indmap[13];

var Indmap_014 = Indmap[14];

var Indmap_015 = Indmap[15];

var Indmap_016 = Indmap[16];

var Indmap_017 = Indmap[17];

var Indmap_018 = Indmap[18];

var Indmap_019 = Indmap[19];

var Indmap_020 = Indmap[20];

var Indmap_021 = Indmap[21];

var Indmap_022 = Indmap[22];

var Indmap_023 = Indmap[23];

var Indmap$1 = [
  Indmap_000,
  Indmap_001,
  Indmap_002,
  Indmap_003,
  Indmap_004,
  Indmap_005,
  Indmap_006,
  Indmap_007,
  Indmap_008,
  Indmap_009,
  Indmap_010,
  Indmap_011,
  Indmap_012,
  Indmap_013,
  Indmap_014,
  Indmap_015,
  Indmap_016,
  Indmap_017,
  Indmap_018,
  Indmap_019,
  Indmap_020,
  Indmap_021,
  Indmap_022,
  Indmap_023
];

var Constrmap_000 = Constrmap[0];

var Constrmap_001 = Constrmap[1];

var Constrmap_002 = Constrmap[2];

var Constrmap_003 = Constrmap[3];

var Constrmap_004 = Constrmap[4];

var Constrmap_005 = Constrmap[5];

var Constrmap_006 = Constrmap[6];

var Constrmap_007 = Constrmap[7];

var Constrmap_008 = Constrmap[8];

var Constrmap_009 = Constrmap[9];

var Constrmap_010 = Constrmap[10];

var Constrmap_011 = Constrmap[11];

var Constrmap_012 = Constrmap[12];

var Constrmap_013 = Constrmap[13];

var Constrmap_014 = Constrmap[14];

var Constrmap_015 = Constrmap[15];

var Constrmap_016 = Constrmap[16];

var Constrmap_017 = Constrmap[17];

var Constrmap_018 = Constrmap[18];

var Constrmap_019 = Constrmap[19];

var Constrmap_020 = Constrmap[20];

var Constrmap_021 = Constrmap[21];

var Constrmap_022 = Constrmap[22];

var Constrmap_023 = Constrmap[23];

var Constrmap$1 = [
  Constrmap_000,
  Constrmap_001,
  Constrmap_002,
  Constrmap_003,
  Constrmap_004,
  Constrmap_005,
  Constrmap_006,
  Constrmap_007,
  Constrmap_008,
  Constrmap_009,
  Constrmap_010,
  Constrmap_011,
  Constrmap_012,
  Constrmap_013,
  Constrmap_014,
  Constrmap_015,
  Constrmap_016,
  Constrmap_017,
  Constrmap_018,
  Constrmap_019,
  Constrmap_020,
  Constrmap_021,
  Constrmap_022,
  Constrmap_023
];

var Indmap_env_000 = Indmap_env[0];

var Indmap_env_001 = Indmap_env[1];

var Indmap_env_002 = Indmap_env[2];

var Indmap_env_003 = Indmap_env[3];

var Indmap_env_004 = Indmap_env[4];

var Indmap_env_005 = Indmap_env[5];

var Indmap_env_006 = Indmap_env[6];

var Indmap_env_007 = Indmap_env[7];

var Indmap_env_008 = Indmap_env[8];

var Indmap_env_009 = Indmap_env[9];

var Indmap_env_010 = Indmap_env[10];

var Indmap_env_011 = Indmap_env[11];

var Indmap_env_012 = Indmap_env[12];

var Indmap_env_013 = Indmap_env[13];

var Indmap_env_014 = Indmap_env[14];

var Indmap_env_015 = Indmap_env[15];

var Indmap_env_016 = Indmap_env[16];

var Indmap_env_017 = Indmap_env[17];

var Indmap_env_018 = Indmap_env[18];

var Indmap_env_019 = Indmap_env[19];

var Indmap_env_020 = Indmap_env[20];

var Indmap_env_021 = Indmap_env[21];

var Indmap_env_022 = Indmap_env[22];

var Indmap_env_023 = Indmap_env[23];

var Indmap_env$1 = [
  Indmap_env_000,
  Indmap_env_001,
  Indmap_env_002,
  Indmap_env_003,
  Indmap_env_004,
  Indmap_env_005,
  Indmap_env_006,
  Indmap_env_007,
  Indmap_env_008,
  Indmap_env_009,
  Indmap_env_010,
  Indmap_env_011,
  Indmap_env_012,
  Indmap_env_013,
  Indmap_env_014,
  Indmap_env_015,
  Indmap_env_016,
  Indmap_env_017,
  Indmap_env_018,
  Indmap_env_019,
  Indmap_env_020,
  Indmap_env_021,
  Indmap_env_022,
  Indmap_env_023
];

var Constrmap_env_000 = Constrmap_env[0];

var Constrmap_env_001 = Constrmap_env[1];

var Constrmap_env_002 = Constrmap_env[2];

var Constrmap_env_003 = Constrmap_env[3];

var Constrmap_env_004 = Constrmap_env[4];

var Constrmap_env_005 = Constrmap_env[5];

var Constrmap_env_006 = Constrmap_env[6];

var Constrmap_env_007 = Constrmap_env[7];

var Constrmap_env_008 = Constrmap_env[8];

var Constrmap_env_009 = Constrmap_env[9];

var Constrmap_env_010 = Constrmap_env[10];

var Constrmap_env_011 = Constrmap_env[11];

var Constrmap_env_012 = Constrmap_env[12];

var Constrmap_env_013 = Constrmap_env[13];

var Constrmap_env_014 = Constrmap_env[14];

var Constrmap_env_015 = Constrmap_env[15];

var Constrmap_env_016 = Constrmap_env[16];

var Constrmap_env_017 = Constrmap_env[17];

var Constrmap_env_018 = Constrmap_env[18];

var Constrmap_env_019 = Constrmap_env[19];

var Constrmap_env_020 = Constrmap_env[20];

var Constrmap_env_021 = Constrmap_env[21];

var Constrmap_env_022 = Constrmap_env[22];

var Constrmap_env_023 = Constrmap_env[23];

var Constrmap_env$1 = [
  Constrmap_env_000,
  Constrmap_env_001,
  Constrmap_env_002,
  Constrmap_env_003,
  Constrmap_env_004,
  Constrmap_env_005,
  Constrmap_env_006,
  Constrmap_env_007,
  Constrmap_env_008,
  Constrmap_env_009,
  Constrmap_env_010,
  Constrmap_env_011,
  Constrmap_env_012,
  Constrmap_env_013,
  Constrmap_env_014,
  Constrmap_env_015,
  Constrmap_env_016,
  Constrmap_env_017,
  Constrmap_env_018,
  Constrmap_env_019,
  Constrmap_env_020,
  Constrmap_env_021,
  Constrmap_env_022,
  Constrmap_env_023
];

var eq_constant_key = equal$6;

var eq_con_chk = equal$6;

var string_of_id = to_string;

var id_of_string = of_string;

var id_ord = compare;

var id_eq = equal;

var Idset = $$Set;

var Idpred = Pred;

var Idmap = $$Map;

var dir_path_ord = compare$2;

var dir_path_eq = equal$2;

var make_dirpath = make;

var repr_dirpath = repr;

var empty_dirpath = /* [] */0;

var is_empty_dirpath = is_empty;

var string_of_dirpath = to_string$1;

var initial_dir = initial;

var mk_label = of_string;

var string_of_label = to_string;

var pr_label = print;

var label_of_id = of_id;

var id_of_label = to_id$1;

var eq_label = equal;

var mod_bound_id_ord = compare$3;

var mod_bound_id_eq = equal$3;

var make_mbid = make$1;

var repr_mbid = repr$1;

var id_of_mbid = to_id;

var string_of_mbid = to_string$2;

var debug_string_of_mbid = debug_to_string;

var name_eq = equal$1;

var mp_ord = compare$4;

var mp_eq = equal$4;

var check_bound_mp = is_bound;

var string_of_mp = to_string$3;

var initial_path = initial$1;

var make_kn = make$2;

var repr_kn = repr$2;

var string_of_kn = to_string$4;

var pr_kn = print$3;

var kn_ord = compare$5;

var Projection = [
  make$4,
  SyntacticOrd$1,
  constant,
  unfolded,
  unfold,
  equal$9,
  hash$11,
  hcons$6,
  compare$10,
  map,
  to_string$6,
  print$5
];

var constant_of_kn_equiv = make$3;

var constant_of_kn = same;

var make_con = make3;

var repr_con = repr3;

var user_con = user;

var canonical_con = canonical;

var con_modpath = modpath$1;

var con_label = label$1;

var eq_constant = equal$7;

var con_ord = compare$7;

var con_user_ord = compare$6;

var con_with_label = change_label;

var string_of_con = to_string$5;

var pr_con = print$4;

var debug_pr_con = debug_print;

var debug_string_of_con = debug_to_string$3;

var mind_of_kn = same;

var mind_of_kn_equiv = make$3;

var make_mind = make3;

var user_mind = user;

var canonical_mind = canonical;

var repr_mind = repr3;

var eq_mind = equal$7;

var mind_ord = compare$7;

var mind_user_ord = compare$6;

var mind_label = label$1;

var mind_modpath = modpath$1;

var string_of_mind = to_string$5;

var pr_mind = print$4;

var debug_pr_mind = debug_print;

var debug_string_of_mind = debug_to_string$3;

exports.Id = Id;
exports.Name = Name;
exports.ModIdset = ModIdset;
exports.ModIdmap = ModIdmap;
exports.DirPath = DirPath;
exports.Label = Label;
exports.MBId = MBId;
exports.MBIset = MBIset;
exports.MBImap = MBImap;
exports.ModPath = ModPath;
exports.MPset = MPset;
exports.MPmap = MPmap;
exports.KerName = KerName;
exports.KNset = KNset;
exports.KNpred = KNpred;
exports.KNmap = KNmap$1;
exports.Constant = Constant;
exports.Cpred = Cpred;
exports.Cset = Cset;
exports.Cset_env = Cset_env;
exports.Cmap = Cmap$1;
exports.Cmap_env = Cmap_env$1;
exports.MutInd = MutInd;
exports.Mindset = Mindset;
exports.Mindmap = Mindmap$1;
exports.Mindmap_env = Mindmap_env$1;
exports.Indmap = Indmap$1;
exports.Constrmap = Constrmap$1;
exports.Indmap_env = Indmap_env$1;
exports.Constrmap_env = Constrmap_env$1;
exports.ind_modpath = ind_modpath;
exports.constr_modpath = constr_modpath;
exports.ith_mutual_inductive = ith_mutual_inductive;
exports.ith_constructor_of_inductive = ith_constructor_of_inductive;
exports.inductive_of_constructor = inductive_of_constructor;
exports.index_of_constructor = index_of_constructor;
exports.eq_ind = eq_ind;
exports.eq_user_ind = eq_user_ind;
exports.eq_syntactic_ind = eq_syntactic_ind;
exports.ind_ord = ind_ord;
exports.ind_hash = ind_hash;
exports.ind_user_ord = ind_user_ord;
exports.ind_user_hash = ind_user_hash;
exports.ind_syntactic_ord = ind_syntactic_ord;
exports.ind_syntactic_hash = ind_syntactic_hash;
exports.eq_constructor = eq_constructor;
exports.eq_user_constructor = eq_user_constructor;
exports.eq_syntactic_constructor = eq_syntactic_constructor;
exports.constructor_ord = constructor_ord;
exports.constructor_hash = constructor_hash;
exports.constructor_user_ord = constructor_user_ord;
exports.constructor_user_hash = constructor_user_hash;
exports.constructor_syntactic_ord = constructor_syntactic_ord;
exports.constructor_syntactic_hash = constructor_syntactic_hash;
exports.eq_egr = eq_egr;
exports.hcons_con = hcons_con;
exports.hcons_mind = hcons_mind;
exports.hcons_ind = hcons_ind;
exports.hcons_construct = hcons_construct;
exports.empty_transparent_state = empty_transparent_state;
exports.full_transparent_state = full_transparent_state;
exports.var_full_transparent_state = var_full_transparent_state;
exports.cst_full_transparent_state = cst_full_transparent_state;
exports.eq_table_key = eq_table_key;
exports.eq_constant_key = eq_constant_key;
exports.eq_con_chk = eq_con_chk;
exports.eq_ind_chk = eq_ind_chk;
exports.string_of_id = string_of_id;
exports.id_of_string = id_of_string;
exports.id_ord = id_ord;
exports.id_eq = id_eq;
exports.Idset = Idset;
exports.Idpred = Idpred;
exports.Idmap = Idmap;
exports.dir_path_ord = dir_path_ord;
exports.dir_path_eq = dir_path_eq;
exports.make_dirpath = make_dirpath;
exports.repr_dirpath = repr_dirpath;
exports.empty_dirpath = empty_dirpath;
exports.is_empty_dirpath = is_empty_dirpath;
exports.string_of_dirpath = string_of_dirpath;
exports.initial_dir = initial_dir;
exports.mk_label = mk_label;
exports.string_of_label = string_of_label;
exports.pr_label = pr_label;
exports.label_of_id = label_of_id;
exports.id_of_label = id_of_label;
exports.eq_label = eq_label;
exports.mod_bound_id_ord = mod_bound_id_ord;
exports.mod_bound_id_eq = mod_bound_id_eq;
exports.make_mbid = make_mbid;
exports.repr_mbid = repr_mbid;
exports.id_of_mbid = id_of_mbid;
exports.string_of_mbid = string_of_mbid;
exports.debug_string_of_mbid = debug_string_of_mbid;
exports.name_eq = name_eq;
exports.mp_ord = mp_ord;
exports.mp_eq = mp_eq;
exports.check_bound_mp = check_bound_mp;
exports.string_of_mp = string_of_mp;
exports.initial_path = initial_path;
exports.make_kn = make_kn;
exports.repr_kn = repr_kn;
exports.modpath = modpath;
exports.label = label;
exports.string_of_kn = string_of_kn;
exports.pr_kn = pr_kn;
exports.kn_ord = kn_ord;
exports.Projection = Projection;
exports.constant_of_kn_equiv = constant_of_kn_equiv;
exports.constant_of_kn = constant_of_kn;
exports.make_con = make_con;
exports.repr_con = repr_con;
exports.user_con = user_con;
exports.canonical_con = canonical_con;
exports.con_modpath = con_modpath;
exports.con_label = con_label;
exports.eq_constant = eq_constant;
exports.con_ord = con_ord;
exports.con_user_ord = con_user_ord;
exports.con_with_label = con_with_label;
exports.string_of_con = string_of_con;
exports.pr_con = pr_con;
exports.debug_pr_con = debug_pr_con;
exports.debug_string_of_con = debug_string_of_con;
exports.mind_of_kn = mind_of_kn;
exports.mind_of_kn_equiv = mind_of_kn_equiv;
exports.make_mind = make_mind;
exports.user_mind = user_mind;
exports.canonical_mind = canonical_mind;
exports.repr_mind = repr_mind;
exports.eq_mind = eq_mind;
exports.mind_ord = mind_ord;
exports.mind_user_ord = mind_user_ord;
exports.mind_label = mind_label;
exports.mind_modpath = mind_modpath;
exports.string_of_mind = string_of_mind;
exports.pr_mind = pr_mind;
exports.debug_pr_mind = debug_pr_mind;
exports.debug_string_of_mind = debug_string_of_mind;
/* Set Not a pure module */
