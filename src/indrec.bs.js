// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Evarutil$ReactTemplate = require("./evarutil.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Universes$ReactTemplate = require("./universes.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");

var RecursionSchemeError = Caml_exceptions.create("Indrec-ReactTemplate.RecursionSchemeError");

function named_hd(env, t, na) {
  return Namegen$ReactTemplate.named_hd(env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(t), na);
}

function name_assumption(env, param) {
  if (param.tag) {
    var c = param[1];
    return /* LocalDef */Block.__(1, [
              named_hd(env, c, param[0]),
              c,
              param[2]
            ]);
  } else {
    var t = param[1];
    return /* LocalAssum */Block.__(0, [
              named_hd(env, t, param[0]),
              t
            ]);
  }
}

function mkLambda_or_LetIn_name(env, d, b) {
  return Term$ReactTemplate.mkLambda_or_LetIn(name_assumption(env, d), b);
}

function mkProd_or_LetIn_name(env, d, b) {
  return Term$ReactTemplate.mkProd_or_LetIn(name_assumption(env, d), b);
}

function mkLambda_name(env, param) {
  return mkLambda_or_LetIn_name(env, /* LocalAssum */Block.__(0, [
                param[0],
                param[1]
              ]), param[2]);
}

function it_mkProd_or_LetIn_name(env, b, l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (c, d) {
                return mkProd_or_LetIn_name(env, d, c);
              }), b, l);
}

function it_mkLambda_or_LetIn_name(env, b, l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (c, d) {
                return mkLambda_or_LetIn_name(env, d, c);
              }), b, l);
}

function make_prod_dep(dep, env) {
  if (dep) {
    return (function (param) {
        var env$1 = env;
        var param$1 = param;
        return mkProd_or_LetIn_name(env$1, /* LocalAssum */Block.__(0, [
                      param$1[0],
                      param$1[1]
                    ]), param$1[2]);
      });
  } else {
    return Constr$ReactTemplate.mkProd;
  }
}

function mkLambda_string(s, t, c) {
  return Constr$ReactTemplate.mkLambda(/* tuple */[
              /* Name */[Names$ReactTemplate.Id[/* of_string */5](s)],
              t,
              c
            ]);
}

function is_private(mib) {
  var match = mib[/* mind_private */9];
  if (match && match[0] !== 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function check_privacy_block(mib) {
  if (is_private(mib)) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("case analysis on a private inductive type"));
  } else {
    return 0;
  }
}

function mis_make_case_com(dep, env, sigma, pind, specif, kind) {
  var mip = specif[1];
  var mib = specif[0];
  var lnamespar = Vars$ReactTemplate.subst_instance_context(pind[1], mib[/* mind_params_ctxt */7]);
  var indf = Inductiveops$ReactTemplate.make_ind_family(/* tuple */[
        pind,
        Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, lnamespar)
      ]);
  var constrs = Inductiveops$ReactTemplate.get_constructors(env, indf);
  var projs = Inductiveops$ReactTemplate.get_projections(env, indf);
  if (Option$ReactTemplate.is_empty(projs)) {
    check_privacy_block(mib);
  }
  if (!Curry._2(Sorts$ReactTemplate.List[/* mem */0], kind, Inductive$ReactTemplate.elim_sorts(specif))) {
    throw [
          RecursionSchemeError,
          /* NotAllowedCaseAnalysis */Block.__(0, [
              /* false */0,
              Universes$ReactTemplate.fresh_sort_in_family(env, kind)[0],
              pind
            ])
        ];
  }
  var ndepar = mip[/* mind_nrealdecls */6] + 1 | 0;
  var env$prime = Environ$ReactTemplate.push_rel_context(lnamespar, env);
  var add_branch = function (env, k) {
    if (k === mip[/* mind_consnames */3].length) {
      var nbprod = k + 1 | 0;
      var indf$prime = Inductiveops$ReactTemplate.lift_inductive_family(nbprod)(indf);
      var match = Inductiveops$ReactTemplate.get_arity(env, indf$prime);
      var arsign = match[0];
      var depind = Inductiveops$ReactTemplate.build_dependent_inductive(env, indf$prime);
      var deparsign_000 = /* LocalAssum */Block.__(0, [
          /* Anonymous */0,
          depind
        ]);
      var deparsign = /* :: */[
        deparsign_000,
        arsign
      ];
      var ci = Inductiveops$ReactTemplate.make_case_info(env, pind[0], /* RegularStyle */4);
      var pbody = Term$ReactTemplate.appvect(/* tuple */[
            Constr$ReactTemplate.mkRel(ndepar + nbprod | 0),
            dep ? Context$ReactTemplate.Rel[/* to_extended_vect */13](Constr$ReactTemplate.mkRel, 0, deparsign) : Context$ReactTemplate.Rel[/* to_extended_vect */13](Constr$ReactTemplate.mkRel, 1, arsign)
          ]);
      var p = it_mkLambda_or_LetIn_name(env$prime, Curry._1(dep ? (function (param) {
                    return mkLambda_name(env$prime, param);
                  }) : Constr$ReactTemplate.mkLambda, /* tuple */[
                /* Anonymous */0,
                depind,
                pbody
              ]), arsign);
      var obj;
      if (projs) {
        var term = Constr$ReactTemplate.mkApp(/* tuple */[
              Constr$ReactTemplate.mkRel(2),
              Util$ReactTemplate.$$Array[/* map */12]((function (p) {
                      return Constr$ReactTemplate.mkProj(/* tuple */[
                                  Names$ReactTemplate.Projection[/* make */0](p, /* true */1),
                                  Constr$ReactTemplate.mkRel(1)
                                ]);
                    }), projs[0])
            ]);
        if (dep) {
          var ty = Constr$ReactTemplate.mkApp(/* tuple */[
                Constr$ReactTemplate.mkRel(3),
                /* array */[Constr$ReactTemplate.mkRel(1)]
              ]);
          obj = Constr$ReactTemplate.mkCast(/* tuple */[
                term,
                /* DEFAULTcast */2,
                ty
              ]);
        } else {
          obj = term;
        }
      } else {
        obj = Constr$ReactTemplate.mkCase(/* tuple */[
              ci,
              Vars$ReactTemplate.lift(ndepar)(p),
              Constr$ReactTemplate.mkRel(1),
              Termops$ReactTemplate.rel_vect(ndepar, k)
            ]);
      }
      return it_mkLambda_or_LetIn_name(env$prime, obj, deparsign);
    } else {
      var cs = Inductiveops$ReactTemplate.lift_constructor(k + 1 | 0, Caml_array.caml_array_get(constrs, k));
      var t = Inductiveops$ReactTemplate.build_branch_type(env, sigma, dep, Constr$ReactTemplate.mkRel(k + 1 | 0), cs);
      return mkLambda_string("f", t, add_branch(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                            /* Anonymous */0,
                            t
                          ]), env), k + 1 | 0));
    }
  };
  var match = Evd$ReactTemplate.fresh_sort_in_family(/* None */0, /* Some */[Evd$ReactTemplate.univ_flexible_alg], env, sigma, kind);
  var sigma$1 = match[0];
  var typP = Inductiveops$ReactTemplate.make_arity(env$prime, sigma$1, dep, indf, match[1]);
  var typP$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](typP);
  var c = it_mkLambda_or_LetIn_name(env, mkLambda_string("P", typP$1, add_branch(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      /* Anonymous */0,
                      typP$1
                    ]), env$prime), 0)), lnamespar);
  return /* tuple */[
          sigma$1,
          c
        ];
}

function type_rec_branch(is_rec, dep, env, sigma, param, tyi, cs, recargs) {
  var decP = param[2];
  var depPvect = param[1];
  var vargs = param[0];
  var make_prod = function (param) {
    return make_prod_dep(dep, param);
  };
  var nparams = Curry._1(Util$ReactTemplate.List[/* length */0], vargs);
  var process_pos = function (env, depK, pk) {
    var prec = function (env, i, sign, _p) {
      while(true) {
        var p = _p;
        var match = Reductionops$ReactTemplate.whd_allnolet_stack(env)(sigma, EConstr$ReactTemplate.of_constr(p));
        var p$prime = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[0]);
        var largs = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.Unsafe[/* to_constr */0], match[1]);
        var match$1 = Constr$ReactTemplate.kind(p$prime);
        var exit = 0;
        switch (match$1.tag | 0) {
          case 6 : 
              var t = match$1[1];
              var n = match$1[0];
              var d = /* LocalAssum */Block.__(0, [
                  n,
                  t
                ]);
              return Curry._1(make_prod(env), /* tuple */[
                          n,
                          t,
                          prec(Environ$ReactTemplate.push_rel(d, env), i + 1 | 0, /* :: */[
                                d,
                                sign
                              ], match$1[2])
                        ]);
          case 8 : 
              var t$1 = match$1[2];
              var b = match$1[1];
              var n$1 = match$1[0];
              if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], largs)) {
                var d$1 = /* LocalDef */Block.__(1, [
                    n$1,
                    b,
                    t$1
                  ]);
                return Constr$ReactTemplate.mkLetIn(/* tuple */[
                            n$1,
                            b,
                            t$1,
                            prec(Environ$ReactTemplate.push_rel(d$1, env), i + 1 | 0, /* :: */[
                                  d$1,
                                  sign
                                ], match$1[3])
                          ]);
              } else {
                exit = 1;
              }
              break;
          case 11 : 
              var realargs = Curry._2(Util$ReactTemplate.List[/* skipn */107], nparams, largs);
              var base = Term$ReactTemplate.applist(/* tuple */[
                    Vars$ReactTemplate.lift(i)(pk),
                    realargs
                  ]);
              if (depK) {
                return Reduction$ReactTemplate.beta_appvect(base, /* array */[Term$ReactTemplate.applist(/* tuple */[
                                  Constr$ReactTemplate.mkRel(i + 1 | 0),
                                  Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, sign)
                                ])]);
              } else {
                return base;
              }
          default:
            exit = 1;
        }
        if (exit === 1) {
          var t$prime = Reductionops$ReactTemplate.whd_all(env)(sigma, EConstr$ReactTemplate.of_constr(p));
          var t$prime$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](t$prime);
          if (Constr$ReactTemplate.equal(p$prime, t$prime$1)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "indrec.ml",
                    192,
                    31
                  ]
                ];
          } else {
            _p = t$prime$1;
            continue ;
            
          }
        }
        
      };
    };
    return (function (param) {
        return prec(env, 0, /* [] */0, param);
      });
  };
  var process_constr = function (env, i, c, recargs, nhyps, li) {
    if (nhyps > 0) {
      var match = Constr$ReactTemplate.kind(c);
      switch (match.tag | 0) {
        case 6 : 
            var c_0 = match[2];
            var t = match[1];
            var n = match[0];
            var match$1;
            if (recargs) {
              var rest = recargs[1];
              var match$2 = Declareops$ReactTemplate.dest_recarg(recargs[0]);
              match$1 = typeof match$2 === "number" ? /* tuple */[
                  /* None */0,
                  rest
                ] : (
                  match$2.tag ? /* tuple */[
                      /* None */0,
                      rest
                    ] : (
                      is_rec ? /* tuple */[
                          Caml_array.caml_array_get(depPvect, match$2[0][1]),
                          rest
                        ] : /* tuple */[
                          /* None */0,
                          rest
                        ]
                    )
                );
            } else {
              match$1 = /* tuple */[
                /* None */0,
                /* [] */0
              ];
            }
            var rest$1 = match$1[1];
            var optionpos = match$1[0];
            if (optionpos) {
              var match$3 = optionpos[0];
              var dep$prime = match$3[0];
              var nP = Vars$ReactTemplate.lift((i + 1 | 0) + decP | 0)(match$3[1]);
              var env$prime = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      n,
                      t
                    ]), env);
              var t_0 = process_pos(env$prime, dep$prime, nP)(Vars$ReactTemplate.lift(1)(t));
              return Curry._1(make_prod_dep(dep || dep$prime, env), /* tuple */[
                          n,
                          t,
                          Term$ReactTemplate.mkArrow(t_0, process_constr(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                          /* Anonymous */0,
                                          t_0
                                        ]), env$prime), i + 2 | 0, Vars$ReactTemplate.lift(1)(c_0), rest$1, nhyps - 1 | 0, /* :: */[
                                    i,
                                    li
                                  ]))
                        ]);
            } else {
              return Curry._1(make_prod(env), /* tuple */[
                          n,
                          t,
                          process_constr(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                      n,
                                      t
                                    ]), env), i + 1 | 0, c_0, rest$1, nhyps - 1 | 0, /* :: */[
                                i,
                                li
                              ])
                        ]);
            }
            break;
        case 8 : 
            var t$1 = match[2];
            var b = match[1];
            var n$1 = match[0];
            return Constr$ReactTemplate.mkLetIn(/* tuple */[
                        n$1,
                        b,
                        t$1,
                        process_constr(Environ$ReactTemplate.push_rel(/* LocalDef */Block.__(1, [
                                    n$1,
                                    b,
                                    t$1
                                  ]), env), i + 1 | 0, match[3], recargs, nhyps - 1 | 0, li)
                      ]);
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "indrec.ml",
                  230,
                  13
                ]
              ];
      }
    } else if (dep) {
      var realargs = Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (k) {
              return Constr$ReactTemplate.mkRel(i - k | 0);
            }), li);
      var params = Curry._2(Util$ReactTemplate.List[/* map */10], Vars$ReactTemplate.lift(i), vargs);
      var co = Term$ReactTemplate.applist(/* tuple */[
            Constr$ReactTemplate.mkConstructU(cs[/* cs_cstr */0]),
            Util$ReactTemplate.$at(params, realargs)
          ]);
      return Reduction$ReactTemplate.beta_appvect(c, /* array */[co]);
    } else {
      return c;
    }
  };
  var nhyps = Curry._1(Util$ReactTemplate.List[/* length */0], cs[/* cs_args */3]);
  var match = Caml_array.caml_array_get(depPvect, tyi);
  var nP;
  if (match) {
    nP = Vars$ReactTemplate.lift(nhyps + decP | 0)(match[0][1]);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "indrec.ml",
            242,
            11
          ]
        ];
  }
  var base = Term$ReactTemplate.appvect(/* tuple */[
        nP,
        cs[/* cs_concl_realargs */4]
      ]);
  var c = Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, base, cs[/* cs_args */3]);
  return process_constr(env, 0, c, recargs, nhyps, /* [] */0);
}

function mis_make_indrec(env, sigma, listdepkind, mib, u) {
  var nparams = mib[/* mind_nparams */5];
  var nparrec = mib[/* mind_nparams_rec */6];
  var evdref = [sigma];
  var match = Termops$ReactTemplate.context_chop(nparams - nparrec | 0, Vars$ReactTemplate.subst_instance_context(u, mib[/* mind_params_ctxt */7]));
  var lnamesparrec = match[1];
  var lnonparrec = match[0];
  var nrec = Curry._1(Util$ReactTemplate.List[/* length */0], listdepkind);
  var depPvec = Caml_array.caml_make_vect(mib[/* mind_ntypes */3], /* None */0);
  var assign = function (_k, _param) {
    while(true) {
      var param = _param;
      var k = _k;
      if (param) {
        var match = param[0];
        Caml_array.caml_array_set(depPvec, match[0][0][1], /* Some */[/* tuple */[
                match[3],
                Constr$ReactTemplate.mkRel(k)
              ]]);
        _param = param[1];
        _k = k - 1 | 0;
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  };
  assign(nrec, listdepkind);
  var recargsvec = Util$ReactTemplate.$$Array[/* map */12]((function (mip) {
          return mip[/* mind_recargs */11];
        }), mib[/* mind_packets */0]);
  var recargparn = function (_l, _n) {
    while(true) {
      var n = _n;
      var l = _l;
      if (n) {
        _n = n - 1 | 0;
        _l = /* :: */[
          Declareops$ReactTemplate.mk_norec,
          l
        ];
        continue ;
        
      } else {
        return l;
      }
    };
  };
  var recargpar = recargparn(/* [] */0, nparams - nparrec | 0);
  var make_one_rec = function (p) {
    var makefix = function (nbconstruct) {
      return (function (param) {
          var _i = 0;
          var _ln = /* [] */0;
          var _ltyp = /* [] */0;
          var _ldef = /* [] */0;
          var _param = param;
          while(true) {
            var param$1 = _param;
            var ldef = _ldef;
            var ltyp = _ltyp;
            var ln = _ln;
            var i = _i;
            if (param$1) {
              var match = param$1[0];
              var dep = match[3];
              var match$1 = match[0];
              var u = match$1[1];
              var indi = match$1[0];
              var tyi = indi[1];
              var nctyi = match[2][/* mind_consnames */3].length;
              var args = Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, nrec + nbconstruct | 0, lnamesparrec);
              var indf = Inductiveops$ReactTemplate.make_ind_family(/* tuple */[
                    /* tuple */[
                      indi,
                      u
                    ],
                    args
                  ]);
              var match$2 = Inductiveops$ReactTemplate.get_arity(env, indf);
              var arsign = match$2[0];
              var depind = Inductiveops$ReactTemplate.build_dependent_inductive(env, indf);
              var deparsign_000 = /* LocalAssum */Block.__(0, [
                  /* Anonymous */0,
                  depind
                ]);
              var deparsign = /* :: */[
                deparsign_000,
                arsign
              ];
              var nonrecpar = Curry._1(Context$ReactTemplate.Rel[/* length */3], lnonparrec);
              var larsign = Curry._1(Context$ReactTemplate.Rel[/* length */3], deparsign);
              var ndepar = larsign - nonrecpar | 0;
              var dect = (larsign + nrec | 0) + nbconstruct | 0;
              var args$prime = Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, dect + nrec | 0, lnamesparrec);
              var args$prime$prime = Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, ndepar, lnonparrec);
              var indf$prime = Inductiveops$ReactTemplate.make_ind_family(/* tuple */[
                    /* tuple */[
                      indi,
                      u
                    ],
                    Util$ReactTemplate.$at(args$prime, args$prime$prime)
                  ]);
              var constrs = Inductiveops$ReactTemplate.get_constructors(env, indf$prime);
              var fi = Termops$ReactTemplate.rel_vect((dect - i | 0) - nctyi | 0, nctyi);
              var vecfi = Util$ReactTemplate.$$Array[/* map */12]((function(ndepar){
                  return function (f) {
                    return Term$ReactTemplate.appvect(/* tuple */[
                                f,
                                Context$ReactTemplate.Rel[/* to_extended_vect */13](Constr$ReactTemplate.mkRel, ndepar, lnonparrec)
                              ]);
                  }
                  }(ndepar)), fi);
              var partial_arg = /* tuple */[
                nparrec,
                depPvec,
                larsign
              ];
              var partial_arg$1 = evdref[0];
              var branches = Util$ReactTemplate.$$Array[/* map3 */51]((function(partial_arg,partial_arg$1){
                  return function (param, param$1, param$2) {
                    var env$1 = env;
                    var sigma = partial_arg$1;
                    var param$3 = partial_arg;
                    var f = param;
                    var cstr = param$1;
                    var recargs = param$2;
                    var decF = param$3[2];
                    var fvect = param$3[1];
                    var nparrec = param$3[0];
                    var process_pos = function (env, fk) {
                      var prec = function (env, i, hyps, _p) {
                        while(true) {
                          var p = _p;
                          var match = Reductionops$ReactTemplate.whd_allnolet_stack(env)(sigma, EConstr$ReactTemplate.of_constr(p));
                          var p$prime = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[0]);
                          var largs = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.Unsafe[/* to_constr */0], match[1]);
                          var match$1 = Constr$ReactTemplate.kind(p$prime);
                          var exit = 0;
                          switch (match$1.tag | 0) {
                            case 6 : 
                                var t = match$1[1];
                                var n = match$1[0];
                                var d = /* LocalAssum */Block.__(0, [
                                    n,
                                    t
                                  ]);
                                return mkLambda_name(env, /* tuple */[
                                            n,
                                            t,
                                            prec(Environ$ReactTemplate.push_rel(d, env), i + 1 | 0, /* :: */[
                                                  d,
                                                  hyps
                                                ], match$1[2])
                                          ]);
                            case 8 : 
                                var t$1 = match$1[2];
                                var b = match$1[1];
                                var n$1 = match$1[0];
                                if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], largs)) {
                                  var d$1 = /* LocalDef */Block.__(1, [
                                      n$1,
                                      b,
                                      t$1
                                    ]);
                                  return Constr$ReactTemplate.mkLetIn(/* tuple */[
                                              n$1,
                                              b,
                                              t$1,
                                              prec(Environ$ReactTemplate.push_rel(d$1, env), i + 1 | 0, /* :: */[
                                                    d$1,
                                                    hyps
                                                  ], match$1[3])
                                            ]);
                                } else {
                                  exit = 1;
                                }
                                break;
                            case 11 : 
                                var realargs = Curry._2(Util$ReactTemplate.List[/* skipn */107], nparrec, largs);
                                var arg = Term$ReactTemplate.appvect(/* tuple */[
                                      Constr$ReactTemplate.mkRel(i + 1 | 0),
                                      Context$ReactTemplate.Rel[/* to_extended_vect */13](Constr$ReactTemplate.mkRel, 0, hyps)
                                    ]);
                                return Term$ReactTemplate.applist(/* tuple */[
                                            Vars$ReactTemplate.lift(i)(fk),
                                            Util$ReactTemplate.$at(realargs, /* :: */[
                                                  arg,
                                                  /* [] */0
                                                ])
                                          ]);
                            default:
                              exit = 1;
                          }
                          if (exit === 1) {
                            var t$prime = Reductionops$ReactTemplate.whd_all(env)(sigma, EConstr$ReactTemplate.of_constr(p));
                            var t$prime$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](t$prime);
                            if (Constr$ReactTemplate.equal(t$prime$1, p$prime)) {
                              throw [
                                    Caml_builtin_exceptions.assert_failure,
                                    [
                                      "indrec.ml",
                                      267,
                                      33
                                    ]
                                  ];
                            } else {
                              _p = t$prime$1;
                              continue ;
                              
                            }
                          }
                          
                        };
                      };
                      return (function (param) {
                          return prec(env, 0, /* [] */0, param);
                        });
                    };
                    var process_constr = function (env, i, f, param) {
                      var match = param[0];
                      if (match) {
                        var d = match[0];
                        if (d.tag) {
                          return Constr$ReactTemplate.mkLetIn(/* tuple */[
                                      d[0],
                                      d[1],
                                      d[2],
                                      process_constr(Environ$ReactTemplate.push_rel(d, env), i + 1 | 0, Vars$ReactTemplate.lift(1)(f), /* tuple */[
                                            match[1],
                                            param[1]
                                          ])
                                    ]);
                        } else {
                          var match$1 = param[1];
                          if (match$1) {
                            var rest = match$1[1];
                            var cprest = match[1];
                            var t = d[1];
                            var n = d[0];
                            var match$2 = Declareops$ReactTemplate.dest_recarg(match$1[0]);
                            var optionpos;
                            optionpos = typeof match$2 === "number" || match$2.tag ? /* None */0 : Caml_array.caml_array_get(fvect, match$2[0][1]);
                            if (optionpos) {
                              var nF = Vars$ReactTemplate.lift((i + 1 | 0) + decF | 0)(optionpos[0][1]);
                              var env$prime = Environ$ReactTemplate.push_rel(d, env);
                              var arg = process_pos(env$prime, nF)(Vars$ReactTemplate.lift(1)(t));
                              return mkLambda_name(env, /* tuple */[
                                          n,
                                          t,
                                          process_constr(env$prime, i + 1 | 0, EConstr$ReactTemplate.Unsafe[/* to_constr */0](Reductionops$ReactTemplate.whd_beta(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(Term$ReactTemplate.applist(/* tuple */[
                                                                Vars$ReactTemplate.lift(1)(f),
                                                                /* :: */[
                                                                  Constr$ReactTemplate.mkRel(1),
                                                                  /* :: */[
                                                                    arg,
                                                                    /* [] */0
                                                                  ]
                                                                ]
                                                              ])))), /* tuple */[
                                                cprest,
                                                rest
                                              ])
                                        ]);
                            } else {
                              return mkLambda_name(env, /* tuple */[
                                          n,
                                          t,
                                          process_constr(Environ$ReactTemplate.push_rel(d, env), i + 1 | 0, EConstr$ReactTemplate.Unsafe[/* to_constr */0](Reductionops$ReactTemplate.whd_beta(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(Term$ReactTemplate.applist(/* tuple */[
                                                                Vars$ReactTemplate.lift(1)(f),
                                                                /* :: */[
                                                                  Constr$ReactTemplate.mkRel(1),
                                                                  /* [] */0
                                                                ]
                                                              ])))), /* tuple */[
                                                cprest,
                                                rest
                                              ])
                                        ]);
                            }
                          } else {
                            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("process_constr."));
                          }
                        }
                      } else if (param[1]) {
                        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("process_constr."));
                      } else {
                        return f;
                      }
                    };
                    return process_constr(env$1, 0, f, /* tuple */[
                                Curry._1(Util$ReactTemplate.List[/* rev */4], cstr[/* cs_args */3]),
                                recargs
                              ]);
                  }
                  }(partial_arg,partial_arg$1)), vecfi, constrs, Declareops$ReactTemplate.dest_subterms(Caml_array.caml_array_get(recargsvec, tyi)));
              var match$3 = Caml_array.caml_array_get(depPvec, tyi);
              var j;
              if (match$3) {
                var c = match$3[0][1];
                if (Constr$ReactTemplate.isRel(c)) {
                  j = Constr$ReactTemplate.destRel(c);
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "indrec.ml",
                          374,
                          14
                        ]
                      ];
                }
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "indrec.ml",
                        374,
                        14
                      ]
                    ];
              }
              var depind$prime = Inductiveops$ReactTemplate.build_dependent_inductive(env, indf$prime);
              var match$4 = Inductiveops$ReactTemplate.get_arity(env, indf$prime);
              var arsign$prime = match$4[0];
              var deparsign$prime_000 = /* LocalAssum */Block.__(0, [
                  /* Anonymous */0,
                  depind$prime
                ]);
              var deparsign$prime = /* :: */[
                deparsign$prime_000,
                arsign$prime
              ];
              var nrpar = Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, (ndepar << 1), lnonparrec);
              var nrar = dep ? Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 0, deparsign$prime) : Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, 1, arsign$prime);
              var pargs = Util$ReactTemplate.$at(nrpar, nrar);
              var ci = Inductiveops$ReactTemplate.make_case_info(env, indi, /* RegularStyle */4);
              var concl = Term$ReactTemplate.applist(/* tuple */[
                    Constr$ReactTemplate.mkRel((dect + j | 0) + ndepar | 0),
                    pargs
                  ]);
              var pred = it_mkLambda_or_LetIn_name(env, Curry._1(dep ? (function (param) {
                            return mkLambda_name(env, param);
                          }) : Constr$ReactTemplate.mkLambda, /* tuple */[
                        /* Anonymous */0,
                        depind$prime,
                        concl
                      ]), arsign$prime);
              var obj = Inductiveops$ReactTemplate.make_case_or_project(env, evdref[0], indf, ci, EConstr$ReactTemplate.of_constr(pred), EConstr$ReactTemplate.mkRel(1), Util$ReactTemplate.$$Array[/* map */12](EConstr$ReactTemplate.of_constr, branches));
              var obj$1 = EConstr$ReactTemplate.to_constr(evdref[0], obj);
              var deftyi = it_mkLambda_or_LetIn_name(env, obj$1, Termops$ReactTemplate.lift_rel_context(nrec)(deparsign));
              var pargs$1 = dep ? Context$ReactTemplate.Rel[/* to_extended_vect */13](Constr$ReactTemplate.mkRel, 0, deparsign) : Context$ReactTemplate.Rel[/* to_extended_vect */13](Constr$ReactTemplate.mkRel, 1, arsign);
              var concl$1 = Term$ReactTemplate.appvect(/* tuple */[
                    Constr$ReactTemplate.mkRel(((nbconstruct + ndepar | 0) + nonrecpar | 0) + j | 0),
                    pargs$1
                  ]);
              var typtyi = it_mkProd_or_LetIn_name(env, concl$1, deparsign);
              _param = param$1[1];
              _ldef = /* :: */[
                deftyi,
                ldef
              ];
              _ltyp = /* :: */[
                typtyi,
                ltyp
              ];
              _ln = /* :: */[
                Context$ReactTemplate.Rel[/* nhyps */5](arsign),
                ln
              ];
              _i = i + nctyi | 0;
              continue ;
              
            } else {
              var fixn = Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(Util$ReactTemplate.List[/* rev */4], ln));
              var fixtyi = Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(Util$ReactTemplate.List[/* rev */4], ltyp));
              var fixdef = Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(Util$ReactTemplate.List[/* rev */4], ldef));
              var names = Caml_array.caml_make_vect(nrec, /* Name */[Names$ReactTemplate.Id[/* of_string */5]("F")]);
              return Constr$ReactTemplate.mkFix(/* tuple */[
                          /* tuple */[
                            fixn,
                            p
                          ],
                          /* tuple */[
                            names,
                            fixtyi,
                            fixdef
                          ]
                        ]);
            }
          };
        });
    };
    var make_branch = function (env, i, param) {
      if (param) {
        var rest = param[1];
        var match = param[0];
        var dep = match[3];
        var mipi = match[2];
        var mibi = match[1];
        var match$1 = match[0];
        var u = match$1[1];
        var indi = match$1[0];
        var tyi = indi[1];
        var nconstr = mipi[/* mind_consnames */3].length;
        var onerec = function (env, j) {
          if (j === nconstr) {
            return make_branch(env, i + j | 0, rest);
          } else {
            var recarg = Caml_array.caml_array_get(Declareops$ReactTemplate.dest_subterms(Caml_array.caml_array_get(recargsvec, tyi)), j);
            var recarg$1 = Util$ReactTemplate.$at(recargpar, recarg);
            var vargs = Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, (nrec + i | 0) + j | 0, lnamesparrec);
            var cs = Inductiveops$ReactTemplate.get_constructor(/* tuple */[
                  /* tuple */[
                    indi,
                    u
                  ],
                  mibi,
                  mipi,
                  vargs
                ], j + 1 | 0);
            var p_0 = type_rec_branch(/* true */1, dep, env, evdref[0], /* tuple */[
                  vargs,
                  depPvec,
                  i + j | 0
                ], tyi, cs, recarg$1);
            return mkLambda_string("f", p_0, onerec(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                                  /* Anonymous */0,
                                  p_0
                                ]), env), j + 1 | 0));
          }
        };
        return onerec(env, 0);
      } else {
        return makefix(i)(listdepkind);
      }
    };
    var put_arity = function (env, i, param) {
      if (param) {
        var match = param[0];
        var match$1 = match[0];
        var indf = Inductiveops$ReactTemplate.make_ind_family(/* tuple */[
              /* tuple */[
                match$1[0],
                match$1[1]
              ],
              Context$ReactTemplate.Rel[/* to_extended_list */12](Constr$ReactTemplate.mkRel, i, lnamesparrec)
            ]);
        var partial_arg = /* Some */[Evd$ReactTemplate.univ_flexible_alg];
        var s = Evarutil$ReactTemplate.evd_comb1((function (param, param$1) {
                return Evd$ReactTemplate.fresh_sort_in_family(/* None */0, partial_arg, env, param, param$1);
              }), evdref, match[4]);
        var typP = Inductiveops$ReactTemplate.make_arity(env, evdref[0], match[3], indf, s);
        var typP$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](typP);
        return mkLambda_string("P", typP$1, put_arity(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                              /* Anonymous */0,
                              typP$1
                            ]), env), i + 1 | 0, param[1]));
      } else {
        return make_branch(env, 0, listdepkind);
      }
    };
    var match = Curry._2(Util$ReactTemplate.List[/* nth */3], listdepkind, p);
    var mipi = match[2];
    var match$1 = match[0];
    if (Inductiveops$ReactTemplate.mis_is_recursive_subset(Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return param[0][0][1];
                }), listdepkind), mipi[/* mind_recargs */11])) {
      var env$prime = Environ$ReactTemplate.push_rel_context(lnamesparrec, env);
      return it_mkLambda_or_LetIn_name(env, put_arity(env$prime, 0, listdepkind), lnamesparrec);
    } else {
      var evd = evdref[0];
      var match$2 = mis_make_case_com(match[3], env, evd, /* tuple */[
            match$1[0],
            match$1[1]
          ], /* tuple */[
            match[1],
            mipi
          ], match[4]);
      evdref[0] = match$2[0];
      return match$2[1];
    }
  };
  return /* tuple */[
          evdref[0],
          Curry._2(Util$ReactTemplate.List[/* init */46], nrec, make_one_rec)
        ];
}

function build_case_analysis_scheme(env, sigma, pity, dep, kind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, pity[0]);
  var mib = match[0];
  if (dep && !Inductiveops$ReactTemplate.has_dependent_elim(mib)) {
    throw [
          RecursionSchemeError,
          /* NotAllowedDependentAnalysis */Block.__(2, [
              /* false */0,
              pity[0]
            ])
        ];
  }
  return mis_make_case_com(dep, env, sigma, pity, /* tuple */[
              mib,
              match[1]
            ], kind);
}

function is_in_prop(mip) {
  var match = Inductive$ReactTemplate.inductive_sort_family(mip);
  if (match !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function build_case_analysis_scheme_default(env, sigma, pity, kind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, pity[0]);
  var mip = match[1];
  var mib = match[0];
  var dep = 1 - (is_in_prop(mip) || 1 - Inductiveops$ReactTemplate.has_dependent_elim(mib));
  return mis_make_case_com(dep, env, sigma, pity, /* tuple */[
              mib,
              mip
            ], kind);
}

function change_sort_arity(sort) {
  var drec = function (_a) {
    while(true) {
      var a = _a;
      var match = Constr$ReactTemplate.kind(a);
      switch (match.tag | 0) {
        case 4 : 
            return /* tuple */[
                    match[0],
                    Constr$ReactTemplate.mkSort(sort)
                  ];
        case 5 : 
            _a = match[0];
            continue ;
            case 6 : 
            var match$1 = drec(match[2]);
            return /* tuple */[
                    match$1[0],
                    Constr$ReactTemplate.mkProd(/* tuple */[
                          match[0],
                          match[1],
                          match$1[1]
                        ])
                  ];
        case 8 : 
            var match$2 = drec(match[3]);
            return /* tuple */[
                    match$2[0],
                    Constr$ReactTemplate.mkLetIn(/* tuple */[
                          match[0],
                          match[1],
                          match[2],
                          match$2[1]
                        ])
                  ];
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "indrec.ml",
                  516,
                  11
                ]
              ];
      }
    };
  };
  return drec;
}

function weaken_sort_scheme(env, evd, set, sort, npars, term, ty) {
  var evdref = [evd];
  var drec = function (np, elim) {
    var match = Constr$ReactTemplate.kind(elim);
    switch (match.tag | 0) {
      case 6 : 
          var c = match[2];
          var t = match[1];
          var n = match[0];
          if (np) {
            var match$1 = drec(np - 1 | 0, c);
            return /* tuple */[
                    Constr$ReactTemplate.mkProd(/* tuple */[
                          n,
                          t,
                          match$1[0]
                        ]),
                    Constr$ReactTemplate.mkLambda(/* tuple */[
                          n,
                          t,
                          match$1[1]
                        ])
                  ];
          } else {
            var match$2 = change_sort_arity(sort)(t);
            var t$prime = match$2[1];
            evdref[0] = Curry._4(set ? Evd$ReactTemplate.set_eq_sort : Evd$ReactTemplate.set_leq_sort, env, evdref[0], sort, match$2[0]);
            return /* tuple */[
                    Constr$ReactTemplate.mkProd(/* tuple */[
                          n,
                          t$prime,
                          c
                        ]),
                    Constr$ReactTemplate.mkLambda(/* tuple */[
                          n,
                          t$prime,
                          Constr$ReactTemplate.mkApp(/* tuple */[
                                term,
                                Termops$ReactTemplate.rel_vect(0, npars + 1 | 0)
                              ])
                        ])
                  ];
          }
          break;
      case 8 : 
          var t$1 = match[2];
          var b = match[1];
          var n$1 = match[0];
          var match$3 = drec(np, match[3]);
          return /* tuple */[
                  Constr$ReactTemplate.mkLetIn(/* tuple */[
                        n$1,
                        b,
                        t$1,
                        match$3[0]
                      ]),
                  Constr$ReactTemplate.mkLetIn(/* tuple */[
                        n$1,
                        b,
                        t$1,
                        match$3[1]
                      ])
                ];
      default:
        return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["weaken_sort_scheme"], Pp$ReactTemplate.str("wrong elimination type."));
    }
  };
  var match = drec(npars, ty);
  return /* tuple */[
          evdref[0],
          match[0],
          match[1]
        ];
}

function check_arities(env, listdepkind) {
  Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (ln, param) {
          var kind = param[4];
          var match = param[0];
          var mind = match[0];
          var ni = mind[1];
          var kelim = Inductive$ReactTemplate.elim_sorts(/* tuple */[
                param[1],
                param[2]
              ]);
          if (Curry._2(Sorts$ReactTemplate.List[/* mem */0], kind, kelim)) {
            if (Curry._2(Int$ReactTemplate.List[/* mem */0], ni, ln)) {
              throw [
                    RecursionSchemeError,
                    /* NotMutualInScheme */Block.__(1, [
                        mind,
                        mind
                      ])
                  ];
            } else {
              return /* :: */[
                      ni,
                      ln
                    ];
            }
          } else {
            throw [
                  RecursionSchemeError,
                  /* NotAllowedCaseAnalysis */Block.__(0, [
                      /* true */1,
                      Universes$ReactTemplate.fresh_sort_in_family(env, kind)[0],
                      /* tuple */[
                        mind,
                        match[1]
                      ]
                    ])
                ];
          }
        }), /* [] */0, listdepkind);
  return /* true */1;
}

function build_mutual_induction_scheme(env, sigma, param) {
  if (param) {
    var match = param[0];
    var dep = match[1];
    var match$1 = match[0];
    var u = match$1[1];
    var mind = match$1[0];
    var match$2 = Inductive$ReactTemplate.lookup_mind_specif(env, mind);
    var mib = match$2[0];
    if (dep && !Inductiveops$ReactTemplate.has_dependent_elim(mib)) {
      throw [
            RecursionSchemeError,
            /* NotAllowedDependentAnalysis */Block.__(2, [
                /* true */1,
                mind
              ])
          ];
    }
    var sp = mind[0];
    var listdepkind_000 = /* tuple */[
      /* tuple */[
        mind,
        u
      ],
      mib,
      match$2[1],
      dep,
      match[2]
    ];
    var listdepkind_001 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            var match = param[0];
            var mind$prime = match[0];
            if (Names$ReactTemplate.MutInd[/* equal */12](sp, mind$prime[0])) {
              var match$1 = Inductive$ReactTemplate.lookup_mind_specif(env, mind$prime);
              return /* tuple */[
                      /* tuple */[
                        mind$prime,
                        match[1]
                      ],
                      match$1[0],
                      match$1[1],
                      param[1],
                      param[2]
                    ];
            } else {
              throw [
                    RecursionSchemeError,
                    /* NotMutualInScheme */Block.__(1, [
                        mind,
                        mind$prime
                      ])
                  ];
            }
          }), param[1]);
    var listdepkind = /* :: */[
      listdepkind_000,
      listdepkind_001
    ];
    check_arities(env, listdepkind);
    return mis_make_indrec(env, sigma, listdepkind, mib, u);
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("build_induction_scheme expects a non empty list of inductive types."));
  }
}

function build_induction_scheme(env, sigma, pind, dep, kind) {
  var match = Inductive$ReactTemplate.lookup_mind_specif(env, pind[0]);
  var mib = match[0];
  if (dep && !Inductiveops$ReactTemplate.has_dependent_elim(mib)) {
    throw [
          RecursionSchemeError,
          /* NotAllowedDependentAnalysis */Block.__(2, [
              /* true */1,
              pind[0]
            ])
        ];
  }
  var match$1 = mis_make_indrec(env, sigma, /* :: */[
        /* tuple */[
          pind,
          mib,
          match[1],
          dep,
          kind
        ],
        /* [] */0
      ], mib, pind[1]);
  return /* tuple */[
          match$1[0],
          Curry._1(Util$ReactTemplate.List[/* hd */1], match$1[1])
        ];
}

function elimination_suffix(param) {
  switch (param) {
    case 0 : 
        return "_ind";
    case 1 : 
        return "_rec";
    case 2 : 
        return "_rect";
    
  }
}

function make_elimination_ident(id, s) {
  return Nameops$ReactTemplate.add_suffix(id, elimination_suffix(s));
}

function lookup_eliminator(ind_sp, s) {
  var kn = ind_sp[0];
  var match = Names$ReactTemplate.KerName[/* repr */2](Names$ReactTemplate.MutInd[/* canonical */5](kn));
  var ind_id = Caml_array.caml_array_get(Global$ReactTemplate.lookup_mind(kn)[/* mind_packets */0], ind_sp[1])[/* mind_typename */0];
  var id = Nameops$ReactTemplate.add_suffix(ind_id, elimination_suffix(s));
  try {
    var cst = Global$ReactTemplate.constant_of_delta_kn(Names$ReactTemplate.KerName[/* make */0](match[0], match[1], Names$ReactTemplate.Label[/* of_id */5](id)));
    Global$ReactTemplate.lookup_constant(cst);
    return /* ConstRef */Block.__(1, [cst]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      try {
        return Nametab$ReactTemplate.locate(Libnames$ReactTemplate.qualid_of_ident(id));
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["default_elim"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Cannot find the elimination combinator "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.strbrk(", the elimination of the inductive definition ")), Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* IndRef */Block.__(2, [ind_sp]))), Pp$ReactTemplate.strbrk(" on sort ")), Termops$ReactTemplate.pr_sort_family(s)), Pp$ReactTemplate.strbrk(" is probably not allowed.")));
        } else {
          throw exn$1;
        }
      }
    } else {
      throw exn;
    }
  }
}

var case_suffix = "_case";

exports.RecursionSchemeError = RecursionSchemeError;
exports.build_case_analysis_scheme = build_case_analysis_scheme;
exports.build_case_analysis_scheme_default = build_case_analysis_scheme_default;
exports.build_induction_scheme = build_induction_scheme;
exports.build_mutual_induction_scheme = build_mutual_induction_scheme;
exports.weaken_sort_scheme = weaken_sort_scheme;
exports.lookup_eliminator = lookup_eliminator;
exports.elimination_suffix = elimination_suffix;
exports.make_elimination_ident = make_elimination_ident;
exports.case_suffix = case_suffix;
/* Pp-ReactTemplate Not a pure module */
