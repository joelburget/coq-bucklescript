// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function get_name(param) {
  return param[0];
}

function get_value(param) {
  if (param.tag) {
    return /* Some */[param[1]];
  } else {
    return /* None */0;
  }
}

function get_type(param) {
  if (param.tag) {
    return param[2];
  } else {
    return param[1];
  }
}

function set_name(na, param) {
  if (param.tag) {
    return /* LocalDef */Block.__(1, [
              na,
              param[1],
              param[2]
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              na,
              param[1]
            ]);
  }
}

function set_type(ty, param) {
  if (param.tag) {
    return /* LocalDef */Block.__(1, [
              param[0],
              param[1],
              ty
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              param[0],
              ty
            ]);
  }
}

function is_local_assum(param) {
  if (param.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function is_local_def(param) {
  if (param.tag) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function exists(f, param) {
  if (param.tag) {
    if (Curry._1(f, param[1])) {
      return /* true */1;
    } else {
      return Curry._1(f, param[2]);
    }
  } else {
    return Curry._1(f, param[1]);
  }
}

function for_all(f, param) {
  if (param.tag) {
    if (Curry._1(f, param[1])) {
      return Curry._1(f, param[2]);
    } else {
      return /* false */0;
    }
  } else {
    return Curry._1(f, param[1]);
  }
}

function equal(eq, decl1, decl2) {
  if (decl1.tag) {
    if (!decl2.tag || !(Names$ReactTemplate.Name[/* equal */4](decl1[0], decl2[0]) && Curry._2(eq, decl1[1], decl2[1]))) {
      return /* false */0;
    } else {
      return Curry._2(eq, decl1[2], decl2[2]);
    }
  } else if (!decl2.tag && Names$ReactTemplate.Name[/* equal */4](decl1[0], decl2[0])) {
    return Curry._2(eq, decl1[1], decl2[1]);
  } else {
    return /* false */0;
  }
}

function map_name(f, decl) {
  if (decl.tag) {
    var na = decl[0];
    var na$prime = Curry._1(f, na);
    if (na === na$prime) {
      return decl;
    } else {
      return /* LocalDef */Block.__(1, [
                na$prime,
                decl[1],
                decl[2]
              ]);
    }
  } else {
    var na$1 = decl[0];
    var na$prime$1 = Curry._1(f, na$1);
    if (na$1 === na$prime$1) {
      return decl;
    } else {
      return /* LocalAssum */Block.__(0, [
                na$prime$1,
                decl[1]
              ]);
    }
  }
}

function map_value(f, decl) {
  if (decl.tag) {
    var v = decl[1];
    var v$prime = Curry._1(f, v);
    if (v === v$prime) {
      return decl;
    } else {
      return /* LocalDef */Block.__(1, [
                decl[0],
                v$prime,
                decl[2]
              ]);
    }
  } else {
    return decl;
  }
}

function map_type(f, decl) {
  if (decl.tag) {
    var ty = decl[2];
    var ty$prime = Curry._1(f, ty);
    if (ty === ty$prime) {
      return decl;
    } else {
      return /* LocalDef */Block.__(1, [
                decl[0],
                decl[1],
                ty$prime
              ]);
    }
  } else {
    var ty$1 = decl[1];
    var ty$prime$1 = Curry._1(f, ty$1);
    if (ty$1 === ty$prime$1) {
      return decl;
    } else {
      return /* LocalAssum */Block.__(0, [
                decl[0],
                ty$prime$1
              ]);
    }
  }
}

function map_constr(f, decl) {
  if (decl.tag) {
    var ty = decl[2];
    var v = decl[1];
    var v$prime = Curry._1(f, v);
    var ty$prime = Curry._1(f, ty);
    if (v === v$prime && ty === ty$prime) {
      return decl;
    } else {
      return /* LocalDef */Block.__(1, [
                decl[0],
                v$prime,
                ty$prime
              ]);
    }
  } else {
    var ty$1 = decl[1];
    var ty$prime$1 = Curry._1(f, ty$1);
    if (ty$1 === ty$prime$1) {
      return decl;
    } else {
      return /* LocalAssum */Block.__(0, [
                decl[0],
                ty$prime$1
              ]);
    }
  }
}

function iter_constr(f, param) {
  if (param.tag) {
    Curry._1(f, param[1]);
    return Curry._1(f, param[2]);
  } else {
    return Curry._1(f, param[1]);
  }
}

function fold_constr(f, decl, acc) {
  if (decl.tag) {
    return Curry._2(f, decl[2], Curry._2(f, decl[1], acc));
  } else {
    return Curry._2(f, decl[1], acc);
  }
}

function to_tuple(param) {
  if (param.tag) {
    return /* tuple */[
            param[0],
            /* Some */[param[1]],
            param[2]
          ];
  } else {
    return /* tuple */[
            param[0],
            /* None */0,
            param[1]
          ];
  }
}

var Declaration = /* module */[
  /* get_name */get_name,
  /* get_value */get_value,
  /* get_type */get_type,
  /* set_name */set_name,
  /* set_type */set_type,
  /* is_local_assum */is_local_assum,
  /* is_local_def */is_local_def,
  /* exists */exists,
  /* for_all */for_all,
  /* equal */equal,
  /* map_name */map_name,
  /* map_value */map_value,
  /* map_type */map_type,
  /* map_constr */map_constr,
  /* iter_constr */iter_constr,
  /* fold_constr */fold_constr,
  /* to_tuple */to_tuple
];

function add(d, ctx) {
  return /* :: */[
          d,
          ctx
        ];
}

var length = Util$ReactTemplate.List[/* length */0];

function nhyps(ctx) {
  var _acc = 0;
  var _param = ctx;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      _param = param[1];
      if (param[0].tag) {
        continue ;
        
      } else {
        _acc = acc + 1 | 0;
        continue ;
        
      }
    } else {
      return acc;
    }
  };
}

function lookup(_n, _ctx) {
  while(true) {
    var ctx = _ctx;
    var n = _n;
    var exit = 0;
    if (n !== 1) {
      exit = 1;
    } else if (ctx) {
      return ctx[0];
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (ctx) {
        _ctx = ctx[1];
        _n = n - 1 | 0;
        continue ;
        
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    }
    
  };
}

function equal$1(eq, l) {
  return Curry._2(Util$ReactTemplate.List[/* equal */44], (function (c) {
                return (function (param) {
                    return equal(eq, c, param);
                  });
              }), l);
}

function map(f) {
  return Curry._1(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
                return map_constr(f, param);
              }));
}

function iter(f) {
  return Curry._1(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return iter_constr(f, param);
              }));
}

function fold_inside(f, init) {
  return Curry._2(Util$ReactTemplate.List[/* fold_left */13], f, init);
}

function fold_outside(f, l, init) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], f, l, init);
}

function to_tags(l) {
  var _l = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var l$1 = _l;
    if (param) {
      _param = param[1];
      if (param[0].tag) {
        _l = /* :: */[
          /* true */1,
          l$1
        ];
        continue ;
        
      } else {
        _l = /* :: */[
          /* false */0,
          l$1
        ];
        continue ;
        
      }
    } else {
      return l$1;
    }
  };
}

function to_extended_list(mk, n, l) {
  var _l = /* [] */0;
  var _p = 1;
  var _param = l;
  while(true) {
    var param = _param;
    var p = _p;
    var l$1 = _l;
    if (param) {
      _param = param[1];
      _p = p + 1 | 0;
      if (param[0].tag) {
        continue ;
        
      } else {
        _l = /* :: */[
          Curry._1(mk, n + p | 0),
          l$1
        ];
        continue ;
        
      }
    } else {
      return l$1;
    }
  };
}

function to_extended_vect(mk, n, hyps) {
  return Util$ReactTemplate.$$Array[/* of_list */10](to_extended_list(mk, n, hyps));
}

function get_id(param) {
  return param[0];
}

function get_value$1(param) {
  if (param.tag) {
    return /* Some */[param[1]];
  } else {
    return /* None */0;
  }
}

function get_type$1(param) {
  if (param.tag) {
    return param[2];
  } else {
    return param[1];
  }
}

function set_id(id, param) {
  if (param.tag) {
    return /* LocalDef */Block.__(1, [
              id,
              param[1],
              param[2]
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              id,
              param[1]
            ]);
  }
}

function set_type$1(ty, param) {
  if (param.tag) {
    return /* LocalDef */Block.__(1, [
              param[0],
              param[1],
              ty
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              param[0],
              ty
            ]);
  }
}

function is_local_assum$1(param) {
  if (param.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function is_local_def$1(param) {
  if (param.tag) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function exists$1(f, param) {
  if (param.tag) {
    if (Curry._1(f, param[1])) {
      return /* true */1;
    } else {
      return Curry._1(f, param[2]);
    }
  } else {
    return Curry._1(f, param[1]);
  }
}

function for_all$1(f, param) {
  if (param.tag) {
    if (Curry._1(f, param[1])) {
      return Curry._1(f, param[2]);
    } else {
      return /* false */0;
    }
  } else {
    return Curry._1(f, param[1]);
  }
}

function equal$2(eq, decl1, decl2) {
  if (decl1.tag) {
    if (!decl2.tag || !(Names$ReactTemplate.Id[/* equal */0](decl1[0], decl2[0]) && Curry._2(eq, decl1[1], decl2[1]))) {
      return /* false */0;
    } else {
      return Curry._2(eq, decl1[2], decl2[2]);
    }
  } else if (!decl2.tag && Names$ReactTemplate.Id[/* equal */0](decl1[0], decl2[0])) {
    return Curry._2(eq, decl1[1], decl2[1]);
  } else {
    return /* false */0;
  }
}

function map_id(f, decl) {
  if (decl.tag) {
    var id = decl[0];
    var id$prime = Curry._1(f, id);
    if (id === id$prime) {
      return decl;
    } else {
      return /* LocalDef */Block.__(1, [
                id$prime,
                decl[1],
                decl[2]
              ]);
    }
  } else {
    var id$1 = decl[0];
    var id$prime$1 = Curry._1(f, id$1);
    if (id$1 === id$prime$1) {
      return decl;
    } else {
      return /* LocalAssum */Block.__(0, [
                id$prime$1,
                decl[1]
              ]);
    }
  }
}

function map_value$1(f, decl) {
  if (decl.tag) {
    var v = decl[1];
    var v$prime = Curry._1(f, v);
    if (v === v$prime) {
      return decl;
    } else {
      return /* LocalDef */Block.__(1, [
                decl[0],
                v$prime,
                decl[2]
              ]);
    }
  } else {
    return decl;
  }
}

function map_type$1(f, decl) {
  if (decl.tag) {
    var ty = decl[2];
    var ty$prime = Curry._1(f, ty);
    if (ty === ty$prime) {
      return decl;
    } else {
      return /* LocalDef */Block.__(1, [
                decl[0],
                decl[1],
                ty$prime
              ]);
    }
  } else {
    var ty$1 = decl[1];
    var ty$prime$1 = Curry._1(f, ty$1);
    if (ty$1 === ty$prime$1) {
      return decl;
    } else {
      return /* LocalAssum */Block.__(0, [
                decl[0],
                ty$prime$1
              ]);
    }
  }
}

function map_constr$1(f, decl) {
  if (decl.tag) {
    var ty = decl[2];
    var v = decl[1];
    var v$prime = Curry._1(f, v);
    var ty$prime = Curry._1(f, ty);
    if (v === v$prime && ty === ty$prime) {
      return decl;
    } else {
      return /* LocalDef */Block.__(1, [
                decl[0],
                v$prime,
                ty$prime
              ]);
    }
  } else {
    var ty$1 = decl[1];
    var ty$prime$1 = Curry._1(f, ty$1);
    if (ty$1 === ty$prime$1) {
      return decl;
    } else {
      return /* LocalAssum */Block.__(0, [
                decl[0],
                ty$prime$1
              ]);
    }
  }
}

function iter_constr$1(f, param) {
  if (param.tag) {
    Curry._1(f, param[1]);
    return Curry._1(f, param[2]);
  } else {
    return Curry._1(f, param[1]);
  }
}

function fold_constr$1(f, decl, a) {
  if (decl.tag) {
    return Curry._2(f, decl[2], Curry._2(f, decl[1], a));
  } else {
    return Curry._2(f, decl[1], a);
  }
}

function to_tuple$1(param) {
  if (param.tag) {
    return /* tuple */[
            param[0],
            /* Some */[param[1]],
            param[2]
          ];
  } else {
    return /* tuple */[
            param[0],
            /* None */0,
            param[1]
          ];
  }
}

function of_tuple(param) {
  var match = param[1];
  var id = param[0];
  if (match) {
    return /* LocalDef */Block.__(1, [
              id,
              match[0],
              param[2]
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              id,
              param[2]
            ]);
  }
}

function of_rel_decl(f, param) {
  if (param.tag) {
    return /* LocalDef */Block.__(1, [
              Curry._1(f, param[0]),
              param[1],
              param[2]
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              Curry._1(f, param[0]),
              param[1]
            ]);
  }
}

function to_rel_decl(param) {
  if (param.tag) {
    return /* LocalDef */Block.__(1, [
              /* Name */[param[0]],
              param[1],
              param[2]
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              /* Name */[param[0]],
              param[1]
            ]);
  }
}

var Declaration$1 = /* module */[
  /* get_id */get_id,
  /* get_value */get_value$1,
  /* get_type */get_type$1,
  /* set_id */set_id,
  /* set_type */set_type$1,
  /* is_local_assum */is_local_assum$1,
  /* is_local_def */is_local_def$1,
  /* exists */exists$1,
  /* for_all */for_all$1,
  /* equal */equal$2,
  /* map_id */map_id,
  /* map_value */map_value$1,
  /* map_type */map_type$1,
  /* map_constr */map_constr$1,
  /* iter_constr */iter_constr$1,
  /* fold_constr */fold_constr$1,
  /* to_tuple */to_tuple$1,
  /* of_tuple */of_tuple,
  /* of_rel_decl */of_rel_decl,
  /* to_rel_decl */to_rel_decl
];

function add$1(d, ctx) {
  return /* :: */[
          d,
          ctx
        ];
}

var length$1 = Util$ReactTemplate.List[/* length */0];

function lookup$1(id, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var decl = param[0];
      if (Names$ReactTemplate.Id[/* equal */0](id, get_id(decl))) {
        return decl;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function equal$3(eq, l) {
  return Curry._2(Util$ReactTemplate.List[/* equal */44], (function (c) {
                return (function (param) {
                    return equal$2(eq, c, param);
                  });
              }), l);
}

function map$1(f) {
  return Curry._1(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
                return map_constr$1(f, param);
              }));
}

function iter$1(f) {
  return Curry._1(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return iter_constr$1(f, param);
              }));
}

function fold_inside$1(f, init) {
  return Curry._2(Util$ReactTemplate.List[/* fold_left */13], f, init);
}

function fold_outside$1(f, l, init) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], f, l, init);
}

function to_vars(l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (accu, decl) {
                return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], get_id(decl), accu);
              }), Names$ReactTemplate.Id[/* Set */9][/* empty */0], l);
}

function to_instance(mk, l) {
  var filter = function (param) {
    if (param.tag) {
      return /* None */0;
    } else {
      return /* Some */[Curry._1(mk, param[0])];
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* map_filter */62], filter, l);
}

var Named = /* module */[
  /* Declaration */Declaration$1,
  /* empty : [] */0,
  /* add */add$1,
  /* length */length$1,
  /* lookup */lookup$1,
  /* equal */equal$3,
  /* map */map$1,
  /* iter */iter$1,
  /* fold_inside */fold_inside$1,
  /* fold_outside */fold_outside$1,
  /* to_vars */to_vars,
  /* to_instance */to_instance
];

function map_constr$2(f, decl) {
  if (decl.tag) {
    var ty = decl[2];
    var c = decl[1];
    var ty$prime = Curry._1(f, ty);
    var c$prime = Curry._1(f, c);
    if (c === c$prime && ty === ty$prime) {
      return decl;
    } else {
      return /* LocalDef */Block.__(1, [
                decl[0],
                c$prime,
                ty$prime
              ]);
    }
  } else {
    var ty$1 = decl[1];
    var ty$prime$1 = Curry._1(f, ty$1);
    if (ty$1 === ty$prime$1) {
      return decl;
    } else {
      return /* LocalAssum */Block.__(0, [
                decl[0],
                ty$prime$1
              ]);
    }
  }
}

function of_named_decl(param) {
  if (param.tag) {
    return /* LocalDef */Block.__(1, [
              /* :: */[
                param[0],
                /* [] */0
              ],
              param[1],
              param[2]
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              /* :: */[
                param[0],
                /* [] */0
              ],
              param[1]
            ]);
  }
}

function to_named_context(param) {
  if (param.tag) {
    var t = param[2];
    var v = param[1];
    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
                  return /* LocalDef */Block.__(1, [
                            id,
                            v,
                            t
                          ]);
                }), param[0]);
  } else {
    var t$1 = param[1];
    return Curry._2(Util$ReactTemplate.List[/* map */10], (function (id) {
                  return /* LocalAssum */Block.__(0, [
                            id,
                            t$1
                          ]);
                }), param[0]);
  }
}

var Declaration$2 = /* module */[
  /* map_constr */map_constr$2,
  /* of_named_decl */of_named_decl,
  /* to_named_context */to_named_context
];

function fold(f, l, init) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], f, l, init);
}

var Compacted = /* module */[
  /* Declaration */Declaration$2,
  /* fold */fold
];

var Rel = [
  Declaration,
  /* [] */0,
  add,
  length,
  equal$1,
  nhyps,
  lookup,
  map,
  iter,
  fold_inside,
  fold_outside,
  to_tags,
  to_extended_list,
  to_extended_vect
];

exports.Rel = Rel;
exports.Named = Named;
exports.Compacted = Compacted;
/* Util-ReactTemplate Not a pure module */
