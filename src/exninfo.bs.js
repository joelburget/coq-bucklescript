// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Mutex$ReactTemplate = require("./mutex.bs.js");
var Store$ReactTemplate = require("./store.bs.js");

var Store = Store$ReactTemplate.Make(/* module */[]);

var make = Store[/* field */5];

var add = Store[/* set */1];

var get = Store[/* get */2];

var $$null = Store[/* empty */0];

var Unique = Caml_exceptions.create("Exninfo-ReactTemplate.Unique");

var dummy_001 = Store[/* empty */0];

var dummy = /* tuple */[
  Unique,
  dummy_001
];

var current = [/* [] */0];

var lock = Mutex$ReactTemplate.create(/* () */0);

function remove_assoc(i, l) {
  if (l) {
    var rem = l[1];
    var match = l[0];
    var j = match[0];
    if (i === j) {
      return rem;
    } else {
      var ans = remove_assoc(i, rem);
      if (rem === ans) {
        return l;
      } else {
        return /* :: */[
                /* tuple */[
                  j,
                  match[1]
                ],
                ans
              ];
      }
    }
  } else {
    return /* [] */0;
  }
}

function find_and_remove_assoc(i, l) {
  if (l) {
    var rem = l[1];
    var match = l[0];
    var v = match[1];
    var j = match[0];
    if (i === j) {
      return /* tuple */[
              v,
              rem
            ];
    } else {
      var match$1 = find_and_remove_assoc(i, rem);
      var ans = match$1[1];
      var r = match$1[0];
      if (rem === ans) {
        return /* tuple */[
                r,
                l
              ];
      } else {
        return /* tuple */[
                r,
                /* :: */[
                  /* tuple */[
                    j,
                    v
                  ],
                  ans
                ]
              ];
      }
    }
  } else {
    return /* tuple */[
            dummy,
            /* [] */0
          ];
  }
}

function iraise(e) {
  Mutex$ReactTemplate.lock(lock);
  current[0] = /* :: */[
    /* tuple */[
      1,
      e
    ],
    remove_assoc(1, current[0])
  ];
  Mutex$ReactTemplate.unlock(lock);
  throw e[0];
}

function raise(info, e) {
  Mutex$ReactTemplate.lock(lock);
  if (info) {
    current[0] = /* :: */[
      /* tuple */[
        1,
        /* tuple */[
          e,
          info[0]
        ]
      ],
      remove_assoc(1, current[0])
    ];
    Mutex$ReactTemplate.unlock(lock);
    throw e;
  } else {
    current[0] = remove_assoc(1, current[0]);
    Mutex$ReactTemplate.unlock(lock);
    throw e;
  }
}

function find_and_remove() {
  Mutex$ReactTemplate.lock(lock);
  var match = find_and_remove_assoc(1, current[0]);
  current[0] = match[1];
  Mutex$ReactTemplate.unlock(lock);
  return match[0];
}

function info(e) {
  var match = find_and_remove(/* () */0);
  if (match[0] === e) {
    return match[1];
  } else {
    return Store[/* empty */0];
  }
}

exports.make = make;
exports.$$null = $$null;
exports.add = add;
exports.get = get;
exports.info = info;
exports.iraise = iraise;
exports.raise = raise;
/* Store Not a pure module */
