// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var CamlinternalOO = require("bs-platform/lib/js/camlinternalOO.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");

var shared = [
  "remove",
  "print",
  "mem",
  "add"
];

var shared$1 = [
  "print",
  "add",
  "mem",
  "remove"
];

function error_undeclared_key(key) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["Goptions"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key)), Pp$ReactTemplate.str(": no table or option of this type")));
}

var table_of_A_tables = [
  0,
  0,
  0
];

var string_table = [/* [] */0];

function get_string_table(k) {
  return Curry._2(Util$ReactTemplate.$$String[/* List */40][/* assoc */2], Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", k), string_table[0]);
}

var ref_table = [/* [] */0];

function get_ref_table(k) {
  return Curry._2(Util$ReactTemplate.$$String[/* List */40][/* assoc */2], Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", k), ref_table[0]);
}

function compare(opt1, opt2) {
  return Curry._3(Util$ReactTemplate.List[/* compare */43], Util$ReactTemplate.$$String[/* compare */24], opt1, opt2);
}

var OptionOrd = /* module */[/* compare */compare];

var OptionMap = Curry._1(Util$ReactTemplate.$$Map[/* Make */0], OptionOrd);

var value_tab = [OptionMap[/* empty */0]];

function get_option(key) {
  return Curry._2(OptionMap[/* find */21], key, value_tab[0]);
}

function check_key(key) {
  try {
    get_option(key);
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Sorry, this option name is already used."));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem_assoc */3], Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key), string_table[0]) || Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem_assoc */3], Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key), ref_table[0])) {
        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Sorry, this option name is already used."));
      } else {
        return 0;
      }
    } else {
      throw exn;
    }
  }
}

var warn_deprecated_option = CWarnings$ReactTemplate.create("deprecated-option", "deprecated", /* None */0, (function (key) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Option"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key))), Pp$ReactTemplate.strbrk(" is deprecated"));
      }));

function declare_option(cast, uncast, append, $staropt$star, param) {
  var write = param[/* optwrite */4];
  var read = param[/* optread */3];
  var key = param[/* optkey */2];
  var depr = param[/* optdepr */0];
  var preprocess = $staropt$star ? $staropt$star[0] : (function (x) {
        return x;
      });
  check_key(key);
  var $$default = Curry._1(read, /* () */0);
  Summary$ReactTemplate.declare_summary(Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key), /* record */[
        /* freeze_function */(function () {
            return Curry._1(read, /* () */0);
          }),
        /* unfreeze_function */write,
        /* init_function */(function () {
            return Curry._1(write, $$default);
          })
      ]);
  var cache_options = function (param) {
    var match = param[1];
    var v = match[2];
    if (match[1] !== 0) {
      return Curry._1(write, Curry._2(append, Curry._1(read, /* () */0), v));
    } else {
      return Curry._1(write, v);
    }
  };
  var load_options = function (_, o) {
    var l = o[1][0];
    if (l !== 2) {
      if (l >= 3) {
        return cache_options(o);
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "goptions.ml",
                250,
                8
              ]
            ];
      }
    } else {
      return /* () */0;
    }
  };
  var open_options = function (i, o) {
    var l = o[1][0];
    if (l !== 2) {
      if (l >= 3) {
        return /* () */0;
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "goptions.ml",
                257,
                8
              ]
            ];
      }
    } else if (i === 1) {
      return cache_options(o);
    } else {
      return 0;
    }
  };
  var subst_options = function (param) {
    return param[1];
  };
  var discharge_options = function (param) {
    var o = param[1];
    if (o[0] !== 1) {
      return /* Some */[o];
    } else {
      return /* None */0;
    }
  };
  var classify_options = function (o) {
    if (o[0] >= 2) {
      return /* Substitute */Block.__(0, [o]);
    } else {
      return /* Dispose */0;
    }
  };
  var init = Libobject$ReactTemplate.default_object(Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key));
  var options = Libobject$ReactTemplate.declare_object(/* record */[
        /* object_name */init[/* object_name */0],
        /* cache_function */cache_options,
        /* load_function */load_options,
        /* open_function */open_options,
        /* classify_function */classify_options,
        /* subst_function */subst_options,
        /* discharge_function */discharge_options,
        /* rebuild_function */init[/* rebuild_function */7]
      ]);
  var change = function (l, m, v) {
    var v$1 = Curry._1(preprocess, v);
    return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(options, /* tuple */[
                    l,
                    m,
                    v$1
                  ]));
  };
  var warn = function () {
    if (depr) {
      return Curry._2(warn_deprecated_option, /* None */0, key);
    } else {
      return 0;
    }
  };
  var cread = function () {
    return Curry._1(cast, Curry._1(read, /* () */0));
  };
  var cwrite = function (l, v) {
    warn(/* () */0);
    return change(l, /* OptSet */0, Curry._1(uncast, v));
  };
  var cappend = function (l, v) {
    warn(/* () */0);
    return change(l, /* OptAppend */1, Curry._1(uncast, v));
  };
  value_tab[0] = Curry._3(OptionMap[/* add */3], key, /* tuple */[
        param[/* optname */1],
        depr,
        /* tuple */[
          cread,
          cwrite,
          cappend
        ]
      ], value_tab[0]);
  return write;
}

function declare_int_option(param, param$1) {
  return declare_option((function (v) {
                return /* IntValue */Block.__(1, [v]);
              }), (function (param) {
                if (param.tag === 1) {
                  return param[0];
                } else {
                  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("async_option."));
                }
              }), (function (_, _$1) {
                return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("async_option."));
              }), param, param$1);
}

function declare_bool_option(param, param$1) {
  return declare_option((function (v) {
                return /* BoolValue */Block.__(0, [v]);
              }), (function (param) {
                if (param.tag) {
                  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("async_option."));
                } else {
                  return param[0];
                }
              }), (function (_, _$1) {
                return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("async_option."));
              }), param, param$1);
}

function declare_string_option(param, param$1) {
  return declare_option((function (v) {
                return /* StringValue */Block.__(2, [v]);
              }), (function (param) {
                if (param.tag === 2) {
                  return param[0];
                } else {
                  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("async_option."));
                }
              }), (function (x, y) {
                return x + ("," + y);
              }), param, param$1);
}

function declare_stringopt_option(param, param$1) {
  return declare_option((function (v) {
                return /* StringOptValue */Block.__(3, [v]);
              }), (function (param) {
                if (param.tag === 3) {
                  return param[0];
                } else {
                  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("async_option."));
                }
              }), (function (_, _$1) {
                return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("async_option."));
              }), param, param$1);
}

var warn_unknown_option = CWarnings$ReactTemplate.create("unknown-option", "option", /* None */0, (function (key) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("There is no option "), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key))), Pp$ReactTemplate.str("."));
      }));

function set_option_value($staropt$star, check_and_cast, key, v) {
  var locality = $staropt$star ? $staropt$star[0] : /* OptDefault */0;
  var opt;
  try {
    opt = /* Some */[get_option(key)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      opt = /* None */0;
    } else {
      throw exn;
    }
  }
  if (opt) {
    var match = opt[0][2];
    return Curry._2(match[1], locality, Curry._2(check_and_cast, v, Curry._1(match[0], /* () */0)));
  } else {
    return Curry._2(warn_unknown_option, /* None */0, key);
  }
}

function bad_type_error() {
  return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Bad type of value for this option."));
}

function check_int_value(v, param) {
  if (param.tag === 1) {
    return /* IntValue */Block.__(1, [v]);
  } else {
    return bad_type_error(/* () */0);
  }
}

function check_bool_value(v, param) {
  if (param.tag) {
    return bad_type_error(/* () */0);
  } else {
    return /* BoolValue */Block.__(0, [v]);
  }
}

function check_string_value(v, param) {
  switch (param.tag | 0) {
    case 0 : 
    case 1 : 
        return bad_type_error(/* () */0);
    case 2 : 
        return /* StringValue */Block.__(2, [v]);
    case 3 : 
        return /* StringOptValue */Block.__(3, [/* Some */[v]]);
    
  }
}

function check_unset_value(_, param) {
  switch (param.tag | 0) {
    case 0 : 
        return /* BoolValue */Block.__(0, [/* false */0]);
    case 1 : 
        return /* IntValue */Block.__(1, [/* None */0]);
    case 2 : 
        return bad_type_error(/* () */0);
    case 3 : 
        return /* StringOptValue */Block.__(3, [/* None */0]);
    
  }
}

function set_int_option_value_gen(locality) {
  return (function (param, param$1) {
      return set_option_value(locality, check_int_value, param, param$1);
    });
}

function set_bool_option_value_gen(locality, key, v) {
  return set_option_value(locality, check_bool_value, key, v);
}

function set_string_option_value_gen(locality) {
  return (function (param, param$1) {
      return set_option_value(locality, check_string_value, param, param$1);
    });
}

function unset_option_value_gen(locality, key) {
  return set_option_value(locality, check_unset_value, key, /* () */0);
}

function set_string_option_append_value_gen($staropt$star, key, v) {
  var locality = $staropt$star ? $staropt$star[0] : /* OptDefault */0;
  var opt;
  try {
    opt = /* Some */[get_option(key)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      opt = /* None */0;
    } else {
      throw exn;
    }
  }
  if (opt) {
    var match = opt[0][2];
    return Curry._2(match[2], locality, check_string_value(v, Curry._1(match[0], /* () */0)));
  } else {
    return Curry._2(warn_unknown_option, /* None */0, key);
  }
}

function set_int_option_value(opt, v) {
  return set_int_option_value_gen(/* None */0)(opt, v);
}

function set_bool_option_value(opt, v) {
  return set_bool_option_value_gen(/* None */0, opt, v);
}

function set_string_option_value(opt, v) {
  return set_string_option_value_gen(/* None */0)(opt, v);
}

function msg_option_value(param) {
  var v = param[1];
  switch (v.tag | 0) {
    case 0 : 
        if (v[0] !== 0) {
          return Pp$ReactTemplate.str("on");
        } else {
          return Pp$ReactTemplate.str("off");
        }
    case 1 : 
        var match = v[0];
        if (match) {
          return Pp$ReactTemplate.$$int(match[0]);
        } else {
          return Pp$ReactTemplate.str("undefined");
        }
    case 2 : 
        return Pp$ReactTemplate.quote(Pp$ReactTemplate.str(v[0]));
    case 3 : 
        var match$1 = v[0];
        if (match$1) {
          return Pp$ReactTemplate.quote(Pp$ReactTemplate.str(match$1[0]));
        } else {
          return Pp$ReactTemplate.str("undefined");
        }
    
  }
}

function print_option_value(key) {
  var match = get_option(key);
  var name = match[0];
  var s = Curry._1(match[2][0], /* () */0);
  if (s.tag) {
    return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Current value of "), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str(" is ")), msg_option_value(/* tuple */[
                        name,
                        s
                      ])));
  } else {
    return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The "), Pp$ReactTemplate.str(name)), Pp$ReactTemplate.str(" mode is ")), Pp$ReactTemplate.str(s[0] ? "on" : "off")));
  }
}

function get_tables() {
  var tables = value_tab[0];
  var fold = function (key, param, accu) {
    var state_000 = /* opt_depr */param[1];
    var state_001 = /* opt_name */param[0];
    var state_002 = /* opt_value */Curry._1(param[2][0], /* () */0);
    var state = /* record */[
      state_000,
      state_001,
      state_002
    ];
    return Curry._3(OptionMap[/* add */3], key, state, accu);
  };
  return Curry._3(OptionMap[/* fold */10], fold, tables, OptionMap[/* empty */0]);
}

function print_tables() {
  var print_option = function (key, name, value, depr) {
    var msg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("  "), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key))), Pp$ReactTemplate.str(": ")), msg_option_value(/* tuple */[
              name,
              value
            ]));
    if (depr) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(msg, Pp$ReactTemplate.str(" [DEPRECATED]")), Pp$ReactTemplate.fnl(/* () */0));
    } else {
      return Pp$ReactTemplate.$plus$plus(msg, Pp$ReactTemplate.fnl(/* () */0));
    }
  };
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Synchronous options:"), Pp$ReactTemplate.fnl(/* () */0)), Curry._3(OptionMap[/* fold */10], (function (key, param, p) {
                                        return Pp$ReactTemplate.$plus$plus(p, print_option(key, param[0], Curry._1(param[2][0], /* () */0), param[1]));
                                      }), value_tab[0], Pp$ReactTemplate.mt(/* () */0))), Pp$ReactTemplate.str("Tables:")), Pp$ReactTemplate.fnl(/* () */0)), Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, p) {
                            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(p, Pp$ReactTemplate.str("  ")), Pp$ReactTemplate.str(param[0])), Pp$ReactTemplate.fnl(/* () */0));
                          }), string_table[0], Pp$ReactTemplate.mt(/* () */0))), Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, p) {
                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(p, Pp$ReactTemplate.str("  ")), Pp$ReactTemplate.str(param[0])), Pp$ReactTemplate.fnl(/* () */0));
                      }), ref_table[0], Pp$ReactTemplate.mt(/* () */0))), Pp$ReactTemplate.fnl(/* () */0));
}

function MakeStringTable(funarg) {
  var compare = Util$ReactTemplate.$$String[/* compare */24];
  var encode = function (x) {
    return x;
  };
  var subst = function (_, x) {
    return x;
  };
  var key = funarg[/* key */0];
  var title = funarg[/* title */1];
  var member_message = funarg[/* member_message */2];
  var A = /* module */[
    /* compare */compare,
    /* table */string_table,
    /* encode */encode,
    /* subst */subst,
    /* printer */Pp$ReactTemplate.str,
    /* key */key,
    /* title */title,
    /* member_message */member_message
  ];
  var nick = Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key);
  if (Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem_assoc */3], nick, string_table[0])) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Sorry, this table name is already used."));
  }
  var MySet = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], /* module */[/* compare */compare]);
  var t = Summary$ReactTemplate.ref(/* None */0, nick, MySet[/* empty */0]);
  var cache_options = function (param) {
    var match = param[1];
    var p = match[1];
    if (match[0] !== 0) {
      t[0] = Curry._2(MySet[/* remove */5], p, t[0]);
      return /* () */0;
    } else {
      t[0] = Curry._2(MySet[/* add */3], p, t[0]);
      return /* () */0;
    }
  };
  var load_options = function (i, o) {
    if (i === 1) {
      return cache_options(o);
    } else {
      return 0;
    }
  };
  var subst_options = function (param) {
    var obj = param[1];
    var p = obj[1];
    if (p === p) {
      return obj;
    } else {
      return /* tuple */[
              obj[0],
              p
            ];
    }
  };
  var init = Libobject$ReactTemplate.default_object(nick);
  var inGo = Libobject$ReactTemplate.declare_object(/* record */[
        /* object_name */init[/* object_name */0],
        /* cache_function */cache_options,
        /* load_function */load_options,
        /* open_function */load_options,
        /* classify_function */(function (x) {
            return /* Substitute */Block.__(0, [x]);
          }),
        /* subst_function */subst_options,
        /* discharge_function */init[/* discharge_function */6],
        /* rebuild_function */init[/* rebuild_function */7]
      ]);
  var match_000 = function (c) {
    return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inGo, /* tuple */[
                    /* GOadd */0,
                    c
                  ]));
  };
  var match_001 = function (c) {
    return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inGo, /* tuple */[
                    /* GOrmv */1,
                    c
                  ]));
  };
  var print_table = function (table_name, printer, table) {
    return Feedback$ReactTemplate.msg_notice(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(table_name), Pp$ReactTemplate.hov(0, Curry._1(MySet[/* is_empty */1], table) ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" None"), Pp$ReactTemplate.fnl(/* () */0)) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._3(MySet[/* fold */13], (function (a, b) {
                                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Curry._1(printer, a)), b);
                                      }), table, Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)))));
  };
  if (!table_of_A_tables[0]) {
    var table_of_A_init = function ($$class) {
      var env = CamlinternalOO.new_variable($$class, "");
      var ids = CamlinternalOO.get_method_labels($$class, shared);
      var remove = ids[0];
      var print = ids[1];
      var mem = ids[2];
      var add = ids[3];
      CamlinternalOO.set_methods($$class, /* array */[
            add,
            (function (self$1, x) {
                var env$1 = self$1[env];
                return Curry._1(env$1[5], Curry._1(env$1[0][/* encode */2], x));
              }),
            remove,
            (function (self$1, x) {
                var env$1 = self$1[env];
                return Curry._1(env$1[4], Curry._1(env$1[0][/* encode */2], x));
              }),
            mem,
            (function (self$1, x) {
                var env$1 = self$1[env];
                var y = Curry._1(env$1[0][/* encode */2], x);
                var answer = Curry._2(env$1[3][/* mem */2], y, env$1[1][0]);
                return Feedback$ReactTemplate.msg_info(/* None */0, Curry._2(env$1[0][/* member_message */7], y, answer));
              }),
            print,
            (function (self$1) {
                var env$1 = self$1[env];
                return Curry._3(env$1[2], env$1[0][/* title */6], env$1[0][/* printer */4], env$1[1][0]);
              })
          ]);
      return (function () {
          return (function (self, _) {
              return CamlinternalOO.create_object_opt(self, $$class);
            });
        });
    };
    CamlinternalOO.make_class_store(shared$1, table_of_A_init, table_of_A_tables);
  }
  var envs_004 = match_001;
  var envs_005 = match_000;
  var envs = [
    A,
    t,
    print_table,
    MySet,
    envs_004,
    envs_005
  ];
  var table_of_A_000 = Curry._1(table_of_A_tables[0], envs);
  var table_of_A_001 = table_of_A_tables[1];
  var table_of_A_002 = table_of_A_tables[0];
  string_table[0] = /* :: */[
    /* tuple */[
      nick,
      Curry._2(table_of_A_000, 0, /* () */0)
    ],
    string_table[0]
  ];
  var active = function (c) {
    return Curry._2(MySet[/* mem */2], c, t[0]);
  };
  var elements = function () {
    return Curry._1(MySet[/* elements */19], t[0]);
  };
  return [
          active,
          elements
        ];
}

function MakeRefTable(funarg) {
  var compare = funarg[/* compare */0];
  var encode = funarg[/* encode */1];
  var subst = funarg[/* subst */2];
  var printer = funarg[/* printer */3];
  var key = funarg[/* key */4];
  var title = funarg[/* title */5];
  var member_message = funarg[/* member_message */6];
  var A = /* module */[
    /* compare */compare,
    /* table */ref_table,
    /* encode */encode,
    /* subst */subst,
    /* printer */printer,
    /* key */key,
    /* title */title,
    /* member_message */member_message
  ];
  var nick = Curry._2(Util$ReactTemplate.$$String[/* concat */6], " ", key);
  if (Curry._2(Util$ReactTemplate.$$String[/* List */40][/* mem_assoc */3], nick, ref_table[0])) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Sorry, this table name is already used."));
  }
  var MySet = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], /* module */[/* compare */compare]);
  var t = Summary$ReactTemplate.ref(/* None */0, nick, MySet[/* empty */0]);
  var cache_options = function (param) {
    var match = param[1];
    var p = match[1];
    if (match[0] !== 0) {
      t[0] = Curry._2(MySet[/* remove */5], p, t[0]);
      return /* () */0;
    } else {
      t[0] = Curry._2(MySet[/* add */3], p, t[0]);
      return /* () */0;
    }
  };
  var load_options = function (i, o) {
    if (i === 1) {
      return cache_options(o);
    } else {
      return 0;
    }
  };
  var subst_options = function (param) {
    var obj = param[1];
    var p = obj[1];
    var p$prime = Curry._2(subst, param[0], p);
    if (p$prime === p) {
      return obj;
    } else {
      return /* tuple */[
              obj[0],
              p$prime
            ];
    }
  };
  var init = Libobject$ReactTemplate.default_object(nick);
  var inGo = Libobject$ReactTemplate.declare_object(/* record */[
        /* object_name */init[/* object_name */0],
        /* cache_function */cache_options,
        /* load_function */load_options,
        /* open_function */load_options,
        /* classify_function */(function (x) {
            return /* Substitute */Block.__(0, [x]);
          }),
        /* subst_function */subst_options,
        /* discharge_function */init[/* discharge_function */6],
        /* rebuild_function */init[/* rebuild_function */7]
      ]);
  var match_000 = function (c) {
    return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inGo, /* tuple */[
                    /* GOadd */0,
                    c
                  ]));
  };
  var match_001 = function (c) {
    return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inGo, /* tuple */[
                    /* GOrmv */1,
                    c
                  ]));
  };
  var print_table = function (table_name, printer, table) {
    return Feedback$ReactTemplate.msg_notice(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(table_name), Pp$ReactTemplate.hov(0, Curry._1(MySet[/* is_empty */1], table) ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" None"), Pp$ReactTemplate.fnl(/* () */0)) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._3(MySet[/* fold */13], (function (a, b) {
                                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Curry._1(printer, a)), b);
                                      }), table, Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.fnl(/* () */0)))));
  };
  if (!table_of_A_tables[0]) {
    var table_of_A_init = function ($$class) {
      var env = CamlinternalOO.new_variable($$class, "");
      var ids = CamlinternalOO.get_method_labels($$class, shared);
      var remove = ids[0];
      var print = ids[1];
      var mem = ids[2];
      var add = ids[3];
      CamlinternalOO.set_methods($$class, /* array */[
            add,
            (function (self$1, x) {
                var env$1 = self$1[env];
                return Curry._1(env$1[5], Curry._1(env$1[0][/* encode */2], x));
              }),
            remove,
            (function (self$1, x) {
                var env$1 = self$1[env];
                return Curry._1(env$1[4], Curry._1(env$1[0][/* encode */2], x));
              }),
            mem,
            (function (self$1, x) {
                var env$1 = self$1[env];
                var y = Curry._1(env$1[0][/* encode */2], x);
                var answer = Curry._2(env$1[3][/* mem */2], y, env$1[1][0]);
                return Feedback$ReactTemplate.msg_info(/* None */0, Curry._2(env$1[0][/* member_message */7], y, answer));
              }),
            print,
            (function (self$1) {
                var env$1 = self$1[env];
                return Curry._3(env$1[2], env$1[0][/* title */6], env$1[0][/* printer */4], env$1[1][0]);
              })
          ]);
      return (function () {
          return (function (self, _) {
              return CamlinternalOO.create_object_opt(self, $$class);
            });
        });
    };
    CamlinternalOO.make_class_store(shared$1, table_of_A_init, table_of_A_tables);
  }
  var envs_004 = match_001;
  var envs_005 = match_000;
  var envs = [
    A,
    t,
    print_table,
    MySet,
    envs_004,
    envs_005
  ];
  var table_of_A_000 = Curry._1(table_of_A_tables[0], envs);
  var table_of_A_001 = table_of_A_tables[1];
  var table_of_A_002 = table_of_A_tables[0];
  ref_table[0] = /* :: */[
    /* tuple */[
      nick,
      Curry._2(table_of_A_000, 0, /* () */0)
    ],
    ref_table[0]
  ];
  var active = function (c) {
    return Curry._2(MySet[/* mem */2], c, t[0]);
  };
  var elements = function () {
    return Curry._1(MySet[/* elements */19], t[0]);
  };
  return [
          active,
          elements
        ];
}

var OptionMap_000 = OptionMap[0];

var OptionMap_001 = OptionMap[1];

var OptionMap_002 = OptionMap[2];

var OptionMap_003 = OptionMap[3];

var OptionMap_004 = OptionMap[4];

var OptionMap_005 = OptionMap[5];

var OptionMap_006 = OptionMap[6];

var OptionMap_007 = OptionMap[7];

var OptionMap_008 = OptionMap[8];

var OptionMap_009 = OptionMap[9];

var OptionMap_010 = OptionMap[10];

var OptionMap_011 = OptionMap[11];

var OptionMap_012 = OptionMap[12];

var OptionMap_013 = OptionMap[13];

var OptionMap_014 = OptionMap[14];

var OptionMap_015 = OptionMap[15];

var OptionMap_016 = OptionMap[16];

var OptionMap_017 = OptionMap[17];

var OptionMap_018 = OptionMap[18];

var OptionMap_019 = OptionMap[19];

var OptionMap_020 = OptionMap[20];

var OptionMap_021 = OptionMap[21];

var OptionMap_022 = OptionMap[22];

var OptionMap_023 = OptionMap[23];

var OptionMap$1 = [
  OptionMap_000,
  OptionMap_001,
  OptionMap_002,
  OptionMap_003,
  OptionMap_004,
  OptionMap_005,
  OptionMap_006,
  OptionMap_007,
  OptionMap_008,
  OptionMap_009,
  OptionMap_010,
  OptionMap_011,
  OptionMap_012,
  OptionMap_013,
  OptionMap_014,
  OptionMap_015,
  OptionMap_016,
  OptionMap_017,
  OptionMap_018,
  OptionMap_019,
  OptionMap_020,
  OptionMap_021,
  OptionMap_022,
  OptionMap_023
];

exports.MakeStringTable = MakeStringTable;
exports.MakeRefTable = MakeRefTable;
exports.declare_int_option = declare_int_option;
exports.declare_bool_option = declare_bool_option;
exports.declare_string_option = declare_string_option;
exports.declare_stringopt_option = declare_stringopt_option;
exports.OptionMap = OptionMap$1;
exports.get_string_table = get_string_table;
exports.get_ref_table = get_ref_table;
exports.set_int_option_value_gen = set_int_option_value_gen;
exports.set_bool_option_value_gen = set_bool_option_value_gen;
exports.set_string_option_value_gen = set_string_option_value_gen;
exports.set_string_option_append_value_gen = set_string_option_append_value_gen;
exports.unset_option_value_gen = unset_option_value_gen;
exports.set_int_option_value = set_int_option_value;
exports.set_bool_option_value = set_bool_option_value;
exports.set_string_option_value = set_string_option_value;
exports.print_option_value = print_option_value;
exports.get_tables = get_tables;
exports.print_tables = print_tables;
exports.error_undeclared_key = error_undeclared_key;
/* OptionMap Not a pure module */
