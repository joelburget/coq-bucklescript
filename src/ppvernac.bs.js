// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Egramml$ReactTemplate = require("./egramml.bs.js");
var Kindops$ReactTemplate = require("./kindops.bs.js");
var Pputils$ReactTemplate = require("./pputils.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Ppconstr$ReactTemplate = require("./ppconstr.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Conv_oracle$ReactTemplate = require("./conv_oracle.bs.js");
var Proof_bullet$ReactTemplate = require("./proof_bullet.bs.js");
var Constrexpr_ops$ReactTemplate = require("./constrexpr_ops.bs.js");

var keyword = Pp$ReactTemplate.str;

function pr_spc_lconstr(param) {
  return Ppconstr$ReactTemplate.pr_sep_com(Pp$ReactTemplate.spc, Ppconstr$ReactTemplate.pr_lconstr_expr, param);
}

function pr_uconstraint(param) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_glob_level(param[0]), Pp$ReactTemplate.spc(/* () */0)), Univ$ReactTemplate.pr_constraint_type(param[1])), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_glob_level(param[2]));
}

function pr_univ_name_list(param) {
  if (param) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@{"), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Ppconstr$ReactTemplate.pr_lname, param[0])), Pp$ReactTemplate.str("}"));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_univdecl_instance(l, extensible) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Ppconstr$ReactTemplate.pr_lident, l), extensible ? Pp$ReactTemplate.str("+") : Pp$ReactTemplate.mt(/* () */0));
}

function pr_univdecl_constraints(l, extensible) {
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], l) && extensible) {
    return Pp$ReactTemplate.mt(/* () */0);
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("|"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                          return Pp$ReactTemplate.str(",");
                        }), pr_uconstraint, l)), extensible ? Pp$ReactTemplate.str("+") : Pp$ReactTemplate.mt(/* () */0));
  }
}

function pr_universe_decl(l) {
  if (l) {
    var l$1 = l[0];
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("@{"), pr_univdecl_instance(l$1[/* univdecl_instance */0], l$1[/* univdecl_extensible_instance */1])), pr_univdecl_constraints(l$1[/* univdecl_constraints */2], l$1[/* univdecl_extensible_constraints */3])), Pp$ReactTemplate.str("}"));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_ident_decl(param) {
  return Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_lident(param[0]), pr_universe_decl(param[1]));
}

function string_of_fqid(fqid) {
  return Curry._2(Util$ReactTemplate.$$String[/* concat */6], ".", Curry._2(Util$ReactTemplate.List[/* map */10], Names$ReactTemplate.Id[/* to_string */7], fqid));
}

function pr_fqid(fqid) {
  return Pp$ReactTemplate.str(string_of_fqid(fqid));
}

function pr_lfqid(param) {
  var loc = param[/* loc */1];
  var fqid = param[/* v */0];
  if (loc) {
    var match = Loc$ReactTemplate.unloc(loc[0]);
    var b = match[0];
    return Pputils$ReactTemplate.pr_located(pr_fqid, Loc$ReactTemplate.tag(/* Some */[Loc$ReactTemplate.make_loc(/* tuple */[
                          b,
                          b + string_of_fqid(fqid).length | 0
                        ])], fqid));
  } else {
    return Pp$ReactTemplate.str(string_of_fqid(fqid));
  }
}

function pr_lname_decl(param) {
  return Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_lname(param[0]), pr_universe_decl(param[1]));
}

function pr_smart_global(param) {
  return Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param);
}

function sep_end(param) {
  if (typeof param === "number") {
    if (param === 5) {
      return Pp$ReactTemplate.str("");
    } else {
      return Pp$ReactTemplate.str(".");
    }
  } else {
    switch (param.tag | 0) {
      case 77 : 
      case 78 : 
          return Pp$ReactTemplate.str("");
      default:
        return Pp$ReactTemplate.str(".");
    }
  }
}

function sep() {
  return Pp$ReactTemplate.spc(/* () */0);
}

function sep_v2() {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(","), Pp$ReactTemplate.spc(/* () */0));
}

function pr_at_level(param) {
  if (param) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("at"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("level")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(param[0]));
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("at"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("next")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("level"));
  }
}

function pr_constr_as_binder_kind(param) {
  switch (param) {
    case 0 : 
        return Pp$ReactTemplate.str("as ident");
    case 1 : 
        return Pp$ReactTemplate.str("as pattern");
    case 2 : 
        return Pp$ReactTemplate.str("as strict pattern");
    
  }
}

function pr_strict(b) {
  if (b) {
    return Pp$ReactTemplate.str("strict ");
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_set_entry_type(pr, param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return Pp$ReactTemplate.str("ident");
      case 1 : 
          return Pp$ReactTemplate.str("global");
      case 2 : 
          return Pp$ReactTemplate.str("bigint");
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          if (param[0] !== 0) {
            return Pp$ReactTemplate.str("binder");
          } else {
            return Pp$ReactTemplate.str("closed binder");
          }
      case 1 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("constr"), Curry._1(pr, param[0]));
      case 2 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(pr, param[1]), Pp$ReactTemplate.spc(/* () */0)), pr_constr_as_binder_kind(param[0]));
      case 3 : 
          var match = param[1];
          var b = param[0];
          if (match) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_strict(b), Pp$ReactTemplate.str("pattern")), Pp$ReactTemplate.spc(/* () */0)), pr_at_level(/* NumLevel */[match[0]]));
          } else {
            return Pp$ReactTemplate.$plus$plus(pr_strict(b), Pp$ReactTemplate.str("pattern"));
          }
      case 4 : 
          return Pp$ReactTemplate.str(param[1]);
      
    }
  }
}

function pr_at_level_opt(param) {
  if (param) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), pr_at_level(param[0]));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_in_out_modules(param) {
  if (param.tag) {
    var l = param[0];
    if (l) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("outside")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, Libnames$ReactTemplate.pr_reference, l));
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("inside")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, Libnames$ReactTemplate.pr_reference, param[0]));
  }
}

function pr_search_about(param) {
  var c = param[1];
  var tmp;
  tmp = c.tag ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.qs(c[0]), Pp$ReactTemplate.pr_opt((function (sc) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("%"), Pp$ReactTemplate.str(sc));
              }), c[1])) : Ppconstr$ReactTemplate.pr_constr_pattern_expr(c[0]);
  return Pp$ReactTemplate.$plus$plus(param[0] ? Pp$ReactTemplate.str("-") : Pp$ReactTemplate.mt(/* () */0), tmp);
}

function pr_explanation(param) {
  var e = param[0];
  var a;
  a = e.tag ? Ppconstr$ReactTemplate.pr_id(e[0]) : CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("No more supported."));
  var a$1 = param[2] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("!"), a) : a;
  if (param[1]) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), a$1), Pp$ReactTemplate.str("]"));
  } else {
    return a$1;
  }
}

function pr_option_ref_value(param) {
  if (param.tag) {
    return Libnames$ReactTemplate.pr_reference(param[0]);
  } else {
    return Pp$ReactTemplate.qs(param[0]);
  }
}

function pr_printoption(table, b) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Pp$ReactTemplate.str, table), Pp$ReactTemplate.pr_opt((function (param) {
                    return Pp$ReactTemplate.prlist_with_sep(sep, pr_option_ref_value, param);
                  }), b));
}

function pr_set_option(a, b) {
  var pr_opt_value = function (param) {
    switch (param.tag | 0) {
      case 0 : 
          return Pp$ReactTemplate.mt(/* () */0);
      case 1 : 
          var match = param[0];
          if (match) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.$$int(match[0]));
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "ppvernac.ml",
                    175,
                    25
                  ]
                ];
          }
          break;
      case 2 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str(param[0]));
      case 3 : 
          var match$1 = param[0];
          if (match$1) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str(match$1[0]));
          } else {
            return Pp$ReactTemplate.mt(/* () */0);
          }
      
    }
  };
  return Pp$ReactTemplate.$plus$plus(pr_printoption(a, /* None */0), pr_opt_value(b));
}

function pr_opt_hintbases(l) {
  if (l) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, Pp$ReactTemplate.str, l));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_reference_or_constr(pr_c, param) {
  if (param.tag) {
    return Curry._1(pr_c, param[0]);
  } else {
    return Libnames$ReactTemplate.pr_reference(param[0]);
  }
}

function pr_hint_mode(param) {
  switch (param) {
    case 0 : 
        return Pp$ReactTemplate.str("+");
    case 1 : 
        return Pp$ReactTemplate.str("!");
    case 2 : 
        return Pp$ReactTemplate.str("-");
    
  }
}

function pr_hint_info(pr_pat, param) {
  var pri = param[/* hint_priority */0];
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_opt((function (x) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("|"), Pp$ReactTemplate.$$int(x));
                  }), pri), Pp$ReactTemplate.pr_opt((function (y) {
                    return Pp$ReactTemplate.$plus$plus(Option$ReactTemplate.is_empty(pri) ? Pp$ReactTemplate.str("| ") : Pp$ReactTemplate.mt(/* () */0), Curry._1(pr_pat, y));
                  }), param[/* hint_pattern */1]));
}

function pr_with_declaration(pr_c, param) {
  if (param.tag) {
    var p = Curry._1(pr_c, param[2]);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Definition"), Pp$ReactTemplate.spc(/* () */0)), pr_lfqid(param[0])), pr_universe_decl(param[1])), Pp$ReactTemplate.str(" := ")), p);
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Module"), Pp$ReactTemplate.spc(/* () */0)), pr_lfqid(param[0])), Pp$ReactTemplate.str(" := ")), Pputils$ReactTemplate.pr_ast(Ppconstr$ReactTemplate.pr_qualid, param[1]));
  }
}

function pr_module_ast(leading_space, pr_c, param) {
  var match = param[/* v */0];
  switch (match.tag | 0) {
    case 0 : 
        var loc = param[/* loc */1];
        var qid = match[0];
        if (leading_space) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pputils$ReactTemplate.pr_located(Ppconstr$ReactTemplate.pr_qualid, /* tuple */[
                          loc,
                          qid
                        ]));
        } else {
          return Pputils$ReactTemplate.pr_located(Ppconstr$ReactTemplate.pr_qualid, /* tuple */[
                      loc,
                      qid
                    ]);
        }
    case 1 : 
        var me2 = match[1];
        var me1 = match[0];
        var exit = 0;
        switch (me2[/* v */0].tag | 0) {
          case 0 : 
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_module_ast(leading_space, pr_c, me1), Pp$ReactTemplate.spc(/* () */0)), pr_module_ast(/* false */0, pr_c, me2));
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        if (exit === 1) {
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_module_ast(leading_space, pr_c, me1), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_module_ast(/* false */0, pr_c, me2)), Pp$ReactTemplate.str(")"))));
        }
        break;
    case 2 : 
        var m = pr_module_ast(leading_space, pr_c, match[0]);
        var p = pr_with_declaration(pr_c, match[1]);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(m, Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.spc(/* () */0)), p);
    
  }
}

function pr_inline(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return Pp$ReactTemplate.mt(/* () */0);
    } else {
      return Pp$ReactTemplate.str("[no inline]");
    }
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("[inline at level "), Pp$ReactTemplate.$$int(param[0])), Pp$ReactTemplate.str("]"));
  }
}

function pr_assumption_inline(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return Pp$ReactTemplate.str("Inline");
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Inline("), Pp$ReactTemplate.$$int(param[0])), Pp$ReactTemplate.str(")"));
  }
}

function pr_module_ast_inl(leading_space, pr_c, param) {
  return Pp$ReactTemplate.$plus$plus(pr_module_ast(leading_space, pr_c, param[0]), pr_inline(param[1]));
}

function pr_of_module_type(prc, param) {
  if (param.tag) {
    return Pp$ReactTemplate.prlist_strict((function (m) {
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("<:"), pr_module_ast_inl(/* true */1, prc, m));
                }), param[0]);
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":"), pr_module_ast_inl(/* true */1, prc, param[0]));
  }
}

function pr_require_token(param) {
  if (param) {
    if (param[0] !== 0) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Export"), Pp$ReactTemplate.spc(/* () */0));
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Import"), Pp$ReactTemplate.spc(/* () */0));
    }
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_module_vardecls(pr_c, param) {
  var m = pr_module_ast(/* true */1, pr_c, param[2][0]);
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_require_token(param[0])), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Ppconstr$ReactTemplate.pr_lident, param[1])), Pp$ReactTemplate.str(":")), m), Pp$ReactTemplate.str(")"))));
}

function pr_type_option(pr_c, c) {
  var match = c[/* v */0];
  var exit = 0;
  if (match.tag === 12) {
    if (typeof match[1] === "number") {
      return Pp$ReactTemplate.mt(/* () */0);
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.brk(/* tuple */[
                        0,
                        2
                      ]), Pp$ReactTemplate.str(" :")), Curry._1(pr_c, c));
  }
  
}

function pr_decl_notation(prc, param) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str("where ")), Pp$ReactTemplate.qs(param[0][/* v */0])), Pp$ReactTemplate.str(" := ")), Flags$ReactTemplate.without_option(Flags$ReactTemplate.beautify, prc, param[1])), Pp$ReactTemplate.pr_opt((function (sc) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(": "), Pp$ReactTemplate.str(sc));
                  }), param[2]));
}

function pr_onescheme(param) {
  var schem = param[1];
  var idop = param[0];
  switch (schem.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(idop ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_lident(idop[0]), Pp$ReactTemplate.str(" :="))), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(schem[0] ? Pp$ReactTemplate.str("Induction for") : Pp$ReactTemplate.str("Minimality for"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, schem[1])))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Sort"), Pp$ReactTemplate.spc(/* () */0)), Termops$ReactTemplate.pr_sort_family(schem[2]))));
    case 1 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(idop ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_lident(idop[0]), Pp$ReactTemplate.str(" :="))), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(schem[0] ? Pp$ReactTemplate.str("Elimination for") : Pp$ReactTemplate.str("Case for"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, schem[1])))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Sort"), Pp$ReactTemplate.spc(/* () */0)), Termops$ReactTemplate.pr_sort_family(schem[2]))));
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(idop ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_lident(idop[0]), Pp$ReactTemplate.str(" :="))), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.str("Equality for"))), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, schem[0]));
    
  }
}

function begin_of_inductive(param) {
  if (param) {
    return Option$ReactTemplate.cata((function (loc) {
                  return Loc$ReactTemplate.unloc(loc)[0];
                }), 0, param[0][1][0][/* loc */1]);
  } else {
    return 0;
  }
}

function pr_class_rawexpr(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return Pp$ReactTemplate.str("Sortclass");
    } else {
      return Pp$ReactTemplate.str("Funclass");
    }
  } else {
    return Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param[0]);
  }
}

function pr_assumption_token(many, discharge, kind) {
  if (discharge !== 0) {
    switch (kind) {
      case 0 : 
          return Pp$ReactTemplate.str(many ? "Parameters" : "Parameter");
      case 1 : 
          return Pp$ReactTemplate.str(many ? "Axioms" : "Axiom");
      case 2 : 
          return Pp$ReactTemplate.str("Conjecture");
      
    }
  } else {
    switch (kind) {
      case 0 : 
          return Pp$ReactTemplate.str(many ? "Variables" : "Variable");
      case 1 : 
          return Pp$ReactTemplate.str(many ? "Hypotheses" : "Hypothesis");
      case 2 : 
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Don't know how to beautify a local conjecture."));
      
    }
  }
}

function pr_params(pr_c, param) {
  var match = param[1];
  return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(sep, Ppconstr$ReactTemplate.pr_lident, param[0]), Pp$ReactTemplate.spc(/* () */0)), match[0] ? Pp$ReactTemplate.str(":>") : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":"), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pr_c, match[1]))));
}

function factorize(param) {
  if (param) {
    var match = param[0];
    var match$1 = match[1];
    var t = match$1[1];
    var idl = match$1[0];
    var c = match[0];
    var l$prime = factorize(param[1]);
    var exit = 0;
    if (l$prime) {
      var match$2 = l$prime[0];
      var r = match$2[1];
      if (c === r[0] && Caml_obj.caml_equal(t, r[1])) {
        return /* :: */[
                /* tuple */[
                  Util$ReactTemplate.$at(idl, match$2[0]),
                  r
                ],
                l$prime[1]
              ];
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* :: */[
              /* tuple */[
                idl,
                /* tuple */[
                  c,
                  t
                ]
              ],
              l$prime
            ];
    }
    
  } else {
    return /* [] */0;
  }
}

function pr_ne_params_list(pr_c, l) {
  var l$1 = factorize(l);
  var exit = 0;
  if (l$1) {
    if (l$1[1]) {
      exit = 1;
    } else {
      return pr_params(pr_c, l$1[0]);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (p) {
                  return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_params(pr_c, p)), Pp$ReactTemplate.str(")")));
                }), l$1);
  }
  
}

function pr_syntax_modifier(param) {
  if (typeof param === "number") {
    if (param) {
      return Pp$ReactTemplate.str("only printing");
    } else {
      return Pp$ReactTemplate.str("only parsing");
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(sep_v2, Pp$ReactTemplate.str, param[0]), Pp$ReactTemplate.spc(/* () */0)), pr_at_level(param[1]));
      case 1 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(sep_v2, Pp$ReactTemplate.str, param[0]), Pp$ReactTemplate.spc(/* () */0)), pr_at_level_opt(param[2])), Pp$ReactTemplate.spc(/* () */0)), pr_constr_as_binder_kind(param[1]));
      case 2 : 
          return pr_at_level(/* NumLevel */[param[0]]);
      case 3 : 
          switch (param[0]) {
            case 0 : 
                return Pp$ReactTemplate.str("no associativity");
            case 1 : 
                return Pp$ReactTemplate.str("right associativity");
            case 2 : 
                return Pp$ReactTemplate.str("left associativity");
            
          }
          break;
      case 4 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(param[0]), Pp$ReactTemplate.spc(/* () */0)), pr_set_entry_type(pr_at_level_opt, param[1]));
      case 5 : 
          return Pp$ReactTemplate.str("compat \"" + (Flags$ReactTemplate.pr_version(param[0]) + "\""));
      case 6 : 
          var k = param[0];
          if (k === "text") {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("format "), Pputils$ReactTemplate.pr_ast(Pp$ReactTemplate.qs, param[1]));
          } else {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("format "), Pp$ReactTemplate.qs(k)), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_ast(Pp$ReactTemplate.qs, param[1]));
          }
          break;
      
    }
  }
}

function pr_syntax_modifiers(l) {
  if (l) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), Pp$ReactTemplate.prlist_with_sep(sep_v2, pr_syntax_modifier, l)), Pp$ReactTemplate.str(")"))));
  } else {
    return Pp$ReactTemplate.mt(/* () */0);
  }
}

function pr_rec_definition(param) {
  var match = param[0];
  var bl = match[2];
  var annot = Ppconstr$ReactTemplate.pr_guard_annot(Ppconstr$ReactTemplate.pr_lconstr_expr, bl, match[1]);
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_ident_decl(match[0]), Pp$ReactTemplate.pr_non_empty_arg(Ppconstr$ReactTemplate.pr_binders, bl)), annot), pr_type_option((function (c) {
                            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Ppconstr$ReactTemplate.pr_lconstr_expr(c));
                          }), match[3])), Pp$ReactTemplate.pr_opt((function (def) {
                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":="), Pp$ReactTemplate.brk(/* tuple */[
                                            1,
                                            2
                                          ])), Flags$ReactTemplate.without_option(Flags$ReactTemplate.beautify, Ppconstr$ReactTemplate.pr_lconstr_expr, def));
                      }), match[4])), Pp$ReactTemplate.prlist((function (param) {
                    return pr_decl_notation(Ppconstr$ReactTemplate.pr_constr_expr, param);
                  }), param[1]));
}

function pr_statement(head, param) {
  var match = param[1];
  var bl = match[0];
  return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(head, Pp$ReactTemplate.spc(/* () */0)), pr_ident_decl(param[0])), Pp$ReactTemplate.spc(/* () */0)), bl ? Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_binders(bl), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.str(":")), Ppconstr$ReactTemplate.pr_sep_com(Pp$ReactTemplate.spc, Ppconstr$ReactTemplate.pr_lconstr_expr, match[1])));
}

function pr_constrarg(c) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Ppconstr$ReactTemplate.pr_constr_expr(c));
}

function pr_lconstrarg(c) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Ppconstr$ReactTemplate.pr_lconstr_expr(c));
}

function pr_intarg(n) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.$$int(n));
}

function pr_oc(param) {
  if (param) {
    if (param[0] !== 0) {
      return Pp$ReactTemplate.str(" :>");
    } else {
      return Pp$ReactTemplate.str(" :>>");
    }
  } else {
    return Pp$ReactTemplate.str(" :");
  }
}

function pr_record_field(param) {
  var match = param[0];
  var pri = match[1];
  var x = match[0];
  var match$1 = x[1];
  var oc = x[0];
  var prx;
  if (match$1.tag) {
    var opt = match$1[2];
    var b = match$1[1];
    var id = match$1[0];
    prx = opt ? Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_lname(id), pr_oc(oc)), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lconstr_expr(opt[0])), Pp$ReactTemplate.str(" :=")), Ppconstr$ReactTemplate.pr_lconstr_expr(b))) : Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_lname(id), Pp$ReactTemplate.str(" :=")), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lconstr_expr(b)));
  } else {
    prx = Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_lname(match$1[0]), pr_oc(oc)), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lconstr_expr(match$1[1])));
  }
  var prpri = pri ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("| "), Pp$ReactTemplate.$$int(pri[0])) : Pp$ReactTemplate.mt(/* () */0);
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(prx, prpri), Pp$ReactTemplate.prlist((function (param) {
                    return pr_decl_notation(Ppconstr$ReactTemplate.pr_constr_expr, param);
                  }), param[1]));
}

function pr_using(e) {
  var aux = function (param) {
    if (typeof param === "number") {
      if (param) {
        return "(Type)";
      } else {
        return "()";
      }
    } else {
      switch (param.tag | 0) {
        case 0 : 
            return "(" + (Names$ReactTemplate.Id[/* to_string */7](param[0][/* v */0]) + ")");
        case 1 : 
            return "-" + (aux(param[0]) + "");
        case 2 : 
            return "(" + (aux(param[0]) + (" + " + (aux(param[1]) + ")")));
        case 3 : 
            return "(" + (aux(param[0]) + (" - " + (aux(param[1]) + ")")));
        case 4 : 
            return "(" + (aux(param[0]) + ")*");
        
      }
    }
  };
  return Pp$ReactTemplate.str(aux(e));
}

function pr_vernac_expr(v) {
  if (typeof v === "number") {
    switch (v) {
      case 0 : 
          return Pp$ReactTemplate.str("Reset Initial");
      case 1 : 
          return Pp$ReactTemplate.str("Abort All");
      case 2 : 
          return Pp$ReactTemplate.str("Restart");
      case 3 : 
          return Pp$ReactTemplate.str("Unfocus");
      case 4 : 
          return Pp$ReactTemplate.str("Unfocused");
      case 5 : 
          return Pp$ReactTemplate.str("}");
      case 6 : 
          return Pp$ReactTemplate.str("Guarded");
      
    }
  } else {
    switch (v.tag | 0) {
      case 0 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Load"), v[0] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("Verbose")), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.qs(v[1])));
      case 1 : 
          var match = v[1];
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Reserved Notation"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_ast(Pp$ReactTemplate.qs, match[0])), pr_syntax_modifiers(match[1]));
      case 2 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(v[0] ? "Open " : "Close "), Pp$ReactTemplate.str("Scope")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(v[1]));
      case 3 : 
          var match$1 = v[1];
          var sc = v[0];
          if (match$1) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Delimit Scope"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(sc)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(match$1[0]));
          } else {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Undelimit Scope"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(sc));
          }
      case 4 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Bind Scope"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(v[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_class_rawexpr, v[1]));
      case 5 : 
          var sn = v[2];
          var match$2 = v[0];
          return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Infix "), Pp$ReactTemplate.qs(match$2[0][/* v */0])), Pp$ReactTemplate.str(" :=")), pr_constrarg(v[1]))), pr_syntax_modifiers(match$2[1])), sn ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(sn[0])) : Pp$ReactTemplate.mt(/* () */0)));
      case 6 : 
          var opt = v[2];
          var match$3 = v[1];
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.qs(match$3[0][/* v */0])), Pp$ReactTemplate.str(" :=")), Flags$ReactTemplate.without_option(Flags$ReactTemplate.beautify, pr_constrarg, v[0])), pr_syntax_modifiers(match$3[1])), opt ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" :"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(opt[0])) : Pp$ReactTemplate.mt(/* () */0)));
      case 7 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Format Notation "), Pp$ReactTemplate.qs(v[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.qs(v[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.qs(v[2]));
      case 8 : 
          var id = v[1];
          var pr_def_token = function (dk) {
            return Pp$ReactTemplate.str(Names$ReactTemplate.Name[/* is_anonymous */1](id[0][/* v */0]) ? "Goal" : Kindops$ReactTemplate.string_of_definition_object_kind(dk));
          };
          var pr_reduce = function (param) {
            if (param) {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Eval"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_red_expr(/* tuple */[
                                      Ppconstr$ReactTemplate.pr_constr_expr,
                                      Ppconstr$ReactTemplate.pr_lconstr_expr,
                                      pr_smart_global,
                                      Ppconstr$ReactTemplate.pr_constr_expr
                                    ], keyword, param[0])), Pp$ReactTemplate.str(" in")), Pp$ReactTemplate.spc(/* () */0));
            } else {
              return Pp$ReactTemplate.mt(/* () */0);
            }
          };
          var pr_def_body = function (param) {
            if (param.tag) {
              var d = param[3];
              var ty = d ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str(":")), Ppconstr$ReactTemplate.pr_sep_com(Pp$ReactTemplate.spc, Ppconstr$ReactTemplate.pr_lconstr_expr, d[0])) : Pp$ReactTemplate.mt(/* () */0);
              return /* tuple */[
                      Pp$ReactTemplate.pr_non_empty_arg(Ppconstr$ReactTemplate.pr_binders, param[0]),
                      ty,
                      /* Some */[Pp$ReactTemplate.$plus$plus(pr_reduce(param[1]), Ppconstr$ReactTemplate.pr_lconstr_expr(param[2]))]
                    ];
            } else {
              var bl = param[0];
              var typ = function (u) {
                if (id[0][/* v */0]) {
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" :"), u);
                } else {
                  if (bl !== /* [] */0) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "ppvernac.ml",
                            718,
                            56
                          ]
                        ];
                  }
                  return u;
                }
              };
              return /* tuple */[
                      Pp$ReactTemplate.pr_non_empty_arg(Ppconstr$ReactTemplate.pr_binders, bl),
                      typ(Ppconstr$ReactTemplate.pr_sep_com(Pp$ReactTemplate.spc, Ppconstr$ReactTemplate.pr_lconstr_expr, param[1])),
                      /* None */0
                    ];
            }
          };
          var match$4 = pr_def_body(v[2]);
          var c = match$4[2];
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_def_token(v[0][1]), Pp$ReactTemplate.spc(/* () */0)), pr_lname_decl(id)), match$4[0]), match$4[1]), c ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" :="), Pp$ReactTemplate.spc(/* () */0)), c[0]) : Pp$ReactTemplate.mt(/* () */0)));
      case 9 : 
          var l = v[1];
          var partial_arg = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("with"));
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(pr_statement(Pp$ReactTemplate.str(Kindops$ReactTemplate.string_of_theorem_kind(v[0])), Curry._1(Util$ReactTemplate.List[/* hd */1], l)), Pp$ReactTemplate.prlist((function (param) {
                                return pr_statement(partial_arg, param);
                              }), Curry._1(Util$ReactTemplate.List[/* tl */2], l))));
      case 10 : 
          var match$5 = v[0];
          if (match$5) {
            var o = match$5[1];
            var opac = match$5[0];
            if (o) {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(opac !== /* Transparent */1 ? Pp$ReactTemplate.str("Save") : Pp$ReactTemplate.str("Defined"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lident(o[0]));
            } else if (opac !== 0) {
              return Pp$ReactTemplate.str("Defined");
            } else {
              return Pp$ReactTemplate.str("Qed");
            }
          } else {
            return Pp$ReactTemplate.str("Admitted");
          }
          break;
      case 11 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Proof"), pr_lconstrarg(v[0])));
      case 12 : 
          var l$1 = v[2];
          var match$6 = v[0];
          var n = Curry._1(Util$ReactTemplate.List[/* length */0], Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                          return prim[0];
                        }), Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                              return prim[1];
                            }), l$1))));
          var pr_params = function (param) {
            var match = param[1];
            return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(sep, pr_ident_decl, match[0]), Pp$ReactTemplate.spc(/* () */0)), param[0] ? Pp$ReactTemplate.str(":>") : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lconstr_expr(match[1]))));
          };
          var assumptions = Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (p) {
                  return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_params(p)), Pp$ReactTemplate.str(")")));
                }), l$1);
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_assumption_token(+(n > 1), match$6[0], match$6[1]), Pp$ReactTemplate.pr_non_empty_arg(pr_assumption_inline, v[1])), Pp$ReactTemplate.spc(/* () */0)), assumptions));
      case 13 : 
          var l$2 = v[3];
          var cum = v[0];
          var pr_constructor = function (param) {
            var match = param[1];
            return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_lident(match[0]), Pp$ReactTemplate.str(" ")), param[0] ? Pp$ReactTemplate.str(":>") : Pp$ReactTemplate.str(":")), Flags$ReactTemplate.without_option(Flags$ReactTemplate.beautify, pr_spc_lconstr, match[1])));
          };
          var pr_constructor_list = function (b, l) {
            if (l.tag) {
              var c = l[0];
              var fs = l[1];
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_opt(Ppconstr$ReactTemplate.pr_lident, c), c ? Pp$ReactTemplate.str(" {") : Pp$ReactTemplate.str("{")), Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_semicolon, pr_record_field, fs), Pp$ReactTemplate.str("}"))));
            } else {
              var l$1 = l[0];
              if (l$1) {
                var fst_sep = l$1 && !l$1[1] ? "   " : " | ";
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Ppconstr$ReactTemplate.pr_com_at(begin_of_inductive(l$1)), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str(fst_sep)), Pp$ReactTemplate.prlist_with_sep((function () {
                                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str(" | "));
                                }), pr_constructor, l$1));
              } else {
                return Pp$ReactTemplate.mt(/* () */0);
              }
            }
          };
          var pr_oneind = function (key, param) {
            var match = param[0];
            var match$1 = match[0];
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(key), Pp$ReactTemplate.spc(/* () */0)), match$1[0] ? Pp$ReactTemplate.str("> ") : Pp$ReactTemplate.str("")), pr_ident_decl(match$1[1])), Pp$ReactTemplate.pr_non_empty_arg(Ppconstr$ReactTemplate.pr_binders, match[1])), Pp$ReactTemplate.pr_opt((function (s) {
                                              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lconstr_expr(s));
                                            }), match[2])), Pp$ReactTemplate.str(" :="))), pr_constructor_list(match[3], match[4])), Pp$ReactTemplate.prlist((function (param) {
                              return pr_decl_notation(Ppconstr$ReactTemplate.pr_constr_expr, param);
                            }), param[1]));
          };
          var match$7 = Curry._1(Util$ReactTemplate.List[/* hd */1], l$2);
          var k = match$7[0][3];
          var kind;
          if (typeof k === "number") {
            switch (k) {
              case 0 : 
                  kind = "Inductive";
                  break;
              case 1 : 
                  kind = "CoInductive";
                  break;
              case 2 : 
                  kind = "Variant";
                  break;
              case 3 : 
                  kind = "Record";
                  break;
              case 4 : 
                  kind = "Structure";
                  break;
              
            }
          } else {
            kind = "Class";
          }
          var key;
          if (v[1]) {
            var cm = cum !== 1 && cum < 3 ? "Cumulative" : "NonCumulative";
            key = cm + (" " + kind);
          } else {
            key = kind;
          }
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hov(1, pr_oneind(key, Curry._1(Util$ReactTemplate.List[/* hd */1], l$2))), Pp$ReactTemplate.prlist((function (ind) {
                            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.hov(1, pr_oneind("with", ind)));
                          }), Curry._1(Util$ReactTemplate.List[/* tl */2], l$2)));
      case 14 : 
          var local = v[0] !== 0 ? "" : "Let ";
          return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(local), Pp$ReactTemplate.str("Fixpoint")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.spc(/* () */0));
                              }), pr_rec_definition, v[1])));
      case 15 : 
          var local$1 = v[0] !== 0 ? Pp$ReactTemplate.str("") : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Let"), Pp$ReactTemplate.spc(/* () */0));
          var pr_onecorec = function (param) {
            var match = param[0];
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_ident_decl(match[0]), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_binders(match[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lconstr_expr(match[2])), Pp$ReactTemplate.pr_opt((function (def) {
                                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":="), Pp$ReactTemplate.brk(/* tuple */[
                                                      1,
                                                      2
                                                    ])), Ppconstr$ReactTemplate.pr_lconstr_expr(def));
                                }), match[3])), Pp$ReactTemplate.prlist((function (param) {
                              return pr_decl_notation(Ppconstr$ReactTemplate.pr_constr_expr, param);
                            }), param[1]));
          };
          return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(local$1, Pp$ReactTemplate.str("CoFixpoint")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.spc(/* () */0));
                              }), pr_onecorec, v[1])));
      case 16 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Scheme"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.spc(/* () */0));
                              }), pr_onescheme, v[0])));
      case 17 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Combined Scheme"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lident(v[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("from")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.fnl(/* () */0), Pp$ReactTemplate.str(", "));
                              }), Ppconstr$ReactTemplate.pr_lident, v[1])));
      case 18 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Universe"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.str(",");
                              }), Ppconstr$ReactTemplate.pr_lident, v[0])));
      case 19 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Constraint"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.str(",");
                              }), pr_uconstraint, v[0])));
      case 20 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Section"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lident(v[0])));
      case 21 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("End"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lident(v[0])));
      case 22 : 
          var from = v[0];
          var from$1 = from ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("From"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_reference(from[0])), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.mt(/* () */0);
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(from$1, Pp$ReactTemplate.str("Require")), Pp$ReactTemplate.spc(/* () */0)), pr_require_token(v[1])), Pp$ReactTemplate.prlist_with_sep(sep, Libnames$ReactTemplate.pr_reference, v[2])));
      case 23 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(v[0] ? Pp$ReactTemplate.str("Export") : Pp$ReactTemplate.str("Import"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, Libnames$ReactTemplate.pr_reference, v[1]));
      case 24 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Canonical Structure"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, v[0]));
      case 25 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Coercion"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, v[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), pr_class_rawexpr(v[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(">->")), Pp$ReactTemplate.spc(/* () */0)), pr_class_rawexpr(v[2])));
      case 26 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Identity Coercion"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lident(v[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), pr_class_rawexpr(v[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(">->")), Pp$ReactTemplate.spc(/* () */0)), pr_class_rawexpr(v[2])));
      case 27 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Package"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lident(v[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(":=")), Pp$ReactTemplate.spc(/* () */0)), pr_using(v[1])));
      case 28 : 
          var props = v[3];
          var match$8 = v[2];
          var instid = match$8[0];
          var match$9 = instid[0];
          var match$10 = match$9[/* v */0];
          var tmp;
          if (props) {
            var match$11 = props[0];
            if (match$11[0] !== 0) {
              var match$12 = match$11[1][/* v */0];
              if (match$12.tag === 8) {
                tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str(":=")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("{")), Ppconstr$ReactTemplate.pr_record_body(match$12[0])), Pp$ReactTemplate.str("}"));
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "ppvernac.ml",
                        906,
                        35
                      ]
                    ];
              }
            } else {
              tmp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str(":=")), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_constr_expr(match$11[1]));
            }
          } else {
            tmp = Pp$ReactTemplate.mt(/* () */0);
          }
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(v[0] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Declare"), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.mt(/* () */0), Pp$ReactTemplate.str("Instance")), match$10 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), pr_ident_decl(/* tuple */[
                                                                    CAst$ReactTemplate.make(match$9[/* loc */1], match$10[0]),
                                                                    instid[1]
                                                                  ])), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.pr_non_empty_arg(Ppconstr$ReactTemplate.pr_binders, v[1])), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), match$8[1] !== 0 ? Pp$ReactTemplate.str("! ") : Pp$ReactTemplate.mt(/* () */0)), Ppconstr$ReactTemplate.pr_constr_expr(match$8[2])), pr_hint_info(Ppconstr$ReactTemplate.pr_constr_pattern_expr, v[4])), tmp));
      case 29 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Context"), Pp$ReactTemplate.pr_non_empty_arg(Ppconstr$ReactTemplate.pr_binders, v[0])));
      case 30 : 
          var insts = v[0];
          var pr_inst = function (param) {
            return Pp$ReactTemplate.$plus$plus(Libnames$ReactTemplate.pr_reference(param[0]), pr_hint_info(Ppconstr$ReactTemplate.pr_constr_pattern_expr, param[1]));
          };
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Existing"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* plural */33], Curry._1(Util$ReactTemplate.List[/* length */0], insts), "Instance"))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.str(", ");
                              }), pr_inst, insts)));
      case 31 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Existing"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("Class")), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_reference(v[0])));
      case 32 : 
          var b = Pp$ReactTemplate.prlist_strict((function (param) {
                  return pr_module_vardecls(Ppconstr$ReactTemplate.pr_lconstr_expr, param);
                }), v[2]);
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Declare Module"), Pp$ReactTemplate.spc(/* () */0)), pr_require_token(v[0])), Ppconstr$ReactTemplate.pr_lident(v[1])), b), Pp$ReactTemplate.str(" :")), pr_module_ast_inl(/* true */1, Ppconstr$ReactTemplate.pr_lconstr_expr, v[3])));
      case 33 : 
          var bd = v[4];
          var b$1 = Pp$ReactTemplate.prlist_strict((function (param) {
                  return pr_module_vardecls(Ppconstr$ReactTemplate.pr_lconstr_expr, param);
                }), v[2]);
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Module"), Pp$ReactTemplate.spc(/* () */0)), pr_require_token(v[0])), Ppconstr$ReactTemplate.pr_lident(v[1])), b$1), pr_of_module_type(Ppconstr$ReactTemplate.pr_lconstr_expr, v[3])), Curry._1(Util$ReactTemplate.List[/* is_empty */45], bd) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.str(":= ")), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.str(" <+");
                              }), (function (param) {
                                return pr_module_ast_inl(/* true */1, Ppconstr$ReactTemplate.pr_lconstr_expr, param);
                              }), bd)));
      case 34 : 
          var m = v[3];
          var b$2 = Pp$ReactTemplate.prlist_strict((function (param) {
                  return pr_module_vardecls(Ppconstr$ReactTemplate.pr_lconstr_expr, param);
                }), v[1]);
          var pr_mt = function (param) {
            return pr_module_ast_inl(/* true */1, Ppconstr$ReactTemplate.pr_lconstr_expr, param);
          };
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Module Type "), Ppconstr$ReactTemplate.pr_lident(v[0])), b$2), Pp$ReactTemplate.prlist_strict((function (m) {
                                        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" <:"), pr_module_ast_inl(/* true */1, Ppconstr$ReactTemplate.pr_lconstr_expr, m));
                                      }), v[2])), Curry._1(Util$ReactTemplate.List[/* is_empty */45], m) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.str(":= ")), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.str(" <+ ");
                              }), pr_mt, m)));
      case 35 : 
          var pr_m = function (param) {
            return pr_module_ast_inl(/* false */0, Ppconstr$ReactTemplate.pr_lconstr_expr, param);
          };
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Include"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                                return Pp$ReactTemplate.str(" <+ ");
                              }), pr_m, v[0])));
      case 36 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Existential"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(v[0])), pr_lconstrarg(v[1]));
      case 37 : 
          var d = v[2];
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Add"), v[0] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("Rec")), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("LoadPath")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.qs(v[1])), d ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("as")), Pp$ReactTemplate.spc(/* () */0)), Names$ReactTemplate.DirPath[/* print */10](d[0])) : Pp$ReactTemplate.mt(/* () */0)));
      case 38 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Remove LoadPath"), Pp$ReactTemplate.qs(v[0]));
      case 39 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Add"), v[0] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("Rec")), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("ML Path")), Pp$ReactTemplate.qs(v[1]));
      case 40 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Declare ML Module"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, Pp$ReactTemplate.qs, v[0])));
      case 41 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cd"), Pp$ReactTemplate.pr_opt(Pp$ReactTemplate.qs, v[0]));
      case 42 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Write State"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.qs(v[0]));
      case 43 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Restore State"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.qs(v[0]));
      case 44 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Reset"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lident(v[0]));
      case 45 : 
          var i = v[0];
          if (i === 1) {
            return Pp$ReactTemplate.str("Back");
          } else {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Back"), pr_intarg(i));
          }
      case 46 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("BackTo"), pr_intarg(v[0]));
      case 47 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Create HintDb"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(v[0])), v[1] ? Pp$ReactTemplate.str(" discriminated") : Pp$ReactTemplate.mt(/* () */0)));
      case 48 : 
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Remove Hints"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (r) {
                                    return Ppconstr$ReactTemplate.pr_id(Constrexpr_ops$ReactTemplate.coerce_reference_to_id(r));
                                  }), v[1])), pr_opt_hintbases(v[0])));
      case 49 : 
          var db = v[0];
          var h = v[1];
          var pr_c = Ppconstr$ReactTemplate.pr_constr_expr;
          var pr_pat = Ppconstr$ReactTemplate.pr_constr_pattern_expr;
          var opth = pr_opt_hintbases(db);
          var pph;
          switch (h.tag | 0) {
            case 0 : 
                pph = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Resolve "), Pp$ReactTemplate.prlist_with_sep(sep, (function (param) {
                            return Pp$ReactTemplate.$plus$plus(pr_reference_or_constr(pr_c, param[2]), pr_hint_info(pr_pat, param[0]));
                          }), h[0]));
                break;
            case 1 : 
                pph = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Immediate"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, (function (c) {
                            return pr_reference_or_constr(pr_c, c);
                          }), h[0]));
                break;
            case 2 : 
                pph = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Unfold"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, Libnames$ReactTemplate.pr_reference, h[0]));
                break;
            case 3 : 
                pph = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(h[1] ? "Transparent" : "Opaque"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, Libnames$ReactTemplate.pr_reference, h[0]));
                break;
            case 4 : 
                pph = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Mode"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_reference(h[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_hint_mode, h[1]));
                break;
            case 5 : 
                pph = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Constructors"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Libnames$ReactTemplate.pr_reference, h[0]));
                break;
            case 6 : 
                var c$1 = h[1];
                var pat = c$1 ? Curry._1(pr_pat, c$1[0]) : Pp$ReactTemplate.mt(/* () */0);
                pph = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Extern"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(h[0])), Pp$ReactTemplate.spc(/* () */0)), pat), Pp$ReactTemplate.str(" =>")), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_raw_generic(Global$ReactTemplate.env(/* () */0), h[2]));
                break;
            
          }
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Hint "), pph), opth));
      case 50 : 
          var compat = v[2];
          var match$13 = v[1];
          var tmp$1;
          if (compat) {
            var v$1 = compat[0];
            tmp$1 = v$1 >= 2 ? /* :: */[
                /* SetOnlyParsing */0,
                /* [] */0
              ] : /* :: */[
                /* SetCompatVersion */Block.__(5, [v$1]),
                /* [] */0
              ];
          } else {
            tmp$1 = /* [] */0;
          }
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Notation"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lident(v[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Ppconstr$ReactTemplate.pr_id, match$13[0])), Pp$ReactTemplate.str(":=")), pr_constrarg(match$13[1])), pr_syntax_modifiers(tmp$1)));
      case 51 : 
          var impls = v[1];
          var q = v[0];
          if (impls) {
            return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Implicit Arguments"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, q)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (imps) {
                                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Pp$ReactTemplate.prlist_with_sep(sep, pr_explanation, imps)), Pp$ReactTemplate.str("]"));
                                }), impls)));
          } else {
            return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Implicit Arguments"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, q)));
          }
      case 52 : 
          var mods = v[4];
          var more_implicits = v[2];
          var pr_s = function (param) {
            if (param) {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("%"), Pp$ReactTemplate.str(param[0][/* v */0]));
            } else {
              return Pp$ReactTemplate.str("");
            }
          };
          var pr_if = function (b, x) {
            if (b) {
              return x;
            } else {
              return Pp$ReactTemplate.str("");
            }
          };
          var pr_br = function (imp, x) {
            switch (imp) {
              case 0 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), x), Pp$ReactTemplate.str("]"));
              case 1 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{"), x), Pp$ReactTemplate.str("}"));
              case 2 : 
                  return x;
              
            }
          };
          var print_arguments = function (n, l) {
            var exit = 0;
            if (n) {
              if (n[0] !== 0) {
                exit = 1;
              } else {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("/")), print_arguments(/* None */0, l));
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              if (l) {
                var match = l[0];
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), pr_br(match[/* implicit_status */3], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_if(match[/* recarg_like */1], Pp$ReactTemplate.str("!")), Names$ReactTemplate.Name[/* print */7](match[/* name */0])), pr_s(match[/* notation_scope */2])))), print_arguments(Option$ReactTemplate.map((function (prim) {
                                      return prim - 1 | 0;
                                    }), n), l[1]));
              } else {
                return Pp$ReactTemplate.mt(/* () */0);
              }
            }
            
          };
          var print_implicits = function (param) {
            if (param) {
              var match = param[0];
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), pr_br(match[1], Names$ReactTemplate.Name[/* print */7](match[0]))), print_implicits(param[1]));
            } else {
              return Pp$ReactTemplate.mt(/* () */0);
            }
          };
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Arguments"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, v[0])), Pp$ReactTemplate.$plus$plus(print_arguments(v[3], v[1]), Curry._1(Util$ReactTemplate.List[/* is_empty */45], more_implicits) ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.mt(/* () */0), Curry._1(Util$ReactTemplate.List[/* is_empty */45], mods) ? Pp$ReactTemplate.str("") : Pp$ReactTemplate.str(" : ")), Pp$ReactTemplate.prlist_with_sep((function () {
                                          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(", "), Pp$ReactTemplate.spc(/* () */0));
                                        }), (function (param) {
                                          if (param >= 676717295) {
                                            if (param >= 1012736563) {
                                              if (param >= 1032426924) {
                                                return Pp$ReactTemplate.str("clear scopes");
                                              } else {
                                                return Pp$ReactTemplate.str("simpl never");
                                              }
                                            } else if (param >= 968597406) {
                                              return Pp$ReactTemplate.str("rename");
                                            } else {
                                              return Pp$ReactTemplate.str("extra scopes");
                                            }
                                          } else if (param >= -560228223) {
                                            if (param >= 9943782) {
                                              return Pp$ReactTemplate.str("assert");
                                            } else {
                                              return Pp$ReactTemplate.str("clear implicits");
                                            }
                                          } else if (param >= -751570227) {
                                            return Pp$ReactTemplate.str("default implicits");
                                          } else {
                                            return Pp$ReactTemplate.str("simpl nomatch");
                                          }
                                        }), mods)) : Pp$ReactTemplate.prlist((function (l) {
                                      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(","), print_implicits(l));
                                    }), more_implicits))));
      case 53 : 
          var pr_opt_scope = function (param) {
            if (param) {
              return Pp$ReactTemplate.str(param[0]);
            } else {
              return Pp$ReactTemplate.str("_");
            }
          };
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Arguments Scope"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, v[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("[")), Pp$ReactTemplate.prlist_with_sep(sep, pr_opt_scope, v[1])), Pp$ReactTemplate.str("]"));
      case 54 : 
          var bl = v[0];
          var n$1 = Curry._1(Util$ReactTemplate.List[/* length */0], Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                          return prim[0];
                        }), bl)));
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Implicit Type"), Pp$ReactTemplate.str(n$1 > 1 ? "s " : " ")), pr_ne_params_list(Ppconstr$ReactTemplate.pr_lconstr_expr, Curry._2(Util$ReactTemplate.List[/* map */10], (function (sb) {
                                    return /* tuple */[
                                            /* false */0,
                                            sb
                                          ];
                                  }), bl))));
      case 55 : 
          var g = v[0];
          var tmp$2;
          if (g) {
            var idl = g[0];
            tmp$2 = idl ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(Curry._1(Util$ReactTemplate.List[/* length */0], idl) > 1 ? "s " : " "), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, Ppconstr$ReactTemplate.pr_lident, idl)) : Pp$ReactTemplate.str("s all");
          } else {
            tmp$2 = Pp$ReactTemplate.str("s none");
          }
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Generalizable Variable"), tmp$2));
      case 56 : 
          var match$14 = v[0];
          var k$1 = match$14[0];
          if (Conv_oracle$ReactTemplate.is_transparent(k$1)) {
            return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Transparent"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, pr_smart_global, match$14[1])));
          } else if (typeof k$1 === "number" && k$1 !== 0) {
            return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Opaque"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, pr_smart_global, match$14[1])));
          } else {
            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("VernacSetOpacity used to set something else."));
          }
      case 57 : 
          var pr_lev = function (l) {
            if (typeof l === "number") {
              if (l !== 0) {
                return Pp$ReactTemplate.str("opaque");
              } else {
                return Pp$ReactTemplate.str("expand");
              }
            } else if (Conv_oracle$ReactTemplate.is_transparent(l)) {
              return Pp$ReactTemplate.str("transparent");
            } else {
              return Pp$ReactTemplate.$$int(l[0]);
            }
          };
          var pr_line = function (param) {
            return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_lev(param[0]), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("[")), Pp$ReactTemplate.prlist_with_sep(sep, pr_smart_global, param[1])), Pp$ReactTemplate.str("]")));
          };
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Strategy"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.hv(0, Pp$ReactTemplate.prlist_with_sep(sep, pr_line, v[0]))));
      case 58 : 
          var $$export = v[0] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Export"), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.mt(/* () */0);
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus($$export, Pp$ReactTemplate.str("Unset")), Pp$ReactTemplate.spc(/* () */0)), pr_printoption(v[1], /* None */0)));
      case 59 : 
          var $$export$1 = v[0] ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Export"), Pp$ReactTemplate.spc(/* () */0)) : Pp$ReactTemplate.mt(/* () */0);
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus($$export$1, Pp$ReactTemplate.str("Set")), Pp$ReactTemplate.spc(/* () */0)), pr_set_option(v[1], v[2])));
      case 60 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Add"), Pp$ReactTemplate.spc(/* () */0)), pr_printoption(v[0], /* Some */[v[1]])));
      case 61 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Remove"), Pp$ReactTemplate.spc(/* () */0)), pr_printoption(v[0], /* Some */[v[1]])));
      case 62 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Test"), Pp$ReactTemplate.spc(/* () */0)), pr_printoption(v[0], /* Some */[v[1]])));
      case 63 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Test"), Pp$ReactTemplate.spc(/* () */0)), pr_printoption(v[0], /* None */0)));
      case 64 : 
          var io = v[1];
          var pr_mayeval = function (r, c) {
            if (r) {
              return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Eval"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_red_expr(/* tuple */[
                                                  Ppconstr$ReactTemplate.pr_constr_expr,
                                                  Ppconstr$ReactTemplate.pr_lconstr_expr,
                                                  pr_smart_global,
                                                  Ppconstr$ReactTemplate.pr_constr_expr
                                                ], keyword, r[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("in")), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lconstr_expr(c)));
            } else {
              return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Check"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lconstr_expr(c)));
            }
          };
          var pr_i = io ? Pp$ReactTemplate.$plus$plus(Proof_bullet$ReactTemplate.pr_goal_selector(io[0]), Pp$ReactTemplate.str(": ")) : Pp$ReactTemplate.mt(/* () */0);
          return Pp$ReactTemplate.$plus$plus(pr_i, pr_mayeval(v[0], v[2]));
      case 65 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Type"), pr_constrarg(v[0])));
      case 66 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Declare Reduction"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(v[0])), Pp$ReactTemplate.str(" := ")), Pputils$ReactTemplate.pr_red_expr(/* tuple */[
                          Ppconstr$ReactTemplate.pr_constr_expr,
                          Ppconstr$ReactTemplate.pr_lconstr_expr,
                          pr_smart_global,
                          Ppconstr$ReactTemplate.pr_constr_expr
                        ], keyword, v[1]));
      case 67 : 
          var param = v[0];
          if (typeof param === "number") {
            switch (param) {
              case 0 : 
                  return Pp$ReactTemplate.str("Print Tables");
              case 1 : 
                  return Pp$ReactTemplate.str("Print All");
              case 2 : 
                  return Pp$ReactTemplate.str("Print Modules");
              case 3 : 
                  return Pp$ReactTemplate.str("Print ML Path");
              case 4 : 
                  return Pp$ReactTemplate.str("Print ML Modules");
              case 5 : 
                  return Pp$ReactTemplate.str("Print ML GC");
              case 6 : 
                  return Pp$ReactTemplate.str("Print Graph");
              case 7 : 
                  return Pp$ReactTemplate.str("Print Classes");
              case 8 : 
                  return Pp$ReactTemplate.str("Print TypeClasses");
              case 9 : 
                  return Pp$ReactTemplate.str("Print Coercions");
              case 10 : 
                  return Pp$ReactTemplate.str("Print Canonical Structures");
              case 11 : 
                  return Pp$ReactTemplate.str("Print Hint");
              case 12 : 
                  return Pp$ReactTemplate.str("Print Hint *");
              case 13 : 
                  return Pp$ReactTemplate.str("Print Scopes");
              
            }
          } else {
            switch (param.tag | 0) {
              case 0 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Section"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_reference(param[0]));
              case 1 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Inspect"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.$$int(param[0]));
              case 2 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Grammar"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(param[0]));
              case 3 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print LoadPath"), Pp$ReactTemplate.pr_opt(Names$ReactTemplate.DirPath[/* print */10], param[0]));
              case 4 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Module"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_reference(param[0]));
              case 5 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Module Type"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_reference(param[0]));
              case 6 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Namespace"), Names$ReactTemplate.DirPath[/* print */10](param[0]));
              case 7 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param[0])), pr_univ_name_list(param[1]));
              case 8 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Instances"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param[0]));
              case 9 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Coercion Paths"), Pp$ReactTemplate.spc(/* () */0)), pr_class_rawexpr(param[0])), Pp$ReactTemplate.spc(/* () */0)), pr_class_rawexpr(param[1]));
              case 10 : 
                  var cmd = param[0] ? "Print Sorted Universes" : "Print Universes";
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(cmd), Pp$ReactTemplate.pr_opt(Pp$ReactTemplate.str, param[1]));
              case 11 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Hint"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param[0]));
              case 12 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print HintDb"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(param[0]));
              case 13 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Scope"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(param[0]));
              case 14 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Visibility"), Pp$ReactTemplate.pr_opt(Pp$ReactTemplate.str, param[0]));
              case 15 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_opt((function (g) {
                                                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Proof_bullet$ReactTemplate.pr_goal_selector(g), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0));
                                              }), param[2]), Pp$ReactTemplate.str("About")), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param[0])), pr_univ_name_list(param[1]));
              case 16 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Implicit"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param[0]));
              case 17 : 
                  var t = param[1];
                  var cmd$1 = param[0] !== 0 ? (
                      t !== 0 ? "Print All Dependencies" : "Print Opaque Dependencies"
                    ) : (
                      t !== 0 ? "Print Transparent Dependencies" : "Print Assumptions"
                    );
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(cmd$1), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param[2]));
              case 18 : 
                  var match$15 = param[0];
                  if (match$15) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Strategy"), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, match$15[0]));
                  } else {
                    return Pp$ReactTemplate.str("Print Strategies");
                  }
              
            }
          }
      case 68 : 
          var a = v[0];
          var gopt = v[1];
          var b$3 = v[2];
          var pr_p = Ppconstr$ReactTemplate.pr_constr_pattern_expr;
          var tmp$3;
          switch (a.tag | 0) {
            case 0 : 
                tmp$3 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("SearchPattern"), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pr_p, a[0])), pr_in_out_modules(b$3));
                break;
            case 1 : 
                tmp$3 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("SearchRewrite"), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pr_p, a[0])), pr_in_out_modules(b$3));
                break;
            case 2 : 
                tmp$3 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("SearchHead"), Pp$ReactTemplate.spc(/* () */0)), Curry._1(pr_p, a[0])), pr_in_out_modules(b$3));
                break;
            case 3 : 
                tmp$3 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Search"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_search_about, a[0])), pr_in_out_modules(b$3));
                break;
            
          }
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_opt((function (g) {
                            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Proof_bullet$ReactTemplate.pr_goal_selector(g), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0));
                          }), gopt), tmp$3);
      case 69 : 
          var pr_locate = function (param) {
            switch (param.tag | 0) {
              case 0 : 
                  return Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param[0]);
              case 1 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Term"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_or_by_notation(Libnames$ReactTemplate.pr_reference, param[0]));
              case 2 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Library"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_reference(param[0]));
              case 3 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Module"), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_reference(param[0]));
              case 4 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(param[0]), Pp$ReactTemplate.spc(/* () */0)), Libnames$ReactTemplate.pr_reference(param[1]));
              case 5 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("File"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.qs(param[0]));
              
            }
          };
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Locate"), Pp$ReactTemplate.spc(/* () */0)), pr_locate(v[0]));
      case 70 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Register Inline"), Pp$ReactTemplate.spc(/* () */0)), Ppconstr$ReactTemplate.pr_lident(v[0])));
      case 71 : 
          return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Comments"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, (function (param) {
                                var pr_c = Ppconstr$ReactTemplate.pr_constr_expr;
                                var param$1 = param;
                                switch (param$1.tag | 0) {
                                  case 0 : 
                                      return Curry._1(pr_c, param$1[0]);
                                  case 1 : 
                                      return Pp$ReactTemplate.qs(param$1[0]);
                                  case 2 : 
                                      return Pp$ReactTemplate.$$int(param$1[0]);
                                  
                                }
                              }), v[0])));
      case 72 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Abort"), Pp$ReactTemplate.pr_opt(Ppconstr$ReactTemplate.pr_lident, v[0]));
      case 73 : 
          var i$1 = v[0];
          if (i$1 === 1) {
            return Pp$ReactTemplate.str("Undo");
          } else {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Undo"), pr_intarg(i$1));
          }
      case 74 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Undo"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("To")), pr_intarg(v[0]));
      case 75 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Backtrack"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, Pp$ReactTemplate.$$int, /* :: */[
                          v[0],
                          /* :: */[
                            v[1],
                            /* :: */[
                              v[2],
                              /* [] */0
                            ]
                          ]
                        ]));
      case 76 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Focus"), Pp$ReactTemplate.pr_opt(Pp$ReactTemplate.$$int, v[0]));
      case 77 : 
          var b$4 = v[0];
          switch (b$4.tag | 0) {
            case 0 : 
                return Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* make */0], b$4[0], /* "-" */45));
            case 1 : 
                return Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* make */0], b$4[0], /* "*" */42));
            case 2 : 
                return Pp$ReactTemplate.str(Curry._2(Util$ReactTemplate.$$String[/* make */0], b$4[0], /* "+" */43));
            
          }
          break;
      case 78 : 
          var match$16 = v[0];
          if (match$16) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Proof_bullet$ReactTemplate.pr_goal_selector(match$16[0]), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("{"));
          } else {
            return Pp$ReactTemplate.str("{");
          }
      case 79 : 
          var pr_goal_reference = function (param) {
            if (typeof param === "number") {
              return Pp$ReactTemplate.mt(/* () */0);
            } else if (param.tag) {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Ppconstr$ReactTemplate.pr_id(param[0]));
            } else {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.$$int(param[0]));
            }
          };
          var param$1 = v[0];
          if (typeof param$1 === "number") {
            switch (param$1) {
              case 0 : 
                  return Pp$ReactTemplate.str("Show Proof");
              case 1 : 
                  return Pp$ReactTemplate.str("Show Script");
              case 2 : 
                  return Pp$ReactTemplate.str("Show Existentials");
              case 3 : 
                  return Pp$ReactTemplate.str("Show Universes");
              case 4 : 
                  return Pp$ReactTemplate.str("Show Conjectures");
              
            }
          } else {
            switch (param$1.tag | 0) {
              case 0 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Show"), pr_goal_reference(param$1[0]));
              case 1 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Show "), param$1[0] ? Pp$ReactTemplate.str("Intros") : Pp$ReactTemplate.str("Intro"));
              case 2 : 
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Show Match "), Libnames$ReactTemplate.pr_reference(param$1[0]));
              
            }
          }
      case 80 : 
          var match$17 = v[0];
          if (match$17) {
            var match$18 = v[1];
            var te = match$17[0];
            if (match$18) {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Proof"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("using")), Pp$ReactTemplate.spc(/* () */0)), pr_using(match$18[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("with")), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_raw_generic(Global$ReactTemplate.env(/* () */0), te));
            } else {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Proof with"), Pp$ReactTemplate.spc(/* () */0)), Pputils$ReactTemplate.pr_raw_generic(Global$ReactTemplate.env(/* () */0), te));
            }
          } else {
            var match$19 = v[1];
            if (match$19) {
              return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Proof "), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("using")), Pp$ReactTemplate.spc(/* () */0)), pr_using(match$19[0]));
            } else {
              return Pp$ReactTemplate.str("Proof");
            }
          }
          break;
      case 81 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Proof Mode"), Pp$ReactTemplate.str(v[0]));
      case 82 : 
          return Pp$ReactTemplate.str("(* <Warning> : No printer for toplevel commands *)");
      case 83 : 
          var s = v[0];
          var cl = v[1];
          var pr_arg = function (a) {
            try {
              return Pputils$ReactTemplate.pr_raw_generic(Global$ReactTemplate.env(/* () */0), a);
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Caml_builtin_exceptions.failure) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("<error in "), Pp$ReactTemplate.str(s[0])), Pp$ReactTemplate.str(">"));
              } else {
                throw exn;
              }
            }
          };
          try {
            var rl = Egramml$ReactTemplate.get_extend_vernac_rule(s);
            var aux = function (rl, cl) {
              if (rl) {
                var match = rl[0];
                if (match.tag) {
                  if (cl) {
                    return /* :: */[
                            pr_arg(cl[0]),
                            aux(rl[1], cl[1])
                          ];
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "ppvernac.ml",
                            562,
                            15
                          ]
                        ];
                  }
                } else {
                  return /* :: */[
                          Pp$ReactTemplate.str(match[0]),
                          aux(rl[1], cl)
                        ];
                }
              } else if (cl) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "ppvernac.ml",
                        562,
                        15
                      ]
                    ];
              } else {
                return /* [] */0;
              }
            };
            return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.pr_sequence(Util$ReactTemplate.identity, aux(rl, cl)));
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("TODO("), Pp$ReactTemplate.str(s[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(sep, pr_arg, cl)), Pp$ReactTemplate.str(")")));
            } else {
              throw exn;
            }
          }
      
    }
  }
}

function pr_vernac_flag(param) {
  if (typeof param === "number") {
    return Pp$ReactTemplate.str("Program");
  } else if (param.tag) {
    var local = param[0];
    if (local) {
      return Pp$ReactTemplate.str("Local");
    } else {
      return Pp$ReactTemplate.str("Global");
    }
  } else if (param[0] !== 0) {
    return Pp$ReactTemplate.str("Polymorphic");
  } else {
    return Pp$ReactTemplate.str("Monomorphic");
  }
}

function pr_vernac_control(v) {
  switch (v.tag | 0) {
    case 0 : 
        var v$prime = v[1];
        return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (f, a) {
                      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pr_vernac_flag(f), Pp$ReactTemplate.spc(/* () */0)), a);
                    }), v[0], Pp$ReactTemplate.$plus$plus(pr_vernac_expr(v$prime), sep_end(v$prime)));
    case 1 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Time"), Pp$ReactTemplate.spc(/* () */0)), pr_vernac_control(v[1][/* v */0]));
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Redirect"), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.qs(v[0])), Pp$ReactTemplate.spc(/* () */0)), pr_vernac_control(v[1][/* v */0]));
    case 3 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Timeout "), Pp$ReactTemplate.$$int(v[0])), Pp$ReactTemplate.spc(/* () */0)), pr_vernac_control(v[1]));
    case 4 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Fail"), Pp$ReactTemplate.spc(/* () */0)), pr_vernac_control(v[0]));
    
  }
}

function pr_vernac(v) {
  try {
    return pr_vernac_control(v);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    return CErrors$ReactTemplate.print(/* None */0, e);
  }
}

exports.pr_set_entry_type = pr_set_entry_type;
exports.pr_rec_definition = pr_rec_definition;
exports.pr_vernac_expr = pr_vernac_expr;
exports.pr_using = pr_using;
exports.pr_vernac = pr_vernac;
/* Pp-ReactTemplate Not a pure module */
