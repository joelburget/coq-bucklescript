// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var DAst$ReactTemplate = require("../src/dAst.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Coqlib$ReactTemplate = require("../library/coqlib.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Tacmach$ReactTemplate = require("../proofs/tacmach.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("../src/globnames.bs.js");
var Patternops$ReactTemplate = require("../src/patternops.bs.js");
var Inductiveops$ReactTemplate = require("../src/inductiveops.bs.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");
var Constr_matching$ReactTemplate = require("../src/constr_matching.bs.js");

var meta1 = Nameops$ReactTemplate.make_ident("X", /* Some */[1]);

var meta2 = Nameops$ReactTemplate.make_ident("X", /* Some */[2]);

function op2bool(param) {
  if (param) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function match_with_non_recursive_type(sigma, t) {
  var match = EConstr$ReactTemplate.kind(sigma, t);
  if (match.tag === 9) {
    var match$1 = EConstr$ReactTemplate.decompose_app(sigma, t);
    var hdapp = match$1[0];
    var match$2 = EConstr$ReactTemplate.kind(sigma, hdapp);
    if (match$2.tag === 11 && Global$ReactTemplate.lookup_mind(match$2[0][0][0])[/* mind_finite */2] === /* CoFinite */1) {
      return /* Some */[/* tuple */[
                hdapp,
                match$1[1]
              ]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function is_non_recursive_type(sigma, t) {
  return op2bool(match_with_non_recursive_type(sigma, t));
}

function has_nodep_prod_after(_n, sigma, _c) {
  while(true) {
    var c = _c;
    var n = _n;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    var exit = 0;
    var b;
    switch (match.tag | 0) {
      case 6 : 
          b = match[2];
          exit = 1;
          break;
      case 8 : 
          b = match[3];
          exit = 1;
          break;
      default:
        return /* true */1;
    }
    if (exit === 1) {
      if (n > 0 || EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, b)) {
        _c = b;
        _n = n - 1 | 0;
        continue ;
        
      } else {
        return /* false */0;
      }
    }
    
  };
}

function has_nodep_prod(sigma, c) {
  return has_nodep_prod_after(0, sigma, c);
}

function is_strict_conjunction(param) {
  if (param && param[0] !== 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_lax_conjunction(param) {
  if (param && param[0] === 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function whd_beta_prod(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 6 : 
        return EConstr$ReactTemplate.mkProd(/* tuple */[
                    match[0],
                    Reductionops$ReactTemplate.whd_beta(sigma, match[1]),
                    whd_beta_prod(sigma, match[2])
                  ]);
    case 8 : 
        return EConstr$ReactTemplate.mkLetIn(/* tuple */[
                    match[0],
                    match[1],
                    match[2],
                    whd_beta_prod(sigma, match[3])
                  ]);
    default:
      return c;
  }
}

function match_with_one_constructor(sigma, style, onlybinary, allow_rec, t) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  var args = match[1];
  var hdapp = match[0];
  var match$1 = EConstr$ReactTemplate.kind(sigma, hdapp);
  var res;
  if (match$1.tag === 11) {
    var ind = match$1[0];
    var match$2 = Global$ReactTemplate.lookup_inductive(ind[0]);
    var mip = match$2[1];
    var mib = match$2[0];
    if (mip[/* mind_consnames */3].length === 1 && (allow_rec || !Inductiveops$ReactTemplate.mis_is_recursive(/* tuple */[
              ind[0],
              mib,
              mip
            ])) && mip[/* mind_nrealargs */5] === 0) {
      if (is_strict_conjunction(style)) {
        var t$1 = EConstr$ReactTemplate.decompose_prod_n_assum(sigma, mib[/* mind_nparams */5], EConstr$ReactTemplate.of_constr(Caml_array.caml_array_get(mip[/* mind_nf_lc */8], 0)))[1];
        var ctx = EConstr$ReactTemplate.decompose_prod_assum(sigma, t$1)[0];
        res = Curry._2(Util$ReactTemplate.List[/* for_all */20], (function (decl) {
                var c = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl);
                if (Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], decl) && EConstr$ReactTemplate.isRel(sigma, c)) {
                  return +(EConstr$ReactTemplate.destRel(sigma, c) === mib[/* mind_nparams */5]);
                } else {
                  return /* false */0;
                }
              }), ctx) ? /* Some */[/* tuple */[
              hdapp,
              args
            ]] : /* None */0;
      } else {
        var ctyp = whd_beta_prod(sigma, Termops$ReactTemplate.prod_applist_assum(sigma, Curry._1(Context$ReactTemplate.Rel[/* length */3], mib[/* mind_params_ctxt */7]), EConstr$ReactTemplate.of_constr(Caml_array.caml_array_get(mip[/* mind_nf_lc */8], 0)), args));
        var cargs = Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], EConstr$ReactTemplate.decompose_prod_assum(sigma, ctyp)[0]);
        res = !is_lax_conjunction(style) || has_nodep_prod_after(0, sigma, ctyp) ? /* Some */[/* tuple */[
              hdapp,
              Curry._1(Util$ReactTemplate.List[/* rev */4], cargs)
            ]] : /* None */0;
      }
    } else {
      res = /* None */0;
    }
  } else {
    res = /* None */0;
  }
  if (res) {
    var args$1 = res[0][1];
    if (onlybinary) {
      if (args$1) {
        var match$3 = args$1[1];
        if (match$3 && !match$3[1]) {
          return res;
        } else {
          return /* None */0;
        }
      } else {
        return /* None */0;
      }
    } else {
      return res;
    }
  } else {
    return /* None */0;
  }
}

function match_with_conjunction($staropt$star, $staropt$star$1, sigma, t) {
  var strict = $staropt$star ? $staropt$star[0] : /* false */0;
  var onlybinary = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  return match_with_one_constructor(sigma, /* Some */[strict], onlybinary, /* false */0, t);
}

function match_with_record(sigma, t) {
  return match_with_one_constructor(sigma, /* None */0, /* false */0, /* false */0, t);
}

function is_conjunction($staropt$star, $staropt$star$1, sigma, t) {
  var strict = $staropt$star ? $staropt$star[0] : /* false */0;
  var onlybinary = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  return op2bool(match_with_conjunction(/* Some */[strict], /* Some */[onlybinary], sigma, t));
}

function is_record(sigma, t) {
  return op2bool(match_with_record(sigma, t));
}

function match_with_tuple(sigma, t) {
  var t$1 = match_with_one_constructor(sigma, /* None */0, /* false */0, /* true */1, t);
  return Option$ReactTemplate.map((function (param) {
                var hd = param[0];
                var ind = EConstr$ReactTemplate.destInd(sigma, hd);
                var ind$1 = Util$ReactTemplate.on_snd((function (u) {
                        return EConstr$ReactTemplate.EInstance[/* kind */1](sigma, u);
                      }), ind);
                var match = Global$ReactTemplate.lookup_pinductive(ind$1);
                var isrec = Inductiveops$ReactTemplate.mis_is_recursive(/* tuple */[
                      ind$1[0],
                      match[0],
                      match[1]
                    ]);
                return /* tuple */[
                        hd,
                        param[1],
                        isrec
                      ];
              }), t$1);
}

function is_tuple(sigma, t) {
  return op2bool(match_with_tuple(sigma, t));
}

function test_strict_disjunction(n, lc) {
  return Util$ReactTemplate.$$Array[/* for_all_i */30]((function (i, c) {
                var match = Term$ReactTemplate.prod_assum(Term$ReactTemplate.decompose_prod_n_assum(n)(c)[1]);
                if (match) {
                  var match$1 = match[0];
                  if (match$1.tag) {
                    return /* false */0;
                  } else if (match[1]) {
                    return /* false */0;
                  } else {
                    var c$1 = match$1[1];
                    if (Constr$ReactTemplate.isRel(c$1)) {
                      return +(Constr$ReactTemplate.destRel(c$1) === (n - i | 0));
                    } else {
                      return /* false */0;
                    }
                  }
                } else {
                  return /* false */0;
                }
              }), 0, lc);
}

function match_with_disjunction($staropt$star, $staropt$star$1, sigma, t) {
  var strict = $staropt$star ? $staropt$star[0] : /* false */0;
  var onlybinary = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  var args = match[1];
  var hdapp = match[0];
  var match$1 = EConstr$ReactTemplate.kind(sigma, hdapp);
  var res;
  if (match$1.tag === 11) {
    var ind = match$1[0][0];
    var car = Inductiveops$ReactTemplate.constructors_nrealargs(ind);
    var match$2 = Global$ReactTemplate.lookup_inductive(ind);
    var mip = match$2[1];
    var mib = match$2[0];
    if (Util$ReactTemplate.$$Array[/* for_all */26]((function (ar) {
              return +(ar === 1);
            }), car) && !Inductiveops$ReactTemplate.mis_is_recursive(/* tuple */[
            ind,
            mib,
            mip
          ]) && mip[/* mind_nrealargs */5] === 0) {
      if (strict) {
        res = test_strict_disjunction(mib[/* mind_nparams */5], mip[/* mind_nf_lc */8]) ? /* Some */[/* tuple */[
              hdapp,
              args
            ]] : /* None */0;
      } else {
        var cargs = Util$ReactTemplate.$$Array[/* map */12]((function (ar) {
                return Util$ReactTemplate.pi2(EConstr$ReactTemplate.destProd(sigma, Termops$ReactTemplate.prod_applist(sigma, EConstr$ReactTemplate.of_constr(ar), args)));
              }), mip[/* mind_nf_lc */8]);
        res = /* Some */[/* tuple */[
            hdapp,
            Util$ReactTemplate.$$Array[/* to_list */9](cargs)
          ]];
      }
    } else {
      res = /* None */0;
    }
  } else {
    res = /* None */0;
  }
  if (res) {
    var args$1 = res[0][1];
    if (onlybinary) {
      if (args$1) {
        var match$3 = args$1[1];
        if (match$3 && !match$3[1]) {
          return res;
        } else {
          return /* None */0;
        }
      } else {
        return /* None */0;
      }
    } else {
      return res;
    }
  } else {
    return /* None */0;
  }
}

function is_disjunction($staropt$star, $staropt$star$1, sigma, t) {
  var strict = $staropt$star ? $staropt$star[0] : /* false */0;
  var onlybinary = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  return op2bool(match_with_disjunction(/* Some */[strict], /* Some */[onlybinary], sigma, t));
}

function match_with_empty_type(sigma, t) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  var hdapp = match[0];
  var match$1 = EConstr$ReactTemplate.kind(sigma, hdapp);
  if (match$1.tag === 11) {
    var match$2 = Global$ReactTemplate.lookup_inductive(match$1[0][0]);
    var nconstr = match$2[1][/* mind_consnames */3].length;
    if (nconstr) {
      return /* None */0;
    } else {
      return /* Some */[hdapp];
    }
  } else {
    return /* None */0;
  }
}

function is_empty_type(sigma, t) {
  return op2bool(match_with_empty_type(sigma, t));
}

function match_with_unit_or_eq_type(sigma, t) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  var hdapp = match[0];
  var match$1 = EConstr$ReactTemplate.kind(sigma, hdapp);
  if (match$1.tag === 11) {
    var match$2 = Global$ReactTemplate.lookup_inductive(match$1[0][0]);
    var mip = match$2[1];
    var mib = match$2[0];
    var constr_types = mip[/* mind_nf_lc */8];
    var nconstr = mip[/* mind_consnames */3].length;
    var zero_args = function (c) {
      return +(Termops$ReactTemplate.nb_prod(sigma, EConstr$ReactTemplate.of_constr(c)) === mib[/* mind_nparams */5]);
    };
    if (nconstr === 1 && zero_args(Caml_array.caml_array_get(constr_types, 0))) {
      return /* Some */[hdapp];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function is_unit_or_eq_type(sigma, t) {
  return op2bool(match_with_unit_or_eq_type(sigma, t));
}

function is_unit_type(sigma, t) {
  var match = match_with_conjunction(/* None */0, /* None */0, sigma, t);
  if (match && !match[0][1]) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

var NoEquationFound = Caml_exceptions.create("Hipattern-ReactTemplate.NoEquationFound");

function mkGApp(f, args) {
  var eta = /* GApp */Block.__(4, [
      f,
      args
    ]);
  return DAst$ReactTemplate.make(/* None */0, eta);
}

var mkGHole = DAst$ReactTemplate.make(/* None */0, /* GHole */Block.__(13, [
        /* QuestionMark */Block.__(3, [
            /* Define */[/* false */0],
            /* Anonymous */0
          ]),
        /* IntroAnonymous */0,
        /* None */0
      ]));

function mkGProd(id, c1, c2) {
  var eta_000 = /* Name */[Names$ReactTemplate.Id[/* of_string */5](id)];
  var eta = /* GProd */Block.__(6, [
      eta_000,
      /* Explicit */0,
      c1,
      c2
    ]);
  return DAst$ReactTemplate.make(/* None */0, eta);
}

function mkGArrow(c1, c2) {
  var eta = /* GProd */Block.__(6, [
      /* Anonymous */0,
      /* Explicit */0,
      c1,
      c2
    ]);
  return DAst$ReactTemplate.make(/* None */0, eta);
}

function mkGVar(id) {
  var eta = /* GVar */Block.__(1, [Names$ReactTemplate.Id[/* of_string */5](id)]);
  return DAst$ReactTemplate.make(/* None */0, eta);
}

function mkGPatVar(id) {
  var eta = /* GPatVar */Block.__(3, [/* FirstOrderPatVar */Block.__(0, [Names$ReactTemplate.Id[/* of_string */5](id)])]);
  return DAst$ReactTemplate.make(/* None */0, eta);
}

function mkGRef(r) {
  var tag = r.tag | 0;
  var eta_000 = tag === 250 ? r[0] : (
      tag === 246 ? CamlinternalLazy.force_lazy_block(r) : r
    );
  var eta = /* GRef */Block.__(0, [
      eta_000,
      /* None */0
    ]);
  return DAst$ReactTemplate.make(/* None */0, eta);
}

var c = mkGProd("x", mkGHole, mkGApp(mkGHole, /* :: */[
          mkGVar("x"),
          /* :: */[
            mkGVar("x"),
            /* [] */0
          ]
        ]));

var coq_refl_leibniz1_pattern = Patternops$ReactTemplate.pattern_of_glob_constr(c)[1];

var c$1 = mkGProd("A", mkGHole, mkGProd("x", mkGVar("A"), mkGApp(mkGHole, /* :: */[
              mkGVar("A"),
              /* :: */[
                mkGVar("x"),
                /* :: */[
                  mkGVar("x"),
                  /* [] */0
                ]
              ]
            ])));

var coq_refl_leibniz2_pattern = Patternops$ReactTemplate.pattern_of_glob_constr(c$1)[1];

var c$2 = mkGProd("A", mkGHole, mkGProd("x", mkGVar("A"), mkGApp(mkGHole, /* :: */[
              mkGVar("A"),
              /* :: */[
                mkGVar("x"),
                /* :: */[
                  mkGVar("A"),
                  /* :: */[
                    mkGVar("x"),
                    /* [] */0
                  ]
                ]
              ]
            ])));

var coq_refl_jm_pattern = Patternops$ReactTemplate.pattern_of_glob_constr(c$2)[1];

function match_with_equation(env, sigma, t) {
  if (!EConstr$ReactTemplate.isApp(sigma, t)) {
    throw NoEquationFound;
  }
  var match = EConstr$ReactTemplate.destApp(sigma, t);
  var args = match[1];
  var hdapp = match[0];
  var match$1 = EConstr$ReactTemplate.kind(sigma, hdapp);
  if (match$1.tag === 11) {
    var ind = match$1[0][0];
    if (Globnames$ReactTemplate.eq_gr(/* IndRef */Block.__(2, [ind]), Coqlib$ReactTemplate.glob_eq)) {
      return /* tuple */[
              /* Some */[Coqlib$ReactTemplate.build_coq_eq_data(/* () */0)],
              hdapp,
              /* PolymorphicLeibnizEq */Block.__(1, [
                  Caml_array.caml_array_get(args, 0),
                  Caml_array.caml_array_get(args, 1),
                  Caml_array.caml_array_get(args, 2)
                ])
            ];
    } else if (Globnames$ReactTemplate.eq_gr(/* IndRef */Block.__(2, [ind]), Coqlib$ReactTemplate.glob_identity)) {
      return /* tuple */[
              /* Some */[Coqlib$ReactTemplate.build_coq_identity_data(/* () */0)],
              hdapp,
              /* PolymorphicLeibnizEq */Block.__(1, [
                  Caml_array.caml_array_get(args, 0),
                  Caml_array.caml_array_get(args, 1),
                  Caml_array.caml_array_get(args, 2)
                ])
            ];
    } else if (Globnames$ReactTemplate.eq_gr(/* IndRef */Block.__(2, [ind]), Coqlib$ReactTemplate.glob_jmeq)) {
      return /* tuple */[
              /* Some */[Coqlib$ReactTemplate.build_coq_jmeq_data(/* () */0)],
              hdapp,
              /* HeterogenousEq */Block.__(2, [
                  Caml_array.caml_array_get(args, 0),
                  Caml_array.caml_array_get(args, 1),
                  Caml_array.caml_array_get(args, 2),
                  Caml_array.caml_array_get(args, 3)
                ])
            ];
    } else {
      var match$2 = Global$ReactTemplate.lookup_inductive(ind);
      var mip = match$2[1];
      var constr_types = mip[/* mind_nf_lc */8];
      var nconstr = mip[/* mind_consnames */3].length;
      if (nconstr === 1) {
        if (Constr_matching$ReactTemplate.is_matching(env, sigma, coq_refl_leibniz1_pattern, EConstr$ReactTemplate.of_constr(Caml_array.caml_array_get(constr_types, 0)))) {
          return /* tuple */[
                  /* None */0,
                  hdapp,
                  /* MonomorphicLeibnizEq */Block.__(0, [
                      Caml_array.caml_array_get(args, 0),
                      Caml_array.caml_array_get(args, 1)
                    ])
                ];
        } else if (Constr_matching$ReactTemplate.is_matching(env, sigma, coq_refl_leibniz2_pattern, EConstr$ReactTemplate.of_constr(Caml_array.caml_array_get(constr_types, 0)))) {
          return /* tuple */[
                  /* None */0,
                  hdapp,
                  /* PolymorphicLeibnizEq */Block.__(1, [
                      Caml_array.caml_array_get(args, 0),
                      Caml_array.caml_array_get(args, 1),
                      Caml_array.caml_array_get(args, 2)
                    ])
                ];
        } else if (Constr_matching$ReactTemplate.is_matching(env, sigma, coq_refl_jm_pattern, EConstr$ReactTemplate.of_constr(Caml_array.caml_array_get(constr_types, 0)))) {
          return /* tuple */[
                  /* None */0,
                  hdapp,
                  /* HeterogenousEq */Block.__(2, [
                      Caml_array.caml_array_get(args, 0),
                      Caml_array.caml_array_get(args, 1),
                      Caml_array.caml_array_get(args, 2),
                      Caml_array.caml_array_get(args, 3)
                    ])
                ];
        } else {
          throw NoEquationFound;
        }
      } else {
        throw NoEquationFound;
      }
    }
  } else {
    throw NoEquationFound;
  }
}

function is_inductive_equality(ind) {
  var match = Global$ReactTemplate.lookup_inductive(ind);
  var nconstr = match[1][/* mind_consnames */3].length;
  if (nconstr === 1) {
    return +(Inductiveops$ReactTemplate.constructor_nrealargs(/* tuple */[
                  ind,
                  1
                ]) === 0);
  } else {
    return /* false */0;
  }
}

function match_with_equality_type(sigma, t) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  var hdapp = match[0];
  var match$1 = EConstr$ReactTemplate.kind(sigma, hdapp);
  if (match$1.tag === 11 && is_inductive_equality(match$1[0][0])) {
    return /* Some */[/* tuple */[
              hdapp,
              match[1]
            ]];
  } else {
    return /* None */0;
  }
}

function is_equality_type(sigma, t) {
  return op2bool(match_with_equality_type(sigma, t));
}

var c$3 = mkGArrow(mkGPatVar("X1"), mkGPatVar("X2"));

var coq_arrow_pattern = Patternops$ReactTemplate.pattern_of_glob_constr(c$3)[1];

function match_arrow_pattern(env, sigma, t) {
  var result = Constr_matching$ReactTemplate.matches(env, sigma, coq_arrow_pattern, t);
  var match = Curry._1(Names$ReactTemplate.Id[/* Map */10][/* bindings */16], result);
  var exit = 0;
  if (match) {
    var match$1 = match[1];
    if (match$1) {
      if (match$1[1]) {
        exit = 1;
      } else {
        var match$2 = match$1[0];
        var match$3 = match[0];
        if (!(Names$ReactTemplate.Id[/* equal */0](match$3[0], meta1) && Names$ReactTemplate.Id[/* equal */0](match$2[0], meta2))) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "hipattern.ml",
                  348,
                  6
                ]
              ];
        }
        return /* tuple */[
                match$3[1],
                match$2[1]
              ];
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Incorrect pattern matching."));
  }
  
}

function match_with_imp_term(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 6) {
    var b = match[2];
    if (EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, b)) {
      return /* Some */[/* tuple */[
                match[1],
                b
              ]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function is_imp_term(sigma, c) {
  return op2bool(match_with_imp_term(sigma, c));
}

function match_with_nottype(env, sigma, t) {
  try {
    var match = match_arrow_pattern(env, sigma, t);
    var mind = match[1];
    if (is_empty_type(sigma, mind)) {
      return /* Some */[/* tuple */[
                mind,
                match[0]
              ]];
    } else {
      return /* None */0;
    }
  }
  catch (exn){
    if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function is_nottype(env, sigma, t) {
  return op2bool(match_with_nottype(env, sigma, t));
}

function match_with_forall_term(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 6) {
    return /* Some */[/* tuple */[
              match[0],
              match[1],
              match[2]
            ]];
  } else {
    return /* None */0;
  }
}

function is_forall_term(sigma, c) {
  return op2bool(match_with_forall_term(sigma, c));
}

function match_with_nodep_ind(sigma, t) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  var args = match[1];
  var hdapp = match[0];
  var match$1 = EConstr$ReactTemplate.kind(sigma, hdapp);
  if (match$1.tag === 11) {
    var match$2 = Global$ReactTemplate.lookup_inductive(match$1[0][0]);
    var mib = match$2[0];
    if (mib[/* mind_packets */0].length > 1) {
      return /* None */0;
    } else {
      var mip = match$2[1];
      var nodep_constr = function (c) {
        return has_nodep_prod_after(Curry._1(Context$ReactTemplate.Rel[/* length */3], mib[/* mind_params_ctxt */7]), sigma, EConstr$ReactTemplate.of_constr(c));
      };
      if (Util$ReactTemplate.$$Array[/* for_all */26](nodep_constr, mip[/* mind_nf_lc */8])) {
        var params = mip[/* mind_nrealargs */5] ? Curry._2(Util$ReactTemplate.List[/* chop */99], mib[/* mind_nparams */5], args)[0] : args;
        return /* Some */[/* tuple */[
                  hdapp,
                  params,
                  mip[/* mind_nrealargs */5]
                ]];
      } else {
        return /* None */0;
      }
    }
  } else {
    return /* None */0;
  }
}

function is_nodep_ind(sigma, t) {
  return op2bool(match_with_nodep_ind(sigma, t));
}

function match_with_sigma_type(sigma, t) {
  var match = EConstr$ReactTemplate.decompose_app(sigma, t);
  var hdapp = match[0];
  var match$1 = EConstr$ReactTemplate.kind(sigma, hdapp);
  if (match$1.tag === 11) {
    var match$2 = Global$ReactTemplate.lookup_inductive(match$1[0][0]);
    var mip = match$2[1];
    var mib = match$2[0];
    if (mib[/* mind_packets */0].length === 1 && mip[/* mind_nrealargs */5] === 0 && mip[/* mind_consnames */3].length === 1 && has_nodep_prod_after(Curry._1(Context$ReactTemplate.Rel[/* length */3], mib[/* mind_params_ctxt */7]) + 1 | 0, sigma, EConstr$ReactTemplate.of_constr(Caml_array.caml_array_get(mip[/* mind_nf_lc */8], 0)))) {
      return /* Some */[/* tuple */[
                hdapp,
                match[1]
              ]];
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function is_sigma_type(sigma, t) {
  return op2bool(match_with_sigma_type(sigma, t));
}

function first_match(matcher, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      var match = param[0];
      if (Curry._1(match[1], /* () */0)) {
        try {
          return /* tuple */[
                  Curry._1(match[2], /* () */0),
                  Curry._1(matcher, match[0])
                ];
        }
        catch (exn){
          if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
            _param = l;
            continue ;
            
          } else {
            throw exn;
          }
        }
      } else {
        _param = l;
        continue ;
        
      }
    } else {
      throw Constr_matching$ReactTemplate.PatternMatchingFailure;
    }
  };
}

function no_check() {
  return /* true */1;
}

function check_jmeq_loaded() {
  return Pervasives.failwith("undefined: check_jmeq_loaded");
}

var equalities_000 = /* tuple */[
  /* tuple */[
    Coqlib$ReactTemplate.coq_eq_ref,
    /* false */0
  ],
  no_check,
  Coqlib$ReactTemplate.build_coq_eq_data
];

var equalities_001 = /* :: */[
  /* tuple */[
    /* tuple */[
      Coqlib$ReactTemplate.coq_jmeq_ref,
      /* true */1
    ],
    check_jmeq_loaded,
    Coqlib$ReactTemplate.build_coq_jmeq_data
  ],
  /* :: */[
    /* tuple */[
      /* tuple */[
        Coqlib$ReactTemplate.coq_identity_ref,
        /* false */0
      ],
      no_check,
      Coqlib$ReactTemplate.build_coq_identity_data
    ],
    /* [] */0
  ]
];

var equalities = /* :: */[
  equalities_000,
  equalities_001
];

function find_eq_data(sigma, eqn) {
  var match = first_match((function (param) {
          var sigma$1 = sigma;
          var eqn$1 = eqn;
          var param$1 = param;
          var hetero = param$1[1];
          var ref = param$1[0];
          var ref$1;
          try {
            var tag = ref.tag | 0;
            ref$1 = tag === 250 ? ref[0] : (
                tag === 246 ? CamlinternalLazy.force_lazy_block(ref) : ref
              );
          }
          catch (raw_e){
            var e = Js_exn.internalToOCamlException(raw_e);
            if (CErrors$ReactTemplate.noncritical(e)) {
              throw Constr_matching$ReactTemplate.PatternMatchingFailure;
            } else {
              throw e;
            }
          }
          var match = EConstr$ReactTemplate.kind(sigma$1, eqn$1);
          if (match.tag === 9) {
            var match$1 = match[1];
            var len = match$1.length;
            var c = match[0];
            if (len !== 3) {
              if (len !== 4) {
                throw Constr_matching$ReactTemplate.PatternMatchingFailure;
              } else {
                var t = match$1[0];
                var x = match$1[1];
                var t$prime = match$1[2];
                var x$prime = match$1[3];
                if (hetero && Termops$ReactTemplate.is_global(sigma$1, ref$1, c)) {
                  return /* HeterogenousEq */Block.__(2, [
                            t,
                            x,
                            t$prime,
                            x$prime
                          ]);
                } else {
                  throw Constr_matching$ReactTemplate.PatternMatchingFailure;
                }
              }
            } else {
              var t$1 = match$1[0];
              var x$1 = match$1[1];
              var y = match$1[2];
              if (!hetero && Termops$ReactTemplate.is_global(sigma$1, ref$1, c)) {
                return /* PolymorphicLeibnizEq */Block.__(1, [
                          t$1,
                          x$1,
                          y
                        ]);
              } else {
                throw Constr_matching$ReactTemplate.PatternMatchingFailure;
              }
            }
          } else {
            throw Constr_matching$ReactTemplate.PatternMatchingFailure;
          }
        }), equalities);
  var match$1 = EConstr$ReactTemplate.destInd(sigma, EConstr$ReactTemplate.destApp(sigma, eqn)[0]);
  return /* tuple */[
          match[0],
          match$1[1],
          match[1]
        ];
}

function extract_eq_args(gl, param) {
  switch (param.tag | 0) {
    case 0 : 
        var e1 = param[0];
        var t = Tacmach$ReactTemplate.New[/* pf_unsafe_type_of */6](gl, e1);
        return /* tuple */[
                t,
                e1,
                param[1]
              ];
    case 1 : 
        return /* tuple */[
                param[0],
                param[1],
                param[2]
              ];
    case 2 : 
        var t1 = param[0];
        if (Tacmach$ReactTemplate.New[/* pf_conv_x */9](gl, t1, param[2])) {
          return /* tuple */[
                  t1,
                  param[1],
                  param[3]
                ];
        } else {
          throw Constr_matching$ReactTemplate.PatternMatchingFailure;
        }
        break;
    
  }
}

function find_eq_data_decompose(gl, eqn) {
  var match = find_eq_data(Tacmach$ReactTemplate.New[/* project */3](gl), eqn);
  return /* tuple */[
          match[0],
          match[1],
          extract_eq_args(gl, match[2])
        ];
}

function find_this_eq_data_decompose(gl, eqn) {
  var match;
  try {
    match = find_eq_data(Tacmach$ReactTemplate.New[/* project */3](gl), eqn);
  }
  catch (exn){
    if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
      match = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("No primitive equality found."));
    } else {
      throw exn;
    }
  }
  var eq_args;
  try {
    eq_args = extract_eq_args(gl, match[2]);
  }
  catch (exn$1){
    if (exn$1 === Constr_matching$ReactTemplate.PatternMatchingFailure) {
      eq_args = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Don't know what to do with JMeq on arguments not of same type."));
    } else {
      throw exn$1;
    }
  }
  return /* tuple */[
          match[0],
          match[1],
          eq_args
        ];
}

function find_sigma_data_decompose(env, ex) {
  return (function (param) {
      var sigma = ex;
      var ex$1 = param;
      var match = EConstr$ReactTemplate.kind(sigma, ex$1);
      if (match.tag === 9) {
        var match$1 = match[1];
        if (match$1.length !== 4) {
          throw Constr_matching$ReactTemplate.PatternMatchingFailure;
        } else {
          var f = match[0];
          var a = match$1[0];
          var p = match$1[1];
          var car = match$1[2];
          var cdr = match$1[3];
          var tag = Coqlib$ReactTemplate.coq_exist_ref.tag | 0;
          if (Termops$ReactTemplate.is_global(sigma, tag === 250 ? Coqlib$ReactTemplate.coq_exist_ref[0] : (
                    tag === 246 ? CamlinternalLazy.force_lazy_block(Coqlib$ReactTemplate.coq_exist_ref) : Coqlib$ReactTemplate.coq_exist_ref
                  ), f)) {
            return /* tuple */[
                    Coqlib$ReactTemplate.build_sigma(/* () */0),
                    /* tuple */[
                      EConstr$ReactTemplate.destConstruct(sigma, f)[1],
                      a,
                      p,
                      car,
                      cdr
                    ]
                  ];
          } else {
            var tag$1 = Coqlib$ReactTemplate.coq_existT_ref.tag | 0;
            if (Termops$ReactTemplate.is_global(sigma, tag$1 === 250 ? Coqlib$ReactTemplate.coq_existT_ref[0] : (
                      tag$1 === 246 ? CamlinternalLazy.force_lazy_block(Coqlib$ReactTemplate.coq_existT_ref) : Coqlib$ReactTemplate.coq_existT_ref
                    ), f)) {
              return /* tuple */[
                      Coqlib$ReactTemplate.build_sigma_type(/* () */0),
                      /* tuple */[
                        EConstr$ReactTemplate.destConstruct(sigma, f)[1],
                        a,
                        p,
                        car,
                        cdr
                      ]
                    ];
            } else {
              throw Constr_matching$ReactTemplate.PatternMatchingFailure;
            }
          }
        }
      } else {
        throw Constr_matching$ReactTemplate.PatternMatchingFailure;
      }
    });
}

var coq_sig_pattern = Block.__(246, [(function () {
        var args_000 = mkGPatVar("X1");
        var args_001 = /* :: */[
          mkGPatVar("X2"),
          /* [] */0
        ];
        var args = /* :: */[
          args_000,
          args_001
        ];
        var c = mkGApp(mkGRef(Coqlib$ReactTemplate.coq_sig_ref), args);
        return Patternops$ReactTemplate.pattern_of_glob_constr(c)[1];
      })]);

function match_sigma(env, sigma, t) {
  var tag = coq_sig_pattern.tag | 0;
  var match = Curry._1(Names$ReactTemplate.Id[/* Map */10][/* bindings */16], Constr_matching$ReactTemplate.matches(env, sigma, tag === 250 ? coq_sig_pattern[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(coq_sig_pattern) : coq_sig_pattern
            ), t));
  var exit = 0;
  if (match) {
    var match$1 = match[1];
    if (match$1) {
      if (match$1[1]) {
        exit = 1;
      } else {
        return /* tuple */[
                match[0][1],
                match$1[0][1]
              ];
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unexpected pattern."));
  }
  
}

function is_matching_sigma(env, sigma, t) {
  var tag = coq_sig_pattern.tag | 0;
  return Constr_matching$ReactTemplate.is_matching(env, sigma, tag === 250 ? coq_sig_pattern[0] : (
                tag === 246 ? CamlinternalLazy.force_lazy_block(coq_sig_pattern) : coq_sig_pattern
              ), t);
}

function coq_eqdec(sum, rev) {
  return Block.__(246, [(function () {
                var args = Curry._2(Util$ReactTemplate.List[/* map */10], mkGPatVar, /* :: */[
                      "X1",
                      /* :: */[
                        "X2",
                        /* :: */[
                          "X3",
                          /* [] */0
                        ]
                      ]
                    ]);
                var eqn = mkGApp(mkGRef(Coqlib$ReactTemplate.coq_eq_ref), args);
                var args_001 = /* :: */[
                  mkGApp(mkGRef(Coqlib$ReactTemplate.coq_not_ref), /* :: */[
                        eqn,
                        /* [] */0
                      ]),
                  /* [] */0
                ];
                var args$1 = /* :: */[
                  eqn,
                  args_001
                ];
                var args$2 = rev ? Curry._1(Util$ReactTemplate.List[/* rev */4], args$1) : args$1;
                var c = mkGApp(mkGRef(sum), args$2);
                return Patternops$ReactTemplate.pattern_of_glob_constr(c)[1];
              })]);
}

var coq_eqdec_inf_pattern = coq_eqdec(Coqlib$ReactTemplate.coq_sumbool_ref, /* false */0);

var coq_eqdec_inf_rev_pattern = coq_eqdec(Coqlib$ReactTemplate.coq_sumbool_ref, /* true */1);

var coq_eqdec_pattern = coq_eqdec(Coqlib$ReactTemplate.coq_or_ref, /* false */0);

var coq_eqdec_rev_pattern = coq_eqdec(Coqlib$ReactTemplate.coq_or_ref, /* true */1);

function match_eqdec(env, sigma, t) {
  var match;
  try {
    var tag = coq_eqdec_inf_pattern.tag | 0;
    match = /* tuple */[
      /* true */1,
      Coqlib$ReactTemplate.coq_sumbool_ref,
      Constr_matching$ReactTemplate.matches(env, sigma, tag === 250 ? coq_eqdec_inf_pattern[0] : (
              tag === 246 ? CamlinternalLazy.force_lazy_block(coq_eqdec_inf_pattern) : coq_eqdec_inf_pattern
            ), t)
    ];
  }
  catch (exn){
    if (exn === Constr_matching$ReactTemplate.PatternMatchingFailure) {
      try {
        var tag$1 = coq_eqdec_inf_rev_pattern.tag | 0;
        match = /* tuple */[
          /* false */0,
          Coqlib$ReactTemplate.coq_sumbool_ref,
          Constr_matching$ReactTemplate.matches(env, sigma, tag$1 === 250 ? coq_eqdec_inf_rev_pattern[0] : (
                  tag$1 === 246 ? CamlinternalLazy.force_lazy_block(coq_eqdec_inf_rev_pattern) : coq_eqdec_inf_rev_pattern
                ), t)
        ];
      }
      catch (exn$1){
        if (exn$1 === Constr_matching$ReactTemplate.PatternMatchingFailure) {
          try {
            var tag$2 = coq_eqdec_pattern.tag | 0;
            match = /* tuple */[
              /* true */1,
              Coqlib$ReactTemplate.coq_or_ref,
              Constr_matching$ReactTemplate.matches(env, sigma, tag$2 === 250 ? coq_eqdec_pattern[0] : (
                      tag$2 === 246 ? CamlinternalLazy.force_lazy_block(coq_eqdec_pattern) : coq_eqdec_pattern
                    ), t)
            ];
          }
          catch (exn$2){
            if (exn$2 === Constr_matching$ReactTemplate.PatternMatchingFailure) {
              var tag$3 = coq_eqdec_rev_pattern.tag | 0;
              match = /* tuple */[
                /* false */0,
                Coqlib$ReactTemplate.coq_or_ref,
                Constr_matching$ReactTemplate.matches(env, sigma, tag$3 === 250 ? coq_eqdec_rev_pattern[0] : (
                        tag$3 === 246 ? CamlinternalLazy.force_lazy_block(coq_eqdec_rev_pattern) : coq_eqdec_rev_pattern
                      ), t)
              ];
            } else {
              throw exn$2;
            }
          }
        } else {
          throw exn$1;
        }
      }
    } else {
      throw exn;
    }
  }
  var op = match[1];
  var match$1 = Curry._1(Names$ReactTemplate.Id[/* Map */10][/* bindings */16], match[2]);
  var exit = 0;
  if (match$1) {
    var match$2 = match$1[1];
    if (match$2) {
      var match$3 = match$2[1];
      if (match$3) {
        if (match$3[1]) {
          exit = 1;
        } else {
          var tag$4 = op.tag | 0;
          return /* tuple */[
                  match[0],
                  tag$4 === 250 ? op[0] : (
                      tag$4 === 246 ? CamlinternalLazy.force_lazy_block(op) : op
                    ),
                  match$2[0][1],
                  match$3[0][1],
                  match$1[0][1]
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unexpected pattern."));
  }
  
}

var coq_not_pattern = Block.__(246, [(function () {
        var c = mkGApp(mkGRef(Coqlib$ReactTemplate.coq_not_ref), /* :: */[
              mkGHole,
              /* [] */0
            ]);
        return Patternops$ReactTemplate.pattern_of_glob_constr(c)[1];
      })]);

var coq_imp_False_pattern = Block.__(246, [(function () {
        var c = mkGArrow(mkGHole, mkGRef(Coqlib$ReactTemplate.coq_False_ref));
        return Patternops$ReactTemplate.pattern_of_glob_constr(c)[1];
      })]);

function is_matching_not(env, sigma, t) {
  var tag = coq_not_pattern.tag | 0;
  return Constr_matching$ReactTemplate.is_matching(env, sigma, tag === 250 ? coq_not_pattern[0] : (
                tag === 246 ? CamlinternalLazy.force_lazy_block(coq_not_pattern) : coq_not_pattern
              ), t);
}

function is_matching_imp_False(env, sigma, t) {
  var tag = coq_imp_False_pattern.tag | 0;
  return Constr_matching$ReactTemplate.is_matching(env, sigma, tag === 250 ? coq_imp_False_pattern[0] : (
                tag === 246 ? CamlinternalLazy.force_lazy_block(coq_imp_False_pattern) : coq_imp_False_pattern
              ), t);
}

exports.match_with_non_recursive_type = match_with_non_recursive_type;
exports.is_non_recursive_type = is_non_recursive_type;
exports.match_with_disjunction = match_with_disjunction;
exports.is_disjunction = is_disjunction;
exports.match_with_conjunction = match_with_conjunction;
exports.is_conjunction = is_conjunction;
exports.match_with_record = match_with_record;
exports.is_record = is_record;
exports.match_with_tuple = match_with_tuple;
exports.is_tuple = is_tuple;
exports.match_with_empty_type = match_with_empty_type;
exports.is_empty_type = is_empty_type;
exports.match_with_unit_or_eq_type = match_with_unit_or_eq_type;
exports.is_unit_or_eq_type = is_unit_or_eq_type;
exports.is_unit_type = is_unit_type;
exports.is_inductive_equality = is_inductive_equality;
exports.match_with_equality_type = match_with_equality_type;
exports.is_equality_type = is_equality_type;
exports.match_with_nottype = match_with_nottype;
exports.is_nottype = is_nottype;
exports.match_with_forall_term = match_with_forall_term;
exports.is_forall_term = is_forall_term;
exports.match_with_imp_term = match_with_imp_term;
exports.is_imp_term = is_imp_term;
exports.has_nodep_prod_after = has_nodep_prod_after;
exports.has_nodep_prod = has_nodep_prod;
exports.match_with_nodep_ind = match_with_nodep_ind;
exports.is_nodep_ind = is_nodep_ind;
exports.match_with_sigma_type = match_with_sigma_type;
exports.is_sigma_type = is_sigma_type;
exports.NoEquationFound = NoEquationFound;
exports.match_with_equation = match_with_equation;
exports.find_eq_data_decompose = find_eq_data_decompose;
exports.find_this_eq_data_decompose = find_this_eq_data_decompose;
exports.find_eq_data = find_eq_data;
exports.find_sigma_data_decompose = find_sigma_data_decompose;
exports.match_sigma = match_sigma;
exports.is_matching_sigma = is_matching_sigma;
exports.match_eqdec = match_eqdec;
exports.is_matching_not = is_matching_not;
exports.is_matching_imp_False = is_matching_imp_False;
/* meta1 Not a pure module */
