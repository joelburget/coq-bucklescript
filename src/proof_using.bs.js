// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Stream = require("bs-platform/lib/js/stream.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Pcoq$ReactTemplate = require("./pcoq.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Printer$ReactTemplate = require("./printer.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var G_vernac$ReactTemplate = require("../parsing/g_vernac.bs.js");
var Goptions$ReactTemplate = require("./goptions.bs.js");
var Ppvernac$ReactTemplate = require("./ppvernac.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");

var known_names = Summary$ReactTemplate.ref(/* None */0, "proofusing-nameset", /* [] */0);

var init = Libobject$ReactTemplate.default_object("proofusing-nameset");

var in_nameset = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */(function (param) {
          known_names[0] = /* :: */[
            param[1],
            known_names[0]
          ];
          return /* () */0;
        }),
      /* load_function */init[/* load_function */2],
      /* open_function */init[/* open_function */3],
      /* classify_function */(function () {
          return /* Dispose */0;
        }),
      /* subst_function */init[/* subst_function */5],
      /* discharge_function */(function () {
          return /* None */0;
        }),
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

function close_fwd(e, _s) {
  while(true) {
    var s = _s;
    var s$prime = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (s, decl) {
            var vb;
            vb = decl.tag ? Environ$ReactTemplate.global_vars_set(e, decl[1]) : Names$ReactTemplate.Id[/* Set */9][/* empty */0];
            var vty = Environ$ReactTemplate.global_vars_set(e, Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl));
            var vbty = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], vb, vty);
            if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* exists */15], (function (v) {
                      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], v, s);
                    }), vbty)) {
              return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl), Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], s, vbty));
            } else {
              return s;
            }
          }), s, Environ$ReactTemplate.named_context(e));
    if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* equal */10], s, s$prime)) {
      return s;
    } else {
      _s = s$prime;
      continue ;
      
    }
  };
}

function set_of_type(env, ty) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, ty) {
                return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], Environ$ReactTemplate.global_vars_set(env, ty), acc);
              }), Names$ReactTemplate.Id[/* Set */9][/* empty */0], ty);
}

function full_set(env) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], Names$ReactTemplate.Id[/* Set */9][/* add */3], Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], Environ$ReactTemplate.named_context(env)), Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
}

function process_expr(env, e, ty) {
  var aux = function (param) {
    if (typeof param === "number") {
      if (param) {
        return set_of_type(env, ty);
      } else {
        return Names$ReactTemplate.Id[/* Set */9][/* empty */0];
      }
    } else {
      switch (param.tag | 0) {
        case 0 : 
            var env$1 = env;
            var id = param[0][/* v */0];
            if (Names$ReactTemplate.Id[/* to_string */7](id) === "All") {
              return Curry._3(Util$ReactTemplate.List[/* fold_right */14], Names$ReactTemplate.Id[/* Set */9][/* add */3], Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], Environ$ReactTemplate.named_context(env$1)), Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
            } else if (CList$ReactTemplate.mem_assoc_f(Names$ReactTemplate.Id[/* equal */0], id, known_names[0])) {
              return process_expr(env$1, CList$ReactTemplate.assoc_f(Names$ReactTemplate.Id[/* equal */0], id, known_names[0]), /* [] */0);
            } else {
              return Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], id);
            }
        case 1 : 
            return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* diff */8], full_set(env), aux(param[0]));
        case 2 : 
            return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], aux(param[0]), aux(param[1]));
        case 3 : 
            return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* diff */8], aux(param[0]), aux(param[1]));
        case 4 : 
            return close_fwd(env, aux(param[0]));
        
      }
    }
  };
  return aux(e);
}

function process_expr$1(env, e, ty) {
  var v_ty = set_of_type(env, ty);
  return Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], v_ty, process_expr(env, e, ty)));
}

function name_set(id, expr) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(in_nameset, /* tuple */[
                  id,
                  expr
                ]));
}

function minimize_hyps(env, ids) {
  var _ids = ids;
  while(true) {
    var ids$1 = _ids;
    var ids$prime = Curry._3(Names$ReactTemplate.Id[/* Set */9][/* fold */13], (function (id, alive) {
            var impl_by_id = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* remove */5], id, Environ$ReactTemplate.really_needed(env, Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], id)));
            if (Curry._1(Names$ReactTemplate.Id[/* Set */9][/* is_empty */1], impl_by_id)) {
              return alive;
            } else {
              return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* diff */8], alive, impl_by_id);
            }
          }), ids$1, ids$1);
    if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* equal */10], ids$1, ids$prime)) {
      return ids$1;
    } else {
      _ids = ids$prime;
      continue ;
      
    }
  };
}

function remove_ids_and_lets(env, s, ids) {
  var not_ids = function (id) {
    return 1 - Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, ids);
  };
  var no_body = function (id) {
    return +(Environ$ReactTemplate.named_body(id, env) === /* None */0);
  };
  var deps = function (id) {
    return Environ$ReactTemplate.really_needed(env, Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], id));
  };
  return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* filter */16], (function (id) {
                if (not_ids(id)) {
                  if (no_body(id)) {
                    return /* true */1;
                  } else {
                    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* exists */15], not_ids, Curry._2(Names$ReactTemplate.Id[/* Set */9][/* filter */16], no_body, deps(id)));
                  }
                } else {
                  return /* false */0;
                }
              }), s);
}

function suggest_common(env, ppid, used, ids_typ, skip) {
  var S = Names$ReactTemplate.Id[/* Set */9];
  var pr_set = function (parens, s) {
    var ppcmds = Pp$ReactTemplate.prlist_with_sep((function () {
            return Pp$ReactTemplate.str(" ");
          }), Names$ReactTemplate.Id[/* print */8], Curry._1(S[/* elements */19], s));
    if (parens && Curry._1(S[/* cardinal */18], s) > 1) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), ppcmds), Pp$ReactTemplate.str(")"));
    } else {
      return ppcmds;
    }
  };
  var needed = minimize_hyps(env, remove_ids_and_lets(env, used, ids_typ));
  var all_needed = Environ$ReactTemplate.really_needed(env, needed);
  var all = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (all, d) {
          return Curry._2(S[/* add */3], Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d), all);
        }), S[/* empty */0], Environ$ReactTemplate.named_context(env));
  var all$1 = Curry._2(S[/* diff */8], all, skip);
  var fwd_typ = close_fwd(env, ids_typ);
  if (Flags$ReactTemplate.debug[0]) {
    var x = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("All "), pr_set(/* false */0, all$1));
    Feedback$ReactTemplate.msg_debug(/* None */0, x);
    var x$1 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Type "), pr_set(/* false */0, ids_typ));
    Feedback$ReactTemplate.msg_debug(/* None */0, x$1);
    var x$2 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("needed "), pr_set(/* false */0, needed));
    Feedback$ReactTemplate.msg_debug(/* None */0, x$2);
    var x$3 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("all_needed "), pr_set(/* false */0, all_needed));
    Feedback$ReactTemplate.msg_debug(/* None */0, x$3);
    var x$4 = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Type* "), pr_set(/* false */0, fwd_typ));
    Feedback$ReactTemplate.msg_debug(/* None */0, x$4);
  }
  var valid_exprs = [/* [] */0];
  var valid = function (e) {
    valid_exprs[0] = /* :: */[
      e,
      valid_exprs[0]
    ];
    return /* () */0;
  };
  if (Curry._1(S[/* is_empty */1], needed)) {
    valid(Pp$ReactTemplate.str("Type"));
  }
  if (Curry._2(S[/* equal */10], all_needed, fwd_typ)) {
    valid(Pp$ReactTemplate.str("Type*"));
  }
  if (Curry._2(S[/* equal */10], all$1, all_needed)) {
    valid(Pp$ReactTemplate.str("All"));
  }
  valid(pr_set(/* false */0, needed));
  return Feedback$ReactTemplate.msg_info(/* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("The proof of "), ppid), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("should start with one of the following commands:")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.v(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.cut, (function (x) {
                            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Proof using "), x), Pp$ReactTemplate.str(". "));
                          }), valid_exprs[0]))));
}

var suggest_proof_using = [/* false */0];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"suggest Proof using",
      /* optkey : :: */[
        "Suggest",
        /* :: */[
          "Proof",
          /* :: */[
            "Using",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return suggest_proof_using[0];
        }),
      /* optwrite */(function (param) {
          suggest_proof_using[0] = param;
          return /* () */0;
        })
    ]);

function suggest_constant(env, kn) {
  if (suggest_proof_using[0]) {
    var body = Environ$ReactTemplate.lookup_constant(kn, env);
    var used = Curry._1(Names$ReactTemplate.Id[/* Set */9][/* of_list */25], Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], body[/* const_hyps */0]));
    var ids_typ = Environ$ReactTemplate.global_vars_set(env, body[/* const_type */2]);
    return suggest_common(env, Printer$ReactTemplate.pr_constant(env, kn), used, ids_typ, Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
  } else {
    return 0;
  }
}

function suggest_variable(env, id) {
  if (suggest_proof_using[0]) {
    var match = Environ$ReactTemplate.lookup_named(id, env);
    if (match.tag) {
      var ids_typ = Environ$ReactTemplate.global_vars_set(env, match[2]);
      var ids_body = Environ$ReactTemplate.global_vars_set(env, match[1]);
      var used = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], ids_body, ids_typ);
      return suggest_common(env, Names$ReactTemplate.Id[/* print */8](id), used, ids_typ, Curry._1(Names$ReactTemplate.Id[/* Set */9][/* singleton */4], id));
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "proof_using.ml",
              179,
              22
            ]
          ];
    }
  } else {
    return 0;
  }
}

var value = [/* None */0];

function using_to_string(us) {
  return Pp$ReactTemplate.string_of_ppcmds(Ppvernac$ReactTemplate.pr_using(us));
}

function using_from_string(us) {
  return Pcoq$ReactTemplate.Gram[/* entry_parse */10](G_vernac$ReactTemplate.section_subset_expr, Pcoq$ReactTemplate.Gram[/* parsable */7](/* None */0, Stream.of_string(us)));
}

Goptions$ReactTemplate.declare_stringopt_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"default value for Proof using",
      /* optkey : :: */[
        "Default",
        /* :: */[
          "Proof",
          /* :: */[
            "Using",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return Option$ReactTemplate.map(using_to_string, value[0]);
        }),
      /* optwrite */(function (b) {
          value[0] = Option$ReactTemplate.map(using_from_string, b);
          return /* () */0;
        })
    ]);

function get_default_proof_using() {
  return value[0];
}

exports.process_expr = process_expr$1;
exports.name_set = name_set;
exports.suggest_constant = suggest_constant;
exports.suggest_variable = suggest_variable;
exports.get_default_proof_using = get_default_proof_using;
/* known_names Not a pure module */
