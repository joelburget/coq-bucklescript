// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var ReasonReact = require("reason-react/src/ReasonReact.js");
var Serapi_protocol$ReactTemplate = require("./serapi_protocol.bs.js");

var compare = Caml_obj.caml_compare;

var StringMap = $$Map.Make(/* module */[/* compare */compare]);

var component = ReasonReact.reducerComponent("Repl");

function onSubmit(text) {
  console.log(text);
  return /* () */0;
}

function valueFromEvent(evt) {
  return evt.target.value;
}

function setInputRef(theRef, param) {
  param[/* state */2][/* inputRef */2][0] = (theRef == null) ? /* None */0 : [theRef];
  return /* () */0;
}

console.log(Serapi_protocol$ReactTemplate.exec_cmd(/* Noop */2));

function make() {
  var newrecord = component.slice();
  newrecord[/* didMount */4] = (function () {
      return /* SideEffects */Block.__(2, [(function () {
                    return /* () */0;
                  })]);
    });
  newrecord[/* render */9] = (function (param) {
      var match = param[/* state */2];
      var inputRef = match[/* inputRef */2];
      var text = match[/* text */0];
      var reduce = param[/* reduce */1];
      var historyOutput = $$Array.concat(List.map((function (historyEntry) {
                  var match = historyEntry[1];
                  var i1 = historyEntry[0];
                  var output_elems = List.rev(List.mapi((function (i2, answer_kind) {
                              return React.createElement("p", {
                                          key: i1 + ("." + Pervasives.string_of_int(i2))
                                        }, String(answer_kind));
                            }), match[1]));
                  return $$Array.of_list(/* :: */[
                              React.createElement("p", {
                                    key: i1
                                  }, "> " + match[0]),
                              output_elems
                            ]);
                }), Curry._1(StringMap[/* bindings */16], match[/* history */1])));
      return React.createElement("div", {
                  className: "container"
                }, React.createElement("div", {
                      className: "input",
                      onClick: (function () {
                          var match = inputRef[0];
                          if (match) {
                            return match[0].focus();
                          } else {
                            return /* () */0;
                          }
                        })
                    }, historyOutput, React.createElement("p", undefined, React.createElement("span", {
                              className: "prompt"
                            }, "> "), React.createElement("input", {
                              ref: Curry._1(param[/* handle */0], setInputRef),
                              autoFocus: true,
                              type: "text",
                              value: text,
                              onKeyDown: (function (evt) {
                                  if (evt.key === "Enter") {
                                    console.log(text);
                                    return Curry._2(reduce, (function () {
                                                  return /* Command */Block.__(1, [text]);
                                                }), /* () */0);
                                  } else {
                                    return 0;
                                  }
                                }),
                              onChange: Curry._1(reduce, (function (evt) {
                                      return /* Typed */Block.__(0, [evt.target.value]);
                                    }))
                            }))));
    });
  newrecord[/* initialState */10] = (function () {
      return /* record */[
              /* text */"",
              /* history */StringMap[/* empty */0],
              /* inputRef */[/* None */0]
            ];
    });
  newrecord[/* reducer */12] = (function (action, state) {
      switch (action.tag | 0) {
        case 0 : 
            return /* Update */Block.__(0, [/* record */[
                        /* text */action[0],
                        /* history */state[/* history */1],
                        /* inputRef */state[/* inputRef */2]
                      ]]);
        case 1 : 
            var history = state[/* history */1];
            return /* Update */Block.__(0, [/* record */[
                        /* text */"",
                        /* history */history,
                        /* inputRef */state[/* inputRef */2]
                      ]]);
        case 2 : 
            var msg = action[0];
            if (msg.tag) {
              var contents = msg[0][/* contents */3];
              return /* SideEffects */Block.__(2, [(function () {
                            console.log("processing feedback", contents);
                            return /* () */0;
                          })]);
            } else {
              var cmd_tag = msg[0];
              var history$1 = state[/* history */1];
              var match = Curry._2(StringMap[/* find */21], cmd_tag, history$1);
              var history$2 = Curry._3(StringMap[/* add */3], cmd_tag, /* tuple */[
                    match[0],
                    /* :: */[
                      msg[1],
                      match[1]
                    ]
                  ], history$1);
              return /* Update */Block.__(0, [/* record */[
                          /* text */state[/* text */0],
                          /* history */history$2,
                          /* inputRef */state[/* inputRef */2]
                        ]]);
            }
            break;
        
      }
    });
  return newrecord;
}

exports.StringMap = StringMap;
exports.component = component;
exports.onSubmit = onSubmit;
exports.valueFromEvent = valueFromEvent;
exports.setInputRef = setInputRef;
exports.make = make;
/* StringMap Not a pure module */
