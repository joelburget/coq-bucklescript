// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Lib$ReactTemplate = require("../src/lib.bs.js");
var CAst$ReactTemplate = require("../src/cAst.bs.js");
var Hook$ReactTemplate = require("../src/hook.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var CList$ReactTemplate = require("../src/cList.bs.js");
var Flags$ReactTemplate = require("../src/flags.bs.js");
var Hints$ReactTemplate = require("../tactics/hints.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Lemmas$ReactTemplate = require("../src/lemmas.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var Pfedit$ReactTemplate = require("../src/pfedit.bs.js");
var Refine$ReactTemplate = require("../src/refine.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var Declare$ReactTemplate = require("../src/declare.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Impargs$ReactTemplate = require("../src/impargs.bs.js");
var Namegen$ReactTemplate = require("../src/namegen.bs.js");
var Nameops$ReactTemplate = require("../src/nameops.bs.js");
var Nametab$ReactTemplate = require("../src/nametab.bs.js");
var Tactics$ReactTemplate = require("../src/tactics.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Univops$ReactTemplate = require("../src/univops.bs.js");
var Evarutil$ReactTemplate = require("../src/evarutil.bs.js");
var Goptions$ReactTemplate = require("../src/goptions.bs.js");
var Libnames$ReactTemplate = require("../src/libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Pretyping$ReactTemplate = require("../src/pretyping.bs.js");
var Proofview$ReactTemplate = require("../src/proofview.bs.js");
var Tacticals$ReactTemplate = require("../tactics/tacticals.bs.js");
var Univdecls$ReactTemplate = require("../src/univdecls.bs.js");
var Universes$ReactTemplate = require("../src/universes.bs.js");
var DeclareDef$ReactTemplate = require("./declareDef.bs.js");
var Obligations$ReactTemplate = require("../src/obligations.bs.js");
var Typeclasses$ReactTemplate = require("../src/typeclasses.bs.js");
var Constrintern$ReactTemplate = require("../src/constrintern.bs.js");
var ComAssumption$ReactTemplate = require("./comAssumption.bs.js");
var Typeclasses_errors$ReactTemplate = require("../src/typeclasses_errors.bs.js");
var Implicit_quantifiers$ReactTemplate = require("../src/implicit_quantifiers.bs.js");

var refine_instance = [/* true */1];

Goptions$ReactTemplate.declare_bool_option(/* None */0, /* record */[
      /* optdepr : false */0,
      /* optname */"definition of instances by refining",
      /* optkey : :: */[
        "Refine",
        /* :: */[
          "Instance",
          /* :: */[
            "Mode",
            /* [] */0
          ]
        ]
      ],
      /* optread */(function () {
          return refine_instance[0];
        }),
      /* optwrite */(function (b) {
          refine_instance[0] = b;
          return /* () */0;
        })
    ]);

var typeclasses_db = "typeclass_instances";

function set_typeclass_transparency(c, local, b) {
  return Hints$ReactTemplate.add_hints(local, /* :: */[
              typeclasses_db,
              /* [] */0
            ], /* HintsTransparencyEntry */Block.__(4, [
                /* :: */[
                  c,
                  /* [] */0
                ],
                b
              ]));
}

Hook$ReactTemplate.set(Typeclasses$ReactTemplate.add_instance_hint_hook, (function (inst, path, local, info, poly) {
        var inst$prime;
        inst$prime = inst.tag ? /* IsConstr */Block.__(1, [
              EConstr$ReactTemplate.of_constr(inst[0]),
              Univ$ReactTemplate.ContextSet[/* empty */0]
            ]) : /* IsGlobRef */Block.__(0, [inst[0]]);
        var partial_arg = Evd$ReactTemplate.from_env(Global$ReactTemplate.env(/* () */0));
        var partial_arg$1 = Global$ReactTemplate.env(/* () */0);
        var info_000 = /* hint_priority */info[/* hint_priority */0];
        var info_001 = /* hint_pattern */Option$ReactTemplate.map((function (eta) {
                var param = /* None */0;
                var param$1 = /* None */0;
                var param$2 = eta;
                return Constrintern$ReactTemplate.intern_constr_pattern(partial_arg$1, partial_arg, param, param$1, param$2);
              }), info[/* hint_pattern */1]);
        var info$1 = /* record */[
          info_000,
          info_001
        ];
        return Flags$ReactTemplate.silently((function () {
                      return Hints$ReactTemplate.add_hints(local, /* :: */[
                                  typeclasses_db,
                                  /* [] */0
                                ], /* HintsResolveEntry */Block.__(0, [/* :: */[
                                      /* tuple */[
                                        info$1,
                                        poly,
                                        /* false */0,
                                        /* PathHints */[path],
                                        inst$prime
                                      ],
                                      /* [] */0
                                    ]]));
                    }), /* () */0);
      }));

Hook$ReactTemplate.set(Typeclasses$ReactTemplate.set_typeclass_transparency_hook, set_typeclass_transparency);

Hook$ReactTemplate.set(Typeclasses$ReactTemplate.classes_transparent_state_hook, (function () {
        return Hints$ReactTemplate.Hint_db[/* transparent_state */13](Hints$ReactTemplate.searchtable_map(typeclasses_db));
      }));

function existing_instance(glob, g, info) {
  var c = Nametab$ReactTemplate.$$global(g);
  var info$1 = Option$ReactTemplate.$$default(Hints$ReactTemplate.empty_hint_info, info);
  var match = Global$ReactTemplate.type_of_global_in_context(Global$ReactTemplate.env(/* () */0), c);
  var match$1 = Term$ReactTemplate.decompose_prod_assum(match[0]);
  var match$2 = Typeclasses$ReactTemplate.class_of_constr(Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(match$1[1]));
  if (match$2) {
    return Typeclasses$ReactTemplate.add_instance(Typeclasses$ReactTemplate.new_instance(match$2[0][1][0][0], info$1, glob, c));
  } else {
    return CErrors$ReactTemplate.user_err(g[/* loc */1], /* Some */["declare_instance"], Pp$ReactTemplate.str("Constant does not build instances of a declared type class."));
  }
}

function mismatched_params(env, n, m) {
  return Typeclasses_errors$ReactTemplate.mismatched_ctx_inst(env, /* Parameters */0, n, m);
}

function mismatched_props(env, n, m) {
  return Typeclasses_errors$ReactTemplate.mismatched_ctx_inst(env, /* Properties */1, n, m);
}

function type_ctx_instance(env, sigma, ctx, inst, subst) {
  var _param = /* tuple */[
    sigma,
    subst,
    /* [] */0
  ];
  var _l = inst;
  var _param$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], ctx);
  while(true) {
    var param = _param$1;
    var param$1 = _param;
    var l = _l;
    var subst$1 = param$1[1];
    var sigma$1 = param$1[0];
    if (param) {
      var decl = param[0];
      var t$prime = EConstr$ReactTemplate.Vars[/* substl */3](subst$1, Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl));
      var match;
      match = decl.tag ? /* tuple */[
          /* tuple */[
            sigma$1,
            EConstr$ReactTemplate.Vars[/* substl */3](subst$1, decl[1])
          ],
          l
        ] : /* tuple */[
          Constrintern$ReactTemplate.interp_casted_constr_evars(env, sigma$1, /* None */0, Curry._1(Util$ReactTemplate.List[/* hd */1], l), t$prime),
          Curry._1(Util$ReactTemplate.List[/* tl */2], l)
        ];
      var match$1 = match[0];
      var c$prime = match$1[1];
      var d_000 = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
      var d_001 = /* Some */[c$prime];
      var d = /* tuple */[
        d_000,
        d_001,
        t$prime
      ];
      _param$1 = param[1];
      _l = match[1];
      _param = /* tuple */[
        match$1[0],
        /* :: */[
          c$prime,
          subst$1
        ],
        /* :: */[
          d,
          param$1[2]
        ]
      ];
      continue ;
      
    } else {
      return /* tuple */[
              sigma$1,
              subst$1
            ];
    }
  };
}

function id_of_class(cl) {
  var match = cl[/* cl_impl */1];
  switch (match.tag | 0) {
    case 1 : 
        var match$1 = Names$ReactTemplate.Constant[/* repr3 */6](match[0]);
        return Names$ReactTemplate.Label[/* to_id */6](match$1[2]);
    case 2 : 
        var mip = Environ$ReactTemplate.lookup_mind(match[0][0], Global$ReactTemplate.env(/* () */0))[/* mind_packets */0];
        return Caml_array.caml_array_get(mip, 0)[/* mind_typename */0];
    case 0 : 
    case 3 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "classes.ml",
                105,
                11
              ]
            ];
    
  }
}

function instance_hook(_, info, $$global, imps, hook, cst) {
  Impargs$ReactTemplate.maybe_declare_manual_implicits(/* false */0, cst, /* Some */[/* false */0], imps);
  Typeclasses$ReactTemplate.declare_instance(/* Some */[info], 1 - $$global, cst);
  if (hook) {
    return Curry._1(hook[0], cst);
  } else {
    return /* () */0;
  }
}

function declare_instance_constant(k, info, $$global, imps, hook, id, decl, poly, sigma, term, termtype) {
  var env = Global$ReactTemplate.env(/* () */0);
  var levels = Curry._2(Univ$ReactTemplate.LSet[/* union */6], Univops$ReactTemplate.universes_of_constr(env, termtype), Univops$ReactTemplate.universes_of_constr(env, term));
  var sigma$1 = Evd$ReactTemplate.restrict_universe_context(sigma, levels);
  var uctx = Evd$ReactTemplate.check_univ_decl(poly, sigma$1, decl);
  var entry = Declare$ReactTemplate.definition_entry(/* None */0, /* None */0, /* None */0, /* Some */[termtype], /* Some */[uctx], /* None */0, term);
  var cdecl_000 = /* DefinitionEntry */Block.__(0, [entry]);
  var cdecl_001 = /* IsDefinition */Block.__(1, [/* Instance */10]);
  var cdecl = /* tuple */[
    cdecl_000,
    cdecl_001
  ];
  var kn = Declare$ReactTemplate.declare_constant(/* None */0, /* None */0, id, /* None */0, cdecl);
  Declare$ReactTemplate.definition_message(id);
  Declare$ReactTemplate.declare_univ_binders(/* ConstRef */Block.__(1, [kn]), Evd$ReactTemplate.universe_binders(sigma$1));
  instance_hook(k, info, $$global, imps, hook, /* ConstRef */Block.__(1, [kn]));
  return id;
}

function new_instance($staropt$star, $staropt$star$1, $staropt$star$2, program_mode, poly, ctx, param, props, $staropt$star$3, tac, hook, pri) {
  var cl = param[2];
  var instid = param[0];
  var $$abstract = $staropt$star ? $staropt$star[0] : /* false */0;
  var $$global = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var refine = $staropt$star$2 ? $staropt$star$2[0] : refine_instance[0];
  var generalize = $staropt$star$3 ? $staropt$star$3[0] : /* true */1;
  var env = Global$ReactTemplate.env(/* () */0);
  var instid$1 = instid[0][/* v */0];
  var match = Univdecls$ReactTemplate.interp_univ_decl_opt(env, instid[1]);
  var decl = match[1];
  var match$1 = param[1] !== 0 ? Implicit_quantifiers$ReactTemplate.implicit_application(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* Some */[/* false */0], (function (avoid, param) {
            if (param[0]) {
              var t = CAst$ReactTemplate.make(/* None */0, /* CHole */Block.__(12, [
                      /* None */0,
                      /* IntroAnonymous */0,
                      /* None */0
                    ]));
              return /* tuple */[
                      t,
                      avoid
                    ];
            } else {
              return Pervasives.failwith("new instance: under-applied typeclass");
            }
          }), cl) : /* tuple */[
      cl,
      Names$ReactTemplate.Id[/* Set */9][/* empty */0]
    ];
  var tclass = match$1[0];
  var tclass$1;
  if (generalize) {
    var eta_001 = /* Some */[/* AbsPi */1];
    var eta = /* CGeneralization */Block.__(18, [
        /* Implicit */1,
        eta_001,
        tclass
      ]);
    tclass$1 = CAst$ReactTemplate.make(/* None */0, eta);
  } else {
    tclass$1 = tclass;
  }
  var match$2 = Constrintern$ReactTemplate.interp_context_evars(/* None */0, /* None */0, /* None */0, env, match[0], ctx);
  var match$3 = match$2[1];
  var match$4 = match$3[1];
  var match$5 = match$4[0];
  var ctx$1 = match$5[1];
  var match$6 = Constrintern$ReactTemplate.interp_type_evars_impls(match$5[0], match$2[0], /* Some */[match$3[0]], tclass$1);
  var match$7 = match$6[1];
  var c$prime = match$7[0];
  var sigma = match$6[0];
  var len = Curry._1(Util$ReactTemplate.List[/* length */0], ctx$1);
  var imps = Util$ReactTemplate.$at(match$4[1], Curry._1(Impargs$ReactTemplate.lift_implicits(len), match$7[1]));
  var match$8 = EConstr$ReactTemplate.decompose_prod_assum(sigma, c$prime);
  var ctx$prime = match$8[0];
  var ctx$prime$prime = Util$ReactTemplate.$at(ctx$prime, ctx$1);
  var match$9 = Typeclasses$ReactTemplate.dest_class_app(EConstr$ReactTemplate.push_rel_context(ctx$prime$prime, env), sigma, match$8[1]);
  var match$10 = match$9[0];
  var u = match$10[1];
  var u_s = EConstr$ReactTemplate.EInstance[/* kind */1](sigma, u);
  var cl$1 = Typeclasses$ReactTemplate.typeclass_univ_instance(/* tuple */[
        match$10[0],
        u_s
      ]);
  var args = Curry._2(Util$ReactTemplate.List[/* map */10], EConstr$ReactTemplate.of_constr, match$9[1]);
  var cl_context = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, param);
        }), cl$1[/* cl_context */2][1]);
  var match$11 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, param) {
          var args$prime = param[1];
          var args = param[0];
          if (decl.tag) {
            return /* tuple */[
                    args,
                    /* :: */[
                      EConstr$ReactTemplate.Vars[/* substl */3](args$prime, decl[1]),
                      args$prime
                    ]
                  ];
          } else {
            return /* tuple */[
                    Curry._1(Util$ReactTemplate.List[/* tl */2], args),
                    /* :: */[
                      Curry._1(Util$ReactTemplate.List[/* hd */1], args),
                      args$prime
                    ]
                  ];
          }
        }), cl_context, /* tuple */[
        args,
        /* [] */0
      ]);
  var args$1 = match$11[1];
  var id;
  if (instid$1) {
    var id$1 = instid$1[0];
    var sp = Lib$ReactTemplate.make_path(id$1);
    if (Nametab$ReactTemplate.exists_cci(sp)) {
      CErrors$ReactTemplate.user_err(/* None */0, /* Some */["new_instance"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](id$1), Pp$ReactTemplate.str(" already exists.")));
    }
    id = id$1;
  } else {
    var i = Nameops$ReactTemplate.add_suffix(id_of_class(cl$1), "_instance_0");
    id = Namegen$ReactTemplate.next_global_ident_away(i, Termops$ReactTemplate.vars_of_env(env));
  }
  var env$prime = EConstr$ReactTemplate.push_rel_context(ctx$1, env);
  var sigma$1 = Evarutil$ReactTemplate.nf_evar_map(sigma);
  var sigma$2 = Typeclasses$ReactTemplate.resolve_typeclasses(/* None */0, /* Some */[Typeclasses$ReactTemplate.all_evars], /* None */0, /* None */0, /* Some */[/* true */1], env, sigma$1);
  if ($$abstract) {
    var subst = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (subst$prime, s, decl) {
            if (Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], decl)) {
              return /* :: */[
                      s,
                      subst$prime
                    ];
            } else {
              return subst$prime;
            }
          }), /* [] */0, args$1, cl$1[/* cl_context */2][1]);
    var match$12 = Typeclasses$ReactTemplate.instance_constructor(/* tuple */[
          cl$1,
          u
        ], subst);
    var termtype = EConstr$ReactTemplate.it_mkProd_or_LetIn(match$12[1], Util$ReactTemplate.$at(ctx$prime, ctx$1));
    var match$13 = Evarutil$ReactTemplate.nf_evars_and_universes(sigma$2);
    var sigma$3 = match$13[0];
    Pretyping$ReactTemplate.check_evars(env, Evd$ReactTemplate.empty, sigma$3, termtype);
    var univs = Evd$ReactTemplate.check_univ_decl(poly, sigma$3, decl);
    var termtype$1 = EConstr$ReactTemplate.to_constr(sigma$3, termtype);
    var cst = Declare$ReactTemplate.declare_constant(/* Some */[/* InternalTacticRequest */1], /* None */0, id, /* None */0, /* tuple */[
          /* ParameterEntry */Block.__(1, [/* tuple */[
                /* None */0,
                /* tuple */[
                  termtype$1,
                  univs
                ],
                /* None */0
              ]]),
          /* IsAssumption */Block.__(0, [/* Logical */1])
        ]);
    Declare$ReactTemplate.declare_univ_binders(/* ConstRef */Block.__(1, [cst]), Evd$ReactTemplate.universe_binders(sigma$3));
    instance_hook(cl$1, pri, $$global, imps, hook, /* ConstRef */Block.__(1, [cst]));
    return id;
  } else {
    var props$1;
    if (props) {
      var match$14 = props[0];
      if (match$14[0] !== 0) {
        var match$15 = match$14[1][/* v */0];
        if (match$15.tag === 8) {
          var fs = match$15[0];
          if (Curry._1(Util$ReactTemplate.List[/* length */0], fs) > Curry._1(Util$ReactTemplate.List[/* length */0], cl$1[/* cl_props */3])) {
            mismatched_props(env$prime, Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                        return prim[1];
                      }), fs), cl$1[/* cl_props */3]);
          }
          props$1 = /* Some */[/* Inl */Block.__(0, [fs])];
        } else {
          props$1 = /* Some */[/* Inr */Block.__(1, [match$14[1]])];
        }
      } else {
        props$1 = /* Some */[/* Inr */Block.__(1, [match$14[1]])];
      }
    } else {
      props$1 = program_mode ? /* Some */[/* Inl */Block.__(0, [/* [] */0])] : /* None */0;
    }
    var match$16;
    if (props$1) {
      var match$17 = props$1[0];
      if (match$17.tag) {
        var match$18 = Constrintern$ReactTemplate.interp_casted_constr_evars(env$prime, sigma$2, /* None */0, match$17[0], c$prime);
        match$16 = /* tuple */[
          /* Some */[/* Inr */Block.__(1, [/* tuple */[
                  match$18[1],
                  args$1
                ]])],
          match$18[0]
        ];
      } else {
        var get_id = function (param) {
          return CAst$ReactTemplate.map((function (param) {
                        if (param.tag) {
                          return param[0];
                        } else {
                          return Libnames$ReactTemplate.repr_qualid(param[0])[1];
                        }
                      }), param);
        };
        var match$19 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, decl) {
                var rest = param[1];
                var props = param[0];
                if (Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], decl)) {
                  try {
                    var is_id = function (param) {
                      var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
                      var match$1 = get_id(param[0]);
                      if (match) {
                        return Names$ReactTemplate.Id[/* equal */0](match[0], match$1[/* v */0]);
                      } else {
                        return /* false */0;
                      }
                    };
                    var match = Curry._2(Util$ReactTemplate.List[/* find */26], is_id, rest);
                    var rest$prime = Curry._2(Util$ReactTemplate.List[/* filter */27], (function (v) {
                            return 1 - is_id(v);
                          }), rest);
                    get_id(match[0]);
                    return /* tuple */[
                            /* :: */[
                              match[1],
                              props
                            ],
                            rest$prime
                          ];
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      return /* tuple */[
                              /* :: */[
                                CAst$ReactTemplate.make(/* None */0, /* CHole */Block.__(12, [
                                        /* None */0,
                                        /* IntroAnonymous */0,
                                        /* None */0
                                      ])),
                                props
                              ],
                              rest
                            ];
                    } else {
                      throw exn;
                    }
                  }
                } else {
                  return /* tuple */[
                          props,
                          rest
                        ];
                }
              }), /* tuple */[
              /* [] */0,
              match$17[0]
            ], cl$1[/* cl_props */3]);
        var rest = match$19[1];
        if (rest) {
          match$16 = Typeclasses_errors$ReactTemplate.unbound_method(env$prime, cl$1[/* cl_impl */1], get_id(rest[0][0]));
        } else {
          var kcl_props = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                  return Termops$ReactTemplate.map_rel_decl(EConstr$ReactTemplate.of_constr, param);
                }), cl$1[/* cl_props */3]);
          var match$20 = type_ctx_instance(EConstr$ReactTemplate.push_rel_context(ctx$prime, env$prime), sigma$2, kcl_props, match$19[0], args$1);
          match$16 = /* tuple */[
            /* Some */[/* Inl */Block.__(0, [match$20[1]])],
            match$20[0]
          ];
        }
      }
    } else {
      match$16 = /* tuple */[
        Curry._1(Util$ReactTemplate.List[/* is_empty */45], cl$1[/* cl_props */3]) ? /* Some */[/* Inl */Block.__(0, [args$1])] : /* None */0,
        sigma$2
      ];
    }
    var subst$1 = match$16[0];
    var match$21;
    if (subst$1) {
      var match$22 = subst$1[0];
      if (match$22.tag) {
        var termtype$2 = EConstr$ReactTemplate.it_mkProd_or_LetIn(c$prime, ctx$1);
        var term = EConstr$ReactTemplate.it_mkLambda_or_LetIn(match$22[0][0], ctx$1);
        match$21 = /* tuple */[
          /* Some */[term],
          termtype$2
        ];
      } else {
        var subst$2 = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (subst$prime, s, decl) {
                if (Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* is_local_assum */5], decl)) {
                  return /* :: */[
                          s,
                          subst$prime
                        ];
                } else {
                  return subst$prime;
                }
              }), /* [] */0, match$22[0], Util$ReactTemplate.$at(cl$1[/* cl_props */3], cl$1[/* cl_context */2][1]));
        var match$23 = Typeclasses$ReactTemplate.instance_constructor(/* tuple */[
              cl$1,
              u
            ], subst$2);
        var termtype$3 = EConstr$ReactTemplate.it_mkProd_or_LetIn(match$23[1], Util$ReactTemplate.$at(ctx$prime, ctx$1));
        var term$1 = EConstr$ReactTemplate.it_mkLambda_or_LetIn(Option$ReactTemplate.get(match$23[0]), Util$ReactTemplate.$at(ctx$prime, ctx$1));
        match$21 = /* tuple */[
          /* Some */[term$1],
          termtype$3
        ];
      }
    } else {
      var termtype$4 = EConstr$ReactTemplate.it_mkProd_or_LetIn(c$prime, ctx$1);
      match$21 = /* tuple */[
        /* None */0,
        termtype$4
      ];
    }
    var termtype$5 = match$21[1];
    var sigma$4 = Evarutil$ReactTemplate.nf_evar_map(match$16[1]);
    var sigma$5 = Typeclasses$ReactTemplate.resolve_typeclasses(/* None */0, /* Some */[Typeclasses$ReactTemplate.no_goals_or_obligations], /* None */0, /* None */0, /* Some */[/* true */1], env, sigma$4);
    var sigma$6 = Typeclasses$ReactTemplate.resolve_typeclasses(/* None */0, /* Some */[Typeclasses$ReactTemplate.all_evars], /* None */0, /* None */0, /* Some */[/* false */0], env, sigma$5);
    var sigma$7 = Evarutil$ReactTemplate.nf_evar_map_undefined(sigma$6);
    var match$24 = Evarutil$ReactTemplate.nf_evar_map_universes(sigma$7);
    var sigma$8 = match$24[0];
    Pretyping$ReactTemplate.check_evars(env, Evd$ReactTemplate.empty, sigma$8, termtype$5);
    var termtype$6 = EConstr$ReactTemplate.to_constr(sigma$8, termtype$5);
    var term$2 = Option$ReactTemplate.map((function (param) {
            return EConstr$ReactTemplate.to_constr(sigma$8, param);
          }), match$21[0]);
    if (!Evd$ReactTemplate.has_undefined(sigma$8) && !Option$ReactTemplate.is_empty(term$2)) {
      return declare_instance_constant(cl$1, pri, $$global, imps, hook, id, decl, poly, sigma$8, Option$ReactTemplate.get(term$2), termtype$6);
    } else if (program_mode || refine || Option$ReactTemplate.is_empty(term$2)) {
      var kind_002 = /* DefinitionBody */Block.__(0, [/* Instance */10]);
      var kind = /* tuple */[
        /* Global */2,
        poly,
        kind_002
      ];
      if (program_mode) {
        var hook$1 = function (_, gr, _$1) {
          var cst;
          if (gr.tag === 1) {
            cst = gr[0];
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "classes.ml",
                    306,
                    51
                  ]
                ];
          }
          Impargs$ReactTemplate.declare_manual_implicits(/* false */0, gr, /* Some */[/* false */0], /* :: */[
                imps,
                /* [] */0
              ]);
          return Typeclasses$ReactTemplate.declare_instance(/* Some */[pri], 1 - $$global, /* ConstRef */Block.__(1, [cst]));
        };
        var match$25;
        if (term$2) {
          var match$26 = Obligations$ReactTemplate.eterm_obligations(env, id, sigma$8, 0, /* None */0, term$2[0], termtype$6);
          match$25 = /* tuple */[
            match$26[0],
            /* Some */[match$26[2]],
            match$26[3]
          ];
        } else {
          match$25 = /* tuple */[
            /* array */[],
            /* None */0,
            termtype$6
          ];
        }
        var hook$2 = Lemmas$ReactTemplate.mk_hook(hook$1);
        var ctx$2 = Evd$ReactTemplate.evar_universe_context(sigma$8);
        Obligations$ReactTemplate.add_definition(id, match$25[1], match$25[2], ctx$2, /* Some */[decl], /* None */0, /* Some */[/* tuple */[
                /* Global */2,
                poly,
                /* Instance */10
              ]], /* None */0, /* None */0, /* Some */[hook$2], /* None */0, match$25[0]);
        return id;
      } else {
        Flags$ReactTemplate.silently((function () {
                var gls = Curry._1(Util$ReactTemplate.List[/* rev */4], Evd$ReactTemplate.future_goals(sigma$8));
                var sigma$9 = Evd$ReactTemplate.reset_future_goals(sigma$8);
                Lemmas$ReactTemplate.start_proof(id, /* Some */[decl], kind, sigma$9, /* None */0, /* None */0, EConstr$ReactTemplate.of_constr(termtype$6), /* None */0, /* None */0, Lemmas$ReactTemplate.mk_hook((function () {
                            return (function (param) {
                                return instance_hook(cl$1, pri, $$global, imps, hook, param);
                              });
                          })));
                if (Option$ReactTemplate.is_empty(term$2)) {
                  if (Flags$ReactTemplate.is_auto_intros(/* () */0)) {
                    Pfedit$ReactTemplate.by(Tacticals$ReactTemplate.New[/* tclDO */28](len, Tactics$ReactTemplate.intro));
                  }
                  
                } else {
                  var init_refine = Tacticals$ReactTemplate.New[/* tclTHENLIST */19](/* :: */[
                        Refine$ReactTemplate.refine(/* false */0, (function (sigma) {
                                return /* tuple */[
                                        sigma,
                                        EConstr$ReactTemplate.of_constr(Option$ReactTemplate.get(term$2))
                                      ];
                              })),
                        /* :: */[
                          Proofview$ReactTemplate.Unsafe[/* tclNEWGOALS */3](CList$ReactTemplate.map(Proofview$ReactTemplate.with_empty_state, gls)),
                          /* :: */[
                            Tactics$ReactTemplate.New[/* reduce_after_refine */1],
                            /* [] */0
                          ]
                        ]
                      ]);
                  Pfedit$ReactTemplate.by(init_refine);
                }
                if (tac) {
                  Pfedit$ReactTemplate.by(tac[0]);
                  return /* () */0;
                } else {
                  return /* () */0;
                }
              }), /* () */0);
        return id;
      }
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Unsolved obligations remaining."));
    }
  }
}

function named_of_rel_context(l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (decl, param) {
                  var subst = param[0];
                  var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
                  var id = match ? match[0] : CErrors$ReactTemplate.invalid_arg(/* None */0, "named_of_rel_context");
                  var d;
                  d = decl.tag ? /* tuple */[
                      id,
                      /* Some */[EConstr$ReactTemplate.Vars[/* substl */3](subst, decl[1])],
                      EConstr$ReactTemplate.Vars[/* substl */3](subst, decl[2])
                    ] : /* tuple */[
                      id,
                      /* None */0,
                      EConstr$ReactTemplate.Vars[/* substl */3](subst, decl[1])
                    ];
                  return /* tuple */[
                          /* :: */[
                            EConstr$ReactTemplate.mkVar(id),
                            subst
                          ],
                          /* :: */[
                            d,
                            param[1]
                          ]
                        ];
                }), l, /* tuple */[
                /* [] */0,
                /* [] */0
              ])[1];
}

function context(poly, l) {
  var env = Global$ReactTemplate.env(/* () */0);
  var sigma = Evd$ReactTemplate.from_env(env);
  var match = Constrintern$ReactTemplate.interp_context_evars(/* None */0, /* None */0, /* None */0, env, sigma, l);
  var match$1 = match[1][1];
  var impls = match$1[1];
  var fullctx = match$1[0][1];
  var match$2 = Evarutil$ReactTemplate.nf_evars_and_universes(match[0]);
  var sigma$1 = match$2[0];
  var ce = function (t) {
    return Pretyping$ReactTemplate.check_evars(env, Evd$ReactTemplate.empty, sigma$1, t);
  };
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (decl) {
          return Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* iter_constr */14], ce, decl);
        }), fullctx);
  var ctx;
  try {
    ctx = named_of_rel_context(fullctx);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    if (CErrors$ReactTemplate.noncritical(e)) {
      ctx = CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Anonymous variables not allowed in contexts."));
    } else {
      throw e;
    }
  }
  var uctx = Evd$ReactTemplate.universe_context_set(sigma$1);
  var univs;
  if (ctx) {
    if (ctx[1]) {
      if (Lib$ReactTemplate.sections_are_opened(/* () */0)) {
        Declare$ReactTemplate.declare_universe_context(poly, uctx);
        univs = poly ? /* Polymorphic_const_entry */Block.__(1, [Univ$ReactTemplate.UContext[/* empty */1]]) : /* Monomorphic_const_entry */Block.__(0, [Univ$ReactTemplate.ContextSet[/* empty */0]]);
      } else if (poly) {
        univs = /* Polymorphic_const_entry */Block.__(1, [Univ$ReactTemplate.ContextSet[/* to_context */13](uctx)]);
      } else {
        Declare$ReactTemplate.declare_universe_context(poly, uctx);
        univs = /* Monomorphic_const_entry */Block.__(0, [Univ$ReactTemplate.ContextSet[/* empty */0]]);
      }
    } else {
      univs = poly ? /* Polymorphic_const_entry */Block.__(1, [Univ$ReactTemplate.ContextSet[/* to_context */13](uctx)]) : /* Monomorphic_const_entry */Block.__(0, [uctx]);
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "classes.ml",
            381,
            12
          ]
        ];
  }
  var fn = function (status, param) {
    var id = param[0];
    var b = Option$ReactTemplate.map((function (param) {
            return EConstr$ReactTemplate.to_constr(sigma$1, param);
          }), param[1]);
    var t = EConstr$ReactTemplate.to_constr(sigma$1, param[2]);
    if (Lib$ReactTemplate.is_modtype(/* () */0) && !Lib$ReactTemplate.sections_are_opened(/* () */0)) {
      var decl;
      if (b) {
        var entry = Declare$ReactTemplate.definition_entry(/* None */0, /* None */0, /* None */0, /* Some */[t], /* Some */[univs], /* None */0, b[0]);
        decl = /* tuple */[
          /* DefinitionEntry */Block.__(0, [entry]),
          /* IsAssumption */Block.__(0, [/* Logical */1])
        ];
      } else {
        decl = /* tuple */[
          /* ParameterEntry */Block.__(1, [/* tuple */[
                /* None */0,
                /* tuple */[
                  t,
                  univs
                ],
                /* None */0
              ]]),
          /* IsAssumption */Block.__(0, [/* Logical */1])
        ];
      }
      var cst = Declare$ReactTemplate.declare_constant(/* Some */[/* InternalTacticRequest */1], /* None */0, id, /* None */0, decl);
      var match = Typeclasses$ReactTemplate.class_of_constr(sigma$1, EConstr$ReactTemplate.of_constr(t));
      if (match) {
        Typeclasses$ReactTemplate.add_instance(Typeclasses$ReactTemplate.new_instance(match[0][1][0][0], Hints$ReactTemplate.empty_hint_info, /* false */0, /* ConstRef */Block.__(1, [cst])));
        return status;
      } else {
        return status;
      }
    } else {
      var test = function (param) {
        var x = param[0];
        if (x.tag) {
          return /* false */0;
        } else {
          var match = x[1];
          if (match) {
            return Names$ReactTemplate.Id[/* equal */0](id, match[0]);
          } else {
            return /* false */0;
          }
        }
      };
      var impl = Curry._2(Util$ReactTemplate.List[/* exists */21], test, impls);
      var decl$1 = /* tuple */[
        /* Discharge */0,
        poly,
        /* Definitional */0
      ];
      var nstatus;
      if (b) {
        var decl$2 = /* tuple */[
          /* Discharge */0,
          poly,
          /* Definition */0
        ];
        var entry$1 = Declare$ReactTemplate.definition_entry(/* None */0, /* None */0, /* None */0, /* Some */[t], /* Some */[univs], /* None */0, b[0]);
        var hook = Lemmas$ReactTemplate.mk_hook((function (_, gr) {
                return gr;
              }));
        DeclareDef$ReactTemplate.declare_definition(id, decl$2, entry$1, Universes$ReactTemplate.empty_binders, /* [] */0, hook);
        nstatus = Lib$ReactTemplate.sections_are_opened(/* () */0) || Lib$ReactTemplate.is_modtype_strict(/* () */0);
      } else {
        nstatus = Util$ReactTemplate.pi3(ComAssumption$ReactTemplate.declare_assumption(/* false */0, decl$1, /* tuple */[
                  t,
                  univs
                ], Universes$ReactTemplate.empty_binders, /* [] */0, impl, /* NoInline */0, CAst$ReactTemplate.make(/* None */0, id)));
      }
      if (status) {
        return nstatus;
      } else {
        return /* false */0;
      }
    }
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], fn, /* true */1, Curry._1(Util$ReactTemplate.List[/* rev */4], ctx));
}

exports.mismatched_params = mismatched_params;
exports.mismatched_props = mismatched_props;
exports.existing_instance = existing_instance;
exports.declare_instance_constant = declare_instance_constant;
exports.new_instance = new_instance;
exports.set_typeclass_transparency = set_typeclass_transparency;
exports.id_of_class = id_of_class;
exports.context = context;
/*  Not a pure module */
