// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Modops$ReactTemplate = require("./modops.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Subtyping$ReactTemplate = require("./subtyping.bs.js");
var Mod_typing$ReactTemplate = require("./mod_typing.bs.js");
var Safe_typing$ReactTemplate = require("./safe_typing.bs.js");

function inl2intopt(param) {
  if (typeof param === "number") {
    if (param !== 0) {
      return /* Some */[Flags$ReactTemplate.get_inline_level(/* () */0)];
    } else {
      return /* None */0;
    }
  } else {
    return /* Some */[param[0]];
  }
}

var table = Summary$ReactTemplate.ref(/* None */0, "MODULE-SUBSTOBJS", Names$ReactTemplate.MPmap[/* empty */0]);

var missing_handler = [(function () {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "declaremods.ml",
              75,
              40
            ]
          ];
    })];

function set(mp, objs) {
  table[0] = Curry._3(Names$ReactTemplate.MPmap[/* add */3], mp, objs, table[0]);
  return /* () */0;
}

function get(mp) {
  try {
    return Curry._2(Names$ReactTemplate.MPmap[/* find */21], mp, table[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Curry._1(missing_handler[0], mp);
    } else {
      throw exn;
    }
  }
}

function sobjs_no_functor(param) {
  return Curry._1(Util$ReactTemplate.List[/* is_empty */45], param[0]);
}

function subst_aobjs(sub, param) {
  if (param.tag) {
    return /* Ref */Block.__(1, [
              param[0],
              Mod_subst$ReactTemplate.join(param[1], sub)
            ]);
  } else {
    return /* Objs */Block.__(0, [Lib$ReactTemplate.subst_objects(sub, param[0])]);
  }
}

function subst_sobjs(sub, param) {
  return /* tuple */[
          param[0],
          subst_aobjs(sub, param[1])
        ];
}

function expand_aobjs(param) {
  if (param.tag) {
    var match = get(param[0]);
    var match$1 = match[1];
    if (match$1.tag) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "declaremods.ml",
              98,
              13
            ]
          ];
    } else {
      return Lib$ReactTemplate.subst_objects(param[1], match$1[0]);
    }
  } else {
    return param[0];
  }
}

function expand_sobjs(param) {
  return expand_aobjs(param[1]);
}

var table$1 = Summary$ReactTemplate.ref(/* None */0, "MODULE-OBJS", Names$ReactTemplate.MPmap[/* empty */0]);

function set$1(mp, objs) {
  table$1[0] = Curry._3(Names$ReactTemplate.MPmap[/* add */3], mp, objs, table$1[0]);
  return /* () */0;
}

function get$1(mp) {
  return Curry._2(Names$ReactTemplate.MPmap[/* find */21], mp, table$1[0]);
}

function mp_of_kn(kn) {
  var match = Names$ReactTemplate.KerName[/* repr */2](kn);
  if (!Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], match[1])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            153,
            2
          ]
        ];
  }
  return /* MPdot */Block.__(2, [
            match[0],
            match[2]
          ]);
}

function dir_of_sp(sp) {
  var match = Libnames$ReactTemplate.repr_path(sp);
  return Libnames$ReactTemplate.add_dirpath_suffix(match[0], match[1]);
}

function consistency_checks(exists, dir, dirinfo) {
  if (exists) {
    var globref;
    try {
      globref = Nametab$ReactTemplate.locate_dir(Libnames$ReactTemplate.qualid_of_dirpath(dir));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        globref = CErrors$ReactTemplate.user_err(/* None */0, /* Some */["consistency_checks"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.DirPath[/* print */10](dir), Pp$ReactTemplate.str(" should already exist!")));
      } else {
        throw exn;
      }
    }
    if (Libnames$ReactTemplate.eq_global_dir_reference(globref, dirinfo)) {
      return 0;
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "declaremods.ml",
              174,
              4
            ]
          ];
    }
  } else if (Nametab$ReactTemplate.exists_dir(dir)) {
    return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["consistency_checks"], Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.DirPath[/* print */10](dir), Pp$ReactTemplate.str(" already exists")));
  } else {
    return 0;
  }
}

function compute_visibility(exists, i) {
  if (exists) {
    return /* Exactly */Block.__(1, [i]);
  } else {
    return /* Until */Block.__(0, [i]);
  }
}

function do_module(exists, iter_objects, i, obj_dir, obj_mp, sobjs, kobjs) {
  var prefix_002 = /* obj_sec */Names$ReactTemplate.DirPath[/* empty */5];
  var prefix = /* record */[
    /* obj_dir */obj_dir,
    /* obj_mp */obj_mp,
    prefix_002
  ];
  var dirinfo = /* DirModule */Block.__(3, [prefix]);
  consistency_checks(exists, obj_dir, dirinfo);
  Nametab$ReactTemplate.push_dir(compute_visibility(exists, i), obj_dir, dirinfo);
  set(obj_mp, sobjs);
  if (sobjs_no_functor(sobjs)) {
    var objs = expand_sobjs(sobjs);
    set$1(obj_mp, /* tuple */[
          prefix,
          objs,
          kobjs
        ]);
    Curry._3(iter_objects, i + 1 | 0, prefix, objs);
    return Curry._3(iter_objects, i + 1 | 0, prefix, kobjs);
  } else {
    return 0;
  }
}

function do_module$prime(exists, iter_objects, i, param) {
  var match = param[0];
  return do_module(exists, iter_objects, i, dir_of_sp(match[0]), mp_of_kn(match[1]), param[1], /* [] */0);
}

function cache_module(param) {
  return do_module$prime(/* false */0, Lib$ReactTemplate.load_objects, 1, param);
}

function load_module(param, param$1) {
  return do_module$prime(/* false */0, Lib$ReactTemplate.load_objects, param, param$1);
}

function open_module(param, param$1) {
  return do_module$prime(/* true */1, Lib$ReactTemplate.open_objects, param, param$1);
}

function subst_module(param) {
  return subst_sobjs(param[0], param[1]);
}

function classify_module(sobjs) {
  return /* Substitute */Block.__(0, [sobjs]);
}

var init = Libobject$ReactTemplate.default_object("MODULE");

var match = Libobject$ReactTemplate.declare_object_full(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_module,
      /* load_function */load_module,
      /* open_function */open_module,
      /* classify_function */classify_module,
      /* subst_function */subst_module,
      /* discharge_function */init[/* discharge_function */6],
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

var out_module = match[1];

var in_module = match[0];

function cache_keep() {
  return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("This module should not be cached!"));
}

function load_keep(i, param) {
  var kobjs = param[1];
  var match = param[0];
  var obj_dir = dir_of_sp(match[0]);
  var obj_mp = mp_of_kn(match[1]);
  var prefix_002 = /* obj_sec */Names$ReactTemplate.DirPath[/* empty */5];
  var prefix = /* record */[
    /* obj_dir */obj_dir,
    /* obj_mp */obj_mp,
    prefix_002
  ];
  var match$1;
  try {
    match$1 = get$1(obj_mp);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "declaremods.ml",
              231,
              22
            ]
          ];
    } else {
      throw exn;
    }
  }
  if (!Libnames$ReactTemplate.eq_op(match$1[0], prefix)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            233,
            2
          ]
        ];
  }
  if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], match$1[2])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            234,
            2
          ]
        ];
  }
  set$1(obj_mp, /* tuple */[
        prefix,
        match$1[1],
        kobjs
      ]);
  return Curry._1(Lib$ReactTemplate.load_objects(i, prefix), kobjs);
}

function open_keep(i, param) {
  var match = param[0];
  var obj_dir = dir_of_sp(match[0]);
  var obj_mp = mp_of_kn(match[1]);
  var prefix_002 = /* obj_sec */Names$ReactTemplate.DirPath[/* empty */5];
  var prefix = /* record */[
    /* obj_dir */obj_dir,
    /* obj_mp */obj_mp,
    prefix_002
  ];
  return Curry._1(Lib$ReactTemplate.open_objects(i, prefix), param[1]);
}

var init$1 = Libobject$ReactTemplate.default_object("MODULE KEEP");

var in_modkeep = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$1[/* object_name */0],
      /* cache_function */cache_keep,
      /* load_function */load_keep,
      /* open_function */open_keep,
      /* classify_function */init$1[/* classify_function */4],
      /* subst_function */init$1[/* subst_function */5],
      /* discharge_function */init$1[/* discharge_function */6],
      /* rebuild_function */init$1[/* rebuild_function */7]
    ]);

function do_modtype(i, sp, mp, sobjs) {
  if (Nametab$ReactTemplate.exists_modtype(sp)) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Libnames$ReactTemplate.pr_path(sp), Pp$ReactTemplate.str(" already exists.")));
  }
  Nametab$ReactTemplate.push_modtype(/* Until */Block.__(0, [i]), sp, mp);
  return set(mp, sobjs);
}

function cache_modtype(param) {
  var match = param[0];
  return do_modtype(1, match[0], mp_of_kn(match[1]), param[1]);
}

function load_modtype(i, param) {
  var match = param[0];
  return do_modtype(i, match[0], mp_of_kn(match[1]), param[1]);
}

function subst_modtype(param) {
  return subst_sobjs(param[0], param[1]);
}

function classify_modtype(sobjs) {
  return /* Substitute */Block.__(0, [sobjs]);
}

function open_modtype(i, param) {
  var match = param[0];
  var sp = match[0];
  var mp = mp_of_kn(match[1]);
  var mp$prime;
  try {
    mp$prime = Nametab$ReactTemplate.locate_modtype(Libnames$ReactTemplate.qualid_of_path(sp));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      mp$prime = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Libnames$ReactTemplate.pr_path(sp), Pp$ReactTemplate.str(" should already exist!")));
    } else {
      throw exn;
    }
  }
  if (!Names$ReactTemplate.ModPath[/* equal */1](mp, mp$prime)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            273,
            2
          ]
        ];
  }
  return Nametab$ReactTemplate.push_modtype(/* Exactly */Block.__(1, [i]), sp, mp);
}

var init$2 = Libobject$ReactTemplate.default_object("MODULE TYPE");

var match$1 = Libobject$ReactTemplate.declare_object_full(/* record */[
      /* object_name */init$2[/* object_name */0],
      /* cache_function */cache_modtype,
      /* load_function */load_modtype,
      /* open_function */open_modtype,
      /* classify_function */classify_modtype,
      /* subst_function */subst_modtype,
      /* discharge_function */init$2[/* discharge_function */6],
      /* rebuild_function */init$2[/* rebuild_function */7]
    ]);

var out_modtype = match$1[1];

var in_modtype = match$1[0];

function do_include(do_load, do_open, i, param) {
  var match = param[0];
  var obj_dir = Libnames$ReactTemplate.dirpath(match[0]);
  var obj_mp = Names$ReactTemplate.KerName[/* modpath */3](match[1]);
  var prefix_002 = /* obj_sec */Names$ReactTemplate.DirPath[/* empty */5];
  var prefix = /* record */[
    /* obj_dir */obj_dir,
    /* obj_mp */obj_mp,
    prefix_002
  ];
  var o = expand_aobjs(param[1]);
  if (do_load) {
    Curry._1(Lib$ReactTemplate.load_objects(i, prefix), o);
  }
  if (do_open) {
    return Curry._1(Lib$ReactTemplate.open_objects(i, prefix), o);
  } else {
    return 0;
  }
}

function cache_include(param) {
  return do_include(/* true */1, /* true */1, 1, param);
}

function load_include(param, param$1) {
  return do_include(/* true */1, /* false */0, param, param$1);
}

function open_include(param, param$1) {
  return do_include(/* false */0, /* true */1, param, param$1);
}

function subst_include(param) {
  return subst_aobjs(param[0], param[1]);
}

function classify_include(aobjs) {
  return /* Substitute */Block.__(0, [aobjs]);
}

var init$3 = Libobject$ReactTemplate.default_object("INCLUDE");

var match$2 = Libobject$ReactTemplate.declare_object_full(/* record */[
      /* object_name */init$3[/* object_name */0],
      /* cache_function */cache_include,
      /* load_function */load_include,
      /* open_function */open_include,
      /* classify_function */classify_include,
      /* subst_function */subst_include,
      /* discharge_function */init$3[/* discharge_function */6],
      /* rebuild_function */init$3[/* rebuild_function */7]
    ]);

var out_include = match$2[1];

var in_include = match$2[0];

function mp_id(mp, id) {
  return /* MPdot */Block.__(2, [
            mp,
            Names$ReactTemplate.Label[/* of_id */5](id)
          ]);
}

function register_mod_objs(mp, param) {
  var obj = param[1];
  var id = param[0];
  var match = Libobject$ReactTemplate.object_tag(obj);
  switch (match) {
    case "INCLUDE" : 
        return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                      return register_mod_objs(mp, param);
                    }), expand_aobjs(Curry._1(out_include, obj)));
    case "MODULE" : 
        return set(mp_id(mp, id), Curry._1(out_module, obj));
    case "MODULE TYPE" : 
        return set(mp_id(mp, id), Curry._1(out_modtype, obj));
    default:
      return /* () */0;
  }
}

function handle_missing_substobjs(mp) {
  switch (mp.tag | 0) {
    case 0 : 
    case 1 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "declaremods.ml",
                333,
                4
              ]
            ];
    case 2 : 
        var mp$prime = mp[0];
        var objs = expand_sobjs(get(mp$prime));
        Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                return register_mod_objs(mp$prime, param);
              }), objs);
        return get(mp);
    
  }
}

missing_handler[0] = handle_missing_substobjs;

function get_applications(mexpr) {
  var _params = /* [] */0;
  var _param = mexpr;
  while(true) {
    var param = _param;
    var params = _params;
    switch (param.tag | 0) {
      case 0 : 
          return /* tuple */[
                  param[0],
                  params
                ];
      case 1 : 
          _param = param[0];
          _params = /* :: */[
            param[1],
            params
          ];
          continue ;
          case 2 : 
          return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Non-atomic functor application."));
      
    }
  };
}

function compute_subst(env, mbids, sign, mp_l, inl) {
  if (mp_l) {
    if (mbids) {
      var mp = mp_l[0];
      var match = Modops$ReactTemplate.destr_functor(sign);
      var mb = Environ$ReactTemplate.lookup_module(mp, env);
      var match$1 = compute_subst(env, mbids[1], match[2], mp_l[1], inl);
      var resolver = Modops$ReactTemplate.is_functor(mb[/* mod_type */2]) ? Mod_subst$ReactTemplate.empty_delta_resolver : Modops$ReactTemplate.inline_delta_resolver(env, inl, mp, match[0], match[1], mb[/* mod_delta */5]);
      return /* tuple */[
              match$1[0],
              Mod_subst$ReactTemplate.join(Mod_subst$ReactTemplate.map_mbid(mbids[0], mp, resolver), match$1[1])
            ];
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Application of a functor with too few arguments."));
    }
  } else {
    return /* tuple */[
            mbids,
            Mod_subst$ReactTemplate.empty_subst
          ];
  }
}

function replace_module_object(idl, mp0, objs0, mp1, objs1) {
  var exit = 0;
  if (objs0) {
    if (idl) {
      var match = objs0[0];
      var obj = match[1];
      var idl$1 = idl[1];
      var id = idl[0];
      if (Names$ReactTemplate.Id[/* equal */0](id, match[0])) {
        if (Libobject$ReactTemplate.object_tag(obj) !== "MODULE") {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "declaremods.ml",
                  376,
                  4
                ]
              ];
        }
        var mp_id_001 = Names$ReactTemplate.Label[/* of_id */5](id);
        var mp_id = /* MPdot */Block.__(2, [
            mp0,
            mp_id_001
          ]);
        var objs;
        if (idl$1) {
          var objs_id = expand_sobjs(Curry._1(out_module, obj));
          objs = replace_module_object(idl$1, mp_id, objs_id, mp1, objs1);
        } else {
          objs = Lib$ReactTemplate.subst_objects(Mod_subst$ReactTemplate.map_mp(mp1, mp_id, Mod_subst$ReactTemplate.empty_delta_resolver), objs1);
        }
        return /* :: */[
                /* tuple */[
                  id,
                  Curry._1(in_module, /* tuple */[
                        /* [] */0,
                        /* Objs */Block.__(0, [objs])
                      ])
                ],
                objs0[1]
              ];
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    return /* [] */0;
  }
  if (exit === 1) {
    return /* :: */[
            objs0[0],
            replace_module_object(idl, mp0, objs0[1], mp1, objs1)
          ];
  }
  
}

function type_of_mod(mp, env, param) {
  if (param !== 0) {
    return Environ$ReactTemplate.lookup_module(mp, env)[/* mod_type */2];
  } else {
    return Environ$ReactTemplate.lookup_modtype(mp, env)[/* mod_type */2];
  }
}

function get_module_path(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case 0 : 
          return param[0];
      case 1 : 
      case 2 : 
          _param = param[0];
          continue ;
          
    }
  };
}

function get_module_sobjs(is_mod, env, inl, _me) {
  while(true) {
    var me = _me;
    switch (me.tag | 0) {
      case 0 : 
          var mp = me[0];
          var sobjs = get(mp);
          if (!sobjs[1].tag && !Names$ReactTemplate.ModPath[/* is_bound */3](mp)) {
            return /* tuple */[
                    sobjs[0],
                    /* Ref */Block.__(1, [
                        mp,
                        Mod_subst$ReactTemplate.empty_subst
                      ])
                  ];
          } else {
            return sobjs;
          }
          break;
      case 1 : 
          var match = get_applications(me);
          var mp1 = match[0];
          var match$1 = get_module_sobjs(is_mod, env, inl, /* MEident */Block.__(0, [mp1]));
          var typ = type_of_mod(mp1, env, is_mod);
          var match$2 = compute_subst(env, match$1[0], typ, match[1], inl);
          return /* tuple */[
                  match$2[0],
                  subst_aobjs(match$2[1], match$1[1])
                ];
      case 2 : 
          var match$3 = me[1];
          var mty = me[0];
          if (match$3.tag) {
            _me = mty;
            continue ;
            
          } else {
            var mp1$1 = match$3[1];
            if (is_mod) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "declaremods.ml",
                      407,
                      4
                    ]
                  ];
            }
            var sobjs0 = get_module_sobjs(is_mod, env, inl, mty);
            if (!sobjs_no_functor(sobjs0)) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "declaremods.ml",
                      409,
                      4
                    ]
                  ];
            }
            var mp0 = get_module_path(mty);
            var objs0 = expand_sobjs(sobjs0);
            var objs1 = expand_sobjs(get(mp1$1));
            return /* tuple */[
                    /* [] */0,
                    /* Objs */Block.__(0, [replace_module_object(match$3[0], mp0, objs0, mp1$1, objs1)])
                  ];
          }
          break;
      
    }
  };
}

function get_functor_sobjs(is_mod, env, inl, param) {
  var match = get_module_sobjs(is_mod, env, inl, param[1]);
  return /* tuple */[
          Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* map */10], (function (prim) {
                      return prim[0];
                    }), param[0]), match[0]),
          match[1]
        ];
}

function process_module_binding(mbid, me) {
  var dir = Names$ReactTemplate.DirPath[/* make */3](/* :: */[
        Names$ReactTemplate.MBId[/* to_id */5](mbid),
        /* [] */0
      ]);
  var mp = /* MPbound */Block.__(1, [mbid]);
  var sobjs = get_module_sobjs(/* false */0, Global$ReactTemplate.env(/* () */0), /* Some */[Flags$ReactTemplate.get_inline_level(/* () */0)], me);
  var subst = Mod_subst$ReactTemplate.map_mp(get_module_path(me), mp, Mod_subst$ReactTemplate.empty_delta_resolver);
  var sobjs$1 = subst_sobjs(subst, sobjs);
  return do_module(/* false */0, Lib$ReactTemplate.load_objects, 1, dir, mp, sobjs$1, /* [] */0);
}

function intern_args(interp_modast, params) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                var interp_modast$1 = interp_modast;
                var param$2 = param;
                var param$3 = param$1;
                var match = param$3[1];
                var inl = inl2intopt(match[1]);
                var lib_dir = Lib$ReactTemplate.library_dp(/* () */0);
                var env = Global$ReactTemplate.env(/* () */0);
                var match$1 = Curry._3(interp_modast$1, env, /* ModType */1, match[0]);
                var cst$prime = match$1[2];
                var mty = match$1[0];
                Global$ReactTemplate.push_context_set(/* true */1, cst$prime);
                var env$1 = Global$ReactTemplate.env(/* () */0);
                var sobjs = get_module_sobjs(/* false */0, env$1, inl, mty);
                var mp0 = get_module_path(mty);
                var fold = function (acc, param) {
                  var id = param[/* v */0];
                  var dir = Names$ReactTemplate.DirPath[/* make */3](/* :: */[
                        id,
                        /* [] */0
                      ]);
                  var mbid = Names$ReactTemplate.MBId[/* make */3](lib_dir, id);
                  var mp = /* MPbound */Block.__(1, [mbid]);
                  var resolver = Global$ReactTemplate.add_module_parameter(mbid, mty, inl);
                  var sobjs$1 = subst_sobjs(Mod_subst$ReactTemplate.map_mp(mp0, mp, resolver), sobjs);
                  do_module(/* false */0, Lib$ReactTemplate.load_objects, 1, dir, mp, sobjs$1, /* [] */0);
                  return /* :: */[
                          /* tuple */[
                            mbid,
                            mty,
                            inl
                          ],
                          acc
                        ];
                };
                var acc = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, param$2[0], param$3[0]);
                return /* tuple */[
                        acc,
                        Univ$ReactTemplate.ContextSet[/* union */6](param$2[1], cst$prime)
                      ];
              }), /* tuple */[
              /* [] */0,
              Univ$ReactTemplate.ContextSet[/* empty */0]
            ], params);
}

function check_sub(mtb, sub_mtb_l) {
  Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (sub_mtb, env) {
          return Environ$ReactTemplate.add_constraints(Subtyping$ReactTemplate.check_subtypes(env, mtb, sub_mtb), env);
        }), sub_mtb_l, Global$ReactTemplate.env(/* () */0));
  return /* () */0;
}

function check_subtypes(mp, sub_mtb_l) {
  var mb;
  try {
    mb = Global$ReactTemplate.lookup_module(mp);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "declaremods.ml",
              499,
              50
            ]
          ];
    } else {
      throw exn;
    }
  }
  var mtb = Modops$ReactTemplate.module_type_of_module(mb);
  return check_sub(mtb, sub_mtb_l);
}

function check_subtypes_mt(mp, sub_mtb_l) {
  var mtb;
  try {
    mtb = Global$ReactTemplate.lookup_modtype(mp);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "declaremods.ml",
              508,
              51
            ]
          ];
    } else {
      throw exn;
    }
  }
  return check_sub(mtb, sub_mtb_l);
}

function mk_params_entry(args) {
  return Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (param) {
                return /* tuple */[
                        param[0],
                        param[1]
                      ];
              }), args);
}

function mk_funct_type(env, args, seb0) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (seb, param) {
                var arg_id = param[0];
                var mp = /* MPbound */Block.__(1, [arg_id]);
                var arg_t = Mod_typing$ReactTemplate.translate_modtype(env, mp, param[2], /* tuple */[
                      /* [] */0,
                      param[1]
                    ]);
                return /* MoreFunctor */Block.__(1, [
                          arg_id,
                          arg_t,
                          seb
                        ]);
              }), seb0, args);
}

function build_subtypes(interp_modast, env, mp, args, mtys) {
  var match = Curry._3(Util$ReactTemplate.List[/* fold_left_map */116], (function (cst, param) {
          var inl = inl2intopt(param[1]);
          var match = Curry._3(interp_modast, env, /* ModType */1, param[0]);
          var cst$prime = match[2];
          var env$1 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], cst$prime, env);
          var cst$1 = Univ$ReactTemplate.ContextSet[/* union */6](cst, cst$prime);
          var mtb = Mod_typing$ReactTemplate.translate_modtype(env$1, mp, inl, /* tuple */[
                /* [] */0,
                match[0]
              ]);
          var newrecord = mtb.slice();
          return /* tuple */[
                  cst$1,
                  (newrecord[/* mod_type */2] = mk_funct_type(env$1, args, mtb[/* mod_type */2]), newrecord)
                ];
        }), Univ$ReactTemplate.ContextSet[/* empty */0], mtys);
  return /* tuple */[
          match[1],
          match[0]
        ];
}

var openmod_info = Summary$ReactTemplate.ref(/* None */0, "MODULE-INFO", /* record */[
      /* cur_typ : None */0,
      /* cur_typs : [] */0
    ]);

var openmodtype_info = Summary$ReactTemplate.ref(/* None */0, "MODTYPE-INFO", /* [] */0);

function start_module(interp_modast, $$export, id, args, res, fs) {
  var mp = Global$ReactTemplate.start_module(id);
  var match = intern_args(interp_modast, args);
  Global$ReactTemplate.push_context_set(/* true */1, match[1]);
  var env = Global$ReactTemplate.env(/* () */0);
  var match$1;
  if (res.tag) {
    var match$2 = build_subtypes(interp_modast, env, mp, match[0], res[0]);
    match$1 = /* tuple */[
      /* None */0,
      match$2[0],
      match$2[1]
    ];
  } else {
    var match$3 = res[0];
    var inl = inl2intopt(match$3[1]);
    var match$4 = Curry._3(interp_modast, env, /* ModType */1, match$3[0]);
    var cst = match$4[2];
    var mte = match$4[0];
    var env$1 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], cst, env);
    var match$5 = Mod_typing$ReactTemplate.translate_mse(env$1, /* None */0, inl, mte);
    var cst$1 = Univ$ReactTemplate.ContextSet[/* union */6](cst, match$5[3]);
    match$1 = /* tuple */[
      /* Some */[/* tuple */[
          mte,
          inl
        ]],
      /* [] */0,
      cst$1
    ];
  }
  Global$ReactTemplate.push_context_set(/* true */1, match$1[2]);
  openmod_info[0] = /* record */[
    /* cur_typ */match$1[0],
    /* cur_typs */match$1[1]
  ];
  var prefix = Lib$ReactTemplate.start_module($$export, id, mp, fs);
  Nametab$ReactTemplate.push_dir(/* Until */Block.__(0, [1]), prefix[/* obj_dir */0], /* DirOpenModule */Block.__(0, [prefix]));
  return mp;
}

function end_module() {
  var match = Lib$ReactTemplate.end_module(/* () */0);
  var oldoname = match[0];
  var match$1 = Lib$ReactTemplate.classify_segment(match[3]);
  var m_info = openmod_info[0];
  var match$2 = m_info[/* cur_typ */0];
  var match$3;
  if (match$2) {
    var match$4 = match$2[0];
    match$3 = /* tuple */[
      get_module_sobjs(/* false */0, Global$ReactTemplate.env(/* () */0), match$4[1], match$4[0]),
      /* [] */0,
      /* [] */0
    ];
  } else {
    match$3 = /* tuple */[
      /* tuple */[
        /* [] */0,
        /* Objs */Block.__(0, [match$1[0]])
      ],
      match$1[1],
      match$1[2]
    ];
  }
  var special = match$3[2];
  var keep = match$3[1];
  var sobjs0 = match$3[0];
  var id = Libnames$ReactTemplate.basename(oldoname[0]);
  var match$5 = Global$ReactTemplate.end_module(match[2], id, m_info[/* cur_typ */0]);
  var mbids = match$5[1];
  var mp = match$5[0];
  var sobjs_000 = Util$ReactTemplate.$at(mbids, sobjs0[0]);
  var sobjs_001 = sobjs0[1];
  var sobjs = /* tuple */[
    sobjs_000,
    sobjs_001
  ];
  check_subtypes(mp, m_info[/* cur_typs */1]);
  var match$6 = m_info[/* cur_typ */0];
  var sobjs$1 = match$6 ? subst_sobjs(Mod_subst$ReactTemplate.map_mp(get_module_path(match$6[0][0]), mp, match$5[2]), sobjs) : sobjs;
  var node = Curry._1(in_module, sobjs$1);
  var objects = keep ? (
      mbids ? Util$ReactTemplate.$at(special, /* :: */[
              node,
              /* [] */0
            ]) : Util$ReactTemplate.$at(special, /* :: */[
              node,
              /* :: */[
                Curry._1(in_modkeep, keep),
                /* [] */0
              ]
            ])
    ) : Util$ReactTemplate.$at(special, /* :: */[
          node,
          /* [] */0
        ]);
  var newoname = Lib$ReactTemplate.add_leaves(id, objects);
  if (!Libnames$ReactTemplate.eq_full_path(newoname[0], oldoname[0])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            630,
            2
          ]
        ];
  }
  if (!Names$ReactTemplate.ModPath[/* equal */1](mp_of_kn(newoname[1]), mp)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            631,
            2
          ]
        ];
  }
  return mp;
}

function declare_module(interp_modast, id, args, res, mexpr_o, fs) {
  var mp = Global$ReactTemplate.start_module(id);
  var match = intern_args(interp_modast, args);
  var cst = match[1];
  var arg_entries_r = match[0];
  var params = mk_params_entry(arg_entries_r);
  var env = Global$ReactTemplate.env(/* () */0);
  var env$1 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], cst, env);
  var match$1;
  if (res.tag) {
    var match$2 = build_subtypes(interp_modast, env$1, mp, arg_entries_r, res[0]);
    match$1 = /* tuple */[
      /* None */0,
      match$2[0],
      /* Some */[Flags$ReactTemplate.get_inline_level(/* () */0)],
      match$2[1]
    ];
  } else {
    var match$3 = res[0];
    var inl = inl2intopt(match$3[1]);
    var match$4 = Curry._3(interp_modast, env$1, /* ModType */1, match$3[0]);
    var cst$1 = match$4[2];
    var mte = match$4[0];
    var env$2 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], cst$1, env$1);
    var match$5 = Mod_typing$ReactTemplate.translate_mse(env$2, /* None */0, inl, mte);
    var cst$2 = Univ$ReactTemplate.ContextSet[/* union */6](cst$1, match$5[3]);
    match$1 = /* tuple */[
      /* Some */[mte],
      /* [] */0,
      inl,
      cst$2
    ];
  }
  var cst$prime = match$1[3];
  var inl_res = match$1[2];
  var mty_entry_o = match$1[0];
  var env$3 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], cst$prime, env$1);
  var cst$3 = Univ$ReactTemplate.ContextSet[/* union */6](cst, cst$prime);
  var match$6;
  if (mexpr_o) {
    var match$7 = mexpr_o[0];
    var match$8 = Curry._3(interp_modast, env$3, /* Module */0, match$7[0]);
    match$6 = /* tuple */[
      /* Some */[match$8[0]],
      inl2intopt(match$7[1]),
      match$8[2]
    ];
  } else {
    match$6 = /* tuple */[
      /* None */0,
      /* Some */[Flags$ReactTemplate.get_inline_level(/* () */0)],
      Univ$ReactTemplate.ContextSet[/* empty */0]
    ];
  }
  var cst$prime$1 = match$6[2];
  var inl_expr = match$6[1];
  var mexpr_entry_o = match$6[0];
  var env$4 = Environ$ReactTemplate.push_context_set(/* Some */[/* true */1], cst$prime$1, env$3);
  var cst$4 = Univ$ReactTemplate.ContextSet[/* union */6](cst$3, cst$prime$1);
  var entry;
  if (mexpr_entry_o) {
    entry = /* MExpr */Block.__(1, [
        params,
        mexpr_entry_o[0],
        mty_entry_o
      ]);
  } else if (mty_entry_o) {
    entry = /* MType */Block.__(0, [
        params,
        mty_entry_o[0]
      ]);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            667,
            20
          ]
        ];
  }
  var match$9;
  var exit = 0;
  var mte$1;
  if (entry.tag) {
    var match$10 = entry[2];
    if (match$10) {
      mte$1 = match$10[0];
      exit = 1;
    } else {
      var me = entry[1];
      match$9 = /* tuple */[
        get_functor_sobjs(/* true */1, env$4, inl_expr, /* tuple */[
              params,
              me
            ]),
        get_module_path(me)
      ];
    }
  } else {
    mte$1 = entry[1];
    exit = 1;
  }
  if (exit === 1) {
    match$9 = /* tuple */[
      get_functor_sobjs(/* false */0, env$4, inl_res, /* tuple */[
            params,
            mte$1
          ]),
      get_module_path(mte$1)
    ];
  }
  Summary$ReactTemplate.unfreeze_summaries(/* None */0, fs);
  var inl$1 = inl_expr ? inl_res : /* None */0;
  Global$ReactTemplate.push_context_set(/* true */1, cst$4);
  var match$11 = Global$ReactTemplate.add_module(id, entry, inl$1);
  if (!Names$ReactTemplate.ModPath[/* equal */1](mp, mp_of_kn(Lib$ReactTemplate.make_kn(id)))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            688,
            2
          ]
        ];
  }
  if (!Names$ReactTemplate.ModPath[/* equal */1](mp, match$11[0])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            689,
            2
          ]
        ];
  }
  check_subtypes(mp, match$1[1]);
  var sobjs = subst_sobjs(Mod_subst$ReactTemplate.map_mp(match$9[1], mp, match$11[1]), match$9[0]);
  Lib$ReactTemplate.add_leaf(id, Curry._1(in_module, sobjs));
  return mp;
}

function start_modtype(interp_modast, id, args, mtys, fs) {
  var mp = Global$ReactTemplate.start_modtype(id);
  var match = intern_args(interp_modast, args);
  Global$ReactTemplate.push_context_set(/* true */1, match[1]);
  var env = Global$ReactTemplate.env(/* () */0);
  var match$1 = build_subtypes(interp_modast, env, mp, match[0], mtys);
  Global$ReactTemplate.push_context_set(/* true */1, match$1[1]);
  openmodtype_info[0] = match$1[0];
  var prefix = Lib$ReactTemplate.start_modtype(id, mp, fs);
  Nametab$ReactTemplate.push_dir(/* Until */Block.__(0, [1]), prefix[/* obj_dir */0], /* DirOpenModtype */Block.__(1, [prefix]));
  return mp;
}

function end_modtype() {
  var match = Lib$ReactTemplate.end_modtype(/* () */0);
  var oldoname = match[0];
  var id = Libnames$ReactTemplate.basename(oldoname[0]);
  var match$1 = Lib$ReactTemplate.classify_segment(match[3]);
  var sub_mty_l = openmodtype_info[0];
  var match$2 = Global$ReactTemplate.end_modtype(match[2], id);
  var mp = match$2[0];
  var modtypeobjs_000 = match$2[1];
  var modtypeobjs_001 = /* Objs */Block.__(0, [match$1[0]]);
  var modtypeobjs = /* tuple */[
    modtypeobjs_000,
    modtypeobjs_001
  ];
  check_subtypes_mt(mp, sub_mty_l);
  var oname = Lib$ReactTemplate.add_leaves(id, Util$ReactTemplate.$at(match$1[2], /* :: */[
            Curry._1(in_modtype, modtypeobjs),
            /* [] */0
          ]));
  if (!Libnames$ReactTemplate.eq_full_path(oname[0], oldoname[0])) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            726,
            2
          ]
        ];
  }
  if (!Names$ReactTemplate.ModPath[/* equal */1](mp_of_kn(oname[1]), mp)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "declaremods.ml",
            727,
            2
          ]
        ];
  }
  return mp;
}

function include_subst(env, mp, reso, mbids, sign, inline) {
  if (mbids) {
    var match = Modops$ReactTemplate.destr_functor(sign);
    var subst = include_subst(env, mp, reso, mbids[1], match[2], inline);
    var mp_delta = Modops$ReactTemplate.inline_delta_resolver(env, inline, mp, match[0], match[1], reso);
    return Mod_subst$ReactTemplate.join(Mod_subst$ReactTemplate.map_mbid(mbids[0], mp, mp_delta), subst);
  } else {
    return Mod_subst$ReactTemplate.empty_subst;
  }
}

var NoIncludeSelf = Caml_exceptions.create("Declaremods-ReactTemplate.RawIncludeOps.NoIncludeSelf");

function type_of_incl(env, is_mod, me) {
  switch (me.tag | 0) {
    case 0 : 
        return type_of_mod(me[0], env, is_mod);
    case 1 : 
        var match = get_applications(me);
        var _mpl = match[1];
        var _typ = type_of_mod(match[0], env, is_mod);
        while(true) {
          var typ = _typ;
          var mpl = _mpl;
          if (mpl) {
            if (typ.tag) {
              _typ = typ[2];
              _mpl = mpl[1];
              continue ;
              
            } else {
              return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Application of a functor with too much arguments."));
            }
          } else {
            return typ;
          }
        };
    case 2 : 
        throw NoIncludeSelf;
    
  }
}

function declare_include(interp, me_asts) {
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                var interp_modast = interp;
                var param$1 = param;
                var env = Global$ReactTemplate.env(/* () */0);
                var match = Curry._3(interp_modast, env, /* ModAny */2, param$1[0]);
                var me = match[0];
                Global$ReactTemplate.push_context_set(/* true */1, match[2]);
                var env$1 = Global$ReactTemplate.env(/* () */0);
                var is_mod = +(match[1] === /* Module */0);
                var cur_mp = Lib$ReactTemplate.current_mp(/* () */0);
                var inl = inl2intopt(param$1[1]);
                var match$1 = get_module_sobjs(is_mod, env$1, inl, me);
                var mbids = match$1[0];
                var subst_self;
                try {
                  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], mbids)) {
                    throw NoIncludeSelf;
                  }
                  var typ = type_of_incl(env$1, is_mod, me);
                  var match$2 = Safe_typing$ReactTemplate.delta_of_senv(Global$ReactTemplate.safe_env(/* () */0));
                  subst_self = include_subst(env$1, cur_mp, match$2[0], mbids, typ, inl);
                }
                catch (exn){
                  if (exn === NoIncludeSelf) {
                    subst_self = Mod_subst$ReactTemplate.empty_subst;
                  } else {
                    throw exn;
                  }
                }
                var base_mp = get_module_path(me);
                var resolver = Global$ReactTemplate.add_include(me, is_mod, inl);
                var subst = Mod_subst$ReactTemplate.join(subst_self, Mod_subst$ReactTemplate.map_mp(base_mp, cur_mp, resolver));
                var aobjs = subst_aobjs(subst, match$1[1]);
                Lib$ReactTemplate.add_leaf(Lib$ReactTemplate.current_mod_id(/* () */0), Curry._1(in_include, aobjs));
                return /* () */0;
              }), me_asts);
}

function protect_summaries(f) {
  var fs = Summary$ReactTemplate.freeze_summaries(/* No */17505);
  try {
    return Curry._1(f, fs);
  }
  catch (raw_reraise){
    var reraise = Js_exn.internalToOCamlException(raw_reraise);
    var reraise$1 = CErrors$ReactTemplate.push(reraise);
    Summary$ReactTemplate.unfreeze_summaries(/* None */0, fs);
    return Util$ReactTemplate.iraise(reraise$1);
  }
}

function start_module$1(interp, $$export, id, args, res) {
  return protect_summaries((function (param) {
                return start_module(interp, $$export, id, args, res, param);
              }));
}

function declare_module$1(interp, id, args, mtys, me_l) {
  return protect_summaries((function (fs) {
                if (me_l) {
                  if (me_l[1]) {
                    start_module(interp, /* None */0, id, args, mtys, fs);
                    declare_include(interp, me_l);
                    return end_module(/* () */0);
                  } else {
                    return declare_module(interp, id, args, mtys, /* Some */[me_l[0]], fs);
                  }
                } else {
                  return declare_module(interp, id, args, mtys, /* None */0, fs);
                }
              }));
}

function start_modtype$1(interp, id, args, mtys) {
  return protect_summaries((function (param) {
                return start_modtype(interp, id, args, mtys, param);
              }));
}

function declare_modtype(interp, id, args, mtys, mty_l) {
  return protect_summaries((function (fs) {
                if (mty_l) {
                  if (mty_l[1]) {
                    start_modtype(interp, id, args, mtys, fs);
                    declare_include(interp, mty_l);
                    return end_modtype(/* () */0);
                  } else {
                    var interp_modast = interp;
                    var id$1 = id;
                    var args$1 = args;
                    var mtys$1 = mtys;
                    var param = mty_l[0];
                    var fs$1 = fs;
                    var inl = inl2intopt(param[1]);
                    var mp = Global$ReactTemplate.start_modtype(id$1);
                    var match = intern_args(interp_modast, args$1);
                    var arg_entries_r = match[0];
                    Global$ReactTemplate.push_context_set(/* true */1, match[1]);
                    var params = mk_params_entry(arg_entries_r);
                    var env = Global$ReactTemplate.env(/* () */0);
                    var match$1 = Curry._3(interp_modast, env, /* ModType */1, param[0]);
                    var mte = match$1[0];
                    Global$ReactTemplate.push_context_set(/* true */1, match$1[2]);
                    var env$1 = Global$ReactTemplate.env(/* () */0);
                    var match$2 = Mod_typing$ReactTemplate.translate_mse(env$1, /* None */0, inl, mte);
                    Global$ReactTemplate.push_context_set(/* true */1, match$2[3]);
                    var env$2 = Global$ReactTemplate.env(/* () */0);
                    var entry = /* tuple */[
                      params,
                      mte
                    ];
                    var match$3 = build_subtypes(interp_modast, env$2, mp, arg_entries_r, mtys$1);
                    Global$ReactTemplate.push_context_set(/* true */1, match$3[1]);
                    var env$3 = Global$ReactTemplate.env(/* () */0);
                    var sobjs = get_functor_sobjs(/* false */0, env$3, inl, entry);
                    var subst = Mod_subst$ReactTemplate.map_mp(get_module_path(mte), mp, Mod_subst$ReactTemplate.empty_delta_resolver);
                    var sobjs$1 = subst_sobjs(subst, sobjs);
                    Summary$ReactTemplate.unfreeze_summaries(/* None */0, fs$1);
                    var mp_env = Global$ReactTemplate.add_modtype(id$1, entry, inl);
                    if (!Names$ReactTemplate.ModPath[/* equal */1](mp_env, mp)) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "declaremods.ml",
                              763,
                              2
                            ]
                          ];
                    }
                    check_subtypes_mt(mp, match$3[0]);
                    Lib$ReactTemplate.add_leaf(id$1, Curry._1(in_modtype, sobjs$1));
                    return mp;
                  }
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "declaremods.ml",
                          865,
                          12
                        ]
                      ];
                }
              }));
}

function declare_include$1(interp, me_asts) {
  return protect_summaries((function () {
                return declare_include(interp, me_asts);
              }));
}

function iter_all_segments(f) {
  var apply_obj = function (prefix, param) {
    var obj = param[1];
    var match = Libobject$ReactTemplate.object_tag(obj);
    if (match === "INCLUDE") {
      var objs = expand_aobjs(Curry._1(out_include, obj));
      return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                    return apply_obj(prefix, param);
                  }), objs);
    } else {
      return Curry._2(f, Libnames$ReactTemplate.make_oname(prefix, param[0]), obj);
    }
  };
  var apply_mod_obj = function (_, param) {
    var prefix = param[0];
    Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
            return apply_obj(prefix, param);
          }), param[1]);
    return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                  return apply_obj(prefix, param);
                }), param[2]);
  };
  var apply_node = function (param) {
    var match = param[1];
    if (match.tag) {
      return /* () */0;
    } else {
      return Curry._2(f, param[0], match[0]);
    }
  };
  Curry._2(Names$ReactTemplate.MPmap[/* iter */9], apply_mod_obj, table$1[0]);
  return Curry._2(Util$ReactTemplate.List[/* iter */9], apply_node, Lib$ReactTemplate.contents(/* () */0));
}

function debug_print_modtab() {
  var pr_seg = function (l) {
    if (l) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("[."), Pp$ReactTemplate.$$int(Curry._1(Util$ReactTemplate.List[/* length */0], l))), Pp$ReactTemplate.str(".]"));
    } else {
      return Pp$ReactTemplate.str("[]");
    }
  };
  var pr_modinfo = function (mp, param, s) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(s, Pp$ReactTemplate.str(Names$ReactTemplate.ModPath[/* to_string */4](mp))), Pp$ReactTemplate.spc(/* () */0)), pr_seg(Curry._1(Lib$ReactTemplate.segment_of_objects(param[0]), Util$ReactTemplate.$at(param[1], param[2]))));
  };
  var modules = Curry._3(Names$ReactTemplate.MPmap[/* fold */10], pr_modinfo, table$1[0], Pp$ReactTemplate.mt(/* () */0));
  return Pp$ReactTemplate.hov(0, modules);
}

exports.declare_module = declare_module$1;
exports.start_module = start_module$1;
exports.end_module = end_module;
exports.declare_modtype = declare_modtype;
exports.start_modtype = start_modtype$1;
exports.end_modtype = end_modtype;
exports.declare_include = declare_include$1;
exports.iter_all_segments = iter_all_segments;
exports.debug_print_modtab = debug_print_modtab;
exports.process_module_binding = process_module_binding;
/* table Not a pure module */
