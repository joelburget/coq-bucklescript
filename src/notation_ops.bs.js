// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var CAst$ReactTemplate = require("./cAst.bs.js");
var DAst$ReactTemplate = require("./dAst.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Miscops$ReactTemplate = require("./miscops.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Detyping$ReactTemplate = require("./detyping.bs.js");
var Glob_ops$ReactTemplate = require("./glob_ops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Genintern$ReactTemplate = require("./genintern.bs.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Inductiveops$ReactTemplate = require("./inductiveops.bs.js");

function get_var_ndx(id, vs) {
  try {
    return /* Some */[Curry._3(Util$ReactTemplate.List[/* index */77], Names$ReactTemplate.Id[/* equal */0], id, vs)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function eq_notation_constr(vars, _t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    switch (t1.tag | 0) {
      case 0 : 
          if (t2.tag) {
            return /* false */0;
          } else {
            return Globnames$ReactTemplate.eq_gr(t1[0], t2[0]);
          }
          break;
      case 1 : 
          var id1 = t1[0];
          if (t2.tag === 1) {
            var id2 = t2[0];
            var match = get_var_ndx(id1, vars[0]);
            var match$1 = get_var_ndx(id2, vars[1]);
            if (match) {
              if (match$1) {
                return +(match[0] === match$1[0]);
              } else {
                return /* false */0;
              }
            } else if (match$1) {
              return /* false */0;
            } else {
              return Names$ReactTemplate.Id[/* equal */0](id1, id2);
            }
          } else {
            return /* false */0;
          }
          break;
      case 2 : 
          if (t2.tag === 2 && eq_notation_constr(vars, t1[0], t2[0])) {
            return Curry._3(Util$ReactTemplate.List[/* equal */44], (function (param, param$1) {
                          return eq_notation_constr(vars, param, param$1);
                        }), t1[1], t2[1]);
          } else {
            return /* false */0;
          }
          break;
      case 3 : 
          if (t2.tag === 3) {
            return /* true */1;
          } else {
            return /* false */0;
          }
          break;
      case 4 : 
          if (t2.tag === 4 && Names$ReactTemplate.Id[/* equal */0](t1[0], t2[0]) && Names$ReactTemplate.Id[/* equal */0](t1[1], t2[1]) && eq_notation_constr(vars, t1[2], t2[2]) && eq_notation_constr(vars, t1[3], t2[3])) {
            return +(t1[4] === t2[4]);
          } else {
            return /* false */0;
          }
          break;
      case 5 : 
          if (t2.tag === 5) {
            if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], t1[0], t2[0])) {
              if (eq_notation_constr(vars, t1[1], t2[1])) {
                _t2 = t2[2];
                _t1 = t1[2];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 6 : 
          if (t2.tag === 6) {
            if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], t1[0], t2[0])) {
              if (eq_notation_constr(vars, t1[1], t2[1])) {
                _t2 = t2[2];
                _t1 = t1[2];
                continue ;
                
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 7 : 
          if (t2.tag === 7 && Names$ReactTemplate.Id[/* equal */0](t1[0], t2[0]) && Names$ReactTemplate.Id[/* equal */0](t1[1], t2[1]) && eq_notation_constr(vars, t1[2], t2[2]) && eq_notation_constr(vars, t1[3], t2[3])) {
            return +(t1[4] === t2[4]);
          } else {
            return /* false */0;
          }
          break;
      case 8 : 
          if (t2.tag === 8) {
            if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], t1[0], t2[0])) {
              if (eq_notation_constr(vars, t1[1], t2[1])) {
                if (Option$ReactTemplate.equal((function (param, param$1) {
                          return eq_notation_constr(vars, param, param$1);
                        }), t1[2], t2[2])) {
                  _t2 = t2[3];
                  _t1 = t1[3];
                  continue ;
                  
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 9 : 
          if (t2.tag === 9) {
            var eqpat = function (param, param$1) {
              if (Curry._3(Util$ReactTemplate.List[/* equal */44], Glob_ops$ReactTemplate.cases_pattern_eq, param[0], param$1[0])) {
                return eq_notation_constr(vars, param[1], param$1[1]);
              } else {
                return /* false */0;
              }
            };
            var eqf = function (param, param$1) {
              var match = param$1[1];
              var match$1 = param[1];
              var eq = function (param, param$1) {
                if (Names$ReactTemplate.eq_ind(param[0], param$1[0])) {
                  return Curry._3(Util$ReactTemplate.List[/* equal */44], Nameops$ReactTemplate.Name[/* equal */4], param[1], param$1[1]);
                } else {
                  return /* false */0;
                }
              };
              if (eq_notation_constr(vars, param[0], param$1[0]) && Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match$1[0], match[0])) {
                return Option$ReactTemplate.equal(eq, match$1[1], match[1]);
              } else {
                return /* false */0;
              }
            };
            if (Option$ReactTemplate.equal((function (param, param$1) {
                      return eq_notation_constr(vars, param, param$1);
                    }), t1[1], t2[1]) && Curry._3(Util$ReactTemplate.List[/* equal */44], eqf, t1[2], t2[2])) {
              return Curry._3(Util$ReactTemplate.List[/* equal */44], eqpat, t1[3], t2[3]);
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 10 : 
          var match$2 = t1[1];
          if (t2.tag === 10) {
            var match$3 = t2[1];
            if (Curry._3(Util$ReactTemplate.List[/* equal */44], Nameops$ReactTemplate.Name[/* equal */4], t1[0], t2[0])) {
              if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match$2[0], match$3[0])) {
                if (Option$ReactTemplate.equal((function (param, param$1) {
                          return eq_notation_constr(vars, param, param$1);
                        }), match$2[1], match$3[1])) {
                  if (eq_notation_constr(vars, t1[2], t2[2])) {
                    _t2 = t2[3];
                    _t1 = t1[3];
                    continue ;
                    
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 11 : 
          var match$4 = t1[1];
          if (t2.tag === 11) {
            var match$5 = t2[1];
            if (eq_notation_constr(vars, t1[0], t2[0])) {
              if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match$4[0], match$5[0])) {
                if (Option$ReactTemplate.equal((function (param, param$1) {
                          return eq_notation_constr(vars, param, param$1);
                        }), match$4[1], match$5[1])) {
                  if (eq_notation_constr(vars, t1[2], t2[2])) {
                    _t2 = t2[3];
                    _t1 = t1[3];
                    continue ;
                    
                  } else {
                    return /* false */0;
                  }
                } else {
                  return /* false */0;
                }
              } else {
                return /* false */0;
              }
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 12 : 
          if (t2.tag === 12) {
            var eq = function (param, param$1) {
              if (Curry._2(Nameops$ReactTemplate.Name[/* equal */4], param[0], param$1[0]) && Option$ReactTemplate.equal((function (param, param$1) {
                        return eq_notation_constr(vars, param, param$1);
                      }), param[1], param$1[1])) {
                return eq_notation_constr(vars, param[2], param$1[2]);
              } else {
                return /* false */0;
              }
            };
            if (Util$ReactTemplate.$$Array[/* equal */21](Names$ReactTemplate.Id[/* equal */0], t1[1], t2[1]) && Util$ReactTemplate.$$Array[/* equal */21](Curry._1(Util$ReactTemplate.List[/* equal */44], eq), t1[2], t2[2]) && Util$ReactTemplate.$$Array[/* equal */21]((function (param, param$1) {
                      return eq_notation_constr(vars, param, param$1);
                    }), t1[3], t2[3])) {
              return Util$ReactTemplate.$$Array[/* equal */21]((function (param, param$1) {
                            return eq_notation_constr(vars, param, param$1);
                          }), t1[4], t2[4]);
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      case 13 : 
          if (t2.tag === 13) {
            return Miscops$ReactTemplate.glob_sort_eq(t1[0], t2[0]);
          } else {
            return /* false */0;
          }
          break;
      case 14 : 
          if (t2.tag === 14 && eq_notation_constr(vars, t1[0], t2[0])) {
            return Glob_ops$ReactTemplate.cast_type_eq((function (param, param$1) {
                          return eq_notation_constr(vars, param, param$1);
                        }), t1[1], t2[1]);
          } else {
            return /* false */0;
          }
          break;
      case 15 : 
          if (t2.tag === 15) {
            if (Names$ReactTemplate.Projection[/* equal */5](t1[0], t2[0])) {
              _t2 = t2[1];
              _t1 = t1[1];
              continue ;
              
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
          break;
      
    }
  };
}

function name_to_ident(param) {
  if (param) {
    return param[0];
  } else {
    return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("This expression should be a simple identifier."));
  }
}

function product_of_cases_patterns(patl) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (patl, restl) {
                return Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (p) {
                                  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (rest) {
                                                return /* :: */[
                                                        p,
                                                        rest
                                                      ];
                                              }), restl);
                                }), patl));
              }), patl, /* :: */[
              /* [] */0,
              /* [] */0
            ]);
}

function cases_pattern_fold_map(loc, g, e) {
  return (function (param) {
      return DAst$ReactTemplate.with_val((function (param) {
                    if (param.tag) {
                      var cstr = param[0];
                      var match = Curry._2(g, e, param[2]);
                      var na$prime = match[2];
                      if (match[1] !== /* None */0) {
                        CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Unable to instantiate an \"as\" clause with a pattern."));
                      }
                      var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_left_map */116], (function (param) {
                              return cases_pattern_fold_map(loc, g, param);
                            }), e, param[1]);
                      var disjpatl$prime = product_of_cases_patterns(match$1[1]);
                      return /* tuple */[
                              match$1[0],
                              Curry._2(Util$ReactTemplate.List[/* map */10], (function (patl$prime) {
                                      return DAst$ReactTemplate.make(loc, /* PatCstr */Block.__(1, [
                                                    cstr,
                                                    patl$prime,
                                                    na$prime
                                                  ]));
                                    }), disjpatl$prime)
                            ];
                    } else {
                      var match$2 = Curry._2(g, e, param[0]);
                      var disjpat = match$2[1];
                      return /* tuple */[
                              match$2[0],
                              disjpat ? disjpat[0][0][1] : /* :: */[
                                  DAst$ReactTemplate.make(loc, /* PatVar */Block.__(0, [match$2[2]])),
                                  /* [] */0
                                ]
                            ];
                    }
                  }), param);
    });
}

function subst_binder_type_vars(l, e) {
  if (typeof e === "number") {
    return e;
  } else if (e.tag === 1) {
    var match = e[0];
    if (match) {
      var id = match[0];
      var id$1;
      try {
        var match$1 = DAst$ReactTemplate.get(Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id, l));
        id$1 = match$1.tag === 1 ? match$1[0] : id;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          id$1 = id;
        } else {
          throw exn;
        }
      }
      return /* BinderType */Block.__(1, [/* Name */[id$1]]);
    } else {
      return e;
    }
  } else {
    return e;
  }
}

function subst_glob_vars(l, gc) {
  return DAst$ReactTemplate.map((function (r) {
                var exit = 0;
                switch (r.tag | 0) {
                  case 1 : 
                      try {
                        return DAst$ReactTemplate.get(Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], r[0], l));
                      }
                      catch (exn){
                        if (exn === Caml_builtin_exceptions.not_found) {
                          return r;
                        } else {
                          throw exn;
                        }
                      }
                      break;
                  case 5 : 
                      var match = r[0];
                      if (match) {
                        var id = match[0];
                        var id$1;
                        try {
                          var match$1 = DAst$ReactTemplate.get(Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id, l));
                          id$1 = match$1.tag === 1 ? match$1[0] : id;
                        }
                        catch (exn$1){
                          if (exn$1 === Caml_builtin_exceptions.not_found) {
                            id$1 = id;
                          } else {
                            throw exn$1;
                          }
                        }
                        return /* GLambda */Block.__(5, [
                                  /* Name */[id$1],
                                  r[1],
                                  subst_glob_vars(l, r[2]),
                                  subst_glob_vars(l, r[3])
                                ]);
                      } else {
                        exit = 1;
                      }
                      break;
                  case 6 : 
                      var match$2 = r[0];
                      if (match$2) {
                        var id$2 = match$2[0];
                        var id$3;
                        try {
                          var match$3 = DAst$ReactTemplate.get(Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id$2, l));
                          id$3 = match$3.tag === 1 ? match$3[0] : id$2;
                        }
                        catch (exn$2){
                          if (exn$2 === Caml_builtin_exceptions.not_found) {
                            id$3 = id$2;
                          } else {
                            throw exn$2;
                          }
                        }
                        return /* GProd */Block.__(6, [
                                  /* Name */[id$3],
                                  r[1],
                                  subst_glob_vars(l, r[2]),
                                  subst_glob_vars(l, r[3])
                                ]);
                      } else {
                        exit = 1;
                      }
                      break;
                  case 13 : 
                      return /* GHole */Block.__(13, [
                                subst_binder_type_vars(l, r[0]),
                                r[1],
                                r[2]
                              ]);
                  default:
                    exit = 1;
                }
                if (exit === 1) {
                  return DAst$ReactTemplate.get(Glob_ops$ReactTemplate.map_glob_constr((function (param) {
                                      return subst_glob_vars(l, param);
                                    }))(gc));
                }
                
              }), gc);
}

var ldots_var = Names$ReactTemplate.Id[/* of_string */5]("..");

function protect(g, e, na) {
  var match = Curry._2(g, e, na);
  if (match[1] !== /* None */0) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Unsupported substitution of an arbitrary pattern."));
  }
  return /* tuple */[
          match[0],
          match[2]
        ];
}

function apply_cases_pattern(loc, param, c) {
  var match = param[0];
  var ids = match[0];
  var tm = DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [param[1]]));
  var eqns = Curry._2(Util$ReactTemplate.List[/* map */10], (function (pat) {
          return CAst$ReactTemplate.make(loc, /* tuple */[
                      ids,
                      /* :: */[
                        pat,
                        /* [] */0
                      ],
                      c
                    ]);
        }), match[1]);
  return DAst$ReactTemplate.make(loc, /* GCases */Block.__(8, [
                /* LetPatternStyle */2,
                /* None */0,
                /* :: */[
                  /* tuple */[
                    tm,
                    /* tuple */[
                      /* Anonymous */0,
                      /* None */0
                    ]
                  ],
                  /* [] */0
                ],
                eqns
              ]));
}

function glob_constr_of_notation_constr_with_binders(loc, g, f, e, nc) {
  var x;
  switch (nc.tag | 0) {
    case 0 : 
        x = /* GRef */Block.__(0, [
            nc[0],
            /* None */0
          ]);
        break;
    case 1 : 
        x = /* GVar */Block.__(1, [nc[0]]);
        break;
    case 2 : 
        x = /* GApp */Block.__(4, [
            Curry._2(f, e, nc[0]),
            Curry._2(Util$ReactTemplate.List[/* map */10], Curry._1(f, e), nc[1])
          ]);
        break;
    case 3 : 
        x = /* GHole */Block.__(13, [
            nc[0],
            nc[1],
            nc[2]
          ]);
        break;
    case 4 : 
        var swap = nc[4];
        var y = nc[1];
        var x$1 = nc[0];
        var t = Curry._2(f, e, nc[3]);
        var it = Curry._2(f, e, nc[2]);
        var innerl_000 = /* tuple */[
          ldots_var,
          t
        ];
        var innerl_001 = swap ? /* [] */0 : /* :: */[
            /* tuple */[
              x$1,
              DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [y]))
            ],
            /* [] */0
          ];
        var innerl = /* :: */[
          innerl_000,
          innerl_001
        ];
        var x_000 = DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [ldots_var]));
        var x_001 = /* :: */[
          subst_glob_vars(innerl, it),
          /* [] */0
        ];
        var x$2 = /* GApp */Block.__(4, [
            x_000,
            x_001
          ]);
        var inner = DAst$ReactTemplate.make(loc, x$2);
        var outerl_000 = /* tuple */[
          ldots_var,
          inner
        ];
        var outerl_001 = swap ? /* :: */[
            /* tuple */[
              x$1,
              DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [y]))
            ],
            /* [] */0
          ] : /* [] */0;
        var outerl = /* :: */[
          outerl_000,
          outerl_001
        ];
        x = DAst$ReactTemplate.get(subst_glob_vars(outerl, it));
        break;
    case 5 : 
        var match = Curry._2(g, e, nc[0]);
        x = /* GLambda */Block.__(5, [
            match[2],
            /* Explicit */0,
            Curry._2(f, e, nc[1]),
            Option$ReactTemplate.fold_right((function (param, param$1) {
                    return apply_cases_pattern(loc, param, param$1);
                  }), match[1], Curry._2(f, match[0], nc[2]))
          ]);
        break;
    case 6 : 
        var match$1 = Curry._2(g, e, nc[0]);
        x = /* GProd */Block.__(6, [
            match$1[2],
            /* Explicit */0,
            Curry._2(f, e, nc[1]),
            Option$ReactTemplate.fold_right((function (param, param$1) {
                    return apply_cases_pattern(loc, param, param$1);
                  }), match$1[1], Curry._2(f, match$1[0], nc[2]))
          ]);
        break;
    case 7 : 
        var swap$1 = nc[4];
        var y$1 = nc[1];
        var x$3 = nc[0];
        var t$1 = Curry._2(f, e, nc[3]);
        var it$1 = Curry._2(f, e, nc[2]);
        var innerl_000$1 = /* tuple */[
          ldots_var,
          t$1
        ];
        var innerl_001$1 = swap$1 ? /* [] */0 : /* :: */[
            /* tuple */[
              x$3,
              DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [y$1]))
            ],
            /* [] */0
          ];
        var innerl$1 = /* :: */[
          innerl_000$1,
          innerl_001$1
        ];
        var x_000$1 = DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [ldots_var]));
        var x_001$1 = /* :: */[
          subst_glob_vars(innerl$1, it$1),
          /* [] */0
        ];
        var x$4 = /* GApp */Block.__(4, [
            x_000$1,
            x_001$1
          ]);
        var inner$1 = DAst$ReactTemplate.make(loc, x$4);
        var outerl_000$1 = /* tuple */[
          ldots_var,
          inner$1
        ];
        var outerl_001$1 = swap$1 ? /* :: */[
            /* tuple */[
              x$3,
              DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [y$1]))
            ],
            /* [] */0
          ] : /* [] */0;
        var outerl$1 = /* :: */[
          outerl_000$1,
          outerl_001$1
        ];
        x = DAst$ReactTemplate.get(subst_glob_vars(outerl$1, it$1));
        break;
    case 8 : 
        var c = nc[3];
        var match$2 = Curry._2(g, e, nc[0]);
        var disjpat = match$2[1];
        var e$prime = match$2[0];
        x = disjpat ? DAst$ReactTemplate.get(apply_cases_pattern(loc, disjpat[0], Curry._2(f, e$prime, c))) : /* GLetIn */Block.__(7, [
              match$2[2],
              Curry._2(f, e, nc[1]),
              Option$ReactTemplate.map(Curry._1(f, e), nc[2]),
              Curry._2(f, e$prime, c)
            ]);
        break;
    case 9 : 
        var match$3 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                var e$prime = param$1[0];
                var match = param[1];
                var t = match[1];
                var match$1;
                if (t) {
                  var match$2 = t[0];
                  var match$3 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (na, param) {
                          var match = protect(g, param[0], na);
                          return /* tuple */[
                                  match[0],
                                  /* :: */[
                                    match[1],
                                    param[1]
                                  ]
                                ];
                        }), match$2[1], /* tuple */[
                        e$prime,
                        /* [] */0
                      ]);
                  match$1 = /* tuple */[
                    match$3[0],
                    /* Some */[CAst$ReactTemplate.make(loc, /* tuple */[
                            match$2[0],
                            match$3[1]
                          ])]
                  ];
                } else {
                  match$1 = /* tuple */[
                    e$prime,
                    /* None */0
                  ];
                }
                var match$4 = protect(g, match$1[0], match[0]);
                return /* tuple */[
                        match$4[0],
                        /* :: */[
                          /* tuple */[
                            Curry._2(f, e, param[0]),
                            /* tuple */[
                              match$4[1],
                              match$1[1]
                            ]
                          ],
                          param$1[1]
                        ]
                      ];
              }), nc[2], /* tuple */[
              e,
              /* [] */0
            ]);
        var fold = function (param, na) {
          var match = Curry._2(g, param[1], na);
          var na$1 = match[2];
          return /* tuple */[
                  /* tuple */[
                    Nameops$ReactTemplate.Name[/* cons */17](na$1, param[0]),
                    match[0]
                  ],
                  match[1],
                  na$1
                ];
        };
        var eqnl$prime = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                var rhs = param[1];
                var match = Curry._3(Util$ReactTemplate.List[/* fold_left_map */116], (function (param) {
                        return cases_pattern_fold_map(loc, fold, param);
                      }), /* tuple */[
                      /* [] */0,
                      e
                    ], param[0]);
                var match$1 = match[0];
                var e$1 = match$1[1];
                var idl = match$1[0];
                var disjpatl = product_of_cases_patterns(match[1]);
                return Curry._2(Util$ReactTemplate.List[/* map */10], (function (patl) {
                              return CAst$ReactTemplate.make(/* None */0, /* tuple */[
                                          idl,
                                          patl,
                                          Curry._2(f, e$1, rhs)
                                        ]);
                            }), disjpatl);
              }), nc[3]);
        x = /* GCases */Block.__(8, [
            nc[0],
            Option$ReactTemplate.map(Curry._1(f, match$3[0]), nc[1]),
            match$3[1],
            Curry._1(Util$ReactTemplate.List[/* flatten */8], eqnl$prime)
          ]);
        break;
    case 10 : 
        var match$4 = nc[1];
        var match$5 = Curry._3(Util$ReactTemplate.List[/* fold_left_map */116], (function (param, param$1) {
                return protect(g, param, param$1);
              }), e, nc[0]);
        var match$6 = protect(g, e, match$4[0]);
        x = /* GLetTuple */Block.__(9, [
            match$5[1],
            /* tuple */[
              match$6[1],
              Option$ReactTemplate.map(Curry._1(f, match$6[0]), match$4[1])
            ],
            Curry._2(f, e, nc[2]),
            Curry._2(f, match$5[0], nc[3])
          ]);
        break;
    case 11 : 
        var match$7 = nc[1];
        var match$8 = protect(g, e, match$7[0]);
        x = /* GIf */Block.__(10, [
            Curry._2(f, e, nc[0]),
            /* tuple */[
              match$8[1],
              Option$ReactTemplate.map(Curry._1(f, match$8[0]), match$7[1])
            ],
            Curry._2(f, e, nc[2]),
            Curry._2(f, e, nc[3])
          ]);
        break;
    case 12 : 
        var match$9 = Util$ReactTemplate.$$Array[/* fold_left_map */54](Curry._1(Util$ReactTemplate.List[/* fold_map */122], (function (e, param) {
                    var match = protect(g, e, param[0]);
                    var e$1 = match[0];
                    return /* tuple */[
                            e$1,
                            /* tuple */[
                              match[1],
                              /* Explicit */0,
                              Option$ReactTemplate.map(Curry._1(f, e$1), param[1]),
                              Curry._2(f, e$1, param[2])
                            ]
                          ];
                  })), e, nc[2]);
        var e$1 = match$9[0];
        var match$10 = Util$ReactTemplate.$$Array[/* fold_left_map */54]((function (param, param$1) {
                var g$1 = function (param, param$1) {
                  return protect(g, param, param$1);
                };
                var e = param;
                var id = param$1;
                var match = Curry._2(g$1, e, /* Name */[id]);
                return /* tuple */[
                        match[0],
                        name_to_ident(match[1])
                      ];
              }), e$1, nc[1]);
        x = /* GRec */Block.__(11, [
            nc[0],
            match$10[1],
            match$9[1],
            Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, e$1), nc[3]),
            Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, match$10[0]), nc[4])
          ]);
        break;
    case 13 : 
        x = /* GSort */Block.__(12, [nc[0]]);
        break;
    case 14 : 
        x = /* GCast */Block.__(14, [
            Curry._2(f, e, nc[0]),
            Miscops$ReactTemplate.map_cast_type(Curry._1(f, e), nc[1])
          ]);
        break;
    case 15 : 
        x = /* GProj */Block.__(15, [
            nc[0],
            Curry._2(f, e, nc[1])
          ]);
        break;
    
  }
  return DAst$ReactTemplate.make(loc, x);
}

function glob_constr_of_notation_constr(loc, x) {
  var aux = function (_, x) {
    return glob_constr_of_notation_constr_with_binders(loc, (function (_, id) {
                  return /* tuple */[
                          /* () */0,
                          /* None */0,
                          id
                        ];
                }), aux, /* () */0, x);
  };
  return aux(/* () */0, x);
}

function add_id(r, id) {
  var init = r[0];
  r[0] = /* record */[
    /* vars : :: */[
      id,
      r[0][/* vars */0]
    ],
    /* recursive_term_vars */init[/* recursive_term_vars */1],
    /* recursive_binders_vars */init[/* recursive_binders_vars */2]
  ];
  return /* () */0;
}

function add_name(r, param) {
  if (param) {
    return add_id(r, param[0]);
  } else {
    return /* () */0;
  }
}

function is_gvar(id, c) {
  var match = DAst$ReactTemplate.get(c);
  if (match.tag === 1) {
    return Names$ReactTemplate.Id[/* equal */0](id, match[0]);
  } else {
    return /* false */0;
  }
}

function split_at_recursive_part(c) {
  var sub = [/* None */0];
  var aux = function (c) {
    var loc0 = c[/* loc */1];
    var match = DAst$ReactTemplate.get(c);
    if (match.tag === 4) {
      var match$1 = match[1];
      if (match$1) {
        var l = match$1[1];
        var f = match[0];
        if (is_gvar(ldots_var, f)) {
          var loc = f[/* loc */1];
          var match$2 = sub[0];
          if (match$2) {
            throw Caml_builtin_exceptions.not_found;
          } else {
            sub[0] = /* Some */[match$1[0]];
            if (l) {
              return DAst$ReactTemplate.make(loc0, /* GApp */Block.__(4, [
                            DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [ldots_var])),
                            l
                          ]));
            } else {
              return DAst$ReactTemplate.make(loc, /* GVar */Block.__(1, [ldots_var]));
            }
          }
        } else {
          return Glob_ops$ReactTemplate.map_glob_constr(aux)(c);
        }
      } else {
        return Glob_ops$ReactTemplate.map_glob_constr(aux)(c);
      }
    } else {
      return Glob_ops$ReactTemplate.map_glob_constr(aux)(c);
    }
  };
  var outer_iterator = aux(c);
  var match = sub[0];
  if (match) {
    var c$1 = match[0];
    var match$1 = DAst$ReactTemplate.get(outer_iterator);
    if (match$1.tag === 1) {
      if (Names$ReactTemplate.Id[/* equal */0](match$1[0], ldots_var)) {
        throw Caml_builtin_exceptions.not_found;
      } else {
        return /* tuple */[
                outer_iterator,
                c$1
              ];
      }
    } else {
      return /* tuple */[
              outer_iterator,
              c$1
            ];
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function subtract_loc(loc1, loc2) {
  var l1 = Option$ReactTemplate.cata(Loc$ReactTemplate.unloc, /* tuple */[
          0,
          0
        ], loc1)[0];
  var l2 = Option$ReactTemplate.cata(Loc$ReactTemplate.unloc, /* tuple */[
          0,
          0
        ], loc2)[0];
  return /* Some */[Loc$ReactTemplate.make_loc(/* tuple */[
                l1,
                l2 - 1 | 0
              ])];
}

function check_is_hole(id, t) {
  var match = DAst$ReactTemplate.get(t);
  if (match.tag === 13) {
    return /* () */0;
  } else {
    return CErrors$ReactTemplate.user_err(Glob_ops$ReactTemplate.loc_of_glob_constr(t), /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("In recursive notation with binders, "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.strbrk(" is expected to come without type.")));
  }
}

function check_pair_matching(loc, x, y, x$prime, y$prime, revert, revert$prime) {
  if (Names$ReactTemplate.Id[/* equal */0](x, x$prime) && Names$ReactTemplate.Id[/* equal */0](y, y$prime) && revert === revert$prime) {
    return 0;
  } else {
    var match = revert ? /* tuple */[
        y,
        x
      ] : /* tuple */[
        x,
        y
      ];
    var match$1 = revert$prime ? /* tuple */[
        y$prime,
        x$prime
      ] : /* tuple */[
        x$prime,
        y$prime
      ];
    return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Found "), Names$ReactTemplate.Id[/* print */8](match[0])), Pp$ReactTemplate.strbrk(" matching ")), Names$ReactTemplate.Id[/* print */8](match[1])), Pp$ReactTemplate.strbrk(" while ")), Names$ReactTemplate.Id[/* print */8](match$1[0])), Pp$ReactTemplate.strbrk(" matching ")), Names$ReactTemplate.Id[/* print */8](match$1[1])), Pp$ReactTemplate.strbrk(" was first found.")));
  }
}

function pair_equal(eq1, eq2, param, param$1) {
  if (Curry._2(eq1, param[0], param$1[0])) {
    return Curry._2(eq2, param[1], param$1[1]);
  } else {
    return /* false */0;
  }
}

function mem_recursive_pair(param, l) {
  var partial_arg = Names$ReactTemplate.Id[/* equal */0];
  var partial_arg$1 = Names$ReactTemplate.Id[/* equal */0];
  return Curry._3(Util$ReactTemplate.List[/* mem_f */47], (function (param, param$1) {
                return pair_equal(partial_arg$1, partial_arg, param, param$1);
              }), /* tuple */[
              param[0],
              param[1]
            ], l);
}

function notation_constr_and_vars_of_glob_constr(recvars, a) {
  var found = [/* record */[
      /* vars : [] */0,
      /* recursive_term_vars : [] */0,
      /* recursive_binders_vars : [] */0
    ]];
  var has_ltac = [/* false */0];
  var aux = function (c) {
    var keepfound = found[0];
    try {
      var recvars$1 = recvars;
      var found$1 = found;
      var f = aux;
      var f$prime = aux$prime;
      var param = split_at_recursive_part(c);
      var iterator = param[0];
      var diff = [/* None */0];
      var terminator = [/* None */0];
      var aux$1 = function (_c1, _c2) {
        while(true) {
          var c2 = _c2;
          var c1 = _c1;
          var match = DAst$ReactTemplate.get(c1);
          var match$1 = DAst$ReactTemplate.get(c2);
          var exit = 0;
          var x;
          var t_x;
          var c;
          var y;
          var t_y;
          var term;
          switch (match.tag | 0) {
            case 1 : 
                var v = match[0];
                if (Names$ReactTemplate.Id[/* equal */0](v, ldots_var)) {
                  var match$2 = terminator[0];
                  if (!(
                      match$2 ? /* false */0 : /* true */1
                    )) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "notation_ops.ml",
                            306,
                            6
                          ]
                        ];
                  }
                  terminator[0] = /* Some */[c2];
                  return /* true */1;
                } else if (match$1.tag === 1) {
                  var y$1 = match$1[0];
                  if (mem_recursive_pair(/* tuple */[
                          v,
                          y$1
                        ], recvars$1) || mem_recursive_pair(/* tuple */[
                          y$1,
                          v
                        ], recvars$1)) {
                    var revert = mem_recursive_pair(/* tuple */[
                          y$1,
                          v
                        ], recvars$1);
                    var match$3 = revert ? /* tuple */[
                        y$1,
                        v
                      ] : /* tuple */[
                        v,
                        y$1
                      ];
                    var y$2 = match$3[1];
                    var x$1 = match$3[0];
                    var match$4 = diff[0];
                    if (match$4) {
                      var match$5 = match$4[0];
                      check_pair_matching(c1[/* loc */1], x$1, y$2, match$5[0], match$5[1], revert, match$5[2][0]);
                      return /* true */1;
                    } else {
                      diff[0] = /* Some */[/* tuple */[
                          x$1,
                          y$2,
                          /* RecursiveTerms */Block.__(0, [revert])
                        ]];
                      return /* true */1;
                    }
                  } else {
                    return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                  }
                } else {
                  return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                }
                break;
            case 4 : 
                if (match$1.tag === 4) {
                  var match$6 = DAst$ReactTemplate.get(match[0]);
                  if (match$6.tag === 1) {
                    if (Names$ReactTemplate.Id[/* equal */0](match$6[0], ldots_var)) {
                      var match$7 = terminator[0];
                      if (!(
                          match$7 ? /* false */0 : /* true */1
                        )) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "notation_ops.ml",
                                314,
                                6
                              ]
                            ];
                      }
                      terminator[0] = /* Some */[match$1[0]];
                      return Curry._3(Util$ReactTemplate.List[/* for_all2eq */92], aux$1, match[1], match$1[1]);
                    } else {
                      return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                    }
                  } else {
                    return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                  }
                } else {
                  return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                }
                break;
            case 5 : 
                var match$8 = match[0];
                if (match$8) {
                  if (match$1.tag === 5) {
                    var match$9 = match$1[0];
                    if (match$9) {
                      x = match$8[0];
                      t_x = match[2];
                      c = match[3];
                      y = match$9[0];
                      t_y = match$1[2];
                      term = match$1[3];
                      exit = 1;
                    } else {
                      return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                    }
                  } else {
                    return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                  }
                } else {
                  return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                }
                break;
            case 6 : 
                var match$10 = match[0];
                if (match$10) {
                  if (match$1.tag === 6) {
                    var match$11 = match$1[0];
                    if (match$11) {
                      x = match$10[0];
                      t_x = match[2];
                      c = match[3];
                      y = match$11[0];
                      t_y = match$1[2];
                      term = match$1[3];
                      exit = 1;
                    } else {
                      return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                    }
                  } else {
                    return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                  }
                } else {
                  return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
                }
                break;
            default:
              return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
          }
          if (exit === 1) {
            if (mem_recursive_pair(/* tuple */[
                    x,
                    y
                  ], recvars$1) || mem_recursive_pair(/* tuple */[
                    y,
                    x
                  ], recvars$1)) {
              check_is_hole(x, t_x);
              check_is_hole(y, t_y);
              var revert$1 = mem_recursive_pair(/* tuple */[
                    y,
                    x
                  ], recvars$1);
              var match$12 = revert$1 ? /* tuple */[
                  y,
                  x
                ] : /* tuple */[
                  x,
                  y
                ];
              var y$3 = match$12[1];
              var x$2 = match$12[0];
              var match$13 = diff[0];
              if (match$13) {
                var match$14 = match$13[0];
                var match$15 = match$14[2];
                var y$prime = match$14[1];
                var x$prime = match$14[0];
                check_pair_matching(c1[/* loc */1], x$2, y$3, x$prime, y$prime, revert$1, match$15[0]);
                if (match$15.tag) {
                  return /* true */1;
                } else {
                  diff[0] = /* Some */[/* tuple */[
                      x$2,
                      y$3,
                      /* RecursiveBinders */Block.__(1, [revert$1])
                    ]];
                  return /* true */1;
                }
              } else {
                diff[0] = /* Some */[/* tuple */[
                    x$2,
                    y$3,
                    /* RecursiveBinders */Block.__(1, [revert$1])
                  ]];
                _c2 = term;
                _c1 = c;
                continue ;
                
              }
            } else {
              return Glob_ops$ReactTemplate.mk_glob_constr_eq(aux$1, c1, c2);
            }
          }
          
        };
      };
      if (aux$1(iterator, param[1])) {
        var match = diff[0];
        if (match) {
          var match$1 = match[0];
          var match$2 = match$1[2];
          var y = match$1[1];
          var x = match$1[0];
          if (match$2.tag) {
            var revert = match$2[0];
            var tmp;
            if (revert) {
              tmp = iterator;
            } else {
              var eta = /* GVar */Block.__(1, [y]);
              tmp = subst_glob_vars(/* :: */[
                    /* tuple */[
                      x,
                      DAst$ReactTemplate.make(/* None */0, eta)
                    ],
                    /* [] */0
                  ], iterator);
            }
            var iterator$1 = Curry._1(f$prime, tmp);
            var init = found$1[0];
            var partial_arg = Names$ReactTemplate.Id[/* equal */0];
            var partial_arg$1 = Names$ReactTemplate.Id[/* equal */0];
            found$1[0] = /* record */[
              /* vars */Curry._3(Util$ReactTemplate.List[/* remove */88], Names$ReactTemplate.Id[/* equal */0], y, found$1[0][/* vars */0]),
              /* recursive_term_vars */init[/* recursive_term_vars */1],
              /* recursive_binders_vars */Curry._3(Util$ReactTemplate.List[/* add_set */48], (function (param, param$1) {
                      return pair_equal(partial_arg$1, partial_arg, param, param$1);
                    }), /* tuple */[
                    x,
                    y
                  ], found$1[0][/* recursive_binders_vars */2])
            ];
            return /* NBinderList */Block.__(7, [
                      x,
                      y,
                      iterator$1,
                      Curry._1(f, Option$ReactTemplate.get(terminator[0])),
                      revert
                    ]);
          } else {
            var revert$1 = match$2[0];
            var tmp$1;
            if (revert$1) {
              tmp$1 = iterator;
            } else {
              var eta$1 = /* GVar */Block.__(1, [y]);
              tmp$1 = subst_glob_vars(/* :: */[
                    /* tuple */[
                      x,
                      DAst$ReactTemplate.make(/* None */0, eta$1)
                    ],
                    /* [] */0
                  ], iterator);
            }
            var iterator$2 = Curry._1(f$prime, tmp$1);
            var init$1 = found$1[0];
            var partial_arg$2 = Names$ReactTemplate.Id[/* equal */0];
            var partial_arg$3 = Names$ReactTemplate.Id[/* equal */0];
            found$1[0] = /* record */[
              /* vars */Curry._3(Util$ReactTemplate.List[/* remove */88], Names$ReactTemplate.Id[/* equal */0], y, found$1[0][/* vars */0]),
              /* recursive_term_vars */Curry._3(Util$ReactTemplate.List[/* add_set */48], (function (param, param$1) {
                      return pair_equal(partial_arg$3, partial_arg$2, param, param$1);
                    }), /* tuple */[
                    x,
                    y
                  ], found$1[0][/* recursive_term_vars */1]),
              /* recursive_binders_vars */init$1[/* recursive_binders_vars */2]
            ];
            return /* NList */Block.__(4, [
                      x,
                      y,
                      iterator$2,
                      Curry._1(f, Option$ReactTemplate.get(terminator[0])),
                      revert$1
                    ]);
          }
        } else {
          var loc1 = Glob_ops$ReactTemplate.loc_of_glob_constr(iterator);
          var loc2 = Glob_ops$ReactTemplate.loc_of_glob_constr(Option$ReactTemplate.get(terminator[0]));
          return CErrors$ReactTemplate.user_err(subtract_loc(loc1, loc2), /* None */0, Pp$ReactTemplate.str("Both ends of the recursive pattern are the same."));
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        found[0] = keepfound;
        var _c = DAst$ReactTemplate.get(c);
        if (_c.tag === 4) {
          var match$3 = _c[1];
          if (match$3) {
            if (match$3[1]) {
              return aux$prime(c);
            } else {
              var t = _c[0];
              var match$4 = DAst$ReactTemplate.get(t);
              if (match$4.tag === 1) {
                if (Names$ReactTemplate.Id[/* equal */0](match$4[0], ldots_var)) {
                  var loc = t[/* loc */1];
                  return CErrors$ReactTemplate.user_err(loc, /* None */0, Pp$ReactTemplate.str("Cannot find where the recursive pattern starts."));
                } else {
                  return aux$prime(c);
                }
              } else {
                return aux$prime(c);
              }
            }
          } else {
            return aux$prime(c);
          }
        } else {
          return aux$prime(c);
        }
      } else {
        throw exn;
      }
    }
  };
  var aux$prime = function (x) {
    return DAst$ReactTemplate.with_val((function (param) {
                  switch (param.tag | 0) {
                    case 0 : 
                        return /* NRef */Block.__(0, [param[0]]);
                    case 1 : 
                        var id = param[0];
                        if (!Names$ReactTemplate.Id[/* equal */0](id, ldots_var)) {
                          add_id(found, id);
                        }
                        return /* NVar */Block.__(1, [id]);
                    case 2 : 
                    case 3 : 
                        return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Existential variables not allowed in notations."));
                    case 4 : 
                        return /* NApp */Block.__(2, [
                                  aux(param[0]),
                                  Curry._2(Util$ReactTemplate.List[/* map */10], aux, param[1])
                                ]);
                    case 5 : 
                        var na = param[0];
                        add_name(found, na);
                        return /* NLambda */Block.__(5, [
                                  na,
                                  aux(param[2]),
                                  aux(param[3])
                                ]);
                    case 6 : 
                        var na$1 = param[0];
                        add_name(found, na$1);
                        return /* NProd */Block.__(6, [
                                  na$1,
                                  aux(param[2]),
                                  aux(param[3])
                                ]);
                    case 7 : 
                        var na$2 = param[0];
                        add_name(found, na$2);
                        return /* NLetIn */Block.__(8, [
                                  na$2,
                                  aux(param[1]),
                                  Option$ReactTemplate.map(aux, param[2]),
                                  aux(param[3])
                                ]);
                    case 8 : 
                        var f = function (param) {
                          var match = param[/* v */0];
                          Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                                  return add_id(found, param);
                                }), match[0]);
                          return /* tuple */[
                                  match[1],
                                  aux(match[2])
                                ];
                        };
                        return /* NCases */Block.__(9, [
                                  param[0],
                                  Option$ReactTemplate.map(aux, param[1]),
                                  Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                          var match = param[1];
                                          var x = match[1];
                                          var na = match[0];
                                          add_name(found, na);
                                          Option$ReactTemplate.iter((function (param) {
                                                  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                                                                return add_name(found, param);
                                                              }), param[/* v */0][1]);
                                                }), x);
                                          return /* tuple */[
                                                  aux(param[0]),
                                                  /* tuple */[
                                                    na,
                                                    Option$ReactTemplate.map((function (param) {
                                                            var match = param[/* v */0];
                                                            return /* tuple */[
                                                                    match[0],
                                                                    match[1]
                                                                  ];
                                                          }), x)
                                                  ]
                                                ];
                                        }), param[2]),
                                  Curry._2(Util$ReactTemplate.List[/* map */10], f, param[3])
                                ]);
                    case 9 : 
                        var match = param[1];
                        var na$3 = match[0];
                        var nal = param[0];
                        add_name(found, na$3);
                        Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                                return add_name(found, param);
                              }), nal);
                        return /* NLetTuple */Block.__(10, [
                                  nal,
                                  /* tuple */[
                                    na$3,
                                    Option$ReactTemplate.map(aux, match[1])
                                  ],
                                  aux(param[2]),
                                  aux(param[3])
                                ]);
                    case 10 : 
                        var match$1 = param[1];
                        var na$4 = match$1[0];
                        add_name(found, na$4);
                        return /* NIf */Block.__(11, [
                                  aux(param[0]),
                                  /* tuple */[
                                    na$4,
                                    Option$ReactTemplate.map(aux, match$1[1])
                                  ],
                                  aux(param[2]),
                                  aux(param[3])
                                ]);
                    case 11 : 
                        var idl = param[1];
                        Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                                return add_id(found, param);
                              }), idl);
                        var dll = Util$ReactTemplate.$$Array[/* map */12](Curry._1(Util$ReactTemplate.List[/* map */10], (function (param) {
                                    var na = param[0];
                                    if (param[1] !== /* Explicit */0) {
                                      CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Binders marked as implicit not allowed in notations."));
                                    }
                                    add_name(found, na);
                                    return /* tuple */[
                                            na,
                                            Option$ReactTemplate.map(aux, param[2]),
                                            aux(param[3])
                                          ];
                                  })), param[2]);
                        return /* NRec */Block.__(12, [
                                  param[0],
                                  idl,
                                  dll,
                                  Util$ReactTemplate.$$Array[/* map */12](aux, param[3]),
                                  Util$ReactTemplate.$$Array[/* map */12](aux, param[4])
                                ]);
                    case 12 : 
                        return /* NSort */Block.__(13, [param[0]]);
                    case 13 : 
                        var arg = param[2];
                        if (arg !== /* None */0) {
                          has_ltac[0] = /* true */1;
                        }
                        return /* NHole */Block.__(3, [
                                  param[0],
                                  param[1],
                                  arg
                                ]);
                    case 14 : 
                        return /* NCast */Block.__(14, [
                                  aux(param[0]),
                                  Miscops$ReactTemplate.map_cast_type(aux, param[1])
                                ]);
                    case 15 : 
                        return /* NProj */Block.__(15, [
                                  param[0],
                                  aux(param[1])
                                ]);
                    
                  }
                }), x);
  };
  var t = aux(a);
  return /* tuple */[
          t,
          found[0],
          has_ltac[0]
        ];
}

function check_variables_and_reversibility(nenv, param) {
  var foundrecbinding = param[/* recursive_binders_vars */2];
  var foundrec = param[/* recursive_term_vars */1];
  var found = param[/* vars */0];
  var injective = [/* [] */0];
  var recvars = nenv[/* ninterp_rec_vars */1];
  var fold = function (_, y, accu) {
    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], y, accu);
  };
  var useless_vars = Curry._3(Names$ReactTemplate.Id[/* Map */10][/* fold */10], fold, recvars, Names$ReactTemplate.Id[/* Set */9][/* empty */0]);
  var filter = function (y, _) {
    return 1 - Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], y, useless_vars);
  };
  var vars = Curry._2(Names$ReactTemplate.Id[/* Map */10][/* filter */13], filter, nenv[/* ninterp_var_type */0]);
  var check_recvar = function (x) {
    if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], x, found)) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](x), Pp$ReactTemplate.strbrk(" should only be used in the recursive part of a pattern.")));
    } else {
      return 0;
    }
  };
  var check = function (param) {
    check_recvar(param[0]);
    return check_recvar(param[1]);
  };
  Curry._2(Util$ReactTemplate.List[/* iter */9], check, foundrec);
  Curry._2(Util$ReactTemplate.List[/* iter */9], check, foundrecbinding);
  var check_bound = function (x) {
    if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem */1], x, found)) {
      return 0;
    } else if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc */3], x, foundrec) || Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc */3], x, foundrecbinding) || Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc_sym */5], x, foundrec) || Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc_sym */5], x, foundrecbinding)) {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str(Names$ReactTemplate.Id[/* to_string */7](x) + " should not be bound in a recursive pattern of the right-hand side."));
    } else {
      injective[0] = /* :: */[
        x,
        injective[0]
      ];
      return /* () */0;
    }
  };
  var check_pair = function (s, x, y, where) {
    if (mem_recursive_pair(/* tuple */[
            x,
            y
          ], where)) {
      return 0;
    } else {
      return CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("in the right-hand side, "), Names$ReactTemplate.Id[/* print */8](x)), Pp$ReactTemplate.str(" and ")), Names$ReactTemplate.Id[/* print */8](y)), Pp$ReactTemplate.strbrk(" should appear in ")), Pp$ReactTemplate.str(s)), Pp$ReactTemplate.str(" position as part of a recursive pattern.")));
    }
  };
  var check_type = function (x, typ) {
    if (typ !== 0) {
      try {
        return check_pair("binding", x, Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x, recvars), foundrecbinding);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return check_bound(x);
        } else {
          throw exn;
        }
      }
    } else {
      try {
        return check_pair("term", x, Curry._2(Names$ReactTemplate.Id[/* Map */10][/* find */21], x, recvars), foundrec);
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          return check_bound(x);
        } else {
          throw exn$1;
        }
      }
    }
  };
  Curry._2(Names$ReactTemplate.Id[/* Map */10][/* iter */9], check_type, vars);
  return Curry._1(Util$ReactTemplate.List[/* rev */4], injective[0]);
}

function notation_constr_of_glob_constr(nenv, a) {
  var recvars = Curry._1(Names$ReactTemplate.Id[/* Map */10][/* bindings */16], nenv[/* ninterp_rec_vars */1]);
  var match = notation_constr_and_vars_of_glob_constr(recvars, a);
  var injective = check_variables_and_reversibility(nenv, match[1]);
  var status = match[2] ? /* HasLtac */1 : (
      injective ? /* NonInjective */[injective] : /* APrioriReversible */0
    );
  return /* tuple */[
          match[0],
          status
        ];
}

function notation_constr_of_constr(avoiding, t) {
  var t$1 = EConstr$ReactTemplate.of_constr(t);
  var t$2 = Detyping$ReactTemplate.detype(/* Now */0, /* None */0, /* false */0, avoiding, Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, t$1);
  var nenv_000 = /* ninterp_var_type */Names$ReactTemplate.Id[/* Map */10][/* empty */0];
  var nenv_001 = /* ninterp_rec_vars */Names$ReactTemplate.Id[/* Map */10][/* empty */0];
  var nenv = /* record */[
    nenv_000,
    nenv_001
  ];
  return notation_constr_of_glob_constr(nenv, t$2);
}

function subst_pat(subst, pat) {
  var match = DAst$ReactTemplate.get(pat);
  if (match.tag) {
    var cpl = match[1];
    var match$1 = match[0];
    var match$2 = match$1[0];
    var kn = match$2[0];
    var kn$prime = Mod_subst$ReactTemplate.subst_mind(subst, kn);
    var cpl$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
            return subst_pat(subst, param);
          }), cpl);
    if (kn$prime === kn && cpl$prime === cpl) {
      return pat;
    } else {
      return DAst$ReactTemplate.make(pat[/* loc */1], /* PatCstr */Block.__(1, [
                    /* tuple */[
                      /* tuple */[
                        kn$prime,
                        match$2[1]
                      ],
                      match$1[1]
                    ],
                    cpl$prime,
                    match[2]
                  ]));
    }
  } else {
    return pat;
  }
}

function subst_notation_constr(subst, bound, raw) {
  switch (raw.tag | 0) {
    case 0 : 
        var ref = raw[0];
        var match = Globnames$ReactTemplate.subst_global(subst, ref);
        if (match[0] === ref) {
          return raw;
        } else {
          return notation_constr_of_constr(bound, match[1])[0];
        }
    case 2 : 
        var rl = raw[1];
        var r = raw[0];
        var r$prime = subst_notation_constr(subst, bound, r);
        var rl$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
                return subst_notation_constr(subst, bound, param);
              }), rl);
        if (r$prime === r && rl$prime === rl) {
          return raw;
        } else {
          return /* NApp */Block.__(2, [
                    r$prime,
                    rl$prime
                  ]);
        }
    case 3 : 
        var solve = raw[2];
        var knd = raw[0];
        var nknd;
        if (typeof knd === "number") {
          nknd = knd;
        } else if (knd.tag) {
          nknd = knd;
        } else {
          var ref$1 = knd[0];
          var match$1 = Globnames$ReactTemplate.subst_global(subst, ref$1);
          var nref = match$1[0];
          nknd = nref === ref$1 ? knd : /* ImplicitArg */Block.__(0, [
                nref,
                knd[1],
                knd[2]
              ]);
        }
        var nsolve = Option$ReactTemplate.smartmap((function (param) {
                return Genintern$ReactTemplate.generic_substitute(subst, param);
              }), solve);
        if (nsolve === solve && nknd === knd) {
          return raw;
        } else {
          return /* NHole */Block.__(3, [
                    nknd,
                    raw[1],
                    nsolve
                  ]);
        }
    case 4 : 
        var r2 = raw[3];
        var r1 = raw[2];
        var r1$prime = subst_notation_constr(subst, bound, r1);
        var r2$prime = subst_notation_constr(subst, bound, r2);
        if (r1$prime === r1 && r2$prime === r2) {
          return raw;
        } else {
          return /* NList */Block.__(4, [
                    raw[0],
                    raw[1],
                    r1$prime,
                    r2$prime,
                    raw[4]
                  ]);
        }
    case 5 : 
        var r2$1 = raw[2];
        var r1$1 = raw[1];
        var r1$prime$1 = subst_notation_constr(subst, bound, r1$1);
        var r2$prime$1 = subst_notation_constr(subst, bound, r2$1);
        if (r1$prime$1 === r1$1 && r2$prime$1 === r2$1) {
          return raw;
        } else {
          return /* NLambda */Block.__(5, [
                    raw[0],
                    r1$prime$1,
                    r2$prime$1
                  ]);
        }
    case 6 : 
        var r2$2 = raw[2];
        var r1$2 = raw[1];
        var r1$prime$2 = subst_notation_constr(subst, bound, r1$2);
        var r2$prime$2 = subst_notation_constr(subst, bound, r2$2);
        if (r1$prime$2 === r1$2 && r2$prime$2 === r2$2) {
          return raw;
        } else {
          return /* NProd */Block.__(6, [
                    raw[0],
                    r1$prime$2,
                    r2$prime$2
                  ]);
        }
    case 7 : 
        var r2$3 = raw[3];
        var r1$3 = raw[2];
        var r1$prime$3 = subst_notation_constr(subst, bound, r1$3);
        var r2$prime$3 = subst_notation_constr(subst, bound, r2$3);
        if (r1$prime$3 === r1$3 && r2$prime$3 === r2$3) {
          return raw;
        } else {
          return /* NBinderList */Block.__(7, [
                    raw[0],
                    raw[1],
                    r1$prime$3,
                    r2$prime$3,
                    raw[4]
                  ]);
        }
    case 8 : 
        var r2$4 = raw[3];
        var t = raw[2];
        var r1$4 = raw[1];
        var r1$prime$4 = subst_notation_constr(subst, bound, r1$4);
        var t$prime = Option$ReactTemplate.smartmap((function (param) {
                return subst_notation_constr(subst, bound, param);
              }), t);
        var r2$prime$4 = subst_notation_constr(subst, bound, r2$4);
        if (r1$prime$4 === r1$4 && t === t$prime && r2$prime$4 === r2$4) {
          return raw;
        } else {
          return /* NLetIn */Block.__(8, [
                    raw[0],
                    r1$prime$4,
                    t$prime,
                    r2$prime$4
                  ]);
        }
    case 9 : 
        var branches = raw[3];
        var rl$1 = raw[2];
        var rtntypopt = raw[1];
        var rtntypopt$prime = Option$ReactTemplate.smartmap((function (param) {
                return subst_notation_constr(subst, bound, param);
              }), rtntypopt);
        var rl$prime$1 = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (x) {
                var match = x[1];
                var signopt = match[1];
                var a = x[0];
                var a$prime = subst_notation_constr(subst, bound, a);
                var signopt$prime = Option$ReactTemplate.map((function (z) {
                        var match = z[0];
                        var indkn = match[0];
                        var indkn$prime = Mod_subst$ReactTemplate.subst_mind(subst, indkn);
                        if (indkn === indkn$prime) {
                          return z;
                        } else {
                          return /* tuple */[
                                  /* tuple */[
                                    indkn$prime,
                                    match[1]
                                  ],
                                  z[1]
                                ];
                        }
                      }), signopt);
                if (a$prime === a && signopt$prime === signopt) {
                  return x;
                } else {
                  return /* tuple */[
                          a$prime,
                          /* tuple */[
                            match[0],
                            signopt$prime
                          ]
                        ];
                }
              }), rl$1);
        var branches$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (branch) {
                var r = branch[1];
                var cpl = branch[0];
                var cpl$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
                        return subst_pat(subst, param);
                      }), cpl);
                var r$prime = subst_notation_constr(subst, bound, r);
                if (cpl$prime === cpl && r$prime === r) {
                  return branch;
                } else {
                  return /* tuple */[
                          cpl$prime,
                          r$prime
                        ];
                }
              }), branches);
        if (rtntypopt$prime === rtntypopt && rtntypopt === rtntypopt$prime && rl$prime$1 === rl$1 && branches$prime === branches) {
          return raw;
        } else {
          return /* NCases */Block.__(9, [
                    raw[0],
                    rtntypopt$prime,
                    rl$prime$1,
                    branches$prime
                  ]);
        }
    case 10 : 
        var c = raw[3];
        var b = raw[2];
        var match$2 = raw[1];
        var po = match$2[1];
        var po$prime = Option$ReactTemplate.smartmap((function (param) {
                return subst_notation_constr(subst, bound, param);
              }), po);
        var b$prime = subst_notation_constr(subst, bound, b);
        var c$prime = subst_notation_constr(subst, bound, c);
        if (po$prime === po && b$prime === b && c$prime === c) {
          return raw;
        } else {
          return /* NLetTuple */Block.__(10, [
                    raw[0],
                    /* tuple */[
                      match$2[0],
                      po$prime
                    ],
                    b$prime,
                    c$prime
                  ]);
        }
    case 11 : 
        var b2 = raw[3];
        var b1 = raw[2];
        var match$3 = raw[1];
        var po$1 = match$3[1];
        var c$1 = raw[0];
        var po$prime$1 = Option$ReactTemplate.smartmap((function (param) {
                return subst_notation_constr(subst, bound, param);
              }), po$1);
        var b1$prime = subst_notation_constr(subst, bound, b1);
        var b2$prime = subst_notation_constr(subst, bound, b2);
        var c$prime$1 = subst_notation_constr(subst, bound, c$1);
        if (po$prime$1 === po$1 && b1$prime === b1 && b2$prime === b2 && c$prime$1 === c$1) {
          return raw;
        } else {
          return /* NIf */Block.__(11, [
                    c$prime$1,
                    /* tuple */[
                      match$3[0],
                      po$prime$1
                    ],
                    b1$prime,
                    b2$prime
                  ]);
        }
    case 12 : 
        var bl = raw[4];
        var tl = raw[3];
        var dll = raw[2];
        var dll$prime = Util$ReactTemplate.$$Array[/* smartmap */47](Curry._1(Util$ReactTemplate.List[/* smartmap */65], (function (x) {
                    var b = x[2];
                    var oc = x[1];
                    var oc$prime = Option$ReactTemplate.smartmap((function (param) {
                            return subst_notation_constr(subst, bound, param);
                          }), oc);
                    var b$prime = subst_notation_constr(subst, bound, b);
                    if (oc$prime === oc && b$prime === b) {
                      return x;
                    } else {
                      return /* tuple */[
                              x[0],
                              oc$prime,
                              b$prime
                            ];
                    }
                  })), dll);
        var tl$prime = Util$ReactTemplate.$$Array[/* smartmap */47]((function (param) {
                return subst_notation_constr(subst, bound, param);
              }), tl);
        var bl$prime = Util$ReactTemplate.$$Array[/* smartmap */47]((function (param) {
                return subst_notation_constr(subst, bound, param);
              }), bl);
        if (dll$prime === dll && tl$prime === tl && bl$prime === bl) {
          return raw;
        } else {
          return /* NRec */Block.__(12, [
                    raw[0],
                    raw[1],
                    dll$prime,
                    tl$prime,
                    bl$prime
                  ]);
        }
    case 1 : 
    case 13 : 
        return raw;
    case 14 : 
        var k = raw[1];
        var r1$5 = raw[0];
        var r1$prime$5 = subst_notation_constr(subst, bound, r1$5);
        var k$prime = Miscops$ReactTemplate.smartmap_cast_type((function (param) {
                return subst_notation_constr(subst, bound, param);
              }), k);
        if (r1$prime$5 === r1$5 && k$prime === k) {
          return raw;
        } else {
          return /* NCast */Block.__(14, [
                    r1$prime$5,
                    k$prime
                  ]);
        }
    case 15 : 
        var c$2 = raw[1];
        var p = raw[0];
        var kn = Names$ReactTemplate.Projection[/* constant */2](p);
        var b$1 = Names$ReactTemplate.Projection[/* unfolded */3](p);
        var kn$prime = Mod_subst$ReactTemplate.subst_constant(subst, kn);
        var c$prime$2 = subst_notation_constr(subst, bound, c$2);
        if (kn$prime === kn && c$prime$2 === c$2) {
          return raw;
        } else {
          return /* NProj */Block.__(15, [
                    Names$ReactTemplate.Projection[/* make */0](kn$prime, b$1),
                    c$prime$2
                  ]);
        }
    
  }
}

function subst_interpretation(subst, param) {
  var metas = param[0];
  var bound = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (accu, param) {
          return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], param[0], accu);
        }), Names$ReactTemplate.Id[/* Set */9][/* empty */0], metas);
  return /* tuple */[
          metas,
          subst_notation_constr(subst, bound, param[1])
        ];
}

function abstract_return_type_context(pi, mklam, tml, rtno) {
  return Option$ReactTemplate.map((function (rtn) {
                var nal = Curry._1(Util$ReactTemplate.List[/* flatten */8], Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                            var match = param[1];
                            var t = match[1];
                            var na = match[0];
                            if (t) {
                              return Util$ReactTemplate.$at(Curry._1(pi, t[0]), /* :: */[
                                          na,
                                          /* [] */0
                                        ]);
                            } else {
                              return /* :: */[
                                      na,
                                      /* [] */0
                                    ];
                            }
                          }), tml));
                return Curry._3(Util$ReactTemplate.List[/* fold_right */14], mklam, nal, rtn);
              }), rtno);
}

function abstract_return_type_context_glob_constr(tml, rtn) {
  return abstract_return_type_context((function (param) {
                return param[/* v */0][1];
              }), (function (na, c) {
                var eta_002 = DAst$ReactTemplate.make(/* None */0, /* GHole */Block.__(13, [
                        /* InternalHole */0,
                        /* IntroAnonymous */0,
                        /* None */0
                      ]));
                var eta = /* GLambda */Block.__(5, [
                    na,
                    /* Explicit */0,
                    eta_002,
                    c
                  ]);
                return DAst$ReactTemplate.make(/* None */0, eta);
              }), tml, rtn);
}

function abstract_return_type_context_notation_constr(tml, rtn) {
  return abstract_return_type_context((function (prim) {
                return prim[1];
              }), (function (na, c) {
                return /* NLambda */Block.__(5, [
                          na,
                          /* NHole */Block.__(3, [
                              /* InternalHole */0,
                              /* IntroAnonymous */0,
                              /* None */0
                            ]),
                          c
                        ]);
              }), tml, rtn);
}

function is_term_meta(id, metas) {
  try {
    var match = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id, metas);
    var match$1 = match[1];
    if (typeof match$1 === "number" && match$1 < 2) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_onlybinding_strict_meta(id, metas) {
  try {
    var match = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id, metas);
    var match$1 = match[1];
    if (typeof match$1 === "number") {
      return /* false */0;
    } else {
      var match$2 = match$1[0];
      if (typeof match$2 === "number" || !(!match$2.tag && match$2[0] !== 0)) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_onlybinding_meta(id, metas) {
  try {
    var match = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id, metas);
    if (typeof match[1] === "number") {
      return /* false */0;
    } else {
      return /* true */1;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_onlybinding_pattern_like_meta(isvar, id, metas) {
  try {
    var match = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id, metas);
    var match$1 = match[1];
    if (typeof match$1 === "number") {
      return /* false */0;
    } else {
      var match$2 = match$1[0];
      if (typeof match$2 === "number") {
        return /* false */0;
      } else if (match$2.tag) {
        if (match$2[0] !== 0) {
          return /* true */1;
        } else {
          return /* false */0;
        }
      } else {
        return 1 - (match$2[0] && isvar);
      }
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function is_bindinglist_meta(id, metas) {
  try {
    var match = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], id, metas);
    var match$1 = match[1];
    if (typeof match$1 === "number" && match$1 >= 2) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

var No_match = Caml_exceptions.create("Notation_ops-ReactTemplate.No_match");

function alpha_var(id1, id2, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      var i2 = match[1];
      var i1 = match[0];
      if (Names$ReactTemplate.Id[/* equal */0](i1, id1)) {
        return Names$ReactTemplate.Id[/* equal */0](i2, id2);
      } else if (Names$ReactTemplate.Id[/* equal */0](i2, id2)) {
        return Names$ReactTemplate.Id[/* equal */0](i1, id1);
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return Names$ReactTemplate.Id[/* equal */0](id1, id2);
    }
  };
}

function alpha_rename(alpmetas, v) {
  if (alpmetas) {
    try {
      return Glob_ops$ReactTemplate.rename_glob_vars(alpmetas, v);
    }
    catch (exn){
      if (exn === Glob_ops$ReactTemplate.UnsoundRenaming) {
        throw No_match;
      } else {
        throw exn;
      }
    }
  } else {
    return v;
  }
}

function add_env(param, param$1, $$var, v) {
  if (!Names$ReactTemplate.Id[/* equal */0](ldots_var, $$var) && Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
            return Glob_ops$ReactTemplate.occur_glob_constr(param[0])(v);
          }), param[0])) {
    throw No_match;
  }
  var v$1 = alpha_rename(param[1], v);
  return /* tuple */[
          /* :: */[
            /* tuple */[
              $$var,
              v$1
            ],
            param$1[0]
          ],
          param$1[1],
          param$1[2],
          param$1[3]
        ];
}

function add_termlist_env(param, param$1, $$var, vl) {
  var alpmetas = param[1];
  if (Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
            return Curry._2(Util$ReactTemplate.List[/* exists */21], Glob_ops$ReactTemplate.occur_glob_constr(param[0]), vl);
          }), param[0])) {
    throw No_match;
  }
  var vl$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return alpha_rename(alpmetas, param);
        }), vl);
  return /* tuple */[
          param$1[0],
          /* :: */[
            /* tuple */[
              $$var,
              vl$1
            ],
            param$1[1]
          ],
          param$1[2],
          param$1[3]
        ];
}

function add_binding_env(_, param, $$var, v) {
  return /* tuple */[
          param[0],
          param[1],
          /* :: */[
            /* tuple */[
              $$var,
              v
            ],
            param[2]
          ],
          param[3]
        ];
}

function add_bindinglist_env(param, x, bl) {
  return /* tuple */[
          param[0],
          param[1],
          param[2],
          /* :: */[
            /* tuple */[
              x,
              bl
            ],
            param[3]
          ]
        ];
}

function map_cases_pattern_name_left(f) {
  return (function (param) {
      return DAst$ReactTemplate.map((function (param) {
                    if (param.tag) {
                      return /* PatCstr */Block.__(1, [
                                param[0],
                                Curry._2(Util$ReactTemplate.List[/* map_left */66], map_cases_pattern_name_left(f), param[1]),
                                Curry._1(f, param[2])
                              ]);
                    } else {
                      return /* PatVar */Block.__(0, [Curry._1(f, param[0])]);
                    }
                  }), param);
    });
}

function fold_cases_pattern_eq(f, x, p, p$prime) {
  var loc = p[/* loc */1];
  var match = DAst$ReactTemplate.get(p);
  var match$1 = DAst$ReactTemplate.get(p$prime);
  if (match.tag) {
    var c = match[0];
    if (match$1.tag) {
      if (Names$ReactTemplate.eq_constructor(c, match$1[0])) {
        var match$2 = fold_cases_pattern_list_eq(f, x, match[1], match$1[1]);
        var match$3 = Curry._3(f, match$2[0], match[2], match$1[2]);
        return /* tuple */[
                match$3[0],
                DAst$ReactTemplate.make(loc, /* PatCstr */Block.__(1, [
                        c,
                        match$2[1],
                        match$3[1]
                      ]))
              ];
      } else {
        return Pervasives.failwith("Not equal");
      }
    } else {
      return Pervasives.failwith("Not equal");
    }
  } else if (match$1.tag) {
    return Pervasives.failwith("Not equal");
  } else {
    var match$4 = Curry._3(f, x, match[0], match$1[0]);
    return /* tuple */[
            match$4[0],
            DAst$ReactTemplate.make(loc, /* PatVar */Block.__(0, [match$4[1]]))
          ];
  }
}

function fold_cases_pattern_list_eq(f, x, pl, pl$prime) {
  if (pl) {
    if (pl$prime) {
      var match = fold_cases_pattern_eq(f, x, pl[0], pl$prime[0]);
      var match$1 = fold_cases_pattern_list_eq(f, match[0], pl[1], pl$prime[1]);
      return /* tuple */[
              match$1[0],
              /* :: */[
                match[1],
                match$1[1]
              ]
            ];
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "notation_ops.ml",
              771,
              9
            ]
          ];
    }
  } else if (pl$prime) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "notation_ops.ml",
            771,
            9
          ]
        ];
  } else {
    return /* tuple */[
            x,
            /* [] */0
          ];
  }
}

function cases_pattern_eq(p1, p2) {
  var match = DAst$ReactTemplate.get(p1);
  var match$1 = DAst$ReactTemplate.get(p2);
  if (match.tag) {
    if (!match$1.tag || !(Names$ReactTemplate.eq_constructor(match[0], match$1[0]) && Curry._3(Util$ReactTemplate.List[/* equal */44], cases_pattern_eq, match[1], match$1[1]))) {
      return /* false */0;
    } else {
      return Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match[2], match$1[2]);
    }
  } else if (match$1.tag) {
    return /* false */0;
  } else {
    return Curry._2(Nameops$ReactTemplate.Name[/* equal */4], match[0], match$1[0]);
  }
}

function pat_binder_of_term(t) {
  return DAst$ReactTemplate.map((function (param) {
                switch (param.tag | 0) {
                  case 1 : 
                      return /* PatVar */Block.__(0, [/* Name */[param[0]]]);
                  case 4 : 
                      var match = DAst$ReactTemplate.get(param[0]);
                      if (match.tag) {
                        throw No_match;
                      } else {
                        var match$1 = match[0];
                        if (match$1.tag === 3) {
                          var cstr = match$1[0];
                          var nparams = Inductiveops$ReactTemplate.inductive_nparams(cstr[0]);
                          var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], nparams, param[1]);
                          return /* PatCstr */Block.__(1, [
                                    cstr,
                                    Curry._2(Util$ReactTemplate.List[/* map */10], pat_binder_of_term, match$2[1]),
                                    /* Anonymous */0
                                  ]);
                        } else {
                          throw No_match;
                        }
                      }
                      break;
                  default:
                    throw No_match;
                }
              }), t);
}

function unify_name_upto(alp, na, na$prime) {
  if (na) {
    if (na$prime) {
      var id$prime = na$prime[0];
      var id = na[0];
      if (Names$ReactTemplate.Id[/* equal */0](id, id$prime)) {
        return /* tuple */[
                alp,
                na$prime
              ];
      } else {
        return /* tuple */[
                /* tuple */[
                  alp[0],
                  /* :: */[
                    /* tuple */[
                      id,
                      id$prime
                    ],
                    alp[1]
                  ]
                ],
                na$prime
              ];
      }
    } else {
      return /* tuple */[
              alp,
              na
            ];
    }
  } else {
    return /* tuple */[
            alp,
            na$prime
          ];
  }
}

function unify_pat_upto(alp, p, p$prime) {
  try {
    return fold_cases_pattern_eq(unify_name_upto, alp, p, p$prime);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      throw No_match;
    } else {
      throw exn;
    }
  }
}

function unify_term(alp, v, v$prime) {
  var match = DAst$ReactTemplate.get(v);
  var match$1 = DAst$ReactTemplate.get(v$prime);
  if (match.tag === 13) {
    return v$prime;
  } else if (match$1.tag === 13) {
    return v;
  } else if (Glob_ops$ReactTemplate.glob_constr_eq(alpha_rename(alp[1], v))(v$prime)) {
    return v;
  } else {
    throw No_match;
  }
}

function unify_opt_term(alp, v, v$prime) {
  if (v) {
    if (v$prime) {
      return /* Some */[unify_term(alp, v[0], v$prime[0])];
    } else {
      return v;
    }
  } else if (v$prime) {
    return v$prime;
  } else {
    return /* None */0;
  }
}

function unify_binding_kind(bk, bk$prime) {
  if (bk === bk$prime) {
    return bk$prime;
  } else {
    throw No_match;
  }
}

function unify_binder_upto(alp, b, b$prime) {
  var loc = b[/* loc */1];
  var match = DAst$ReactTemplate.get(b);
  var match$1 = DAst$ReactTemplate.get(b$prime);
  switch (match.tag | 0) {
    case 0 : 
        switch (match$1.tag | 0) {
          case 0 : 
              var match$2 = unify_name_upto(alp, match[0], match$1[0]);
              var alp$1 = match$2[0];
              return /* tuple */[
                      alp$1,
                      DAst$ReactTemplate.make(loc, /* GLocalAssum */Block.__(0, [
                              match$2[1],
                              unify_binding_kind(match[1], match$1[1]),
                              unify_term(alp$1, match[2], match$1[2])
                            ]))
                    ];
          case 1 : 
          case 2 : 
              throw No_match;
          
        }
        break;
    case 1 : 
        switch (match$1.tag | 0) {
          case 1 : 
              var match$3 = unify_name_upto(alp, match[0], match$1[0]);
              var alp$2 = match$3[0];
              return /* tuple */[
                      alp$2,
                      DAst$ReactTemplate.make(loc, /* GLocalDef */Block.__(1, [
                              match$3[1],
                              unify_binding_kind(match[1], match$1[1]),
                              unify_term(alp$2, match[2], match$1[2]),
                              unify_opt_term(alp$2, match[3], match$1[3])
                            ]))
                    ];
          case 0 : 
          case 2 : 
              throw No_match;
          
        }
        break;
    case 2 : 
        var match$4 = match[0];
        var disjpat = match$4[0];
        switch (match$1.tag | 0) {
          case 0 : 
          case 1 : 
              throw No_match;
          case 2 : 
              var disjpat$prime = match$1[0][0];
              if (Curry._1(Util$ReactTemplate.List[/* length */0], disjpat) === Curry._1(Util$ReactTemplate.List[/* length */0], disjpat$prime)) {
                var match$5 = Curry._4(Util$ReactTemplate.List[/* fold_left2_map */118], unify_pat_upto, alp, disjpat, disjpat$prime);
                var alp$3 = match$5[0];
                return /* tuple */[
                        alp$3,
                        DAst$ReactTemplate.make(loc, /* GLocalPattern */Block.__(2, [
                                /* tuple */[
                                  match$5[1],
                                  match$4[1]
                                ],
                                match[1],
                                unify_binding_kind(match[2], match$1[2]),
                                unify_term(alp$3, match[3], match$1[3])
                              ]))
                      ];
              } else {
                throw No_match;
              }
              break;
          
        }
        break;
    
  }
}

function unify_terms(alp, vl, vl$prime) {
  if (vl) {
    if (vl$prime) {
      return /* :: */[
              unify_term(alp, vl[0], vl$prime[0]),
              unify_terms(alp, vl[1], vl$prime[1])
            ];
    } else {
      throw No_match;
    }
  } else if (vl$prime) {
    throw No_match;
  } else {
    return /* [] */0;
  }
}

function unify_binders_upto(alp, bl, bl$prime) {
  if (bl) {
    if (bl$prime) {
      var match = unify_binder_upto(alp, bl[0], bl$prime[0]);
      var match$1 = unify_binders_upto(match[0], bl[1], bl$prime[1]);
      return /* tuple */[
              match$1[0],
              /* :: */[
                match[1],
                match$1[1]
              ]
            ];
    } else {
      throw No_match;
    }
  } else if (bl$prime) {
    throw No_match;
  } else {
    return /* tuple */[
            alp,
            /* [] */0
          ];
  }
}

function unify_id(alp, id, na$prime) {
  if (na$prime) {
    if (Names$ReactTemplate.Id[/* equal */0](Glob_ops$ReactTemplate.rename_var(alp[1], id), na$prime[0])) {
      return na$prime;
    } else {
      throw No_match;
    }
  } else {
    return /* Name */[Glob_ops$ReactTemplate.rename_var(alp[1], id)];
  }
}

function unify_pat(alp, p, p$prime) {
  var partial_arg = alp[1];
  var partial_arg$1 = function (param) {
    return Glob_ops$ReactTemplate.rename_var(partial_arg, param);
  };
  var partial_arg$2 = Nameops$ReactTemplate.Name[/* map */12];
  if (cases_pattern_eq(map_cases_pattern_name_left((function (param) {
                  return partial_arg$2(partial_arg$1, param);
                }))(p), p$prime)) {
    return p$prime;
  } else {
    throw No_match;
  }
}

function unify_term_binder(alp, c) {
  return (function (param) {
      return DAst$ReactTemplate.map((function (b$prime) {
                    var match = DAst$ReactTemplate.get(c);
                    var exit = 0;
                    if (match.tag === 1) {
                      switch (b$prime.tag | 0) {
                        case 0 : 
                            return /* GLocalAssum */Block.__(0, [
                                      unify_id(alp, match[0], b$prime[0]),
                                      b$prime[1],
                                      b$prime[2]
                                    ]);
                        case 1 : 
                            throw No_match;
                        case 2 : 
                            exit = 1;
                            break;
                        
                      }
                    } else {
                      exit = 1;
                    }
                    if (exit === 1) {
                      switch (b$prime.tag | 0) {
                        case 0 : 
                        case 1 : 
                            throw No_match;
                        case 2 : 
                            var match$1 = b$prime[0];
                            var match$2 = match$1[0];
                            if (match$2) {
                              if (match$2[1]) {
                                throw No_match;
                              } else {
                                var p = pat_binder_of_term(c);
                                return /* GLocalPattern */Block.__(2, [
                                          /* tuple */[
                                            /* :: */[
                                              unify_pat(alp, p, match$2[0]),
                                              /* [] */0
                                            ],
                                            match$1[1]
                                          ],
                                          b$prime[1],
                                          b$prime[2],
                                          b$prime[3]
                                        ]);
                              }
                            } else {
                              throw No_match;
                            }
                            break;
                        
                      }
                    }
                    
                  }), param);
    });
}

function unify_terms_binders(alp, _cl, _bl$prime) {
  while(true) {
    var bl$prime = _bl$prime;
    var cl = _cl;
    if (cl) {
      if (bl$prime) {
        var bl$prime$1 = bl$prime[1];
        var b$prime = bl$prime[0];
        var cl$1 = cl[1];
        var match = DAst$ReactTemplate.get(b$prime);
        var exit = 0;
        switch (match.tag | 0) {
          case 1 : 
              _bl$prime = bl$prime$1;
              _cl = cl$1;
              continue ;
              case 0 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        if (exit === 1) {
          return /* :: */[
                  unify_term_binder(alp, cl[0])(b$prime),
                  unify_terms_binders(alp, cl$1, bl$prime$1)
                ];
        }
        
      } else {
        throw No_match;
      }
    } else if (bl$prime) {
      throw No_match;
    } else {
      return /* [] */0;
    }
  };
}

function bind_term_env(alp, sigma, $$var, v) {
  var terms = sigma[0];
  try {
    var v$prime = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], $$var, terms);
    var v$prime$prime = unify_term(alp, v, v$prime);
    if (v$prime$prime === v$prime) {
      return sigma;
    } else {
      var sigma_000 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* remove_assoc */4], $$var, terms);
      var sigma_001 = sigma[1];
      var sigma_002 = sigma[2];
      var sigma_003 = sigma[3];
      var sigma$1 = /* tuple */[
        sigma_000,
        sigma_001,
        sigma_002,
        sigma_003
      ];
      return add_env(alp, sigma$1, $$var, v);
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return add_env(alp, sigma, $$var, v);
    } else {
      throw exn;
    }
  }
}

function force_cases_pattern(c) {
  return DAst$ReactTemplate.make(c[/* loc */1], DAst$ReactTemplate.get(c));
}

function bind_binding_as_term_env(alp, sigma, $$var, c) {
  var binders = sigma[2];
  var pat;
  try {
    pat = force_cases_pattern(Glob_ops$ReactTemplate.cases_pattern_of_glob_constr(/* Anonymous */0)(c));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw No_match;
    } else {
      throw exn;
    }
  }
  try {
    var patl$prime = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], $$var, binders);
    var patl$prime$prime = Curry._3(Util$ReactTemplate.List[/* map2 */16], (function (param, param$1) {
            return unify_pat(alp, param, param$1);
          }), /* :: */[
          pat,
          /* [] */0
        ], patl$prime);
    if (patl$prime === patl$prime$prime) {
      return sigma;
    } else {
      var sigma_000 = sigma[0];
      var sigma_001 = sigma[1];
      var sigma_002 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* remove_assoc */4], $$var, binders);
      var sigma_003 = sigma[3];
      var sigma$1 = /* tuple */[
        sigma_000,
        sigma_001,
        sigma_002,
        sigma_003
      ];
      return add_binding_env(alp, sigma$1, $$var, patl$prime$prime);
    }
  }
  catch (exn$1){
    if (exn$1 === Caml_builtin_exceptions.not_found) {
      return add_binding_env(alp, sigma, $$var, /* :: */[
                  pat,
                  /* [] */0
                ]);
    } else {
      throw exn$1;
    }
  }
}

function bind_binding_env(alp, sigma, $$var, disjpat) {
  var binders = sigma[2];
  try {
    var disjpat$prime = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], $$var, binders);
    var match = Curry._4(Util$ReactTemplate.List[/* fold_left2_map */118], unify_pat_upto, alp, disjpat, disjpat$prime);
    var alp$1 = match[0];
    var sigma_000 = sigma[0];
    var sigma_001 = sigma[1];
    var sigma_002 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* remove_assoc */4], $$var, binders);
    var sigma_003 = sigma[3];
    var sigma$1 = /* tuple */[
      sigma_000,
      sigma_001,
      sigma_002,
      sigma_003
    ];
    return /* tuple */[
            alp$1,
            add_binding_env(alp$1, sigma$1, $$var, match[1])
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* tuple */[
              alp,
              add_binding_env(alp, sigma, $$var, disjpat)
            ];
    } else {
      throw exn;
    }
  }
}

function bind_bindinglist_env(alp, sigma, $$var, bl) {
  var binderlists = sigma[3];
  var bl$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], bl);
  try {
    var bl$prime = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], $$var, binderlists);
    var match = unify_binders_upto(alp, bl$1, bl$prime);
    var sigma_000 = sigma[0];
    var sigma_001 = sigma[1];
    var sigma_002 = sigma[2];
    var sigma_003 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* remove_assoc */4], $$var, binderlists);
    var sigma$1 = /* tuple */[
      sigma_000,
      sigma_001,
      sigma_002,
      sigma_003
    ];
    return /* tuple */[
            match[0],
            add_bindinglist_env(sigma$1, $$var, match[1])
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* tuple */[
              alp,
              add_bindinglist_env(sigma, $$var, bl$1)
            ];
    } else {
      throw exn;
    }
  }
}

function match_fix_kind(fk1, fk2) {
  if (fk1.tag) {
    if (fk2.tag) {
      return +(fk1[0] === fk2[0]);
    } else {
      return /* false */0;
    }
  } else {
    var match = fk1[0];
    if (fk2.tag) {
      return /* false */0;
    } else {
      var match$1 = fk2[0];
      var test = function (param, param$1) {
        var n2 = param$1[0];
        var n1 = param[0];
        if (n2) {
          if (n1) {
            return +(n1[0] === n2[0]);
          } else {
            return /* false */0;
          }
        } else {
          return /* true */1;
        }
      };
      if (match[1] === match$1[1]) {
        return Util$ReactTemplate.$$Array[/* for_all2 */27](test, match[0], match$1[0]);
      } else {
        return /* false */0;
      }
    }
  }
}

function match_opt(f, sigma, t1, t2) {
  if (t1) {
    if (t2) {
      return Curry._3(f, sigma, t1[0], t2[0]);
    } else {
      throw No_match;
    }
  } else if (t2) {
    throw No_match;
  } else {
    return sigma;
  }
}

function match_names(metas, param, na1, na2) {
  var sigma = param[1];
  var alp = param[0];
  var exit = 0;
  if (na2) {
    var id2 = na2[0];
    if (is_onlybinding_strict_meta(id2, metas)) {
      throw No_match;
    } else if (is_onlybinding_meta(id2, metas)) {
      return bind_binding_env(alp, sigma, id2, /* :: */[
                  DAst$ReactTemplate.make(/* None */0, /* PatVar */Block.__(0, [na1])),
                  /* [] */0
                ]);
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (na1) {
      if (na2) {
        var id2$1 = na2[0];
        var id1 = na1[0];
        if (is_term_meta(id2$1, metas)) {
          var alp$1 = alp;
          var sigma$1 = sigma;
          var $$var = id2$1;
          var id = id1;
          try {
            var match = DAst$ReactTemplate.get(Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], $$var, sigma$1[0]));
            if (match.tag === 1) {
              var id$prime = match[0];
              return /* tuple */[
                      Names$ReactTemplate.Id[/* equal */0](id, id$prime) ? alp$1 : /* tuple */[
                          alp$1[0],
                          /* :: */[
                            /* tuple */[
                              id,
                              id$prime
                            ],
                            alp$1[1]
                          ]
                        ],
                      sigma$1
                    ];
            } else {
              return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("A term which can be a binder has to be a variable."));
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              var eta = /* GVar */Block.__(1, [id]);
              return /* tuple */[
                      alp$1,
                      add_env(alp$1, sigma$1, $$var, DAst$ReactTemplate.make(/* None */0, eta))
                    ];
            } else {
              throw exn;
            }
          }
        } else {
          return /* tuple */[
                  /* tuple */[
                    /* :: */[
                      /* tuple */[
                        id1,
                        id2$1
                      ],
                      alp[0]
                    ],
                    alp[1]
                  ],
                  sigma
                ];
        }
      } else {
        throw No_match;
      }
    } else if (na2) {
      if (is_term_meta(na2[0], metas)) {
        return /* tuple */[
                alp,
                sigma
              ];
      } else {
        throw No_match;
      }
    } else {
      return /* tuple */[
              alp,
              sigma
            ];
    }
  }
  
}

function match_cases_pattern_binders(allow_catchall, metas, acc, pat1, pat2) {
  var sigma = acc[1];
  var alp = acc[0];
  var match = DAst$ReactTemplate.get(pat1);
  var match$1 = DAst$ReactTemplate.get(pat2);
  var exit = 0;
  var exit$1 = 0;
  if (match.tag) {
    var patl1 = match[1];
    if (match$1.tag) {
      var patl2 = match$1[1];
      if (Names$ReactTemplate.eq_constructor(match[0], match$1[0]) && Curry._1(Util$ReactTemplate.List[/* length */0], patl1) === Curry._1(Util$ReactTemplate.List[/* length */0], patl2)) {
        return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, param$1, param$2) {
                      return match_cases_pattern_binders(/* false */0, metas, param, param$1, param$2);
                    }), match_names(metas, acc, match[2], match$1[2]), patl1, patl2);
      } else {
        throw No_match;
      }
    } else {
      exit$1 = 2;
    }
  } else if (match$1.tag) {
    throw No_match;
  } else {
    var match$2 = match$1[0];
    if (match$2) {
      var id2 = match$2[0];
      if (is_onlybinding_pattern_like_meta(/* true */1, id2, metas)) {
        return bind_binding_env(alp, sigma, id2, /* :: */[
                    pat1,
                    /* [] */0
                  ]);
      } else {
        exit$1 = 2;
      }
    } else {
      exit = 1;
    }
  }
  if (exit$1 === 2) {
    var match$3 = match$1[0];
    if (match$3) {
      var id2$1 = match$3[0];
      if (is_onlybinding_pattern_like_meta(/* false */0, id2$1, metas)) {
        return bind_binding_env(alp, sigma, id2$1, /* :: */[
                    pat1,
                    /* [] */0
                  ]);
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    if (match.tag) {
      if (match$1[0]) {
        throw No_match;
      } else if (allow_catchall) {
        return acc;
      } else {
        throw No_match;
      }
    } else {
      return match_names(metas, acc, match[0], match$1[0]);
    }
  }
  
}

function remove_sigma(x, param) {
  return /* tuple */[
          Curry._2(Names$ReactTemplate.Id[/* List */12][/* remove_assoc */4], x, param[0]),
          param[1],
          param[2],
          param[3]
        ];
}

function remove_bindinglist_sigma(x, param) {
  return /* tuple */[
          param[0],
          param[1],
          param[2],
          Curry._2(Names$ReactTemplate.Id[/* List */12][/* remove_assoc */4], x, param[3])
        ];
}

function add_ldots_var(metas) {
  return /* :: */[
          /* tuple */[
            ldots_var,
            /* tuple */[
              /* tuple */[
                /* None */0,
                /* [] */0
              ],
              /* NtnTypeConstr */0
            ]
          ],
          metas
        ];
}

function add_meta_bindinglist(x, metas) {
  return /* :: */[
          /* tuple */[
            x,
            /* tuple */[
              /* tuple */[
                /* None */0,
                /* [] */0
              ],
              /* NtnTypeBinderList */2
            ]
          ],
          metas
        ];
}

var OnlyTrailingLetIns = Caml_exceptions.create("Notation_ops-ReactTemplate.OnlyTrailingLetIns");

function add_meta_term(x, metas) {
  return /* :: */[
          /* tuple */[
            x,
            /* tuple */[
              /* tuple */[
                /* None */0,
                /* [] */0
              ],
              /* NtnTypeConstr */0
            ]
          ],
          metas
        ];
}

function does_not_come_from_already_eta_expanded_var(glob) {
  var match = DAst$ReactTemplate.get(glob);
  if (match.tag === 1) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function match_(_inner, u, _alp, metas, _sigma, _a1, _a2) {
  while(true) {
    var a2 = _a2;
    var a1 = _a1;
    var sigma = _sigma;
    var alp = _alp;
    var inner = _inner;
    var loc = a1[/* loc */1];
    var match = DAst$ReactTemplate.get(a1);
    var exit = 0;
    var na1;
    var b1;
    var c1;
    var na2;
    var b2;
    var c2;
    var exit$1 = 0;
    var exit$2 = 0;
    var exit$3 = 0;
    switch (a2.tag | 0) {
      case 1 : 
          var id2 = a2[0];
          if (is_term_meta(id2, metas)) {
            return bind_term_env(alp, sigma, id2, a1);
          } else {
            exit$3 = 5;
          }
          break;
      case 4 : 
          var match_fun = (function(alp){
          return function match_fun(param, param$1, param$2, param$3) {
            return match_(/* false */0, u, alp, param, param$1, param$2, param$3);
          }
          }(alp));
          var alp$1 = alp;
          var metas$1 = metas;
          var sigma$1 = sigma;
          var rest = a1;
          var x = a2[0];
          var y = a2[1];
          var iter = a2[2];
          var termin = a2[3];
          var revert = a2[4];
          var aux = (function(match_fun,metas$1,y,iter,termin){
          return function aux(sigma, acc, rest) {
            try {
              var metas$2 = add_ldots_var(add_meta_term(y, metas$1));
              var sigma$1 = Curry._4(match_fun, metas$2, sigma, rest, iter);
              var terms = sigma$1[0];
              var rest$1 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], ldots_var, terms);
              var t = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], y, terms);
              var sigma$2 = remove_sigma(y, remove_sigma(ldots_var, sigma$1));
              return aux(sigma$2, /* :: */[
                          t,
                          acc
                        ], rest$1);
            }
            catch (exn){
              if (exn === No_match) {
                if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], acc)) {
                  throw exn;
                } else {
                  return /* tuple */[
                          acc,
                          Curry._4(match_fun, metas$1, sigma, rest, termin)
                        ];
                }
              } else {
                throw exn;
              }
            }
          }
          }(match_fun,metas$1,y,iter,termin));
          var match$1 = aux(sigma$1, /* [] */0, rest);
          var sigma$2 = match$1[1];
          var l = match$1[0];
          var l$1 = revert ? l : Curry._1(Util$ReactTemplate.List[/* rev */4], l);
          if (is_bindinglist_meta(x, metas$1)) {
            var alp$2 = alp$1;
            var param = sigma$2;
            var $$var = x;
            var cl = l$1;
            var binderlists = param[3];
            try {
              var bl$prime = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], $$var, binderlists);
              var bl = unify_terms_binders(alp$2, cl, bl$prime);
              var sigma_000 = param[0];
              var sigma_001 = param[1];
              var sigma_002 = param[2];
              var sigma_003 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* remove_assoc */4], $$var, binderlists);
              var sigma$3 = /* tuple */[
                sigma_000,
                sigma_001,
                sigma_002,
                sigma_003
              ];
              return add_bindinglist_env(sigma$3, $$var, bl);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("There should be a binder list bindings this list of terms."));
              } else {
                throw exn;
              }
            }
          } else {
            var alp$3 = alp$1;
            var sigma$4 = sigma$2;
            var $$var$1 = x;
            var vl = l$1;
            var termlists = sigma$4[1];
            try {
              var vl$prime = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], $$var$1, termlists);
              var vl$1 = unify_terms(alp$3, vl, vl$prime);
              var sigma_000$1 = sigma$4[0];
              var sigma_001$1 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* remove_assoc */4], $$var$1, termlists);
              var sigma_002$1 = sigma$4[2];
              var sigma_003$1 = sigma$4[3];
              var sigma$5 = /* tuple */[
                sigma_000$1,
                sigma_001$1,
                sigma_002$1,
                sigma_003$1
              ];
              return add_termlist_env(alp$3, sigma$5, $$var$1, vl$1);
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                return add_termlist_env(alp$3, sigma$4, $$var$1, vl);
              } else {
                throw exn$1;
              }
            }
          }
      case 7 : 
          var match_fun$1 = function (param, param$1, param$2, param$3, param$4) {
            return match_(/* false */0, u, param, param$1, param$2, param$3, param$4);
          };
          var alp$4 = alp;
          var metas$2 = metas;
          var sigma$6 = sigma;
          var rest$1 = a1;
          var x$1 = a2[0];
          var y$1 = a2[1];
          var iter$1 = a2[2];
          var termin$1 = a2[3];
          var revert$1 = a2[4];
          var aux$1 = (function(match_fun$1,alp$4,metas$2,y$1,iter$1){
          return function aux$1(trailing_letins, sigma, bl, rest) {
            try {
              var metas$3 = add_ldots_var(add_meta_bindinglist(y$1, metas$2));
              var sigma$1 = Curry._5(match_fun$1, alp$4, metas$3, sigma, rest, iter$1);
              var rest$1 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], ldots_var, sigma$1[0]);
              var match = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], y$1, sigma$1[3]);
              var b;
              if (match) {
                if (match[1]) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "notation_ops.ml",
                          1031,
                          62
                        ]
                      ];
                } else {
                  b = match[0];
                }
              } else {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "notation_ops.ml",
                        1031,
                        62
                      ]
                    ];
              }
              var sigma$2 = remove_bindinglist_sigma(y$1, remove_sigma(ldots_var, sigma$1));
              var sigma$3 = remove_sigma(y$1, sigma$2);
              return aux$1(/* false */0, sigma$3, /* :: */[
                          b,
                          bl
                        ], rest$1);
            }
            catch (exn){
              if (exn === No_match) {
                var match$1 = DAst$ReactTemplate.get(rest);
                if (match$1.tag === 7) {
                  var b$1 = DAst$ReactTemplate.make(rest[/* loc */1], /* GLocalDef */Block.__(1, [
                          match$1[0],
                          /* Explicit */0,
                          match$1[1],
                          match$1[2]
                        ]));
                  try {
                    return aux$1(/* true */1, sigma, /* :: */[
                                b$1,
                                bl
                              ], match$1[3]);
                  }
                  catch (exn$1){
                    if (exn$1 === OnlyTrailingLetIns) {
                      if (trailing_letins && /* true */1) {
                        throw exn$1;
                      } else if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], bl)) {
                        throw No_match;
                      } else {
                        return /* tuple */[
                                bl,
                                rest,
                                sigma
                              ];
                      }
                    } else {
                      throw exn$1;
                    }
                  }
                } else {
                  if (trailing_letins && /* true */1) {
                    throw OnlyTrailingLetIns;
                  }
                  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], bl)) {
                    throw No_match;
                  } else {
                    return /* tuple */[
                            bl,
                            rest,
                            sigma
                          ];
                  }
                }
              } else {
                throw exn;
              }
            }
          }
          }(match_fun$1,alp$4,metas$2,y$1,iter$1));
          var match$2 = aux$1(/* false */0, sigma$6, /* [] */0, rest$1);
          var bl$1 = match$2[0];
          var bl$2 = revert$1 ? Curry._1(Util$ReactTemplate.List[/* rev */4], bl$1) : bl$1;
          var match$3 = bind_bindinglist_env(alp$4, match$2[2], x$1, bl$2);
          return Curry._5(match_fun$1, match$3[0], metas$2, match$3[1], match$2[1], termin$1);
      default:
        exit$3 = 5;
    }
    if (exit$3 === 5) {
      switch (match.tag | 0) {
        case 0 : 
            switch (a2.tag | 0) {
              case 0 : 
                  if (Globnames$ReactTemplate.eq_gr(match[0], a2[0])) {
                    return sigma;
                  } else {
                    exit = 1;
                  }
                  break;
              case 1 : 
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              default:
                exit = 1;
            }
            break;
        case 1 : 
            switch (a2.tag | 0) {
              case 1 : 
                  var id2$1 = a2[0];
                  if (is_onlybinding_pattern_like_meta(/* true */1, id2$1, metas)) {
                    return bind_binding_as_term_env(alp, sigma, id2$1, a1);
                  } else {
                    exit$2 = 4;
                  }
                  break;
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              default:
                exit = 1;
            }
            break;
        case 3 : 
            switch (a2.tag | 0) {
              case 3 : 
                  throw No_match;
              case 1 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              default:
                exit = 1;
            }
            break;
        case 4 : 
            var l1 = match[1];
            var f1 = match[0];
            switch (a2.tag | 0) {
              case 2 : 
                  var l2 = a2[1];
                  var f2 = a2[0];
                  var n1 = Curry._1(Util$ReactTemplate.List[/* length */0], l1);
                  var n2 = Curry._1(Util$ReactTemplate.List[/* length */0], l2);
                  var match$4;
                  if (n1 < n2) {
                    var match$5 = Curry._2(Util$ReactTemplate.List[/* chop */99], n2 - n1 | 0, l2);
                    match$4 = /* tuple */[
                      f1,
                      l1,
                      /* NApp */Block.__(2, [
                          f2,
                          match$5[0]
                        ]),
                      match$5[1]
                    ];
                  } else if (n1 > n2) {
                    var match$6 = Curry._2(Util$ReactTemplate.List[/* chop */99], n1 - n2 | 0, l1);
                    match$4 = /* tuple */[
                      DAst$ReactTemplate.make(loc, /* GApp */Block.__(4, [
                              f1,
                              match$6[0]
                            ])),
                      match$6[1],
                      f2,
                      l2
                    ];
                  } else {
                    match$4 = /* tuple */[
                      f1,
                      l1,
                      f2,
                      l2
                    ];
                  }
                  var f1$1 = match$4[0];
                  var may_use_eta = does_not_come_from_already_eta_expanded_var(f1$1);
                  return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function(alp,may_use_eta){
                            return function (param, param$1, param$2) {
                              return match_(may_use_eta, u, alp, metas, param, param$1, param$2);
                            }
                            }(alp,may_use_eta)), match_(/* false */0, u, alp, metas, sigma, f1$1, match$4[2]), match$4[1], match$4[3]);
              case 1 : 
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              default:
                exit = 1;
            }
            break;
        case 5 : 
            var t1 = match[2];
            switch (a2.tag | 0) {
              case 1 : 
              case 3 : 
                  exit$2 = 4;
                  break;
              case 5 : 
                  return match_extended_binders(/* None */0, /* false */0, u, alp, metas, match[0], a2[0], match[1], t1, match_(/* true */1, u, alp, metas, sigma, t1, a2[1]), match[3], a2[2]);
              default:
                exit = 1;
            }
            break;
        case 6 : 
            var t1$1 = match[2];
            switch (a2.tag | 0) {
              case 1 : 
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              case 6 : 
                  return match_extended_binders(/* None */0, /* true */1, u, alp, metas, match[0], a2[0], match[1], t1$1, match_(/* true */1, u, alp, metas, sigma, t1$1, a2[1]), match[3], a2[2]);
              default:
                exit = 1;
            }
            break;
        case 7 : 
            var match$7 = match[2];
            var b1$1 = match[1];
            var na1$1 = match[0];
            var exit$4 = 0;
            if (match$7) {
              switch (a2.tag | 0) {
                case 1 : 
                case 3 : 
                case 5 : 
                    exit$2 = 4;
                    break;
                case 8 : 
                    var match$8 = a2[2];
                    if (match$8) {
                      return match_binders(u, alp, metas, na1$1, a2[0], match_(/* true */1, u, alp, metas, match_(/* true */1, u, alp, metas, sigma, b1$1, a2[1]), match$7[0], match$8[0]), match[3], a2[3]);
                    } else {
                      exit$4 = 6;
                    }
                    break;
                default:
                  exit = 1;
              }
            } else {
              exit$4 = 6;
            }
            if (exit$4 === 6) {
              switch (a2.tag | 0) {
                case 1 : 
                case 3 : 
                case 5 : 
                    exit$2 = 4;
                    break;
                case 8 : 
                    na1 = na1$1;
                    b1 = b1$1;
                    c1 = match[3];
                    na2 = a2[0];
                    b2 = a2[1];
                    c2 = a2[3];
                    exit = 2;
                    break;
                default:
                  exit = 1;
              }
            }
            break;
        case 8 : 
            var eqnl1 = match[3];
            var tml1 = match[2];
            switch (a2.tag | 0) {
              case 1 : 
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              case 9 : 
                  var eqnl2 = a2[3];
                  var tml2 = a2[2];
                  if (match[0] === a2[0] && Curry._1(Util$ReactTemplate.List[/* length */0], tml1) === Curry._1(Util$ReactTemplate.List[/* length */0], tml2)) {
                    var rtno1$prime = abstract_return_type_context_glob_constr(tml1, match[1]);
                    var rtno2$prime = abstract_return_type_context_notation_constr(tml2, a2[1]);
                    var sigma$7;
                    try {
                      sigma$7 = Option$ReactTemplate.fold_left2((function(alp){
                          return function (param, param$1, param$2) {
                            return match_(/* true */1, u, alp, metas, param, param$1, param$2);
                          }
                          }(alp)), sigma, rtno1$prime, rtno2$prime);
                    }
                    catch (exn$2){
                      if (exn$2 === Option$ReactTemplate.Heterogeneous) {
                        throw No_match;
                      } else {
                        throw exn$2;
                      }
                    }
                    var sigma$8 = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function(alp){
                        return function (s, param, param$1) {
                          return match_(/* true */1, u, alp, metas, s, param[0], param$1[0]);
                        }
                        }(alp)), sigma$7, tml1, tml2);
                    try {
                      return Curry._5(Util$ReactTemplate.List[/* fold_left2_set */85], No_match, (function(alp){
                                return function (param, param$1, param$2, param$3, param$4) {
                                  var u$1 = u;
                                  var alp$5 = alp;
                                  var metas$3 = metas;
                                  var sigma = param;
                                  var param$5 = param$1;
                                  var param$6 = param$2;
                                  var rest2 = param$4;
                                  var match = param$5[/* v */0];
                                  var allow_catchall = +(rest2 === /* [] */0 && match[0] === /* [] */0);
                                  var match$1 = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, param$1, param$2) {
                                          return match_cases_pattern_binders(allow_catchall, metas$3, param, param$1, param$2);
                                        }), /* tuple */[
                                        alp$5,
                                        sigma
                                      ], match[1], param$6[0]);
                                  return match_(/* true */1, u$1, match$1[0], metas$3, match$1[1], match[2], param$6[1]);
                                }
                                }(alp)), sigma$8, eqnl1, eqnl2);
                    }
                    catch (exn$3){
                      if (exn$3 === No_match) {
                        return Curry._5(Util$ReactTemplate.List[/* fold_left2_set */85], No_match, (function(alp){
                                  return function (param, param$1, param$2, param$3, param$4) {
                                    var u$1 = u;
                                    var alp$5 = alp;
                                    var metas$3 = metas;
                                    var sigma = param;
                                    var param$5 = param$1;
                                    var param$6 = param$2;
                                    var match = param$5[/* v */0];
                                    var match$1 = Curry._5(Util$ReactTemplate.List[/* fold_left2_set */85], No_match, (function (alp_sigma, patl1, patl2, _, _$1) {
                                            return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, param$1, param$2) {
                                                          return match_cases_pattern_binders(/* false */0, metas$3, param, param$1, param$2);
                                                        }), alp_sigma, patl1, patl2);
                                          }), /* tuple */[
                                          alp$5,
                                          sigma
                                        ], match[1], param$6[0]);
                                    return match_(/* true */1, u$1, match$1[0], metas$3, match$1[1], match[2], param$6[1]);
                                  }
                                  }(alp)), sigma$8, Detyping$ReactTemplate.factorize_eqns(eqnl1), Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                                          return /* tuple */[
                                                  /* :: */[
                                                    param[0],
                                                    /* [] */0
                                                  ],
                                                  param[1]
                                                ];
                                        }), eqnl2));
                      } else {
                        throw exn$3;
                      }
                    }
                  } else {
                    exit = 1;
                  }
                  break;
              default:
                exit = 1;
            }
            break;
        case 9 : 
            var match$9 = match[1];
            var na1$2 = match$9[0];
            var nal1 = match[0];
            switch (a2.tag | 0) {
              case 1 : 
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              case 10 : 
                  var match$10 = a2[1];
                  var na2$1 = match$10[0];
                  var nal2 = a2[0];
                  if (Curry._1(Util$ReactTemplate.List[/* length */0], nal1) === Curry._1(Util$ReactTemplate.List[/* length */0], nal2)) {
                    var sigma$9 = match_opt((function(alp,na1$2,na2$1){
                        return function (param, param$1, param$2) {
                          return match_binders(u, alp, metas, na1$2, na2$1, param, param$1, param$2);
                        }
                        }(alp,na1$2,na2$1)), sigma, match$9[1], match$10[1]);
                    var sigma$10 = match_(/* true */1, u, alp, metas, sigma$9, match[2], a2[2]);
                    var match$11 = Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, param$1, param$2) {
                            return match_names(metas, param, param$1, param$2);
                          }), /* tuple */[
                          alp,
                          sigma$10
                        ], nal1, nal2);
                    _a2 = a2[3];
                    _a1 = match[3];
                    _sigma = match$11[1];
                    _alp = match$11[0];
                    _inner = /* true */1;
                    continue ;
                    
                  } else {
                    exit = 1;
                  }
                  break;
              default:
                exit = 1;
            }
            break;
        case 10 : 
            var match$12 = match[1];
            var na1$3 = match$12[0];
            switch (a2.tag | 0) {
              case 1 : 
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              case 11 : 
                  var match$13 = a2[1];
                  var na2$2 = match$13[0];
                  var sigma$11 = match_opt((function(alp,na1$3,na2$2){
                      return function (param, param$1, param$2) {
                        return match_binders(u, alp, metas, na1$3, na2$2, param, param$1, param$2);
                      }
                      }(alp,na1$3,na2$2)), sigma, match$12[1], match$13[1]);
                  return Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function(alp){
                            return function (param, param$1, param$2) {
                              return match_(/* true */1, u, alp, metas, param, param$1, param$2);
                            }
                            }(alp)), sigma$11, /* :: */[
                              match[0],
                              /* :: */[
                                match[2],
                                /* :: */[
                                  match[3],
                                  /* [] */0
                                ]
                              ]
                            ], /* :: */[
                              a2[0],
                              /* :: */[
                                a2[2],
                                /* :: */[
                                  a2[3],
                                  /* [] */0
                                ]
                              ]
                            ]);
              default:
                exit = 1;
            }
            break;
        case 11 : 
            var dll1 = match[2];
            var idl1 = match[1];
            switch (a2.tag | 0) {
              case 1 : 
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              case 12 : 
                  var dll2 = a2[2];
                  var idl2 = a2[1];
                  if (match_fix_kind(match[0], a2[0]) && idl1.length === idl2.length && Util$ReactTemplate.$$Array[/* for_all2 */27]((function (l1, l2) {
                            return +(Curry._1(Util$ReactTemplate.List[/* length */0], l1) === Curry._1(Util$ReactTemplate.List[/* length */0], l2));
                          }), dll1, dll2)) {
                    var match$14 = Util$ReactTemplate.$$Array[/* fold_left2 */40](Curry._1(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, param$1, param$2) {
                                var alp = param[0];
                                var sigma = match_(/* true */1, u, alp, metas, match_opt((function (param, param$1, param$2) {
                                            return match_(/* true */1, u, alp, metas, param, param$1, param$2);
                                          }), param[1], param$1[2], param$2[1]), param$1[3], param$2[2]);
                                return match_names(metas, /* tuple */[
                                            alp,
                                            sigma
                                          ], param$1[0], param$2[0]);
                              })), /* tuple */[
                          alp,
                          sigma
                        ], dll1, dll2);
                    var alp$5 = match$14[0];
                    var sigma$12 = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function(alp$5){
                        return function (param, param$1, param$2) {
                          return match_(/* true */1, u, alp$5, metas, param, param$1, param$2);
                        }
                        }(alp$5)), match$14[1], match[3], a2[3]);
                    var match$15 = Util$ReactTemplate.$$Array[/* fold_right2 */39]((function (id1, id2, alsig) {
                            return match_names(metas, alsig, /* Name */[id1], /* Name */[id2]);
                          }), idl1, idl2, /* tuple */[
                          alp$5,
                          sigma$12
                        ]);
                    var alp$6 = match$15[0];
                    return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function(alp$6){
                              return function (param, param$1, param$2) {
                                return match_(/* true */1, u, alp$6, metas, param, param$1, param$2);
                              }
                              }(alp$6)), match$15[1], match[4], a2[4]);
                  } else {
                    exit = 1;
                  }
                  break;
              default:
                exit = 1;
            }
            break;
        case 12 : 
            var s1 = match[0];
            var exit$5 = 0;
            if (typeof s1 === "number") {
              exit$5 = 6;
            } else {
              switch (a2.tag | 0) {
                case 1 : 
                case 3 : 
                case 5 : 
                    exit$2 = 4;
                    break;
                case 13 : 
                    if (typeof a2[0] === "number") {
                      exit$5 = 6;
                    } else if (u) {
                      exit$5 = 6;
                    } else {
                      return sigma;
                    }
                    break;
                default:
                  exit = 1;
              }
            }
            if (exit$5 === 6) {
              switch (a2.tag | 0) {
                case 1 : 
                case 3 : 
                case 5 : 
                    exit$2 = 4;
                    break;
                case 13 : 
                    if (Miscops$ReactTemplate.glob_sort_eq(s1, a2[0])) {
                      return sigma;
                    } else {
                      exit = 1;
                    }
                    break;
                default:
                  exit = 1;
              }
            }
            break;
        case 2 : 
        case 13 : 
            exit$2 = 4;
            break;
        case 14 : 
            switch (a2.tag | 0) {
              case 1 : 
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              case 14 : 
                  var match_fun$2 = (function(alp){
                  return function match_fun$2(param, param$1, param$2) {
                    return match_(/* true */1, u, alp, metas, param, param$1, param$2);
                  }
                  }(alp));
                  var sigma$13 = match_(/* true */1, u, alp, metas, sigma, match[0], a2[0]);
                  var c1$1 = match[1];
                  var c2$1 = a2[1];
                  if (typeof c1$1 === "number") {
                    if (typeof c2$1 === "number") {
                      return sigma$13;
                    } else {
                      throw No_match;
                    }
                  } else if (c1$1.tag) {
                    if (typeof c2$1 === "number") {
                      throw No_match;
                    } else if (c2$1.tag) {
                      return Curry._3(match_fun$2, sigma$13, c1$1[0], c2$1[0]);
                    } else {
                      throw No_match;
                    }
                  } else if (typeof c2$1 === "number") {
                    throw No_match;
                  } else if (c2$1.tag) {
                    throw No_match;
                  } else {
                    return Curry._3(match_fun$2, sigma$13, c1$1[0], c2$1[0]);
                  }
              default:
                exit = 1;
            }
            break;
        case 15 : 
            switch (a2.tag | 0) {
              case 1 : 
              case 3 : 
              case 5 : 
                  exit$2 = 4;
                  break;
              case 15 : 
                  if (Names$ReactTemplate.Projection[/* equal */5](match[0], a2[0])) {
                    _a2 = a2[1];
                    _a1 = match[1];
                    _inner = /* true */1;
                    continue ;
                    
                  } else {
                    exit = 1;
                  }
                  break;
              default:
                exit = 1;
            }
            break;
        
      }
    }
    if (exit$2 === 4) {
      switch (a2.tag | 0) {
        case 1 : 
            var id2$2 = a2[0];
            if (is_onlybinding_pattern_like_meta(/* false */0, id2$2, metas)) {
              return bind_binding_as_term_env(alp, sigma, id2$2, a1);
            } else if (match.tag === 1) {
              var id2$3 = a2[0];
              if (is_onlybinding_strict_meta(id2$3, metas)) {
                throw No_match;
              } else if (is_onlybinding_meta(id2$3, metas)) {
                return bind_binding_as_term_env(alp, sigma, id2$3, a1);
              } else {
                exit$1 = 3;
              }
            } else {
              exit$1 = 3;
            }
            break;
        case 3 : 
            return sigma;
        case 5 : 
            var na = a2[0];
            if (na) {
              var t2 = a2[1];
              var id = na[0];
              var exit$6 = 0;
              switch (t2.tag | 0) {
                case 1 : 
                case 3 : 
                    exit$6 = 5;
                    break;
                default:
                  exit = 1;
              }
              if (exit$6 === 5) {
                if (inner) {
                  var avoid = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], Glob_ops$ReactTemplate.free_glob_vars(a1), Glob_ops$ReactTemplate.glob_visible_short_qualid(a1));
                  var id$prime = Namegen$ReactTemplate.next_ident_away(id, avoid);
                  var eta_000 = /* BinderType */Block.__(1, [/* Name */[id$prime]]);
                  var eta = /* GHole */Block.__(13, [
                      eta_000,
                      /* IntroAnonymous */0,
                      /* None */0
                    ]);
                  var t1$2 = DAst$ReactTemplate.make(/* None */0, eta);
                  var sigma$14;
                  switch (t2.tag | 0) {
                    case 1 : 
                        sigma$14 = bind_term_env(alp, sigma, t2[0], t1$2);
                        break;
                    case 3 : 
                        sigma$14 = sigma;
                        break;
                    default:
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "notation_ops.ml",
                              1212,
                              13
                            ]
                          ];
                  }
                  var match$16;
                  if (is_bindinglist_meta(id, metas)) {
                    var eta_000$1 = /* Name */[id$prime];
                    var eta$1 = /* GLocalAssum */Block.__(0, [
                        eta_000$1,
                        /* Explicit */0,
                        t1$2
                      ]);
                    match$16 = bind_bindinglist_env(alp, sigma$14, id, /* :: */[
                          DAst$ReactTemplate.make(/* None */0, eta$1),
                          /* [] */0
                        ]);
                  } else {
                    match$16 = match_names(metas, /* tuple */[
                          alp,
                          sigma$14
                        ], /* Name */[id$prime], na);
                  }
                  var eta$2 = /* GVar */Block.__(1, [id$prime]);
                  _a2 = a2[2];
                  _a1 = Glob_ops$ReactTemplate.mkGApp(/* None */0, a1, DAst$ReactTemplate.make(/* None */0, eta$2));
                  _sigma = match$16[1];
                  _alp = match$16[0];
                  _inner = /* true */1;
                  continue ;
                  
                } else {
                  exit = 1;
                }
              }
              
            } else {
              exit = 1;
            }
            break;
        default:
          exit = 1;
      }
    }
    if (exit$1 === 3) {
      var id2$4 = a2[0];
      if (is_bindinglist_meta(id2$4, metas)) {
        return bind_term_env(alp, sigma, id2$4, a1);
      } else {
        exit = 1;
      }
    }
    switch (exit) {
      case 1 : 
          if (match.tag === 1) {
            if (a2.tag === 1) {
              if (alpha_var(match[0], a2[0], alp[0])) {
                return sigma;
              } else {
                throw No_match;
              }
            } else {
              throw No_match;
            }
          } else {
            throw No_match;
          }
          break;
      case 2 : 
          return match_binders(u, alp, metas, na1, na2, match_(/* true */1, u, alp, metas, sigma, b1, b2), c1, c2);
      
    }
  };
}

function match_binders(u, alp, metas, na1, na2, sigma, b1, b2) {
  var match = match_names(metas, /* tuple */[
        alp,
        sigma
      ], na1, na2);
  return match_(/* true */1, u, match[0], metas, match[1], b1, b2);
}

function match_extended_binders(loc, isprod, u, alp, metas, na1, na2, bk, t, sigma, b1, b2) {
  var match = Util$ReactTemplate.set_temporary_memory(/* () */0);
  var get = match[1];
  var store = match[0];
  var match$1 = DAst$ReactTemplate.get(b1);
  var exit = 0;
  var exit$1 = 0;
  if (na1) {
    if (match$1.tag === 8) {
      if (match$1[0] !== 2) {
        exit$1 = 2;
      } else if (match$1[1]) {
        exit$1 = 2;
      } else {
        var match$2 = match$1[2];
        if (match$2) {
          if (match$2[1]) {
            exit$1 = 2;
          } else {
            var eqns = match$1[3];
            if (eqns) {
              if (na2) {
                var id = na2[0];
                var e = match$2[0][0];
                var p = na1[0];
                if (is_gvar(p, e) && is_bindinglist_meta(id, metas) && Curry._1(Util$ReactTemplate.List[/* length */0], Curry._1(store, Detyping$ReactTemplate.factorize_eqns(eqns))) === 1) {
                  var match$3 = Curry._1(get, /* () */0);
                  if (match$3) {
                    if (match$3[1]) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "notation_ops.ml",
                              1249,
                              12
                            ]
                          ];
                    } else {
                      var match$4 = match$3[0][/* v */0];
                      var b1$1 = match$4[2];
                      var disjpat = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                              if (param) {
                                if (param[1]) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "notation_ops.ml",
                                          1245,
                                          58
                                        ]
                                      ];
                                } else {
                                  return param[0];
                                }
                              } else {
                                throw [
                                      Caml_builtin_exceptions.assert_failure,
                                      [
                                        "notation_ops.ml",
                                        1245,
                                        58
                                      ]
                                    ];
                              }
                            }), match$4[1]);
                      var disjpat$1 = Glob_ops$ReactTemplate.occur_glob_constr(p)(b1$1) ? Curry._2(Util$ReactTemplate.List[/* map */10], Glob_ops$ReactTemplate.set_pat_alias(p), disjpat) : disjpat;
                      var match$5 = bind_bindinglist_env(alp, sigma, id, /* :: */[
                            DAst$ReactTemplate.make(loc, /* GLocalPattern */Block.__(2, [
                                    /* tuple */[
                                      disjpat$1,
                                      match$4[0]
                                    ],
                                    p,
                                    bk,
                                    t
                                  ])),
                            /* [] */0
                          ]);
                      return match_(/* true */1, u, match$5[0], metas, match$5[1], b1$1, b2);
                    }
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "notation_ops.ml",
                            1249,
                            12
                          ]
                        ];
                  }
                } else if (is_gvar(p, e) && is_onlybinding_pattern_like_meta(/* false */0, id, metas) && Curry._1(Util$ReactTemplate.List[/* length */0], Curry._1(store, Detyping$ReactTemplate.factorize_eqns(eqns))) === 1) {
                  var match$6 = Curry._1(get, /* () */0);
                  if (match$6) {
                    if (match$6[1]) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "notation_ops.ml",
                              1258,
                              12
                            ]
                          ];
                    } else {
                      var match$7 = match$6[0][/* v */0];
                      var b1$2 = match$7[2];
                      var disjpat$2 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                              if (param) {
                                if (param[1]) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        [
                                          "notation_ops.ml",
                                          1254,
                                          58
                                        ]
                                      ];
                                } else {
                                  return param[0];
                                }
                              } else {
                                throw [
                                      Caml_builtin_exceptions.assert_failure,
                                      [
                                        "notation_ops.ml",
                                        1254,
                                        58
                                      ]
                                    ];
                              }
                            }), match$7[1]);
                      var disjpat$3 = Glob_ops$ReactTemplate.occur_glob_constr(p)(b1$2) ? Curry._2(Util$ReactTemplate.List[/* map */10], Glob_ops$ReactTemplate.set_pat_alias(p), disjpat$2) : disjpat$2;
                      var match$8 = bind_binding_env(alp, sigma, id, disjpat$3);
                      return match_(/* true */1, u, match$8[0], metas, match$8[1], b1$2, b2);
                    }
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "notation_ops.ml",
                            1258,
                            12
                          ]
                        ];
                  }
                } else {
                  exit$1 = 2;
                }
              } else {
                exit = 1;
              }
            } else {
              exit$1 = 2;
            }
          }
        } else {
          exit$1 = 2;
        }
      }
    } else {
      exit$1 = 2;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    if (na2) {
      var id$1 = na2[0];
      if (is_bindinglist_meta(id$1, metas) && (!isprod || na1 !== /* Anonymous */0)) {
        var match$9 = bind_bindinglist_env(alp, sigma, id$1, /* :: */[
              DAst$ReactTemplate.make(loc, /* GLocalAssum */Block.__(0, [
                      na1,
                      bk,
                      t
                    ])),
              /* [] */0
            ]);
        return match_(/* true */1, u, match$9[0], metas, match$9[1], b1, b2);
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    var match$10 = match_names(metas, /* tuple */[
          alp,
          sigma
        ], na1, na2);
    return match_(/* true */1, u, match$10[0], metas, match$10[1], b1, b2);
  }
  
}

function match_notation_constr(u, c, param) {
  var metas = param[0];
  var match = match_(/* false */0, u, /* tuple */[
        /* [] */0,
        /* [] */0
      ], metas, /* tuple */[
        /* [] */0,
        /* [] */0,
        /* [] */0,
        /* [] */0
      ], c, param[1]);
  var binderlists = match[3];
  var binders = match[2];
  var termlists = match[1];
  var terms = match[0];
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                var binderlists$prime = param$1[3];
                var binders$prime = param$1[2];
                var termlists$prime = param$1[1];
                var terms$prime = param$1[0];
                var match = param[1];
                var typ = match[1];
                var scl = match[0];
                var x = param[0];
                if (typeof typ === "number") {
                  switch (typ) {
                    case 0 : 
                        var term;
                        try {
                          term = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], x, terms);
                        }
                        catch (exn){
                          if (exn === Caml_builtin_exceptions.not_found) {
                            throw No_match;
                          } else {
                            throw exn;
                          }
                        }
                        return /* tuple */[
                                /* :: */[
                                  /* tuple */[
                                    term,
                                    scl
                                  ],
                                  terms$prime
                                ],
                                termlists$prime,
                                binders$prime,
                                binderlists$prime
                              ];
                    case 1 : 
                        return /* tuple */[
                                terms$prime,
                                /* :: */[
                                  /* tuple */[
                                    Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], x, termlists),
                                    scl
                                  ],
                                  termlists$prime
                                ],
                                binders$prime,
                                binderlists$prime
                              ];
                    case 2 : 
                        var bl;
                        try {
                          bl = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], x, binderlists);
                        }
                        catch (exn$1){
                          if (exn$1 === Caml_builtin_exceptions.not_found) {
                            throw No_match;
                          } else {
                            throw exn$1;
                          }
                        }
                        return /* tuple */[
                                terms$prime,
                                termlists$prime,
                                binders$prime,
                                /* :: */[
                                  /* tuple */[
                                    bl,
                                    scl
                                  ],
                                  binderlists$prime
                                ]
                              ];
                    
                  }
                } else {
                  var exit = 0;
                  var tmp = typ[0];
                  if (typeof tmp === "number") {
                    exit = 1;
                  } else if (tmp.tag) {
                    var match$1 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], x, binders);
                    if (match$1) {
                      if (match$1[1]) {
                        throw No_match;
                      } else {
                        var v = Glob_ops$ReactTemplate.glob_constr_of_cases_pattern(match$1[0]);
                        return /* tuple */[
                                /* :: */[
                                  /* tuple */[
                                    v,
                                    scl
                                  ],
                                  terms$prime
                                ],
                                termlists$prime,
                                binders$prime,
                                binderlists$prime
                              ];
                      }
                    } else {
                      throw No_match;
                    }
                  } else {
                    exit = 1;
                  }
                  if (exit === 1) {
                    return /* tuple */[
                            terms$prime,
                            termlists$prime,
                            /* :: */[
                              /* tuple */[
                                Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], x, binders),
                                scl
                              ],
                              binders$prime
                            ],
                            binderlists$prime
                          ];
                  }
                  
                }
              }), metas, /* tuple */[
              /* [] */0,
              /* [] */0,
              /* [] */0,
              /* [] */0
            ]);
}

function bind_env_cases_pattern(sigma, $$var, v) {
  var terms = sigma[0];
  try {
    var vvar = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], $$var, terms);
    if (cases_pattern_eq(v, vvar)) {
      return sigma;
    } else {
      throw No_match;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* tuple */[
              /* :: */[
                /* tuple */[
                  $$var,
                  v
                ],
                terms
              ],
              sigma[1],
              sigma[2],
              sigma[3]
            ];
    } else {
      throw exn;
    }
  }
}

function match_cases_pattern_list(match_fun, metas, sigma, rest, x, y, iter, termin, revert) {
  var aux = function (sigma, acc, rest) {
    try {
      var metas$1 = add_ldots_var(add_meta_term(y, metas));
      var sigma$1 = Curry._4(match_fun, metas$1, sigma, rest, iter);
      var terms = sigma$1[0];
      var rest$1 = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], ldots_var, terms);
      var t = Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], y, terms);
      var sigma$2 = remove_sigma(y, remove_sigma(ldots_var, sigma$1));
      return aux(sigma$2, /* :: */[
                  t,
                  acc
                ], rest$1);
    }
    catch (exn){
      if (exn === No_match) {
        if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], acc)) {
          throw exn;
        } else {
          return /* tuple */[
                  acc,
                  Curry._4(match_fun, metas, sigma, rest, termin)
                ];
        }
      } else {
        throw exn;
      }
    }
  };
  var match = aux(sigma, /* [] */0, rest);
  var sigma$1 = match[1];
  var l = match[0];
  return /* tuple */[
          sigma$1[0],
          /* :: */[
            /* tuple */[
              x,
              revert ? l : Curry._1(Util$ReactTemplate.List[/* rev */4], l)
            ],
            sigma$1[1]
          ],
          sigma$1[2],
          sigma$1[3]
        ];
}

function match_cases_pattern(metas, sigma, a1, a2) {
  var match = DAst$ReactTemplate.get(a1);
  var exit = 0;
  switch (a2.tag | 0) {
    case 1 : 
        var id2 = a2[0];
        if (Curry._2(Names$ReactTemplate.Id[/* List */12][/* mem_assoc */3], id2, metas)) {
          return /* tuple */[
                  bind_env_cases_pattern(sigma, id2, a1),
                  /* tuple */[
                    0,
                    /* [] */0
                  ]
                ];
        } else {
          throw No_match;
        }
        break;
    case 0 : 
    case 2 : 
    case 3 : 
        exit = 1;
        break;
    case 4 : 
        return /* tuple */[
                match_cases_pattern_list(match_cases_pattern_no_more_args, metas, /* tuple */[
                      sigma[0],
                      sigma[1],
                      /* () */0,
                      /* () */0
                    ], a1, a2[0], a2[1], a2[2], a2[3], a2[4]),
                /* tuple */[
                  0,
                  /* [] */0
                ]
              ];
    default:
      throw No_match;
  }
  if (exit === 1) {
    if (match.tag) {
      var largs = match[1];
      var r1 = match[0];
      switch (a2.tag | 0) {
        case 0 : 
            var match$1 = a2[0];
            if (match$1.tag === 3) {
              if (Names$ReactTemplate.eq_constructor(r1, match$1[0])) {
                var l;
                try {
                  l = Glob_ops$ReactTemplate.add_patterns_for_params_remove_local_defs(r1, largs);
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    throw No_match;
                  } else {
                    throw exn;
                  }
                }
                return /* tuple */[
                        sigma,
                        /* tuple */[
                          0,
                          l
                        ]
                      ];
              } else {
                throw No_match;
              }
            } else {
              throw No_match;
            }
            break;
        case 2 : 
            var match$2 = a2[0];
            if (match$2.tag) {
              throw No_match;
            } else {
              var match$3 = match$2[0];
              if (match$3.tag === 3) {
                var l2 = a2[1];
                if (Names$ReactTemplate.eq_constructor(r1, match$3[0])) {
                  var l1;
                  try {
                    l1 = Glob_ops$ReactTemplate.add_patterns_for_params_remove_local_defs(r1, largs);
                  }
                  catch (exn$1){
                    if (exn$1 === Caml_builtin_exceptions.not_found) {
                      throw No_match;
                    } else {
                      throw exn$1;
                    }
                  }
                  var le2 = Curry._1(Util$ReactTemplate.List[/* length */0], l2);
                  if (le2 === 0 || le2 > Curry._1(Util$ReactTemplate.List[/* length */0], l1)) {
                    throw No_match;
                  } else {
                    var match$4 = Curry._2(Util$ReactTemplate.List[/* chop */99], le2, l1);
                    return /* tuple */[
                            Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, param$1, param$2) {
                                    return match_cases_pattern_no_more_args(metas, param, param$1, param$2);
                                  }), sigma, match$4[0], l2),
                            /* tuple */[
                              le2,
                              match$4[1]
                            ]
                          ];
                  }
                } else {
                  throw No_match;
                }
              } else {
                throw No_match;
              }
            }
            break;
        case 3 : 
            throw No_match;
        
      }
    } else if (match[0]) {
      throw No_match;
    } else {
      switch (a2.tag | 0) {
        case 0 : 
        case 2 : 
            throw No_match;
        case 3 : 
            return /* tuple */[
                    sigma,
                    /* tuple */[
                      0,
                      /* [] */0
                    ]
                  ];
        
      }
    }
  }
  
}

function match_cases_pattern_no_more_args(metas, sigma, a1, a2) {
  var match = match_cases_pattern(metas, sigma, a1, a2);
  if (match[1][1]) {
    throw No_match;
  } else {
    return match[0];
  }
}

function match_ind_pattern(metas, sigma, ind, pats, a2) {
  switch (a2.tag | 0) {
    case 0 : 
        var match = a2[0];
        if (match.tag === 2) {
          if (Names$ReactTemplate.eq_ind(ind, match[0])) {
            return /* tuple */[
                    sigma,
                    /* tuple */[
                      0,
                      pats
                    ]
                  ];
          } else {
            throw No_match;
          }
        } else {
          throw No_match;
        }
        break;
    case 2 : 
        var match$1 = a2[0];
        if (match$1.tag) {
          throw No_match;
        } else {
          var match$2 = match$1[0];
          if (match$2.tag === 2) {
            var l2 = a2[1];
            if (Names$ReactTemplate.eq_ind(ind, match$2[0])) {
              var le2 = Curry._1(Util$ReactTemplate.List[/* length */0], l2);
              if (le2 === 0 || le2 > Curry._1(Util$ReactTemplate.List[/* length */0], pats)) {
                throw No_match;
              } else {
                var match$3 = Curry._2(Util$ReactTemplate.List[/* chop */99], le2, pats);
                return /* tuple */[
                        Curry._4(Util$ReactTemplate.List[/* fold_left2 */18], (function (param, param$1, param$2) {
                                return match_cases_pattern_no_more_args(metas, param, param$1, param$2);
                              }), sigma, match$3[0], l2),
                        /* tuple */[
                          le2,
                          match$3[1]
                        ]
                      ];
              }
            } else {
              throw No_match;
            }
          } else {
            throw No_match;
          }
        }
        break;
    default:
      throw No_match;
  }
}

function reorder_canonically_substitution(terms, termlists, metas) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
                var match = param[1];
                var typ = match[1];
                if (typeof typ === "number") {
                  var termlists$prime = param$1[1];
                  var terms$prime = param$1[0];
                  var scl = match[0];
                  var x = param[0];
                  switch (typ) {
                    case 0 : 
                        return /* tuple */[
                                /* :: */[
                                  /* tuple */[
                                    Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], x, terms),
                                    scl
                                  ],
                                  terms$prime
                                ],
                                termlists$prime
                              ];
                    case 1 : 
                        return /* tuple */[
                                terms$prime,
                                /* :: */[
                                  /* tuple */[
                                    Curry._2(Names$ReactTemplate.Id[/* List */12][/* assoc */2], x, termlists),
                                    scl
                                  ],
                                  termlists$prime
                                ]
                              ];
                    case 2 : 
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "notation_ops.ml",
                                1382,
                                29
                              ]
                            ];
                    
                  }
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "notation_ops.ml",
                          1380,
                          27
                        ]
                      ];
                }
              }), metas, /* tuple */[
              /* [] */0,
              /* [] */0
            ]);
}

function match_notation_constr_cases_pattern(c, param) {
  var metas = param[0];
  var match = match_cases_pattern(metas, /* tuple */[
        /* [] */0,
        /* [] */0,
        /* () */0,
        /* () */0
      ], c, param[1]);
  var match$1 = match[0];
  return /* tuple */[
          reorder_canonically_substitution(match$1[0], match$1[1], metas),
          match[1]
        ];
}

function match_notation_constr_ind_pattern(ind, args, param) {
  var metas = param[0];
  var match = match_ind_pattern(metas, /* tuple */[
        /* [] */0,
        /* [] */0,
        /* () */0,
        /* () */0
      ], ind, args, param[1]);
  var match$1 = match[0];
  return /* tuple */[
          reorder_canonically_substitution(match$1[0], match$1[1], metas),
          match[1]
        ];
}

exports.eq_notation_constr = eq_notation_constr;
exports.subst_interpretation = subst_interpretation;
exports.ldots_var = ldots_var;
exports.notation_constr_of_glob_constr = notation_constr_of_glob_constr;
exports.apply_cases_pattern = apply_cases_pattern;
exports.glob_constr_of_notation_constr_with_binders = glob_constr_of_notation_constr_with_binders;
exports.glob_constr_of_notation_constr = glob_constr_of_notation_constr;
exports.No_match = No_match;
exports.match_notation_constr = match_notation_constr;
exports.match_notation_constr_cases_pattern = match_notation_constr_cases_pattern;
exports.match_notation_constr_ind_pattern = match_notation_constr_ind_pattern;
/* ldots_var Not a pure module */
