// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Rtree$ReactTemplate = require("./rtree.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var UGraph$ReactTemplate = require("./uGraph.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Typeops$ReactTemplate = require("./typeops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");
var Declareops$ReactTemplate = require("./declareops.bs.js");

var indices_matter = [/* false */0];

function enforce_indices_matter() {
  indices_matter[0] = /* true */1;
  return /* () */0;
}

function is_indices_matter() {
  return indices_matter[0];
}

function weaker_noccur_between(env, x, nvars, t) {
  if (Vars$ReactTemplate.noccur_between(x, nvars, t)) {
    return /* Some */[t];
  } else {
    var t$prime = Reduction$ReactTemplate.whd_all(env, t);
    if (Vars$ReactTemplate.noccur_between(x, nvars, t$prime)) {
      return /* Some */[t$prime];
    } else {
      return /* None */0;
    }
  }
}

var InductiveError = Caml_exceptions.create("Indtypes-ReactTemplate.InductiveError");

function check(_idset, _param) {
  while(true) {
    var param = _param;
    var idset = _idset;
    if (param) {
      var c = param[0];
      if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], c, idset)) {
        throw [
              InductiveError,
              /* SameNamesConstructors */Block.__(5, [c])
            ];
      } else {
        _param = param[1];
        _idset = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], c, idset);
        continue ;
        
      }
    } else {
      return idset;
    }
  };
}

function mind_check_names(mie) {
  var _indset = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var _cstset = Names$ReactTemplate.Id[/* Set */9][/* empty */0];
  var _param = mie[/* mind_entry_inds */3];
  while(true) {
    var param = _param;
    var cstset = _cstset;
    var indset = _indset;
    if (param) {
      var ind = param[0];
      var id = ind[/* mind_entry_typename */0];
      var cl = ind[/* mind_entry_consnames */3];
      if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id, indset)) {
        throw [
              InductiveError,
              /* SameNamesTypes */Block.__(4, [id])
            ];
      } else {
        var cstset$prime = check(cstset, cl);
        _param = param[1];
        _cstset = cstset$prime;
        _indset = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], id, indset);
        continue ;
        
      }
    } else {
      return /* () */0;
    }
  };
}

function is_unit(constrsinfos) {
  if (constrsinfos) {
    if (constrsinfos[1]) {
      return /* false */0;
    } else {
      return Univ$ReactTemplate.is_type0m_univ(constrsinfos[0]);
    }
  } else {
    return /* true */1;
  }
}

function infer_constructor_packet(env_ar_par, params, lc) {
  var jlc = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return Typeops$ReactTemplate.infer_type(env_ar_par, param);
        }), lc);
  var jlc$1 = Util$ReactTemplate.$$Array[/* of_list */10](jlc);
  var lc$prime$prime = Util$ReactTemplate.$$Array[/* map */12]((function (j) {
          return Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, j[/* utj_val */0], params);
        }), jlc$1);
  var levels = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          var env = env_ar_par;
          var t = param;
          var _env = env;
          var _t = t;
          var _max = Univ$ReactTemplate.Universe[/* type0m */12];
          while(true) {
            var max = _max;
            var t$1 = _t;
            var env$1 = _env;
            var t$2 = Reduction$ReactTemplate.whd_all(env$1, t$1);
            var match = Constr$ReactTemplate.kind(t$2);
            if (match.tag === 6) {
              var varj = Typeops$ReactTemplate.infer_type(env$1, match[1]);
              var env1 = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                      match[0],
                      varj[/* utj_val */0]
                    ]), env$1);
              var max$1 = Univ$ReactTemplate.Universe[/* sup */11](max, Sorts$ReactTemplate.univ_of_sort(varj[/* utj_type */1]));
              _max = max$1;
              _t = match[2];
              _env = env1;
              continue ;
              
            } else {
              Constr$ReactTemplate.isRel(Constr$ReactTemplate.decompose_app(t$2)[0]);
              return max;
            }
          };
        }), lc);
  var isunit = is_unit(levels);
  var min = jlc$1.length > 1 ? Univ$ReactTemplate.Universe[/* type0 */13] : Univ$ReactTemplate.Universe[/* type0m */12];
  var level = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (max, l) {
          return Univ$ReactTemplate.Universe[/* sup */11](max, l);
        }), min, levels);
  return /* tuple */[
          lc$prime$prime,
          /* tuple */[
            isunit,
            level
          ]
        ];
}

function cumulate_arity_large_levels(env, sign) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (d, param) {
                  var env = param[1];
                  var lev = param[0];
                  if (d.tag) {
                    return /* tuple */[
                            lev,
                            Environ$ReactTemplate.push_rel(d, env)
                          ];
                  } else {
                    var tj = Typeops$ReactTemplate.infer_type(env, d[1]);
                    var u = Sorts$ReactTemplate.univ_of_sort(tj[/* utj_type */1]);
                    return /* tuple */[
                            Univ$ReactTemplate.Universe[/* sup */11](u, lev),
                            Environ$ReactTemplate.push_rel(d, env)
                          ];
                  }
                }), sign, /* tuple */[
                Univ$ReactTemplate.Universe[/* type0m */12],
                env
              ])[0];
}

function is_impredicative(env, u) {
  if (Univ$ReactTemplate.is_type0m_univ(u)) {
    return /* true */1;
  } else if (Univ$ReactTemplate.is_type0_univ(u)) {
    return Environ$ReactTemplate.is_impredicative_set(env);
  } else {
    return /* false */0;
  }
}

function param_ccls(paramsctxt) {
  var fold = function (acc, param) {
    if (param.tag) {
      return acc;
    } else {
      var c = Term$ReactTemplate.strip_prod_assum(param[1]);
      var match = Constr$ReactTemplate.kind(c);
      var tmp;
      if (match.tag === 4) {
        var match$1 = match[0];
        tmp = match$1.tag ? Univ$ReactTemplate.Universe[/* level */8](match$1[0]) : /* None */0;
      } else {
        tmp = /* None */0;
      }
      return /* :: */[
              tmp,
              acc
            ];
    }
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, /* [] */0, paramsctxt);
}

function check_subtyping_arity_constructor(env, subst, arcn, numparams, is_arity) {
  var numchecked = [0];
  var basic_check = function (ev, tp) {
    if (numchecked[0] >= numparams) {
      Curry._2(Reduction$ReactTemplate.conv_leq(/* None */0, /* None */0, ev, /* None */0), tp, Curry._1(subst, tp));
    }
    numchecked[0] = numchecked[0] + 1 | 0;
    return /* () */0;
  };
  var check_typ = function (typ, typ_env) {
    if (typ.tag) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str(""));
    } else {
      try {
        basic_check(typ_env, typ[1]);
        return Environ$ReactTemplate.push_rel(typ, typ_env);
      }
      catch (exn){
        if (exn === Reduction$ReactTemplate.NotConvertible) {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["bad inductive subtyping relation"], Pp$ReactTemplate.str("Invalid subtyping relation"));
        } else {
          throw exn;
        }
      }
    }
  };
  var match = Reduction$ReactTemplate.dest_prod(env)(arcn);
  var last_env = Context$ReactTemplate.Rel[/* fold_outside */10](check_typ, match[0], env);
  if (is_arity) {
    return /* () */0;
  } else {
    return basic_check(last_env, match[1]);
  }
}

function check_subtyping(cumi, paramsctxt, env_ar, inds) {
  var numparams = Context$ReactTemplate.Rel[/* nhyps */5](paramsctxt);
  var uctx = Univ$ReactTemplate.CumulativityInfo[/* univ_context */3](cumi);
  var partial_arg = Names$ReactTemplate.DirPath[/* empty */5];
  var partial_arg$1 = Univ$ReactTemplate.Level[/* make */8];
  var new_levels = Util$ReactTemplate.$$Array[/* init */0](Univ$ReactTemplate.UContext[/* size */7](uctx), (function (param) {
          return partial_arg$1(partial_arg, param);
        }));
  var lmap = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (lmap, u, u$prime) {
          return Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, u$prime, lmap);
        }), Univ$ReactTemplate.LMap[/* empty */0], Univ$ReactTemplate.Instance[/* to_array */3](Univ$ReactTemplate.UContext[/* instance */3](uctx)), new_levels);
  var dosubst = function (param) {
    return Vars$ReactTemplate.subst_univs_level_constr(lmap, param);
  };
  var instance_other = Univ$ReactTemplate.Instance[/* of_array */2](new_levels);
  var constraints_other = Univ$ReactTemplate.subst_univs_level_constraints(lmap, Univ$ReactTemplate.UContext[/* constraints */4](uctx));
  var uctx_other = Univ$ReactTemplate.UContext[/* make */0](/* tuple */[
        instance_other,
        constraints_other
      ]);
  var env = Environ$ReactTemplate.push_context(/* None */0, uctx, env_ar);
  var env$1 = Environ$ReactTemplate.push_context(/* None */0, uctx_other, env);
  var subtyp_constraints = Univ$ReactTemplate.CumulativityInfo[/* leq_constraints */6](cumi, Univ$ReactTemplate.UContext[/* instance */3](uctx), instance_other, Univ$ReactTemplate.Constraint[/* empty */0]);
  var env$2 = Environ$ReactTemplate.add_constraints(subtyp_constraints, env$1);
  return Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                var arity = param[3][1];
                if (arity.tag) {
                  return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["check_subtyping"], Pp$ReactTemplate.str("template polymorphism and cumulative polymorphism are not compatible"));
                } else {
                  check_subtyping_arity_constructor(env$2, dosubst, arity[0][1], numparams, /* true */1);
                  return Util$ReactTemplate.$$Array[/* iter */11]((function (cnt) {
                                return check_subtyping_arity_constructor(env$2, dosubst, cnt, numparams, /* false */0);
                              }), param[2]);
                }
              }), inds);
}

function typecheck_inductive(env, mie) {
  var match = mie[/* mind_entry_inds */3];
  if (!match) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("empty inductive types declaration."));
  }
  mind_check_names(mie);
  var match$1 = mie[/* mind_entry_universes */4];
  var env$prime;
  switch (match$1.tag | 0) {
    case 0 : 
        env$prime = Environ$ReactTemplate.push_context_set(/* None */0, match$1[0], env);
        break;
    case 1 : 
        env$prime = Environ$ReactTemplate.push_context(/* None */0, match$1[0], env);
        break;
    case 2 : 
        env$prime = Environ$ReactTemplate.push_context(/* None */0, Univ$ReactTemplate.CumulativityInfo[/* univ_context */3](match$1[0]), env);
        break;
    
  }
  var match$2 = Typeops$ReactTemplate.infer_local_decls(env$prime, mie[/* mind_entry_params */2]);
  var paramsctxt = match$2[1];
  var env_params = match$2[0];
  var match$3 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, ind) {
          var expltype = ind[/* mind_entry_template */2];
          var arity;
          if (Term$ReactTemplate.isArity(ind[/* mind_entry_arity */1])) {
            var match = Reduction$ReactTemplate.dest_arity(env_params, ind[/* mind_entry_arity */1]);
            var s = match[1];
            if (s.tag) {
              if (Univ$ReactTemplate.universe_level(s[0])) {
                arity = Typeops$ReactTemplate.infer_type(env_params, ind[/* mind_entry_arity */1])[/* utj_val */0];
              } else {
                var proparity = Typeops$ReactTemplate.infer_type(env_params, Term$ReactTemplate.mkArity(/* tuple */[
                          match[0],
                          Sorts$ReactTemplate.prop
                        ]));
                var match$1 = Term$ReactTemplate.destArity(proparity[/* utj_val */0]);
                arity = Term$ReactTemplate.mkArity(/* tuple */[
                      match$1[0],
                      s
                    ]);
              }
            } else {
              arity = Typeops$ReactTemplate.infer_type(env_params, ind[/* mind_entry_arity */1])[/* utj_val */0];
            }
          } else {
            arity = Typeops$ReactTemplate.infer_type(env_params, ind[/* mind_entry_arity */1])[/* utj_val */0];
          }
          var match$2 = Reduction$ReactTemplate.dest_arity(env_params, arity);
          var sign = match$2[0];
          var inflev = indices_matter[0] ? /* Some */[cumulate_arity_large_levels(env_params, sign)] : /* None */0;
          var full_arity = Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, arity, paramsctxt);
          var id = ind[/* mind_entry_typename */0];
          var env_ar$prime = Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  /* Name */[id],
                  full_arity
                ]), param[0]);
          return /* tuple */[
                  env_ar$prime,
                  /* :: */[
                    /* tuple */[
                      id,
                      full_arity,
                      Util$ReactTemplate.$at(sign, paramsctxt),
                      expltype,
                      match$2[1],
                      inflev
                    ],
                    param[1]
                  ]
                ];
        }), /* tuple */[
        env$prime,
        /* [] */0
      ], mie[/* mind_entry_inds */3]);
  var env_arities = match$3[0];
  var arity_list = Curry._1(Util$ReactTemplate.List[/* rev */4], match$3[1]);
  var env_ar_par = Environ$ReactTemplate.push_rel_context(paramsctxt, env_arities);
  var inds = Curry._4(Util$ReactTemplate.List[/* fold_right2 */19], (function (ind, arity_data, inds) {
          var match = infer_constructor_packet(env_ar_par, paramsctxt, ind[/* mind_entry_lc */4]);
          var consnames = ind[/* mind_entry_consnames */3];
          var ind$prime_002 = match[0];
          var ind$prime_003 = match[1];
          var ind$prime = /* tuple */[
            arity_data,
            consnames,
            ind$prime_002,
            ind$prime_003
          ];
          return /* :: */[
                  ind$prime,
                  inds
                ];
        }), mie[/* mind_entry_inds */3], arity_list, /* [] */0);
  var inds$1 = Util$ReactTemplate.$$Array[/* of_list */10](inds);
  var inds$2 = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
          var clev = param[3][1];
          var match = param[0];
          var inf_level = match[5];
          var def_level = match[4];
          var expltype = match[3];
          var full_arity = match[1];
          var infu = inf_level ? Univ$ReactTemplate.Universe[/* sup */11](clev, inf_level[0]) : clev;
          var full_polymorphic = function () {
            var defu = Sorts$ReactTemplate.univ_of_sort(def_level);
            var is_natural = Environ$ReactTemplate.type_in_type(env) || UGraph$ReactTemplate.check_leq(Environ$ReactTemplate.universes(env$prime), infu, defu);
            if (!is_impredicative(env, defu)) {
              if (is_natural) {
                
              } else {
                CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["check_inductive"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incorrect universe "), Univ$ReactTemplate.Universe[/* pr */4](defu)), Pp$ReactTemplate.str(" declared for inductive type, inferred level is ")), Univ$ReactTemplate.Universe[/* pr */4](infu)), Pp$ReactTemplate.str(".")));
              }
            }
            return /* RegularArity */Block.__(0, [/* tuple */[
                        1 - is_natural,
                        full_arity,
                        defu
                      ]]);
          };
          var template_polymorphic = function () {
            var match;
            try {
              match = Reduction$ReactTemplate.dest_arity(env, full_arity);
            }
            catch (exn){
              if (exn === Reduction$ReactTemplate.NotArity) {
                throw [
                      InductiveError,
                      /* NotAnArity */Block.__(7, [
                          env,
                          full_arity
                        ])
                    ];
              } else {
                throw exn;
              }
            }
            var s = match[1];
            if (s.tag) {
              if (expltype) {
                var u = s[0];
                var b = Environ$ReactTemplate.type_in_type(env) || UGraph$ReactTemplate.check_leq(Environ$ReactTemplate.universes(env$prime), infu, u);
                if (b) {
                  return /* TemplateArity */Block.__(1, [/* tuple */[
                              param_ccls(paramsctxt),
                              infu
                            ]]);
                } else {
                  return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["check_inductive"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Incorrect universe "), Univ$ReactTemplate.Universe[/* pr */4](u)), Pp$ReactTemplate.str(" declared for inductive type, inferred level is ")), Univ$ReactTemplate.Universe[/* pr */4](clev)), Pp$ReactTemplate.str(".")));
                }
              } else {
                return full_polymorphic(/* () */0);
              }
            } else {
              return full_polymorphic(/* () */0);
            }
          };
          var match$1 = mie[/* mind_entry_universes */4];
          var arity;
          switch (match$1.tag | 0) {
            case 0 : 
                arity = template_polymorphic(/* () */0);
                break;
            case 1 : 
            case 2 : 
                arity = full_polymorphic(/* () */0);
                break;
            
          }
          return /* tuple */[
                  match[0],
                  param[1],
                  param[2],
                  /* tuple */[
                    match[2],
                    arity
                  ]
                ];
        }), inds$1);
  var match$4 = mie[/* mind_entry_universes */4];
  switch (match$4.tag | 0) {
    case 0 : 
    case 1 : 
        break;
    case 2 : 
        check_subtyping(match$4[0], paramsctxt, env_arities, inds$2);
        break;
    
  }
  return /* tuple */[
          env_arities,
          env_ar_par,
          paramsctxt,
          inds$2
        ];
}

var IllFormedInd = Caml_exceptions.create("Indtypes-ReactTemplate.IllFormedInd");

function failwith_non_pos(n, ntypes, c) {
  for(var k = n ,k_finish = (n + ntypes | 0) - 1 | 0; k <= k_finish; ++k){
    if (!Vars$ReactTemplate.noccurn(k, c)) {
      throw [
            IllFormedInd,
            /* LocalNonPos */Block.__(0, [(k - n | 0) + 1 | 0])
          ];
    }
    
  }
  return /* () */0;
}

function failwith_non_pos_list(n, ntypes, l) {
  Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
          return failwith_non_pos(n, ntypes, param);
        }), l);
  return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["failwith_non_pos_list"], Pp$ReactTemplate.str("some k in [n;n+ntypes-1] should occur."));
}

function check_correct_par(param, paramdecls, ind_index, args) {
  var ntypes = param[2];
  var n = param[1];
  var env = param[0];
  var nparams = Context$ReactTemplate.Rel[/* nhyps */5](paramdecls);
  var args$1 = Util$ReactTemplate.$$Array[/* of_list */10](args);
  if (args$1.length < nparams) {
    throw [
          IllFormedInd,
          /* LocalNotEnoughArgs */Block.__(1, [ind_index])
        ];
  }
  var match = Util$ReactTemplate.$$Array[/* chop */46](nparams, args$1);
  var realargs = match[1];
  var params = match[0];
  var nparamdecls = Curry._1(Util$ReactTemplate.List[/* length */0], paramdecls);
  var check = function (_param_index, _paramdecl_index, _param) {
    while(true) {
      var param = _param;
      var paramdecl_index = _paramdecl_index;
      var param_index = _param_index;
      if (param) {
        if (param[0].tag) {
          _param = param[1];
          _paramdecl_index = paramdecl_index + 1 | 0;
          continue ;
          
        } else {
          var match = Constr$ReactTemplate.kind(Reduction$ReactTemplate.whd_all(env, Caml_array.caml_array_get(params, param_index)));
          var exit = 0;
          if (match.tag) {
            exit = 1;
          } else if (match[0] === paramdecl_index) {
            _param = param[1];
            _paramdecl_index = paramdecl_index + 1 | 0;
            _param_index = param_index - 1 | 0;
            continue ;
            
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var paramdecl_index_in_env = ((paramdecl_index - n | 0) + nparamdecls | 0) + 1 | 0;
            var err_000 = param_index + 1 | 0;
            var err = /* LocalNonPar */Block.__(3, [
                err_000,
                paramdecl_index_in_env,
                ind_index
              ]);
            throw [
                  IllFormedInd,
                  err
                ];
          }
          
        }
      } else {
        return /* () */0;
      }
    };
  };
  check(nparams - 1 | 0, n - nparamdecls | 0, paramdecls);
  if (Util$ReactTemplate.$$Array[/* for_all */26]((function (param) {
            return Vars$ReactTemplate.noccur_between(n, ntypes, param);
          }), realargs)) {
    return 0;
  } else {
    var n$1 = n;
    var ntypes$1 = ntypes;
    var v = realargs;
    Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
            return failwith_non_pos(n$1, ntypes$1, param);
          }), v);
    return CErrors$ReactTemplate.anomaly(/* None */0, /* Some */["failwith_non_pos_vect"], Pp$ReactTemplate.str("some k in [n;n+ntypes-1] should occur."));
  }
}

function compute_rec_par(param, paramsctxt, nmr, largs) {
  if (nmr) {
    var env = param[0];
    var match = Curry._2(Util$ReactTemplate.List[/* chop */99], nmr, largs);
    var _k = 0;
    var _index = param[1] - 1 | 0;
    var _param = /* tuple */[
      match[0],
      Curry._1(Util$ReactTemplate.List[/* rev */4], paramsctxt)
    ];
    while(true) {
      var param$1 = _param;
      var index = _index;
      var k = _k;
      var lp = param$1[0];
      if (lp) {
        var match$1 = param$1[1];
        if (match$1) {
          if (match$1[0].tag) {
            _param = /* tuple */[
              lp,
              match$1[1]
            ];
            _index = index - 1 | 0;
            continue ;
            
          } else {
            var match$2 = Constr$ReactTemplate.kind(Reduction$ReactTemplate.whd_all(env, lp[0]));
            if (match$2.tag) {
              return k;
            } else if (match$2[0] === index) {
              _param = /* tuple */[
                lp[1],
                param$1[1][1]
              ];
              _index = index - 1 | 0;
              _k = k + 1 | 0;
              continue ;
              
            } else {
              return k;
            }
          }
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "indtypes.ml",
                  507,
                  13
                ]
              ];
        }
      } else {
        return nmr;
      }
    };
  } else {
    return 0;
  }
}

function ienv_push_var(param, param$1) {
  return /* tuple */[
          Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  param$1[0],
                  param$1[1]
                ]), param[0]),
          param[1] + 1 | 0,
          param[2],
          /* :: */[
            /* tuple */[
              /* Norec */0,
              param$1[2]
            ],
            param[3]
          ]
        ];
}

function ienv_push_inductive(param, param$1) {
  var match = param$1[0];
  var mi = match[0];
  var env = param[0];
  var specif_000 = Inductive$ReactTemplate.lookup_mind_specif(env, mi);
  var specif_001 = match[1];
  var specif = /* tuple */[
    specif_000,
    specif_001
  ];
  var ty = Inductive$ReactTemplate.type_of_inductive(env, specif);
  var decl_001 = Reduction$ReactTemplate.hnf_prod_applist(env, ty, param$1[1]);
  var decl = /* LocalAssum */Block.__(0, [
      /* Anonymous */0,
      decl_001
    ]);
  var env$prime = Environ$ReactTemplate.push_rel(decl, env);
  var ra_env$prime_000 = /* tuple */[
    /* Imbr */Block.__(1, [mi]),
    Caml_array.caml_array_get(Rtree$ReactTemplate.mk_rec_calls(1), 0)
  ];
  var ra_env$prime_001 = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* tuple */[
                  param[0],
                  Rtree$ReactTemplate.lift(1, param[1])
                ];
        }), param[3]);
  var ra_env$prime = /* :: */[
    ra_env$prime_000,
    ra_env$prime_001
  ];
  var newidx = param[1] + 1 | 0;
  return /* tuple */[
          env$prime,
          newidx,
          param[2],
          ra_env$prime
        ];
}

function ienv_decompose_prod(_ienv, _n, _c) {
  while(true) {
    var c = _c;
    var n = _n;
    var ienv = _ienv;
    if (n) {
      var c$prime = Reduction$ReactTemplate.whd_all(ienv[0], c);
      var match = Constr$ReactTemplate.kind(c$prime);
      if (match.tag === 6) {
        var ienv$prime = ienv_push_var(ienv, /* tuple */[
              match[0],
              match[1],
              Declareops$ReactTemplate.mk_norec
            ]);
        _c = match[2];
        _n = n - 1 | 0;
        _ienv = ienv$prime;
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "indtypes.ml",
                545,
                13
              ]
            ];
      }
    } else {
      return /* tuple */[
              ienv,
              c
            ];
    }
  };
}

function array_min(nmr, a) {
  if (nmr) {
    return Util$ReactTemplate.$$Array[/* fold_left */15]((function (k, param) {
                  return Caml_primitive.caml_int_min(k, param[0]);
                }), nmr, a);
  } else {
    return 0;
  }
}

function check_positivity(chkpos, kn, env_ar_par, paramsctxt, finite, inds) {
  var ntypes = inds.length;
  var recursive = +(finite !== /* BiFinite */2);
  var rc = Util$ReactTemplate.$$Array[/* mapi */14]((function (j, t) {
          return /* tuple */[
                  /* Mrec */Block.__(0, [/* tuple */[
                        kn,
                        j
                      ]]),
                  t
                ];
        }), Rtree$ReactTemplate.mk_rec_calls(ntypes));
  var ra_env_ar = Util$ReactTemplate.$$Array[/* rev_to_list */63](rc);
  var nparamsctxt = Curry._1(Context$ReactTemplate.Rel[/* length */3], paramsctxt);
  var nmr = Context$ReactTemplate.Rel[/* nhyps */5](paramsctxt);
  var check_one = function (i, param) {
    var ra_env_ar_par = Util$ReactTemplate.$at(Curry._2(Util$ReactTemplate.List[/* init */46], nparamsctxt, (function () {
                return /* tuple */[
                        /* Norec */0,
                        Declareops$ReactTemplate.mk_norec
                      ];
              })), ra_env_ar);
    var ienv_001 = 1 + nparamsctxt | 0;
    var ienv = /* tuple */[
      env_ar_par,
      ienv_001,
      ntypes,
      ra_env_ar_par
    ];
    var nnonrecargs = Context$ReactTemplate.Rel[/* nhyps */5](param[3][0]) - nmr | 0;
    var chkpos$1 = chkpos;
    var recursive$1 = recursive;
    var ienv$1 = ienv;
    var paramsctxt$1 = paramsctxt;
    var ind = /* tuple */[
      kn,
      i
    ];
    var nnonrecargs$1 = nnonrecargs;
    var lcnames = param[1];
    var indlc = param[2];
    var i$1 = ind[1];
    var ntypes$1 = ienv$1[2];
    var env = ienv$1[0];
    var nparamsctxt$1 = Curry._1(Context$ReactTemplate.Rel[/* length */3], paramsctxt$1);
    var nmr$1 = Context$ReactTemplate.Rel[/* nhyps */5](paramsctxt$1);
    var check_pos = function (_ienv, nmr, _c) {
      while(true) {
        var c = _c;
        var ienv = _ienv;
        var ntypes = ienv[2];
        var n = ienv[1];
        var env = ienv[0];
        var match = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(env, c));
        var largs = match[1];
        var x = match[0];
        var err = Constr$ReactTemplate.kind(x);
        switch (err.tag | 0) {
          case 0 : 
              try {
                var match$1 = Curry._2(Util$ReactTemplate.List[/* nth */3], ienv[3], err[0] - 1 | 0);
                var largs$1 = Curry._2(Util$ReactTemplate.List[/* map */10], (function(env){
                    return function (param) {
                      return Reduction$ReactTemplate.whd_all(env, param);
                    }
                    }(env)), largs);
                var nmr1;
                var tmp = match$1[0];
                nmr1 = typeof tmp === "number" || tmp.tag ? nmr : compute_rec_par(ienv, paramsctxt$1, nmr, largs$1);
                if (chkpos$1 && !Curry._2(Util$ReactTemplate.List[/* for_all */20], (function(n,ntypes){
                      return function (param) {
                        return Vars$ReactTemplate.noccur_between(n, ntypes, param);
                      }
                      }(n,ntypes)), largs$1)) {
                  return failwith_non_pos_list(n, ntypes, largs$1);
                } else {
                  return /* tuple */[
                          nmr1,
                          match$1[1]
                        ];
                }
              }
              catch (raw_exn){
                var exn = Js_exn.internalToOCamlException(raw_exn);
                if (exn[0] === Caml_builtin_exceptions.failure) {
                  return /* tuple */[
                          nmr,
                          Declareops$ReactTemplate.mk_norec
                        ];
                } else if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
                  return /* tuple */[
                          nmr,
                          Declareops$ReactTemplate.mk_norec
                        ];
                } else {
                  throw exn;
                }
              }
              break;
          case 6 : 
              var d = err[2];
              var b = err[1];
              var na = err[0];
              if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], largs)) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "indtypes.ml",
                        572,
                        14
                      ]
                    ];
              }
              var match$2 = weaker_noccur_between(env, n, ntypes, b);
              if (match$2) {
                _c = d;
                _ienv = ienv_push_var(ienv, /* tuple */[
                      na,
                      match$2[0],
                      Declareops$ReactTemplate.mk_norec
                    ]);
                continue ;
                
              } else if (chkpos$1) {
                return failwith_non_pos_list(n, ntypes, /* :: */[
                            b,
                            /* [] */0
                          ]);
              } else {
                _c = d;
                _ienv = ienv_push_var(ienv, /* tuple */[
                      na,
                      b,
                      Declareops$ReactTemplate.mk_norec
                    ]);
                continue ;
                
              }
              break;
          case 11 : 
              if (Curry._2(Util$ReactTemplate.List[/* for_all */20], (function(n,ntypes){
                    return function (param) {
                      return Vars$ReactTemplate.noccur_between(n, ntypes, param);
                    }
                    }(n,ntypes)), largs)) {
                return /* tuple */[
                        nmr,
                        Declareops$ReactTemplate.mk_norec
                      ];
              } else {
                var ienv$1 = ienv;
                var nmr$1 = nmr;
                var param = /* tuple */[
                  err[0],
                  largs
                ];
                var match$3 = param[0];
                var mi = match$3[0];
                var ntypes$1 = ienv$1[2];
                var n$1 = ienv$1[1];
                var match$4 = Inductive$ReactTemplate.lookup_mind_specif(ienv$1[0], mi);
                var mib = match$4[0];
                var auxnrecpar = mib[/* mind_nparams_rec */6];
                var auxnnonrecpar = mib[/* mind_nparams */5] - auxnrecpar | 0;
                var match$5;
                try {
                  match$5 = Curry._2(Util$ReactTemplate.List[/* chop */99], auxnrecpar, param[1]);
                }
                catch (raw_exn$1){
                  var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
                  if (exn$1[0] === Caml_builtin_exceptions.failure) {
                    throw [
                          IllFormedInd,
                          /* LocalNonPos */Block.__(0, [n$1])
                        ];
                  } else {
                    throw exn$1;
                  }
                }
                var auxnonrecargs = match$5[1];
                var auxrecparams = match$5[0];
                if (chkpos$1 && !Curry._2(Util$ReactTemplate.List[/* for_all */20], (function(n$1,ntypes$1){
                      return function (param) {
                        return Vars$ReactTemplate.noccur_between(n$1, ntypes$1, param);
                      }
                      }(n$1,ntypes$1)), auxnonrecargs)) {
                  failwith_non_pos_list(n$1, ntypes$1, auxnonrecargs);
                }
                var auxntyp = mib[/* mind_ntypes */3];
                if (auxntyp !== 1) {
                  throw [
                        IllFormedInd,
                        /* LocalNonPos */Block.__(0, [n$1])
                      ];
                }
                var auxlcvect = Inductive$ReactTemplate.abstract_mind_lc(auxntyp, auxnrecpar, match$4[1][/* mind_nf_lc */8]);
                var ienv$prime = ienv_push_inductive(ienv$1, /* tuple */[
                      /* tuple */[
                        mi,
                        match$3[1]
                      ],
                      auxrecparams
                    ]);
                var env$prime = ienv$prime[0];
                var auxrecparams$prime = Curry._2(Util$ReactTemplate.List[/* map */10], Vars$ReactTemplate.lift(auxntyp), auxrecparams);
                var irecargs_nmr = Util$ReactTemplate.$$Array[/* map */12]((function(nmr$1,auxnnonrecpar,env$prime,ienv$prime,auxrecparams$prime){
                    return function (c) {
                      var c$prime = Reduction$ReactTemplate.hnf_prod_applist(env$prime, c, auxrecparams$prime);
                      var match = ienv_decompose_prod(ienv$prime, auxnnonrecpar, c$prime);
                      return check_constructors(match[0], /* false */0, nmr$1, match[1]);
                    }
                    }(nmr$1,auxnnonrecpar,env$prime,ienv$prime,auxrecparams$prime)), auxlcvect);
                var irecargs = Util$ReactTemplate.$$Array[/* map */12]((function (prim) {
                        return prim[1];
                      }), irecargs_nmr);
                var nmr$prime = array_min(nmr$1, irecargs_nmr);
                return /* tuple */[
                        nmr$prime,
                        Caml_array.caml_array_get(Rtree$ReactTemplate.mk_rec(/* array */[Declareops$ReactTemplate.mk_paths(/* Imbr */Block.__(1, [mi]), irecargs)]), 0)
                      ];
              }
          default:
            if (!chkpos$1 || Vars$ReactTemplate.noccur_between(n, ntypes, x) && Curry._2(Util$ReactTemplate.List[/* for_all */20], (function(n,ntypes){
                  return function (param) {
                    return Vars$ReactTemplate.noccur_between(n, ntypes, param);
                  }
                  }(n,ntypes)), largs)) {
              return /* tuple */[
                      nmr,
                      Declareops$ReactTemplate.mk_norec
                    ];
            } else {
              return failwith_non_pos_list(n, ntypes, /* :: */[
                          x,
                          largs
                        ]);
            }
        }
      };
    };
    var check_constructors = function (ienv, check_head, nmr, c) {
      var _ienv = ienv;
      var _nmr = nmr;
      var _lrec = /* [] */0;
      var _c = c;
      while(true) {
        var c$1 = _c;
        var lrec = _lrec;
        var nmr$1 = _nmr;
        var ienv$1 = _ienv;
        var ntypes = ienv$1[2];
        var n = ienv$1[1];
        var match = Constr$ReactTemplate.decompose_app(Reduction$ReactTemplate.whd_all(ienv$1[0], c$1));
        var largs = match[1];
        var hd = Constr$ReactTemplate.kind(match[0]);
        if (hd.tag === 6) {
          var b = hd[1];
          if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], largs)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "indtypes.ml",
                    681,
                    16
                  ]
                ];
          }
          if (!recursive$1 && !Vars$ReactTemplate.noccur_between(n, ntypes, b)) {
            throw [
                  InductiveError,
                  /* BadEntry */0
                ];
          }
          var match$1 = check_pos(ienv$1, nmr$1, b);
          var ienv$prime = ienv_push_var(ienv$1, /* tuple */[
                hd[0],
                b,
                Declareops$ReactTemplate.mk_norec
              ]);
          _c = hd[2];
          _lrec = /* :: */[
            match$1[1],
            lrec
          ];
          _nmr = match$1[0];
          _ienv = ienv$prime;
          continue ;
          
        } else {
          if (check_head) {
            if (hd.tag) {
              throw [
                    IllFormedInd,
                    /* LocalNotConstructor */Block.__(2, [
                        paramsctxt$1,
                        nnonrecargs$1
                      ])
                  ];
            } else if (hd[0] === (((n + ntypes | 0) - i$1 | 0) - 1 | 0)) {
              check_correct_par(ienv$1, paramsctxt$1, ntypes - i$1 | 0, largs);
            } else {
              throw [
                    IllFormedInd,
                    /* LocalNotConstructor */Block.__(2, [
                        paramsctxt$1,
                        nnonrecargs$1
                      ])
                  ];
            }
          } else if (chkpos$1 && !Curry._2(Util$ReactTemplate.List[/* for_all */20], (function(n,ntypes){
                return function (param) {
                  return Vars$ReactTemplate.noccur_between(n, ntypes, param);
                }
                }(n,ntypes)), largs)) {
            failwith_non_pos_list(n, ntypes, largs);
          }
          return /* tuple */[
                  nmr$1,
                  Curry._1(Util$ReactTemplate.List[/* rev */4], lrec)
                ];
        }
      };
    };
    var irecargs_nmr = Util$ReactTemplate.$$Array[/* map2 */49]((function (id, c) {
            var match = Term$ReactTemplate.decompose_prod_n_assum(nparamsctxt$1)(c);
            try {
              return check_constructors(ienv$1, /* true */1, nmr$1, match[1]);
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === IllFormedInd) {
                var id$1 = id;
                var ntyp = ntypes$1 - i$1 | 0;
                var env$1 = env;
                var nparamsctxt$2 = nparamsctxt$1;
                var c$1 = c;
                var err = exn[1];
                var match$1 = Term$ReactTemplate.decompose_prod_n_assum(nparamsctxt$2)(c$1);
                var c$prime = match$1[1];
                switch (err.tag | 0) {
                  case 0 : 
                      throw [
                            InductiveError,
                            /* NonPos */Block.__(0, [
                                env$1,
                                c$prime,
                                Constr$ReactTemplate.mkRel(err[0] + nparamsctxt$2 | 0)
                              ])
                          ];
                  case 1 : 
                      throw [
                            InductiveError,
                            /* NotEnoughArgs */Block.__(1, [
                                env$1,
                                c$prime,
                                Constr$ReactTemplate.mkRel(err[0] + nparamsctxt$2 | 0)
                              ])
                          ];
                  case 2 : 
                      var nparams = Context$ReactTemplate.Rel[/* nhyps */5](err[0]);
                      throw [
                            InductiveError,
                            /* NotConstructor */Block.__(2, [
                                env$1,
                                id$1,
                                c$prime,
                                Constr$ReactTemplate.mkRel(ntyp + nparamsctxt$2 | 0),
                                nparams,
                                err[1]
                              ])
                          ];
                  case 3 : 
                      throw [
                            InductiveError,
                            /* NonPar */Block.__(3, [
                                env$1,
                                c$prime,
                                err[0],
                                Constr$ReactTemplate.mkRel(err[1]),
                                Constr$ReactTemplate.mkRel(err[2] + nparamsctxt$2 | 0)
                              ])
                          ];
                  
                }
              } else {
                throw exn;
              }
            }
          }), Util$ReactTemplate.$$Array[/* of_list */10](lcnames), indlc);
    var irecargs = Util$ReactTemplate.$$Array[/* map */12]((function (prim) {
            return prim[1];
          }), irecargs_nmr);
    var nmr$prime = array_min(nmr$1, irecargs_nmr);
    return /* tuple */[
            nmr$prime,
            Declareops$ReactTemplate.mk_paths(/* Mrec */Block.__(0, [ind]), irecargs)
          ];
  };
  var irecargs_nmr = Util$ReactTemplate.$$Array[/* mapi */14](check_one, inds);
  var irecargs = Util$ReactTemplate.$$Array[/* map */12]((function (prim) {
          return prim[1];
        }), irecargs_nmr);
  var nmr$prime = array_min(nmr, irecargs_nmr);
  return /* tuple */[
          nmr$prime,
          Rtree$ReactTemplate.mk_rec(irecargs)
        ];
}

var all_sorts = /* :: */[
  /* InProp */0,
  /* :: */[
    /* InSet */1,
    /* :: */[
      /* InType */2,
      /* [] */0
    ]
  ]
];

function allowed_sorts(is_smashed, s) {
  if (is_smashed) {
    var match = Sorts$ReactTemplate.family(s);
    switch (match) {
      case 0 : 
          return /* :: */[
                  /* InProp */0,
                  /* [] */0
                ];
      case 1 : 
          return /* :: */[
                  /* InProp */0,
                  /* :: */[
                    /* InSet */1,
                    /* [] */0
                  ]
                ];
      case 2 : 
          return all_sorts;
      
    }
  } else {
    return all_sorts;
  }
}

function arity_conclusion(param) {
  if (param.tag) {
    return Constr$ReactTemplate.mkType(param[0][1]);
  } else {
    return param[0][1];
  }
}

function fold_inductive_blocks(f) {
  var partial_arg = Util$ReactTemplate.$$Array[/* fold_left */15];
  return (function (param, param$1) {
      return partial_arg((function (acc, param) {
                    var match = param[3];
                    return Curry._2(f, Util$ReactTemplate.$$Array[/* fold_left */15](f, acc, param[2]), Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, arity_conclusion(match[1]), match[0]));
                  }), param, param$1);
    });
}

function used_section_variables(env, inds) {
  var ids = fold_inductive_blocks((function (l, c) {
            return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], Environ$ReactTemplate.global_vars_set(env, c), l);
          }))(Names$ReactTemplate.Id[/* Set */9][/* empty */0], inds);
  return Environ$ReactTemplate.keep_hyps(env, ids);
}

function rel_vect(n, m) {
  return Util$ReactTemplate.$$Array[/* init */0](m, (function (i) {
                return Constr$ReactTemplate.mkRel((n + m | 0) - i | 0);
              }));
}

function rel_list(n, m) {
  return Util$ReactTemplate.$$Array[/* to_list */9](rel_vect(n, m));
}

var UndefinableExpansion = Caml_exceptions.create("Indtypes-ReactTemplate.UndefinableExpansion");

function compute_projections(indu, _, x, nparamargs, params, mind_consnrealdecls, mind_consnrealargs, paramslet, ctx) {
  var ind = indu[0];
  var match = Names$ReactTemplate.MutInd[/* repr3 */6](ind[0]);
  var dp = match[1];
  var mp = match[0];
  var inst = Context$ReactTemplate.Rel[/* to_extended_vect */13](Constr$ReactTemplate.mkRel, 0, paramslet);
  var ty = Constr$ReactTemplate.mkApp(/* tuple */[
        Constr$ReactTemplate.mkIndU(indu),
        inst
      ]);
  var inst$prime = rel_list(0, nparamargs);
  var subst = Vars$ReactTemplate.subst_of_rel_context_instance(paramslet, inst$prime);
  var subst_000 = Constr$ReactTemplate.mkRel(1);
  var subst_001 = Curry._2(Util$ReactTemplate.List[/* map */10], Vars$ReactTemplate.lift(1), subst);
  var subst$1 = /* :: */[
    subst_000,
    subst_001
  ];
  var print_info_001 = /* cstr_tags : array */[Context$ReactTemplate.Rel[/* to_tags */11](ctx)];
  var print_info = /* record */[
    /* ind_tags : [] */0,
    print_info_001,
    /* style : LetStyle */0
  ];
  var ci = /* record */[
    /* ci_ind */ind,
    /* ci_npar */nparamargs,
    /* ci_cstr_ndecls */mind_consnrealdecls,
    /* ci_cstr_nargs */mind_consnrealargs,
    /* ci_pp_info */print_info
  ];
  var len = Curry._1(Util$ReactTemplate.List[/* length */0], ctx);
  var x$1 = /* Name */[x];
  var compat_body = function (ccl, i) {
    var ccl$prime = Vars$ReactTemplate.liftn(1, 2, ccl);
    var p = Constr$ReactTemplate.mkLambda(/* tuple */[
          x$1,
          Vars$ReactTemplate.lift(1)(ty),
          ccl$prime
        ]);
    var branch = Curry._2(Term$ReactTemplate.it_mkLambda_or_LetIn, Constr$ReactTemplate.mkRel(len - i | 0), ctx);
    var body = Constr$ReactTemplate.mkCase(/* tuple */[
          ci,
          p,
          Constr$ReactTemplate.mkRel(1),
          /* array */[Vars$ReactTemplate.lift(1)(branch)]
        ]);
    return Curry._2(Term$ReactTemplate.it_mkLambda_or_LetIn, Constr$ReactTemplate.mkLambda(/* tuple */[
                    x$1,
                    ty,
                    body
                  ]), params);
  };
  var projections = function (decl, param) {
    var letsubst = param[5];
    var subst = param[4];
    var pbs = param[3];
    var kns = param[2];
    var j = param[1];
    var i = param[0];
    if (decl.tag) {
      var c = Vars$ReactTemplate.liftn(1, j, decl[1]);
      var c1 = Vars$ReactTemplate.substl(subst, c);
      var subst$1 = /* :: */[
        c1,
        subst
      ];
      var c2 = Vars$ReactTemplate.substl(letsubst, c);
      var letsubst$1 = /* :: */[
        c2,
        letsubst
      ];
      return /* tuple */[
              i,
              j + 1 | 0,
              kns,
              pbs,
              subst$1,
              letsubst$1
            ];
    } else {
      var na = decl[0];
      if (na) {
        var kn = Names$ReactTemplate.Constant[/* make1 */1](Names$ReactTemplate.KerName[/* make */0](mp, dp, Names$ReactTemplate.Label[/* of_id */5](na[0])));
        var t = Vars$ReactTemplate.liftn(1, j, decl[1]);
        var projty = Vars$ReactTemplate.substl(letsubst, t);
        var ty$1 = Vars$ReactTemplate.substl(subst, t);
        var term = Constr$ReactTemplate.mkProj(/* tuple */[
              Names$ReactTemplate.Projection[/* make */0](kn, /* true */1),
              Constr$ReactTemplate.mkRel(1)
            ]);
        var fterm = Constr$ReactTemplate.mkProj(/* tuple */[
              Names$ReactTemplate.Projection[/* make */0](kn, /* false */0),
              Constr$ReactTemplate.mkRel(1)
            ]);
        var compat = compat_body(ty$1, j - 1 | 0);
        var etab = Curry._2(Term$ReactTemplate.it_mkLambda_or_LetIn, Constr$ReactTemplate.mkLambda(/* tuple */[
                  x$1,
                  ty,
                  term
                ]), params);
        var etat = Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, Constr$ReactTemplate.mkProd(/* tuple */[
                  x$1,
                  ty,
                  ty$1
                ]), params);
        var body_000 = /* proj_ind */ind[0];
        var body_004 = /* proj_eta : tuple */[
          etab,
          etat
        ];
        var body = /* record */[
          body_000,
          /* proj_npars */nparamargs,
          /* proj_arg */i,
          /* proj_type */projty,
          body_004,
          /* proj_body */compat
        ];
        return /* tuple */[
                i + 1 | 0,
                j + 1 | 0,
                /* :: */[
                  kn,
                  kns
                ],
                /* :: */[
                  body,
                  pbs
                ],
                /* :: */[
                  fterm,
                  subst
                ],
                /* :: */[
                  fterm,
                  letsubst
                ]
              ];
      } else {
        throw UndefinableExpansion;
      }
    }
  };
  var match$1 = Curry._3(Util$ReactTemplate.List[/* fold_right */14], projections, ctx, /* tuple */[
        0,
        1,
        /* [] */0,
        /* [] */0,
        /* [] */0,
        subst$1
      ]);
  return /* tuple */[
          Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(Util$ReactTemplate.List[/* rev */4], match$1[2])),
          Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(Util$ReactTemplate.List[/* rev */4], match$1[3]))
        ];
}

function abstract_inductive_universes(iu) {
  switch (iu.tag | 0) {
    case 0 : 
        return /* tuple */[
                Univ$ReactTemplate.empty_level_subst,
                /* Monomorphic_ind */Block.__(0, [iu[0]])
              ];
    case 1 : 
        var match = Univ$ReactTemplate.abstract_universes(iu[0]);
        var inst = Univ$ReactTemplate.make_instance_subst(match[0]);
        return /* tuple */[
                inst,
                /* Polymorphic_ind */Block.__(1, [match[1]])
              ];
    case 2 : 
        var match$1 = Univ$ReactTemplate.abstract_cumulativity_info(iu[0]);
        var inst$1 = Univ$ReactTemplate.make_instance_subst(match$1[0]);
        return /* tuple */[
                inst$1,
                /* Cumulative_ind */Block.__(2, [match$1[1]])
              ];
    
  }
}

function check_inductive(env, kn, mie) {
  var match = typecheck_inductive(env, mie);
  var inds = match[3];
  var paramsctxt = match[2];
  var chkpos = Environ$ReactTemplate.typing_flags(env)[/* check_guarded */0];
  var match$1 = check_positivity(chkpos, kn, match[1], paramsctxt, mie[/* mind_entry_finite */1], inds);
  var env$1 = env;
  var prv = mie[/* mind_entry_private */5];
  var iu = mie[/* mind_entry_universes */4];
  var env_ar = match[0];
  var paramsctxt$1 = paramsctxt;
  var kn$1 = kn;
  var isrecord = mie[/* mind_entry_record */0];
  var isfinite = mie[/* mind_entry_finite */1];
  var inds$1 = inds;
  var nmr = match$1[0];
  var recargs = match$1[1];
  var ntypes = inds$1.length;
  var hyps = used_section_variables(env$1, inds$1);
  var nparamargs = Context$ReactTemplate.Rel[/* nhyps */5](paramsctxt$1);
  var nparamsctxt = Curry._1(Context$ReactTemplate.Rel[/* length */3], paramsctxt$1);
  var match$2 = abstract_inductive_universes(iu);
  var aiu = match$2[1];
  var substunivs = match$2[0];
  var paramsctxt$2 = Curry._1(Vars$ReactTemplate.subst_univs_level_context(substunivs), paramsctxt$1);
  var ctxunivs = Environ$ReactTemplate.rel_context(env_ar);
  var ctxunivs$prime = Curry._1(Vars$ReactTemplate.subst_univs_level_context(substunivs), ctxunivs);
  var env_ar$1 = Environ$ReactTemplate.push_rel_context(ctxunivs$prime, env$1);
  var build_one_packet = function (param, recarg) {
    var match = param[3];
    var ar_kind = match[1];
    var ar_sign = match[0];
    var cnames = param[1];
    var lc = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
            return Vars$ReactTemplate.subst_univs_level_constr(substunivs, param);
          }), param[2]);
    var splayed_lc = Util$ReactTemplate.$$Array[/* map */12](Reduction$ReactTemplate.dest_prod_assum(env_ar$1), lc);
    var nf_lc = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
            return Curry._2(Term$ReactTemplate.it_mkProd_or_LetIn, param[1], param[0]);
          }), splayed_lc);
    var consnrealdecls = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
            return Curry._1(Context$ReactTemplate.Rel[/* length */3], param[0]) - nparamsctxt | 0;
          }), splayed_lc);
    var consnrealargs = Util$ReactTemplate.$$Array[/* map */12]((function (param) {
            return Context$ReactTemplate.Rel[/* nhyps */5](param[0]) - nparamargs | 0;
          }), splayed_lc);
    var match$1;
    if (ar_kind.tag) {
      var match$2 = ar_kind[0];
      var ar_000 = /* template_param_levels */match$2[0];
      var ar_001 = /* template_level */match$2[1];
      var ar = /* record */[
        ar_000,
        ar_001
      ];
      match$1 = /* tuple */[
        /* TemplateArity */Block.__(1, [ar]),
        all_sorts
      ];
    } else {
      var match$3 = ar_kind[0];
      var defs = match$3[2];
      var s = Sorts$ReactTemplate.sort_of_univ(defs);
      var kelim = allowed_sorts(match$3[0], s);
      var ar$1 = /* RegularArity */Block.__(0, [/* record */[
            /* mind_user_arity */Vars$ReactTemplate.subst_univs_level_constr(substunivs, match$3[1]),
            /* mind_sort */Sorts$ReactTemplate.sort_of_univ(Univ$ReactTemplate.subst_univs_level_universe(substunivs, defs))
          ]]);
      match$1 = /* tuple */[
        ar$1,
        kelim
      ];
    }
    var nconst = [0];
    var nblock = [0];
    var transf = function (num) {
      var arity = Curry._1(Util$ReactTemplate.List[/* length */0], Caml_array.caml_array_get(Declareops$ReactTemplate.dest_subterms(recarg), num));
      if (arity) {
        var p_000 = nblock[0] + 1 | 0;
        var p = /* tuple */[
          p_000,
          arity
        ];
        nblock[0] = nblock[0] + 1 | 0;
        return p;
      } else {
        var p_000$1 = nconst[0];
        var p$1 = /* tuple */[
          p_000$1,
          0
        ];
        nconst[0] = nconst[0] + 1 | 0;
        return p$1;
      }
    };
    var rtbl = Util$ReactTemplate.$$Array[/* init */0](Curry._1(Util$ReactTemplate.List[/* length */0], cnames), transf);
    return /* record */[
            /* mind_typename */param[0],
            /* mind_arity_ctxt */Curry._1(Vars$ReactTemplate.subst_univs_level_context(substunivs), ar_sign),
            /* mind_arity */match$1[0],
            /* mind_consnames */Util$ReactTemplate.$$Array[/* of_list */10](cnames),
            /* mind_user_lc */lc,
            /* mind_nrealargs */Context$ReactTemplate.Rel[/* nhyps */5](ar_sign) - nparamargs | 0,
            /* mind_nrealdecls */Curry._1(Context$ReactTemplate.Rel[/* length */3], ar_sign) - nparamsctxt | 0,
            /* mind_kelim */match$1[1],
            /* mind_nf_lc */nf_lc,
            /* mind_consnrealargs */consnrealargs,
            /* mind_consnrealdecls */consnrealdecls,
            /* mind_recargs */recarg,
            /* mind_nb_constant */nconst[0],
            /* mind_nb_args */nblock[0],
            /* mind_reloc_tbl */rtbl
          ];
  };
  var packets = Util$ReactTemplate.$$Array[/* map2 */49](build_one_packet, inds$1, recargs);
  var pkt = Caml_array.caml_array_get(packets, 0);
  var isrecord$1;
  if (isrecord) {
    var match$3 = isrecord[0];
    if (match$3) {
      if (pkt[/* mind_kelim */7] === all_sorts && pkt[/* mind_consnames */3].length === 1 && Caml_array.caml_array_get(pkt[/* mind_consnrealargs */9], 0) > 0) {
        var rid = match$3[0];
        var u;
        switch (aiu.tag | 0) {
          case 0 : 
              u = Univ$ReactTemplate.Instance[/* empty */0];
              break;
          case 1 : 
              u = Univ$ReactTemplate.make_abstract_instance(aiu[0]);
              break;
          case 2 : 
              u = Univ$ReactTemplate.make_abstract_instance(Univ$ReactTemplate.ACumulativityInfo[/* univ_context */0](aiu[0]));
              break;
          
        }
        var indsp_000 = /* tuple */[
          kn$1,
          0
        ];
        var indsp = /* tuple */[
          indsp_000,
          u
        ];
        var match$4 = Term$ReactTemplate.decompose_prod_assum(Vars$ReactTemplate.subst1(Constr$ReactTemplate.mkIndU(indsp), Caml_array.caml_array_get(pkt[/* mind_nf_lc */8], 0)));
        try {
          var match$5 = Curry._2(Util$ReactTemplate.List[/* chop */99], Caml_array.caml_array_get(pkt[/* mind_consnrealdecls */10], 0), match$4[0]);
          var match$6 = compute_projections(indsp, pkt[/* mind_typename */0], rid, nparamargs, paramsctxt$2, pkt[/* mind_consnrealdecls */10], pkt[/* mind_consnrealargs */9], match$5[1], match$5[0]);
          isrecord$1 = /* Some */[/* Some */[/* tuple */[
                rid,
                match$6[0],
                match$6[1]
              ]]];
        }
        catch (exn){
          if (exn === UndefinableExpansion) {
            isrecord$1 = /* Some */[/* None */0];
          } else {
            throw exn;
          }
        }
      } else {
        isrecord$1 = /* Some */[/* None */0];
      }
    } else {
      isrecord$1 = /* Some */[/* None */0];
    }
  } else {
    isrecord$1 = /* None */0;
  }
  return /* record */[
          /* mind_packets */packets,
          /* mind_record */isrecord$1,
          /* mind_finite */isfinite,
          /* mind_ntypes */ntypes,
          /* mind_hyps */hyps,
          /* mind_nparams */nparamargs,
          /* mind_nparams_rec */nmr,
          /* mind_params_ctxt */paramsctxt$2,
          /* mind_universes */aiu,
          /* mind_private */prv,
          /* mind_typing_flags */Environ$ReactTemplate.typing_flags(env$1)
        ];
}

exports.InductiveError = InductiveError;
exports.check_inductive = check_inductive;
exports.enforce_indices_matter = enforce_indices_matter;
exports.is_indices_matter = is_indices_matter;
exports.compute_projections = compute_projections;
/* Pp-ReactTemplate Not a pure module */
