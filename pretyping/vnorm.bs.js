// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Vm$ReactTemplate = require("../kernel/vm.bs.js");
var Evd$ReactTemplate = require("../src/evd.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Vars$ReactTemplate = require("../src/vars.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var Vconv$ReactTemplate = require("../kernel/vconv.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var EConstr$ReactTemplate = require("../src/eConstr.bs.js");
var Environ$ReactTemplate = require("../src/environ.bs.js");
var Termops$ReactTemplate = require("../src/termops.bs.js");
var Typeops$ReactTemplate = require("../src/typeops.bs.js");
var Vmvalues$ReactTemplate = require("../src/vmvalues.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Inductive$ReactTemplate = require("../src/inductive.bs.js");
var Reduction$ReactTemplate = require("../src/reduction.bs.js");
var Cbytecodes$ReactTemplate = require("../src/cbytecodes.bs.js");
var Coq_config$ReactTemplate = require("../shims/coq_config.bs.js");
var Declareops$ReactTemplate = require("../src/declareops.bs.js");
var Inductiveops$ReactTemplate = require("../src/inductiveops.bs.js");
var Reductionops$ReactTemplate = require("../src/reductionops.bs.js");
var Retroknowledge$ReactTemplate = require("../src/retroknowledge.bs.js");

function decompose_prod(env, t) {
  var res = Constr$ReactTemplate.destProd(Reduction$ReactTemplate.whd_all(env, t));
  if (res[0]) {
    return res;
  } else {
    return /* tuple */[
            /* Name */[Names$ReactTemplate.Id[/* of_string */5]("x")],
            res[1],
            res[2]
          ];
  }
}

var Find_at = Caml_exceptions.create("Vnorm-ReactTemplate.Find_at");

function invert_tag(cst, tag, reloc_tbl) {
  try {
    for(var j = 0 ,j_finish = reloc_tbl.length - 1 | 0; j <= j_finish; ++j){
      var match = Caml_array.caml_array_get(reloc_tbl, j);
      var no_arity = +(match[1] === 0);
      if (tag === match[0] && (cst && no_arity || !(cst || no_arity))) {
        throw [
              Find_at,
              j
            ];
      }
      
    }
    throw Caml_builtin_exceptions.not_found;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Find_at) {
      return exn[1] + 1 | 0;
    } else {
      throw exn;
    }
  }
}

function find_rectype_a(env, c) {
  var match = Constr$ReactTemplate.decompose_appvect(Reduction$ReactTemplate.whd_all(env, c));
  var match$1 = Constr$ReactTemplate.kind(match[0]);
  if (match$1.tag === 11) {
    return /* tuple */[
            match$1[0],
            match[1]
          ];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "vnorm.ml",
            60,
            9
          ]
        ];
  }
}

function type_constructor(mind, mib, u, typ, params) {
  var s = Inductive$ReactTemplate.ind_subst(mind, mib, u);
  var ctyp = Vars$ReactTemplate.substl(s, typ);
  var ctyp$1 = Vars$ReactTemplate.subst_instance_constr(u, ctyp);
  var ndecls = Curry._1(Context$ReactTemplate.Rel[/* length */3], mib[/* mind_params_ctxt */7]);
  if (ndecls) {
    var match = Term$ReactTemplate.decompose_prod_n_assum(ndecls)(ctyp$1);
    return Vars$ReactTemplate.substl(Curry._1(Util$ReactTemplate.List[/* rev */4], Vars$ReactTemplate.adjust_subst_to_rel_context(mib[/* mind_params_ctxt */7], Util$ReactTemplate.$$Array[/* to_list */9](params))), match[1]);
  } else {
    return ctyp$1;
  }
}

function construct_of_constr($$const, env, tag, typ) {
  var match = find_rectype_a(env, typ);
  var indu = match[0];
  var ind = indu[0];
  try {
    if ($$const) {
      return /* tuple */[
              Curry._2(Environ$ReactTemplate.retroknowledge(Retroknowledge$ReactTemplate.get_vm_decompile_constant_info, env), Constr$ReactTemplate.mkIndU(indu), tag),
              typ
            ];
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var match$1 = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
      var mip = match$1[1];
      var mib = match$1[0];
      var nparams = mib[/* mind_nparams */5];
      var i = invert_tag($$const, tag, mip[/* mind_reloc_tbl */14]);
      var params = Util$ReactTemplate.$$Array[/* sub */5](match[1], 0, nparams);
      var ctyp = type_constructor(ind[0], mib, indu[1], Caml_array.caml_array_get(mip[/* mind_nf_lc */8], i - 1 | 0), params);
      return /* tuple */[
              Constr$ReactTemplate.mkApp(/* tuple */[
                    Constr$ReactTemplate.mkConstructUi(/* tuple */[
                          indu,
                          i
                        ]),
                    params
                  ]),
              ctyp
            ];
    } else {
      throw exn;
    }
  }
}

function construct_of_constr_block(param, param$1, param$2) {
  return construct_of_constr(/* false */0, param, param$1, param$2);
}

function type_of_ind(env, param) {
  return Inductive$ReactTemplate.type_of_inductive(env, /* tuple */[
              Inductive$ReactTemplate.lookup_mind_specif(env, param[0]),
              param[1]
            ]);
}

function build_branches_type(env, sigma, _ind, mib, mip, u, params, dep, p) {
  var mind = _ind[0];
  var rtbl = mip[/* mind_reloc_tbl */14];
  var build_one_branch = function (i, cty) {
    var typi = type_constructor(mind, mib, u, cty, params);
    var match = Reductionops$ReactTemplate.splay_prod(env, sigma)(EConstr$ReactTemplate.of_constr(typi));
    var partial_arg = EConstr$ReactTemplate.Unsafe[/* to_constr */0];
    var decl = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
            return Util$ReactTemplate.on_snd(partial_arg, param);
          }), match[0]);
    var indapp = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[1]);
    var match$1 = Term$ReactTemplate.decompose_prod_assum(typi);
    var match$2 = find_rectype_a(env, indapp);
    var cargs = match$2[1];
    var match$3 = match$2[0];
    var nparams = params.length;
    var carity = Caml_array.caml_array_get(rtbl, i)[1];
    var crealargs = Util$ReactTemplate.$$Array[/* sub */5](cargs, nparams, cargs.length - nparams | 0);
    var ndecl = Curry._1(Util$ReactTemplate.List[/* length */0], decl);
    var papp = Constr$ReactTemplate.mkApp(/* tuple */[
          Vars$ReactTemplate.lift(ndecl)(p),
          crealargs
        ]);
    var codom;
    if (dep) {
      var cstr = Names$ReactTemplate.ith_constructor_of_inductive(match$3[0], i + 1 | 0);
      var relargs = Util$ReactTemplate.$$Array[/* init */0](carity, (function (i) {
              return Constr$ReactTemplate.mkRel(carity - i | 0);
            }));
      var params$1 = Util$ReactTemplate.$$Array[/* map */12](Vars$ReactTemplate.lift(ndecl), params);
      var dep_cstr = Constr$ReactTemplate.mkApp(/* tuple */[
            Constr$ReactTemplate.mkApp(/* tuple */[
                  Constr$ReactTemplate.mkConstructU(/* tuple */[
                        cstr,
                        match$3[1]
                      ]),
                  params$1
                ]),
            relargs
          ]);
      codom = Constr$ReactTemplate.mkApp(/* tuple */[
            papp,
            /* array */[dep_cstr]
          ]);
    } else {
      codom = papp;
    }
    return /* tuple */[
            decl,
            match$1[0],
            codom
          ];
  };
  return Util$ReactTemplate.$$Array[/* mapi */14](build_one_branch, mip[/* mind_nf_lc */8]);
}

function build_case_type(dep, p, realargs, c) {
  if (dep) {
    return Constr$ReactTemplate.mkApp(/* tuple */[
                Constr$ReactTemplate.mkApp(/* tuple */[
                      p,
                      realargs
                    ]),
                /* array */[c]
              ]);
  } else {
    return Constr$ReactTemplate.mkApp(/* tuple */[
                p,
                realargs
              ]);
  }
}

function nf_val(env, sigma, v, t) {
  var env$1 = env;
  var sigma$1 = sigma;
  var whd = Vmvalues$ReactTemplate.whd_val(v);
  var typ = t;
  switch (whd.tag | 0) {
    case 0 : 
        var p = whd[0];
        var dom = nf_vtype(env$1, sigma$1, Vmvalues$ReactTemplate.dom(p));
        var name = /* Name */[Names$ReactTemplate.Id[/* of_string */5]("x")];
        var vc = Vm$ReactTemplate.reduce_fun(Environ$ReactTemplate.nb_rel(env$1), Vmvalues$ReactTemplate.codom(p));
        var codom = nf_vtype(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                    name,
                    dom
                  ]), env$1), sigma$1, vc);
        return Constr$ReactTemplate.mkProd(/* tuple */[
                    name,
                    dom,
                    codom
                  ]);
    case 1 : 
        return nf_fun(env$1, sigma$1, whd[0], typ);
    case 2 : 
        var match = whd[1];
        var f = whd[0];
        if (match) {
          return nf_fix_app(env$1, sigma$1, f, match[0])[0];
        } else {
          return nf_fix(env$1, sigma$1, f);
        }
    case 3 : 
        var match$1 = whd[2];
        var cf = whd[0];
        if (match$1) {
          var cfd = nf_cofix(env$1, sigma$1, cf);
          var match$2 = Constr$ReactTemplate.destCoFix(cfd);
          var t$1 = Caml_array.caml_array_get(match$2[1][1], match$2[0]);
          var match$3 = nf_args(env$1, sigma$1, match$1[0], /* None */0, t$1);
          return Constr$ReactTemplate.mkApp(/* tuple */[
                      cfd,
                      match$3[1]
                    ]);
        } else {
          return nf_cofix(env$1, sigma$1, cf);
        }
        break;
    case 4 : 
        var env$2 = env$1;
        var tag = whd[0];
        var typ$1 = typ;
        return construct_of_constr(/* true */1, env$2, tag, typ$1)[0];
    case 5 : 
        var b = whd[0];
        var tag$1 = Vmvalues$ReactTemplate.btag(b);
        var match$4;
        if (tag$1 === Cbytecodes$ReactTemplate.last_variant_tag) {
          var match$5 = Vmvalues$ReactTemplate.whd_val(Vmvalues$ReactTemplate.bfield(b, 0));
          if (match$5.tag === 4) {
            match$4 = /* tuple */[
              match$5[0] + Cbytecodes$ReactTemplate.last_variant_tag | 0,
              1
            ];
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "vnorm.ml",
                    170,
                    10
                  ]
                ];
          }
        } else {
          match$4 = /* tuple */[
            tag$1,
            0
          ];
        }
        var match$6 = construct_of_constr_block(env$1, match$4[0], typ);
        var args = nf_bargs(env$1, sigma$1, b, match$4[1], match$6[1]);
        return Constr$ReactTemplate.mkApp(/* tuple */[
                    match$6[0],
                    args
                  ]);
    case 6 : 
        var match$7 = whd[0];
        switch (match$7.tag | 0) {
          case 0 : 
              var env$3 = env$1;
              var sigma$2 = sigma$1;
              var idkey = match$7[0];
              var stk = whd[1];
              switch (idkey.tag | 0) {
                case 0 : 
                    var cst = idkey[0];
                    var cbody = Environ$ReactTemplate.lookup_constant(cst, env$3);
                    var nb_univs = Univ$ReactTemplate.AUContext[/* size */4](Declareops$ReactTemplate.constant_polymorphic_context(cbody));
                    var mk = function (u) {
                      var pcst = /* tuple */[
                        cst,
                        u
                      ];
                      return /* tuple */[
                              Constr$ReactTemplate.mkConstU(pcst),
                              Typeops$ReactTemplate.type_of_constant_in(env$3, pcst)
                            ];
                    };
                    return nf_univ_args(nb_univs, mk, env$3, sigma$2, stk);
                case 1 : 
                    var id = idkey[0];
                    var ty = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], Environ$ReactTemplate.lookup_named(id, env$3));
                    return nf_stk(/* None */0, env$3, sigma$2, Constr$ReactTemplate.mkVar(id), ty, stk);
                case 2 : 
                    var n = Environ$ReactTemplate.nb_rel(env$3) - idkey[0] | 0;
                    var ty$1 = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], Environ$ReactTemplate.lookup_rel(n, env$3));
                    return nf_stk(/* None */0, env$3, sigma$2, Constr$ReactTemplate.mkRel(n), Vars$ReactTemplate.lift(n)(ty$1), stk);
                case 3 : 
                    var env$4 = env$3;
                    var sigma$3 = sigma$2;
                    var evk = idkey[0];
                    var stk$1 = stk;
                    var evi;
                    try {
                      evi = Evd$ReactTemplate.find(sigma$3, evk);
                    }
                    catch (exn){
                      if (exn === Caml_builtin_exceptions.not_found) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              [
                                "vnorm.ml",
                                206,
                                53
                              ]
                            ];
                      } else {
                        throw exn;
                      }
                    }
                    var hyps = Environ$ReactTemplate.named_context_of_val(Evd$ReactTemplate.evar_filtered_hyps(evi));
                    var concl = Evd$ReactTemplate.evar_concl(evi);
                    if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], hyps)) {
                      return nf_stk(/* None */0, env$4, sigma$3, Constr$ReactTemplate.mkEvar(/* tuple */[
                                      evk,
                                      /* array */[]
                                    ]), concl, stk$1);
                    } else if (stk$1) {
                      var match$8 = stk$1[0];
                      if (match$8.tag) {
                        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Argument size mismatch when decompiling an evar"));
                      } else {
                        var fold = function (accu, d) {
                          return Term$ReactTemplate.mkNamedProd_or_LetIn(d, accu);
                        };
                        var t$2 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], fold, concl, hyps);
                        var match$9 = nf_args(env$4, sigma$3, match$8[0], /* None */0, t$2);
                        var match$10 = Util$ReactTemplate.$$Array[/* chop */46](Curry._1(Util$ReactTemplate.List[/* length */0], hyps), match$9[1]);
                        var c = Constr$ReactTemplate.mkApp(/* tuple */[
                              Constr$ReactTemplate.mkEvar(/* tuple */[
                                    evk,
                                    match$10[0]
                                  ]),
                              match$10[1]
                            ]);
                        return nf_stk(/* None */0, env$4, sigma$3, c, match$9[0], stk$1[1]);
                      }
                    } else {
                      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Argument size mismatch when decompiling an evar"));
                    }
                
              }
          case 1 : 
              var ind = match$7[0];
              var mib = Environ$ReactTemplate.lookup_mind(ind[0], env$1);
              var nb_univs$1 = Univ$ReactTemplate.AUContext[/* size */4](Declareops$ReactTemplate.inductive_polymorphic_context(mib));
              var mk$1 = function (u) {
                var pind = /* tuple */[
                  ind,
                  u
                ];
                return /* tuple */[
                        Constr$ReactTemplate.mkIndU(pind),
                        type_of_ind(env$1, pind)
                      ];
              };
              return nf_univ_args(nb_univs$1, mk$1, env$1, sigma$1, whd[1]);
          case 2 : 
              if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], whd[1])) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "vnorm.ml",
                        187,
                        4
                      ]
                    ];
              }
              return Constr$ReactTemplate.mkSort(match$7[0]);
          
        }
        break;
    case 7 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "vnorm.ml",
                189,
                4
              ]
            ];
    
  }
}

function nf_vtype(env, sigma, v) {
  return nf_val(env, sigma, v, Constr$ReactTemplate.mkSet);
}

function nf_univ_args(nb_univs, mk, env, sigma, stk) {
  var u;
  if (nb_univs) {
    if (stk) {
      var match = stk[0];
      if (match.tag) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "vnorm.ml",
                200,
                11
              ]
            ];
      } else {
        var args = match[0];
        u = Univ$ReactTemplate.Instance[/* of_array */2](Util$ReactTemplate.$$Array[/* init */0](nb_univs, (function (i) {
                    return Vmvalues$ReactTemplate.uni_lvl_val(Vmvalues$ReactTemplate.arg(args, i));
                  })));
      }
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "vnorm.ml",
              200,
              11
            ]
          ];
    }
  } else {
    u = Univ$ReactTemplate.Instance[/* empty */0];
  }
  var match$1 = Curry._1(mk, u);
  return nf_stk(/* Some */[nb_univs], env, sigma, match$1[0], match$1[1], stk);
}

function nf_stk(_$staropt$star, env, sigma, _c, _t, _stk) {
  while(true) {
    var stk = _stk;
    var t = _t;
    var c = _c;
    var $staropt$star = _$staropt$star;
    var from = $staropt$star ? $staropt$star[0] : 0;
    if (stk) {
      var match = stk[0];
      switch (match.tag | 0) {
        case 0 : 
            var stk$1 = stk[1];
            var vargs = match[0];
            if (Vmvalues$ReactTemplate.nargs(vargs) >= from) {
              var match$1 = nf_args(env, sigma, vargs, /* Some */[from], t);
              _stk = stk$1;
              _t = match$1[0];
              _c = Constr$ReactTemplate.mkApp(/* tuple */[
                    c,
                    match$1[1]
                  ]);
              _$staropt$star = /* None */0;
              continue ;
              
            } else {
              var rest = from - Vmvalues$ReactTemplate.nargs(vargs) | 0;
              _stk = stk$1;
              _$staropt$star = /* Some */[rest];
              continue ;
              
            }
            break;
        case 1 : 
            if (from !== 0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "vnorm.ml",
                      256,
                      6
                    ]
                  ];
            }
            var match$2 = nf_fix_app(env, sigma, match[0], match[1]);
            var match$3 = decompose_prod(env, match$2[1]);
            _stk = stk[1];
            _t = Vars$ReactTemplate.subst1(c, match$3[2]);
            _c = Constr$ReactTemplate.mkApp(/* tuple */[
                  match$2[0],
                  /* array */[c]
                ]);
            _$staropt$star = /* None */0;
            continue ;
            case 2 : 
            var sw = match[0];
            if (from !== 0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "vnorm.ml",
                      261,
                      6
                    ]
                  ];
            }
            var match$4 = find_rectype_a(env, t);
            var match$5 = match$4[0];
            var u = match$5[1];
            var ind = match$5[0];
            var match$6 = Inductive$ReactTemplate.lookup_mind_specif(env, ind);
            var mip = match$6[1];
            var mib = match$6[0];
            var nparams = mib[/* mind_nparams */5];
            var match$7 = Util$ReactTemplate.$$Array[/* chop */46](nparams, match$4[1]);
            var params = match$7[0];
            var nparamdecls = Curry._1(Context$ReactTemplate.Rel[/* length */3], Inductive$ReactTemplate.inductive_paramdecls(/* tuple */[
                      mib,
                      u
                    ]));
            var pT = Reduction$ReactTemplate.hnf_prod_applist_assum(env, nparamdecls, type_of_ind(env, /* tuple */[
                      ind,
                      u
                    ]), Util$ReactTemplate.$$Array[/* to_list */9](params));
            var pT$1 = Reduction$ReactTemplate.whd_all(env, pT);
            var match$8 = nf_predicate(env, sigma, /* tuple */[
                  ind,
                  u
                ], mip, params, Vm$ReactTemplate.type_of_switch(sw), pT$1);
            var p = match$8[1];
            var dep = match$8[0];
            var btypes = build_branches_type(env, sigma, ind, mib, mip, u, params, dep, p);
            var bsw = Vm$ReactTemplate.branch_of_switch(Environ$ReactTemplate.nb_rel(env), sw);
            var mkbranch = (function(btypes){
            return function mkbranch(i, param) {
              var match = Caml_array.caml_array_get(btypes, i);
              var b = nf_val(Termops$ReactTemplate.push_rels_assum(match[0])(env), sigma, param[1], match[2]);
              return Termops$ReactTemplate.it_mkLambda_or_LetIn_from_no_LetIn(b, match[1]);
            }
            }(btypes));
            var branchs = Util$ReactTemplate.$$Array[/* mapi */14](mkbranch, bsw);
            var tcase = build_case_type(dep, p, match$7[1], c);
            var ci = sw[/* sw_annot */2][/* ci */0];
            _stk = stk[1];
            _t = tcase;
            _c = Constr$ReactTemplate.mkCase(/* tuple */[
                  ci,
                  p,
                  c,
                  branchs
                ]);
            _$staropt$star = /* None */0;
            continue ;
            case 3 : 
            if (from !== 0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "vnorm.ml",
                      285,
                      5
                    ]
                  ];
            }
            var p$prime = Names$ReactTemplate.Projection[/* make */0](match[0], /* true */1);
            var ty = Inductiveops$ReactTemplate.type_of_projection_knowing_arg(env, sigma, p$prime, EConstr$ReactTemplate.of_constr(c), EConstr$ReactTemplate.of_constr(t));
            _stk = stk[1];
            _t = ty;
            _c = Constr$ReactTemplate.mkProj(/* tuple */[
                  p$prime,
                  c
                ]);
            _$staropt$star = /* None */0;
            continue ;
            
      }
    } else {
      return c;
    }
  };
}

function nf_predicate(env, sigma, ind, mip, params, v, pT) {
  var match = Vmvalues$ReactTemplate.whd_val(v);
  var match$1 = Constr$ReactTemplate.kind(pT);
  if (match.tag === 1) {
    var f = match[0];
    if (match$1.tag === 6) {
      var k = Environ$ReactTemplate.nb_rel(env);
      var vb = Vm$ReactTemplate.reduce_fun(k, f);
      var match$2 = decompose_prod(env, pT);
      var dom = match$2[1];
      var name = match$2[0];
      var match$3 = nf_predicate(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  name,
                  dom
                ]), env), sigma, ind, mip, params, vb, match$2[2]);
      return /* tuple */[
              match$3[0],
              Constr$ReactTemplate.mkLambda(/* tuple */[
                    name,
                    dom,
                    match$3[1]
                  ])
            ];
    } else {
      var k$1 = Environ$ReactTemplate.nb_rel(env);
      var vb$1 = Vm$ReactTemplate.reduce_fun(k$1, f);
      var name$1 = /* Name */[Names$ReactTemplate.Id[/* of_string */5]("c")];
      var n = mip[/* mind_nrealargs */5];
      var rargs = Util$ReactTemplate.$$Array[/* init */0](n, (function (i) {
              return Constr$ReactTemplate.mkRel(n - i | 0);
            }));
      var params$1 = n ? Util$ReactTemplate.$$Array[/* map */12](Vars$ReactTemplate.lift(n), params) : params;
      var dom$1 = Constr$ReactTemplate.mkApp(/* tuple */[
            Constr$ReactTemplate.mkIndU(ind),
            Util$ReactTemplate.$$Array[/* append */3](params$1, rargs)
          ]);
      var body = nf_vtype(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                  name$1,
                  dom$1
                ]), env), sigma, vb$1);
      return /* tuple */[
              /* true */1,
              Constr$ReactTemplate.mkLambda(/* tuple */[
                    name$1,
                    dom$1,
                    body
                  ])
            ];
    }
  } else {
    return /* tuple */[
            /* false */0,
            nf_val(env, sigma, v, Constr$ReactTemplate.mkSet)
          ];
  }
}

function nf_args(env, sigma, vargs, $staropt$star, t) {
  var f = $staropt$star ? $staropt$star[0] : 0;
  var t$1 = [t];
  var len = Vmvalues$ReactTemplate.nargs(vargs) - f | 0;
  var args = Util$ReactTemplate.$$Array[/* init */0](len, (function (i) {
          var match = decompose_prod(env, t$1[0]);
          var c = nf_val(env, sigma, Vmvalues$ReactTemplate.arg(vargs, f + i | 0), match[1]);
          t$1[0] = Vars$ReactTemplate.subst1(c, match[2]);
          return c;
        }));
  return /* tuple */[
          t$1[0],
          args
        ];
}

function nf_bargs(env, sigma, b, ofs, t) {
  var t$1 = [t];
  var len = Vmvalues$ReactTemplate.bsize(b) - ofs | 0;
  return Util$ReactTemplate.$$Array[/* init */0](len, (function (i) {
                var match = decompose_prod(env, t$1[0]);
                var c = nf_val(env, sigma, Vmvalues$ReactTemplate.bfield(b, i + ofs | 0), match[1]);
                t$1[0] = Vars$ReactTemplate.subst1(c, match[2]);
                return c;
              }));
}

function nf_fun(env, sigma, f, typ) {
  var k = Environ$ReactTemplate.nb_rel(env);
  var vb = Vm$ReactTemplate.reduce_fun(k, f);
  var match;
  try {
    match = decompose_prod(env, typ);
  }
  catch (exn){
    if (exn === Constr$ReactTemplate.DestKO) {
      match = CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.strbrk("Returned a functional value in a type not recognized as a product type."));
    } else {
      throw exn;
    }
  }
  var dom = match[1];
  var name = match[0];
  var body = nf_val(Environ$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
              name,
              dom
            ]), env), sigma, vb, match[2]);
  return Constr$ReactTemplate.mkLambda(/* tuple */[
              name,
              dom,
              body
            ]);
}

function nf_fix(env, sigma, f) {
  var init = Vmvalues$ReactTemplate.current_fix(f);
  var rec_args = Vmvalues$ReactTemplate.rec_args(f);
  var k = Environ$ReactTemplate.nb_rel(env);
  var match = Vm$ReactTemplate.reduce_fix(k, f);
  var vt = match[1];
  var ndef = vt.length;
  var ft = Util$ReactTemplate.$$Array[/* map */12]((function (v) {
          return nf_val(env, sigma, v, Constr$ReactTemplate.mkSet);
        }), vt);
  var name = Util$ReactTemplate.$$Array[/* init */0](ndef, (function () {
          return /* Name */[Names$ReactTemplate.Id[/* of_string */5]("Ffix")];
        }));
  var env$1 = Environ$ReactTemplate.push_rec_types(/* tuple */[
        name,
        ft,
        ft
      ], env);
  var norm_vb = function (v, t) {
    return nf_fun(env$1, sigma, v, Vars$ReactTemplate.lift(ndef)(t));
  };
  var fb = Util$ReactTemplate.$$Array[/* map2 */49](norm_vb, match[0], ft);
  return Constr$ReactTemplate.mkFix(/* tuple */[
              /* tuple */[
                rec_args,
                init
              ],
              /* tuple */[
                name,
                ft,
                fb
              ]
            ]);
}

function nf_fix_app(env, sigma, f, vargs) {
  var fd = nf_fix(env, sigma, f);
  var match = Constr$ReactTemplate.destFix(fd);
  var t = Caml_array.caml_array_get(match[1][1], match[0][1]);
  var match$1 = nf_args(env, sigma, vargs, /* None */0, t);
  return /* tuple */[
          Constr$ReactTemplate.mkApp(/* tuple */[
                fd,
                match$1[1]
              ]),
          match$1[0]
        ];
}

function nf_cofix(env, sigma, cf) {
  var init = Vmvalues$ReactTemplate.current_cofix(cf);
  var k = Environ$ReactTemplate.nb_rel(env);
  var match = Vm$ReactTemplate.reduce_cofix(k, cf);
  var vt = match[1];
  var ndef = vt.length;
  var cft = Util$ReactTemplate.$$Array[/* map */12]((function (v) {
          return nf_val(env, sigma, v, Constr$ReactTemplate.mkSet);
        }), vt);
  var name = Util$ReactTemplate.$$Array[/* init */0](ndef, (function () {
          return /* Name */[Names$ReactTemplate.Id[/* of_string */5]("Fcofix")];
        }));
  var env$1 = Environ$ReactTemplate.push_rec_types(/* tuple */[
        name,
        cft,
        cft
      ], env);
  var cfb = Util$ReactTemplate.$$Array[/* map2 */49]((function (v, t) {
          return nf_val(env$1, sigma, v, t);
        }), match[0], cft);
  return Constr$ReactTemplate.mkCoFix(/* tuple */[
              init,
              /* tuple */[
                name,
                cft,
                cfb
              ]
            ]);
}

function cbv_vm(env, sigma, c, t) {
  if (Termops$ReactTemplate.occur_meta(sigma, c)) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("vm_compute does not support metas."));
  }
  var c$1 = EConstr$ReactTemplate.to_constr(sigma, c);
  var t$1 = EConstr$ReactTemplate.to_constr(sigma, t);
  var v = Vconv$ReactTemplate.val_of_constr(env, c$1);
  return EConstr$ReactTemplate.of_constr(nf_val(env, sigma, v, t$1));
}

function vm_infer_conv($staropt$star, env, sigma, t1, t2) {
  var pb = $staropt$star ? $staropt$star[0] : /* CUMUL */1;
  return Reductionops$ReactTemplate.infer_conv_gen((function (pb, _, _$1, _$2) {
                return (function (param, param$1, param$2, param$3) {
                    return Vconv$ReactTemplate.vm_conv_gen(pb, param, param$1, param$2, param$3);
                  });
              }), /* Some */[/* true */1], /* Some */[pb], /* None */0, env, sigma, t1, t2);
}

if (Coq_config$ReactTemplate.bytecode_compiler) {
  Reductionops$ReactTemplate.set_vm_infer_conv(vm_infer_conv);
}

exports.cbv_vm = cbv_vm;
/*  Not a pure module */
