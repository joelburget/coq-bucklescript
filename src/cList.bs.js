// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function map_loop(f, _p, _param) {
  while(true) {
    var param = _param;
    var p = _p;
    if (param) {
      var c = /* record */[
        /* head */Curry._1(f, param[0]),
        /* tail : [] */0
      ];
      p[/* tail */1] = c;
      _param = param[1];
      _p = c;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function map(f, param) {
  if (param) {
    var c = /* record */[
      /* head */Curry._1(f, param[0]),
      /* tail : [] */0
    ];
    map_loop(f, c, param[1]);
    return c;
  } else {
    return /* [] */0;
  }
}

function map2_loop(f, _p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var p = _p;
    if (l1) {
      if (l2) {
        var c = /* record */[
          /* head */Curry._2(f, l1[0], l2[0]),
          /* tail : [] */0
        ];
        p[/* tail */1] = c;
        _l2 = l2[1];
        _l1 = l1[1];
        _p = c;
        continue ;
        
      } else {
        return Pervasives.invalid_arg("List.map2");
      }
    } else if (l2) {
      return Pervasives.invalid_arg("List.map2");
    } else {
      return /* () */0;
    }
  };
}

function map2(f, l1, l2) {
  if (l1) {
    if (l2) {
      var c = /* record */[
        /* head */Curry._2(f, l1[0], l2[0]),
        /* tail : [] */0
      ];
      map2_loop(f, c, l1[1], l2[1]);
      return c;
    } else {
      return Pervasives.invalid_arg("List.map2");
    }
  } else if (l2) {
    return Pervasives.invalid_arg("List.map2");
  } else {
    return /* [] */0;
  }
}

function map_of_array_loop(f, _p, a, _i, l) {
  while(true) {
    var i = _i;
    var p = _p;
    if (i === l) {
      return /* () */0;
    } else {
      var c = /* record */[
        /* head */Curry._1(f, a[i]),
        /* tail : [] */0
      ];
      p[/* tail */1] = c;
      _i = i + 1 | 0;
      _p = c;
      continue ;
      
    }
  };
}

function map_of_array(f, a) {
  var l = a.length;
  if (l) {
    var c = /* record */[
      /* head */Curry._1(f, a[0]),
      /* tail : [] */0
    ];
    map_of_array_loop(f, c, a, 1, l);
    return c;
  } else {
    return /* [] */0;
  }
}

function append_loop(_p, tl, _param) {
  while(true) {
    var param = _param;
    var p = _p;
    if (param) {
      var c = /* record */[
        /* head */param[0],
        /* tail : [] */0
      ];
      p[/* tail */1] = c;
      _param = param[1];
      _p = c;
      continue ;
      
    } else {
      p[/* tail */1] = tl;
      return /* () */0;
    }
  };
}

function append(l1, l2) {
  if (l1) {
    var c = /* record */[
      /* head */l1[0],
      /* tail : [] */0
    ];
    append_loop(c, l2, l1[1]);
    return c;
  } else {
    return l2;
  }
}

function copy(_p, _param) {
  while(true) {
    var param = _param;
    var p = _p;
    if (param) {
      var c = /* record */[
        /* head */param[0],
        /* tail : [] */0
      ];
      p[/* tail */1] = c;
      _param = param[1];
      _p = c;
      continue ;
      
    } else {
      return p;
    }
  };
}

function init_loop(len, f, _p, _i) {
  while(true) {
    var i = _i;
    var p = _p;
    if (i === len) {
      return /* () */0;
    } else {
      var c = /* record */[
        /* head */Curry._1(f, i),
        /* tail : [] */0
      ];
      p[/* tail */1] = c;
      _i = i + 1 | 0;
      _p = c;
      continue ;
      
    }
  };
}

function init(len, f) {
  if (len < 0) {
    return Pervasives.invalid_arg("List.init");
  } else if (len) {
    var c = /* record */[
      /* head */Curry._1(f, 0),
      /* tail : [] */0
    ];
    init_loop(len, f, c, 1);
    return c;
  } else {
    return /* [] */0;
  }
}

function concat_loop(_p, _param) {
  while(true) {
    var param = _param;
    var p = _p;
    if (param) {
      _param = param[1];
      _p = copy(p, param[0]);
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function concat(l) {
  var dummy = /* record */[
    /* head */0,
    /* tail : [] */0
  ];
  concat_loop(dummy, l);
  return dummy[/* tail */1];
}

function split_loop(_p, _q, _param) {
  while(true) {
    var param = _param;
    var q = _q;
    var p = _p;
    if (param) {
      var match = param[0];
      var cl = /* record */[
        /* head */match[0],
        /* tail : [] */0
      ];
      var cr = /* record */[
        /* head */match[1],
        /* tail : [] */0
      ];
      p[/* tail */1] = cl;
      q[/* tail */1] = cr;
      _param = param[1];
      _q = cr;
      _p = cl;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function split(param) {
  if (param) {
    var match = param[0];
    var cl = /* record */[
      /* head */match[0],
      /* tail : [] */0
    ];
    var cr = /* record */[
      /* head */match[1],
      /* tail : [] */0
    ];
    split_loop(cl, cr, param[1]);
    return /* tuple */[
            cl,
            cr
          ];
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function combine_loop(_p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var p = _p;
    if (l1) {
      if (l2) {
        var c = /* record */[
          /* head : tuple */[
            l1[0],
            l2[0]
          ],
          /* tail : [] */0
        ];
        p[/* tail */1] = c;
        _l2 = l2[1];
        _l1 = l1[1];
        _p = c;
        continue ;
        
      } else {
        return Pervasives.invalid_arg("List.combine");
      }
    } else if (l2) {
      return Pervasives.invalid_arg("List.combine");
    } else {
      return /* () */0;
    }
  };
}

function combine(l1, l2) {
  if (l1) {
    if (l2) {
      var c = /* record */[
        /* head : tuple */[
          l1[0],
          l2[0]
        ],
        /* tail : [] */0
      ];
      combine_loop(c, l1[1], l2[1]);
      return c;
    } else {
      return Pervasives.invalid_arg("List.combine");
    }
  } else if (l2) {
    return Pervasives.invalid_arg("List.combine");
  } else {
    return /* [] */0;
  }
}

function filter_loop(f, _p, _param) {
  while(true) {
    var param = _param;
    var p = _p;
    if (param) {
      var l = param[1];
      var x = param[0];
      if (Curry._1(f, x)) {
        var c = /* record */[
          /* head */x,
          /* tail : [] */0
        ];
        p[/* tail */1] = c;
        _param = l;
        _p = c;
        continue ;
        
      } else {
        _param = l;
        continue ;
        
      }
    } else {
      return /* () */0;
    }
  };
}

function filter(f, l) {
  var c = /* record */[
    /* head */0,
    /* tail : [] */0
  ];
  filter_loop(f, c, l);
  return c[/* tail */1];
}

function map_i_loop(f, _i, _p, _param) {
  while(true) {
    var param = _param;
    var p = _p;
    var i = _i;
    if (param) {
      var c = /* record */[
        /* head */Curry._2(f, i, param[0]),
        /* tail : [] */0
      ];
      p[/* tail */1] = c;
      _param = param[1];
      _p = c;
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function map_i(f, i, param) {
  if (param) {
    var c = /* record */[
      /* head */Curry._2(f, i, param[0]),
      /* tail : [] */0
    ];
    map_i_loop(f, i + 1 | 0, c, param[1]);
    return c;
  } else {
    return /* [] */0;
  }
}

function compare(cmp, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1 === l2) {
      return 0;
    } else if (l1) {
      if (l2) {
        var c = Curry._2(cmp, l1[0], l2[0]);
        if (c !== 0) {
          return c;
        } else {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
          
        }
      } else {
        return 1;
      }
    } else if (l2) {
      return -1;
    } else {
      return 0;
    }
  };
}

function equal(cmp, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1 === l2) {
      return /* true */1;
    } else if (l1) {
      if (l2) {
        if (Curry._2(cmp, l1[0], l2[0])) {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else if (l2) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
}

function is_empty(param) {
  if (param) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function mem_f(cmp, x, l) {
  return List.exists(Curry._1(cmp, x), l);
}

function intersect(cmp, l1, l2) {
  return filter((function (x) {
                return List.exists(Curry._1(cmp, x), l2);
              }), l1);
}

function union(cmp, l1, l2) {
  var urec = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[1];
        var a = param[0];
        if (List.exists(Curry._1(cmp, a), l2)) {
          _param = l;
          continue ;
          
        } else {
          return /* :: */[
                  a,
                  urec(l)
                ];
        }
      } else {
        return l2;
      }
    };
  };
  return urec(l1);
}

function subtract(cmp, l1, l2) {
  if (is_empty(l2)) {
    return l1;
  } else {
    return List.filter((function (x) {
                    return 1 - List.exists(Curry._1(cmp, x), l2);
                  }))(l1);
  }
}

function unionq(l1, l2) {
  return union((function (prim, prim$1) {
                return +(prim === prim$1);
              }), l1, l2);
}

function subtractq(l1, l2) {
  return subtract((function (prim, prim$1) {
                return +(prim === prim$1);
              }), l1, l2);
}

function interval(n, m) {
  var _param = /* tuple */[
    /* [] */0,
    m
  ];
  while(true) {
    var param = _param;
    var m$1 = param[1];
    var l = param[0];
    if (n > m$1) {
      return l;
    } else {
      _param = /* tuple */[
        /* :: */[
          m$1,
          l
        ],
        m$1 - 1 | 0
      ];
      continue ;
      
    }
  };
}

function addn(n, v) {
  if (n < 0) {
    return Pervasives.invalid_arg("List.addn");
  } else {
    return (function (param) {
        var _n = n;
        var _l = param;
        while(true) {
          var l = _l;
          var n$1 = _n;
          if (n$1) {
            _l = /* :: */[
              v,
              l
            ];
            _n = n$1 - 1 | 0;
            continue ;
            
          } else {
            return l;
          }
        };
      });
  }
}

function make(n, v) {
  return addn(n, v)(/* [] */0);
}

function assign(l, n, e) {
  var _stk = /* [] */0;
  var _l = l;
  var _i = n;
  while(true) {
    var i = _i;
    var l$1 = _l;
    var stk = _stk;
    if (l$1) {
      var t = l$1[1];
      if (i !== 0) {
        _i = i - 1 | 0;
        _l = t;
        _stk = /* :: */[
          l$1[0],
          stk
        ];
        continue ;
        
      } else {
        return List.rev_append(stk, /* :: */[
                    e,
                    t
                  ]);
      }
    } else {
      return Pervasives.failwith("List.assign");
    }
  };
}

function smartmap(f, l) {
  if (l) {
    var tl = l[1];
    var h = l[0];
    var h$prime = Curry._1(f, h);
    var tl$prime = smartmap(f, tl);
    if (h$prime === h && tl$prime === tl) {
      return l;
    } else {
      return /* :: */[
              h$prime,
              tl$prime
            ];
    }
  } else {
    return l;
  }
}

function map2_i(f, i, l1, l2) {
  var map_i = function (i, param) {
    var match = param[0];
    if (match) {
      var match$1 = param[1];
      if (match$1) {
        var v = Curry._3(f, i, match[0], match$1[0]);
        return /* :: */[
                v,
                map_i(i + 1 | 0, /* tuple */[
                      match[1],
                      match$1[1]
                    ])
              ];
      } else {
        return Pervasives.invalid_arg("map2_i");
      }
    } else if (param[1]) {
      return Pervasives.invalid_arg("map2_i");
    } else {
      return /* [] */0;
    }
  };
  return map_i(i, /* tuple */[
              l1,
              l2
            ]);
}

function map3(f, l1, l2, l3) {
  var map = function (param) {
    var match = param[0];
    if (match) {
      var match$1 = param[1];
      if (match$1) {
        var match$2 = param[2];
        if (match$2) {
          var v = Curry._3(f, match[0], match$1[0], match$2[0]);
          return /* :: */[
                  v,
                  map(/* tuple */[
                        match[1],
                        match$1[1],
                        match$2[1]
                      ])
                ];
        } else {
          return Pervasives.invalid_arg("map3");
        }
      } else {
        return Pervasives.invalid_arg("map3");
      }
    } else if (param[1] || param[2]) {
      return Pervasives.invalid_arg("map3");
    } else {
      return /* [] */0;
    }
  };
  return map(/* tuple */[
              l1,
              l2,
              l3
            ]);
}

function map4(f, l1, l2, l3, l4) {
  var map = function (param) {
    var match = param[0];
    if (match) {
      var match$1 = param[1];
      if (match$1) {
        var match$2 = param[2];
        if (match$2) {
          var match$3 = param[3];
          if (match$3) {
            var v = Curry._4(f, match[0], match$1[0], match$2[0], match$3[0]);
            return /* :: */[
                    v,
                    map(/* tuple */[
                          match[1],
                          match$1[1],
                          match$2[1],
                          match$3[1]
                        ])
                  ];
          } else {
            return Pervasives.invalid_arg("map4");
          }
        } else {
          return Pervasives.invalid_arg("map4");
        }
      } else {
        return Pervasives.invalid_arg("map4");
      }
    } else if (param[1] || param[2] || param[3]) {
      return Pervasives.invalid_arg("map4");
    } else {
      return /* [] */0;
    }
  };
  return map(/* tuple */[
              l1,
              l2,
              l3,
              l4
            ]);
}

function smartfilter(f, l) {
  if (l) {
    var tl = l[1];
    var h = l[0];
    var tl$prime = smartfilter(f, tl);
    if (Curry._1(f, h)) {
      if (tl$prime === tl) {
        return l;
      } else {
        return /* :: */[
                h,
                tl$prime
              ];
      }
    } else {
      return tl$prime;
    }
  } else {
    return l;
  }
}

function extend(l, a, l$prime) {
  if (l) {
    if (l[0] !== 0) {
      if (l$prime) {
        return /* :: */[
                l$prime[0],
                extend(l[1], a, l$prime[1])
              ];
      } else {
        return Pervasives.invalid_arg("extend");
      }
    } else {
      return /* :: */[
              a,
              extend(l[1], a, l$prime)
            ];
    }
  } else if (l$prime) {
    return Pervasives.invalid_arg("extend");
  } else {
    return /* [] */0;
  }
}

function count(f, l) {
  var _acc = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var t = param[1];
      if (Curry._1(f, param[0])) {
        _param = t;
        _acc = acc + 1 | 0;
        continue ;
        
      } else {
        _param = t;
        continue ;
        
      }
    } else {
      return acc;
    }
  };
}

function index_f(f, x, _l, _n) {
  while(true) {
    var n = _n;
    var l = _l;
    if (l) {
      if (Curry._2(f, x, l[0])) {
        return n;
      } else {
        _n = n + 1 | 0;
        _l = l[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function index(f, x, l) {
  return index_f(f, x, l, 1);
}

function index0(f, x, l) {
  return index_f(f, x, l, 0);
}

function fold_left_until(f, accu, s) {
  var _accu = accu;
  var _param = s;
  while(true) {
    var param = _param;
    var accu$1 = _accu;
    if (param) {
      var match = Curry._2(f, accu$1, param[0]);
      if (match.tag) {
        _param = param[1];
        _accu = match[0];
        continue ;
        
      } else {
        return match[0];
      }
    } else {
      return accu$1;
    }
  };
}

function fold_right_i(f, i, l) {
  var it_f = function (i, l, a) {
    if (l) {
      return Curry._3(f, i - 1 | 0, l[0], it_f(i - 1 | 0, l[1], a));
    } else {
      return a;
    }
  };
  var partial_arg = List.length(l) + i | 0;
  return (function (param) {
      return it_f(partial_arg, l, param);
    });
}

function fold_left_i(f) {
  var it_list_f = function (_i, _a, _param) {
    while(true) {
      var param = _param;
      var a = _a;
      var i = _i;
      if (param) {
        _param = param[1];
        _a = Curry._3(f, i, a, param[0]);
        _i = i + 1 | 0;
        continue ;
        
      } else {
        return a;
      }
    };
  };
  return it_list_f;
}

function fold_left3(f, _accu, _l1, _l2, _l3) {
  while(true) {
    var l3 = _l3;
    var l2 = _l2;
    var l1 = _l1;
    var accu = _accu;
    if (l1) {
      if (l2) {
        if (l3) {
          _l3 = l3[1];
          _l2 = l2[1];
          _l1 = l1[1];
          _accu = Curry._4(f, accu, l1[0], l2[0], l3[0]);
          continue ;
          
        } else {
          return Pervasives.invalid_arg("List.fold_left3");
        }
      } else {
        return Pervasives.invalid_arg("List.fold_left3");
      }
    } else if (l2 || l3) {
      return Pervasives.invalid_arg("List.fold_left3");
    } else {
      return accu;
    }
  };
}

function fold_left4(f, _accu, _l1, _l2, _l3, _l4) {
  while(true) {
    var l4 = _l4;
    var l3 = _l3;
    var l2 = _l2;
    var l1 = _l1;
    var accu = _accu;
    if (l1) {
      if (l2) {
        if (l3) {
          if (l4) {
            _l4 = l4[1];
            _l3 = l3[1];
            _l2 = l2[1];
            _l1 = l1[1];
            _accu = Curry._5(f, accu, l1[0], l2[0], l3[0], l4[0]);
            continue ;
            
          } else {
            return Pervasives.invalid_arg("List.fold_left4");
          }
        } else {
          return Pervasives.invalid_arg("List.fold_left4");
        }
      } else {
        return Pervasives.invalid_arg("List.fold_left4");
      }
    } else if (l2 || l3 || l4) {
      return Pervasives.invalid_arg("List.fold_left4");
    } else {
      return accu;
    }
  };
}

function fold_right_and_left(f, l, hd) {
  var aux = function (tl, param) {
    if (param) {
      var a = param[0];
      var hd$1 = aux(/* :: */[
            a,
            tl
          ], param[1]);
      return Curry._3(f, hd$1, a, tl);
    } else {
      return hd;
    }
  };
  return aux(/* [] */0, l);
}

function fold_left2_set(e, f, x, l1, l2) {
  if (l1) {
    var l1$1 = l1[1];
    var a1 = l1[0];
    var _seen = /* [] */0;
    var _param = l2;
    while(true) {
      var param = _param;
      var seen = _seen;
      if (param) {
        var l2$1 = param[1];
        var a2 = param[0];
        try {
          return fold_left2_set(e, f, Curry._5(f, x, a1, a2, l1$1, l2$1), l1$1, List.rev_append(seen, l2$1));
        }
        catch (raw_e$prime){
          var e$prime = Js_exn.internalToOCamlException(raw_e$prime);
          if (Caml_obj.caml_equal(e$prime, e)) {
            _param = l2$1;
            _seen = /* :: */[
              a2,
              seen
            ];
            continue ;
            
          } else {
            throw e$prime;
          }
        }
      } else {
        throw e;
      }
    };
  } else if (l2) {
    throw e;
  } else {
    return x;
  }
}

function iteri(f, l) {
  return fold_left_i((function (i, _, x) {
                  return Curry._2(f, i, x);
                }))(0, /* () */0, l);
}

function for_all_i(p) {
  var for_all_p = function (_i, _param) {
    while(true) {
      var param = _param;
      var i = _i;
      if (param) {
        if (Curry._2(p, i, param[0])) {
          _param = param[1];
          _i = i + 1 | 0;
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* true */1;
      }
    };
  };
  return for_all_p;
}

function except(cmp, x, l) {
  return List.filter((function (y) {
                  return 1 - Curry._2(cmp, x, y);
                }))(l);
}

function remove_first(p, param) {
  if (param) {
    var l = param[1];
    var b = param[0];
    if (Curry._1(p, b)) {
      return l;
    } else {
      return /* :: */[
              b,
              remove_first(p, l)
            ];
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function extract_first(p, li) {
  var _rev_left = /* [] */0;
  var _param = li;
  while(true) {
    var param = _param;
    var rev_left = _rev_left;
    if (param) {
      var right = param[1];
      var x = param[0];
      if (Curry._1(p, x)) {
        return /* tuple */[
                List.rev_append(rev_left, right),
                x
              ];
      } else {
        _param = right;
        _rev_left = /* :: */[
          x,
          rev_left
        ];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function insert(p, v, l) {
  var insrec = function (param) {
    if (param) {
      var tl = param[1];
      var h = param[0];
      if (Curry._2(p, v, h)) {
        return /* :: */[
                v,
                /* :: */[
                  h,
                  tl
                ]
              ];
      } else {
        return /* :: */[
                h,
                insrec(tl)
              ];
      }
    } else {
      return /* :: */[
              v,
              /* [] */0
            ];
    }
  };
  return insrec(l);
}

function add_set(cmp, x, l) {
  if (List.exists(Curry._1(cmp, x), l)) {
    return l;
  } else {
    return /* :: */[
            x,
            l
          ];
  }
}

function eq_set(cmp, l1, l2) {
  try {
    var _l1 = l1;
    var _param = l2;
    while(true) {
      var param = _param;
      var l1$1 = _l1;
      if (param) {
        _param = param[1];
        _l1 = remove_first(Curry._1(cmp, param[0]), l1$1);
        continue ;
        
      } else {
        return is_empty(l1$1);
      }
    };
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function for_all2eq(f, l1, l2) {
  try {
    return List.for_all2(f, l1, l2);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function filteri(p) {
  var filter_i_rec = function (i, param) {
    if (param) {
      var x = param[0];
      var l$prime = filter_i_rec(i + 1 | 0, param[1]);
      if (Curry._2(p, i, x)) {
        return /* :: */[
                x,
                l$prime
              ];
      } else {
        return l$prime;
      }
    } else {
      return /* [] */0;
    }
  };
  return (function (param) {
      return filter_i_rec(0, param);
    });
}

function partitioni(p) {
  var aux = function (i, param) {
    if (param) {
      var x = param[0];
      var match = aux(i + 1 | 0, param[1]);
      var l2 = match[1];
      var l1 = match[0];
      if (Curry._2(p, i, x)) {
        return /* tuple */[
                /* :: */[
                  x,
                  l1
                ],
                l2
              ];
      } else {
        return /* tuple */[
                l1,
                /* :: */[
                  x,
                  l2
                ]
              ];
      }
    } else {
      return /* tuple */[
              /* [] */0,
              /* [] */0
            ];
    }
  };
  return (function (param) {
      return aux(0, param);
    });
}

function sep_last(param) {
  if (param) {
    var tl = param[1];
    var hd = param[0];
    if (tl) {
      var match = sep_last(tl);
      return /* tuple */[
              match[0],
              /* :: */[
                hd,
                match[1]
              ]
            ];
    } else {
      return /* tuple */[
              hd,
              /* [] */0
            ];
    }
  } else {
    return Pervasives.failwith("sep_last");
  }
}

function find_map(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = Curry._1(f, param[0]);
      if (match) {
        return match[0];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function uniquize(l) {
  var visited = Hashtbl.create(/* None */0, 23);
  var _acc = /* [] */0;
  var _changed = /* false */0;
  var _param = l;
  while(true) {
    var param = _param;
    var changed = _changed;
    var acc = _acc;
    if (param) {
      var t = param[1];
      var h = param[0];
      if (Hashtbl.mem(visited, h)) {
        _param = t;
        _changed = /* true */1;
        continue ;
        
      } else {
        Hashtbl.add(visited, h, h);
        _param = t;
        _acc = /* :: */[
          h,
          acc
        ];
        continue ;
        
      }
    } else if (changed) {
      return List.rev(acc);
    } else {
      return l;
    }
  };
}

function uniquize_sorted(cmp, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      var a = param[0];
      if (l) {
        if (Curry._2(cmp, a, l[0])) {
          return /* :: */[
                  a,
                  uniquize_sorted(cmp, l)
                ];
        } else {
          _param = /* :: */[
            a,
            l[1]
          ];
          continue ;
          
        }
      } else {
        return /* :: */[
                a,
                uniquize_sorted(cmp, l)
              ];
      }
    } else {
      return /* [] */0;
    }
  };
}

function sort_uniquize(cmp, l) {
  return uniquize_sorted(cmp, List.sort(cmp, l));
}

function distinct(l) {
  var visited = Hashtbl.create(/* None */0, 23);
  var _param = l;
  while(true) {
    var param = _param;
    if (param) {
      var h = param[0];
      if (Hashtbl.mem(visited, h)) {
        return /* false */0;
      } else {
        Hashtbl.add(visited, h, h);
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* true */1;
    }
  };
}

function distinct_f(cmp, l) {
  var _param = List.sort(cmp, l);
  while(true) {
    var param = _param;
    if (param) {
      var l$1 = param[1];
      if (l$1) {
        if (Curry._2(cmp, param[0], l$1[0])) {
          _param = l$1;
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        _param = l$1;
        continue ;
        
      }
    } else {
      return /* true */1;
    }
  };
}

function merge_uniq(cmp, l1, l2) {
  if (l1) {
    if (l2) {
      var t2 = l2[1];
      var h2 = l2[0];
      var t1 = l1[1];
      var h1 = l1[0];
      var c = Curry._2(cmp, h1, h2);
      if (c) {
        if (c <= 0) {
          return /* :: */[
                  h1,
                  merge_uniq(cmp, t1, l2)
                ];
        } else {
          return /* :: */[
                  h2,
                  merge_uniq(cmp, l1, t2)
                ];
        }
      } else {
        return /* :: */[
                h1,
                merge_uniq(cmp, t1, t2)
              ];
      }
    } else {
      return l1;
    }
  } else {
    return l2;
  }
}

function duplicates(cmp, param) {
  if (param) {
    var l = param[1];
    var x = param[0];
    var l$prime = duplicates(cmp, l);
    if (List.exists(Curry._1(cmp, x), l)) {
      return add_set(cmp, x, l$prime);
    } else {
      return l$prime;
    }
  } else {
    return /* [] */0;
  }
}

function filter2_loop(f, _p, _q, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var q = _q;
    var p = _p;
    if (l1) {
      if (l2) {
        var l2$1 = l2[1];
        var y = l2[0];
        var l1$1 = l1[1];
        var x = l1[0];
        if (Curry._2(f, x, y)) {
          var c1 = /* record */[
            /* head */x,
            /* tail : [] */0
          ];
          var c2 = /* record */[
            /* head */y,
            /* tail : [] */0
          ];
          p[/* tail */1] = c1;
          q[/* tail */1] = c2;
          _l2 = l2$1;
          _l1 = l1$1;
          _q = c2;
          _p = c1;
          continue ;
          
        } else {
          _l2 = l2$1;
          _l1 = l1$1;
          continue ;
          
        }
      } else {
        return Pervasives.invalid_arg("List.filter2");
      }
    } else if (l2) {
      return Pervasives.invalid_arg("List.filter2");
    } else {
      return /* () */0;
    }
  };
}

function filter2(f, l1, l2) {
  var c1 = /* record */[
    /* head */0,
    /* tail : [] */0
  ];
  var c2 = /* record */[
    /* head */0,
    /* tail : [] */0
  ];
  filter2_loop(f, c1, c2, l1, l2);
  return /* tuple */[
          c1[/* tail */1],
          c2[/* tail */1]
        ];
}

function map_filter_loop(f, _p, _param) {
  while(true) {
    var param = _param;
    var p = _p;
    if (param) {
      var l = param[1];
      var match = Curry._1(f, param[0]);
      if (match) {
        var c = /* record */[
          /* head */match[0],
          /* tail : [] */0
        ];
        p[/* tail */1] = c;
        _param = l;
        _p = c;
        continue ;
        
      } else {
        _param = l;
        continue ;
        
      }
    } else {
      return /* () */0;
    }
  };
}

function map_filter(f, l) {
  var c = /* record */[
    /* head */0,
    /* tail : [] */0
  ];
  map_filter_loop(f, c, l);
  return c[/* tail */1];
}

function map_filter_i_loop(f, _i, _p, _param) {
  while(true) {
    var param = _param;
    var p = _p;
    var i = _i;
    if (param) {
      var l = param[1];
      var match = Curry._2(f, i, param[0]);
      if (match) {
        var c = /* record */[
          /* head */match[0],
          /* tail : [] */0
        ];
        p[/* tail */1] = c;
        _param = l;
        _p = c;
        _i = i + 1 | 0;
        continue ;
        
      } else {
        _param = l;
        _i = i + 1 | 0;
        continue ;
        
      }
    } else {
      return /* () */0;
    }
  };
}

function map_filter_i(f, l) {
  var c = /* record */[
    /* head */0,
    /* tail : [] */0
  ];
  map_filter_i_loop(f, 0, c, l);
  return c[/* tail */1];
}

function filter_with(_filter, _l) {
  while(true) {
    var l = _l;
    var filter = _filter;
    if (filter) {
      if (filter[0] !== 0) {
        if (l) {
          return /* :: */[
                  l[0],
                  filter_with(filter[1], l[1])
                ];
        } else {
          return Pervasives.invalid_arg("List.filter_with");
        }
      } else if (l) {
        _l = l[1];
        _filter = filter[1];
        continue ;
        
      } else {
        return Pervasives.invalid_arg("List.filter_with");
      }
    } else if (l) {
      return Pervasives.invalid_arg("List.filter_with");
    } else {
      return /* [] */0;
    }
  };
}

function subset(l1, l2) {
  var t2 = Hashtbl.create(/* None */0, 151);
  List.iter((function (x) {
          return Hashtbl.add(t2, x, /* () */0);
        }), l2);
  var look = function (param) {
    if (param) {
      try {
        Hashtbl.find(t2, param[0]);
        return look(param[1]);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* false */0;
        } else {
          throw exn;
        }
      }
    } else {
      return /* true */1;
    }
  };
  return look(l1);
}

var IndexOutOfRange = Caml_exceptions.create("CList-ReactTemplate.IndexOutOfRange");

function $$goto(n, l) {
  var _i = n;
  var _acc = /* [] */0;
  var _tl = l;
  while(true) {
    var tl = _tl;
    var acc = _acc;
    var i = _i;
    if (i) {
      if (tl) {
        _tl = tl[1];
        _acc = /* :: */[
          tl[0],
          acc
        ];
        _i = i - 1 | 0;
        continue ;
        
      } else {
        throw IndexOutOfRange;
      }
    } else {
      return /* tuple */[
              acc,
              tl
            ];
    }
  };
}

function chop(n, l) {
  try {
    var match = $$goto(n, l);
    return /* tuple */[
            List.rev(match[0]),
            match[1]
          ];
  }
  catch (exn){
    if (exn === IndexOutOfRange) {
      return Pervasives.failwith("List.chop");
    } else {
      throw exn;
    }
  }
}

function split_when(p) {
  return (function (param) {
      var _x = /* [] */0;
      var _y = param;
      while(true) {
        var y = _y;
        var x = _x;
        if (y) {
          var a = y[0];
          if (Curry._1(p, a)) {
            return /* tuple */[
                    List.rev(x),
                    y
                  ];
          } else {
            _y = y[1];
            _x = /* :: */[
              a,
              x
            ];
            continue ;
            
          }
        } else {
          return /* tuple */[
                  List.rev(x),
                  /* [] */0
                ];
        }
      };
    });
}

function split3(param) {
  if (param) {
    var match = param[0];
    var match$1 = split3(param[1]);
    return /* tuple */[
            /* :: */[
              match[0],
              match$1[0]
            ],
            /* :: */[
              match[1],
              match$1[1]
            ],
            /* :: */[
              match[2],
              match$1[2]
            ]
          ];
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0,
            /* [] */0
          ];
  }
}

function firstn(n, l) {
  var _acc = /* [] */0;
  var _n = n;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var n$1 = _n;
    var acc = _acc;
    if (n$1 !== 0) {
      if (l$1) {
        _l = l$1[1];
        _n = n$1 - 1 | 0;
        _acc = /* :: */[
          l$1[0],
          acc
        ];
        continue ;
        
      } else {
        return Pervasives.failwith("firstn");
      }
    } else {
      return List.rev(acc);
    }
  };
}

function last(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var l = param[1];
      if (l) {
        _param = l;
        continue ;
        
      } else {
        return param[0];
      }
    } else {
      return Pervasives.failwith("List.last");
    }
  };
}

function lastn(n, l) {
  var len = List.length(l);
  if (len < n) {
    return Pervasives.failwith("lastn");
  } else {
    var _m = len;
    var _l = l;
    while(true) {
      var l$1 = _l;
      var m = _m;
      if (m === n) {
        return l$1;
      } else {
        _l = List.tl(l$1);
        _m = m - 1 | 0;
        continue ;
        
      }
    };
  }
}

function skipn(_n, _l) {
  while(true) {
    var l = _l;
    var n = _n;
    if (n !== 0) {
      if (l) {
        _l = l[1];
        _n = n - 1 | 0;
        continue ;
        
      } else {
        return Pervasives.failwith("List.skipn");
      }
    } else {
      return l;
    }
  };
}

function skipn_at_least(n, l) {
  try {
    return skipn(n, l);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return /* [] */0;
    } else {
      throw exn;
    }
  }
}

function prefix_of(cmp, prefl, l) {
  var _param = /* tuple */[
    prefl,
    l
  ];
  while(true) {
    var param = _param;
    var match = param[0];
    if (match) {
      var match$1 = param[1];
      if (match$1) {
        if (Curry._2(cmp, match[0], match$1[0])) {
          _param = /* tuple */[
            match[1],
            match$1[1]
          ];
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function drop_prefix(cmp, p, l) {
  var _param = /* tuple */[
    p,
    l
  ];
  while(true) {
    var param = _param;
    var match = param[0];
    if (match) {
      var match$1 = param[1];
      if (match$1) {
        if (Curry._2(cmp, match[0], match$1[0])) {
          _param = /* tuple */[
            match[1],
            match$1[1]
          ];
          continue ;
          
        } else {
          return l;
        }
      } else {
        return l;
      }
    } else {
      return param[1];
    }
  };
}

function map_append(f, l) {
  return List.flatten(List.map(f, l));
}

function map_append2(f, l1, l2) {
  return List.flatten(List.map2(f, l1, l2));
}

function share_tails(l1, l2) {
  var _acc = /* [] */0;
  var _param = /* tuple */[
    List.rev(l1),
    List.rev(l2)
  ];
  while(true) {
    var param = _param;
    var acc = _acc;
    var l1$1 = param[0];
    var exit = 0;
    if (l1$1) {
      var match = param[1];
      if (match) {
        var x1 = l1$1[0];
        if (x1 === match[0]) {
          _param = /* tuple */[
            l1$1[1],
            match[1]
          ];
          _acc = /* :: */[
            x1,
            acc
          ];
          continue ;
          
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* tuple */[
              List.rev(l1$1),
              List.rev(param[1]),
              acc
            ];
    }
    
  };
}

function fold_left_map(f, e, param) {
  if (param) {
    var match = Curry._2(f, e, param[0]);
    var match$1 = fold_left_map(f, match[0], param[1]);
    return /* tuple */[
            match$1[0],
            /* :: */[
              match[1],
              match$1[1]
            ]
          ];
  } else {
    return /* tuple */[
            e,
            /* [] */0
          ];
  }
}

function fold_right_map(f, l, e) {
  return List.fold_right((function (x, param) {
                var match = Curry._2(f, x, param[1]);
                return /* tuple */[
                        /* :: */[
                          match[0],
                          param[0]
                        ],
                        match[1]
                      ];
              }), l, /* tuple */[
              /* [] */0,
              e
            ]);
}

function on_snd(f, param) {
  return /* tuple */[
          param[0],
          Curry._1(f, param[1])
        ];
}

function fold_left2_map(f, e, l, l$prime) {
  return on_snd(List.rev, List.fold_left2((function (param, x, x$prime) {
                    var match = Curry._3(f, param[0], x, x$prime);
                    return /* tuple */[
                            match[0],
                            /* :: */[
                              match[1],
                              param[1]
                            ]
                          ];
                  }), /* tuple */[
                  e,
                  /* [] */0
                ], l, l$prime));
}

function fold_right2_map(f, l, l$prime, e) {
  return List.fold_right2((function (x, x$prime, param) {
                var match = Curry._3(f, x, x$prime, param[1]);
                return /* tuple */[
                        /* :: */[
                          match[0],
                          param[0]
                        ],
                        match[1]
                      ];
              }), l, l$prime, /* tuple */[
              /* [] */0,
              e
            ]);
}

function fold_left3_map(f, e, l, l$prime, l$prime$prime) {
  return on_snd(List.rev, fold_left3((function (param, x, x$prime, x$prime$prime) {
                    var match = Curry._4(f, param[0], x, x$prime, x$prime$prime);
                    return /* tuple */[
                            match[0],
                            /* :: */[
                              match[1],
                              param[1]
                            ]
                          ];
                  }), /* tuple */[
                  e,
                  /* [] */0
                ], l, l$prime, l$prime$prime));
}

function fold_left4_map(f, e, l1, l2, l3, l4) {
  return on_snd(List.rev, fold_left4((function (param, x1, x2, x3, x4) {
                    var match = Curry._5(f, param[0], x1, x2, x3, x4);
                    return /* tuple */[
                            match[0],
                            /* :: */[
                              match[1],
                              param[1]
                            ]
                          ];
                  }), /* tuple */[
                  e,
                  /* [] */0
                ], l1, l2, l3, l4));
}

function map_assoc(f) {
  return (function (param) {
      return List.map((function (param) {
                    return /* tuple */[
                            param[0],
                            Curry._1(f, param[1])
                          ];
                  }), param);
    });
}

function assoc_f(f, a, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (Curry._2(f, a, match[0])) {
        return match[1];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function remove_assoc_f(f, a, l) {
  try {
    return remove_first((function (param) {
                  return Curry._2(f, a, param[0]);
                }), l);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return l;
    } else {
      throw exn;
    }
  }
}

function mem_assoc_f(f, a, l) {
  return List.exists((function (param) {
                return Curry._2(f, a, param[0]);
              }), l);
}

function cartesian(op, l1, l2) {
  return List.flatten(List.map((function (x) {
                    return List.map(Curry._1(op, x), l2);
                  }), l1));
}

function cartesians(op, init, ll) {
  return List.fold_right((function (param, param$1) {
                return cartesian(op, param, param$1);
              }), ll, /* :: */[
              init,
              /* [] */0
            ]);
}

function combinations(l) {
  return cartesians((function (x, l) {
                return /* :: */[
                        x,
                        l
                      ];
              }), /* [] */0, l);
}

function combine3(x, y, z) {
  if (x) {
    if (y && z) {
      return /* :: */[
              /* tuple */[
                x[0],
                y[0],
                z[0]
              ],
              combine3(x[1], y[1], z[1])
            ];
    } else {
      return Pervasives.invalid_arg("List.combine3");
    }
  } else if (y || z) {
    return Pervasives.invalid_arg("List.combine3");
  } else {
    return /* [] */0;
  }
}

function cartesians_filter(op, init, ll) {
  return List.fold_right((function (param, param$1) {
                var op$1 = op;
                var l1 = param;
                var l2 = param$1;
                return List.flatten(List.map((function (x) {
                                  return map_filter(Curry._1(op$1, x), l2);
                                }), l1));
              }), ll, /* :: */[
              init,
              /* [] */0
            ]);
}

function drop_last(param) {
  if (param) {
    var tl = param[1];
    if (tl) {
      return /* :: */[
              param[0],
              drop_last(tl)
            ];
    } else {
      return /* [] */0;
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "cList.ml",
            886,
            10
          ]
        ];
  }
}

function factorize_left(cmp, param) {
  if (param) {
    var match = param[0];
    var a = match[0];
    var match$1 = List.partition((function (param) {
            return Curry._2(cmp, a, param[0]);
          }), param[1]);
    return /* :: */[
            /* tuple */[
              a,
              /* :: */[
                match[1],
                List.map((function (prim) {
                        return prim[1];
                      }), match$1[0])
              ]
            ],
            factorize_left(cmp, match$1[1])
          ];
  } else {
    return /* [] */0;
  }
}

var length = List.length;

var hd = List.hd;

var tl = List.tl;

var nth = List.nth;

var rev = List.rev;

var rev_append = List.rev_append;

var flatten = concat;

var iter = List.iter;

var mapi = List.mapi;

var rev_map = List.rev_map;

var fold_left = List.fold_left;

var fold_right = List.fold_right;

var iter2 = List.iter2;

var rev_map2 = List.rev_map2;

var fold_left2 = List.fold_left2;

var fold_right2 = List.fold_right2;

var for_all = List.for_all;

var exists = List.exists;

var for_all2 = List.for_all2;

var exists2 = List.exists2;

var mem = List.mem;

var memq = List.memq;

var find = List.find;

var find_all = List.find_all;

var partition = List.partition;

var assoc = List.assoc;

var assq = List.assq;

var mem_assoc = List.mem_assoc;

var mem_assq = List.mem_assq;

var remove_assoc = List.remove_assoc;

var remove_assq = List.remove_assq;

var sort = List.sort;

var stable_sort = List.stable_sort;

var fast_sort = List.fast_sort;

var sort_uniq = List.sort_uniq;

var merge = List.merge;

var map_left = map;

var remove = except;

var fold_map = fold_left_map;

var fold_map$prime = fold_right_map;

exports.length = length;
exports.hd = hd;
exports.tl = tl;
exports.nth = nth;
exports.rev = rev;
exports.append = append;
exports.rev_append = rev_append;
exports.concat = concat;
exports.flatten = flatten;
exports.iter = iter;
exports.map = map;
exports.mapi = mapi;
exports.rev_map = rev_map;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.iter2 = iter2;
exports.map2 = map2;
exports.rev_map2 = rev_map2;
exports.fold_left2 = fold_left2;
exports.fold_right2 = fold_right2;
exports.for_all = for_all;
exports.exists = exists;
exports.for_all2 = for_all2;
exports.exists2 = exists2;
exports.mem = mem;
exports.memq = memq;
exports.find = find;
exports.filter = filter;
exports.find_all = find_all;
exports.partition = partition;
exports.assoc = assoc;
exports.assq = assq;
exports.mem_assoc = mem_assoc;
exports.mem_assq = mem_assq;
exports.remove_assoc = remove_assoc;
exports.remove_assq = remove_assq;
exports.split = split;
exports.combine = combine;
exports.sort = sort;
exports.stable_sort = stable_sort;
exports.fast_sort = fast_sort;
exports.sort_uniq = sort_uniq;
exports.merge = merge;
exports.compare = compare;
exports.equal = equal;
exports.is_empty = is_empty;
exports.init = init;
exports.mem_f = mem_f;
exports.add_set = add_set;
exports.eq_set = eq_set;
exports.intersect = intersect;
exports.union = union;
exports.unionq = unionq;
exports.subtract = subtract;
exports.subtractq = subtractq;
exports.interval = interval;
exports.make = make;
exports.assign = assign;
exports.distinct = distinct;
exports.distinct_f = distinct_f;
exports.duplicates = duplicates;
exports.filter2 = filter2;
exports.map_filter = map_filter;
exports.map_filter_i = map_filter_i;
exports.filter_with = filter_with;
exports.smartmap = smartmap;
exports.map_left = map_left;
exports.map_i = map_i;
exports.map2_i = map2_i;
exports.map3 = map3;
exports.map4 = map4;
exports.filteri = filteri;
exports.partitioni = partitioni;
exports.map_of_array = map_of_array;
exports.smartfilter = smartfilter;
exports.extend = extend;
exports.count = count;
exports.index = index;
exports.index0 = index0;
exports.iteri = iteri;
exports.fold_left_until = fold_left_until;
exports.fold_right_i = fold_right_i;
exports.fold_left_i = fold_left_i;
exports.fold_right_and_left = fold_right_and_left;
exports.fold_left3 = fold_left3;
exports.fold_left2_set = fold_left2_set;
exports.for_all_i = for_all_i;
exports.except = except;
exports.remove = remove;
exports.remove_first = remove_first;
exports.extract_first = extract_first;
exports.insert = insert;
exports.for_all2eq = for_all2eq;
exports.sep_last = sep_last;
exports.find_map = find_map;
exports.uniquize = uniquize;
exports.sort_uniquize = sort_uniquize;
exports.merge_uniq = merge_uniq;
exports.subset = subset;
exports.chop = chop;
exports.IndexOutOfRange = IndexOutOfRange;
exports.$$goto = $$goto;
exports.split_when = split_when;
exports.split3 = split3;
exports.firstn = firstn;
exports.last = last;
exports.lastn = lastn;
exports.skipn = skipn;
exports.skipn_at_least = skipn_at_least;
exports.addn = addn;
exports.prefix_of = prefix_of;
exports.drop_prefix = drop_prefix;
exports.drop_last = drop_last;
exports.map_append = map_append;
exports.map_append2 = map_append2;
exports.share_tails = share_tails;
exports.fold_left_map = fold_left_map;
exports.fold_right_map = fold_right_map;
exports.fold_left2_map = fold_left2_map;
exports.fold_right2_map = fold_right2_map;
exports.fold_left3_map = fold_left3_map;
exports.fold_left4_map = fold_left4_map;
exports.fold_map = fold_map;
exports.fold_map$prime = fold_map$prime;
exports.map_assoc = map_assoc;
exports.assoc_f = assoc_f;
exports.remove_assoc_f = remove_assoc_f;
exports.mem_assoc_f = mem_assoc_f;
exports.cartesian = cartesian;
exports.cartesians = cartesians;
exports.combinations = combinations;
exports.combine3 = combine3;
exports.cartesians_filter = cartesians_filter;
exports.factorize_left = factorize_left;
/* No side effect */
