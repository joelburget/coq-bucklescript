// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var HMap$ReactTemplate = require("./hMap.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var CList$ReactTemplate = require("./cList.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Hashset$ReactTemplate = require("./hashset.bs.js");
var Hashcons$ReactTemplate = require("./hashcons.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function compare(u, v) {
  if (typeof u === "number") {
    if (u) {
      if (typeof v === "number") {
        if (v !== 0) {
          return 0;
        } else {
          return 1;
        }
      } else {
        return -1;
      }
    } else if (typeof v === "number" && v === 0) {
      return 0;
    } else {
      return -1;
    }
  } else if (u.tag) {
    if (typeof v === "number" || !v.tag) {
      return 1;
    } else {
      return Caml_primitive.caml_int_compare(u[0], v[0]);
    }
  } else {
    var i1 = u[0];
    if (typeof v === "number") {
      return 1;
    } else if (v.tag) {
      return -1;
    } else {
      var i2 = v[0];
      if (i1 < i2) {
        return -1;
      } else if (i1 > i2) {
        return 1;
      } else {
        return Curry._2(Names$ReactTemplate.DirPath[/* compare */1], u[1], v[1]);
      }
    }
  }
}

function hcons(x) {
  if (typeof x === "number") {
    return x;
  } else if (x.tag) {
    return x;
  } else {
    var d = x[1];
    var d$prime = Curry._1(Names$ReactTemplate.DirPath[/* hcons */9], d);
    if (d$prime === d) {
      return x;
    } else {
      return /* Level */Block.__(0, [
                x[0],
                d$prime
              ]);
    }
  }
}

function hash(param) {
  if (typeof param === "number") {
    if (param) {
      return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, 1);
    } else {
      return Hashset$ReactTemplate.Combine[/* combinesmall */1](1, 0);
    }
  } else if (param.tag) {
    return Hashset$ReactTemplate.Combine[/* combinesmall */1](2, param[0]);
  } else {
    return Hashset$ReactTemplate.Combine[/* combinesmall */1](3, Hashset$ReactTemplate.Combine[/* combine */0](param[0], Names$ReactTemplate.DirPath[/* hash */2](param[1])));
  }
}

function equal(x, y) {
  if (x === y) {
    return /* true */1;
  } else if (x[/* hash */0] === y[/* hash */0]) {
    var x$1 = x[/* data */1];
    var y$1 = y[/* data */1];
    if (x$1 === y$1) {
      return /* true */1;
    } else if (typeof x$1 === "number") {
      if (x$1) {
        if (typeof y$1 === "number" && y$1 !== 0) {
          return /* true */1;
        } else {
          return /* false */0;
        }
      } else if (typeof y$1 === "number" && y$1 === 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else if (x$1.tag) {
      if (typeof y$1 === "number" || y$1.tag !== 1) {
        return /* false */0;
      } else {
        return +(x$1[0] === y$1[0]);
      }
    } else if (typeof y$1 === "number" || !(!y$1.tag && x$1[0] === y$1[0])) {
      return /* false */0;
    } else {
      return Curry._2(Names$ReactTemplate.DirPath[/* equal */0], x$1[1], y$1[1]);
    }
  } else {
    return /* false */0;
  }
}

function hash$1(x) {
  return x[/* hash */0];
}

function eq(x, y) {
  if (x[/* hash */0] === y[/* hash */0]) {
    var x$1 = x[/* data */1];
    var y$1 = y[/* data */1];
    if (x$1 === y$1) {
      return /* true */1;
    } else if (typeof x$1 === "number") {
      if (x$1) {
        if (typeof y$1 === "number" && y$1 !== 0) {
          return /* true */1;
        } else {
          return /* false */0;
        }
      } else if (typeof y$1 === "number" && y$1 === 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else if (x$1.tag) {
      if (typeof y$1 === "number" || y$1.tag !== 1) {
        return /* false */0;
      } else {
        return +(x$1[0] === y$1[0]);
      }
    } else if (typeof y$1 === "number" || !(!y$1.tag && x$1[0] === y$1[0])) {
      return /* false */0;
    } else {
      return +(x$1[1] === y$1[1]);
    }
  } else {
    return /* false */0;
  }
}

function hash$2(x) {
  return x[/* hash */0];
}

function hashcons(_, x) {
  var data$prime = hcons(x[/* data */1]);
  if (x[/* data */1] === data$prime) {
    return x;
  } else {
    return /* record */[
            /* hash */x[/* hash */0],
            /* data */data$prime
          ];
  }
}

var H = Hashcons$ReactTemplate.Make([
      hashcons,
      eq,
      hash$2
    ]);

var hcons$1 = Hashcons$ReactTemplate.simple_hcons(H[/* generate */0], H[/* hcons */1], /* () */0);

function make(l) {
  return Curry._1(hcons$1, /* record */[
              /* hash */hash(l),
              /* data */l
            ]);
}

var set = make(/* Set */1);

var prop = make(/* Prop */0);

function is_small(x) {
  var match = x[/* data */1];
  if (typeof match === "number") {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_prop(x) {
  var match = x[/* data */1];
  if (typeof match === "number" && match === 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_set(x) {
  var match = x[/* data */1];
  if (typeof match === "number" && match !== 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function compare$1(u, v) {
  if (u === v) {
    return 0;
  } else {
    var c = Caml_primitive.caml_int_compare(u[/* hash */0], v[/* hash */0]);
    if (c) {
      return c;
    } else {
      return compare(u[/* data */1], v[/* data */1]);
    }
  }
}

function natural_compare(u, v) {
  if (u === v) {
    return 0;
  } else {
    return compare(u[/* data */1], v[/* data */1]);
  }
}

function to_string(x) {
  var match = x[/* data */1];
  if (typeof match === "number") {
    if (match) {
      return "Set";
    } else {
      return "Prop";
    }
  } else if (match.tag) {
    return "Var(" + (Pervasives.string_of_int(match[0]) + ")");
  } else {
    return Names$ReactTemplate.DirPath[/* to_string */7](match[1]) + ("." + Pervasives.string_of_int(match[0]));
  }
}

function pr(u) {
  return Pp$ReactTemplate.str(to_string(u));
}

function apart(u, v) {
  var match = u[/* data */1];
  var match$1 = v[/* data */1];
  if (typeof match === "number") {
    if (match !== 0) {
      if (typeof match$1 === "number" && match$1 === 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else if (typeof match$1 === "number" && match$1 !== 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

var vars = Util$ReactTemplate.$$Array[/* init */0](20, (function (i) {
        return make(/* Var */Block.__(1, [i]));
      }));

function $$var(n) {
  if (n < 20) {
    return Caml_array.caml_array_get(vars, n);
  } else {
    return make(/* Var */Block.__(1, [n]));
  }
}

function var_index(u) {
  var match = u[/* data */1];
  if (typeof match === "number" || match.tag !== 1) {
    return /* None */0;
  } else {
    return /* Some */[match[0]];
  }
}

function make$1(m, n) {
  return make(/* Level */Block.__(0, [
                n,
                Curry._1(Names$ReactTemplate.DirPath[/* hcons */9], m)
              ]));
}

function name(u) {
  var match = u[/* data */1];
  if (typeof match === "number" || match.tag) {
    return /* None */0;
  } else {
    return /* Some */[/* tuple */[
              match[1],
              match[0]
            ]];
  }
}

var M = HMap$ReactTemplate.Make([
      compare$1,
      hash$1
    ]);

var empty = M[0];

var is_empty = M[1];

var mem = M[2];

var add = M[3];

var merge = M[6];

var fold = M[10];

var bindings = M[16];

var find = M[21];

function union(l, r) {
  return Curry._3(merge, (function (_, l, r) {
                if (l) {
                  return l;
                } else {
                  return r;
                }
              }), l, r);
}

function subst_union(l, r) {
  return Curry._3(merge, (function (_, l, r) {
                if (l && (l[0] || !r)) {
                  return l;
                } else {
                  return r;
                }
              }), l, r);
}

function diff(ext, orig) {
  return Curry._3(fold, (function (u, v, acc) {
                if (Curry._2(mem, u, orig)) {
                  return acc;
                } else {
                  return Curry._3(add, u, v, acc);
                }
              }), ext, empty);
}

function pr$1(f, m) {
  return Pp$ReactTemplate.h(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, (function (param) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(to_string(param[0])), Curry._1(f, param[1]));
                  }), Curry._1(bindings, m)));
}

var include = M[/* Set */24];

var empty$1 = include[0];

var is_empty$1 = include[1];

var add$1 = include[3];

var singleton = include[4];

var union$1 = include[6];

var diff$1 = include[8];

var equal$1 = include[10];

var fold$1 = include[13];

var cardinal = include[18];

var elements = include[19];

function pr$2(prl, s) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{"), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, prl, Curry._1(elements, s))), Pp$ReactTemplate.str("}"));
}

function of_array(l) {
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (acc, x) {
                return Curry._2(add$1, x, acc);
              }), empty$1, l);
}

function hashcons$1(hdir, x) {
  var b = x[0];
  var b$prime = Curry._1(hdir, b);
  if (b$prime === b) {
    return x;
  } else {
    return /* tuple */[
            b$prime,
            x[1]
          ];
  }
}

function eq$1(l1, l2) {
  if (l1 === l2) {
    return /* true */1;
  } else if (l1[0] === l2[0]) {
    return +(l1[1] === l2[1]);
  } else {
    return /* false */0;
  }
}

function hash$3(param) {
  return param[1] + param[0][/* hash */0] | 0;
}

var ExprHash = /* module */[
  /* hashcons */hashcons$1,
  /* eq */eq$1,
  /* hash */hash$3
];

var H$1 = Hashcons$ReactTemplate.Make(ExprHash);

var hcons$2 = Hashcons$ReactTemplate.simple_hcons(H$1[/* generate */0], H$1[/* hcons */1], hcons$1);

function compare$2(u, v) {
  if (u === v) {
    return 0;
  } else {
    var n$prime = v[1];
    var n = u[1];
    if (n === n$prime) {
      return compare$1(u[0], v[0]);
    } else {
      return n - n$prime | 0;
    }
  }
}

var prop$1 = Curry._1(hcons$2, /* tuple */[
      prop,
      0
    ]);

var set$1 = Curry._1(hcons$2, /* tuple */[
      set,
      0
    ]);

var type1 = Curry._1(hcons$2, /* tuple */[
      set,
      1
    ]);

function equal$2(x, y) {
  if (x === y) {
    return /* true */1;
  } else if (x[1] === y[1]) {
    return equal(x[0], y[0]);
  } else {
    return /* false */0;
  }
}

function successor(param) {
  var u = param[0];
  if (is_prop(u)) {
    return type1;
  } else {
    return /* tuple */[
            u,
            param[1] + 1 | 0
          ];
  }
}

function $$super(param, param$1) {
  var n$prime = param$1[1];
  var v = param$1[0];
  var n = param[1];
  var u = param[0];
  var cmp = compare$1(u, v);
  if (cmp) {
    var match = u[/* data */1];
    var match$1 = v[/* data */1];
    var exit = 0;
    if (typeof match === "number") {
      if (match !== 0) {
        exit = 1;
      } else if (typeof match$1 === "number") {
        if (match$1 !== 0) {
          if (n !== 0) {
            exit = 1;
          } else {
            return /* SuperSame */Block.__(0, [/* true */1]);
          }
        } else {
          return /* SuperSame */Block.__(0, [+(n < n$prime)]);
        }
      } else if (n !== 0) {
        exit = 1;
      } else {
        return /* SuperSame */Block.__(0, [/* true */1]);
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (typeof match$1 === "number") {
        if (match$1 !== 0) {
          return /* SuperDiff */Block.__(1, [cmp]);
        } else if (n$prime !== 0) {
          return /* SuperDiff */Block.__(1, [cmp]);
        } else {
          return /* SuperSame */Block.__(0, [/* false */0]);
        }
      } else {
        return /* SuperDiff */Block.__(1, [cmp]);
      }
    }
    
  } else {
    return /* SuperSame */Block.__(0, [+(n < n$prime)]);
  }
}

function to_string$1(param) {
  var n = param[1];
  var v = param[0];
  if (n) {
    return to_string(v) + ("+" + Pervasives.string_of_int(n));
  } else {
    return to_string(v);
  }
}

function pr$3(x) {
  return Pp$ReactTemplate.str(to_string$1(x));
}

function pr_with(f, param) {
  var n = param[1];
  var v = param[0];
  if (n) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(f, v), Pp$ReactTemplate.str("+")), Pp$ReactTemplate.$$int(n));
  } else {
    return Curry._1(f, v);
  }
}

function is_level(param) {
  if (param[1] !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function get_level(param) {
  return param[0];
}

function map(f, x) {
  var n = x[1];
  var v = x[0];
  var v$prime = Curry._1(f, v);
  if (v$prime === v) {
    return x;
  } else if (is_prop(v$prime) && n !== 0) {
    return /* tuple */[
            set,
            n
          ];
  } else {
    return /* tuple */[
            v$prime,
            n
          ];
  }
}

function hash$4(param) {
  if (param) {
    return Hashset$ReactTemplate.Combine[/* combinesmall */1](hash$3(param[0]), hash$4(param[1]));
  } else {
    return 0;
  }
}

function equal$3(x, y) {
  if (x === y) {
    return /* true */1;
  } else {
    return Curry._3(Util$ReactTemplate.List[/* equal */44], equal$2, x, y);
  }
}

function compare$3(x, y) {
  if (x === y) {
    return 0;
  } else {
    return Curry._3(Util$ReactTemplate.List[/* compare */43], compare$2, x, y);
  }
}

var Huniv = Hashcons$ReactTemplate.Hlist([hash$3]);

var hcons$3 = Hashcons$ReactTemplate.recursive_hcons(Huniv[/* generate */0], Huniv[/* hcons */1], hcons$2);

function make$2(l) {
  return /* :: */[
          /* tuple */[
            l,
            0
          ],
          /* [] */0
        ];
}

function pr$4(l) {
  var exit = 0;
  if (l) {
    if (l[1]) {
      exit = 1;
    } else {
      return Pp$ReactTemplate.str(to_string$1(l[0]));
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("max("), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, pr$3, l))), Pp$ReactTemplate.str(")"));
  }
  
}

function pr_with$1(f, l) {
  var exit = 0;
  if (l) {
    if (l[1]) {
      exit = 1;
    } else {
      return pr_with(f, l[0]);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("max("), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.pr_comma, (function (param) {
                              return pr_with(f, param);
                            }), l))), Pp$ReactTemplate.str(")"));
  }
  
}

function is_level$1(l) {
  if (l && !l[1]) {
    return is_level(l[0]);
  } else {
    return /* false */0;
  }
}

function is_levels(_l) {
  while(true) {
    var l = _l;
    if (l) {
      if (is_level(l[0])) {
        _l = l[1];
        continue ;
        
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function level(l) {
  if (l && !l[1]) {
    var param = l[0];
    if (param[1] !== 0) {
      return /* None */0;
    } else {
      return /* Some */[param[0]];
    }
  } else {
    return /* None */0;
  }
}

function levels(l) {
  return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, x) {
                return Curry._2(add$1, get_level(x), acc);
              }), empty$1, l);
}

function is_small$1(u) {
  if (u && !u[1]) {
    var param = u[0];
    if (param[1] !== 0) {
      return /* false */0;
    } else {
      return is_small(param[0]);
    }
  } else {
    return /* false */0;
  }
}

var type0m = /* :: */[
  prop$1,
  /* [] */0
];

var type0 = /* :: */[
  set$1,
  /* [] */0
];

var type1_000 = successor(set$1);

var type1$1 = /* :: */[
  type1_000,
  /* [] */0
];

function is_type0m(x) {
  return equal$3(type0m, x);
}

function is_type0(x) {
  return equal$3(type0, x);
}

function $$super$1(l) {
  if (is_small$1(l)) {
    return type1$1;
  } else {
    return Curry._2(Util$ReactTemplate.List[/* smartmap */65], successor, l);
  }
}

function merge_univs(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        var t2 = l2[1];
        var h2 = l2[0];
        var t1 = l1[1];
        var h1 = l1[0];
        var match = $$super(h1, h2);
        if (match.tag) {
          if (match[0] <= 0) {
            return /* :: */[
                    h1,
                    merge_univs(t1, l2)
                  ];
          } else {
            return /* :: */[
                    h2,
                    merge_univs(l1, t2)
                  ];
          }
        } else if (match[0] !== 0) {
          _l1 = t1;
          continue ;
          
        } else {
          _l2 = t2;
          continue ;
          
        }
      } else {
        return l1;
      }
    } else {
      return l2;
    }
  };
}

function sort(u) {
  var aux = function (a, _l) {
    while(true) {
      var l = _l;
      if (l) {
        var l$prime = l[1];
        var b = l[0];
        var match = $$super(a, b);
        if (match.tag) {
          if (match[0] <= 0) {
            return /* :: */[
                    a,
                    l
                  ];
          } else {
            return /* :: */[
                    b,
                    aux(a, l$prime)
                  ];
          }
        } else if (match[0] !== 0) {
          return l;
        } else {
          _l = l$prime;
          continue ;
          
        }
      } else {
        return /* :: */[
                a,
                l
              ];
      }
    };
  };
  return Curry._3(Util$ReactTemplate.List[/* fold_right */14], aux, u, /* [] */0);
}

function max_var_pred(p, _u) {
  while(true) {
    var u = _u;
    if (u) {
      var u$1 = u[1];
      var match = var_index(u[0][0]);
      if (match) {
        var i = match[0];
        if (Curry._1(p, i)) {
          return Caml_primitive.caml_int_max(i, max_var_pred(p, u$1));
        } else {
          _u = u$1;
          continue ;
          
        }
      } else {
        _u = u$1;
        continue ;
        
      }
    } else {
      return -1;
    }
  };
}

function remap_var(_u, i, j) {
  while(true) {
    var u = _u;
    if (u) {
      var u$1 = u[1];
      var match = u[0];
      if (Caml_obj.caml_equal(var_index(match[0]), /* Some */[i])) {
        return /* :: */[
                /* tuple */[
                  $$var(j),
                  match[1]
                ],
                remap_var(u$1, i, j)
              ];
      } else {
        _u = u$1;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function compact(u, max_var, i) {
  if (i >= max_var) {
    return /* tuple */[
            u,
            /* [] */0
          ];
  } else {
    var j = max_var_pred((function (j) {
            return +(j < i);
          }), u);
    if (i === (j + 1 | 0)) {
      var match = compact(u, max_var, i + 1 | 0);
      return /* tuple */[
              match[0],
              /* :: */[
                i,
                match[1]
              ]
            ];
    } else {
      var match$1 = compact(remap_var(u, i, j), max_var, i + 1 | 0);
      return /* tuple */[
              match$1[0],
              /* :: */[
                j + 1 | 0,
                match$1[1]
              ]
            ];
    }
  }
}

function compact$1(u) {
  var max_var = max_var_pred((function () {
          return /* true */1;
        }), u);
  return compact(u, max_var, 0);
}

var sup = merge_univs;

var exists = Util$ReactTemplate.List[/* exists */21];

var for_all = Util$ReactTemplate.List[/* for_all */20];

var smartmap = Util$ReactTemplate.List[/* smartmap */65];

var map$1 = Util$ReactTemplate.List[/* map */10];

function is_univ_variable(l) {
  return +(level(l) !== /* None */0);
}

function constraint_type_ord(c1, c2) {
  switch (c1) {
    case 0 : 
        if (c2 !== 0) {
          return -1;
        } else {
          return 0;
        }
    case 1 : 
        switch (c2) {
          case 0 : 
              return 1;
          case 1 : 
              return 0;
          case 2 : 
              return -1;
          
        }
        break;
    case 2 : 
        if (c2 >= 2) {
          return 0;
        } else {
          return 1;
        }
    
  }
}

var UniverseInconsistency = Caml_exceptions.create("Univ-ReactTemplate.UniverseInconsistency");

function pr_constraint_type(op) {
  var tmp;
  switch (op) {
    case 0 : 
        tmp = " < ";
        break;
    case 1 : 
        tmp = " <= ";
        break;
    case 2 : 
        tmp = " = ";
        break;
    
  }
  return Pp$ReactTemplate.str(tmp);
}

function compare$4(param, param$1) {
  var i = constraint_type_ord(param[1], param$1[1]);
  if (i !== 0) {
    return i;
  } else {
    var i$prime = compare$1(param[0], param$1[0]);
    if (i$prime !== 0) {
      return i$prime;
    } else {
      return compare$1(param[2], param$1[2]);
    }
  }
}

var UConstraintOrd = /* module */[/* compare */compare$4];

var S = Curry._1(Util$ReactTemplate.$$Set[/* Make */0], UConstraintOrd);

var empty$2 = S[0];

var is_empty$2 = S[1];

var add$2 = S[3];

var union$2 = S[6];

var diff$2 = S[8];

var equal$4 = S[10];

var fold$2 = S[13];

var elements$1 = S[19];

function pr$5(prl, c) {
  return Curry._3(fold$2, (function (param, pp_std) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pp_std, Curry._1(prl, param[0])), pr_constraint_type(param[1])), Curry._1(prl, param[2])), Pp$ReactTemplate.fnl(/* () */0));
              }), c, Pp$ReactTemplate.str(""));
}

function universes_of(c) {
  return Curry._3(fold$2, (function (param, unvs) {
                return Curry._2(add$1, param[2], Curry._2(add$1, param[0], unvs));
              }), c, empty$1);
}

function hashcons$2(hul, param) {
  return /* tuple */[
          Curry._1(hul, param[0]),
          param[1],
          Curry._1(hul, param[2])
        ];
}

function eq$2(param, param$1) {
  if (param[0] === param$1[0] && param[1] === param$1[1]) {
    return +(param[2] === param$1[2]);
  } else {
    return /* false */0;
  }
}

var Hconstraint = Hashcons$ReactTemplate.Make(/* module */[
      /* hashcons */hashcons$2,
      /* eq */eq$2,
      /* hash */Hashtbl.hash
    ]);

function hashcons$3(huc, s) {
  return Curry._3(fold$2, (function (x) {
                return Curry._1(add$2, Curry._1(huc, x));
              }), s, empty$2);
}

function eq$3(s, s$prime) {
  return Curry._3(Util$ReactTemplate.List[/* for_all2eq */92], (function (prim, prim$1) {
                return +(prim === prim$1);
              }), Curry._1(elements$1, s), Curry._1(elements$1, s$prime));
}

var Hconstraints = Hashcons$ReactTemplate.Make(/* module */[
      /* hashcons */hashcons$3,
      /* eq */eq$3,
      /* hash */Hashtbl.hash
    ]);

var hcons_constraint = Hashcons$ReactTemplate.simple_hcons(Hconstraint[/* generate */0], Hconstraint[/* hcons */1], hcons$1);

var hcons_constraints = Hashcons$ReactTemplate.simple_hcons(Hconstraints[/* generate */0], Hconstraints[/* hcons */1], hcons_constraint);

function constraints_of(param) {
  return param[1];
}

function enforce_eq_level(u, v, c) {
  if (equal(u, v)) {
    return c;
  } else if (apart(u, v)) {
    var o = /* Eq */2;
    var u$1 = u;
    var v$1 = v;
    var p = /* None */0;
    throw [
          UniverseInconsistency,
          /* tuple */[
            o,
            /* :: */[
              /* tuple */[
                u$1,
                0
              ],
              /* [] */0
            ],
            /* :: */[
              /* tuple */[
                v$1,
                0
              ],
              /* [] */0
            ],
            p
          ]
        ];
  } else {
    return Curry._2(add$2, /* tuple */[
                u,
                /* Eq */2,
                v
              ], c);
  }
}

function enforce_eq(u, v, c) {
  if (equal$3(u, v)) {
    return c;
  } else {
    var u$1 = u;
    var v$1 = v;
    var c$1 = c;
    var match = level(u$1);
    var match$1 = level(v$1);
    if (match && match$1) {
      return enforce_eq_level(match[0], match$1[0], c$1);
    } else {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("A universe comparison can only happen between variables."));
    }
  }
}

function check_univ_leq(u, v) {
  return Curry._2(for_all, (function (u) {
                var u$1 = u;
                var v$1 = v;
                return Curry._2(exists, (function (param) {
                              var param$1 = u$1;
                              var param$2 = param;
                              var n$prime = param$2[1];
                              var v = param$2[0];
                              var n = param$1[1];
                              var u$2 = param$1[0];
                              var cmp = compare$1(u$2, v);
                              if (cmp) {
                                if (Caml_obj.caml_lessequal(n, n$prime) && is_prop(u$2)) {
                                  return is_small(v);
                                } else {
                                  return /* false */0;
                                }
                              } else {
                                return Caml_obj.caml_lessequal(n, n$prime);
                              }
                            }), v$1);
              }), u);
}

function enforce_leq(u, v, c) {
  if (check_univ_leq(u, v)) {
    return c;
  } else {
    var u$1 = u;
    var v$1 = v;
    var c$1 = c;
    var _acc = c$1;
    var _v = v$1;
    while(true) {
      var v$2 = _v;
      var acc = _acc;
      if (v$2) {
        var v$3 = v$2[0];
        _v = v$2[1];
        _acc = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function(v$3){
            return function (u) {
              return (function (param) {
                  var v$4 = u;
                  var u$1 = v$3;
                  var c = param;
                  if (equal$2(v$4, u$1)) {
                    return c;
                  } else {
                    var y = u$1[0];
                    var x = v$4[0];
                    var j = u$1[1] - v$4[1] | 0;
                    if (j === -1) {
                      return Curry._2(add$2, /* tuple */[
                                  x,
                                  /* Lt */0,
                                  y
                                ], c);
                    } else if (j <= -1) {
                      if (equal(x, y)) {
                        throw [
                              UniverseInconsistency,
                              /* tuple */[
                                /* Le */1,
                                /* :: */[
                                  v$4,
                                  /* [] */0
                                ],
                                /* :: */[
                                  u$1,
                                  /* [] */0
                                ],
                                /* None */0
                              ]
                            ];
                      } else {
                        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unable to handle arbitrary u+k <= v constraints."));
                      }
                    } else if (j) {
                      if (equal(x, y) || is_small(x)) {
                        return c;
                      } else {
                        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Unable to handle arbitrary u <= v+k constraints."));
                      }
                    } else {
                      return Curry._2(add$2, /* tuple */[
                                  x,
                                  /* Le */1,
                                  y
                                ], c);
                    }
                  }
                });
            }
            }(v$3)), u$1, c$1);
        continue ;
        
      } else {
        return acc;
      }
    };
  }
}

function enforce_leq_level(u, v, c) {
  if (equal(u, v)) {
    return c;
  } else {
    return Curry._2(add$2, /* tuple */[
                u,
                /* Le */1,
                v
              ], c);
  }
}

function univ_level_mem(u, v) {
  return Curry._2(Util$ReactTemplate.List[/* exists */21], (function (param) {
                if (param[1]) {
                  return /* false */0;
                } else {
                  return equal(u, param[0]);
                }
              }), v);
}

function univ_level_rem(u, v, min) {
  var match = level(v);
  if (match) {
    if (equal(u, match[0])) {
      return min;
    } else {
      return v;
    }
  } else {
    return Curry._2(Util$ReactTemplate.List[/* filter */27], (function (param) {
                  return 1 - (+(param[1] === 0) && equal(u, param[0]));
                }), v);
  }
}

function sup$1(x, y) {
  var exit = 0;
  switch (x) {
    case 0 : 
        return y;
    case 1 : 
        if (y !== 1) {
          exit = 1;
        } else {
          return /* Covariant */1;
        }
        break;
    case 2 : 
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    switch (y) {
      case 0 : 
          return x;
      case 1 : 
      case 2 : 
          return /* Invariant */2;
      
    }
  }
  
}

function check_subtype(x, y) {
  var exit = 0;
  switch (x) {
    case 0 : 
        if (y !== 1) {
          exit = 1;
        } else {
          return /* false */0;
        }
        break;
    case 1 : 
        exit = 1;
        break;
    case 2 : 
        if (y >= 2) {
          return /* true */1;
        } else {
          exit = 1;
        }
        break;
    
  }
  if (exit === 1) {
    switch (y) {
      case 0 : 
      case 1 : 
          return /* true */1;
      case 2 : 
          return /* false */0;
      
    }
  }
  
}

function pr$6(param) {
  switch (param) {
    case 0 : 
        return Pp$ReactTemplate.str("*");
    case 1 : 
        return Pp$ReactTemplate.str("+");
    case 2 : 
        return Pp$ReactTemplate.str("=");
    
  }
}

function leq_constraint(csts, variance, u, u$prime) {
  switch (variance) {
    case 0 : 
        return csts;
    case 1 : 
        return enforce_leq_level(u, u$prime, csts);
    case 2 : 
        return enforce_eq_level(u, u$prime, csts);
    
  }
}

function eq_constraint(csts, variance, u, u$prime) {
  if (variance !== 0) {
    return enforce_eq_level(u, u$prime, csts);
  } else {
    return csts;
  }
}

function leq_constraints(variance, u, u$prime, csts) {
  var len = u.length;
  if (!(len === u$prime.length && len === variance.length)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "univ.ml",
            789,
            4
          ]
        ];
  }
  return Util$ReactTemplate.$$Array[/* fold_left3 */41](leq_constraint, csts, variance, u, u$prime);
}

function eq_constraints(variance, u, u$prime, csts) {
  var len = u.length;
  if (!(len === u$prime.length && len === variance.length)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "univ.ml",
            794,
            4
          ]
        ];
  }
  return Util$ReactTemplate.$$Array[/* fold_left3 */41](eq_constraint, csts, variance, u, u$prime);
}

var empty$3 = /* array */[];

function hashcons$4(huniv, a) {
  var len = a.length;
  if (len) {
    for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
      var x = a[i];
      var x$prime = Curry._1(huniv, x);
      if (x !== x$prime) {
        a[i] = x$prime;
      }
      
    }
    return a;
  } else {
    return empty$3;
  }
}

function eq$4(t1, t2) {
  if (t1 === t2) {
    return /* true */1;
  } else if (t1.length === t2.length) {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === t1.length) {
        return /* true */1;
      } else if (Caml_array.caml_array_get(t1, i) === Caml_array.caml_array_get(t2, i)) {
        _i = i + 1 | 0;
        continue ;
        
      } else {
        return /* false */0;
      }
    };
  } else {
    return /* false */0;
  }
}

function hash$5(a) {
  var accu = 0;
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    var l = a[i];
    var h = l[/* hash */0];
    accu = Hashset$ReactTemplate.Combine[/* combine */0](accu, h);
  }
  return accu & 1073741823;
}

var HInstancestruct = /* module */[
  /* hashcons */hashcons$4,
  /* eq */eq$4,
  /* hash */hash$5
];

var HInstance = Hashcons$ReactTemplate.Make(HInstancestruct);

var hcons$4 = Hashcons$ReactTemplate.simple_hcons(HInstance[/* generate */0], HInstance[/* hcons */1], hcons$1);

function share(a) {
  return /* tuple */[
          Curry._1(hcons$4, a),
          hash$5(a)
        ];
}

var empty$4 = Curry._1(hcons$4, /* array */[]);

function is_empty$3(x) {
  return +(x.length === 0);
}

function append(x, y) {
  if (x.length) {
    if (y.length) {
      return Util$ReactTemplate.$$Array[/* append */3](x, y);
    } else {
      return x;
    }
  } else {
    return y;
  }
}

function of_array$1(a) {
  if (!Util$ReactTemplate.$$Array[/* for_all */26]((function (x) {
            return 1 - is_prop(x);
          }), a)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "univ.ml",
            881,
            4
          ]
        ];
  }
  return a;
}

function to_array(a) {
  return a;
}

function length(a) {
  return a.length;
}

function subst_fn(fn, t) {
  var t$prime = CArray$ReactTemplate.smartmap(fn, t);
  if (t$prime === t) {
    return t;
  } else {
    return of_array$1(t$prime);
  }
}

var levels$1 = of_array;

function pr$7(prl, variance) {
  var ppu = function (i, u) {
    var v = Option$ReactTemplate.map((function (v) {
            return Caml_array.caml_array_get(v, i);
          }), variance);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_opt_no_spc(pr$6, v), Curry._1(prl, u));
  };
  return (function (param) {
      return Pp$ReactTemplate.prvecti_with_sep(Pp$ReactTemplate.spc, ppu, param);
    });
}

function equal$5(t, u) {
  if (t === u || Util$ReactTemplate.$$Array[/* is_empty */23](t) && Util$ReactTemplate.$$Array[/* is_empty */23](u)) {
    return /* true */1;
  } else {
    return CArray$ReactTemplate.for_all2(equal, t, u);
  }
}

var Instance = /* module */[
  /* empty */empty$4,
  /* is_empty */is_empty$3,
  /* of_array */of_array$1,
  /* to_array */to_array,
  /* append */append,
  /* equal */equal$5,
  /* length */length,
  /* hcons */hcons$4,
  /* hash */hash$5,
  /* share */share,
  /* subst_fn */subst_fn,
  /* pr */pr$7,
  /* levels */levels$1
];

function enforce_eq_instances(x, y) {
  if (x.length !== y.length) {
    CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Invalid argument: enforce_eq_instances called with"), Pp$ReactTemplate.str(" instances of different lengths.")));
  }
  return (function (param) {
      return CArray$ReactTemplate.fold_right2(enforce_eq_level, x, y, param);
    });
}

function subst_instance_level(s, l) {
  var match = l[/* data */1];
  if (typeof match === "number" || match.tag !== 1) {
    return l;
  } else {
    return Caml_array.caml_array_get(s, match[0]);
  }
}

function subst_instance_instance(s, i) {
  return Util$ReactTemplate.$$Array[/* smartmap */47]((function (l) {
                return subst_instance_level(s, l);
              }), i);
}

function subst_instance_universe(s, u) {
  var f = function (x) {
    return map((function (u) {
                  return subst_instance_level(s, u);
                }), x);
  };
  var u$prime = Curry._2(smartmap, f, u);
  if (u === u$prime) {
    return u;
  } else {
    return sort(u$prime);
  }
}

function subst_instance_constraint(s, c) {
  var v = c[2];
  var u = c[0];
  var u$prime = subst_instance_level(s, u);
  var v$prime = subst_instance_level(s, v);
  if (u$prime === u && v$prime === v) {
    return c;
  } else {
    return /* tuple */[
            u$prime,
            c[1],
            v$prime
          ];
  }
}

function out_punivs(param) {
  return param[0];
}

function in_punivs(x) {
  return /* tuple */[
          x,
          empty$4
        ];
}

function eq_puniverses(f, param, param$1) {
  if (Curry._2(f, param[0], param$1[0])) {
    return equal$5(param[1], param$1[1]);
  } else {
    return /* false */0;
  }
}

function make$3(x) {
  return x;
}

var empty$5 = /* tuple */[
  empty$4,
  empty$2
];

function is_empty$4(param) {
  if (param[0].length) {
    return /* false */0;
  } else {
    return Curry._1(is_empty$2, param[1]);
  }
}

function pr$8(prl, variance, ctx) {
  if (is_empty$4(ctx)) {
    return Pp$ReactTemplate.mt(/* () */0);
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.h(0, Pp$ReactTemplate.$plus$plus(pr$7(prl, variance)(ctx[0]), Pp$ReactTemplate.str(" |= "))), Pp$ReactTemplate.h(0, Pp$ReactTemplate.v(0, pr$5(prl, ctx[1]))));
  }
}

function hcons$5(param) {
  return /* tuple */[
          Curry._1(hcons$4, param[0]),
          hcons_constraints(param[1])
        ];
}

function instance(param) {
  return param[0];
}

function constraints(param) {
  return param[1];
}

function union$3(param, param$1) {
  return /* tuple */[
          append(param[0], param$1[0]),
          Curry._2(union$2, param[1], param$1[1])
        ];
}

function dest(x) {
  return x;
}

function size(param) {
  return param[0].length;
}

function repr(param) {
  return /* tuple */[
          Util$ReactTemplate.$$Array[/* mapi */14]((function (i, _) {
                  return $$var(i);
                }), param[0]),
          param[1]
        ];
}

function instantiate(inst, param) {
  if (param[0].length !== inst.length) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "univ.ml",
            996,
            4
          ]
        ];
  }
  var s = inst;
  var csts = param[1];
  return Curry._3(fold$2, (function (c, csts) {
                return Curry._2(add$2, subst_instance_constraint(s, c), csts);
              }), csts, empty$2);
}

function make$4(x) {
  if (instance(x[0]).length === x[1].length) {
    return x;
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Invalid subtyping information encountered!"));
  }
}

var empty_001 = /* array */[];

var empty$6 = /* tuple */[
  empty$5,
  empty_001
];

function is_empty$5(param) {
  if (is_empty$4(param[0])) {
    return Util$ReactTemplate.$$Array[/* is_empty */23](param[1]);
  } else {
    return /* false */0;
  }
}

function pr$9(prl, param) {
  return pr$8(prl, /* Some */[param[1]], param[0]);
}

function hcons$6(param) {
  return /* tuple */[
          hcons$5(param[0]),
          param[1]
        ];
}

function univ_context(param) {
  return param[0];
}

function variance(param) {
  return param[1];
}

function from_universe_context(univs) {
  return /* tuple */[
          univs,
          Util$ReactTemplate.$$Array[/* init */0](size(univs), (function () {
                  return /* Invariant */2;
                }))
        ];
}

function leq_constraints$1(param, u, u$prime, csts) {
  return leq_constraints(param[1], u, u$prime, csts);
}

function eq_constraints$1(param, u, u$prime, csts) {
  return eq_constraints(param[1], u, u$prime, csts);
}

var empty$7 = /* tuple */[
  empty$1,
  empty$2
];

function is_empty$6(param) {
  if (Curry._1(is_empty$1, param[0])) {
    return Curry._1(is_empty$2, param[1]);
  } else {
    return /* false */0;
  }
}

function equal$6(x, y) {
  if (x === y) {
    return /* true */1;
  } else if (Curry._2(equal$1, x[0], y[0])) {
    return Curry._2(equal$4, x[1], y[1]);
  } else {
    return /* false */0;
  }
}

function of_set(s) {
  return /* tuple */[
          s,
          empty$2
        ];
}

function singleton$1(l) {
  var s = Curry._1(singleton, l);
  return /* tuple */[
          s,
          empty$2
        ];
}

function of_instance(i) {
  var s = of_array(i);
  return /* tuple */[
          s,
          empty$2
        ];
}

function union$4(x, y) {
  if (x === y) {
    return x;
  } else {
    return /* tuple */[
            Curry._2(union$1, x[0], y[0]),
            Curry._2(union$2, x[1], y[1])
          ];
  }
}

function append$1(param, param$1) {
  var univs = Curry._3(fold$1, add$1, param[0], param$1[0]);
  var cst = Curry._3(fold$2, add$2, param[1], param$1[1]);
  return /* tuple */[
          univs,
          cst
        ];
}

function diff$3(param, param$1) {
  return /* tuple */[
          Curry._2(diff$1, param[0], param$1[0]),
          Curry._2(diff$2, param[1], param$1[1])
        ];
}

function add_universe(u, param) {
  return /* tuple */[
          Curry._2(add$1, u, param[0]),
          param[1]
        ];
}

function add_constraints(cst$prime, param) {
  return /* tuple */[
          param[0],
          Curry._2(union$2, param[1], cst$prime)
        ];
}

function add_instance(inst, param) {
  var fold = function (accu, u) {
    return Curry._2(add$1, u, accu);
  };
  var univs = Util$ReactTemplate.$$Array[/* fold_left */15](fold, param[0], inst);
  return /* tuple */[
          univs,
          param[1]
        ];
}

function sort_levels(a) {
  Util$ReactTemplate.$$Array[/* sort */17](natural_compare, a);
  return a;
}

function to_context(param) {
  return /* tuple */[
          of_array$1(sort_levels(Util$ReactTemplate.$$Array[/* of_list */10](Curry._1(elements, param[0])))),
          param[1]
        ];
}

function of_context(param) {
  return /* tuple */[
          of_array(param[0]),
          param[1]
        ];
}

function pr$10(prl, ctx) {
  if (is_empty$6(ctx)) {
    return Pp$ReactTemplate.mt(/* () */0);
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.h(0, Pp$ReactTemplate.$plus$plus(pr$2(prl, ctx[0]), Pp$ReactTemplate.str(" |= "))), Pp$ReactTemplate.h(0, Pp$ReactTemplate.v(0, pr$5(prl, ctx[1]))));
  }
}

function constraints$1(param) {
  return param[1];
}

function levels$2(param) {
  return param[0];
}

function size$1(param) {
  return Curry._1(cardinal, param[0]);
}

function subst_univs_level_level(subst, l) {
  try {
    return Curry._2(find, l, subst);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return l;
    } else {
      throw exn;
    }
  }
}

function subst_univs_level_universe(subst, u) {
  var f = function (x) {
    return map((function (u) {
                  return subst_univs_level_level(subst, u);
                }), x);
  };
  var u$prime = Curry._2(smartmap, f, u);
  if (u === u$prime) {
    return u;
  } else {
    return sort(u$prime);
  }
}

function subst_univs_level_instance(subst, i) {
  var i$prime = subst_fn((function (param) {
          return subst_univs_level_level(subst, param);
        }), i);
  if (i === i$prime) {
    return i;
  } else {
    return i$prime;
  }
}

function subst_univs_level_constraint(subst, param) {
  var d = param[1];
  var u$prime = subst_univs_level_level(subst, param[0]);
  var v$prime = subst_univs_level_level(subst, param[2]);
  if (d !== /* Lt */0 && equal(u$prime, v$prime)) {
    return /* None */0;
  } else {
    return /* Some */[/* tuple */[
              u$prime,
              d,
              v$prime
            ]];
  }
}

function subst_univs_level_constraints(subst, csts) {
  return Curry._3(fold$2, (function (c) {
                var partial_arg = subst_univs_level_constraint(subst, c);
                return (function (param) {
                    return Option$ReactTemplate.fold_right(add$2, partial_arg, param);
                  });
              }), csts, empty$2);
}

function subst_univs_level_abstract_universe_context(subst, param) {
  return /* tuple */[
          param[0],
          subst_univs_level_constraints(subst, param[1])
        ];
}

function make_subst(subst, l) {
  return Curry._2(find, l, subst);
}

function subst_univs_expr_opt(fn, param) {
  var n = param[1];
  var l = Curry._1(fn, param[0]);
  return Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (x) {
                var k = n;
                var x$1 = x;
                if (k) {
                  var n$1 = x$1[1];
                  var u = x$1[0];
                  if (is_prop(u)) {
                    return /* tuple */[
                            set,
                            n$1 + k | 0
                          ];
                  } else {
                    return /* tuple */[
                            u,
                            n$1 + k | 0
                          ];
                  }
                } else {
                  return x$1;
                }
              }), l);
}

function subst_univs_universe(fn, ul) {
  var match = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (u, param) {
          var nosubst = param[1];
          var subst = param[0];
          try {
            var a$prime = subst_univs_expr_opt(fn, u);
            return /* tuple */[
                    /* :: */[
                      a$prime,
                      subst
                    ],
                    nosubst
                  ];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* tuple */[
                      subst,
                      /* :: */[
                        u,
                        nosubst
                      ]
                    ];
            } else {
              throw exn;
            }
          }
        }), ul, /* tuple */[
        /* [] */0,
        /* [] */0
      ]);
  var subst = match[0];
  if (CList$ReactTemplate.is_empty(subst)) {
    return ul;
  } else {
    var substs = Curry._3(Util$ReactTemplate.List[/* fold_left */13], merge_univs, /* [] */0, subst);
    return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (acc, u) {
                  return merge_univs(acc, /* :: */[
                              u,
                              /* [] */0
                            ]);
                }), substs, match[1]);
  }
}

function make_instance_subst(i) {
  return Util$ReactTemplate.$$Array[/* fold_left_i */38]((function (i, acc, l) {
                return Curry._3(add, l, $$var(i), acc);
              }), empty, i);
}

function make_inverse_instance_subst(i) {
  return Util$ReactTemplate.$$Array[/* fold_left_i */38]((function (i, acc, l) {
                return Curry._3(add, $$var(i), l, acc);
              }), empty, i);
}

function make_abstract_instance(param) {
  return Util$ReactTemplate.$$Array[/* mapi */14]((function (i, _) {
                return $$var(i);
              }), param[0]);
}

function abstract_universes(ctx) {
  var instance$1 = instance(ctx);
  var subst = make_instance_subst(instance$1);
  var cstrs = subst_univs_level_constraints(subst, constraints(ctx));
  var ctx$1 = /* tuple */[
    instance$1,
    cstrs
  ];
  return /* tuple */[
          instance$1,
          ctx$1
        ];
}

function abstract_cumulativity_info(param) {
  var match = abstract_universes(param[0]);
  return /* tuple */[
          match[0],
          /* tuple */[
            match[1],
            param[1]
          ]
        ];
}

function pr_constraints(prl) {
  return (function (param) {
      return pr$5(prl, param);
    });
}

function pr_universe_subst(param) {
  return pr$1((function (u) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" := "), pr$4(u)), Pp$ReactTemplate.spc(/* () */0));
              }), param);
}

function pr_universe_level_subst(param) {
  return pr$1((function (u) {
                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" := "), Pp$ReactTemplate.str(to_string(u))), Pp$ReactTemplate.spc(/* () */0));
              }), param);
}

function hashcons$5(huc, s) {
  return Curry._3(fold$1, (function (x) {
                return Curry._1(add$1, Curry._1(huc, x));
              }), s, empty$1);
}

var eq$5 = Curry.__2(equal$1);

var Huniverse_set = Hashcons$ReactTemplate.Make(/* module */[
      /* hashcons */hashcons$5,
      /* eq */eq$5,
      /* hash */Hashtbl.hash
    ]);

var hcons_universe_set = Hashcons$ReactTemplate.simple_hcons(Huniverse_set[/* generate */0], Huniverse_set[/* hcons */1], hcons$1);

function hcons_universe_context_set(param) {
  return /* tuple */[
          hcons_universe_set(param[0]),
          hcons_constraints(param[1])
        ];
}

var hcons_univ = Curry.__1(hcons$3);

function explain_universe_inconsistency(prl, param) {
  var p = param[3];
  var v = param[2];
  var u = param[1];
  var pr_rel = function (param) {
    switch (param) {
      case 0 : 
          return Pp$ReactTemplate.str("<");
      case 1 : 
          return Pp$ReactTemplate.str("<=");
      case 2 : 
          return Pp$ReactTemplate.str("=");
      
    }
  };
  var reason;
  if (p) {
    var p$1 = p[0];
    reason = p$1 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" because"), Pp$ReactTemplate.spc(/* () */0)), pr_with$1(prl, v)), Pp$ReactTemplate.prlist((function (param) {
                      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), pr_rel(param[0])), Pp$ReactTemplate.str(" ")), pr_with$1(prl, param[1]));
                    }), p$1)), equal$3(Curry._1(Util$ReactTemplate.List[/* last */105], p$1)[1], u) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("= ")), pr_with$1(prl, u))) : Pp$ReactTemplate.mt(/* () */0);
  } else {
    reason = Pp$ReactTemplate.mt(/* () */0);
  }
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cannot enforce"), Pp$ReactTemplate.spc(/* () */0)), pr_with$1(prl, u)), Pp$ReactTemplate.spc(/* () */0)), pr_rel(param[0])), Pp$ReactTemplate.spc(/* () */0)), pr_with$1(prl, v)), reason);
}

var Level = [
  set,
  prop,
  is_small,
  is_prop,
  is_set,
  compare$1,
  equal,
  hash$1,
  make$1,
  pr,
  to_string,
  $$var,
  var_index,
  name
];

var LSet_002 = include[2];

var LSet_005 = include[5];

var LSet_007 = include[7];

var LSet_009 = include[9];

var LSet_011 = include[11];

var LSet_012 = include[12];

var LSet_014 = include[14];

var LSet_015 = include[15];

var LSet_016 = include[16];

var LSet_017 = include[17];

var LSet_020 = include[20];

var LSet_021 = include[21];

var LSet_022 = include[22];

var LSet_023 = include[23];

var LSet = [
  empty$1,
  is_empty$1,
  LSet_002,
  add$1,
  singleton,
  LSet_005,
  union$1,
  LSet_007,
  diff$1,
  LSet_009,
  equal$1,
  LSet_011,
  LSet_012,
  fold$1,
  LSet_014,
  LSet_015,
  LSet_016,
  LSet_017,
  cardinal,
  elements,
  LSet_020,
  LSet_021,
  LSet_022,
  LSet_023,
  pr$2
];

var Universe = [
  compare$3,
  equal$3,
  hash$4,
  make$2,
  pr$4,
  pr_with$1,
  is_level$1,
  is_levels,
  level,
  levels,
  $$super$1,
  sup,
  type0m,
  type0,
  type1$1,
  exists,
  for_all,
  map$1,
  compact$1
];

var pr_uni = pr$4;

var type0m_univ = type0m;

var type0_univ = type0;

var type1_univ = type1$1;

var is_type0_univ = is_type0;

var is_type0m_univ = is_type0m;

var is_small_univ = is_small$1;

var universe_level = level;

var Constraint_002 = S[2];

var Constraint_004 = S[4];

var Constraint_005 = S[5];

var Constraint_007 = S[7];

var Constraint_009 = S[9];

var Constraint_011 = S[11];

var Constraint_012 = S[12];

var Constraint_014 = S[14];

var Constraint_015 = S[15];

var Constraint_016 = S[16];

var Constraint_017 = S[17];

var Constraint_018 = S[18];

var Constraint_020 = S[20];

var Constraint_021 = S[21];

var Constraint_022 = S[22];

var Constraint_023 = S[23];

var Constraint_024 = S[24];

var Constraint_025 = S[25];

var Constraint = [
  empty$2,
  is_empty$2,
  Constraint_002,
  add$2,
  Constraint_004,
  Constraint_005,
  union$2,
  Constraint_007,
  diff$2,
  Constraint_009,
  equal$4,
  Constraint_011,
  Constraint_012,
  fold$2,
  Constraint_014,
  Constraint_015,
  Constraint_016,
  Constraint_017,
  Constraint_018,
  elements$1,
  Constraint_020,
  Constraint_021,
  Constraint_022,
  Constraint_023,
  Constraint_024,
  Constraint_025
];

var empty_constraint = empty$2;

var union_constraint = union$2;

var eq_constraint$1 = equal$4;

var LMap_004 = M[4];

var LMap_005 = M[5];

var LMap_007 = M[7];

var LMap_008 = M[8];

var LMap_009 = M[9];

var LMap_011 = M[11];

var LMap_012 = M[12];

var LMap_013 = M[13];

var LMap_014 = M[14];

var LMap_015 = M[15];

var LMap_017 = M[17];

var LMap_018 = M[18];

var LMap_019 = M[19];

var LMap_020 = M[20];

var LMap_022 = M[22];

var LMap_023 = M[23];

var LMap_024 = M[25];

var LMap_025 = M[26];

var LMap_026 = M[27];

var LMap_027 = M[28];

var LMap_028 = M[29];

var LMap_029 = M[30];

var LMap_030 = M[31];

var LMap_031 = M[32];

var LMap_032 = M[33];

var LMap_033 = M[34];

var LMap_034 = M[/* Unsafe */35];

var LMap_035 = M[/* Monad */36];

var LMap = [
  empty,
  is_empty,
  mem,
  add,
  LMap_004,
  LMap_005,
  merge,
  LMap_007,
  LMap_008,
  LMap_009,
  fold,
  LMap_011,
  LMap_012,
  LMap_013,
  LMap_014,
  LMap_015,
  bindings,
  LMap_017,
  LMap_018,
  LMap_019,
  LMap_020,
  find,
  LMap_022,
  LMap_023,
  LMap_024,
  LMap_025,
  LMap_026,
  LMap_027,
  LMap_028,
  LMap_029,
  LMap_030,
  LMap_031,
  LMap_032,
  LMap_033,
  LMap_034,
  LMap_035,
  union,
  diff,
  subst_union,
  pr$1
];

var Variance = [
  check_subtype,
  sup$1,
  pr$6
];

var enforce_eq_variance_instances = eq_constraints;

var enforce_leq_variance_instances = leq_constraints;

var UContext = [
  make$3,
  empty$5,
  is_empty$4,
  instance,
  constraints,
  dest,
  union$3,
  size
];

var AUContext = [
  repr,
  empty$5,
  is_empty$4,
  instance,
  size,
  union$3,
  instantiate
];

var CumulativityInfo = [
  make$4,
  empty$6,
  is_empty$5,
  univ_context,
  variance,
  from_universe_context,
  leq_constraints$1,
  eq_constraints$1
];

var ACumulativityInfo = [
  univ_context,
  variance,
  leq_constraints$1,
  eq_constraints$1
];

var ContextSet = [
  empty$7,
  is_empty$6,
  singleton$1,
  of_instance,
  of_set,
  equal$6,
  union$4,
  append$1,
  diff$3,
  add_universe,
  add_constraints,
  add_instance,
  sort_levels,
  to_context,
  of_context,
  constraints$1,
  levels$2,
  size$1
];

var empty_level_subst = empty;

var is_empty_level_subst = is_empty;

var empty_subst = empty;

var is_empty_subst = is_empty;

var pr_universe_context = pr$8;

var pr_cumulativity_info = pr$9;

var pr_abstract_universe_context = pr$8;

var pr_abstract_cumulativity_info = pr$9;

var pr_universe_context_set = pr$10;

var hcons_universe_context = hcons$5;

var hcons_abstract_universe_context = hcons$5;

var hcons_cumulativity_info = hcons$6;

var hcons_abstract_cumulativity_info = hcons$6;

var compare_levels = compare$1;

var eq_levels = equal;

var equal_universes = equal$3;

var universes_of_constraints = universes_of;

exports.Level = Level;
exports.LSet = LSet;
exports.Universe = Universe;
exports.pr_uni = pr_uni;
exports.type0m_univ = type0m_univ;
exports.type0_univ = type0_univ;
exports.type1_univ = type1_univ;
exports.is_type0_univ = is_type0_univ;
exports.is_type0m_univ = is_type0m_univ;
exports.is_univ_variable = is_univ_variable;
exports.is_small_univ = is_small_univ;
exports.sup = sup;
exports.$$super = $$super$1;
exports.universe_level = universe_level;
exports.univ_level_mem = univ_level_mem;
exports.univ_level_rem = univ_level_rem;
exports.Constraint = Constraint;
exports.empty_constraint = empty_constraint;
exports.union_constraint = union_constraint;
exports.eq_constraint = eq_constraint$1;
exports.constraints_of = constraints_of;
exports.enforce_eq = enforce_eq;
exports.enforce_leq = enforce_leq;
exports.enforce_eq_level = enforce_eq_level;
exports.enforce_leq_level = enforce_leq_level;
exports.UniverseInconsistency = UniverseInconsistency;
exports.LMap = LMap;
exports.Variance = Variance;
exports.Instance = Instance;
exports.enforce_eq_instances = enforce_eq_instances;
exports.enforce_eq_variance_instances = enforce_eq_variance_instances;
exports.enforce_leq_variance_instances = enforce_leq_variance_instances;
exports.out_punivs = out_punivs;
exports.in_punivs = in_punivs;
exports.eq_puniverses = eq_puniverses;
exports.UContext = UContext;
exports.AUContext = AUContext;
exports.CumulativityInfo = CumulativityInfo;
exports.ACumulativityInfo = ACumulativityInfo;
exports.ContextSet = ContextSet;
exports.empty_level_subst = empty_level_subst;
exports.is_empty_level_subst = is_empty_level_subst;
exports.subst_univs_level_level = subst_univs_level_level;
exports.subst_univs_level_universe = subst_univs_level_universe;
exports.subst_univs_level_constraints = subst_univs_level_constraints;
exports.subst_univs_level_abstract_universe_context = subst_univs_level_abstract_universe_context;
exports.subst_univs_level_instance = subst_univs_level_instance;
exports.empty_subst = empty_subst;
exports.is_empty_subst = is_empty_subst;
exports.make_subst = make_subst;
exports.subst_univs_universe = subst_univs_universe;
exports.subst_instance_instance = subst_instance_instance;
exports.subst_instance_universe = subst_instance_universe;
exports.make_instance_subst = make_instance_subst;
exports.make_inverse_instance_subst = make_inverse_instance_subst;
exports.abstract_universes = abstract_universes;
exports.abstract_cumulativity_info = abstract_cumulativity_info;
exports.make_abstract_instance = make_abstract_instance;
exports.pr_constraint_type = pr_constraint_type;
exports.pr_constraints = pr_constraints;
exports.pr_universe_context = pr_universe_context;
exports.pr_cumulativity_info = pr_cumulativity_info;
exports.pr_abstract_universe_context = pr_abstract_universe_context;
exports.pr_abstract_cumulativity_info = pr_abstract_cumulativity_info;
exports.pr_universe_context_set = pr_universe_context_set;
exports.explain_universe_inconsistency = explain_universe_inconsistency;
exports.pr_universe_level_subst = pr_universe_level_subst;
exports.pr_universe_subst = pr_universe_subst;
exports.hcons_univ = hcons_univ;
exports.hcons_constraints = hcons_constraints;
exports.hcons_universe_set = hcons_universe_set;
exports.hcons_universe_context = hcons_universe_context;
exports.hcons_abstract_universe_context = hcons_abstract_universe_context;
exports.hcons_universe_context_set = hcons_universe_context_set;
exports.hcons_cumulativity_info = hcons_cumulativity_info;
exports.hcons_abstract_cumulativity_info = hcons_abstract_cumulativity_info;
exports.compare_levels = compare_levels;
exports.eq_levels = eq_levels;
exports.equal_universes = equal_universes;
exports.universes_of_constraints = universes_of_constraints;
/* H Not a pure module */
