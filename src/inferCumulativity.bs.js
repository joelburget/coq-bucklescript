// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Esubst$ReactTemplate = require("./esubst.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var Control$ReactTemplate = require("../shims/control.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Typeops$ReactTemplate = require("./typeops.bs.js");
var CClosure$ReactTemplate = require("./cClosure.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Reduction$ReactTemplate = require("./reduction.bs.js");

function infer_level_eq(u, variances) {
  if (Curry._2(Univ$ReactTemplate.LMap[/* mem */2], u, variances)) {
    return Curry._3(Univ$ReactTemplate.LMap[/* set */25], u, /* Invariant */2, variances);
  } else {
    return variances;
  }
}

function infer_level_leq(u, variances) {
  var exit = 0;
  var varu;
  try {
    varu = Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, variances);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return variances;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return Curry._3(Univ$ReactTemplate.LMap[/* set */25], u, Univ$ReactTemplate.Variance[/* sup */1](varu, /* Covariant */1), variances);
  }
  
}

function infer_generic_instance_eq(variances, u) {
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (variances, u) {
                return infer_level_eq(u, variances);
              }), variances, Univ$ReactTemplate.Instance[/* to_array */3](u));
}

function variance_pb(cv_pb, $$var) {
  switch ($$var) {
    case 0 : 
        return /* Irrelevant */0;
    case 1 : 
        if (cv_pb !== 0) {
          return /* Covariant */1;
        } else {
          return /* Invariant */2;
        }
    case 2 : 
        return /* Invariant */2;
    
  }
}

function infer_cumulative_ind_instance(cv_pb, cumi, variances, u) {
  return Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (variances, varu, u) {
                var exit = 0;
                var varu$prime;
                try {
                  varu$prime = Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, variances);
                  exit = 1;
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return variances;
                  } else {
                    throw exn;
                  }
                }
                if (exit === 1) {
                  return Curry._3(Univ$ReactTemplate.LMap[/* set */25], u, Univ$ReactTemplate.Variance[/* sup */1](varu$prime, variance_pb(cv_pb, varu)), variances);
                }
                
              }), variances, Univ$ReactTemplate.ACumulativityInfo[/* variance */1](cumi), Univ$ReactTemplate.Instance[/* to_array */3](u));
}

function infer_inductive_instance(cv_pb, env, variances, ind, nargs, u) {
  var mind = Environ$ReactTemplate.lookup_mind(ind[0], env);
  var match = mind[/* mind_universes */8];
  switch (match.tag | 0) {
    case 0 : 
        if (!Univ$ReactTemplate.Instance[/* is_empty */1](u)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "inferCumulativity.ml",
                  55,
                  25
                ]
              ];
        }
        return variances;
    case 1 : 
        return infer_generic_instance_eq(variances, u);
    case 2 : 
        if (Reduction$ReactTemplate.inductive_cumulativity_arguments(/* tuple */[
                mind,
                ind[1]
              ]) !== nargs) {
          return infer_generic_instance_eq(variances, u);
        } else {
          return infer_cumulative_ind_instance(cv_pb, match[0], variances, u);
        }
    
  }
}

function infer_constructor_instance_eq(env, variances, param, nargs, u) {
  var match = param[0];
  var mind = Environ$ReactTemplate.lookup_mind(match[0], env);
  var match$1 = mind[/* mind_universes */8];
  switch (match$1.tag | 0) {
    case 0 : 
        if (!Univ$ReactTemplate.Instance[/* is_empty */1](u)) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "inferCumulativity.ml",
                  65,
                  25
                ]
              ];
        }
        return variances;
    case 1 : 
        return infer_generic_instance_eq(variances, u);
    case 2 : 
        if (Reduction$ReactTemplate.constructor_cumulativity_arguments(/* tuple */[
                mind,
                match[1],
                param[1]
              ]) !== nargs) {
          return infer_generic_instance_eq(variances, u);
        } else {
          return infer_cumulative_ind_instance(/* CONV */0, match$1[0], variances, u);
        }
    
  }
}

function infer_table_key(_, variances, c) {
  switch (c.tag | 0) {
    case 0 : 
        return infer_generic_instance_eq(variances, c[0][1]);
    case 1 : 
    case 2 : 
        return variances;
    
  }
}

function whd_stack(param, hd, stk) {
  return CClosure$ReactTemplate.whd_stack(param[0], param[1], hd, stk);
}

function infer_fterm(_cv_pb, infos, _variances, _hd, _stk) {
  while(true) {
    var stk = _stk;
    var hd = _hd;
    var variances = _variances;
    var cv_pb = _cv_pb;
    Control$ReactTemplate.check_for_interrupt(/* () */0);
    var match = whd_stack(infos, hd, stk);
    var stk$1 = match[1];
    var hd$1 = match[0];
    var match$1 = CClosure$ReactTemplate.fterm_of(hd$1);
    var exit = 0;
    if (typeof match$1 === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "inferCumulativity.ml",
              140,
              76
            ]
          ];
    } else {
      switch (match$1.tag | 0) {
        case 0 : 
            return variances;
        case 1 : 
            var match$2 = Constr$ReactTemplate.kind(match$1[0]);
            switch (match$2.tag | 0) {
              case 2 : 
                  return infer_stack(infos, variances, stk$1);
              case 4 : 
                  var cv_pb$1 = cv_pb;
                  var variances$1 = variances;
                  var s = match$2[0];
                  if (cv_pb$1 !== 0) {
                    return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], infer_level_leq, Univ$ReactTemplate.Universe[/* levels */9](Sorts$ReactTemplate.univ_of_sort(s)), variances$1);
                  } else {
                    return Curry._3(Univ$ReactTemplate.LSet[/* fold */13], infer_level_eq, Univ$ReactTemplate.Universe[/* levels */9](Sorts$ReactTemplate.univ_of_sort(s)), variances$1);
                  }
              default:
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "inferCumulativity.ml",
                        97,
                        13
                      ]
                    ];
            }
            break;
        case 3 : 
            var variances$2 = infer_table_key(infos, variances, match$1[0]);
            return infer_stack(infos, variances$2, stk$1);
        case 4 : 
            var match$3 = match$1[0];
            var u = match$3[1];
            var variances$3;
            if (Univ$ReactTemplate.Instance[/* is_empty */1](u)) {
              variances$3 = variances;
            } else {
              var nargs = CClosure$ReactTemplate.stack_args_size(stk$1);
              variances$3 = infer_inductive_instance(cv_pb, CClosure$ReactTemplate.info_env(infos[0]), variances, match$3[0], nargs, u);
            }
            return infer_stack(infos, variances$3, stk$1);
        case 5 : 
            var match$4 = match$1[0];
            var u$1 = match$4[1];
            var variances$4;
            if (Univ$ReactTemplate.Instance[/* is_empty */1](u$1)) {
              variances$4 = variances;
            } else {
              var nargs$1 = CClosure$ReactTemplate.stack_args_size(stk$1);
              variances$4 = infer_constructor_instance_eq(CClosure$ReactTemplate.info_env(infos[0]), variances, match$4[0], nargs$1, u$1);
            }
            return infer_stack(infos, variances$4, stk$1);
        case 7 : 
            var variances$5 = infer_fterm(/* CONV */0, infos, variances, match$1[1], /* [] */0);
            return infer_stack(infos, variances$5, stk$1);
        case 8 : 
        case 9 : 
            exit = 1;
            break;
        case 11 : 
            var match$5 = CClosure$ReactTemplate.destFLambda(CClosure$ReactTemplate.mk_clos, hd$1);
            var variances$6 = infer_fterm(/* CONV */0, infos, variances, match$5[1], /* [] */0);
            _stk = /* [] */0;
            _hd = match$5[2];
            _variances = variances$6;
            _cv_pb = /* CONV */0;
            continue ;
            case 12 : 
            var variances$7 = infer_fterm(/* CONV */0, infos, variances, match$1[1], /* [] */0);
            _stk = /* [] */0;
            _hd = match$1[2];
            _variances = variances$7;
            continue ;
            case 14 : 
            var e = match$1[1];
            var variances$8 = infer_stack(infos, variances, stk$1);
            return infer_vect(infos, variances$8, Util$ReactTemplate.$$Array[/* map */12]((function(e){
                          return function (param) {
                            return CClosure$ReactTemplate.mk_clos(e, param);
                          }
                          }(e)), match$1[0][1]));
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "inferCumulativity.ml",
                  140,
                  76
                ]
              ];
      }
    }
    if (exit === 1) {
      var e$1 = match$1[1];
      var match$6 = match$1[0][1];
      var cl = match$6[2];
      var n = cl.length;
      var variances$9 = infer_vect(infos, variances, Util$ReactTemplate.$$Array[/* map */12]((function(e$1){
              return function (param) {
                return CClosure$ReactTemplate.mk_clos(e$1, param);
              }
              }(e$1)), match$6[1]));
      var le = Esubst$ReactTemplate.subs_liftn(n, e$1);
      var variances$10 = infer_vect(infos, variances$9, Util$ReactTemplate.$$Array[/* map */12]((function(le){
              return function (param) {
                return CClosure$ReactTemplate.mk_clos(le, param);
              }
              }(le)), cl));
      return infer_stack(infos, variances$10, stk$1);
    }
    
  };
}

function infer_stack(infos, _variances, _stk) {
  while(true) {
    var stk = _stk;
    var variances = _variances;
    if (stk) {
      var z = stk[0];
      var variances$1;
      switch (z.tag | 0) {
        case 0 : 
            variances$1 = infer_vect(infos, variances, z[0]);
            break;
        case 1 : 
            var e = z[3];
            var variances$2 = infer_fterm(/* CONV */0, infos, variances, CClosure$ReactTemplate.mk_clos(e, z[1]), /* [] */0);
            variances$1 = infer_vect(infos, variances$2, Util$ReactTemplate.$$Array[/* map */12]((function(e){
                    return function (param) {
                      return CClosure$ReactTemplate.mk_clos(e, param);
                    }
                    }(e)), z[2]));
            break;
        case 3 : 
            var variances$3 = infer_fterm(/* CONV */0, infos, variances, z[0], /* [] */0);
            variances$1 = infer_stack(infos, variances$3, z[1]);
            break;
        default:
          variances$1 = variances;
      }
      _stk = stk[1];
      _variances = variances$1;
      continue ;
      
    } else {
      return variances;
    }
  };
}

function infer_vect(infos, variances, v) {
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (variances, c) {
                return infer_fterm(/* CONV */0, infos, variances, c, /* [] */0);
              }), variances, v);
}

function infer_term(cv_pb, env, variances, c) {
  var infos_000 = CClosure$ReactTemplate.create_clos_infos(/* None */0, CClosure$ReactTemplate.all, env);
  var infos_001 = CClosure$ReactTemplate.create_tab(/* () */0);
  var infos = /* tuple */[
    infos_000,
    infos_001
  ];
  return infer_fterm(cv_pb, infos, variances, CClosure$ReactTemplate.inject(c), /* [] */0);
}

function infer_arity_constructor(is_arity, env, variances, arcn) {
  var infer_typ = function (typ, param) {
    var env = param[0];
    if (typ.tag) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "inferCumulativity.ml",
              174,
              44
            ]
          ];
    } else {
      return /* tuple */[
              Environ$ReactTemplate.push_rel(typ, env),
              infer_term(/* CUMUL */1, env, param[1], typ[1])
            ];
    }
  };
  var match = Reduction$ReactTemplate.dest_prod(env)(arcn);
  var match$1 = Context$ReactTemplate.Rel[/* fold_outside */10](infer_typ, match[0], /* tuple */[
        env,
        variances
      ]);
  var variances$1 = match$1[1];
  if (is_arity) {
    return variances$1;
  } else {
    return infer_term(/* CUMUL */1, match$1[0], variances$1, match[1]);
  }
}

function infer_inductive(env, mie) {
  var univs = mie[/* mind_entry_universes */4];
  var univs$1;
  switch (univs.tag | 0) {
    case 0 : 
    case 1 : 
        univs$1 = univs;
        break;
    case 2 : 
        var uctx = Univ$ReactTemplate.CumulativityInfo[/* univ_context */3](univs[0]);
        var uarray = Univ$ReactTemplate.Instance[/* to_array */3](Univ$ReactTemplate.UContext[/* instance */3](uctx));
        var env$1 = Environ$ReactTemplate.push_context(/* None */0, uctx, env);
        var variances = Util$ReactTemplate.$$Array[/* fold_left */15]((function (variances, u) {
                return Curry._3(Univ$ReactTemplate.LMap[/* add */3], u, /* Irrelevant */0, variances);
              }), Univ$ReactTemplate.LMap[/* empty */0], uarray);
        var match = Typeops$ReactTemplate.infer_local_decls(env$1, mie[/* mind_entry_params */2]);
        var env$2 = match[0];
        var variances$1 = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (variances, entry) {
                var variances$1 = infer_arity_constructor(/* true */1, env$2, variances, entry[/* mind_entry_arity */1]);
                return Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (param, param$1) {
                              return infer_arity_constructor(/* false */0, env$2, param, param$1);
                            }), variances$1, entry[/* mind_entry_lc */4]);
              }), variances, mie[/* mind_entry_inds */3]);
        var variances$2 = Util$ReactTemplate.$$Array[/* map */12]((function (u) {
                return Curry._2(Univ$ReactTemplate.LMap[/* find */21], u, variances$1);
              }), uarray);
        univs$1 = /* Cumulative_ind_entry */Block.__(2, [Univ$ReactTemplate.CumulativityInfo[/* make */0](/* tuple */[
                  uctx,
                  variances$2
                ])]);
        break;
    
  }
  var newrecord = mie.slice();
  newrecord[/* mind_entry_universes */4] = univs$1;
  return newrecord;
}

exports.infer_inductive = infer_inductive;
/* Univ-ReactTemplate Not a pure module */
