// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var $$Set = require("bs-platform/lib/js/set.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Int$ReactTemplate = require("./int.bs.js");
var CMap$ReactTemplate = require("./cMap.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function Make(funarg) {
  var $$Set$1 = $$Set.Make([funarg[0]]);
  var empty = Int$ReactTemplate.$$Map[/* empty */0];
  var is_empty = Int$ReactTemplate.$$Map[/* is_empty */1];
  var mem = function (x, s) {
    var h = Curry._1(funarg[/* hash */1], x);
    try {
      var m = Int$ReactTemplate.$$Map[/* find */21](h, s);
      return Curry._2($$Set$1[/* mem */2], x, m);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  };
  var add = function (x, s) {
    var h = Curry._1(funarg[/* hash */1], x);
    try {
      var m = Int$ReactTemplate.$$Map[/* find */21](h, s);
      var m$1 = Curry._2($$Set$1[/* add */3], x, m);
      return Curry._3(Int$ReactTemplate.$$Map[/* set */25], h, m$1, s);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var m$2 = Curry._1($$Set$1[/* singleton */4], x);
        return Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, m$2, s);
      } else {
        throw exn;
      }
    }
  };
  var singleton = function (x) {
    var h = Curry._1(funarg[/* hash */1], x);
    var m = Curry._1($$Set$1[/* singleton */4], x);
    return Curry._2(Int$ReactTemplate.$$Map[/* singleton */4], h, m);
  };
  var remove = function (x, s) {
    var h = Curry._1(funarg[/* hash */1], x);
    try {
      var m = Int$ReactTemplate.$$Map[/* find */21](h, s);
      var m$1 = Curry._2($$Set$1[/* remove */5], x, m);
      if (Curry._1($$Set$1[/* is_empty */1], m$1)) {
        return Curry._2(Int$ReactTemplate.$$Map[/* remove */5], h, s);
      } else {
        return Curry._3(Int$ReactTemplate.$$Map[/* set */25], h, m$1, s);
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return s;
      } else {
        throw exn;
      }
    }
  };
  var is_smaller = function (s1, s2) {
    return +(Curry._1(Int$ReactTemplate.$$Map[/* height */33], s1) <= (Curry._1(Int$ReactTemplate.$$Map[/* height */33], s2) + 3 | 0));
  };
  var fast_union = function (s1, s2) {
    var fold = function (h, s, accu) {
      try {
        return Curry._3(Int$ReactTemplate.$$Map[/* modify */26], h, (function (_, s$prime) {
                      return Curry._3($$Set$1[/* fold */13], $$Set$1[/* add */3], s, s$prime);
                    }), accu);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, s, accu);
        } else {
          throw exn;
        }
      }
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold, s1, s2);
  };
  var union = function (s1, s2) {
    if (is_smaller(s1, s2)) {
      return fast_union(s1, s2);
    } else if (is_smaller(s2, s1)) {
      return fast_union(s2, s1);
    } else {
      var fu = function (_, m1, m2) {
        if (m1) {
          if (m2) {
            return /* Some */[Curry._2($$Set$1[/* union */6], m1[0], m2[0])];
          } else {
            return m1;
          }
        } else if (m2) {
          return m2;
        } else {
          return /* None */0;
        }
      };
      return Curry._3(Int$ReactTemplate.$$Map[/* merge */6], fu, s1, s2);
    }
  };
  var fast_inter = function (s1, s2) {
    var fold = function (h, s, accu) {
      try {
        var s$prime = Int$ReactTemplate.$$Map[/* find */21](h, s2);
        var si = Curry._2($$Set$1[/* filter */16], (function (e) {
                return Curry._2($$Set$1[/* mem */2], e, s$prime);
              }), s);
        if (Curry._1($$Set$1[/* is_empty */1], si)) {
          return accu;
        } else {
          return Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, si, accu);
        }
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return accu;
        } else {
          throw exn;
        }
      }
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold, s1, Int$ReactTemplate.$$Map[/* empty */0]);
  };
  var inter = function (s1, s2) {
    if (is_smaller(s1, s2)) {
      return fast_inter(s1, s2);
    } else if (is_smaller(s2, s1)) {
      return fast_inter(s2, s1);
    } else {
      var fu = function (_, m1, m2) {
        if (m1) {
          if (m2) {
            var m = Curry._2($$Set$1[/* inter */7], m1[0], m2[0]);
            if (Curry._1($$Set$1[/* is_empty */1], m)) {
              return /* None */0;
            } else {
              return /* Some */[m];
            }
          } else {
            return /* None */0;
          }
        } else {
          return /* None */0;
        }
      };
      return Curry._3(Int$ReactTemplate.$$Map[/* merge */6], fu, s1, s2);
    }
  };
  var diff = function (s1, s2) {
    if (is_smaller(s1, s2)) {
      var s1$1 = s1;
      var s2$1 = s2;
      var fold = function (h, s, accu) {
        try {
          var s$prime = Int$ReactTemplate.$$Map[/* find */21](h, s2$1);
          var si = Curry._2($$Set$1[/* filter */16], (function (e) {
                  return 1 - Curry._2($$Set$1[/* mem */2], e, s$prime);
                }), s);
          if (Curry._1($$Set$1[/* is_empty */1], si)) {
            return accu;
          } else {
            return Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, si, accu);
          }
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, s, accu);
          } else {
            throw exn;
          }
        }
      };
      return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold, s1$1, Int$ReactTemplate.$$Map[/* empty */0]);
    } else if (is_smaller(s2, s2)) {
      var s1$2 = s1;
      var s2$2 = s2;
      var fold$1 = function (h, s, accu) {
        try {
          var s$prime = Int$ReactTemplate.$$Map[/* find */21](h, accu);
          var si = Curry._2($$Set$1[/* filter */16], (function (e) {
                  return 1 - Curry._2($$Set$1[/* mem */2], e, s);
                }), s$prime);
          if (Curry._1($$Set$1[/* is_empty */1], si)) {
            return Curry._2(Int$ReactTemplate.$$Map[/* remove */5], h, accu);
          } else {
            return Curry._3(Int$ReactTemplate.$$Map[/* set */25], h, si, accu);
          }
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return accu;
          } else {
            throw exn;
          }
        }
      };
      return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold$1, s2$2, s1$2);
    } else {
      var fu = function (_, m1, m2) {
        if (m1) {
          if (m2) {
            var m = Curry._2($$Set$1[/* diff */8], m1[0], m2[0]);
            if (Curry._1($$Set$1[/* is_empty */1], m)) {
              return /* None */0;
            } else {
              return /* Some */[m];
            }
          } else {
            return m1;
          }
        } else {
          return /* None */0;
        }
      };
      return Curry._3(Int$ReactTemplate.$$Map[/* merge */6], fu, s1, s2);
    }
  };
  var compare = function (s1, s2) {
    return Curry._3(Int$ReactTemplate.$$Map[/* compare */7], $$Set$1[/* compare */9], s1, s2);
  };
  var equal = function (s1, s2) {
    return Curry._3(Int$ReactTemplate.$$Map[/* equal */8], $$Set$1[/* equal */10], s1, s2);
  };
  var subset = function (s1, s2) {
    var check = function (h, m1) {
      var m2;
      try {
        m2 = Int$ReactTemplate.$$Map[/* find */21](h, s2);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          m2 = $$Set$1[/* empty */0];
        } else {
          throw exn;
        }
      }
      return Curry._2($$Set$1[/* subset */11], m1, m2);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* for_all */11], check, s1);
  };
  var iter = function (f, s) {
    var fi = function (_, m) {
      return Curry._2($$Set$1[/* iter */12], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* iter */9], fi, s);
  };
  var fold = function (f, s, accu) {
    var ff = function (_, m, accu) {
      return Curry._3($$Set$1[/* fold */13], f, m, accu);
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], ff, s, accu);
  };
  var for_all = function (f, s) {
    var ff = function (_, m) {
      return Curry._2($$Set$1[/* for_all */14], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* for_all */11], ff, s);
  };
  var exists = function (f, s) {
    var fe = function (_, m) {
      return Curry._2($$Set$1[/* exists */15], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* exists */12], fe, s);
  };
  var filter = function (f, s) {
    var ff = function (m) {
      return Curry._2($$Set$1[/* filter */16], f, m);
    };
    var s$1 = Curry._2(Int$ReactTemplate.$$Map[/* map */22], ff, s);
    return Curry._2(Int$ReactTemplate.$$Map[/* filter */13], (function (_, m) {
                  return 1 - Curry._1($$Set$1[/* is_empty */1], m);
                }), s$1);
  };
  var partition = function (f, s) {
    var fold = function (h, m, param) {
      var sr = param[1];
      var sl = param[0];
      var match = Curry._2($$Set$1[/* partition */17], f, m);
      var mr = match[1];
      var ml = match[0];
      var sl$1 = Curry._1($$Set$1[/* is_empty */1], ml) ? sl : Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, ml, sl);
      var sr$1 = Curry._1($$Set$1[/* is_empty */1], mr) ? sr : Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, mr, sr);
      return /* tuple */[
              sl$1,
              sr$1
            ];
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold, s, /* tuple */[
                Int$ReactTemplate.$$Map[/* empty */0],
                Int$ReactTemplate.$$Map[/* empty */0]
              ]);
  };
  var cardinal = function (s) {
    var fold = function (_, m, accu) {
      return accu + Curry._1($$Set$1[/* cardinal */18], m) | 0;
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold, s, 0);
  };
  var elements = function (s) {
    var fold = function (_, m, accu) {
      return Curry._3($$Set$1[/* fold */13], (function (x, accu) {
                    return /* :: */[
                            x,
                            accu
                          ];
                  }), m, accu);
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold, s, /* [] */0);
  };
  var min_elt = function () {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "hMap.ml",
            208,
            18
          ]
        ];
  };
  var max_elt = function () {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "hMap.ml",
            210,
            18
          ]
        ];
  };
  var choose = function (s) {
    var match = Curry._1(Int$ReactTemplate.$$Map[/* choose */19], s);
    return Curry._1($$Set$1[/* choose */22], match[1]);
  };
  var split = function (_, _$1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "hMap.ml",
            216,
            18
          ]
        ];
  };
  var $$Map = CMap$ReactTemplate.Make([funarg[0]]);
  var empty$1 = Int$ReactTemplate.$$Map[/* empty */0];
  var is_empty$1 = Int$ReactTemplate.$$Map[/* is_empty */1];
  var mem$1 = function (k, s) {
    var h = Curry._1(funarg[/* hash */1], k);
    try {
      var m = Int$ReactTemplate.$$Map[/* find */21](h, s);
      return Curry._2($$Map[/* mem */2], k, m);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  };
  var add$1 = function (k, x, s) {
    var h = Curry._1(funarg[/* hash */1], k);
    try {
      var m = Int$ReactTemplate.$$Map[/* find */21](h, s);
      var m$1 = Curry._3($$Map[/* add */3], k, x, m);
      return Curry._3(Int$ReactTemplate.$$Map[/* set */25], h, m$1, s);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var m$2 = Curry._2($$Map[/* singleton */4], k, x);
        return Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, m$2, s);
      } else {
        throw exn;
      }
    }
  };
  var singleton$1 = function (k, x) {
    var h = Curry._1(funarg[/* hash */1], k);
    return Curry._2(Int$ReactTemplate.$$Map[/* singleton */4], h, Curry._2($$Map[/* singleton */4], k, x));
  };
  var remove$1 = function (k, s) {
    var h = Curry._1(funarg[/* hash */1], k);
    try {
      var m = Int$ReactTemplate.$$Map[/* find */21](h, s);
      var m$1 = Curry._2($$Map[/* remove */5], k, m);
      if (Curry._1($$Map[/* is_empty */1], m$1)) {
        return Curry._2(Int$ReactTemplate.$$Map[/* remove */5], h, s);
      } else {
        return Curry._3(Int$ReactTemplate.$$Map[/* set */25], h, m$1, s);
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return s;
      } else {
        throw exn;
      }
    }
  };
  var merge = function (f, s1, s2) {
    var fm = function (_, m1, m2) {
      if (m1) {
        var m = m1[0];
        if (m2) {
          var m$1 = Curry._3($$Map[/* merge */6], f, m, m2[0]);
          if (Curry._1($$Map[/* is_empty */1], m$1)) {
            return /* None */0;
          } else {
            return /* Some */[m$1];
          }
        } else {
          var m$2 = Curry._3($$Map[/* merge */6], f, m, $$Map[/* empty */0]);
          if (Curry._1($$Map[/* is_empty */1], m$2)) {
            return /* None */0;
          } else {
            return /* Some */[m$2];
          }
        }
      } else if (m2) {
        var m$3 = Curry._3($$Map[/* merge */6], f, $$Map[/* empty */0], m2[0]);
        if (Curry._1($$Map[/* is_empty */1], m$3)) {
          return /* None */0;
        } else {
          return /* Some */[m$3];
        }
      } else {
        return /* None */0;
      }
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* merge */6], fm, s1, s2);
  };
  var compare$1 = function (f, s1, s2) {
    var fc = function (m1, m2) {
      return Curry._3($$Map[/* compare */7], f, m1, m2);
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* compare */7], fc, s1, s2);
  };
  var equal$1 = function (f, s1, s2) {
    var fe = function (m1, m2) {
      return Curry._3($$Map[/* equal */8], f, m1, m2);
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* equal */8], fe, s1, s2);
  };
  var iter$1 = function (f, s) {
    var fi = function (_, m) {
      return Curry._2($$Map[/* iter */9], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* iter */9], fi, s);
  };
  var fold$1 = function (f, s, accu) {
    var ff = function (_, m, accu) {
      return Curry._3($$Map[/* fold */10], f, m, accu);
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], ff, s, accu);
  };
  var for_all$1 = function (f, s) {
    var ff = function (_, m) {
      return Curry._2($$Map[/* for_all */11], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* for_all */11], ff, s);
  };
  var exists$1 = function (f, s) {
    var fe = function (_, m) {
      return Curry._2($$Map[/* exists */12], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* exists */12], fe, s);
  };
  var filter$1 = function (f, s) {
    var ff = function (m) {
      return Curry._2($$Map[/* filter */13], f, m);
    };
    var s$1 = Curry._2(Int$ReactTemplate.$$Map[/* map */22], ff, s);
    return Curry._2(Int$ReactTemplate.$$Map[/* filter */13], (function (_, m) {
                  return 1 - Curry._1($$Map[/* is_empty */1], m);
                }), s$1);
  };
  var partition$1 = function (f, s) {
    var fold = function (h, m, param) {
      var sr = param[1];
      var sl = param[0];
      var match = Curry._2($$Map[/* partition */14], f, m);
      var mr = match[1];
      var ml = match[0];
      var sl$1 = Curry._1($$Map[/* is_empty */1], ml) ? sl : Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, ml, sl);
      var sr$1 = Curry._1($$Map[/* is_empty */1], mr) ? sr : Curry._3(Int$ReactTemplate.$$Map[/* add */3], h, mr, sr);
      return /* tuple */[
              sl$1,
              sr$1
            ];
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold, s, /* tuple */[
                Int$ReactTemplate.$$Map[/* empty */0],
                Int$ReactTemplate.$$Map[/* empty */0]
              ]);
  };
  var cardinal$1 = function (s) {
    var fold = function (_, m, accu) {
      return accu + Curry._1($$Map[/* cardinal */15], m) | 0;
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold, s, 0);
  };
  var bindings = function (s) {
    var fold = function (_, m, accu) {
      return Curry._3($$Map[/* fold */10], (function (k, x, accu) {
                    return /* :: */[
                            /* tuple */[
                              k,
                              x
                            ],
                            accu
                          ];
                  }), m, accu);
    };
    return Curry._3(Int$ReactTemplate.$$Map[/* fold */10], fold, s, /* [] */0);
  };
  var min_binding = function () {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "hMap.ml",
            339,
            22
          ]
        ];
  };
  var max_binding = function () {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "hMap.ml",
            341,
            22
          ]
        ];
  };
  var fold_left = function (_, _$1, _$2) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "hMap.ml",
            343,
            24
          ]
        ];
  };
  var fold_right = function (_, _$1, _$2) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "hMap.ml",
            345,
            25
          ]
        ];
  };
  var choose$1 = function (s) {
    var match = Curry._1(Int$ReactTemplate.$$Map[/* choose */19], s);
    return Curry._1($$Map[/* choose */19], match[1]);
  };
  var find = function (k, s) {
    var h = Curry._1(funarg[/* hash */1], k);
    var m = Int$ReactTemplate.$$Map[/* find */21](h, s);
    return Curry._2($$Map[/* find */21], k, m);
  };
  var get = function (k, s) {
    try {
      return find(k, s);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "hMap.ml",
                356,
                47
              ]
            ];
      } else {
        throw exn;
      }
    }
  };
  var split$1 = function (_, _$1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "hMap.ml",
            358,
            18
          ]
        ];
  };
  var map = function (f, s) {
    var fs = function (m) {
      return Curry._2($$Map[/* map */22], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* map */22], fs, s);
  };
  var mapi = function (f, s) {
    var fs = function (m) {
      return Curry._2($$Map[/* mapi */23], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* map */22], fs, s);
  };
  var modify = function (k, f, s) {
    var h = Curry._1(funarg[/* hash */1], k);
    var m = Int$ReactTemplate.$$Map[/* find */21](h, s);
    var m$1 = Curry._3($$Map[/* modify */26], k, f, m);
    return Curry._3(Int$ReactTemplate.$$Map[/* set */25], h, m$1, s);
  };
  var bind = function (f, s) {
    var fb = function (m) {
      return Curry._2($$Map[/* bind */28], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* map */22], fb, s);
  };
  var domain = function (s) {
    return Curry._2(Int$ReactTemplate.$$Map[/* map */22], $$Map[/* domain */27], s);
  };
  var set = function (k, x, s) {
    var h = Curry._1(funarg[/* hash */1], k);
    var m = Int$ReactTemplate.$$Map[/* find */21](h, s);
    var m$1 = Curry._3($$Map[/* set */25], k, x, m);
    return Curry._3(Int$ReactTemplate.$$Map[/* set */25], h, m$1, s);
  };
  var smartmap = function (f, s) {
    var fs = function (m) {
      return Curry._2($$Map[/* smartmap */31], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* smartmap */31], fs, s);
  };
  var smartmapi = function (f, s) {
    var fs = function (m) {
      return Curry._2($$Map[/* smartmapi */32], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* smartmap */31], fs, s);
  };
  var height = function (s) {
    return Curry._1(Int$ReactTemplate.$$Map[/* height */33], s);
  };
  var map$1 = function (f, s) {
    var fs = function (m) {
      return Curry._2($$Map[/* Unsafe */34][/* map */0], f, m);
    };
    return Curry._2(Int$ReactTemplate.$$Map[/* map */22], fs, s);
  };
  var Unsafe = /* module */[/* map */map$1];
  var Monad = function (M) {
    var IntM = Curry._1(Int$ReactTemplate.$$Map[/* Monad */35], M);
    var ExtM = Curry._1($$Map[/* Monad */35], M);
    var fold = function (f, s, accu) {
      var ff = function (_, m, accu) {
        return Curry._3(ExtM[/* fold */0], f, m, accu);
      };
      return Curry._3(IntM[/* fold */0], ff, s, accu);
    };
    var fold_left = function (_, _$1, _$2) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "hMap.ml",
              412,
              26
            ]
          ];
    };
    var fold_right = function (_, _$1, _$2) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "hMap.ml",
              413,
              27
            ]
          ];
    };
    return /* module */[
            /* IntM */IntM,
            /* ExtM */ExtM,
            /* fold */fold,
            /* fold_left */fold_left,
            /* fold_right */fold_right
          ];
  };
  return [
          empty$1,
          is_empty$1,
          mem$1,
          add$1,
          singleton$1,
          remove$1,
          merge,
          compare$1,
          equal$1,
          iter$1,
          fold$1,
          for_all$1,
          exists$1,
          filter$1,
          partition$1,
          cardinal$1,
          bindings,
          min_binding,
          max_binding,
          choose$1,
          split$1,
          find,
          map,
          mapi,
          [
            empty,
            is_empty,
            mem,
            add,
            singleton,
            remove,
            union,
            inter,
            diff,
            compare,
            equal,
            subset,
            iter,
            fold,
            for_all,
            exists,
            filter,
            partition,
            cardinal,
            elements,
            min_elt,
            max_elt,
            choose,
            split
          ],
          get,
          set,
          modify,
          domain,
          bind,
          fold_left,
          fold_right,
          smartmap,
          smartmapi,
          height,
          Unsafe,
          (function (funarg) {
              var $$let = Monad(funarg);
              return [
                      $$let[2],
                      $$let[3],
                      $$let[4]
                    ];
            })
        ];
}

exports.Make = Make;
/* Int-ReactTemplate Not a pure module */
