// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Int$ReactTemplate = require("./int.bs.js");
var Evar$ReactTemplate = require("./evar.bs.js");
var Term$ReactTemplate = require("./term.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var CArray$ReactTemplate = require("./cArray.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var UState$ReactTemplate = require("./uState.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Context$ReactTemplate = require("./context.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Nameops$ReactTemplate = require("./nameops.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Universes$ReactTemplate = require("./universes.bs.js");

function print_sort(param) {
  if (param.tag) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Type("), Univ$ReactTemplate.Universe[/* pr */4](param[0])), Pp$ReactTemplate.str(")"));
  } else if (param[0] !== 0) {
    return Pp$ReactTemplate.str("Prop");
  } else {
    return Pp$ReactTemplate.str("Set");
  }
}

function pr_sort_family(param) {
  switch (param) {
    case 0 : 
        return Pp$ReactTemplate.str("Prop");
    case 1 : 
        return Pp$ReactTemplate.str("Set");
    case 2 : 
        return Pp$ReactTemplate.str("Type");
    
  }
}

function pr_fix(pr_constr, param) {
  var match = param[1];
  var bl = match[2];
  var tl = match[1];
  var match$1 = param[0];
  var t = match$1[0];
  var fixl = Util$ReactTemplate.$$Array[/* mapi */14]((function (i, na) {
          return /* tuple */[
                  na,
                  Caml_array.caml_array_get(t, i),
                  Caml_array.caml_array_get(tl, i),
                  Caml_array.caml_array_get(bl, i)
                ];
        }), match[0]);
  return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("fix "), Pp$ReactTemplate.$$int(match$1[1])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("{")), Pp$ReactTemplate.v(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                                return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(Nameops$ReactTemplate.Name[/* print */7], param[0]), Pp$ReactTemplate.str("/")), Pp$ReactTemplate.$$int(param[1])), Pp$ReactTemplate.str(":")), Curry._1(pr_constr, param[2])), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str(":=")), Curry._1(pr_constr, param[3]));
                              }), Util$ReactTemplate.$$Array[/* to_list */9](fixl)))), Pp$ReactTemplate.str("}")));
}

function pr_puniverses(p, u) {
  if (Univ$ReactTemplate.Instance[/* is_empty */1](u)) {
    return p;
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(p, Pp$ReactTemplate.str("(*")), Univ$ReactTemplate.Instance[/* pr */11](Universes$ReactTemplate.pr_with_global_universes, /* None */0)(u)), Pp$ReactTemplate.str("*)"));
  }
}

function pr_constr(c) {
  var match = Constr$ReactTemplate.kind(c);
  switch (match.tag | 0) {
    case 0 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("#"), Pp$ReactTemplate.$$int(match[0]));
    case 1 : 
        return Names$ReactTemplate.Id[/* print */8](match[0]);
    case 2 : 
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Meta("), Pp$ReactTemplate.$$int(match[0])), Pp$ReactTemplate.str(")"));
    case 3 : 
        var match$1 = match[0];
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Evar#"), Pp$ReactTemplate.$$int(Evar$ReactTemplate.repr(match$1[0]))), Pp$ReactTemplate.str("{")), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_constr, Util$ReactTemplate.$$Array[/* to_list */9](match$1[1]))), Pp$ReactTemplate.str("}")));
    case 4 : 
        return print_sort(match[0]);
    case 5 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_constr(match[0])), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str(":")), pr_constr(match[2])), Pp$ReactTemplate.str(")")));
    case 6 : 
        var match$2 = match[0];
        if (match$2) {
          return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("forall "), Names$ReactTemplate.Id[/* print */8](match$2[0])), Pp$ReactTemplate.str(":")), pr_constr(match[1])), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.spc(/* () */0)), pr_constr(match[2])));
        } else {
          return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_constr(match[1])), Pp$ReactTemplate.str(" ->")), Pp$ReactTemplate.spc(/* () */0)), pr_constr(match[2])), Pp$ReactTemplate.str(")")));
        }
    case 7 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("fun "), Curry._1(Nameops$ReactTemplate.Name[/* print */7], match[0])), Pp$ReactTemplate.str(":")), pr_constr(match[1])), Pp$ReactTemplate.str(" =>")), Pp$ReactTemplate.spc(/* () */0)), pr_constr(match[2])));
    case 8 : 
        return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("let "), Curry._1(Nameops$ReactTemplate.Name[/* print */7], match[0])), Pp$ReactTemplate.str(":=")), pr_constr(match[1])), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.brk(/* tuple */[
                                        1,
                                        2
                                      ])), pr_constr(match[2])), Pp$ReactTemplate.cut(/* () */0)), pr_constr(match[3])));
    case 9 : 
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_constr(match[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_constr, Util$ReactTemplate.$$Array[/* to_list */9](match[1]))), Pp$ReactTemplate.str(")")));
    case 10 : 
        var match$3 = match[0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Cst("), pr_puniverses(Pp$ReactTemplate.str(Names$ReactTemplate.Constant[/* to_string */15](match$3[0])), match$3[1])), Pp$ReactTemplate.str(")"));
    case 11 : 
        var match$4 = match[0];
        var match$5 = match$4[0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Ind("), pr_puniverses(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.MutInd[/* print */15](match$5[0]), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.$$int(match$5[1])), match$4[1])), Pp$ReactTemplate.str(")"));
    case 12 : 
        var match$6 = match[0];
        var match$7 = match$6[0];
        var match$8 = match$7[0];
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Constr("), pr_puniverses(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.MutInd[/* print */15](match$8[0]), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.$$int(match$8[1])), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.$$int(match$7[1])), match$6[1])), Pp$ReactTemplate.str(")"));
    case 13 : 
        return Pp$ReactTemplate.v(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.hv(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("<"), pr_constr(match[1])), Pp$ReactTemplate.str(">")), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str("Case ")), pr_constr(match[2])), Pp$ReactTemplate.str("of"))), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.prlist_with_sep((function () {
                                      return Pp$ReactTemplate.brk(/* tuple */[
                                                  1,
                                                  2
                                                ]);
                                    }), pr_constr, Util$ReactTemplate.$$Array[/* to_list */9](match[3]))), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str("end")));
    case 14 : 
        return pr_fix(pr_constr, match[0]);
    case 15 : 
        var match$9 = match[0];
        var match$10 = match$9[1];
        var bl = match$10[2];
        var tl = match$10[1];
        var fixl = Util$ReactTemplate.$$Array[/* mapi */14]((function (i, na) {
                return /* tuple */[
                        na,
                        Caml_array.caml_array_get(tl, i),
                        Caml_array.caml_array_get(bl, i)
                      ];
              }), match$10[0]);
        return Pp$ReactTemplate.hov(1, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("cofix "), Pp$ReactTemplate.$$int(match$9[0])), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("{")), Pp$ReactTemplate.v(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, (function (param) {
                                      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Curry._1(Nameops$ReactTemplate.Name[/* print */7], param[0]), Pp$ReactTemplate.str(":")), pr_constr(param[1])), Pp$ReactTemplate.cut(/* () */0)), Pp$ReactTemplate.str(":=")), pr_constr(param[2]));
                                    }), Util$ReactTemplate.$$Array[/* to_list */9](fixl)))), Pp$ReactTemplate.str("}")));
    case 16 : 
        var p = match[0];
        var sp = Names$ReactTemplate.Projection[/* constant */2](p);
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Proj("), Pp$ReactTemplate.str(Names$ReactTemplate.Constant[/* to_string */15](sp))), Pp$ReactTemplate.str(",")), Pp$ReactTemplate.bool(Names$ReactTemplate.Projection[/* unfolded */3](p))), pr_constr(match[1])), Pp$ReactTemplate.str(")"));
    
  }
}

var term_printer = [(function (_, _$1, c) {
      return pr_constr(EConstr$ReactTemplate.Unsafe[/* to_constr */0](c));
    })];

function print_constr_env(env, sigma, t) {
  return Curry._3(term_printer[0], env, sigma, t);
}

function print_constr(t) {
  return Curry._3(term_printer[0], Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty, t);
}

function set_print_constr(f) {
  term_printer[0] = f;
  return /* () */0;
}

function pr_evar_suggested_name(evk, sigma) {
  var base_id = function (evk$prime, evi) {
    var match = Evd$ReactTemplate.evar_ident(evk$prime, sigma);
    if (match) {
      return match[0];
    } else {
      var match$1 = evi[/* evar_source */4];
      var match$2 = match$1[1];
      var exit = 0;
      if (typeof match$2 === "number") {
        if (match$2 === 1) {
          return Names$ReactTemplate.Id[/* of_string */5]("Goal");
        } else {
          exit = 1;
        }
      } else {
        switch (match$2.tag | 0) {
          case 0 : 
              var match$3 = match$2[1][1];
              if (match$3) {
                return match$3[0];
              } else {
                exit = 1;
              }
              break;
          case 3 : 
              var match$4 = match$2[1];
              if (match$4) {
                return match$4[0];
              } else {
                exit = 1;
              }
              break;
          case 7 : 
              return match$2[0];
          default:
            exit = 1;
        }
      }
      if (exit === 1) {
        var env = Environ$ReactTemplate.reset_with_named_context(evi[/* evar_hyps */1], Global$ReactTemplate.env(/* () */0));
        return Namegen$ReactTemplate.id_of_name_using_hdchar(env, sigma, EConstr$ReactTemplate.of_constr(evi[/* evar_concl */0]), /* Anonymous */0);
      }
      
    }
  };
  var names = Curry._2(Evar$ReactTemplate.$$Map[/* mapi */23], base_id, Evd$ReactTemplate.undefined_map(sigma));
  var id = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk, names);
  var fold = function (evk$prime, id$prime, param) {
    var n = param[1];
    var seen = param[0];
    if (seen) {
      return /* tuple */[
              seen,
              n
            ];
    } else if (Evar$ReactTemplate.equal(evk, evk$prime)) {
      return /* tuple */[
              /* true */1,
              n
            ];
    } else if (Names$ReactTemplate.Id[/* equal */0](id, id$prime)) {
      return /* tuple */[
              seen,
              n + 1 | 0
            ];
    } else {
      return /* tuple */[
              seen,
              n
            ];
    }
  };
  var match = Curry._3(Evar$ReactTemplate.$$Map[/* fold */10], fold, names, /* tuple */[
        /* false */0,
        0
      ]);
  var n = match[1];
  if (n) {
    return Nameops$ReactTemplate.add_suffix(id, Pervasives.string_of_int(n - 1 | 0));
  } else {
    return id;
  }
}

function pr_existential_key(sigma, evk) {
  var match = Evd$ReactTemplate.evar_ident(evk, sigma);
  if (match) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("?"), Names$ReactTemplate.Id[/* print */8](match[0]));
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("?"), Names$ReactTemplate.Id[/* print */8](pr_evar_suggested_name(evk, sigma)));
  }
}

function pr_instance_status(param) {
  var tmp;
  switch (param[0]) {
    case 0 : 
        tmp = Pp$ReactTemplate.str(" [or a supertype of it]");
        break;
    case 1 : 
        tmp = Pp$ReactTemplate.str(" [or a subtype of it]");
        break;
    case 2 : 
        tmp = Pp$ReactTemplate.mt(/* () */0);
        break;
    
  }
  var tmp$1;
  switch (param[1]) {
    case 0 : 
        tmp$1 = Pp$ReactTemplate.str(" [up to coercion]");
        break;
    case 1 : 
        tmp$1 = Pp$ReactTemplate.mt(/* () */0);
        break;
    case 2 : 
        tmp$1 = Pp$ReactTemplate.str(" [type is checked]");
        break;
    
  }
  return Pp$ReactTemplate.$plus$plus(tmp, tmp$1);
}

function protect(f, x) {
  try {
    return Curry._1(f, x);
  }
  catch (raw_e){
    var e = Js_exn.internalToOCamlException(raw_e);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("EXCEPTION: "), Pp$ReactTemplate.str(Printexc.to_string(e)));
  }
}

function print_kconstr(a) {
  return protect((function (c) {
                return print_constr(EConstr$ReactTemplate.of_constr(c));
              }), a);
}

function pr_meta_map(evd) {
  var pr_name = function (param) {
    if (param) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Names$ReactTemplate.Id[/* print */8](param[0])), Pp$ReactTemplate.str("]"));
    } else {
      return Pp$ReactTemplate.mt(/* () */0);
    }
  };
  var pr_meta_binding = function (param) {
    var match = param[1];
    var mv = param[0];
    if (match.tag) {
      var match$1 = match[1];
      return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Nameops$ReactTemplate.pr_meta(mv), pr_name(match[0])), Pp$ReactTemplate.str(" := ")), print_kconstr(match$1[0][/* rebus */0])), Pp$ReactTemplate.str(" : ")), print_kconstr(match[2][/* rebus */0])), Pp$ReactTemplate.spc(/* () */0)), pr_instance_status(match$1[1])), Pp$ReactTemplate.fnl(/* () */0)));
    } else {
      return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Nameops$ReactTemplate.pr_meta(mv), pr_name(match[0])), Pp$ReactTemplate.str(" : ")), print_kconstr(match[1][/* rebus */0])), Pp$ReactTemplate.fnl(/* () */0)));
    }
  };
  return Pp$ReactTemplate.prlist(pr_meta_binding, Evd$ReactTemplate.meta_list(evd));
}

function pr_decl(param) {
  var ok = param[1];
  var decl = param[0];
  if (decl.tag) {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(ok ? "(" : "{"), Names$ReactTemplate.Id[/* print */8](decl[0])), Pp$ReactTemplate.str(":=")), print_kconstr(decl[1])), Pp$ReactTemplate.str(ok ? ")" : "}"));
  } else {
    var id = decl[0];
    if (ok) {
      return Names$ReactTemplate.Id[/* print */8](id);
    } else {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("{"), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.str("}"));
    }
  }
}

function pr_evar_source(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return Pp$ReactTemplate.str("internal placeholder");
      case 1 : 
          return Pp$ReactTemplate.str("goal evar");
      case 2 : 
          return Pp$ReactTemplate.str("type of impossible pattern-matching clause");
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var id = Option$ReactTemplate.get(param[1][1]);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("parameter "), Names$ReactTemplate.Id[/* print */8](id)), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("of")), Pp$ReactTemplate.spc(/* () */0)), print_kconstr(Globnames$ReactTemplate.printable_constr_of_global(param[0])));
      case 1 : 
          var match = param[0];
          if (match) {
            return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("type of "), Names$ReactTemplate.Id[/* print */8](match[0]));
          } else {
            return Pp$ReactTemplate.str("type of anonymous binder");
          }
      case 2 : 
          return Names$ReactTemplate.Id[/* print */8](param[0]);
      case 3 : 
          return Pp$ReactTemplate.str("underscore");
      case 4 : 
          if (param[0] !== 0) {
            return Pp$ReactTemplate.str("subterm of pattern-matching return predicate");
          } else {
            return Pp$ReactTemplate.str("pattern-matching return predicate");
          }
      case 5 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.pr_nth(param[1]), Pp$ReactTemplate.str(" argument of type ")), print_kconstr(Constr$ReactTemplate.mkInd(param[0])));
      case 6 : 
          return Pp$ReactTemplate.str("matching variable");
      case 7 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("instance of "), Names$ReactTemplate.Id[/* print */8](param[0]));
      case 8 : 
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("subterm of "), Evar$ReactTemplate.print(param[0]));
      
    }
  }
}

function pr_evar_info(evi) {
  var phyps;
  try {
    var match = Evd$ReactTemplate.Filter[/* repr */10](Evd$ReactTemplate.evar_filter(evi));
    var decls = match ? Curry._2(Util$ReactTemplate.List[/* combine */37], Evd$ReactTemplate.evar_context(evi), match[0]) : Curry._2(Util$ReactTemplate.List[/* map */10], (function (c) {
              return /* tuple */[
                      c,
                      /* true */1
                    ];
            }), Evd$ReactTemplate.evar_context(evi));
    phyps = Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.spc, pr_decl, Curry._1(Util$ReactTemplate.List[/* rev */4], decls));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      phyps = Pp$ReactTemplate.str("Ill-formed filtered context");
    } else {
      throw exn;
    }
  }
  var pty = print_kconstr(evi[/* evar_concl */0]);
  var match$1 = evi[/* evar_body */2];
  var pb = match$1 ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("=> ")), print_kconstr(match$1[0])) : Pp$ReactTemplate.mt(/* () */0);
  var match$2 = evi[/* evar_body */2];
  var match$3 = evi[/* evar_candidates */5];
  var candidates = match$2 || !match$3 ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.spc(/* () */0), Pp$ReactTemplate.str("{")), Pp$ReactTemplate.prlist_with_sep((function () {
                    return Pp$ReactTemplate.str("|");
                  }), print_kconstr, match$3[0])), Pp$ReactTemplate.str("}"));
  var src = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), pr_evar_source(evi[/* evar_source */4][1])), Pp$ReactTemplate.str(")"));
  return Pp$ReactTemplate.hov(2, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), phyps), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("|- ")), pty), pb), Pp$ReactTemplate.str("]")), candidates), Pp$ReactTemplate.spc(/* () */0)), src));
}

function compute_evar_dependency_graph(sigma) {
  var fold = function (evk, evi, acc) {
    var fold_ev = function (evk$prime, acc) {
      var tab;
      try {
        tab = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk$prime, acc);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          tab = Evar$ReactTemplate.$$Set[/* empty */0];
        } else {
          throw exn;
        }
      }
      return Curry._3(Evar$ReactTemplate.$$Map[/* add */3], evk$prime, Curry._2(Evar$ReactTemplate.$$Set[/* add */3], evk, tab), acc);
    };
    var match = Evd$ReactTemplate.evar_body(evi);
    if (match) {
      return Curry._3(Evar$ReactTemplate.$$Set[/* fold */13], fold_ev, Evd$ReactTemplate.evars_of_term(match[0]), acc);
    } else {
      return acc;
    }
  };
  return Evd$ReactTemplate.fold(fold, sigma, Evar$ReactTemplate.$$Map[/* empty */0]);
}

function evar_dependency_closure(n, sigma) {
  var graph = compute_evar_dependency_graph(sigma);
  var undef = Curry._1(Evar$ReactTemplate.$$Map[/* domain */27], Evd$ReactTemplate.undefined_map(sigma));
  var _n = n;
  var _curr = undef;
  var _accu = Evar$ReactTemplate.$$Set[/* empty */0];
  while(true) {
    var accu = _accu;
    var curr = _curr;
    var n$1 = _n;
    if (n$1) {
      var fold = function (evk, accu) {
        try {
          var deps = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], evk, graph);
          return Curry._2(Evar$ReactTemplate.$$Set[/* union */6], deps, accu);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return accu;
          } else {
            throw exn;
          }
        }
      };
      var ncurr = Curry._3(Evar$ReactTemplate.$$Set[/* fold */13], fold, curr, Evar$ReactTemplate.$$Set[/* empty */0]);
      var accu$1 = Curry._2(Evar$ReactTemplate.$$Set[/* union */6], curr, accu);
      _accu = accu$1;
      _curr = ncurr;
      _n = n$1 - 1 | 0;
      continue ;
      
    } else {
      return Curry._2(Evar$ReactTemplate.$$Set[/* union */6], curr, accu);
    }
  };
}

function evar_dependency_closure$1(n, sigma) {
  var deps = evar_dependency_closure(n, sigma);
  return Curry._1(Evar$ReactTemplate.$$Map[/* bindings */16], Curry._2(Evar$ReactTemplate.$$Map[/* bind */28], (function (ev) {
                    return Evd$ReactTemplate.find(sigma, ev);
                  }), deps));
}

function has_no_evar(sigma) {
  try {
    Evd$ReactTemplate.fold((function (_, _$1, _$2) {
            throw Pervasives.Exit;
          }), sigma, /* () */0);
    return /* true */1;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function pr_evd_level(evd) {
  var partial_arg = Evd$ReactTemplate.evar_universe_context(evd);
  return (function (param) {
      return UState$ReactTemplate.pr_uctx_level(partial_arg, param);
    });
}

function reference_of_level(evd, l) {
  return UState$ReactTemplate.reference_of_level(Evd$ReactTemplate.evar_universe_context(evd))(l);
}

function pr_evar_universe_context(ctx) {
  var prl = function (param) {
    return UState$ReactTemplate.pr_uctx_level(ctx, param);
  };
  if (UState$ReactTemplate.is_empty(ctx)) {
    return Pp$ReactTemplate.mt(/* () */0);
  } else {
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("UNIVERSES:"), Pp$ReactTemplate.brk(/* tuple */[
                                                                            0,
                                                                            1
                                                                          ])), Pp$ReactTemplate.h(0, Univ$ReactTemplate.pr_universe_context_set(prl, UState$ReactTemplate.context_set(ctx)))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("ALGEBRAIC UNIVERSES:")), Pp$ReactTemplate.brk(/* tuple */[
                                                            0,
                                                            1
                                                          ])), Pp$ReactTemplate.h(0, Univ$ReactTemplate.LSet[/* pr */24](prl, UState$ReactTemplate.algebraics(ctx)))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("UNDEFINED UNIVERSES:")), Pp$ReactTemplate.brk(/* tuple */[
                                            0,
                                            1
                                          ])), Pp$ReactTemplate.h(0, Universes$ReactTemplate.pr_universe_opt_subst(UState$ReactTemplate.subst(ctx)))), Pp$ReactTemplate.fnl(/* () */0)), Pp$ReactTemplate.str("WEAK CONSTRAINTS:")), Pp$ReactTemplate.brk(/* tuple */[
                            0,
                            1
                          ])), Pp$ReactTemplate.h(0, UState$ReactTemplate.pr_weak(prl, ctx))), Pp$ReactTemplate.fnl(/* () */0));
  }
}

function print_env_short(env) {
  var pr_rel_decl = function (param) {
    if (param.tag) {
      return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("("), Curry._1(Nameops$ReactTemplate.Name[/* print */7], param[0])), Pp$ReactTemplate.str(" := ")), print_kconstr(param[1])), Pp$ReactTemplate.str(")"));
    } else {
      return Curry._1(Nameops$ReactTemplate.Name[/* print */7], param[0]);
    }
  };
  var partial_arg = Context$ReactTemplate.Named[/* Declaration */0][/* to_rel_decl */19];
  var pr_named_decl = function (param) {
    return Util$ReactTemplate.$percent$great(partial_arg, pr_rel_decl, param);
  };
  var nc = Curry._1(Util$ReactTemplate.List[/* rev */4], Environ$ReactTemplate.named_context(env));
  var rc = Curry._1(Util$ReactTemplate.List[/* rev */4], Environ$ReactTemplate.rel_context(env));
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Pp$ReactTemplate.pr_sequence(pr_named_decl, nc)), Pp$ReactTemplate.str("]")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("[")), Pp$ReactTemplate.pr_sequence(pr_rel_decl, rc)), Pp$ReactTemplate.str("]"));
}

function pr_evar_constraints(sigma, pbs) {
  var pr_evconstr = function (param) {
    var env = Namegen$ReactTemplate.make_all_name_different(param[1], sigma);
    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(print_env_short(env), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str("|-")), Pp$ReactTemplate.spc(/* () */0)), protect((function (param) {
                                      return print_constr_env(env, sigma, param);
                                    }), EConstr$ReactTemplate.of_constr(param[2]))), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(param[0] !== 0 ? "<=" : "==")), Pp$ReactTemplate.spc(/* () */0)), protect((function (param) {
                      return print_constr_env(env, Evd$ReactTemplate.empty, param);
                    }), EConstr$ReactTemplate.of_constr(param[3])));
  };
  return Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, pr_evconstr, pbs);
}

function pr_evar_map_gen(with_univs, pr_evars, sigma) {
  var uvs = Evd$ReactTemplate.evar_universe_context(sigma);
  var match = Evd$ReactTemplate.extract_all_conv_pbs(sigma);
  var conv_pbs = match[1];
  var evs = has_no_evar(sigma) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Curry._1(pr_evars, sigma), Pp$ReactTemplate.fnl(/* () */0));
  var svs = with_univs ? pr_evar_universe_context(uvs) : Pp$ReactTemplate.mt(/* () */0);
  var cstrs = Curry._1(Util$ReactTemplate.List[/* is_empty */45], conv_pbs) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("CONSTRAINTS:"), Pp$ReactTemplate.brk(/* tuple */[
                      0,
                      1
                    ])), pr_evar_constraints(sigma, conv_pbs)), Pp$ReactTemplate.fnl(/* () */0));
  var metas = Curry._1(Util$ReactTemplate.List[/* is_empty */45], Evd$ReactTemplate.meta_list(sigma)) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("METAS:"), Pp$ReactTemplate.brk(/* tuple */[
                  0,
                  1
                ])), pr_meta_map(sigma));
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(evs, svs), cstrs), metas);
}

function pr_evar_list(sigma, l) {
  var pr = function (param) {
    var evi = param[1];
    var ev = param[0];
    return Pp$ReactTemplate.h(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Evar$ReactTemplate.print(ev), Pp$ReactTemplate.str("==")), pr_evar_info(evi)), evi[/* evar_body */2] ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" {"), pr_existential_key(sigma, ev)), Pp$ReactTemplate.str("}"))));
  };
  return Pp$ReactTemplate.h(0, Pp$ReactTemplate.prlist_with_sep(Pp$ReactTemplate.fnl, pr, l));
}

function to_list(d) {
  var l = [/* [] */0];
  var fold_def = function (evk, evi, _) {
    var match = evi[/* evar_body */2];
    if (match) {
      l[0] = /* :: */[
        /* tuple */[
          evk,
          evi
        ],
        l[0]
      ];
      return /* () */0;
    } else {
      return /* () */0;
    }
  };
  var fold_undef = function (evk, evi, _) {
    var match = evi[/* evar_body */2];
    if (match) {
      return /* () */0;
    } else {
      l[0] = /* :: */[
        /* tuple */[
          evk,
          evi
        ],
        l[0]
      ];
      return /* () */0;
    }
  };
  Evd$ReactTemplate.fold(fold_def, d, /* () */0);
  Evd$ReactTemplate.fold(fold_undef, d, /* () */0);
  return l[0];
}

function pr_evar_map($staropt$star, depth, sigma) {
  var with_univs = $staropt$star ? $staropt$star[0] : /* true */1;
  return pr_evar_map_gen(with_univs, (function (sigma) {
                var depth$1 = depth;
                var sigma$1 = sigma;
                if (depth$1) {
                  var n = depth$1[0];
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("UNDEFINED EVARS:"), n ? Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" (+level "), Pp$ReactTemplate.$$int(n)), Pp$ReactTemplate.str(" closure):")) : Pp$ReactTemplate.mt(/* () */0)), Pp$ReactTemplate.brk(/* tuple */[
                                          0,
                                          1
                                        ])), pr_evar_list(sigma$1, evar_dependency_closure$1(n, sigma$1))), Pp$ReactTemplate.fnl(/* () */0));
                } else {
                  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("EVARS:"), Pp$ReactTemplate.brk(/* tuple */[
                                          0,
                                          1
                                        ])), pr_evar_list(sigma$1, to_list(sigma$1))), Pp$ReactTemplate.fnl(/* () */0));
                }
              }), sigma);
}

function pr_evar_map_filter($staropt$star, filter, sigma) {
  var with_univs = $staropt$star ? $staropt$star[0] : /* true */1;
  return pr_evar_map_gen(with_univs, (function (sigma) {
                var filter$1 = filter;
                var sigma$1 = sigma;
                var elts = Evd$ReactTemplate.fold((function (evk, evi, accu) {
                        return /* :: */[
                                /* tuple */[
                                  evk,
                                  evi
                                ],
                                accu
                              ];
                      }), sigma$1, /* [] */0);
                var elts$1 = Curry._1(Util$ReactTemplate.List[/* rev */4], elts);
                var is_def = function (param) {
                  var match = param[1][/* evar_body */2];
                  if (match) {
                    return /* true */1;
                  } else {
                    return /* false */0;
                  }
                };
                var match = Curry._2(Util$ReactTemplate.List[/* partition */29], is_def, elts$1);
                var filter$2 = function (param) {
                  return Curry._2(filter$1, param[0], param[1]);
                };
                var defined = Curry._2(Util$ReactTemplate.List[/* filter */27], filter$2, match[0]);
                var $$undefined = Curry._2(Util$ReactTemplate.List[/* filter */27], filter$2, match[1]);
                var prdef = Curry._1(Util$ReactTemplate.List[/* is_empty */45], defined) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("DEFINED EVARS:"), Pp$ReactTemplate.brk(/* tuple */[
                                0,
                                1
                              ])), pr_evar_list(sigma$1, defined));
                var prundef = Curry._1(Util$ReactTemplate.List[/* is_empty */45], $$undefined) ? Pp$ReactTemplate.mt(/* () */0) : Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("UNDEFINED EVARS:"), Pp$ReactTemplate.brk(/* tuple */[
                                0,
                                1
                              ])), pr_evar_list(sigma$1, $$undefined));
                return Pp$ReactTemplate.$plus$plus(prdef, prundef);
              }), sigma);
}

function pr_metaset(metas) {
  return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("["), Pp$ReactTemplate.pr_sequence(Nameops$ReactTemplate.pr_meta, Curry._1(Evd$ReactTemplate.Metaset[/* elements */19], metas))), Pp$ReactTemplate.str("]"));
}

function pr_var_decl(env, decl) {
  var pbody;
  if (decl.tag) {
    var c = EConstr$ReactTemplate.of_constr(decl[1]);
    var pb = print_constr_env(env, Evd$ReactTemplate.empty, c);
    pbody = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" := "), pb), Pp$ReactTemplate.cut(/* () */0));
  } else {
    pbody = Pp$ReactTemplate.mt(/* () */0);
  }
  var pt = print_constr_env(env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl)));
  var ptyp = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(" : "), pt);
  return Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl)), Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(pbody, ptyp)));
}

function pr_rel_decl(env, decl) {
  var pbody;
  if (decl.tag) {
    var c = EConstr$ReactTemplate.of_constr(decl[1]);
    var pb = print_constr_env(env, Evd$ReactTemplate.empty, c);
    pbody = Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str(":="), Pp$ReactTemplate.spc(/* () */0)), pb), Pp$ReactTemplate.spc(/* () */0));
  } else {
    pbody = Pp$ReactTemplate.mt(/* () */0);
  }
  var ptyp = print_constr_env(env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_type */2], decl)));
  var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
  if (match) {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](match[0]), Pp$ReactTemplate.spc(/* () */0)), pbody), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), ptyp));
  } else {
    return Pp$ReactTemplate.hov(0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("<>"), Pp$ReactTemplate.spc(/* () */0)), pbody), Pp$ReactTemplate.str(":")), Pp$ReactTemplate.spc(/* () */0)), ptyp));
  }
}

function print_named_context(env) {
  return Pp$ReactTemplate.hv(0, Environ$ReactTemplate.fold_named_context((function (env, d, pps) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.ws(2)), pr_var_decl(env, d));
                  }), env, Pp$ReactTemplate.mt(/* () */0)));
}

function print_rel_context(env) {
  return Pp$ReactTemplate.hv(0, Environ$ReactTemplate.fold_rel_context((function (env, d, pps) {
                    return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.ws(2)), pr_rel_decl(env, d));
                  }), env, Pp$ReactTemplate.mt(/* () */0)));
}

function print_env(env) {
  var sign_env = Environ$ReactTemplate.fold_named_context((function (env, d, pps) {
          var pidt = pr_var_decl(env, d);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.fnl(/* () */0)), pidt);
        }), env, Pp$ReactTemplate.mt(/* () */0));
  var db_env = Environ$ReactTemplate.fold_rel_context((function (env, d, pps) {
          var pnat = pr_rel_decl(env, d);
          return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(pps, Pp$ReactTemplate.fnl(/* () */0)), pnat);
        }), env, Pp$ReactTemplate.mt(/* () */0));
  return Pp$ReactTemplate.$plus$plus(sign_env, db_env);
}

function rel_vect(n, m) {
  return Util$ReactTemplate.$$Array[/* init */0](m, (function (i) {
                return Constr$ReactTemplate.mkRel((n + m | 0) - i | 0);
              }));
}

function rel_list(n, m) {
  var _l = /* [] */0;
  var _p = 1;
  while(true) {
    var p = _p;
    var l = _l;
    if (p > m) {
      return l;
    } else {
      _p = p + 1 | 0;
      _l = /* :: */[
        EConstr$ReactTemplate.mkRel(n + p | 0),
        l
      ];
      continue ;
      
    }
  };
}

function push_rel_assum(param, env) {
  return EConstr$ReactTemplate.push_rel(/* LocalAssum */Block.__(0, [
                param[0],
                param[1]
              ]), env);
}

function push_rels_assum(assums) {
  var partial_arg = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return /* LocalAssum */Block.__(0, [
                    param[0],
                    param[1]
                  ]);
        }), assums);
  return (function (param) {
      return Environ$ReactTemplate.push_rel_context(partial_arg, param);
    });
}

function push_named_rec_types(param, env) {
  var ctxt = Util$ReactTemplate.$$Array[/* map2_i */50]((function (i, na, t) {
          if (na) {
            return /* LocalAssum */Block.__(0, [
                      na[0],
                      Vars$ReactTemplate.lift(i)(t)
                    ]);
          } else {
            return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Fix declarations must be named."));
          }
        }), param[0], param[1]);
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (e, assum) {
                return Environ$ReactTemplate.push_named(assum, e);
              }), env, ctxt);
}

function lookup_rel_id(id, sign) {
  var _n = 1;
  var _param = sign;
  while(true) {
    var param = _param;
    var n = _n;
    if (param) {
      var match = param[0];
      if (match.tag) {
        var match$1 = match[0];
        if (match$1) {
          if (Names$ReactTemplate.Id[/* equal */0](match$1[0], id)) {
            return /* tuple */[
                    n,
                    /* Some */[match[1]],
                    match[2]
                  ];
          } else {
            _param = param[1];
            _n = n + 1 | 0;
            continue ;
            
          }
        } else {
          _param = param[1];
          _n = n + 1 | 0;
          continue ;
          
        }
      } else {
        var match$2 = match[0];
        if (match$2) {
          if (Names$ReactTemplate.Id[/* equal */0](match$2[0], id)) {
            return /* tuple */[
                    n,
                    /* None */0,
                    match[1]
                  ];
          } else {
            _param = param[1];
            _n = n + 1 | 0;
            continue ;
            
          }
        } else {
          _param = param[1];
          _n = n + 1 | 0;
          continue ;
          
        }
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function mkProd_wo_LetIn(decl, c) {
  if (decl.tag) {
    return EConstr$ReactTemplate.Vars[/* subst1 */4](decl[1], c);
  } else {
    return EConstr$ReactTemplate.mkProd(/* tuple */[
                decl[0],
                decl[1],
                c
              ]);
  }
}

function it_mkProd(init) {
  return Curry._2(Util$ReactTemplate.List[/* fold_left */13], (function (c, param) {
                return EConstr$ReactTemplate.mkProd(/* tuple */[
                            param[0],
                            param[1],
                            c
                          ]);
              }), init);
}

function it_mkLambda(init) {
  return Curry._2(Util$ReactTemplate.List[/* fold_left */13], (function (c, param) {
                return EConstr$ReactTemplate.mkLambda(/* tuple */[
                            param[0],
                            param[1],
                            c
                          ]);
              }), init);
}

function it_named_context_quantifier(f, init) {
  return Curry._2(Util$ReactTemplate.List[/* fold_left */13], (function (c, d) {
                return Curry._2(f, d, c);
              }), init);
}

function it_mkProd_or_LetIn(init) {
  return it_named_context_quantifier(EConstr$ReactTemplate.mkProd_or_LetIn, init);
}

function it_mkProd_wo_LetIn(init) {
  return it_named_context_quantifier(mkProd_wo_LetIn, init);
}

function it_mkLambda_or_LetIn(init) {
  return it_named_context_quantifier(Term$ReactTemplate.mkLambda_or_LetIn, init);
}

function it_mkNamedProd_or_LetIn(init) {
  return it_named_context_quantifier(EConstr$ReactTemplate.mkNamedProd_or_LetIn, init);
}

function it_mkNamedProd_wo_LetIn(init) {
  return it_named_context_quantifier(Term$ReactTemplate.mkNamedProd_wo_LetIn, init);
}

function it_mkNamedLambda_or_LetIn(init) {
  return it_named_context_quantifier(EConstr$ReactTemplate.mkNamedLambda_or_LetIn, init);
}

function it_mkLambda_or_LetIn_from_no_LetIn(c, decls) {
  var aux = function (k, decls, c) {
    if (decls) {
      var match = decls[0];
      if (match.tag) {
        return Constr$ReactTemplate.mkLetIn(/* tuple */[
                    match[0],
                    match[1],
                    match[2],
                    aux(k - 1 | 0, decls[1], Vars$ReactTemplate.liftn(1, k, c))
                  ]);
      } else {
        return Constr$ReactTemplate.mkLambda(/* tuple */[
                    match[0],
                    match[1],
                    aux(k - 1 | 0, decls[1], c)
                  ]);
      }
    } else {
      return c;
    }
  };
  return aux(Curry._1(Util$ReactTemplate.List[/* length */0], decls), Curry._1(Util$ReactTemplate.List[/* rev */4], decls), c);
}

function strip_head_cast(sigma, _c) {
  while(true) {
    var c = _c;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 9 : 
          var _f = match[0];
          var _cl2 = match[1];
          while(true) {
            var cl2 = _cl2;
            var f = _f;
            var match$1 = EConstr$ReactTemplate.kind(sigma, f);
            switch (match$1.tag | 0) {
              case 5 : 
                  _f = match$1[0];
                  continue ;
                  case 9 : 
                  _cl2 = Util$ReactTemplate.$$Array[/* append */3](match$1[1], cl2);
                  _f = match$1[0];
                  continue ;
                  default:
                if (cl2.length) {
                  return EConstr$ReactTemplate.mkApp(/* tuple */[
                              f,
                              cl2
                            ]);
                } else {
                  return f;
                }
            }
          };
      default:
        return c;
    }
  };
}

function drop_extra_implicit_args(sigma, _c) {
  while(true) {
    var c = _c;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 9) {
      var args = match[1];
      if (EConstr$ReactTemplate.isEvar(sigma, Util$ReactTemplate.$$Array[/* last */34](args))) {
        _c = EConstr$ReactTemplate.mkApp(/* tuple */[
              match[0],
              Util$ReactTemplate.$$Array[/* chop */46](args.length - 1 | 0, args)[0]
            ]);
        continue ;
        
      } else {
        return c;
      }
    } else {
      return c;
    }
  };
}

function last_arg(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 9) {
    return Util$ReactTemplate.$$Array[/* last */34](match[1]);
  } else {
    return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("last_arg."));
  }
}

function decompose_app_vect(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 9) {
    return /* tuple */[
            match[0],
            match[1]
          ];
  } else {
    return /* tuple */[
            c,
            /* array */[]
          ];
  }
}

function adjust_app_list_size(f1, l1, f2, l2) {
  var len1 = Curry._1(Util$ReactTemplate.List[/* length */0], l1);
  var len2 = Curry._1(Util$ReactTemplate.List[/* length */0], l2);
  if (len1 === len2) {
    return /* tuple */[
            f1,
            l1,
            f2,
            l2
          ];
  } else if (len1 < len2) {
    var match = Curry._2(Util$ReactTemplate.List[/* chop */99], len2 - len1 | 0, l2);
    return /* tuple */[
            f1,
            l1,
            EConstr$ReactTemplate.applist(/* tuple */[
                  f2,
                  match[0]
                ]),
            match[1]
          ];
  } else {
    var match$1 = Curry._2(Util$ReactTemplate.List[/* chop */99], len1 - len2 | 0, l1);
    return /* tuple */[
            EConstr$ReactTemplate.applist(/* tuple */[
                  f1,
                  match$1[0]
                ]),
            match$1[1],
            f2,
            l2
          ];
  }
}

function adjust_app_array_size(f1, l1, f2, l2) {
  var len1 = l1.length;
  var len2 = l2.length;
  if (len1 === len2) {
    return /* tuple */[
            f1,
            l1,
            f2,
            l2
          ];
  } else if (len1 < len2) {
    var match = Util$ReactTemplate.$$Array[/* chop */46](len2 - len1 | 0, l2);
    return /* tuple */[
            f1,
            l1,
            EConstr$ReactTemplate.mkApp(/* tuple */[
                  f2,
                  match[0]
                ]),
            match[1]
          ];
  } else {
    var match$1 = Util$ReactTemplate.$$Array[/* chop */46](len1 - len2 | 0, l1);
    return /* tuple */[
            EConstr$ReactTemplate.mkApp(/* tuple */[
                  f1,
                  match$1[0]
                ]),
            match$1[1],
            f2,
            l2
          ];
  }
}

function fold_rec_types(g, param, e) {
  var ctxt = Util$ReactTemplate.$$Array[/* map2_i */50]((function (i, na, t) {
          return /* LocalAssum */Block.__(0, [
                    na,
                    EConstr$ReactTemplate.Vars[/* lift */0](i, t)
                  ]);
        }), param[0], param[1]);
  return Util$ReactTemplate.$$Array[/* fold_left */15]((function (e, assum) {
                return Curry._2(g, assum, e);
              }), e, ctxt);
}

function map_left2(f, a, g, b) {
  var l = a.length;
  if (l) {
    var r = Caml_array.caml_make_vect(l, Curry._1(f, Caml_array.caml_array_get(a, 0)));
    var s = Caml_array.caml_make_vect(l, Curry._1(g, Caml_array.caml_array_get(b, 0)));
    for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      Caml_array.caml_array_set(r, i, Curry._1(f, Caml_array.caml_array_get(a, i)));
      Caml_array.caml_array_set(s, i, Curry._1(g, Caml_array.caml_array_get(b, i)));
    }
    return /* tuple */[
            r,
            s
          ];
  } else {
    return /* tuple */[
            /* array */[],
            /* array */[]
          ];
  }
}

function map_constr_with_binders_left_to_right(sigma, g, f, l, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 3 : 
        var match$1 = match[0];
        var al = match$1[1];
        var al$prime = Util$ReactTemplate.$$Array[/* map_left */52](Curry._1(f, l), al);
        if (Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), al$prime, al)) {
          return c;
        } else {
          return EConstr$ReactTemplate.mkEvar(/* tuple */[
                      match$1[0],
                      al$prime
                    ]);
        }
    case 5 : 
        var t = match[2];
        var b = match[0];
        var b$prime = Curry._2(f, l, b);
        var t$prime = Curry._2(f, l, t);
        if (b$prime === b && t$prime === t) {
          return c;
        } else {
          return EConstr$ReactTemplate.mkCast(/* tuple */[
                      b$prime,
                      match[1],
                      t$prime
                    ]);
        }
    case 6 : 
        var b$1 = match[2];
        var t$1 = match[1];
        var na = match[0];
        var t$prime$1 = Curry._2(f, l, t$1);
        var b$prime$1 = Curry._2(f, Curry._2(g, /* LocalAssum */Block.__(0, [
                    na,
                    t$1
                  ]), l), b$1);
        if (t$prime$1 === t$1 && b$prime$1 === b$1) {
          return c;
        } else {
          return EConstr$ReactTemplate.mkProd(/* tuple */[
                      na,
                      t$prime$1,
                      b$prime$1
                    ]);
        }
    case 7 : 
        var b$2 = match[2];
        var t$2 = match[1];
        var na$1 = match[0];
        var t$prime$2 = Curry._2(f, l, t$2);
        var b$prime$2 = Curry._2(f, Curry._2(g, /* LocalAssum */Block.__(0, [
                    na$1,
                    t$2
                  ]), l), b$2);
        if (t$prime$2 === t$2 && b$prime$2 === b$2) {
          return c;
        } else {
          return EConstr$ReactTemplate.mkLambda(/* tuple */[
                      na$1,
                      t$prime$2,
                      b$prime$2
                    ]);
        }
    case 8 : 
        var b$3 = match[3];
        var t$3 = match[2];
        var bo = match[1];
        var na$2 = match[0];
        var bo$prime = Curry._2(f, l, bo);
        var t$prime$3 = Curry._2(f, l, t$3);
        var b$prime$3 = Curry._2(f, Curry._2(g, /* LocalDef */Block.__(1, [
                    na$2,
                    bo,
                    t$3
                  ]), l), b$3);
        if (bo$prime === bo && t$prime$3 === t$3 && b$prime$3 === b$3) {
          return c;
        } else {
          return EConstr$ReactTemplate.mkLetIn(/* tuple */[
                      na$2,
                      bo$prime,
                      t$prime$3,
                      b$prime$3
                    ]);
        }
    case 9 : 
        var al$1 = match[1];
        if (al$1.length !== 0) {
          var a = Caml_array.caml_array_get(al$1, al$1.length - 1 | 0);
          var app = EConstr$ReactTemplate.mkApp(/* tuple */[
                match[0],
                Util$ReactTemplate.$$Array[/* sub */5](al$1, 0, al$1.length - 1 | 0)
              ]);
          var app$prime = Curry._2(f, l, app);
          var a$prime = Curry._2(f, l, a);
          if (app$prime === app && a$prime === a) {
            return c;
          } else {
            return EConstr$ReactTemplate.mkApp(/* tuple */[
                        app$prime,
                        /* array */[a$prime]
                      ]);
          }
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "termops.ml",
                  671,
                  20
                ]
              ];
        }
        break;
    case 13 : 
        var bl = match[3];
        var b$4 = match[2];
        var p = match[1];
        var b$prime$4 = Curry._2(f, l, b$4);
        var p$prime = Curry._2(f, l, p);
        var bl$prime = Util$ReactTemplate.$$Array[/* map_left */52](Curry._1(f, l), bl);
        if (b$prime$4 === b$4 && p$prime === p && bl$prime === bl) {
          return c;
        } else {
          return EConstr$ReactTemplate.mkCase(/* tuple */[
                      match[0],
                      p$prime,
                      b$prime$4,
                      bl$prime
                    ]);
        }
    case 14 : 
        var match$2 = match[0];
        var fx = match$2[1];
        var bl$1 = fx[2];
        var tl = fx[1];
        var l$prime = fold_rec_types(g, fx, l);
        var match$3 = map_left2(Curry._1(f, l), tl, Curry._1(f, l$prime), bl$1);
        var bl$prime$1 = match$3[1];
        var tl$prime = match$3[0];
        if (Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), tl, tl$prime) && Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), bl$1, bl$prime$1)) {
          return c;
        } else {
          return EConstr$ReactTemplate.mkFix(/* tuple */[
                      match$2[0],
                      /* tuple */[
                        fx[0],
                        tl$prime,
                        bl$prime$1
                      ]
                    ]);
        }
    case 15 : 
        var match$4 = match[0];
        var fx$1 = match$4[1];
        var bl$2 = fx$1[2];
        var tl$1 = fx$1[1];
        var l$prime$1 = fold_rec_types(g, fx$1, l);
        var match$5 = map_left2(Curry._1(f, l), tl$1, Curry._1(f, l$prime$1), bl$2);
        var bl$prime$2 = match$5[1];
        var tl$prime$1 = match$5[0];
        if (Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), tl$1, tl$prime$1) && Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), bl$2, bl$prime$2)) {
          return c;
        } else {
          return EConstr$ReactTemplate.mkCoFix(/* tuple */[
                      match$4[0],
                      /* tuple */[
                        fx$1[0],
                        tl$prime$1,
                        bl$prime$2
                      ]
                    ]);
        }
    case 16 : 
        var b$5 = match[1];
        var b$prime$5 = Curry._2(f, l, b$5);
        if (b$prime$5 === b$5) {
          return c;
        } else {
          return EConstr$ReactTemplate.mkProj(/* tuple */[
                      match[0],
                      b$prime$5
                    ]);
        }
    default:
      return c;
  }
}

function map_constr_with_full_binders(sigma, g, f, l, cstr) {
  var match = EConstr$ReactTemplate.kind(sigma, cstr);
  switch (match.tag | 0) {
    case 3 : 
        var match$1 = match[0];
        var al = match$1[1];
        var al$prime = Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, l), al);
        if (Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), al, al$prime)) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkEvar(/* tuple */[
                      match$1[0],
                      al$prime
                    ]);
        }
    case 5 : 
        var t = match[2];
        var c = match[0];
        var c$prime = Curry._2(f, l, c);
        var t$prime = Curry._2(f, l, t);
        if (c === c$prime && t === t$prime) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkCast(/* tuple */[
                      c$prime,
                      match[1],
                      t$prime
                    ]);
        }
    case 6 : 
        var c$1 = match[2];
        var t$1 = match[1];
        var na = match[0];
        var t$prime$1 = Curry._2(f, l, t$1);
        var c$prime$1 = Curry._2(f, Curry._2(g, /* LocalAssum */Block.__(0, [
                    na,
                    t$1
                  ]), l), c$1);
        if (t$1 === t$prime$1 && c$1 === c$prime$1) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkProd(/* tuple */[
                      na,
                      t$prime$1,
                      c$prime$1
                    ]);
        }
    case 7 : 
        var c$2 = match[2];
        var t$2 = match[1];
        var na$1 = match[0];
        var t$prime$2 = Curry._2(f, l, t$2);
        var c$prime$2 = Curry._2(f, Curry._2(g, /* LocalAssum */Block.__(0, [
                    na$1,
                    t$2
                  ]), l), c$2);
        if (t$2 === t$prime$2 && c$2 === c$prime$2) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkLambda(/* tuple */[
                      na$1,
                      t$prime$2,
                      c$prime$2
                    ]);
        }
    case 8 : 
        var c$3 = match[3];
        var t$3 = match[2];
        var b = match[1];
        var na$2 = match[0];
        var b$prime = Curry._2(f, l, b);
        var t$prime$3 = Curry._2(f, l, t$3);
        var c$prime$3 = Curry._2(f, Curry._2(g, /* LocalDef */Block.__(1, [
                    na$2,
                    b,
                    t$3
                  ]), l), c$3);
        if (b === b$prime && t$3 === t$prime$3 && c$3 === c$prime$3) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkLetIn(/* tuple */[
                      na$2,
                      b$prime,
                      t$prime$3,
                      c$prime$3
                    ]);
        }
    case 9 : 
        var al$1 = match[1];
        var c$4 = match[0];
        var c$prime$4 = Curry._2(f, l, c$4);
        var al$prime$1 = Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, l), al$1);
        if (c$4 === c$prime$4 && Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), al$1, al$prime$1)) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkApp(/* tuple */[
                      c$prime$4,
                      al$prime$1
                    ]);
        }
    case 13 : 
        var bl = match[3];
        var c$5 = match[2];
        var p = match[1];
        var p$prime = Curry._2(f, l, p);
        var c$prime$5 = Curry._2(f, l, c$5);
        var bl$prime = Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, l), bl);
        if (p === p$prime && c$5 === c$prime$5 && Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), bl, bl$prime)) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkCase(/* tuple */[
                      match[0],
                      p$prime,
                      c$prime$5,
                      bl$prime
                    ]);
        }
    case 14 : 
        var match$2 = match[0];
        var match$3 = match$2[1];
        var bl$1 = match$3[2];
        var tl = match$3[1];
        var lna = match$3[0];
        var tl$prime = Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, l), tl);
        var l$prime = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (l, na, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              na,
                              t
                            ]), l);
              }), l, lna, tl);
        var bl$prime$1 = Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, l$prime), bl$1);
        if (Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), tl, tl$prime) && Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), bl$1, bl$prime$1)) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkFix(/* tuple */[
                      match$2[0],
                      /* tuple */[
                        lna,
                        tl$prime,
                        bl$prime$1
                      ]
                    ]);
        }
    case 15 : 
        var match$4 = match[0];
        var match$5 = match$4[1];
        var bl$2 = match$5[2];
        var tl$1 = match$5[1];
        var lna$1 = match$5[0];
        var tl$prime$1 = Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, l), tl$1);
        var l$prime$1 = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (l, na, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              na,
                              t
                            ]), l);
              }), l, lna$1, tl$1);
        var bl$prime$2 = Util$ReactTemplate.$$Array[/* map */12](Curry._1(f, l$prime$1), bl$2);
        if (Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), tl$1, tl$prime$1) && Util$ReactTemplate.$$Array[/* for_all2 */27]((function (prim, prim$1) {
                  return +(prim === prim$1);
                }), bl$2, bl$prime$2)) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkCoFix(/* tuple */[
                      match$4[0],
                      /* tuple */[
                        lna$1,
                        tl$prime$1,
                        bl$prime$2
                      ]
                    ]);
        }
    case 16 : 
        var c$6 = match[1];
        var c$prime$6 = Curry._2(f, l, c$6);
        if (c$prime$6 === c$6) {
          return cstr;
        } else {
          return EConstr$ReactTemplate.mkProj(/* tuple */[
                      match[0],
                      c$prime$6
                    ]);
        }
    default:
      return cstr;
  }
}

function fold_constr_with_full_binders(sigma, g, f, n, acc, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  var exit = 0;
  switch (match.tag | 0) {
    case 3 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](Curry._1(f, n), acc, match[0][1]);
    case 5 : 
        return Curry._3(f, n, Curry._3(f, n, acc, match[0]), match[2]);
    case 6 : 
    case 7 : 
        exit = 1;
        break;
    case 8 : 
        var t = match[2];
        var b = match[1];
        return Curry._3(f, Curry._2(g, /* LocalDef */Block.__(1, [
                          match[0],
                          EConstr$ReactTemplate.Unsafe[/* to_constr */0](b),
                          EConstr$ReactTemplate.Unsafe[/* to_constr */0](t)
                        ]), n), Curry._3(f, n, Curry._3(f, n, acc, b), t), match[3]);
    case 9 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](Curry._1(f, n), Curry._3(f, n, acc, match[0]), match[1]);
    case 13 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](Curry._1(f, n), Curry._3(f, n, Curry._3(f, n, acc, match[1]), match[2]), match[3]);
    case 14 : 
        var match$1 = match[0][1];
        var tl = match$1[1];
        var n$prime = CArray$ReactTemplate.fold_left2((function (c, n, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              n,
                              EConstr$ReactTemplate.Unsafe[/* to_constr */0](t)
                            ]), c);
              }), n, match$1[0], tl);
        var fd = Util$ReactTemplate.$$Array[/* map2 */49]((function (t, b) {
                return /* tuple */[
                        t,
                        b
                      ];
              }), tl, match$1[2]);
        return Util$ReactTemplate.$$Array[/* fold_left */15]((function (acc, param) {
                      return Curry._3(f, n$prime, Curry._3(f, n, acc, param[0]), param[1]);
                    }), acc, fd);
    case 15 : 
        var match$2 = match[0][1];
        var tl$1 = match$2[1];
        var n$prime$1 = CArray$ReactTemplate.fold_left2((function (c, n, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              n,
                              EConstr$ReactTemplate.Unsafe[/* to_constr */0](t)
                            ]), c);
              }), n, match$2[0], tl$1);
        var fd$1 = Util$ReactTemplate.$$Array[/* map2 */49]((function (t, b) {
                return /* tuple */[
                        t,
                        b
                      ];
              }), tl$1, match$2[2]);
        return Util$ReactTemplate.$$Array[/* fold_left */15]((function (acc, param) {
                      return Curry._3(f, n$prime$1, Curry._3(f, n, acc, param[0]), param[1]);
                    }), acc, fd$1);
    case 16 : 
        return Curry._3(f, n, acc, match[1]);
    default:
      return acc;
  }
  if (exit === 1) {
    var t$1 = match[1];
    return Curry._3(f, Curry._2(g, /* LocalAssum */Block.__(0, [
                      match[0],
                      EConstr$ReactTemplate.Unsafe[/* to_constr */0](t$1)
                    ]), n), Curry._3(f, n, acc, t$1), match[2]);
  }
  
}

function fold_constr_with_binders(sigma, g, f, n, acc, c) {
  return fold_constr_with_full_binders(sigma, (function (_, x) {
                return Curry._1(g, x);
              }), f, n, acc, c);
}

function iter_constr_with_full_binders(sigma, g, f, l, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  var exit = 0;
  switch (match.tag | 0) {
    case 3 : 
        return Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, l), match[0][1]);
    case 5 : 
        Curry._2(f, l, match[0]);
        return Curry._2(f, l, match[2]);
    case 6 : 
    case 7 : 
        exit = 1;
        break;
    case 8 : 
        var t = match[2];
        var b = match[1];
        Curry._2(f, l, b);
        Curry._2(f, l, t);
        return Curry._2(f, Curry._2(g, /* LocalDef */Block.__(1, [
                          match[0],
                          b,
                          t
                        ]), l), match[3]);
    case 9 : 
        Curry._2(f, l, match[0]);
        return Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, l), match[1]);
    case 13 : 
        Curry._2(f, l, match[1]);
        Curry._2(f, l, match[2]);
        return Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, l), match[3]);
    case 14 : 
        var match$1 = match[0][1];
        var tl = match$1[1];
        var l$prime = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (l, na, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              na,
                              t
                            ]), l);
              }), l, match$1[0], tl);
        Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, l), tl);
        return Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, l$prime), match$1[2]);
    case 15 : 
        var match$2 = match[0][1];
        var tl$1 = match$2[1];
        var l$prime$1 = Util$ReactTemplate.$$Array[/* fold_left2 */40]((function (l, na, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              na,
                              t
                            ]), l);
              }), l, match$2[0], tl$1);
        Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, l), tl$1);
        return Util$ReactTemplate.$$Array[/* iter */11](Curry._1(f, l$prime$1), match$2[2]);
    case 16 : 
        return Curry._2(f, l, match[1]);
    default:
      return /* () */0;
  }
  if (exit === 1) {
    var t$1 = match[1];
    Curry._2(f, l, t$1);
    return Curry._2(f, Curry._2(g, /* LocalAssum */Block.__(0, [
                      match[0],
                      t$1
                    ]), l), match[2]);
  }
  
}

var Occur = Caml_exceptions.create("Termops-ReactTemplate.Occur");

function occur_meta(sigma, c) {
  var occrec = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 2) {
      throw Occur;
    } else {
      return EConstr$ReactTemplate.iter(sigma, occrec, c);
    }
  };
  try {
    occrec(c);
    return /* false */0;
  }
  catch (exn){
    if (exn === Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function occur_existential(sigma, c) {
  var occrec = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 3) {
      throw Occur;
    } else {
      return EConstr$ReactTemplate.iter(sigma, occrec, c);
    }
  };
  try {
    occrec(c);
    return /* false */0;
  }
  catch (exn){
    if (exn === Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function occur_meta_or_existential(sigma, c) {
  var occrec = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 2 : 
      case 3 : 
          throw Occur;
      default:
        return EConstr$ReactTemplate.iter(sigma, occrec, c);
    }
  };
  try {
    occrec(c);
    return /* false */0;
  }
  catch (exn){
    if (exn === Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function occur_evar(sigma, n, c) {
  var occur_rec = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 3) {
      if (Evar$ReactTemplate.equal(match[0][0], n)) {
        throw Occur;
      } else {
        return EConstr$ReactTemplate.iter(sigma, occur_rec, c);
      }
    } else {
      return EConstr$ReactTemplate.iter(sigma, occur_rec, c);
    }
  };
  try {
    occur_rec(c);
    return /* false */0;
  }
  catch (exn){
    if (exn === Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function occur_var(env, sigma, id, c) {
  var occur_rec = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    var exit = 0;
    switch (match.tag | 0) {
      case 1 : 
      case 10 : 
      case 11 : 
      case 12 : 
          exit = 1;
          break;
      default:
        return EConstr$ReactTemplate.iter(sigma, occur_rec, c);
    }
    if (exit === 1) {
      var env$1 = env;
      var id$1 = id;
      var constr = EConstr$ReactTemplate.to_constr(sigma, c);
      var vars = Environ$ReactTemplate.vars_of_global(env$1, constr);
      if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], id$1, vars)) {
        throw Occur;
      } else {
        return 0;
      }
    }
    
  };
  try {
    occur_rec(c);
    return /* false */0;
  }
  catch (exn){
    if (exn === Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function occur_var_in_decl(env, sigma, hyp, decl) {
  if (!decl.tag || !occur_var(env, sigma, hyp, decl[2])) {
    return occur_var(env, sigma, hyp, decl[1]);
  } else {
    return /* true */1;
  }
}

function local_occur_var(sigma, id, c) {
  var occur = function (c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 1) {
      if (Names$ReactTemplate.Id[/* equal */0](id, match[0])) {
        throw Occur;
      } else {
        return 0;
      }
    } else {
      return EConstr$ReactTemplate.iter(sigma, occur, c);
    }
  };
  try {
    occur(c);
    return /* false */0;
  }
  catch (exn){
    if (exn === Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function free_rels(sigma, m) {
  var frec = function (depth, acc, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag) {
      return fold_constr_with_binders(sigma, (function (prim) {
                    return prim + 1 | 0;
                  }), frec, depth, acc, c);
    } else {
      var n = match[0];
      if (n >= depth) {
        return Curry._2(Int$ReactTemplate.$$Set[/* add */3], (n - depth | 0) + 1 | 0, acc);
      } else {
        return acc;
      }
    }
  };
  return frec(1, Int$ReactTemplate.$$Set[/* empty */0], m);
}

function collect_metas(sigma, c) {
  var collrec = function (acc, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 2) {
      return Curry._3(Util$ReactTemplate.List[/* add_set */48], (function (prim, prim$1) {
                    return +(prim === prim$1);
                  }), match[0], acc);
    } else {
      return EConstr$ReactTemplate.fold(sigma, collrec, acc, c);
    }
  };
  return Curry._1(Util$ReactTemplate.List[/* rev */4], collrec(/* [] */0, c));
}

function collect_vars(sigma, c) {
  var aux = function (vars, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 1) {
      return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], match[0], vars);
    } else {
      return EConstr$ReactTemplate.fold(sigma, aux, vars, c);
    }
  };
  return aux(Names$ReactTemplate.Id[/* Set */9][/* empty */0], c);
}

function vars_of_global_reference(env, gr) {
  var match = Global$ReactTemplate.constr_of_global_in_context(env, gr);
  return Environ$ReactTemplate.vars_of_global(Global$ReactTemplate.env(/* () */0), match[0]);
}

function dependent_main(noevar, sigma, m, t) {
  var deprec = function (m, t) {
    if (EConstr$ReactTemplate.eq_constr_nounivs(sigma, m, t)) {
      throw Occur;
    } else {
      var match = EConstr$ReactTemplate.kind(sigma, m);
      var match$1 = EConstr$ReactTemplate.kind(sigma, t);
      var exit = 0;
      var exit$1 = 0;
      if (match.tag === 9) {
        var lm = match[1];
        switch (match$1.tag | 0) {
          case 3 : 
          case 5 : 
              exit$1 = 2;
              break;
          case 9 : 
              var lt = match$1[1];
              if (lm.length < lt.length) {
                deprec(m, EConstr$ReactTemplate.mkApp(/* tuple */[
                          match$1[0],
                          Util$ReactTemplate.$$Array[/* sub */5](lt, 0, lm.length)
                        ]));
                return CArray$ReactTemplate.Fun1[/* iter */2](deprec, m, Util$ReactTemplate.$$Array[/* sub */5](lt, lm.length, lt.length - lm.length | 0));
              } else {
                exit = 1;
              }
              break;
          default:
            exit = 1;
        }
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        switch (match$1.tag | 0) {
          case 3 : 
              if (noevar) {
                return /* () */0;
              } else {
                exit = 1;
              }
              break;
          case 5 : 
              if (noevar && EConstr$ReactTemplate.isMeta(sigma, match$1[0])) {
                return /* () */0;
              } else {
                exit = 1;
              }
              break;
          default:
            exit = 1;
        }
      }
      if (exit === 1) {
        return EConstr$ReactTemplate.iter_with_binders(sigma, (function (c) {
                      return EConstr$ReactTemplate.Vars[/* lift */0](1, c);
                    }), deprec, m, t);
      }
      
    }
  };
  try {
    deprec(m, t);
    return /* false */0;
  }
  catch (exn){
    if (exn === Occur) {
      return /* true */1;
    } else {
      throw exn;
    }
  }
}

function dependent(sigma, c, t) {
  return dependent_main(/* false */0, sigma, c, t);
}

function dependent_no_evar(sigma, c, t) {
  return dependent_main(/* true */1, sigma, c, t);
}

function dependent_in_decl(sigma, a, decl) {
  if (decl.tag) {
    if (dependent(sigma, a, decl[1])) {
      return /* true */1;
    } else {
      return dependent(sigma, a, decl[2]);
    }
  } else {
    return dependent(sigma, a, decl[1]);
  }
}

function count_occurrences(sigma, m, t) {
  var n = [0];
  var countrec = function (m, t) {
    if (EConstr$ReactTemplate.eq_constr(sigma, m, t)) {
      n[0] = n[0] + 1 | 0;
      return /* () */0;
    } else {
      var match = EConstr$ReactTemplate.kind(sigma, m);
      var match$1 = EConstr$ReactTemplate.kind(sigma, t);
      var exit = 0;
      var exit$1 = 0;
      if (match.tag === 9) {
        var lm = match[1];
        switch (match$1.tag | 0) {
          case 3 : 
          case 5 : 
              exit$1 = 2;
              break;
          case 9 : 
              var lt = match$1[1];
              if (lm.length < lt.length) {
                countrec(m, EConstr$ReactTemplate.mkApp(/* tuple */[
                          match$1[0],
                          Util$ReactTemplate.$$Array[/* sub */5](lt, 0, lm.length)
                        ]));
                return Util$ReactTemplate.$$Array[/* iter */11]((function (param) {
                              return countrec(m, param);
                            }), Util$ReactTemplate.$$Array[/* sub */5](lt, lm.length, lt.length - lm.length | 0));
              } else {
                exit = 1;
              }
              break;
          default:
            exit = 1;
        }
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        switch (match$1.tag | 0) {
          case 3 : 
              return /* () */0;
          case 5 : 
              if (EConstr$ReactTemplate.isMeta(sigma, match$1[0])) {
                return /* () */0;
              } else {
                exit = 1;
              }
              break;
          default:
            exit = 1;
        }
      }
      if (exit === 1) {
        var partial_arg = EConstr$ReactTemplate.Vars[/* lift */0];
        return EConstr$ReactTemplate.iter_with_binders(sigma, (function (param) {
                      return partial_arg(1, param);
                    }), countrec, m, t);
      }
      
    }
  };
  countrec(m, t);
  return n[0];
}

function pop(t) {
  return EConstr$ReactTemplate.Vars[/* lift */0](-1, t);
}

function isMetaOf(sigma, mv, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 2) {
    return +(mv === match[0]);
  } else {
    return /* false */0;
  }
}

function subst_meta(bl, c) {
  var match = Constr$ReactTemplate.kind(c);
  if (match.tag === 2) {
    try {
      return Curry._2(Int$ReactTemplate.List[/* assoc */1], match[0], bl);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return c;
      } else {
        throw exn;
      }
    }
  } else {
    return Constr$ReactTemplate.map((function (param) {
                  return subst_meta(bl, param);
                }), c);
  }
}

function strip_outer_cast(sigma, _c) {
  while(true) {
    var c = _c;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    if (match.tag === 5) {
      _c = match[0];
      continue ;
      
    } else {
      return c;
    }
  };
}

function collapse_appl(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 9) {
    var f = match[0];
    if (EConstr$ReactTemplate.isCast(sigma, f)) {
      var _f = f;
      var _cl2 = match[1];
      while(true) {
        var cl2 = _cl2;
        var f$1 = _f;
        var match$1 = EConstr$ReactTemplate.kind(sigma, strip_outer_cast(sigma, f$1));
        if (match$1.tag === 9) {
          _cl2 = Util$ReactTemplate.$$Array[/* append */3](match$1[1], cl2);
          _f = match$1[0];
          continue ;
          
        } else {
          return EConstr$ReactTemplate.mkApp(/* tuple */[
                      f$1,
                      cl2
                    ]);
        }
      };
    } else {
      return c;
    }
  } else {
    return c;
  }
}

function prefix_application(sigma, eq_fun, param, t) {
  var c$prime = collapse_appl(sigma, param[1]);
  var t$prime = collapse_appl(sigma, t);
  var match = EConstr$ReactTemplate.kind(sigma, c$prime);
  var match$1 = EConstr$ReactTemplate.kind(sigma, t$prime);
  if (match.tag === 9) {
    if (match$1.tag === 9) {
      var cl2 = match$1[1];
      var l1 = match[1].length;
      var l2 = cl2.length;
      if (l1 <= l2 && Curry._3(eq_fun, sigma, c$prime, EConstr$ReactTemplate.mkApp(/* tuple */[
                  match$1[0],
                  Util$ReactTemplate.$$Array[/* sub */5](cl2, 0, l1)
                ]))) {
        return /* Some */[EConstr$ReactTemplate.mkApp(/* tuple */[
                      EConstr$ReactTemplate.mkRel(param[0]),
                      Util$ReactTemplate.$$Array[/* sub */5](cl2, l1, l2 - l1 | 0)
                    ])];
      } else {
        return /* None */0;
      }
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function my_prefix_application(sigma, eq_fun, param, by_c, t) {
  var c$prime = collapse_appl(sigma, param[1]);
  var t$prime = collapse_appl(sigma, t);
  var match = EConstr$ReactTemplate.kind(sigma, c$prime);
  var match$1 = EConstr$ReactTemplate.kind(sigma, t$prime);
  if (match.tag === 9) {
    if (match$1.tag === 9) {
      var cl2 = match$1[1];
      var l1 = match[1].length;
      var l2 = cl2.length;
      if (l1 <= l2 && Curry._3(eq_fun, sigma, c$prime, EConstr$ReactTemplate.mkApp(/* tuple */[
                  match$1[0],
                  Util$ReactTemplate.$$Array[/* sub */5](cl2, 0, l1)
                ]))) {
        return /* Some */[EConstr$ReactTemplate.mkApp(/* tuple */[
                      EConstr$ReactTemplate.Vars[/* lift */0](param[0], by_c),
                      Util$ReactTemplate.$$Array[/* sub */5](cl2, l1, l2 - l1 | 0)
                    ])];
      } else {
        return /* None */0;
      }
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function subst_term_gen(sigma, eq_fun, c, t) {
  var substrec = function (kc, t) {
    var match = prefix_application(sigma, eq_fun, kc, t);
    if (match) {
      return match[0];
    } else if (Curry._3(eq_fun, sigma, kc[1], t)) {
      return EConstr$ReactTemplate.mkRel(kc[0]);
    } else {
      return EConstr$ReactTemplate.map_with_binders(sigma, (function (param) {
                    return /* tuple */[
                            param[0] + 1 | 0,
                            EConstr$ReactTemplate.Vars[/* lift */0](1, param[1])
                          ];
                  }), substrec, kc, t);
    }
  };
  return substrec(/* tuple */[
              1,
              c
            ], t);
}

function subst_term(sigma, c, t) {
  return subst_term_gen(sigma, EConstr$ReactTemplate.eq_constr, c, t);
}

function replace_term_gen(sigma, eq_fun, c, by_c, in_t) {
  var substrec = function (kc, t) {
    var match = my_prefix_application(sigma, eq_fun, kc, by_c, t);
    if (match) {
      return match[0];
    } else if (Curry._3(eq_fun, sigma, kc[1], t)) {
      return EConstr$ReactTemplate.Vars[/* lift */0](kc[0], by_c);
    } else {
      return EConstr$ReactTemplate.map_with_binders(sigma, (function (param) {
                    return /* tuple */[
                            param[0] + 1 | 0,
                            EConstr$ReactTemplate.Vars[/* lift */0](1, param[1])
                          ];
                  }), substrec, kc, t);
    }
  };
  return substrec(/* tuple */[
              0,
              c
            ], in_t);
}

function replace_term(sigma, c, byc, t) {
  return replace_term_gen(sigma, EConstr$ReactTemplate.eq_constr, c, byc, t);
}

function vars_of_env(env) {
  var s = Environ$ReactTemplate.ids_of_named_context_val(Environ$ReactTemplate.named_context_val(env));
  if (Curry._1(Util$ReactTemplate.List[/* is_empty */45], Environ$ReactTemplate.rel_context(env))) {
    return s;
  } else {
    return Context$ReactTemplate.Rel[/* fold_outside */10]((function (decl, s) {
                  var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
                  if (match) {
                    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], match[0], s);
                  } else {
                    return s;
                  }
                }), Environ$ReactTemplate.rel_context(env), s);
  }
}

function add_vname(vars, param) {
  if (param) {
    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* add */3], param[0], vars);
  } else {
    return vars;
  }
}

function add_name(n, nl) {
  return /* :: */[
          n,
          nl
        ];
}

function lookup_name_of_rel(p, names) {
  try {
    return Curry._2(Util$ReactTemplate.List[/* nth */3], names, p - 1 | 0);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      throw Caml_builtin_exceptions.not_found;
    } else if (exn[0] === Caml_builtin_exceptions.failure) {
      throw Caml_builtin_exceptions.not_found;
    } else {
      throw exn;
    }
  }
}

function lookup_rel_of_name(id, names) {
  var _n = 1;
  var _param = names;
  while(true) {
    var param = _param;
    var n = _n;
    if (param) {
      var match = param[0];
      if (match) {
        if (Names$ReactTemplate.Id[/* equal */0](match[0], id)) {
          return n;
        } else {
          _param = param[1];
          _n = n + 1 | 0;
          continue ;
          
        }
      } else {
        _param = param[1];
        _n = n + 1 | 0;
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function ids_of_rel_context(sign) {
  return Context$ReactTemplate.Rel[/* fold_outside */10]((function (decl, l) {
                var match = Curry._1(Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], decl);
                if (match) {
                  return /* :: */[
                          match[0],
                          l
                        ];
                } else {
                  return l;
                }
              }), sign, /* [] */0);
}

function ids_of_named_context(sign) {
  return Context$ReactTemplate.Named[/* fold_outside */9]((function (decl, idl) {
                return /* :: */[
                        Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], decl),
                        idl
                      ];
              }), sign, /* [] */0);
}

function ids_of_context(env) {
  return Util$ReactTemplate.$at(ids_of_rel_context(Environ$ReactTemplate.rel_context(env)), ids_of_named_context(Environ$ReactTemplate.named_context(env)));
}

function names_of_rel_context(env) {
  return Curry._2(Util$ReactTemplate.List[/* map */10], Context$ReactTemplate.Rel[/* Declaration */0][/* get_name */0], Environ$ReactTemplate.rel_context(env));
}

function is_section_variable(id) {
  try {
    Global$ReactTemplate.lookup_named(id);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function global_of_constr(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 1 : 
        return /* tuple */[
                /* VarRef */Block.__(0, [match[0]]),
                EConstr$ReactTemplate.EInstance[/* empty */2]
              ];
    case 10 : 
        var match$1 = match[0];
        return /* tuple */[
                /* ConstRef */Block.__(1, [match$1[0]]),
                match$1[1]
              ];
    case 11 : 
        var match$2 = match[0];
        return /* tuple */[
                /* IndRef */Block.__(2, [match$2[0]]),
                match$2[1]
              ];
    case 12 : 
        var match$3 = match[0];
        return /* tuple */[
                /* ConstructRef */Block.__(3, [match$3[0]]),
                match$3[1]
              ];
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function is_global(sigma, c, t) {
  var match = EConstr$ReactTemplate.kind(sigma, t);
  switch (c.tag | 0) {
    case 0 : 
        if (match.tag === 1) {
          return Names$ReactTemplate.Id[/* equal */0](c[0], match[0]);
        } else {
          return /* false */0;
        }
        break;
    case 1 : 
        if (match.tag === 10) {
          return Names$ReactTemplate.Constant[/* equal */12](c[0], match[0][0]);
        } else {
          return /* false */0;
        }
        break;
    case 2 : 
        if (match.tag === 11) {
          return Names$ReactTemplate.eq_ind(c[0], match[0][0]);
        } else {
          return /* false */0;
        }
        break;
    case 3 : 
        if (match.tag === 12) {
          return Names$ReactTemplate.eq_constructor(c[0], match[0][0]);
        } else {
          return /* false */0;
        }
        break;
    
  }
}

function isGlobalRef(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 1 : 
    case 10 : 
    case 11 : 
    case 12 : 
        return /* true */1;
    default:
      return /* false */0;
  }
}

function is_template_polymorphic(env, sigma, f) {
  var match = EConstr$ReactTemplate.kind(sigma, f);
  if (match.tag === 11) {
    var match$1 = match[0];
    if (Curry._1(EConstr$ReactTemplate.EInstance[/* is_empty */3], match$1[1])) {
      return Environ$ReactTemplate.template_polymorphic_ind(match$1[0], env);
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function base_sort_cmp(pb, s0, s1) {
  if (s0.tag) {
    if (s1.tag) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (s1.tag) {
    return +(pb === /* CUMUL */1);
  } else if (s0[0] === /* Null */1) {
    return /* true */1;
  } else {
    return +(s1[0] === /* Pos */0);
  }
}

function is_Prop(sigma, _c) {
  while(true) {
    var c = _c;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 4 : 
          var match$1 = EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]);
          if (!match$1.tag && match$1[0] !== 0) {
            return /* true */1;
          } else {
            return /* false */0;
          }
          break;
      case 5 : 
          _c = match[0];
          continue ;
          default:
        return /* false */0;
    }
  };
}

function is_Set(sigma, _c) {
  while(true) {
    var c = _c;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 4 : 
          var match$1 = EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]);
          if (!match$1.tag && match$1[0] === 0) {
            return /* true */1;
          } else {
            return /* false */0;
          }
          break;
      case 5 : 
          _c = match[0];
          continue ;
          default:
        return /* false */0;
    }
  };
}

function is_Type(sigma, _c) {
  while(true) {
    var c = _c;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 4 : 
          var match$1 = EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]);
          if (match$1.tag) {
            return /* true */1;
          } else {
            return /* false */0;
          }
          break;
      case 5 : 
          _c = match[0];
          continue ;
          default:
        return /* false */0;
    }
  };
}

function compare_constr_univ(sigma, f, cv_pb, t1, t2) {
  var match = EConstr$ReactTemplate.kind(sigma, t1);
  var match$1 = EConstr$ReactTemplate.kind(sigma, t2);
  var exit = 0;
  switch (match.tag | 0) {
    case 4 : 
        if (match$1.tag === 4) {
          return base_sort_cmp(cv_pb, EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match[0]), EConstr$ReactTemplate.ESorts[/* kind */1](sigma, match$1[0]));
        } else {
          exit = 1;
        }
        break;
    case 6 : 
        if (match$1.tag === 6) {
          if (Curry._3(f, /* CONV */0, match[1], match$1[1])) {
            return Curry._3(f, cv_pb, match[2], match$1[2]);
          } else {
            return /* false */0;
          }
        } else {
          exit = 1;
        }
        break;
    case 10 : 
        if (match$1.tag === 10) {
          return Names$ReactTemplate.Constant[/* equal */12](match[0][0], match$1[0][0]);
        } else {
          exit = 1;
        }
        break;
    case 11 : 
        if (match$1.tag === 11) {
          return Names$ReactTemplate.eq_ind(match[0][0], match$1[0][0]);
        } else {
          exit = 1;
        }
        break;
    case 12 : 
        if (match$1.tag === 12) {
          return Names$ReactTemplate.eq_constructor(match[0][0], match$1[0][0]);
        } else {
          exit = 1;
        }
        break;
    default:
      exit = 1;
  }
  if (exit === 1) {
    return EConstr$ReactTemplate.compare_constr(sigma, (function (t1, t2) {
                  return Curry._3(f, /* CONV */0, t1, t2);
                }), t1, t2);
  }
  
}

function constr_cmp(sigma, cv_pb, t1, t2) {
  var compare = function (cv_pb, t1, t2) {
    return compare_constr_univ(sigma, compare, cv_pb, t1, t2);
  };
  return compare(cv_pb, t1, t2);
}

function eq_constr(sigma, t1, t2) {
  return constr_cmp(sigma, /* CONV */0, t1, t2);
}

function split_app(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 9) {
    var l = match[1];
    var c$1 = match[0];
    var len = l.length;
    if (len) {
      var last = Caml_array.caml_array_get(l, len - 1 | 0);
      var prev = Util$ReactTemplate.$$Array[/* sub */5](l, 0, len - 1 | 0);
      return /* tuple */[
              /* :: */[
                c$1,
                Util$ReactTemplate.$$Array[/* to_list */9](prev)
              ],
              last
            ];
    } else {
      return /* tuple */[
              /* [] */0,
              c$1
            ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "termops.ml",
            1211,
            9
          ]
        ];
  }
}

var CannotFilter = Caml_exceptions.create("Termops-ReactTemplate.CannotFilter");

function filtering(sigma, env, cv_pb, c1, c2) {
  var evm = [Evar$ReactTemplate.$$Map[/* empty */0]];
  var define = function (cv_pb, e1, ev, c1) {
    try {
      var match = Curry._2(Evar$ReactTemplate.$$Map[/* find */21], ev, evm[0]);
      var shift = Curry._1(Util$ReactTemplate.List[/* length */0], e1) - Curry._1(Util$ReactTemplate.List[/* length */0], match[0]) | 0;
      if (constr_cmp(sigma, cv_pb, c1, EConstr$ReactTemplate.Vars[/* lift */0](shift, match[1]))) {
        return /* () */0;
      } else {
        throw CannotFilter;
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        evm[0] = Curry._3(Evar$ReactTemplate.$$Map[/* add */3], ev, /* tuple */[
              e1,
              c1
            ], evm[0]);
        return /* () */0;
      } else {
        throw exn;
      }
    }
  };
  var aux = function (_env, cv_pb, _c1, _c2) {
    while(true) {
      var c2 = _c2;
      var c1 = _c1;
      var env = _env;
      var match = EConstr$ReactTemplate.kind(sigma, c1);
      var match$1 = EConstr$ReactTemplate.kind(sigma, c2);
      var exit = 0;
      var exit$1 = 0;
      switch (match.tag | 0) {
        case 6 : 
            var t1 = match[1];
            switch (match$1.tag | 0) {
              case 3 : 
                  exit$1 = 2;
                  break;
              case 6 : 
                  aux(env, cv_pb, t1, match$1[1]);
                  _c2 = match$1[2];
                  _c1 = match[2];
                  _env = /* :: */[
                    /* LocalAssum */Block.__(0, [
                        match[0],
                        t1
                      ]),
                    env
                  ];
                  continue ;
                  default:
                exit = 1;
            }
            break;
        case 9 : 
            switch (match$1.tag | 0) {
              case 3 : 
                  exit$1 = 2;
                  break;
              case 9 : 
                  var match_000 = split_app(sigma, c1);
                  var match_001 = split_app(sigma, c2);
                  var match$2 = match_001;
                  var p2 = match$2[0];
                  var match$3 = match_000;
                  var p1 = match$3[0];
                  aux(env, cv_pb, match$3[1], match$2[1]);
                  if (p1) {
                    if (p2) {
                      _c2 = EConstr$ReactTemplate.applist(/* tuple */[
                            p2[0],
                            p2[1]
                          ]);
                      _c1 = EConstr$ReactTemplate.applist(/* tuple */[
                            p1[0],
                            p1[1]
                          ]);
                      continue ;
                      
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "termops.ml",
                              1237,
                              15
                            ]
                          ];
                    }
                  } else if (p2) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "termops.ml",
                            1237,
                            15
                          ]
                        ];
                  } else {
                    return /* () */0;
                  }
                  break;
              default:
                exit = 1;
            }
            break;
        default:
          exit$1 = 2;
      }
      if (exit$1 === 2) {
        if (match$1.tag === 3) {
          return define(cv_pb, env, match$1[0][0], c1);
        } else if (match.tag === 3) {
          return define(cv_pb, env, match[0][0], c2);
        } else {
          exit = 1;
        }
      }
      if (exit === 1) {
        if (compare_constr_univ(sigma, (function(env){
              return function (pb, c1, c2) {
                aux(env, pb, c1, c2);
                return /* true */1;
              }
              }(env)), cv_pb, c1, c2)) {
          return /* () */0;
        } else {
          throw CannotFilter;
        }
      }
      
    };
  };
  aux(env, cv_pb, c1, c2);
  return evm[0];
}

function decompose_prod_letin(sigma, c) {
  var _i = 0;
  var _l = /* [] */0;
  var _c = c;
  while(true) {
    var c$1 = _c;
    var l = _l;
    var i = _i;
    var match = EConstr$ReactTemplate.kind(sigma, c$1);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          _l = /* :: */[
            /* LocalAssum */Block.__(0, [
                match[0],
                match[1]
              ]),
            l
          ];
          _i = i + 1 | 0;
          continue ;
          case 8 : 
          _c = match[3];
          _l = /* :: */[
            /* LocalDef */Block.__(1, [
                match[0],
                match[1],
                match[2]
              ]),
            l
          ];
          _i = i + 1 | 0;
          continue ;
          default:
        return /* tuple */[
                i,
                l,
                c$1
              ];
    }
  };
}

function nb_lam(sigma, c) {
  var _n = 0;
  var _c = c;
  while(true) {
    var c$1 = _c;
    var n = _n;
    var match = EConstr$ReactTemplate.kind(sigma, c$1);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 7 : 
          _c = match[2];
          _n = n + 1 | 0;
          continue ;
          default:
        return n;
    }
  };
}

function nb_prod(sigma, c) {
  var _n = 0;
  var _c = c;
  while(true) {
    var c$1 = _c;
    var n = _n;
    var match = EConstr$ReactTemplate.kind(sigma, c$1);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          _n = n + 1 | 0;
          continue ;
          default:
        return n;
    }
  };
}

function nb_prod_modulo_zeta(sigma, x) {
  var _n = 0;
  var _c = x;
  while(true) {
    var c = _c;
    var n = _n;
    var match = EConstr$ReactTemplate.kind(sigma, c);
    switch (match.tag | 0) {
      case 5 : 
          _c = match[0];
          continue ;
          case 6 : 
          _c = match[2];
          _n = n + 1 | 0;
          continue ;
          case 8 : 
          _c = EConstr$ReactTemplate.Vars[/* subst1 */4](match[1], match[3]);
          continue ;
          default:
        return n;
    }
  };
}

function align_prod_letin(sigma, c, a) {
  var match = decompose_prod_letin(sigma, c);
  var lc = match[0];
  var match$1 = decompose_prod_letin(sigma, a);
  if (match$1[0] < lc) {
    CErrors$ReactTemplate.invalid_arg(/* None */0, "align_prod_letin");
  }
  var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], lc, match$1[1]);
  return /* tuple */[
          match$2[1],
          Curry._1(it_mkProd_or_LetIn(match$1[2]), match$2[0])
        ];
}

function eta_reduce_head(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  if (match.tag === 7) {
    var match$1 = EConstr$ReactTemplate.kind(sigma, eta_reduce_head(sigma, match[2]));
    if (match$1.tag === 9) {
      var cl = match$1[1];
      var f = match$1[0];
      var lastn = cl.length - 1 | 0;
      if (lastn < 0) {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("application without arguments."));
      } else {
        var match$2 = EConstr$ReactTemplate.kind(sigma, Caml_array.caml_array_get(cl, lastn));
        if (match$2.tag) {
          return c;
        } else if (match$2[0] !== 1) {
          return c;
        } else {
          var c$prime = lastn ? EConstr$ReactTemplate.mkApp(/* tuple */[
                  f,
                  Util$ReactTemplate.$$Array[/* sub */5](cl, 0, lastn)
                ]) : f;
          if (EConstr$ReactTemplate.Vars[/* noccurn */12](sigma, 1, c$prime)) {
            return EConstr$ReactTemplate.Vars[/* lift */0](-1, c$prime);
          } else {
            return c;
          }
        }
      }
    } else {
      return c;
    }
  } else {
    return c;
  }
}

function process_rel_context(f, env) {
  var sign = Environ$ReactTemplate.named_context_val(env);
  var rels = EConstr$ReactTemplate.rel_context(env);
  var env0 = Environ$ReactTemplate.reset_with_named_context(sign, env);
  return Context$ReactTemplate.Rel[/* fold_outside */10](f, rels, env0);
}

function assums_of_rel_context(sign) {
  return Context$ReactTemplate.Rel[/* fold_outside */10]((function (decl, l) {
                if (decl.tag) {
                  return l;
                } else {
                  return /* :: */[
                          /* tuple */[
                            decl[0],
                            decl[1]
                          ],
                          l
                        ];
                }
              }), sign, /* [] */0);
}

function map_rel_context_in_env(f, env, sign) {
  var _env = env;
  var _acc = /* [] */0;
  var _param = Curry._1(Util$ReactTemplate.List[/* rev */4], sign);
  while(true) {
    var param = _param;
    var acc = _acc;
    var env$1 = _env;
    if (param) {
      var d = param[0];
      _param = param[1];
      _acc = /* :: */[
        Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], Curry._1(f, env$1), d),
        acc
      ];
      _env = Environ$ReactTemplate.push_rel(d, env$1);
      continue ;
      
    } else {
      return acc;
    }
  };
}

function map_rel_context_with_binders(f, sign) {
  var aux = function (k, param) {
    if (param) {
      return /* :: */[
              Curry._2(Context$ReactTemplate.Rel[/* Declaration */0][/* map_constr */13], Curry._1(f, k), param[0]),
              aux(k - 1 | 0, param[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  return aux(Curry._1(Context$ReactTemplate.Rel[/* length */3], sign), sign);
}

function substl_rel_context(l) {
  return (function (param) {
      return map_rel_context_with_binders((function (k) {
                    var partial_arg = k - 1 | 0;
                    return (function (param) {
                        return Vars$ReactTemplate.substnl(l, partial_arg, param);
                      });
                  }), param);
    });
}

function lift_rel_context(n) {
  return (function (param) {
      return map_rel_context_with_binders((function (param, param$1) {
                    return Vars$ReactTemplate.liftn(n, param, param$1);
                  }), param);
    });
}

function smash_rel_context(sign) {
  var aux = function (_acc, _param) {
    while(true) {
      var param = _param;
      var acc = _acc;
      if (param) {
        var d = param[0];
        _param = param[1];
        if (d.tag) {
          _acc = Curry._1(Util$ReactTemplate.List[/* rev */4], substl_rel_context(/* :: */[
                      d[1],
                      /* [] */0
                    ])(Curry._1(Util$ReactTemplate.List[/* rev */4], acc)));
          continue ;
          
        } else {
          _acc = /* :: */[
            d,
            acc
          ];
          continue ;
          
        }
      } else {
        return acc;
      }
    };
  };
  return Curry._1(Util$ReactTemplate.List[/* rev */4], aux(/* [] */0, sign));
}

function fold_named_context_both_sides(f, l, init) {
  return Curry._3(Util$ReactTemplate.List[/* fold_right_and_left */83], f, l, init);
}

function mem_named_context_val(id, ctxt) {
  try {
    Environ$ReactTemplate.lookup_named_val(id, ctxt);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function map_rel_decl(f, param) {
  if (param.tag) {
    return /* LocalDef */Block.__(1, [
              param[0],
              Curry._1(f, param[1]),
              Curry._1(f, param[2])
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              param[0],
              Curry._1(f, param[1])
            ]);
  }
}

function map_named_decl(f, param) {
  if (param.tag) {
    return /* LocalDef */Block.__(1, [
              param[0],
              Curry._1(f, param[1]),
              Curry._1(f, param[2])
            ]);
  } else {
    return /* LocalAssum */Block.__(0, [
              param[0],
              Curry._1(f, param[1])
            ]);
  }
}

function compact_named_context(sign) {
  var compact = function (l, decl) {
    if (decl.tag) {
      var t = decl[2];
      var c = decl[1];
      var i = decl[0];
      if (l) {
        var match = l[0];
        if (match.tag) {
          var q = l[1];
          var t2 = match[2];
          var c2 = match[1];
          var li = match[0];
          if (Constr$ReactTemplate.equal(c, c2) && Constr$ReactTemplate.equal(t, t2)) {
            return /* :: */[
                    /* LocalDef */Block.__(1, [
                        /* :: */[
                          i,
                          li
                        ],
                        c2,
                        t2
                      ]),
                    q
                  ];
          } else {
            return /* :: */[
                    /* LocalDef */Block.__(1, [
                        /* :: */[
                          i,
                          /* [] */0
                        ],
                        c,
                        t
                      ]),
                    /* :: */[
                      /* LocalDef */Block.__(1, [
                          li,
                          c2,
                          t2
                        ]),
                      q
                    ]
                  ];
          }
        } else {
          return /* :: */[
                  /* LocalDef */Block.__(1, [
                      /* :: */[
                        i,
                        /* [] */0
                      ],
                      c,
                      t
                    ]),
                  l
                ];
        }
      } else {
        return /* :: */[
                /* LocalDef */Block.__(1, [
                    /* :: */[
                      i,
                      /* [] */0
                    ],
                    c,
                    t
                  ]),
                /* [] */0
              ];
      }
    } else {
      var t$1 = decl[1];
      var i$1 = decl[0];
      if (l) {
        var match$1 = l[0];
        if (match$1.tag) {
          return /* :: */[
                  /* LocalAssum */Block.__(0, [
                      /* :: */[
                        i$1,
                        /* [] */0
                      ],
                      t$1
                    ]),
                  l
                ];
        } else {
          var q$1 = l[1];
          var t2$1 = match$1[1];
          var li$1 = match$1[0];
          if (Constr$ReactTemplate.equal(t$1, t2$1)) {
            return /* :: */[
                    /* LocalAssum */Block.__(0, [
                        /* :: */[
                          i$1,
                          li$1
                        ],
                        t2$1
                      ]),
                    q$1
                  ];
          } else {
            return /* :: */[
                    /* LocalAssum */Block.__(0, [
                        /* :: */[
                          i$1,
                          /* [] */0
                        ],
                        t$1
                      ]),
                    /* :: */[
                      /* LocalAssum */Block.__(0, [
                          li$1,
                          t2$1
                        ]),
                      q$1
                    ]
                  ];
          }
        }
      } else {
        return /* :: */[
                /* LocalAssum */Block.__(0, [
                    /* :: */[
                      i$1,
                      /* [] */0
                    ],
                    t$1
                  ]),
                /* [] */0
              ];
      }
    }
  };
  return Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._1(Context$ReactTemplate.Named[/* fold_inside */8](compact, /* [] */0), sign));
}

function clear_named_body(id, env) {
  var aux = function (_, d) {
    if (d.tag) {
      if (Names$ReactTemplate.Id[/* equal */0](id, d[0])) {
        var partial_arg_001 = d[2];
        var partial_arg = /* LocalAssum */Block.__(0, [
            id,
            partial_arg_001
          ]);
        return (function (param) {
            return Environ$ReactTemplate.push_named(partial_arg, param);
          });
      } else {
        return (function (param) {
            return Environ$ReactTemplate.push_named(d, param);
          });
      }
    } else {
      return (function (param) {
          return Environ$ReactTemplate.push_named(d, param);
        });
    }
  };
  return Environ$ReactTemplate.fold_named_context(aux, env, Environ$ReactTemplate.reset_context(env));
}

function global_vars_set(env, sigma, constr) {
  var filtrec = function (acc, c) {
    var match = EConstr$ReactTemplate.kind(sigma, c);
    var acc$1;
    var exit = 0;
    switch (match.tag | 0) {
      case 1 : 
      case 10 : 
      case 11 : 
      case 12 : 
          exit = 1;
          break;
      default:
        acc$1 = acc;
    }
    if (exit === 1) {
      acc$1 = Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], Environ$ReactTemplate.vars_of_global(env, EConstr$ReactTemplate.to_constr(sigma, c)), acc);
    }
    return EConstr$ReactTemplate.fold(sigma, filtrec, acc$1, c);
  };
  return filtrec(Names$ReactTemplate.Id[/* Set */9][/* empty */0], constr);
}

function global_vars(env, sigma, ids) {
  return Curry._1(Names$ReactTemplate.Id[/* Set */9][/* elements */19], global_vars_set(env, sigma, ids));
}

function global_vars_set_of_decl(env, sigma, param) {
  if (param.tag) {
    return Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], global_vars_set(env, sigma, param[2]), global_vars_set(env, sigma, param[1]));
  } else {
    return global_vars_set(env, sigma, param[1]);
  }
}

function dependency_closure(env, sigma, sign, hyps) {
  if (Curry._1(Names$ReactTemplate.Id[/* Set */9][/* is_empty */1], hyps)) {
    return /* [] */0;
  } else {
    var match = Curry._1(Context$ReactTemplate.Named[/* fold_inside */8]((function (param, d) {
                var hl = param[1];
                var hs = param[0];
                var x = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_id */0], d);
                if (Curry._2(Names$ReactTemplate.Id[/* Set */9][/* mem */2], x, hs)) {
                  return /* tuple */[
                          Curry._2(Names$ReactTemplate.Id[/* Set */9][/* union */6], global_vars_set_of_decl(env, sigma, d), Curry._2(Names$ReactTemplate.Id[/* Set */9][/* remove */5], x, hs)),
                          /* :: */[
                            x,
                            hl
                          ]
                        ];
                } else {
                  return /* tuple */[
                          hs,
                          hl
                        ];
                }
              }), /* tuple */[
              hyps,
              /* [] */0
            ]), sign);
    return Curry._1(Util$ReactTemplate.List[/* rev */4], match[1]);
  }
}

function global_app_of_constr(sigma, c) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 1 : 
        return /* tuple */[
                /* tuple */[
                  /* VarRef */Block.__(0, [match[0]]),
                  EConstr$ReactTemplate.EInstance[/* empty */2]
                ],
                /* None */0
              ];
    case 10 : 
        var match$1 = match[0];
        return /* tuple */[
                /* tuple */[
                  /* ConstRef */Block.__(1, [match$1[0]]),
                  match$1[1]
                ],
                /* None */0
              ];
    case 11 : 
        var match$2 = match[0];
        return /* tuple */[
                /* tuple */[
                  /* IndRef */Block.__(2, [match$2[0]]),
                  match$2[1]
                ],
                /* None */0
              ];
    case 12 : 
        var match$3 = match[0];
        return /* tuple */[
                /* tuple */[
                  /* ConstructRef */Block.__(3, [match$3[0]]),
                  match$3[1]
                ],
                /* None */0
              ];
    case 16 : 
        return /* tuple */[
                /* tuple */[
                  /* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](match[0])]),
                  EConstr$ReactTemplate.EInstance[/* empty */2]
                ],
                /* Some */[match[1]]
              ];
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function prod_applist(sigma, c, l) {
  var _subst = /* [] */0;
  var _c = c;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var c$1 = _c;
    var subst = _subst;
    var match = EConstr$ReactTemplate.kind(sigma, c$1);
    var exit = 0;
    if (match.tag === 6) {
      if (l$1) {
        _l = l$1[1];
        _c = match[2];
        _subst = /* :: */[
          l$1[0],
          subst
        ];
        continue ;
        
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (l$1) {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough prod's."));
      } else {
        return EConstr$ReactTemplate.Vars[/* substl */3](subst, c$1);
      }
    }
    
  };
}

function prod_applist_assum(sigma, n, c, l) {
  var _n = n;
  var _subst = /* [] */0;
  var _c = c;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var c$1 = _c;
    var subst = _subst;
    var n$1 = _n;
    if (n$1) {
      var match = EConstr$ReactTemplate.kind(sigma, c$1);
      switch (match.tag | 0) {
        case 6 : 
            if (l$1) {
              _l = l$1[1];
              _c = match[2];
              _subst = /* :: */[
                l$1[0],
                subst
              ];
              _n = n$1 - 1 | 0;
              continue ;
              
            } else {
              return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough prod/let's."));
            }
            break;
        case 8 : 
            _c = match[3];
            _subst = /* :: */[
              EConstr$ReactTemplate.Vars[/* substl */3](subst, match[1]),
              subst
            ];
            _n = n$1 - 1 | 0;
            continue ;
            default:
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough prod/let's."));
      }
    } else if (l$1) {
      return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("Not enough arguments."));
    } else {
      return EConstr$ReactTemplate.Vars[/* substl */3](subst, c$1);
    }
  };
}

function on_judgment(f, j) {
  return /* record */[
          /* uj_val */Curry._1(f, j[/* uj_val */0]),
          /* uj_type */Curry._1(f, j[/* uj_type */1])
        ];
}

function on_judgment_value(f, j) {
  return /* record */[
          /* uj_val */Curry._1(f, j[/* uj_val */0]),
          /* uj_type */j[/* uj_type */1]
        ];
}

function on_judgment_type(f, j) {
  return /* record */[
          /* uj_val */j[/* uj_val */0],
          /* uj_type */Curry._1(f, j[/* uj_type */1])
        ];
}

function context_chop(k, ctx) {
  var _acc = /* [] */0;
  var _param = /* tuple */[
    k,
    ctx
  ];
  while(true) {
    var param = _param;
    var acc = _acc;
    var n = param[0];
    if (n !== 0) {
      var match = param[1];
      if (match) {
        var h = match[0];
        if (h.tag) {
          _param = /* tuple */[
            n,
            match[1]
          ];
          _acc = /* :: */[
            h,
            acc
          ];
          continue ;
          
        } else {
          _param = /* tuple */[
            n - 1 | 0,
            match[1]
          ];
          _acc = /* :: */[
            h,
            acc
          ];
          continue ;
          
        }
      } else {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.str("context_chop."));
      }
    } else {
      return /* tuple */[
              Curry._1(Util$ReactTemplate.List[/* rev */4], acc),
              param[1]
            ];
    }
  };
}

function env_rel_context_chop(k, env) {
  var rels = EConstr$ReactTemplate.rel_context(env);
  var match = Curry._2(Util$ReactTemplate.List[/* chop */99], k, rels);
  return /* tuple */[
          EConstr$ReactTemplate.push_rel_context(match[1], Environ$ReactTemplate.reset_with_named_context(Environ$ReactTemplate.named_context_val(env), env)),
          match[0]
        ];
}

var mkProd_or_LetIn = EConstr$ReactTemplate.mkProd_or_LetIn;

var occur_term = dependent;

var empty_names_context = /* [] */0;

exports.print_sort = print_sort;
exports.pr_sort_family = pr_sort_family;
exports.pr_fix = pr_fix;
exports.push_rel_assum = push_rel_assum;
exports.push_rels_assum = push_rels_assum;
exports.push_named_rec_types = push_named_rec_types;
exports.lookup_rel_id = lookup_rel_id;
exports.rel_vect = rel_vect;
exports.rel_list = rel_list;
exports.mkProd_or_LetIn = mkProd_or_LetIn;
exports.mkProd_wo_LetIn = mkProd_wo_LetIn;
exports.it_mkProd = it_mkProd;
exports.it_mkLambda = it_mkLambda;
exports.it_mkProd_or_LetIn = it_mkProd_or_LetIn;
exports.it_mkProd_wo_LetIn = it_mkProd_wo_LetIn;
exports.it_mkLambda_or_LetIn = it_mkLambda_or_LetIn;
exports.it_mkNamedProd_or_LetIn = it_mkNamedProd_or_LetIn;
exports.it_mkNamedProd_wo_LetIn = it_mkNamedProd_wo_LetIn;
exports.it_mkNamedLambda_or_LetIn = it_mkNamedLambda_or_LetIn;
exports.it_mkLambda_or_LetIn_from_no_LetIn = it_mkLambda_or_LetIn_from_no_LetIn;
exports.map_constr_with_binders_left_to_right = map_constr_with_binders_left_to_right;
exports.map_constr_with_full_binders = map_constr_with_full_binders;
exports.fold_constr_with_binders = fold_constr_with_binders;
exports.fold_constr_with_full_binders = fold_constr_with_full_binders;
exports.iter_constr_with_full_binders = iter_constr_with_full_binders;
exports.strip_head_cast = strip_head_cast;
exports.drop_extra_implicit_args = drop_extra_implicit_args;
exports.Occur = Occur;
exports.occur_meta = occur_meta;
exports.occur_existential = occur_existential;
exports.occur_meta_or_existential = occur_meta_or_existential;
exports.occur_evar = occur_evar;
exports.occur_var = occur_var;
exports.occur_var_in_decl = occur_var_in_decl;
exports.local_occur_var = local_occur_var;
exports.free_rels = free_rels;
exports.dependent = dependent;
exports.dependent_no_evar = dependent_no_evar;
exports.dependent_in_decl = dependent_in_decl;
exports.count_occurrences = count_occurrences;
exports.collect_metas = collect_metas;
exports.collect_vars = collect_vars;
exports.vars_of_global_reference = vars_of_global_reference;
exports.occur_term = occur_term;
exports.subst_meta = subst_meta;
exports.isMetaOf = isMetaOf;
exports.pop = pop;
exports.subst_term_gen = subst_term_gen;
exports.replace_term_gen = replace_term_gen;
exports.subst_term = subst_term;
exports.replace_term = replace_term;
exports.base_sort_cmp = base_sort_cmp;
exports.compare_constr_univ = compare_constr_univ;
exports.constr_cmp = constr_cmp;
exports.eq_constr = eq_constr;
exports.eta_reduce_head = eta_reduce_head;
exports.collapse_appl = collapse_appl;
exports.prod_applist = prod_applist;
exports.prod_applist_assum = prod_applist_assum;
exports.strip_outer_cast = strip_outer_cast;
exports.CannotFilter = CannotFilter;
exports.filtering = filtering;
exports.decompose_prod_letin = decompose_prod_letin;
exports.align_prod_letin = align_prod_letin;
exports.nb_lam = nb_lam;
exports.nb_prod = nb_prod;
exports.nb_prod_modulo_zeta = nb_prod_modulo_zeta;
exports.last_arg = last_arg;
exports.decompose_app_vect = decompose_app_vect;
exports.adjust_app_list_size = adjust_app_list_size;
exports.adjust_app_array_size = adjust_app_array_size;
exports.add_name = add_name;
exports.lookup_name_of_rel = lookup_name_of_rel;
exports.lookup_rel_of_name = lookup_rel_of_name;
exports.empty_names_context = empty_names_context;
exports.ids_of_rel_context = ids_of_rel_context;
exports.ids_of_named_context = ids_of_named_context;
exports.ids_of_context = ids_of_context;
exports.names_of_rel_context = names_of_rel_context;
exports.context_chop = context_chop;
exports.env_rel_context_chop = env_rel_context_chop;
exports.vars_of_env = vars_of_env;
exports.add_vname = add_vname;
exports.process_rel_context = process_rel_context;
exports.assums_of_rel_context = assums_of_rel_context;
exports.lift_rel_context = lift_rel_context;
exports.substl_rel_context = substl_rel_context;
exports.smash_rel_context = smash_rel_context;
exports.map_rel_context_in_env = map_rel_context_in_env;
exports.map_rel_context_with_binders = map_rel_context_with_binders;
exports.fold_named_context_both_sides = fold_named_context_both_sides;
exports.mem_named_context_val = mem_named_context_val;
exports.compact_named_context = compact_named_context;
exports.map_rel_decl = map_rel_decl;
exports.map_named_decl = map_named_decl;
exports.clear_named_body = clear_named_body;
exports.global_vars = global_vars;
exports.global_vars_set = global_vars_set;
exports.global_vars_set_of_decl = global_vars_set_of_decl;
exports.global_app_of_constr = global_app_of_constr;
exports.dependency_closure = dependency_closure;
exports.is_section_variable = is_section_variable;
exports.global_of_constr = global_of_constr;
exports.is_global = is_global;
exports.isGlobalRef = isGlobalRef;
exports.is_template_polymorphic = is_template_polymorphic;
exports.is_Prop = is_Prop;
exports.is_Set = is_Set;
exports.is_Type = is_Type;
exports.reference_of_level = reference_of_level;
exports.on_judgment = on_judgment;
exports.on_judgment_value = on_judgment_value;
exports.on_judgment_type = on_judgment_type;
exports.pr_existential_key = pr_existential_key;
exports.pr_evar_suggested_name = pr_evar_suggested_name;
exports.pr_evar_info = pr_evar_info;
exports.pr_evar_constraints = pr_evar_constraints;
exports.pr_evar_map = pr_evar_map;
exports.pr_evar_map_filter = pr_evar_map_filter;
exports.pr_metaset = pr_metaset;
exports.pr_evar_universe_context = pr_evar_universe_context;
exports.pr_evd_level = pr_evd_level;
exports.set_print_constr = set_print_constr;
exports.print_constr = print_constr;
exports.print_constr_env = print_constr_env;
exports.print_named_context = print_named_context;
exports.pr_rel_decl = pr_rel_decl;
exports.print_rel_context = print_rel_context;
exports.print_env = print_env;
/* Pp-ReactTemplate Not a pure module */
