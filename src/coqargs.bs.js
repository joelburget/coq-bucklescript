// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Filename = require("bs-platform/lib/js/filename.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Stm$ReactTemplate = require("./stm.bs.js");
var Str$ReactTemplate = require("../shims/str.bs.js");
var Flags$ReactTemplate = require("./flags.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var Topfmt$ReactTemplate = require("../vernac/topfmt.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var CString$ReactTemplate = require("./cString.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Namegen$ReactTemplate = require("./namegen.bs.js");
var Printer$ReactTemplate = require("./printer.bs.js");
var Spawned$ReactTemplate = require("../shims/spawned.bs.js");
var Feedback$ReactTemplate = require("./feedback.bs.js");
var G_vernac$ReactTemplate = require("../parsing/g_vernac.bs.js");
var Indtypes$ReactTemplate = require("./indtypes.bs.js");
var Libnames$ReactTemplate = require("./libnames.bs.js");
var Backtrace$ReactTemplate = require("./backtrace.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var WorkerLoop$ReactTemplate = require("./workerLoop.bs.js");
var CoqworkmgrApi$ReactTemplate = require("./coqworkmgrApi.bs.js");

function error_missing_arg(s) {
  console.error("Error: extra argument expected after option " + s);
  console.error("See -help for the syntax of supported options");
  return Pervasives.exit(1);
}

function set_worker_id(_, s) {
  if (s === "master") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "coqargs.ml",
            27,
            2
          ]
        ];
  }
  Flags$ReactTemplate.async_proofs_worker_id[0] = s;
  return /* () */0;
}

function set_type_in_type() {
  var typing_flags = Environ$ReactTemplate.typing_flags(Global$ReactTemplate.env(/* () */0));
  return Global$ReactTemplate.set_typing_flags(/* record */[
              /* check_guarded */typing_flags[/* check_guarded */0],
              /* check_universes : false */0,
              /* conv_oracle */typing_flags[/* conv_oracle */2]
            ]);
}

var init_args_008 = /* toplevel_name */Names$ReactTemplate.DirPath[/* make */3](/* :: */[
      Names$ReactTemplate.Id[/* of_string */5]("Top"),
      /* [] */0
    ]);

var init_args_019 = /* stm_flags */Stm$ReactTemplate.AsyncOpts[/* default_opts */0];

var init_args = /* record */[
  /* load_init : true */1,
  /* load_rcfile : true */1,
  /* rcfile : None */0,
  /* ml_includes : [] */0,
  /* vo_includes : [] */0,
  /* vo_requires : [] */0,
  /* batch_mode : false */0,
  /* compilation_mode : BuildVo */0,
  init_args_008,
  /* toploop : None */0,
  /* compile_list : [] */0,
  /* compilation_output_name : None */0,
  /* load_vernacular_list : [] */0,
  /* vio_checking : false */0,
  /* vio_tasks : [] */0,
  /* vio_files : [] */0,
  /* vio_files_j */0,
  /* color : AUTO */725067631,
  /* impredicative_set : PredicativeSet */1,
  init_args_019,
  /* debug : false */0,
  /* time : false */0,
  /* filter_opts : false */0,
  /* glob_opt : false */0,
  /* memory_stat : false */0,
  /* print_tags : false */0,
  /* print_where : false */0,
  /* print_config : false */0,
  /* output_context : false */0,
  /* inputstate : None */0,
  /* outputstate : None */0
];

function add_ml_include(opts, s) {
  var newrecord = opts.slice();
  newrecord[/* ml_includes */3] = /* :: */[
    s,
    opts[/* ml_includes */3]
  ];
  return newrecord;
}

function add_vo_include(opts, d, p, implicit) {
  var p$1 = Libnames$ReactTemplate.dirpath_of_string(p);
  var newrecord = opts.slice();
  newrecord[/* vo_includes */4] = /* :: */[
    /* tuple */[
      d,
      p$1,
      implicit
    ],
    opts[/* vo_includes */4]
  ];
  return newrecord;
}

function add_vo_require(opts, d, p, $$export) {
  var newrecord = opts.slice();
  newrecord[/* vo_requires */5] = /* :: */[
    /* tuple */[
      d,
      p,
      $$export
    ],
    opts[/* vo_requires */5]
  ];
  return newrecord;
}

function add_compat_require(opts, v) {
  switch (v) {
    case 0 : 
        return add_vo_require(opts, "Coq.Compat.Coq86", /* None */0, /* Some */[/* false */0]);
    case 1 : 
        return add_vo_require(opts, "Coq.Compat.Coq87", /* None */0, /* Some */[/* false */0]);
    case 2 : 
        return opts;
    
  }
}

function set_batch_mode(opts) {
  Flags$ReactTemplate.quiet[0] = /* true */1;
  var newrecord = opts.slice();
  newrecord[/* batch_mode */6] = /* true */1;
  return newrecord;
}

function add_compile(opts, verbose, s) {
  var opts$1 = set_batch_mode(opts);
  var s$1 = Curry._1(Filename.is_implicit, s) ? Filename.concat(Filename.current_dir_name, s) : s;
  var newrecord = opts$1.slice();
  newrecord[/* compile_list */10] = /* :: */[
    /* tuple */[
      s$1,
      verbose
    ],
    opts$1[/* compile_list */10]
  ];
  return newrecord;
}

function add_vio_task(opts, f) {
  var opts$1 = set_batch_mode(opts);
  var newrecord = opts$1.slice();
  newrecord[/* vio_tasks */14] = /* :: */[
    f,
    opts$1[/* vio_tasks */14]
  ];
  return newrecord;
}

function add_vio_file(opts, f) {
  var opts$1 = set_batch_mode(opts);
  var newrecord = opts$1.slice();
  newrecord[/* vio_files */15] = /* :: */[
    f,
    opts$1[/* vio_files */15]
  ];
  return newrecord;
}

function set_vio_checking_j(opts, opt, j) {
  try {
    var newrecord = opts.slice();
    newrecord[/* vio_files_j */16] = Caml_format.caml_int_of_string(j);
    return newrecord;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      console.error("The first argument of " + (opt + " must the number"));
      console.error("of concurrent workers to be used (a positive integer).");
      console.error("Makefiles generated by coq_makefile should be called");
      console.error("setting the J variable like in 'make vio2vo J=3'");
      return Pervasives.exit(1);
    } else {
      throw exn;
    }
  }
}

function set_emacs(opts) {
  if (!Option$ReactTemplate.is_empty(opts[/* toploop */9])) {
    CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Flag -emacs is incompatible with a custom toplevel loop"));
  }
  Printer$ReactTemplate.enable_goal_tags_printing[0] = /* true */1;
  var newrecord = opts.slice();
  newrecord[/* color */17] = /* OFF */3944271;
  return newrecord;
}

function set_color(opts, param) {
  var exit = 0;
  switch (param) {
    case "auto" : 
        var newrecord = opts.slice();
        newrecord[/* color */17] = /* AUTO */725067631;
        return newrecord;
    case "no" : 
    case "off" : 
        exit = 2;
        break;
    case "on" : 
    case "yes" : 
        exit = 1;
        break;
    default:
      console.error("Error: on/off/auto expected after option color");
      return Pervasives.exit(1);
  }
  switch (exit) {
    case 1 : 
        var newrecord$1 = opts.slice();
        newrecord$1[/* color */17] = /* ON */17695;
        return newrecord$1;
    case 2 : 
        var newrecord$2 = opts.slice();
        newrecord$2[/* color */17] = /* OFF */3944271;
        return newrecord$2;
    
  }
}

var warn_deprecated_inputstate = CWarnings$ReactTemplate.create("deprecated-inputstate", "deprecated", /* None */0, (function () {
        return Pp$ReactTemplate.strbrk("The inputstate option is deprecated and discouraged.");
      }));

function set_inputstate(opts, s) {
  Curry._2(warn_deprecated_inputstate, /* None */0, /* () */0);
  var newrecord = opts.slice();
  newrecord[/* inputstate */29] = /* Some */[s];
  return newrecord;
}

var warn_deprecated_outputstate = CWarnings$ReactTemplate.create("deprecated-outputstate", "deprecated", /* None */0, (function () {
        return Pp$ReactTemplate.strbrk("The outputstate option is deprecated and discouraged.");
      }));

function set_outputstate(opts, s) {
  Curry._2(warn_deprecated_outputstate, /* None */0, /* () */0);
  var newrecord = opts.slice();
  newrecord[/* outputstate */30] = /* Some */[s];
  return newrecord;
}

function exitcode(opts) {
  if (opts[/* filter_opts */22]) {
    return 2;
  } else {
    return 0;
  }
}

function get_task_list(s) {
  return List.map(Caml_format.caml_int_of_string, Str$ReactTemplate.split(Str$ReactTemplate.regexp(","), s));
}

function get_bool(opt, param) {
  switch (param) {
    case "no" : 
    case "off" : 
        return /* false */0;
    case "on" : 
    case "yes" : 
        return /* true */1;
    default:
      console.error("Error: yes/no expected after option " + opt);
      return Pervasives.exit(1);
  }
}

function get_int(opt, n) {
  try {
    return Caml_format.caml_int_of_string(n);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      console.error("Error: integer expected after option " + opt);
      return Pervasives.exit(1);
    } else {
      throw exn;
    }
  }
}

function get_float(opt, n) {
  try {
    return Caml_format.caml_float_of_string(n);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      console.error("Error: float expected after option " + opt);
      return Pervasives.exit(1);
    } else {
      throw exn;
    }
  }
}

function get_host_port(opt, s) {
  var match = CString$ReactTemplate.split(/* ":" */58, s);
  var exit = 0;
  if (match) {
    var host = match[0];
    var match$1 = match[1];
    if (match$1) {
      var match$2 = match$1[1];
      if (match$2) {
        if (match$2[1]) {
          exit = 1;
        } else {
          return /* Some */[/* Socket */[
                    host,
                    Caml_format.caml_int_of_string(match$1[0]),
                    Caml_format.caml_int_of_string(match$2[0])
                  ]];
        }
      } else {
        exit = 1;
      }
    } else if (host === "stdfds") {
      return /* Some */[/* AnonPipe */0];
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    console.error("Error: host:portr:portw or stdfds expected after option " + opt);
    return Pervasives.exit(1);
  }
  
}

function get_error_resilience(_, s) {
  switch (s) {
    case "no" : 
    case "off" : 
        return /* None */870530776;
    case "all" : 
    case "on" : 
    case "yes" : 
        return /* All */3256577;
    default:
      return /* `Only */[
              881570188,
              CString$ReactTemplate.split(/* "," */44, s)
            ];
  }
}

function get_priority(opt, s) {
  try {
    return CoqworkmgrApi$ReactTemplate.priority_of_string(s);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      console.error("Error: low/high expected after " + opt);
      return Pervasives.exit(1);
    } else {
      throw exn;
    }
  }
}

function get_async_proofs_mode(opt, param) {
  switch (param) {
    case "lazy" : 
        return /* APonLazy */1;
    case "no" : 
    case "off" : 
        return /* APoff */0;
    case "on" : 
    case "yes" : 
        return /* APon */2;
    default:
      console.error("Error: on/off/lazy expected after " + opt);
      return Pervasives.exit(1);
  }
}

function get_cache(opt, param) {
  if (param === "force") {
    return /* Some */[/* Force */0];
  } else {
    console.error("Error: force expected after " + opt);
    return Pervasives.exit(1);
  }
}

function get_identifier(opt, s) {
  try {
    return Names$ReactTemplate.Id[/* of_string */5](s);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === CErrors$ReactTemplate.UserError) {
      console.error("Error: valid identifier expected after option " + opt);
      return Pervasives.exit(1);
    } else {
      throw exn;
    }
  }
}

function is_not_dash_option(param) {
  if (param) {
    var f = param[0];
    if (f.length > 0 && Caml_string.get(f, 0) !== /* "-" */45) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else {
    return /* false */0;
  }
}

function add_vio_args(peek, next, _oval) {
  while(true) {
    var oval = _oval;
    if (is_not_dash_option(Curry._1(peek, /* () */0))) {
      var oval$1 = add_vio_file(oval, Curry._1(next, /* () */0));
      _oval = oval$1;
      continue ;
      
    } else {
      return oval;
    }
  };
}

CWarnings$ReactTemplate.create("usage-no-coqlib", "filesystem", /* None */0, (function () {
        return Pp$ReactTemplate.str("cannot guess a path for Coq libraries; dynaminally loaded flags will not be mentioned");
      }));

function parse_args(arglist) {
  var args = [arglist];
  var extras = [/* [] */0];
  try {
    var _oval = init_args;
    while(true) {
      var oval = _oval;
      var match = args[0];
      if (match) {
        var rem = match[1];
        var opt = match[0];
        args[0] = rem;
        var next = (function(opt){
        return function next() {
          var match = args[0];
          if (match) {
            args[0] = match[1];
            return match[0];
          } else {
            return error_missing_arg(opt);
          }
        }
        }(opt));
        var peek_next = function () {
          var match = args[0];
          if (match) {
            return /* Some */[match[0]];
          } else {
            return /* None */0;
          }
        };
        var tmp;
        var exit = 0;
        switch (opt) {
          case "-Q" : 
              if (rem) {
                var match$1 = rem[1];
                if (match$1) {
                  args[0] = match$1[1];
                  tmp = add_vo_include(oval, rem[0], match$1[0], /* false */0);
                } else {
                  tmp = error_missing_arg(opt);
                }
              } else {
                tmp = error_missing_arg(opt);
              }
              break;
          case "-R" : 
              if (rem) {
                var match$2 = rem[1];
                if (match$2) {
                  args[0] = match$2[1];
                  tmp = add_vo_include(oval, rem[0], match$2[0], /* true */1);
                } else {
                  tmp = error_missing_arg(opt);
                }
              } else {
                tmp = error_missing_arg(opt);
              }
              break;
          case "-async-proofs" : 
              var newrecord = oval.slice();
              var newrecord$1 = oval[/* stm_flags */19].slice();
              newrecord$1[/* async_proofs_mode */3] = get_async_proofs_mode(opt, next(/* () */0));
              newrecord[/* stm_flags */19] = newrecord$1;
              tmp = newrecord;
              break;
          case "-async-proofs-cache" : 
              var newrecord$2 = oval.slice();
              var newrecord$3 = oval[/* stm_flags */19].slice();
              newrecord$3[/* async_proofs_cache */2] = get_cache(opt, next(/* () */0));
              newrecord$2[/* stm_flags */19] = newrecord$3;
              tmp = newrecord$2;
              break;
          case "-async-proofs-command-error-resilience" : 
              var newrecord$4 = oval.slice();
              var newrecord$5 = oval[/* stm_flags */19].slice();
              newrecord$5[/* async_proofs_cmd_error_resilience */8] = get_bool(opt, next(/* () */0));
              newrecord$4[/* stm_flags */19] = newrecord$5;
              tmp = newrecord$4;
              break;
          case "-async-proofs-delegation-threshold" : 
              var newrecord$6 = oval.slice();
              var newrecord$7 = oval[/* stm_flags */19].slice();
              newrecord$7[/* async_proofs_delegation_threshold */9] = get_float(opt, next(/* () */0));
              newrecord$6[/* stm_flags */19] = newrecord$7;
              tmp = newrecord$6;
              break;
          case "-async-proofs-j" : 
              var newrecord$8 = oval.slice();
              var newrecord$9 = oval[/* stm_flags */19].slice();
              newrecord$9[/* async_proofs_n_workers */0] = get_int(opt, next(/* () */0));
              newrecord$8[/* stm_flags */19] = newrecord$9;
              tmp = newrecord$8;
              break;
          case "-async-proofs-never-reopen-branch" : 
              var newrecord$10 = oval.slice();
              var newrecord$11 = oval[/* stm_flags */19].slice();
              newrecord$11[/* async_proofs_never_reopen_branch */6] = /* true */1;
              newrecord$10[/* stm_flags */19] = newrecord$11;
              tmp = newrecord$10;
              break;
          case "-async-proofs-private-flags" : 
              var newrecord$12 = oval.slice();
              var newrecord$13 = oval[/* stm_flags */19].slice();
              newrecord$13[/* async_proofs_private_flags */4] = /* Some */[next(/* () */0)];
              newrecord$12[/* stm_flags */19] = newrecord$13;
              tmp = newrecord$12;
              break;
          case "-async-proofs-tac-j" : 
              var newrecord$14 = oval.slice();
              var newrecord$15 = oval[/* stm_flags */19].slice();
              newrecord$15[/* async_proofs_n_tacworkers */1] = get_int(opt, next(/* () */0));
              newrecord$14[/* stm_flags */19] = newrecord$15;
              tmp = newrecord$14;
              break;
          case "-async-proofs-tactic-error-resilience" : 
              var newrecord$16 = oval.slice();
              var newrecord$17 = oval[/* stm_flags */19].slice();
              newrecord$17[/* async_proofs_tac_error_resilience */7] = get_error_resilience(opt, next(/* () */0));
              newrecord$16[/* stm_flags */19] = newrecord$17;
              tmp = newrecord$16;
              break;
          case "-async-proofs-worker-priority" : 
              WorkerLoop$ReactTemplate.async_proofs_worker_priority[0] = get_priority(opt, next(/* () */0));
              tmp = oval;
              break;
          case "-async-proofs-always-delegate" : 
          case "-async-proofs-full" : 
          case "-async-queries-always-delegate" : 
              exit = 3;
              break;
          case "-batch" : 
              tmp = set_batch_mode(oval);
              break;
          case "-beautify" : 
              Flags$ReactTemplate.beautify[0] = /* true */1;
              tmp = oval;
              break;
          case "-bt" : 
              Backtrace$ReactTemplate.record_backtrace(/* true */1);
              tmp = oval;
              break;
          case "-check-vio-tasks" : 
              var tno = get_task_list(next(/* () */0));
              var tfile = next(/* () */0);
              tmp = add_vio_task(oval, /* tuple */[
                    tno,
                    tfile
                  ]);
              break;
          case "-color" : 
              tmp = set_color(oval, next(/* () */0));
              break;
          case "-compat" : 
              var v = G_vernac$ReactTemplate.parse_compat_version(/* Some */[/* false */0], next(/* () */0));
              Flags$ReactTemplate.compat_version[0] = v;
              tmp = add_compat_require(oval, v);
              break;
          case "--config" : 
          case "-config" : 
              exit = 4;
              break;
          case "-control-channel" : 
              Spawned$ReactTemplate.control_channel[0] = get_host_port(opt, next(/* () */0));
              tmp = oval;
              break;
          case "-emacs" : 
              tmp = set_emacs(oval);
              break;
          case "-filteropts" : 
              var newrecord$18 = oval.slice();
              newrecord$18[/* filter_opts */22] = /* true */1;
              tmp = newrecord$18;
              break;
          case "--help" : 
          case "-?" : 
          case "-H" : 
          case "-h" : 
          case "-help" : 
              Pervasives.failwith("usage");
              tmp = oval;
              break;
          case "-impredicative-set" : 
              var newrecord$19 = oval.slice();
              newrecord$19[/* impredicative_set */18] = /* ImpredicativeSet */0;
              tmp = newrecord$19;
              break;
          case "-I" : 
          case "-include" : 
              exit = 1;
              break;
          case "-indices-matter" : 
              Indtypes$ReactTemplate.enforce_indices_matter(/* () */0);
              tmp = oval;
              break;
          case "-init-file" : 
              var newrecord$20 = oval.slice();
              newrecord$20[/* rcfile */2] = /* Some */[next(/* () */0)];
              tmp = newrecord$20;
              break;
          case "-inputstate" : 
          case "-is" : 
              tmp = set_inputstate(oval, next(/* () */0));
              break;
          case "-list-tags" : 
              var newrecord$21 = oval.slice();
              newrecord$21[/* print_tags */25] = /* true */1;
              tmp = newrecord$21;
              break;
          case "--memory" : 
          case "-m" : 
              exit = 5;
              break;
          case "-main-channel" : 
              Spawned$ReactTemplate.main_channel[0] = get_host_port(opt, next(/* () */0));
              tmp = oval;
              break;
          case "-mangle-names" : 
              Namegen$ReactTemplate.set_mangle_names_mode(get_identifier(opt, next(/* () */0)));
              tmp = oval;
              break;
          case "-noinit" : 
          case "-nois" : 
              exit = 6;
              break;
          case "-o" : 
              var newrecord$22 = oval.slice();
              newrecord$22[/* compilation_output_name */11] = /* Some */[next(/* () */0)];
              tmp = newrecord$22;
              break;
          case "-output-context" : 
              var newrecord$23 = oval.slice();
              newrecord$23[/* output_context */28] = /* true */1;
              tmp = newrecord$23;
              break;
          case "-outputstate" : 
              tmp = set_outputstate(oval, next(/* () */0));
              break;
          case "-q" : 
              var newrecord$24 = oval.slice();
              newrecord$24[/* load_rcfile */1] = /* false */0;
              tmp = newrecord$24;
              break;
          case "-quick" : 
              var newrecord$25 = oval.slice();
              newrecord$25[/* compilation_mode */7] = /* BuildVio */1;
              tmp = newrecord$25;
              break;
          case "-schedule-vio-checking" : 
              var newrecord$26 = oval.slice();
              newrecord$26[/* vio_checking */13] = /* true */1;
              var oval$1 = set_vio_checking_j(newrecord$26, opt, next(/* () */0));
              var oval$2 = add_vio_file(oval$1, next(/* () */0));
              tmp = add_vio_args(peek_next, next, oval$2);
              break;
          case "-schedule-vio2vo" : 
              var oval$3 = set_vio_checking_j(oval, opt, next(/* () */0));
              var oval$4 = add_vio_file(oval$3, next(/* () */0));
              tmp = add_vio_args(peek_next, next, oval$4);
              break;
          case "-quiet" : 
          case "-silent" : 
              Flags$ReactTemplate.quiet[0] = /* true */1;
              Flags$ReactTemplate.make_warn(/* false */0);
              tmp = oval;
              break;
          case "-stm-debug" : 
              Stm$ReactTemplate.stm_debug[0] = /* true */1;
              tmp = oval;
              break;
          case "-test-mode" : 
              Flags$ReactTemplate.test_mode[0] = /* true */1;
              tmp = oval;
              break;
          case "-time" : 
              var newrecord$27 = oval.slice();
              newrecord$27[/* time */21] = /* true */1;
              tmp = newrecord$27;
              break;
          case "-top" : 
              var topname = Libnames$ReactTemplate.dirpath_of_string(next(/* () */0));
              if (Curry._1(Names$ReactTemplate.DirPath[/* is_empty */6], topname)) {
                CErrors$ReactTemplate.user_err(/* None */0, /* None */0, Pp$ReactTemplate.str("Need a non empty toplevel module name"));
              }
              var newrecord$28 = oval.slice();
              newrecord$28[/* toplevel_name */8] = topname;
              tmp = newrecord$28;
              break;
          case "-type-in-type" : 
              set_type_in_type(/* () */0);
              tmp = oval;
              break;
          case "-unicode" : 
              tmp = add_vo_require(oval, "Utf8_core", /* None */0, /* Some */[/* false */0]);
              break;
          case "-vio2vo" : 
              var oval$5 = add_compile(oval, /* false */0, next(/* () */0));
              var newrecord$29 = oval$5.slice();
              newrecord$29[/* compilation_mode */7] = /* Vio2Vo */2;
              tmp = newrecord$29;
              break;
          case "-W" : 
          case "-w" : 
              exit = 2;
              break;
          case "-where" : 
              var newrecord$30 = oval.slice();
              newrecord$30[/* print_where */26] = /* true */1;
              tmp = newrecord$30;
              break;
          case "-worker-id" : 
              set_worker_id(opt, next(/* () */0));
              tmp = oval;
              break;
          default:
            extras[0] = /* :: */[
              opt,
              extras[0]
            ];
            tmp = oval;
        }
        switch (exit) {
          case 1 : 
              if (rem) {
                args[0] = rem[1];
                tmp = add_ml_include(oval, rem[0]);
              } else {
                tmp = error_missing_arg(opt);
              }
              break;
          case 2 : 
              var w = next(/* () */0);
              if (w === "none") {
                CWarnings$ReactTemplate.set_flags(w);
                tmp = oval;
              } else {
                var w$1 = CWarnings$ReactTemplate.get_flags(/* () */0) + ("," + w);
                CWarnings$ReactTemplate.set_flags(CWarnings$ReactTemplate.normalize_flags_string(w$1));
                tmp = oval;
              }
              break;
          case 3 : 
              var newrecord$31 = oval.slice();
              var newrecord$32 = oval[/* stm_flags */19].slice();
              newrecord$32[/* async_proofs_full */5] = /* true */1;
              newrecord$31[/* stm_flags */19] = newrecord$32;
              tmp = newrecord$31;
              break;
          case 4 : 
              var newrecord$33 = oval.slice();
              newrecord$33[/* print_config */27] = /* true */1;
              tmp = newrecord$33;
              break;
          case 5 : 
              var newrecord$34 = oval.slice();
              newrecord$34[/* memory_stat */24] = /* true */1;
              tmp = newrecord$34;
              break;
          case 6 : 
              var newrecord$35 = oval.slice();
              newrecord$35[/* load_init */0] = /* false */0;
              tmp = newrecord$35;
              break;
          
        }
        _oval = tmp;
        continue ;
        
      } else {
        return /* tuple */[
                oval,
                List.rev(extras[0])
              ];
      }
    };
  }
  catch (raw_any){
    var any = Js_exn.internalToOCamlException(raw_any);
    var extra = /* None */0;
    var exn = any;
    Topfmt$ReactTemplate.print_err_exn(extra, exn);
    return Pervasives.exit(CErrors$ReactTemplate.is_anomaly(exn) || !CErrors$ReactTemplate.handled(exn) ? 129 : 1);
  }
}

exports.parse_args = parse_args;
exports.exitcode = exitcode;
/* init_args Not a pure module */
