// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Loc$ReactTemplate = require("./loc.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Type_errors$ReactTemplate = require("./type_errors.bs.js");

var PretypeError = Caml_exceptions.create("Pretype_errors-ReactTemplate.PretypeError");

function precatchable_exception(param) {
  if (param[0] === CErrors$ReactTemplate.UserError || param[0] === Type_errors$ReactTemplate.TypeError || param[0] === PretypeError || param[0] === Nametab$ReactTemplate.GlobalizationError) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function raise_pretype_error(loc, param) {
  return Loc$ReactTemplate.raise(loc, [
              PretypeError,
              param[0],
              param[1],
              param[2]
            ]);
}

function raise_type_error(loc, param) {
  return Loc$ReactTemplate.raise(loc, [
              PretypeError,
              param[0],
              param[1],
              /* TypingError */Block.__(16, [param[2]])
            ]);
}

function error_actual_type(loc, env, sigma, param, expty, reason) {
  var j_000 = /* uj_val */param[/* uj_val */0];
  var j_001 = /* uj_type */param[/* uj_type */1];
  var j = /* record */[
    j_000,
    j_001
  ];
  return raise_pretype_error(loc, /* tuple */[
              env,
              sigma,
              /* ActualTypeNotCoercible */Block.__(1, [
                  j,
                  expty,
                  reason
                ])
            ]);
}

function error_actual_type_core(loc, env, sigma, param, expty) {
  var j_000 = /* uj_val */param[/* uj_val */0];
  var j_001 = /* uj_type */param[/* uj_type */1];
  var j = /* record */[
    j_000,
    j_001
  ];
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* ActualType */Block.__(11, [
                  j,
                  expty
                ])
            ]);
}

function error_cant_apply_not_functional(loc, env, sigma, rator, randl) {
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* CantApplyNonFunctional */Block.__(13, [
                  rator,
                  randl
                ])
            ]);
}

function error_cant_apply_bad_type(loc, env, sigma, param, rator, randl) {
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* CantApplyBadType */Block.__(12, [
                  /* tuple */[
                    param[0],
                    param[1],
                    param[2]
                  ],
                  rator,
                  randl
                ])
            ]);
}

function error_ill_formed_branch(loc, env, sigma, c, i, actty, expty) {
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* IllFormedBranch */Block.__(9, [
                  c,
                  i,
                  actty,
                  expty
                ])
            ]);
}

function error_number_branches(loc, env, sigma, cj, expn) {
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* NumberBranches */Block.__(8, [
                  cj,
                  expn
                ])
            ]);
}

function error_case_not_inductive(loc, env, sigma, cj) {
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* CaseNotInductive */Block.__(6, [cj])
            ]);
}

function error_ill_typed_rec_body(loc, env, sigma, i, na, jl, tys) {
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* IllTypedRecBody */Block.__(15, [
                  i,
                  na,
                  jl,
                  tys
                ])
            ]);
}

function error_elim_arity(loc, env, sigma, pi, s, c, j, a) {
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* ElimArity */Block.__(5, [
                  pi,
                  s,
                  c,
                  j,
                  a
                ])
            ]);
}

function error_not_a_type(loc, env, sigma, j) {
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* NotAType */Block.__(2, [j])
            ]);
}

function error_assumption(loc, env, sigma, j) {
  return raise_type_error(loc, /* tuple */[
              env,
              sigma,
              /* BadAssumption */Block.__(3, [j])
            ]);
}

function error_occur_check(env, sigma, ev, c) {
  throw [
        PretypeError,
        env,
        sigma,
        /* UnifOccurCheck */Block.__(2, [
            ev,
            c
          ])
      ];
}

function error_unsolvable_implicit(loc, env, sigma, evk, explain) {
  return Loc$ReactTemplate.raise(loc, [
              PretypeError,
              env,
              sigma,
              /* UnsolvableImplicit */Block.__(3, [
                  evk,
                  explain
                ])
            ]);
}

function error_cannot_unify(loc, env, sigma, reason, param) {
  return Loc$ReactTemplate.raise(loc, [
              PretypeError,
              env,
              sigma,
              /* CannotUnify */Block.__(4, [
                  param[0],
                  param[1],
                  reason
                ])
            ]);
}

function error_cannot_unify_local(env, sigma, param) {
  throw [
        PretypeError,
        env,
        sigma,
        /* CannotUnifyLocal */Block.__(5, [
            param[0],
            param[1],
            param[2]
          ])
      ];
}

function error_cannot_coerce(env, sigma, param) {
  throw [
        PretypeError,
        env,
        sigma,
        /* CannotUnify */Block.__(4, [
            param[0],
            param[1],
            /* None */0
          ])
      ];
}

function error_cannot_find_well_typed_abstraction(env, sigma, p, l, e) {
  throw [
        PretypeError,
        env,
        sigma,
        /* CannotFindWellTypedAbstraction */Block.__(9, [
            p,
            l,
            e
          ])
      ];
}

function error_wrong_abstraction_type(env, sigma, na, a, p, l) {
  throw [
        PretypeError,
        env,
        sigma,
        /* WrongAbstractionType */Block.__(10, [
            na,
            a,
            p,
            l
          ])
      ];
}

function error_abstraction_over_meta(env, sigma, hdmeta, metaarg) {
  var m = Evd$ReactTemplate.meta_name(sigma, hdmeta);
  var n = Evd$ReactTemplate.meta_name(sigma, metaarg);
  throw [
        PretypeError,
        env,
        sigma,
        /* AbstractionOverMeta */Block.__(11, [
            m,
            n
          ])
      ];
}

function error_non_linear_unification(env, sigma, hdmeta, t) {
  var m = Evd$ReactTemplate.meta_name(sigma, hdmeta);
  throw [
        PretypeError,
        env,
        sigma,
        /* NonLinearUnification */Block.__(12, [
            m,
            t
          ])
      ];
}

function error_cant_find_case_type(loc, env, sigma, expr) {
  return raise_pretype_error(loc, /* tuple */[
              env,
              sigma,
              /* CantFindCaseType */Block.__(0, [expr])
            ]);
}

function error_unexpected_type(loc, env, sigma, actty, expty) {
  return raise_pretype_error(loc, /* tuple */[
              env,
              sigma,
              /* UnexpectedType */Block.__(14, [
                  actty,
                  expty
                ])
            ]);
}

function error_not_product(loc, env, sigma, c) {
  return raise_pretype_error(loc, /* tuple */[
              env,
              sigma,
              /* NotProduct */Block.__(15, [c])
            ]);
}

function error_var_not_found(loc, s) {
  return raise_pretype_error(loc, /* tuple */[
              Environ$ReactTemplate.empty_env,
              Evd$ReactTemplate.empty,
              /* VarNotFound */Block.__(13, [s])
            ]);
}

function unsatisfiable_constraints(env, evd, ev, comp) {
  if (ev) {
    var ev$1 = ev[0];
    var match = Evd$ReactTemplate.evar_source(ev$1, evd);
    var err_000 = /* Some */[/* tuple */[
        ev$1,
        match[1]
      ]];
    var err = /* UnsatisfiableConstraints */Block.__(18, [
        err_000,
        comp
      ]);
    return Loc$ReactTemplate.raise(match[0], [
                PretypeError,
                env,
                evd,
                err
              ]);
  } else {
    var err$1 = /* UnsatisfiableConstraints */Block.__(18, [
        /* None */0,
        comp
      ]);
    throw [
          PretypeError,
          env,
          evd,
          err$1
        ];
  }
}

function unsatisfiable_exception(exn) {
  if (exn[0] === PretypeError && exn[3].tag === 18) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

exports.PretypeError = PretypeError;
exports.precatchable_exception = precatchable_exception;
exports.error_actual_type = error_actual_type;
exports.error_actual_type_core = error_actual_type_core;
exports.error_cant_apply_not_functional = error_cant_apply_not_functional;
exports.error_cant_apply_bad_type = error_cant_apply_bad_type;
exports.error_case_not_inductive = error_case_not_inductive;
exports.error_ill_formed_branch = error_ill_formed_branch;
exports.error_number_branches = error_number_branches;
exports.error_ill_typed_rec_body = error_ill_typed_rec_body;
exports.error_elim_arity = error_elim_arity;
exports.error_not_a_type = error_not_a_type;
exports.error_assumption = error_assumption;
exports.error_cannot_coerce = error_cannot_coerce;
exports.error_occur_check = error_occur_check;
exports.error_unsolvable_implicit = error_unsolvable_implicit;
exports.error_cannot_unify = error_cannot_unify;
exports.error_cannot_unify_local = error_cannot_unify_local;
exports.error_cannot_find_well_typed_abstraction = error_cannot_find_well_typed_abstraction;
exports.error_wrong_abstraction_type = error_wrong_abstraction_type;
exports.error_abstraction_over_meta = error_abstraction_over_meta;
exports.error_non_linear_unification = error_non_linear_unification;
exports.error_cant_find_case_type = error_cant_find_case_type;
exports.error_unexpected_type = error_unexpected_type;
exports.error_not_product = error_not_product;
exports.error_var_not_found = error_var_not_found;
exports.unsatisfiable_constraints = unsatisfiable_constraints;
exports.unsatisfiable_exception = unsatisfiable_exception;
/* Evd-ReactTemplate Not a pure module */
