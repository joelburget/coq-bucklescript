// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Pp$ReactTemplate = require("../src/pp.bs.js");
var Term$ReactTemplate = require("../src/term.bs.js");
var Univ$ReactTemplate = require("../src/univ.bs.js");
var Util$ReactTemplate = require("../src/util.bs.js");
var Vars$ReactTemplate = require("../src/vars.bs.js");
var Names$ReactTemplate = require("../src/names.bs.js");
var CArray$ReactTemplate = require("../src/cArray.bs.js");
var Constr$ReactTemplate = require("../src/constr.bs.js");
var Global$ReactTemplate = require("../src/global.bs.js");
var Modops$ReactTemplate = require("../src/modops.bs.js");
var Option$ReactTemplate = require("../src/option.bs.js");
var CErrors$ReactTemplate = require("../src/cErrors.bs.js");
var Context$ReactTemplate = require("../src/context.bs.js");
var Printer$ReactTemplate = require("../src/printer.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("../src/globnames.bs.js");
var Inductive$ReactTemplate = require("../src/inductive.bs.js");
var Mod_subst$ReactTemplate = require("../src/mod_subst.bs.js");
var Declareops$ReactTemplate = require("../src/declareops.bs.js");

var modcache = [Names$ReactTemplate.MPmap[/* empty */0]];

function fields_of_functor(f, _subs, mp0, _args, _param) {
  while(true) {
    var param = _param;
    var args = _args;
    var subs = _subs;
    if (param.tag) {
      if (args) {
        var subs$1 = Mod_subst$ReactTemplate.join(Mod_subst$ReactTemplate.map_mbid(param[0], args[0], Mod_subst$ReactTemplate.empty_delta_resolver), subs);
        _param = param[2];
        _args = args[1];
        _subs = subs$1;
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "assumptions.ml",
                66,
                12
              ]
            ];
      }
    } else {
      return Curry._4(f, subs, mp0, args, param[0]);
    }
  };
}

function lookup_module_in_impl(mp) {
  try {
    return Global$ReactTemplate.lookup_module(mp);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      switch (mp.tag | 0) {
        case 0 : 
            throw Caml_builtin_exceptions.not_found;
        case 1 : 
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "assumptions.ml",
                    78,
                    19
                  ]
                ];
        case 2 : 
            var fields = memoize_fields_of_mp(mp[0]);
            var lab = mp[1];
            var _param = fields;
            while(true) {
              var param = _param;
              if (param) {
                var match = param[0];
                var match$1 = match[1];
                if (match$1.tag === 2) {
                  if (Names$ReactTemplate.Label[/* equal */0](match[0], lab)) {
                    return match$1[0];
                  } else {
                    _param = param[1];
                    continue ;
                    
                  }
                } else {
                  _param = param[1];
                  continue ;
                  
                }
              } else {
                throw Caml_builtin_exceptions.not_found;
              }
            };
        
      }
    } else {
      throw exn;
    }
  }
}

function memoize_fields_of_mp(mp) {
  try {
    return Curry._2(Names$ReactTemplate.MPmap[/* find */21], mp, modcache[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var l = fields_of_mp(mp);
      modcache[0] = Curry._3(Names$ReactTemplate.MPmap[/* add */3], mp, l, modcache[0]);
      return l;
    } else {
      throw exn;
    }
  }
}

function fields_of_mp(mp) {
  var mb = lookup_module_in_impl(mp);
  var match = fields_of_mb(Mod_subst$ReactTemplate.empty_subst, mb, /* [] */0);
  var subs = match[2];
  var inner_mp = match[1];
  var subs$1 = Names$ReactTemplate.ModPath[/* equal */1](inner_mp, mp) ? subs : Mod_subst$ReactTemplate.add_mp(inner_mp, mp, mb[/* mod_delta */5], subs);
  return Modops$ReactTemplate.subst_structure(subs$1)(match[0]);
}

function fields_of_mb(subs, mb, args) {
  var match = mb[/* mod_expr */1];
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else if (match.tag) {
    return fields_of_signature(subs)(mb[/* mod_mp */0], args, match[0]);
  } else {
    return fields_of_functor(fields_of_expr, subs, mb[/* mod_mp */0], args, match[0]);
  }
  if (exit === 1) {
    return fields_of_signature(subs)(mb[/* mod_mp */0], args, mb[/* mod_type */2]);
  }
  
}

function fields_of_signature(x) {
  return (function (param, param$1, param$2) {
      return fields_of_functor((function (subs, mp0, args, struc) {
                    if (!Curry._1(Util$ReactTemplate.List[/* is_empty */45], args)) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            [
                              "assumptions.ml",
                              109,
                              6
                            ]
                          ];
                    }
                    return /* tuple */[
                            struc,
                            mp0,
                            subs
                          ];
                  }), x, param, param$1, param$2);
    });
}

function fields_of_expr(subs, _, _args, _param) {
  while(true) {
    var param = _param;
    var args = _args;
    switch (param.tag | 0) {
      case 0 : 
          var mb = lookup_module_in_impl(Mod_subst$ReactTemplate.subst_mp(subs, param[0]));
          return fields_of_mb(subs, mb, args);
      case 1 : 
          _param = param[0];
          _args = /* :: */[
            param[1],
            args
          ];
          continue ;
          case 2 : 
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "assumptions.ml",
                  117,
                  15
                ]
              ];
      
    }
  };
}

function lookup_constant_in_impl(cst, fallback) {
  try {
    var match = Names$ReactTemplate.KerName[/* repr */2](Names$ReactTemplate.Constant[/* canonical */5](cst));
    var fields = memoize_fields_of_mp(match[0]);
    var lab = match[2];
    var _param = fields;
    while(true) {
      var param = _param;
      if (param) {
        var match$1 = param[0];
        var match$2 = match$1[1];
        if (match$2.tag) {
          _param = param[1];
          continue ;
          
        } else if (Names$ReactTemplate.Label[/* equal */0](match$1[0], lab)) {
          return match$2[0];
        } else {
          _param = param[1];
          continue ;
          
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      if (fallback) {
        return fallback[0];
      } else {
        return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Assumption: unknown constant "), Names$ReactTemplate.Constant[/* print */16](cst)), Pp$ReactTemplate.str(".")));
      }
    } else {
      throw exn;
    }
  }
}

function lookup_constant(cst) {
  try {
    var cb = Global$ReactTemplate.lookup_constant(cst);
    if (Declareops$ReactTemplate.constant_has_body(cb)) {
      return cb;
    } else {
      return lookup_constant_in_impl(cst, /* Some */[cb]);
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return lookup_constant_in_impl(cst, /* None */0);
    } else {
      throw exn;
    }
  }
}

function lookup_mind(mind) {
  try {
    return Global$ReactTemplate.lookup_mind(mind);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var mind$1 = mind;
      try {
        var match = Names$ReactTemplate.KerName[/* repr */2](Names$ReactTemplate.MutInd[/* canonical */5](mind$1));
        var fields = memoize_fields_of_mp(match[0]);
        var lab = match[2];
        var _param = fields;
        while(true) {
          var param = _param;
          if (param) {
            var match$1 = param[0];
            var match$2 = match$1[1];
            if (match$2.tag === 1) {
              if (Names$ReactTemplate.Label[/* equal */0](match$1[0], lab)) {
                return match$2[0];
              } else {
                _param = param[1];
                continue ;
                
              }
            } else {
              _param = param[1];
              continue ;
              
            }
          } else {
            throw Caml_builtin_exceptions.not_found;
          }
        };
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          return CErrors$ReactTemplate.anomaly(/* None */0, /* None */0, Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Print Assumption: unknown inductive "), Names$ReactTemplate.MutInd[/* print */15](mind$1)), Pp$ReactTemplate.str(".")));
        } else {
          throw exn$1;
        }
      }
    } else {
      throw exn;
    }
  }
}

function label_of(param) {
  switch (param.tag | 0) {
    case 0 : 
        return Names$ReactTemplate.Label[/* of_id */5](param[0]);
    case 1 : 
        return Util$ReactTemplate.pi3(Names$ReactTemplate.Constant[/* repr3 */6](param[0]));
    case 2 : 
        return Util$ReactTemplate.pi3(Names$ReactTemplate.MutInd[/* repr3 */6](param[0][0]));
    case 3 : 
        return Util$ReactTemplate.pi3(Names$ReactTemplate.MutInd[/* repr3 */6](param[0][0][0]));
    
  }
}

function fold_constr_with_full_binders(g, f, n, acc, c) {
  var match = Constr$ReactTemplate.kind(c);
  var exit = 0;
  switch (match.tag | 0) {
    case 3 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](Curry._1(f, n), acc, match[0][1]);
    case 5 : 
        return Curry._3(f, n, Curry._3(f, n, acc, match[0]), match[2]);
    case 6 : 
    case 7 : 
        exit = 1;
        break;
    case 8 : 
        var t = match[2];
        var b = match[1];
        return Curry._3(f, Curry._2(g, /* LocalDef */Block.__(1, [
                          match[0],
                          b,
                          t
                        ]), n), Curry._3(f, n, Curry._3(f, n, acc, b), t), match[3]);
    case 9 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](Curry._1(f, n), Curry._3(f, n, acc, match[0]), match[1]);
    case 13 : 
        return Util$ReactTemplate.$$Array[/* fold_left */15](Curry._1(f, n), Curry._3(f, n, Curry._3(f, n, acc, match[1]), match[2]), match[3]);
    case 14 : 
        var match$1 = match[0][1];
        var tl = match$1[1];
        var n$prime = CArray$ReactTemplate.fold_left2((function (c, n, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              n,
                              t
                            ]), c);
              }), n, match$1[0], tl);
        var fd = Util$ReactTemplate.$$Array[/* map2 */49]((function (t, b) {
                return /* tuple */[
                        t,
                        b
                      ];
              }), tl, match$1[2]);
        return Util$ReactTemplate.$$Array[/* fold_left */15]((function (acc, param) {
                      return Curry._3(f, n$prime, Curry._3(f, n, acc, param[0]), param[1]);
                    }), acc, fd);
    case 15 : 
        var match$2 = match[0][1];
        var tl$1 = match$2[1];
        var n$prime$1 = CArray$ReactTemplate.fold_left2((function (c, n, t) {
                return Curry._2(g, /* LocalAssum */Block.__(0, [
                              n,
                              t
                            ]), c);
              }), n, match$2[0], tl$1);
        var fd$1 = Util$ReactTemplate.$$Array[/* map2 */49]((function (t, b) {
                return /* tuple */[
                        t,
                        b
                      ];
              }), tl$1, match$2[2]);
        return Util$ReactTemplate.$$Array[/* fold_left */15]((function (acc, param) {
                      return Curry._3(f, n$prime$1, Curry._3(f, n, acc, param[0]), param[1]);
                    }), acc, fd$1);
    case 16 : 
        return Curry._3(f, n, acc, match[1]);
    default:
      return acc;
  }
  if (exit === 1) {
    var t$1 = match[1];
    return Curry._3(f, Curry._2(g, /* LocalAssum */Block.__(0, [
                      match[0],
                      t$1
                    ]), n), Curry._3(f, n, acc, t$1), match[2]);
  }
  
}

function traverse(current, ctx, accu, t) {
  var match = Constr$ReactTemplate.kind(t);
  var exit = 0;
  switch (match.tag | 0) {
    case 1 : 
        var id = match[0];
        var body = function () {
          return Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_value */1], Global$ReactTemplate.lookup_named(id));
        };
        return traverse_object(/* None */0, accu, body, /* VarRef */Block.__(0, [id]));
    case 2 : 
    case 3 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "assumptions.ml",
                198,
                21
              ]
            ];
    case 10 : 
        var kn = match[0][0];
        var body$1 = function () {
          return Option$ReactTemplate.map((function (prim) {
                        return prim[0];
                      }), Global$ReactTemplate.body_of_constant_body(lookup_constant(kn)));
        };
        return traverse_object(/* None */0, accu, body$1, /* ConstRef */Block.__(1, [kn]));
    case 11 : 
        var ind = match[0][0];
        return traverse_inductive(accu, ind[0], /* IndRef */Block.__(2, [ind]));
    case 12 : 
        var cst = match[0][0];
        return traverse_inductive(accu, cst[0][0], /* ConstructRef */Block.__(3, [cst]));
    case 13 : 
        if (match[3].length !== 0) {
          exit = 1;
        } else {
          var match$1 = Constr$ReactTemplate.kind(match[1]);
          var match$2 = Constr$ReactTemplate.kind(match[2]);
          var exit$1 = 0;
          if (match$1.tag === 7) {
            if (match$2.tag === 10) {
              var kn$1 = match$2[0][0];
              var oty = match$1[2];
              if (Vars$ReactTemplate.noccurn(1, oty) && !Declareops$ReactTemplate.constant_has_body(lookup_constant(kn$1))) {
                var body$2 = function () {
                  return Option$ReactTemplate.map((function (prim) {
                                return prim[0];
                              }), Global$ReactTemplate.body_of_constant_body(lookup_constant(kn$1)));
                };
                return traverse_object(/* Some */[/* tuple */[
                              current,
                              ctx,
                              Vars$ReactTemplate.subst1(Constr$ReactTemplate.mkProp, oty)
                            ]], accu, body$2, /* ConstRef */Block.__(1, [kn$1]));
              } else {
                exit$1 = 2;
              }
            } else {
              exit$1 = 2;
            }
          } else {
            exit$1 = 2;
          }
          if (exit$1 === 2) {
            return fold_constr_with_full_binders(Context$ReactTemplate.Rel[/* add */2], (function (param, param$1, param$2) {
                          return traverse(current, param, param$1, param$2);
                        }), ctx, accu, t);
          }
          
        }
        break;
    default:
      exit = 1;
  }
  if (exit === 1) {
    return fold_constr_with_full_binders(Context$ReactTemplate.Rel[/* add */2], (function (param, param$1, param$2) {
                  return traverse(current, param, param$1, param$2);
                }), ctx, accu, t);
  }
  
}

function traverse_object(inhabits, param, body, obj) {
  var ax2ty = param[2];
  var data = param[1];
  var already_in = Curry._2(Globnames$ReactTemplate.Refmap_env[/* mem */2], obj, data);
  var match = Curry._1(body, /* () */0);
  var match$1;
  if (match) {
    if (already_in) {
      match$1 = /* tuple */[
        data,
        ax2ty
      ];
    } else {
      var match$2 = traverse(label_of(obj), Context$ReactTemplate.Rel[/* empty */1], /* tuple */[
            Globnames$ReactTemplate.Refset_env[/* empty */0],
            data,
            ax2ty
          ], match[0]);
      match$1 = /* tuple */[
        Curry._3(Globnames$ReactTemplate.Refmap_env[/* add */3], obj, match$2[0], match$2[1]),
        match$2[2]
      ];
    }
  } else {
    var data$1 = already_in ? data : Curry._3(Globnames$ReactTemplate.Refmap_env[/* add */3], obj, Globnames$ReactTemplate.Refset_env[/* empty */0], data);
    var ax2ty$1;
    if (Option$ReactTemplate.is_empty(inhabits)) {
      ax2ty$1 = ax2ty;
    } else {
      var ty = Option$ReactTemplate.get(inhabits);
      try {
        var l = Curry._2(Globnames$ReactTemplate.Refmap_env[/* find */21], obj, ax2ty);
        ax2ty$1 = Curry._3(Globnames$ReactTemplate.Refmap_env[/* add */3], obj, /* :: */[
              ty,
              l
            ], ax2ty);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          ax2ty$1 = Curry._3(Globnames$ReactTemplate.Refmap_env[/* add */3], obj, /* :: */[
                ty,
                /* [] */0
              ], ax2ty);
        } else {
          throw exn;
        }
      }
    }
    match$1 = /* tuple */[
      data$1,
      ax2ty$1
    ];
  }
  return /* tuple */[
          Curry._2(Globnames$ReactTemplate.Refset_env[/* add */3], obj, param[0]),
          match$1[0],
          match$1[1]
        ];
}

function traverse_inductive(param, mind, obj) {
  var ax2ty = param[2];
  var data = param[1];
  var firstind_ref = /* IndRef */Block.__(2, [/* tuple */[
        mind,
        0
      ]]);
  var label = label_of(obj);
  var match;
  if (Curry._2(Globnames$ReactTemplate.Refmap_env[/* mem */2], firstind_ref, data)) {
    match = /* tuple */[
      data,
      ax2ty
    ];
  } else {
    var mib = lookup_mind(mind);
    var param_ctx = mib[/* mind_params_ctxt */7];
    var nparam = Curry._1(Util$ReactTemplate.List[/* length */0], param_ctx);
    var accu = traverse_context(label, Context$ReactTemplate.Rel[/* empty */1], /* tuple */[
          Globnames$ReactTemplate.Refset_env[/* empty */0],
          data,
          ax2ty
        ], param_ctx);
    var global_env = Global$ReactTemplate.env(/* () */0);
    var arities_ctx = Util$ReactTemplate.$$Array[/* fold_left */15]((function (accu, oib) {
            var pspecif = Univ$ReactTemplate.in_punivs(/* tuple */[
                  mib,
                  oib
                ]);
            var ind_type = Inductive$ReactTemplate.type_of_inductive(global_env, pspecif);
            var ind_name = /* Name */[oib[/* mind_typename */0]];
            return Context$ReactTemplate.Rel[/* add */2](/* LocalAssum */Block.__(0, [
                          ind_name,
                          ind_type
                        ]), accu);
          }), Context$ReactTemplate.Rel[/* empty */1], mib[/* mind_packets */0]);
    var match$1 = Util$ReactTemplate.$$Array[/* fold_left */15]((function (accu, oib) {
            var arity_wo_param = Curry._1(Util$ReactTemplate.List[/* rev */4], Curry._2(Util$ReactTemplate.List[/* skipn */107], nparam, Curry._1(Util$ReactTemplate.List[/* rev */4], oib[/* mind_arity_ctxt */1])));
            var accu$1 = traverse_context(label, param_ctx, accu, arity_wo_param);
            return Util$ReactTemplate.$$Array[/* fold_left */15]((function (accu, cst_typ) {
                          var match = Term$ReactTemplate.decompose_prod_n_assum(nparam)(cst_typ);
                          var ctx = Context$ReactTemplate.Rel[/* fold_outside */10](Context$ReactTemplate.Rel[/* add */2], match[0], arities_ctx);
                          return traverse(label, ctx, accu, match[1]);
                        }), accu$1, oib[/* mind_user_lc */4]);
          }), accu, mib[/* mind_packets */0]);
    var contents = match$1[0];
    var data$1 = Util$ReactTemplate.$$Array[/* fold_left_i */38]((function (n, data, oib) {
            var ind = /* tuple */[
              mind,
              n
            ];
            var data$1 = Curry._3(Globnames$ReactTemplate.Refmap_env[/* add */3], /* IndRef */Block.__(2, [ind]), contents, data);
            return Util$ReactTemplate.$$Array[/* fold_left_i */38]((function (k, data, _) {
                          return Curry._3(Globnames$ReactTemplate.Refmap_env[/* add */3], /* ConstructRef */Block.__(3, [/* tuple */[
                                          ind,
                                          k + 1 | 0
                                        ]]), contents, data);
                        }), data$1, oib[/* mind_consnames */3]);
          }), match$1[1], mib[/* mind_packets */0]);
    match = /* tuple */[
      data$1,
      match$1[2]
    ];
  }
  return /* tuple */[
          Curry._2(Globnames$ReactTemplate.Refset_env[/* add */3], obj, param[0]),
          match[0],
          match[1]
        ];
}

function traverse_context(current, ctx, accu, ctxt) {
  return Context$ReactTemplate.Rel[/* fold_outside */10]((function (decl, param) {
                  var accu = param[1];
                  var ctx = param[0];
                  if (decl.tag) {
                    var accu$1 = traverse(current, ctx, traverse(current, ctx, accu, decl[2]), decl[1]);
                    var ctx$1 = Context$ReactTemplate.Rel[/* add */2](decl, ctx);
                    return /* tuple */[
                            ctx$1,
                            accu$1
                          ];
                  } else {
                    var accu$2 = traverse(current, ctx, accu, decl[1]);
                    var ctx$2 = Context$ReactTemplate.Rel[/* add */2](decl, ctx);
                    return /* tuple */[
                            ctx$2,
                            accu$2
                          ];
                  }
                }), ctxt, /* tuple */[
                ctx,
                accu
              ])[1];
}

function traverse$1(current, t) {
  modcache[0] = Names$ReactTemplate.MPmap[/* empty */0];
  return traverse(current, Context$ReactTemplate.Rel[/* empty */1], /* tuple */[
              Globnames$ReactTemplate.Refset_env[/* empty */0],
              Globnames$ReactTemplate.Refmap_env[/* empty */0],
              Globnames$ReactTemplate.Refmap_env[/* empty */0]
            ], t);
}

function assumptions($staropt$star, $staropt$star$1, st, gr, t) {
  var add_opaque = $staropt$star ? $staropt$star[0] : /* false */0;
  var add_transparent = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var knst = st[1];
  var match = traverse$1(label_of(gr), t);
  var ax2ty = match[2];
  var fold = function (obj, _, accu) {
    var exit = 0;
    var m;
    switch (obj.tag | 0) {
      case 0 : 
          var id = obj[0];
          var decl = Global$ReactTemplate.lookup_named(id);
          if (Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* is_local_assum */5], decl)) {
            var t = Curry._1(Context$ReactTemplate.Named[/* Declaration */0][/* get_type */2], decl);
            return Curry._3(Printer$ReactTemplate.ContextObjectMap[/* add */3], /* Variable */Block.__(0, [id]), t, accu);
          } else {
            return accu;
          }
          break;
      case 1 : 
          var kn = obj[0];
          var cb = lookup_constant(kn);
          var accu$1;
          if (cb[/* const_typing_flags */7][/* check_guarded */0]) {
            accu$1 = accu;
          } else {
            var l;
            try {
              l = Curry._2(Globnames$ReactTemplate.Refmap_env[/* find */21], obj, ax2ty);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                l = /* [] */0;
              } else {
                throw exn;
              }
            }
            accu$1 = Curry._3(Printer$ReactTemplate.ContextObjectMap[/* add */3], /* Axiom */Block.__(1, [
                    /* Guarded */Block.__(2, [kn]),
                    l
                  ]), Constr$ReactTemplate.mkProp, accu);
          }
          if (!Declareops$ReactTemplate.constant_has_body(cb) || !cb[/* const_typing_flags */7][/* check_universes */1]) {
            var t$1 = cb[/* const_type */2];
            var l$1;
            try {
              l$1 = Curry._2(Globnames$ReactTemplate.Refmap_env[/* find */21], obj, ax2ty);
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                l$1 = /* [] */0;
              } else {
                throw exn$1;
              }
            }
            return Curry._3(Printer$ReactTemplate.ContextObjectMap[/* add */3], /* Axiom */Block.__(1, [
                          /* Constant */Block.__(0, [kn]),
                          l$1
                        ]), t$1, accu$1);
          } else if (add_opaque && (Declareops$ReactTemplate.is_opaque(cb) || !Curry._2(Names$ReactTemplate.Cpred[/* mem */4], kn, knst))) {
            var t$2 = cb[/* const_type */2];
            return Curry._3(Printer$ReactTemplate.ContextObjectMap[/* add */3], /* Opaque */Block.__(2, [kn]), t$2, accu$1);
          } else if (add_transparent) {
            var t$3 = cb[/* const_type */2];
            return Curry._3(Printer$ReactTemplate.ContextObjectMap[/* add */3], /* Transparent */Block.__(3, [kn]), t$3, accu$1);
          } else {
            return accu$1;
          }
          break;
      case 2 : 
          m = obj[0][0];
          exit = 1;
          break;
      case 3 : 
          m = obj[0][0][0];
          exit = 1;
          break;
      
    }
    if (exit === 1) {
      var mind = lookup_mind(m);
      if (mind[/* mind_typing_flags */10][/* check_guarded */0]) {
        return accu;
      } else {
        var l$2;
        try {
          l$2 = Curry._2(Globnames$ReactTemplate.Refmap_env[/* find */21], obj, ax2ty);
        }
        catch (exn$2){
          if (exn$2 === Caml_builtin_exceptions.not_found) {
            l$2 = /* [] */0;
          } else {
            throw exn$2;
          }
        }
        return Curry._3(Printer$ReactTemplate.ContextObjectMap[/* add */3], /* Axiom */Block.__(1, [
                      /* Positive */Block.__(1, [m]),
                      l$2
                    ]), Constr$ReactTemplate.mkProp, accu);
      }
    }
    
  };
  return Curry._3(Globnames$ReactTemplate.Refmap_env[/* fold */10], fold, match[1], Printer$ReactTemplate.ContextObjectMap[/* empty */0]);
}

exports.traverse = traverse$1;
exports.assumptions = assumptions;
/* Pp-ReactTemplate Not a pure module */
