// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Pp$ReactTemplate = require("./pp.bs.js");
var Evd$ReactTemplate = require("./evd.bs.js");
var Lib$ReactTemplate = require("./lib.bs.js");
var Univ$ReactTemplate = require("./univ.bs.js");
var Util$ReactTemplate = require("./util.bs.js");
var Vars$ReactTemplate = require("./vars.bs.js");
var Names$ReactTemplate = require("./names.bs.js");
var Sorts$ReactTemplate = require("./sorts.bs.js");
var Constr$ReactTemplate = require("./constr.bs.js");
var Global$ReactTemplate = require("./global.bs.js");
var Option$ReactTemplate = require("./option.bs.js");
var CErrors$ReactTemplate = require("./cErrors.bs.js");
var EConstr$ReactTemplate = require("./eConstr.bs.js");
var Environ$ReactTemplate = require("./environ.bs.js");
var Nametab$ReactTemplate = require("./nametab.bs.js");
var Summary$ReactTemplate = require("./summary.bs.js");
var Termops$ReactTemplate = require("./termops.bs.js");
var Typeops$ReactTemplate = require("./typeops.bs.js");
var CWarnings$ReactTemplate = require("./cWarnings.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Globnames$ReactTemplate = require("./globnames.bs.js");
var Inductive$ReactTemplate = require("./inductive.bs.js");
var Libobject$ReactTemplate = require("./libobject.bs.js");
var Mod_subst$ReactTemplate = require("./mod_subst.bs.js");
var Reductionops$ReactTemplate = require("./reductionops.bs.js");

var structure_table = Summary$ReactTemplate.ref(/* None */0, "record-structs", Names$ReactTemplate.Indmap[/* empty */0]);

var projection_table = Summary$ReactTemplate.ref(/* None */0, "record-projs", Names$ReactTemplate.Cmap[/* empty */0]);

function load_structure(_, param) {
  var match = param[1];
  var projs = match[3];
  var ind = match[0];
  var n = Global$ReactTemplate.lookup_inductive(ind)[0][/* mind_nparams */5];
  var struc_000 = /* s_CONST */match[1];
  var struc_002 = /* s_PROJKIND */match[2];
  var struc = /* record */[
    struc_000,
    /* s_EXPECTEDPARAM */n,
    struc_002,
    /* s_PROJ */projs
  ];
  structure_table[0] = Curry._3(Names$ReactTemplate.Indmap[/* add */3], ind, struc, structure_table[0]);
  projection_table[0] = Curry._3(Util$ReactTemplate.List[/* fold_right */14], (function (param, param$1) {
          return Option$ReactTemplate.fold_right((function (proj) {
                        return Curry._2(Names$ReactTemplate.Cmap[/* add */3], proj, struc);
                      }), param, param$1);
        }), projs, projection_table[0]);
  return /* () */0;
}

function cache_structure(o) {
  return load_structure(1, o);
}

function subst_structure(param) {
  var obj = param[1];
  var projs = obj[3];
  var id = obj[1];
  var match = obj[0];
  var kn = match[0];
  var subst = param[0];
  var kn$prime = Mod_subst$ReactTemplate.subst_mind(subst, kn);
  var projs$prime = Curry._2(Util$ReactTemplate.List[/* smartmap */65], (function (param) {
          return Option$ReactTemplate.smartmap((function (kn) {
                        return Mod_subst$ReactTemplate.subst_con_kn(subst, kn)[0];
                      }), param);
        }), projs);
  var id$prime = Globnames$ReactTemplate.subst_constructor(subst, id)[0];
  if (projs$prime === projs && kn$prime === kn && id$prime === id) {
    return obj;
  } else {
    return /* tuple */[
            /* tuple */[
              kn$prime,
              match[1]
            ],
            id$prime,
            obj[2],
            projs$prime
          ];
  }
}

function discharge_constructor(param) {
  return /* tuple */[
          Lib$ReactTemplate.discharge_inductive(param[0]),
          param[1]
        ];
}

function discharge_structure(param) {
  var match = param[1];
  return /* Some */[/* tuple */[
            Lib$ReactTemplate.discharge_inductive(match[0]),
            discharge_constructor(match[1]),
            match[2],
            Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                    return Option$ReactTemplate.map(Lib$ReactTemplate.discharge_con, param);
                  }), match[3])
          ]];
}

var init = Libobject$ReactTemplate.default_object("STRUCTURE");

var inStruc = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init[/* object_name */0],
      /* cache_function */cache_structure,
      /* load_function */load_structure,
      /* open_function */init[/* open_function */3],
      /* classify_function */(function (x) {
          return /* Substitute */Block.__(0, [x]);
        }),
      /* subst_function */subst_structure,
      /* discharge_function */discharge_structure,
      /* rebuild_function */init[/* rebuild_function */7]
    ]);

function declare_structure(param) {
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inStruc, /* tuple */[
                  param[0],
                  param[1],
                  param[2],
                  param[3]
                ]));
}

function lookup_structure(indsp) {
  return Curry._2(Names$ReactTemplate.Indmap[/* find */21], indsp, structure_table[0]);
}

function lookup_projections(indsp) {
  return lookup_structure(indsp)[/* s_PROJ */3];
}

function find_projection_nparams(param) {
  if (param.tag === 1) {
    return Curry._2(Names$ReactTemplate.Cmap[/* find */21], param[0], projection_table[0])[/* s_EXPECTEDPARAM */1];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_projection(param) {
  if (param.tag === 1) {
    return Curry._2(Names$ReactTemplate.Cmap[/* find */21], param[0], projection_table[0]);
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function eq_cs_pattern(p1, p2) {
  if (typeof p1 === "number") {
    if (p1) {
      if (typeof p2 === "number" && p2 !== 0) {
        return /* true */1;
      } else {
        return /* false */0;
      }
    } else if (typeof p2 === "number" && p2 === 0) {
      return /* true */1;
    } else {
      return /* false */0;
    }
  } else if (p1.tag) {
    if (typeof p2 === "number" || p2.tag !== 1) {
      return /* false */0;
    } else {
      return Sorts$ReactTemplate.family_equal(p1[0], p2[0]);
    }
  } else if (typeof p2 === "number" || p2.tag) {
    return /* false */0;
  } else {
    return Globnames$ReactTemplate.eq_gr(p1[0], p2[0]);
  }
}

function assoc_pat(a, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      var match$1 = match[0];
      if (eq_cs_pattern(match$1[0], a)) {
        return /* tuple */[
                match$1[1],
                match[1]
              ];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

var object_table = Summary$ReactTemplate.ref(/* None */0, "record-canonical-structs", Globnames$ReactTemplate.Refmap[/* empty */0]);

function canonical_projections() {
  return Curry._3(Globnames$ReactTemplate.Refmap[/* fold */10], (function (x) {
                return Curry._1(Util$ReactTemplate.List[/* fold_right */14], (function (param, acc) {
                              return /* :: */[
                                      /* tuple */[
                                        /* tuple */[
                                          x,
                                          param[0][0]
                                        ],
                                        param[1]
                                      ],
                                      acc
                                    ];
                            }));
              }), object_table[0], /* [] */0);
}

function keep_true_projections(projs, kinds) {
  var filter = function (param) {
    if (param[1][1]) {
      return /* Some */[param[0]];
    } else {
      return /* None */0;
    }
  };
  return Curry._2(Util$ReactTemplate.List[/* map_filter */62], filter, Curry._2(Util$ReactTemplate.List[/* combine */37], projs, kinds));
}

function cs_pattern_of_constr(env, t) {
  var match = Constr$ReactTemplate.kind(t);
  var exit = 0;
  switch (match.tag | 0) {
    case 0 : 
        return /* tuple */[
                /* Default_cs */1,
                /* Some */[match[0]],
                /* [] */0
              ];
    case 4 : 
        return /* tuple */[
                /* Sort_cs */Block.__(1, [Sorts$ReactTemplate.family(match[0])]),
                /* None */0,
                /* [] */0
              ];
    case 6 : 
        var b = match[2];
        if (Vars$ReactTemplate.noccurn(1, b)) {
          return /* tuple */[
                  /* Prod_cs */0,
                  /* None */0,
                  /* :: */[
                    match[1],
                    /* :: */[
                      Vars$ReactTemplate.lift(-1)(b),
                      /* [] */0
                    ]
                  ]
                ];
        } else {
          exit = 1;
        }
        break;
    case 9 : 
        try {
          return /* tuple */[
                  /* Const_cs */Block.__(0, [Globnames$ReactTemplate.global_of_constr(match[0])]),
                  /* None */0,
                  Util$ReactTemplate.$$Array[/* to_list */9](match[1])
                ];
        }
        catch (raw_e){
          var e = Js_exn.internalToOCamlException(raw_e);
          if (CErrors$ReactTemplate.noncritical(e)) {
            throw Caml_builtin_exceptions.not_found;
          } else {
            throw e;
          }
        }
        break;
    case 16 : 
        var c = match[1];
        var match$1 = Curry._2(Typeops$ReactTemplate.infer, env, c);
        var match$2 = Inductive$ReactTemplate.find_rectype(env, match$1[/* uj_type */1]);
        return /* tuple */[
                /* Const_cs */Block.__(0, [/* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](match[0])])]),
                /* None */0,
                Util$ReactTemplate.$at(match$2[1], /* :: */[
                      c,
                      /* [] */0
                    ])
              ];
    default:
      exit = 1;
  }
  if (exit === 1) {
    try {
      return /* tuple */[
              /* Const_cs */Block.__(0, [Globnames$ReactTemplate.global_of_constr(t)]),
              /* None */0,
              /* [] */0
            ];
    }
    catch (raw_e$1){
      var e$1 = Js_exn.internalToOCamlException(raw_e$1);
      if (CErrors$ReactTemplate.noncritical(e$1)) {
        throw Caml_builtin_exceptions.not_found;
      } else {
        throw e$1;
      }
    }
  }
  
}

var warn_projection_no_head_constant = CWarnings$ReactTemplate.create("projection-no-head-constant", "typechecker", /* None */0, (function (param) {
        var env = Termops$ReactTemplate.push_rels_assum(param[0])(param[1]);
        var con_pp = Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* ConstRef */Block.__(1, [param[3]]));
        var proji_sp_pp = Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], /* ConstRef */Block.__(1, [param[4]]));
        var term_pp = Termops$ReactTemplate.print_constr_env(env, Evd$ReactTemplate.empty, EConstr$ReactTemplate.of_constr(param[2]));
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Projection value has no head constant: "), term_pp), Pp$ReactTemplate.strbrk(" in canonical instance ")), con_pp), Pp$ReactTemplate.str(" of ")), proji_sp_pp), Pp$ReactTemplate.strbrk(", ignoring it."));
      }));

function compute_canonical_projections(warn, param) {
  var con = param[0];
  var env = Global$ReactTemplate.env(/* () */0);
  var ctx = Environ$ReactTemplate.constant_context(env, con);
  var u = Univ$ReactTemplate.make_abstract_instance(ctx);
  var v = Constr$ReactTemplate.mkConstU(/* tuple */[
        con,
        u
      ]);
  var c = Environ$ReactTemplate.constant_value_in(env, /* tuple */[
        con,
        u
      ]);
  var match = Reductionops$ReactTemplate.splay_lam(env, Evd$ReactTemplate.empty)(EConstr$ReactTemplate.of_constr(c));
  var partial_arg = EConstr$ReactTemplate.Unsafe[/* to_constr */0];
  var sign = Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
          return Util$ReactTemplate.on_snd(partial_arg, param);
        }), match[0]);
  var t = EConstr$ReactTemplate.Unsafe[/* to_constr */0](match[1]);
  var lt = Curry._2(Util$ReactTemplate.List[/* rev_map */12], (function (prim) {
          return prim[1];
        }), sign);
  var args = Constr$ReactTemplate.decompose_app(t)[1];
  var match$1 = lookup_structure(param[1]);
  var match$2 = Curry._2(Util$ReactTemplate.List[/* chop */99], match$1[/* s_EXPECTEDPARAM */1], args);
  var params = match$2[0];
  var lpj = keep_true_projections(match$1[/* s_PROJ */3], match$1[/* s_PROJKIND */2]);
  var lps = Curry._2(Util$ReactTemplate.List[/* combine */37], lpj, match$2[1]);
  var nenv = Termops$ReactTemplate.push_rels_assum(sign)(env);
  var comp = Curry._3(Util$ReactTemplate.List[/* fold_left */13], (function (l, param) {
          var t = param[1];
          var spopt = param[0];
          if (spopt) {
            var proji_sp = spopt[0];
            try {
              var match = cs_pattern_of_constr(nenv, t);
              return /* :: */[
                      /* tuple */[
                        /* ConstRef */Block.__(1, [proji_sp]),
                        match[0],
                        t,
                        match[1],
                        match[2]
                      ],
                      l
                    ];
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                if (warn) {
                  Curry._2(warn_projection_no_head_constant, /* None */0, /* tuple */[
                        sign,
                        env,
                        t,
                        con,
                        proji_sp
                      ]);
                }
                return l;
              } else {
                throw exn;
              }
            }
          } else {
            return l;
          }
        }), /* [] */0, lps);
  return Curry._2(Util$ReactTemplate.List[/* map */10], (function (param) {
                return /* tuple */[
                        /* tuple */[
                          param[0],
                          /* tuple */[
                            param[1],
                            param[2]
                          ]
                        ],
                        /* record */[
                          /* o_DEF */v,
                          /* o_CTX */ctx,
                          /* o_INJ */param[3],
                          /* o_TABS */lt,
                          /* o_TPARAMS */params,
                          /* o_NPARAMS */Curry._1(Util$ReactTemplate.List[/* length */0], params),
                          /* o_TCOMPS */param[4]
                        ]
                      ];
              }), comp);
}

function pr_cs_pattern(param) {
  if (typeof param === "number") {
    if (param) {
      return Pp$ReactTemplate.str("_");
    } else {
      return Pp$ReactTemplate.str("_ -> _");
    }
  } else if (param.tag) {
    return Termops$ReactTemplate.pr_sort_family(param[0]);
  } else {
    return Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], param[0]);
  }
}

var warn_redundant_canonical_projection = CWarnings$ReactTemplate.create("redundant-canonical-projection", "typechecker", /* None */0, (function (param) {
        return Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.strbrk("Ignoring canonical projection to "), param[0]), Pp$ReactTemplate.strbrk(" by ")), param[1]), Pp$ReactTemplate.strbrk(" in ")), param[2]), Pp$ReactTemplate.strbrk(": redundant with ")), param[3]);
      }));

function add_canonical_structure(warn, o) {
  var lo = compute_canonical_projections(warn, o);
  return Curry._2(Util$ReactTemplate.List[/* iter */9], (function (param) {
                var s = param[1];
                var match = param[0];
                var pat = match[1];
                var cs_pat = pat[0];
                var proj = match[0];
                var l;
                try {
                  l = Curry._2(Globnames$ReactTemplate.Refmap[/* find */21], proj, object_table[0]);
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    l = /* [] */0;
                  } else {
                    throw exn;
                  }
                }
                var ocs;
                try {
                  ocs = /* Some */[assoc_pat(cs_pat, l)];
                }
                catch (exn$1){
                  if (exn$1 === Caml_builtin_exceptions.not_found) {
                    ocs = /* None */0;
                  } else {
                    throw exn$1;
                  }
                }
                if (ocs) {
                  var old_can_s = Termops$ReactTemplate.print_constr(EConstr$ReactTemplate.of_constr(ocs[0][1][/* o_DEF */0]));
                  var new_can_s = Termops$ReactTemplate.print_constr(EConstr$ReactTemplate.of_constr(s[/* o_DEF */0]));
                  var prj = Nametab$ReactTemplate.pr_global_env(Names$ReactTemplate.Id[/* Set */9][/* empty */0], proj);
                  var hd_val = pr_cs_pattern(cs_pat);
                  if (warn) {
                    return Curry._2(warn_redundant_canonical_projection, /* None */0, /* tuple */[
                                hd_val,
                                prj,
                                new_can_s,
                                old_can_s
                              ]);
                  } else {
                    return 0;
                  }
                } else {
                  object_table[0] = Curry._3(Globnames$ReactTemplate.Refmap[/* add */3], proj, /* :: */[
                        /* tuple */[
                          pat,
                          s
                        ],
                        l
                      ], object_table[0]);
                  return /* () */0;
                }
              }), lo);
}

function open_canonical_structure(i, param) {
  if (i === 1) {
    return add_canonical_structure(/* false */0, param[1]);
  } else {
    return 0;
  }
}

function cache_canonical_structure(param) {
  return add_canonical_structure(/* true */1, param[1]);
}

function subst_canonical_structure(param) {
  var obj = param[1];
  var ind = obj[1];
  var cst = obj[0];
  var subst = param[0];
  var cst$prime = Mod_subst$ReactTemplate.subst_constant(subst, cst);
  var ind$prime = Mod_subst$ReactTemplate.subst_ind(subst, ind);
  if (cst$prime === cst && ind$prime === ind) {
    return obj;
  } else {
    return /* tuple */[
            cst$prime,
            ind$prime
          ];
  }
}

function discharge_canonical_structure(param) {
  var match = param[1];
  return /* Some */[/* tuple */[
            Lib$ReactTemplate.discharge_con(match[0]),
            Lib$ReactTemplate.discharge_inductive(match[1])
          ]];
}

var init$1 = Libobject$ReactTemplate.default_object("CANONICAL-STRUCTURE");

var inCanonStruc = Libobject$ReactTemplate.declare_object(/* record */[
      /* object_name */init$1[/* object_name */0],
      /* cache_function */cache_canonical_structure,
      /* load_function */init$1[/* load_function */2],
      /* open_function */open_canonical_structure,
      /* classify_function */(function (x) {
          return /* Substitute */Block.__(0, [x]);
        }),
      /* subst_function */subst_canonical_structure,
      /* discharge_function */discharge_canonical_structure,
      /* rebuild_function */init$1[/* rebuild_function */7]
    ]);

function error_not_structure(ref, description) {
  return CErrors$ReactTemplate.user_err(/* None */0, /* Some */["object_declare"], Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.str("Could not declare a canonical structure "), Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Pp$ReactTemplate.$plus$plus(Names$ReactTemplate.Id[/* print */8](Nametab$ReactTemplate.basename_of_global(ref)), Pp$ReactTemplate.str(".")), Pp$ReactTemplate.spc(/* () */0)), Pp$ReactTemplate.str(description))));
}

function check_and_decompose_canonical_structure(ref) {
  var sp;
  sp = ref.tag === 1 ? ref[0] : error_not_structure(ref, "Expected an instance of a record or structure.");
  var env = Global$ReactTemplate.env(/* () */0);
  var u = Univ$ReactTemplate.make_abstract_instance(Environ$ReactTemplate.constant_context(env, sp));
  var match = Environ$ReactTemplate.constant_opt_value_in(env, /* tuple */[
        sp,
        u
      ]);
  var vc = match ? match[0] : error_not_structure(ref, "Could not find its value in the global environment.");
  var body = Reductionops$ReactTemplate.splay_lam(Global$ReactTemplate.env(/* () */0), Evd$ReactTemplate.empty)(EConstr$ReactTemplate.of_constr(vc))[1];
  var body$1 = EConstr$ReactTemplate.Unsafe[/* to_constr */0](body);
  var match$1 = Constr$ReactTemplate.kind(body$1);
  var match$2;
  match$2 = match$1.tag === 9 ? /* tuple */[
      match$1[0],
      match$1[1]
    ] : error_not_structure(ref, "Expected a record or structure constructor applied to arguments.");
  var match$3 = Constr$ReactTemplate.kind(match$2[0]);
  var indsp;
  if (match$3.tag === 12) {
    var match$4 = match$3[0][0];
    indsp = match$4[1] !== 1 ? error_not_structure(ref, "Expected an instance of a record or structure.") : match$4[0];
  } else {
    indsp = error_not_structure(ref, "Expected an instance of a record or structure.");
  }
  var s;
  try {
    s = lookup_structure(indsp);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      s = error_not_structure(ref, "Could not find the record or structure " + Names$ReactTemplate.MutInd[/* to_string */14](indsp[0]));
    } else {
      throw exn;
    }
  }
  var ntrue_projs = Curry._2(Util$ReactTemplate.List[/* count */76], (function (prim) {
          return prim[1];
        }), s[/* s_PROJKIND */2]);
  if ((s[/* s_EXPECTEDPARAM */1] + ntrue_projs | 0) > match$2[1].length) {
    error_not_structure(ref, "Got too few arguments to the record or structure constructor.");
  }
  return /* tuple */[
          sp,
          indsp
        ];
}

function declare_canonical_structure(ref) {
  var x = check_and_decompose_canonical_structure(ref);
  return Lib$ReactTemplate.add_anonymous_leaf(/* None */0, Curry._1(inCanonStruc, x));
}

function lookup_canonical_conversion(param) {
  return assoc_pat(param[1], Curry._2(Globnames$ReactTemplate.Refmap[/* find */21], param[0], object_table[0]));
}

function decompose_projection(sigma, c, args) {
  var match = EConstr$ReactTemplate.kind(sigma, c);
  switch (match.tag | 0) {
    case 10 : 
        var c$1 = match[0][0];
        var n = find_projection_nparams(/* ConstRef */Block.__(1, [c$1]));
        Curry._2(Globnames$ReactTemplate.Refmap[/* find */21], /* ConstRef */Block.__(1, [c$1]), object_table[0]);
        return Reductionops$ReactTemplate.Stack[/* nth */19](args, n);
    case 16 : 
        Curry._2(Globnames$ReactTemplate.Refmap[/* find */21], /* ConstRef */Block.__(1, [Names$ReactTemplate.Projection[/* constant */2](match[0])]), object_table[0]);
        return match[1];
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function is_open_canonical_projection(env, sigma, param) {
  try {
    var arg = decompose_projection(sigma, param[0], param[1]);
    try {
      var arg$1 = Reductionops$ReactTemplate.whd_all(env)(sigma, arg);
      var match = EConstr$ReactTemplate.kind(sigma, arg$1);
      var hd;
      hd = match.tag === 9 ? match[0] : arg$1;
      return 1 - EConstr$ReactTemplate.isConstruct(sigma, hd);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  }
  catch (exn$1){
    if (exn$1 === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn$1;
    }
  }
}

exports.declare_structure = declare_structure;
exports.lookup_structure = lookup_structure;
exports.lookup_projections = lookup_projections;
exports.find_projection_nparams = find_projection_nparams;
exports.find_projection = find_projection;
exports.cs_pattern_of_constr = cs_pattern_of_constr;
exports.pr_cs_pattern = pr_cs_pattern;
exports.lookup_canonical_conversion = lookup_canonical_conversion;
exports.declare_canonical_structure = declare_canonical_structure;
exports.is_open_canonical_projection = is_open_canonical_projection;
exports.canonical_projections = canonical_projections;
/* structure_table Not a pure module */
